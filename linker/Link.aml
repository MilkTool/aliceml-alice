(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure TextIO             from "../lib/system/TextIO"
import structure Signature          from "../lib/system/Signature"
import structure FromEqHashKey      from "../lib/utility/HASH_KEY-sig"
import structure MkHashImpMap       from "../lib/utility/MkHashImpMap"
import structure MkDepthFirstSearch from "../lib/utility/MkDepthFirstSearch"
import structure Url                from "../lib/utility/Url"
import structure Label              from "../lib/rtt/Label"
import signature LINK               from "LINK-sig"
import structure MyComponent        from "MyComponent"

structure Link :> LINK =
    struct
	datatype boundary =
	    INCLUDE of string
	  | EXCLUDE of string

	exception Empty
	exception Mismatch of Url.t * Url.t
	exception Conflict of Url.t
	exception Cyclic of Url.t list

	structure UrlHashKey = FromEqHashKey(Url)
	structure UrlMap = MkHashImpMap(UrlHashKey)

	fun signMatches (SOME s1, SOME s2) = Signature.matches (s1, s2)
	  | signMatches (_, _) = true

	fun signIntersect (sign1, sign2) = SOME sign1   (*--** *)

	fun isExcluded (url, boundary) =
	    isExcluded' (Url.toString url, boundary, 0, Vector.length boundary)
	and isExcluded' (s, boundary, i, n) =
	    if i = n then true
	    else
		case Vector.sub (boundary, i) of
		    INCLUDE s' => if String.isPrefix s' s then false
				  else isExcluded' (s, boundary, i + 1, n)
		  | EXCLUDE s' => if String.isPrefix s' s then true
				  else isExcluded' (s, boundary, i + 1, n)

	fun collect boundary root =
	    let
		val componentMap = UrlMap.new ()
		val includeMap = UrlMap.new ()
		val excludeMap = UrlMap.new ()

		fun collect' (url, parent, expectedSign) =
		    if UrlMap.member (componentMap, url) then
			let
			    val component =
				UrlMap.lookupExistent (componentMap, url)
			    val actualSign = MyComponent.sign component
			in
			    if signMatches (actualSign, expectedSign) then ()
			    else raise Mismatch (url, parent)
			end
		    else if UrlMap.member (excludeMap, url) then
			let
			    val sign' = UrlMap.lookupExistent (excludeMap, url)
			in
			    case signIntersect (expectedSign, sign') of
				SOME sign'' =>
				    UrlMap.insert (excludeMap, url, sign'')
			      | NONE => raise Conflict url
			end
		    else if isExcluded (url, boundary) then
			UrlMap.insert (excludeMap, url, expectedSign)
		    else
			let
			    val component = MyComponent.load url
			    val actualSign = MyComponent.sign component
			    val _ = if signMatches (actualSign, expectedSign)
				    then () else raise Mismatch (url, parent)
			    val component' =
				if url = root then component
				else MyComponent.stripImportSigns component
			    val _ =
				UrlMap.insert (componentMap, url, component')
			    val resolve = Url.resolve url
			    val importUrls =
				Vector.map
				(fn (label, s, sign) =>
				    let
					val url' = resolve (Url.fromString s)
				    in
					collect' (url', url, sign); url'
				    end) (MyComponent.imports component)
			in
			    UrlMap.insert (includeMap, url, importUrls)
			end
	    in
		collect' (root, Url.empty, NONE);
		if UrlMap.isEmpty componentMap then raise Empty else ();
		{componentMap, includeMap, excludeMap}
	    end

	structure DepthFirstSearch =
	    MkDepthFirstSearch(structure Key = UrlHashKey
			       structure Map = UrlMap)

	fun sort (includeMap, excludeMap) =
	    let
		val graph = UrlMap.new ()
	    in
		UrlMap.appi (fn (url, urls) =>
				UrlMap.insert (graph, url, Vector.toList urls))
			    includeMap;
		UrlMap.appi (fn (url, _) => UrlMap.insert (graph, url, nil))
			    excludeMap;
		List.map (fn urls =>
			     case urls of
				 [url] => url
			       | urls => raise Cyclic urls)
			 (DepthFirstSearch.search graph)
	    end

	fun rewrite rewrites s =
	    rewrite' (s, rewrites, 0, Vector.length rewrites)
	and rewrite' (s, rewrites, i, n) =
	    if i = n then s
	    else
		let
		    val (fro, to) = Vector.sub (rewrites, i)
		in
		    if String.isPrefix fro s then
			to ^ String.extract (s, String.size fro, NONE)
		    else rewrite' (s, rewrites, i + 1, n)
		end

	fun build (root, componentMap, includeMap, excludeMap, rewrite) =
	    let
		fun getComponent url =
		    UrlMap.lookupExistent (componentMap, url)
		val excludes =
		    Vector.fromList (UrlMap.foldi (fn (url, _, rest) =>
						      url::rest)
						  nil excludeMap)
		val includes =
		    Vector.fromList (UrlMap.foldi (fn (url, _, rest) =>
						      url::rest)
						  nil excludeMap)
		val urlToIndexMap = UrlMap.new ()
		val _ =
		    Vector.appi (fn (i, url) =>
				    UrlMap.insert (urlToIndexMap, url,
						   (true, i)))
				(includes, 0, NONE)
		val _ =
		    Vector.appi (fn (i, url) =>
				    UrlMap.insert (urlToIndexMap, url,
						   (false, i)))
				(excludes, 0, NONE)
		val imports =
		    Vector.mapi (fn (i, url) =>
				    (Label.fromInt i,
				     rewrite (Url.toString url),
				     UrlMap.lookupExistent (excludeMap, url)))
				(excludes, 0, NONE)
		val includeTable =
		    Vector.map
		    (fn url =>
			let
			    val component = getComponent url
			    val importUrls =
				UrlMap.lookupExistent (includeMap, url)
			    val imports = MyComponent.imports component
			    val importSpec =
				Vector.mapi
				(fn (i, (label, _, _)) =>
				    let
					val url = Vector.sub (importUrls, i)
					val (included, index) =
					    UrlMap.lookupExistent
						(urlToIndexMap, url)
				    in
					(label, included, index)
				    end) (imports, 0, NONE)
			in
			    (importSpec, MyComponent.body (getComponent url))
			end) includes
		val (_, rootIndex) =
		    UrlMap.lookupExistent (urlToIndexMap, root)
		fun body imports =
		    let
			val strs = Vector.tabulate (Vector.length includeTable,
						    fn _ => Hole.hole ())
		    in
			Vector.appi
			(fn (i, (importSpec, body)) =>
			    let
				val actuals =
				    Vector.map
				    (fn (label, included, index) =>
					(label,
					 if included then
					     Vector.sub (strs, index)
					 else
(*--** this gives a type error:		     #2 (Vector.sub (imports, index))*)
(*--** as does this:			     case Vector.sub (imports, index)
					       of {2 = str, ...} => str *)
					     case Vector.sub (imports, index)
					       of (_, str) => str
				    )) importSpec
				val str = lazy body actuals
			    in
				Hole.fill (Vector.sub (strs, i), str)
			    end) (includeTable, 0, NONE);
			Vector.sub (strs, rootIndex)
		    end
		val sign = MyComponent.sign (getComponent root)
	    in
		MyComponent.new {imports, body, sign}
	    end

	fun link {root, boundary, rewrite = rewrites} =
	    let
		val {componentMap, includeMap, excludeMap} =
		    collect boundary root
		val order = sort (includeMap, excludeMap)
		val includes =
		    List.filter (fn url =>
				    url <> root andalso
				    UrlMap.member (includeMap, url)) order @
		    [root]
		val imports =
		    List.filter (fn url => UrlMap.member (excludeMap, url))
				order
	    in
		TextIO.print ("Include:\n");
		List.app (fn url =>
			     TextIO.print ("   " ^ Url.toString url ^ "\n"))
			 includes;
		TextIO.print ("Import:\n");
		List.app (fn url =>
			     TextIO.print ("   " ^ Url.toString url ^ "\n"))
			 imports;
		build (root, componentMap, includeMap, excludeMap,
		       rewrite rewrites)
	    end
    end
