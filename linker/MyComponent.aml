(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Inf             from "../lib/rtt/Inf"
import structure IO              from "../lib/system/IO"
import structure OS              from "../lib/system/OS"
import structure Reflect         from "../lib/system/Reflect"
import structure Url             from "../lib/system/Url"
import structure Resolver        from "../lib/system/Resolver"
import structure UnsafeComponent from "../lib/system/UnsafeComponent"
import structure Component       from "../lib/system/Component"
import signature MY_COMPONENT    from "MY_COMPONENT-sig"

structure MyComponent :> MY_COMPONENT =
struct
    nonfix mod
    type inf = Inf.t option
    type mod = Reflect.module

    datatype component =
	UNEVALUATED of { imports: (string * inf) vector,
			 body:    mod vector -> mod,
			 inf:     inf }
      | EVALUATED of { inf: inf, mod: mod }
    type t = component

    fun load url =
	let
	    val name = Url.toStringRaw url   (*--** use getLocalPath instead *)
	in
	    case Resolver.localize Component.defaultResolver name of
		SOME (Resolver.FILE name') =>
		    (SOME (UnsafeComponent.load name')
		     handle Component.Corrupt =>
			 (UnsafeComponent.linkNative name'; NONE)
			 handle cause =>
			     raise IO.Io {name, function = "load", cause})
	      | SOME (Resolver.STRING string) =>
		    (SOME (UnsafeComponent.unpack_ string)
		     handle cause =>
			 raise IO.Io {name, function = "load", cause})
	      | NONE =>
		    raise IO.Io {name, function = "load",
				 cause = Component.NotFound}
	end

    fun save (name, component) =
	UnsafeComponent.save (name, component)
	handle cause => raise IO.Io {name, function = "save", cause}

    fun imports (UNEVALUATED {imports, ...}) = imports
      | imports (EVALUATED {...}) = #[]

    fun body (UNEVALUATED {body, ...}) = body
      | body (EVALUATED {mod, ...}) = fn #[] => mod

    fun inf (UNEVALUATED {inf, ...}) = inf
      | inf (EVALUATED {inf, ...}) = inf

    fun new {imports, body, inf} = UNEVALUATED {imports, body, inf}

    fun stripImportInfs (UNEVALUATED {imports, body, inf}) =
	let
	    val imports = Vector.map (fn (s, _) => (s, NONE)) imports
	in
	    UNEVALUATED {imports, body, inf}
	end
      | stripImportInfs (component as EVALUATED _) = component
end
