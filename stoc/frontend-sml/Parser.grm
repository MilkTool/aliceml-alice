(*										*)
(* Standard ML syntactical analysis						*)
(*										*)
(* Definition, sections 2, 3, and 8, Appendix A and B				*)
(*										*)
(* Extensions:									*)
(*   - vector expressions and patterns:						*)
(*	  atexp ::= #[ exp_1 , ... , exp_n ] 	(n>=0)				*)
(*	  atpat ::= #[ pat_1 , ... , pat_n ]	(n>=0)				*)
(*   - punning in record expressions (derived form):				*)
(*	  exprow ::= vid <: ty> <, exprow>					*)
(*   - more relaxed constructor pattern syntax:					*)
(*	  pat ::= pat atpat			(R)				*)
(*   - generalized layered patterns:						*)
(*	  pat ::= pat as pat			(R)				*)
(*   - alternative and guarded patterns:					*)
(*	  atpat ::= ( pat_1 | ... | pat_n )	(n>=2)				*)
(*	  pat   ::= pat when atexp		(L)				*)
(*   - where for structures:							*)
(*	  sigexp ::= sigexp where longstrid_1 = longstrid_2			*)
(*   - fun keyword in signatures (derived form):				*)
(*	  spec ::= fun valdesc							*)
(*   - withtype in signatures (derived form):					*)
(*	  spec ::= datatype datdesc <withtype syndesc>				*)
(*   - fixity directives in signatures:						*)
(*	  spec ::= infix <d> vid_1 ... vid_n	(n>=1)				*)
(*		   infixr <d> vid_1 ... vid_n	(n>=1)				*)
(*		   nonfix vid_1 ... vid_n	(n>=1)				*)
(*										*)
(* Notes:									*)
(*   - Two phrases named Fmatch and Fmrule have been added to factorize		*)
(*     Fvalbind.								*)
(*   - A phrase named SynDesc has been added to factorize type synonym		*)
(*     specifications. Similarly, a phrase named TyReaDesc has been added to	*)
(*     factorize type realisation signature expressions.			*)
(*   - Infix expressions [Definition, section 2.6] are resolved during		*)
(*     elaboration because we allow fixity specifications in signatures that	*)
(*     come into effect by an open declaration. Infix status is completely	*)
(*     ignored here.								*)
(*   - Syntactic restrictions [Definition, sections 2.9 and 3.5] are checked	*)
(*     during elaboration, as well as the Fvalbind derived form.		*)
(*   - The Definition is not clear about whether `=' should also be legal as	*)
(*     a tycon. Since this would result in massive conflicts, and a type named	*)
(*     `=' could only be used legally if an implementation would be mad enough	*)
(*     to predefine it anyway, we simply disallow it.				*)
(*   - Datatype replication requires rules for datatype to be duplicated to	*)
(*     avoid conflicts on empty tyvarseqs.					*)
(*   - The messy `sigexp where type ... and type ...' syntax requires some	*)
(*     really ugly transformations (in absence of a lookahead of 2), watch out	*)
(*     for non-terminals of the form xxx__AND_yyybind_opt.			*)
(*   - Programs consist of only a single topdec, because parsing has to stop	*)
(*     after seeing the first toplevel semicolon.				*)
(*   - ML-Yacc does not seem to like comments that stretch over several		*)
(*     lines... Similarly, comments in semantic actions make it puke...		*)
(*										*)



    (* Import *)

    open BasicObjects_Core
    open BasicObjects_Module

    open Grammar_Core
    open Grammar_Module
    open Grammar_Program

    open DerivedForms_Core
    open DerivedForms_Module
    open DerivedForms_Program


    (* Helper to build position fields *)

    fun I(left, right) = if right = 0 then (left, left) else (left, right)


%%


%header	(functor LrVals(structure Token:  TOKEN
			structure Error:  ERROR
				  where type position = Source.position

			structure Grammar_Core:    GRAMMAR_CORE
				  where type Info = Error.position
			structure Grammar_Module:  GRAMMAR_MODULE
				  where Core      = Grammar_Core
				  where type Info = Error.position
			structure Grammar_Program: GRAMMAR_PROGRAM
				  where Module    = Grammar_Module
				  where type Info = Error.position

			structure DerivedForms_Core:    DERIVEDFORMS_CORE
				  where Grammar = Grammar_Core
			structure DerivedForms_Module:  DERIVEDFORMS_MODULE
				  where Grammar = Grammar_Module
			structure DerivedForms_Program: DERIVEDFORMS_PROGRAM
				  where Grammar = Grammar_Program
		       )
	)


%name Parser

%pos  Source.pos

%verbose



%term	(* End of file *)
	  EOF

	(* Reserved words for the core language *)
	| ABSTYPE | AND | ANDALSO | AS | CASE | DO | DATATYPE | ELSE
	| END | EXCEPTION | FN | FUN | HANDLE | IF | IN | INFIX
	| INFIXR | LET | LOCAL | NONFIX | OF | OP | OPEN | ORELSE
	| RAISE | REC | THEN | TYPE | VAL | WITH | WITHTYPE | WHILE
	| LPAR | RPAR | LBRACK | RBRACK | LBRACE | RBRACE | COMMA | COLON
	| SEMICOLON | DOTS | UNDERBAR | BAR | EQUALS | DARROW | ARROW | HASH
	| WHEN | DOT | HASHBRACK

	(* Additional reserved words for the modules language *)
	| EQTYPE | FUNCTOR | INCLUDE | SHARING | SIG
	| SIGNATURE | STRUCT | STRUCTURE | WHERE | COLONGREATER

	(* Special constants *)
	| ZERO | DIGIT of int | NUMERIC of int | INT of int | WORD of word
	| REAL of real | STRING of string | CHAR of char

	(* Identifiers *)
	| ALPHA of string | SYMBOL of string | STAR
	| TYVAR of string | ETYVAR of string

%keyword ABSTYPE AND ANDALSO AS CASE DO DATATYPE ELSE
	 END EXCEPTION FN FUN HANDLE IF IN INFIX
	 INFIXR LET LOCAL NONFIX OF OP OPEN ORELSE
	 RAISE REC THEN TYPE VAL WITH WITHTYPE WHILE
	 EQTYPE FUNCTOR INCLUDE SHARING SIG
	 SIGNATURE STRUCT STRUCTURE WHERE

%eop     EOF SEMICOLON
%noshift EOF


%left  SHARING
%left  SEMICOLON
%right VAL FUN TYPE EQTYPE DATATYPE ABSTYPE EXCEPTION
       STRUCTURE SIGNATURE FUNCTOR
%right LOCAL OPEN INFIX INFIXR NONFIX INCLUDE
%right AND
%left  DARROW		(* L/R is arbitrary *)
%left  BAR		(* L/R is arbitrary *)
%left  DO		(* L/R is arbitrary *)
%left  ELSE		(* L/R is arbitrary *)
%left  RAISE		(* L/R is arbitrary *)
%right HANDLE
%right ORELSE
%right ANDALSO
%left  WHEN
%right AS
%left  COLON
%right ARROW


%start program

%nonterm
	(* Constants *)
	  scon				of SCon
	| d				of int

	(* Identifiers and labels *)
	| lab				of Lab
	| vid				of VId
	|    vid'			of VId		(* excludes `=' *)
	| tycon				of TyCon
	| tyvar				of TyVar
	| strid				of StrId
	| sigid				of SigId
	| funid				of FunId

	| longvid			of LongVId
	|    longvid'			of LongVId	(* excludes `=' *)
	| longtycon			of LongTyCon
	| longstrid			of LongStrId

	| OP_opt			of Op

	(* Nonterminals for core grammar *)
	| atexp				of AtExp
	|    exp_COMMA_list0		of Exp list
	|    exp_COMMA_list1		of Exp list
	|    exp_COMMA_list2		of Exp list
	|    exp_SEMICOLON_list1	of Exp list
	|    exp_SEMICOLON_list2	of Exp list
	| exprow			of ExpRow
	|    exprow_opt			of ExpRow option
	|    COMMA_exprow_opt		of ExpRow option
	| appexp			of AppExp
	| infexp			of InfExp
	| exp				of Exp

	| match				of Match
	|    BAR_match_opt		of Match option
	| mrule				of Mrule

	| dec				of Dec
	|    dec1			of Dec
	|    dec1'			of Dec (* excludes local and seq. *)
	|    WITHTYPE_typbind_opt	of TypBind option
	|    vid_list1			of VId list
	|    longstrid_list1		of LongStrId list
	|    d_opt			of int option
	| valbind			of ValBind
	|    AND_valbind_opt		of ValBind option
	| fvalbind			of FvalBind
	|    AND_fvalbind_opt		of FvalBind option
	| fmatch			of Fmatch
	|    BAR_fmatch_opt		of Fmatch option
	| fmrule			of Fmrule
	| fpat				of Fpat
	| typbind			of TypBind
	|    AND_typbind_opt		of TypBind option
	| datbind			of DatBind
	|    datbind0			of DatBind
	|    datbind1			of DatBind
	|    AND_datbind_opt		of DatBind option
	| conbind			of ConBind
	|    BAR_conbind_opt		of ConBind option
	|    OF_ty_opt			of Ty option
	| exbind			of ExBind
	|    AND_exbind_opt		of ExBind option

	| atpat				of AtPat
	|    atpat'			of AtPat (* excludes <op>longvid *)
	|    pat_COMMA_list0		of Pat list
	|    pat_COMMA_list1		of Pat list
	|    pat_COMMA_list2		of Pat list
	|    pat_BAR_list2		of Pat list
	| patrow			of PatRow
	|    patrow_opt			of PatRow option
	|    COMMA_patrow_opt		of PatRow option
	|    COLON_ty_opt		of Ty option
	|    AS_pat_opt			of Pat option
	| infpat			of Pat
	| pat				of Pat

	| ty				of Ty
	|    tupty			of Ty
	|    ty_STAR_list		of Ty list
	|    consty			of Ty
	|    atty			of Ty
	| tyrow				of TyRow
	|    tyrow_opt			of TyRow option
	|    COMMA_tyrow_opt		of TyRow option
	| tyseq				of TySeq
	|    ty_COMMA_list2		of Ty list
	| tyvarseq			of TyVarSeq
	|    tyvarseq1			of TyVarSeq
	|    tyvar_COMMA_list1		of TyVar list

	(* Nonterminals for the module language *)
	| strexp			of StrExp
	|    strexp'			of StrExp (* excludes constraints *)
	| strdec			of StrDec
	|    strdec1			of StrDec
	|    strdec1'			of StrDec (* excludes sequencing *)
	| strbind			of StrBind
	|    AND_strbind_opt		of StrBind option
	|    strexp__AND_strbind_opt	of StrExp * StrBind option
	|    sigexp__AND_strbind_opt	of SigExp * StrBind option
	|    tyreadesc__AND_strbind_opt	of TyReaDesc * StrBind option
	|    AND_tyreadesc_opt__AND_strbind_opt
					of TyReaDesc option * StrBind option
	|    COLON_sigexp_opt		of SigExp option

	| sigexp			of SigExp
	|    sigexp'			of SigExp (* excludes where *)
	| sigdec			of SigDec
	| sigbind			of SigBind
	|    AND_sigbind_opt		of SigBind option
	|    sigexp__AND_sigbind_opt	of SigExp * SigBind option
	|    tyreadesc__AND_sigbind_opt	of TyReaDesc * SigBind option
	|    AND_tyreadesc_opt__AND_sigbind_opt
					of TyReaDesc option * SigBind option
	| tyreadesc			of TyReaDesc
	|    AND_tyreadesc_opt		of TyReaDesc option

	| spec				of Spec
	|    spec1			of Spec
	|    spec1'			of Spec (* excludes sharing and seq. *)
	|    WITHTYPE_syndesc_opt	of SynDesc option
	|    sigid_list2		of SigId list
	|    longtycon_EQUALS_list1	of LongTyCon list
	|    longtycon_EQUALS_list2	of LongTyCon list
	|    longstrid_EQUALS_list1	of LongStrId list
	|    longstrid_EQUALS_list2	of LongStrId list

	| valdesc			of ValDesc
	|    AND_valdesc_opt		of ValDesc option
	| typdesc			of TypDesc
	|    AND_typdesc_opt		of TypDesc option
	| syndesc			of SynDesc
	|    AND_syndesc_opt		of SynDesc option
	| datdesc			of DatDesc
	|    datdesc0			of DatDesc
	|    datdesc1			of DatDesc
	|    AND_datdesc_opt		of DatDesc option
	| condesc			of ConDesc
	|    BAR_condesc_opt		of ConDesc option
	| exdesc			of ExDesc
	|    AND_exdesc_opt		of ExDesc option
	| strdesc			of StrDesc
	|    AND_strdesc_opt		of StrDesc option
	|    sigexp__AND_strdesc_opt	of SigExp * StrDesc option
	|    tyreadesc__AND_strdesc_opt	of TyReaDesc * StrDesc option
	|    AND_tyreadesc_opt__AND_strdesc_opt
					of TyReaDesc option * StrDesc option

	| fundec			of FunDec
	| funbind			of FunBind
	|    AND_funbind_opt		of FunBind option
	|    strexp__AND_funbind_opt	of StrExp * FunBind option
	|    sigexp__AND_funbind_opt	of SigExp * FunBind option
	|    tyreadesc__AND_funbind_opt	of TyReaDesc * FunBind option
	|    AND_tyreadesc_opt__AND_funbind_opt
					of TyReaDesc option * FunBind option
	| topdec			of TopDec
	|    topdec1			of TopDec
	|    topdec_opt			of TopDec option

	(* Top nonterminal *)
	| program			of Program


%%


  (* Constants *)

  scon:
	  ZERO		( SCon(I(ZEROleft,ZEROright),   SCon.fromInt 0) )
	| DIGIT		( SCon(I(DIGITleft,DIGITright), SCon.fromInt DIGIT) )
	| NUMERIC	( SCon(I(NUMERICleft,NUMERICright),
							SCon.fromInt NUMERIC) )
	| INT		( SCon(I(INTleft,INTright),     SCon.fromInt INT) )
	| WORD		( SCon(I(WORDleft,WORDright),   SCon.fromWord WORD) )
	| STRING	( SCon(I(STRINGleft,STRINGright),
							SCon.fromString STRING) )
	| CHAR		( SCon(I(CHARleft,CHARright),   SCon.fromChar CHAR) )
	| REAL		( SCon(I(REALleft,REALright),   SCon.fromReal REAL) )

  d:
	  ZERO		( 0 )
	| DIGIT		( DIGIT )



  (* Identifiers and labels *)

  lab:
	  ALPHA		( Lab(I(ALPHAleft,ALPHAright),   Lab.fromString ALPHA) )
	| SYMBOL	( Lab(I(SYMBOLleft,SYMBOLright), Lab.fromString SYMBOL))
	| STAR		( Lab(I(STARleft,STARright),     Lab.fromString "*") )
	| DIGIT		( Lab(I(DIGITleft,DIGITright),   Lab.fromInt DIGIT) )
	| NUMERIC	( Lab(I(NUMERICleft,NUMERICright), Lab.fromInt NUMERIC))


  vid:
	  vid'		( vid' )
	| EQUALS	( VId(I(EQUALSleft,EQUALSright), VId.fromString "=") )

     vid':
	  ALPHA		( VId(I(ALPHAleft,ALPHAright),   VId.fromString ALPHA) )
	| SYMBOL	( VId(I(SYMBOLleft,SYMBOLright), VId.fromString SYMBOL))
	| STAR		( VId(I(STARleft,STARright),     VId.fromString "*") )

  tycon:
	  ALPHA		( TyCon(I(ALPHAleft,ALPHAright),
				TyCon.fromString ALPHA) )
	| SYMBOL	( TyCon(I(SYMBOLleft,SYMBOLright),
				TyCon.fromString SYMBOL) )

  tyvar:  TYVAR		( TyVar(I(TYVARleft,TYVARright),
				TyVar.fromString TYVAR) )

  strid:  ALPHA		( StrId(I(ALPHAleft,ALPHAright),
				StrId.fromString ALPHA) )

  sigid:  ALPHA		( SigId(I(ALPHAleft,ALPHAright),
				SigId.fromString ALPHA) )

  funid:  ALPHA		( FunId(I(ALPHAleft,ALPHAright),
				FunId.fromString ALPHA) )


  longvid:
	  longvid'		( longvid' )
	| EQUALS		( SHORTLongId(I(EQUALSleft,EQUALSright),
					      VId(I(EQUALSleft,EQUALSright),
						  VId.fromString "=")) )
     longvid':
	  vid'			( SHORTLongId(I(vid'left,vid'right), vid') )
	| longstrid DOT vid	( DOTLongId(I(longstridleft,vidright),
					    longstrid, vid) )
  longtycon:
	  tycon			( SHORTLongId(I(tyconleft,tyconright), tycon) )
	| longstrid DOT tycon	( DOTLongId(I(longstridleft,tyconright),
					    longstrid, tycon) )
  longstrid:
	  strid			( SHORTLongId(I(stridleft,stridright), strid) )
	| longstrid DOT strid	( DOTLongId(I(longstridleft,stridright),
					    longstrid, strid) )


  OP_opt:
	  OP			( WITHOp )
	| (*empty*)		( SANSOp )




  (* Core: Expressions *)

  atexp:
	  scon		( SCONAtExp(I(sconleft,sconright), scon) )
	| OP_opt longvid
			( LONGVIDAtExp(I(OP_optleft,longvidright),
				       OP_opt, longvid) )
	| LBRACE exprow_opt RBRACE
			( RECORDAtExp(I(LBRACEleft,RBRACEright), exprow_opt) )
	| HASH lab	( HASHAtExp(I(HASHleft,labright), lab) )
	| LPAR RPAR	( UNITAtExp(I(LPARleft,RPARright)) )
	| LPAR exp_COMMA_list2 RPAR
			( TUPLEAtExp(I(LPARleft,RPARright), exp_COMMA_list2) )
	| LBRACK exp_COMMA_list0 RBRACK
			( LISTAtExp(I(LBRACKleft,RBRACKright),
				    exp_COMMA_list0 ))
	| HASHBRACK exp_COMMA_list0 RBRACK
			( VECTORAtExp(I(HASHBRACKleft,RBRACKright),
				    exp_COMMA_list0 ))
	| LPAR exp_SEMICOLON_list2 RPAR
			( SEQAtExp(I(LPARleft,RPARright), exp_SEMICOLON_list2) )
	| LET dec IN exp_SEMICOLON_list1 END
			( LETAtExp(I(LETleft,ENDright),
				   dec, exp_SEMICOLON_list1) )
	| LPAR exp RPAR	( PARAtExp(I(LPARleft,RPARright), exp) )


     exp_COMMA_list0:
	  exp_COMMA_list1		( exp_COMMA_list1 )
	| (*empty*)			( [] )

     exp_COMMA_list1:
	  exp COMMA exp_COMMA_list1	( exp::exp_COMMA_list1 )
	| exp				( exp::[] )

     exp_COMMA_list2:
	  exp COMMA exp_COMMA_list1	( exp::exp_COMMA_list1 )

     exp_SEMICOLON_list1:
	  exp SEMICOLON exp_SEMICOLON_list1	( exp::exp_SEMICOLON_list1 )
	| exp					( exp::[] )

     exp_SEMICOLON_list2:
	  exp SEMICOLON exp_SEMICOLON_list1	( exp::exp_SEMICOLON_list1 )


  exprow:
	  lab EQUALS exp COMMA_exprow_opt
	  			( ROWExpRow(I(lableft,COMMA_exprow_optright),
	  				    lab, exp, COMMA_exprow_opt) )
	| vid' COLON_ty_opt COMMA_exprow_opt
	  			( VIDExpRow(I(vid'left,COMMA_exprow_optright),
	  				    vid', COLON_ty_opt,
					    COMMA_exprow_opt) )
     COMMA_exprow_opt:
	  COMMA exprow		( SOME exprow )
	| (*empty*)		( NONE )

     exprow_opt:
	  exprow		( SOME exprow )
	| (*empty*)		( NONE )


  appexp:
	  atexp			( ATEXPExp(I(atexpleft,atexpright), atexp) )
	| appexp atexp		( APPExp(I(appexpleft,atexpright),
					 appexp, atexp) )


  infexp:
	  appexp		( appexp )
	(*infexp vid infexp	( included above... )*)


  exp:
	  infexp		( infexp )
	| exp COLON ty		( TYPEDExp(I(expleft,tyright), exp, ty) )
	| exp ANDALSO exp	( ANDALSOExp(I(exp1left,exp2right), exp1, exp2))
	| exp ORELSE exp	( ORELSEExp(I(exp1left,exp2right), exp1, exp2) )
	| exp HANDLE match	( HANDLEExp(I(expleft,matchright), exp, match) )
	| RAISE exp		( RAISEExp(I(RAISEleft,expright), exp) )
	| IF exp THEN exp ELSE exp
				( IFExp(I(IFleft,exp3right), exp1, exp2, exp3) )
	| WHILE exp DO exp	( WHILEExp(I(WHILEleft,exp2right), exp1, exp2) )
	| CASE exp OF match	( CASEExp(I(CASEleft,matchright), exp, match) )
	| FN match		( FNExp(I(FNleft,matchright), match) )



  (* Core: Matches *)

  match:
	  mrule BAR_match_opt	( Match(I(mruleleft,BAR_match_optright),
					mrule, BAR_match_opt) )

     BAR_match_opt:
	  BAR match			( SOME match )
	| (*empty*) %prec DARROW	( NONE )

  mrule:
	  pat DARROW exp	( Mrule(I(patleft,expright), pat, exp) )



  (* Core: Declarations *)

  dec:
	  dec1		( dec1 )
	| (*empty*)	( EMPTYDec(I(defaultPos,defaultPos)) )

     dec1:
	  dec1'		( dec1' )
	| LOCAL dec IN dec END
			( LOCALDec(I(LOCALleft,ENDright), dec1, dec2) )
	| dec1 dec1 %prec SEMICOLON
			( SEQDec(I(dec11left,dec12right), dec11, dec12) )
	| SEMICOLON	( EMPTYDec(I(defaultPos,defaultPos)) )

     dec1':
	  VAL valbind	( VALDec(I(VALleft,valbindright),
			     TyVarSeq(I(defaultPos,defaultPos), []), valbind) )
	| VAL tyvarseq1 valbind
			( VALDec(I(VALleft,valbindright), tyvarseq1, valbind) )
	| FUN fvalbind	( FUNDec(I(FUNleft,fvalbindright),
			    TyVarSeq(I(defaultPos,defaultPos), []), fvalbind) )
	| FUN tyvarseq1 fvalbind
			( FUNDec(I(FUNleft,fvalbindright), tyvarseq1, fvalbind))
	| TYPE typbind	( TYPEDec(I(TYPEleft,typbindright), typbind) )
	| DATATYPE datbind0 WITHTYPE_typbind_opt
			( DATATYPEDec(I(DATATYPEleft,WITHTYPE_typbind_optright),
				     datbind0, WITHTYPE_typbind_opt) )
	| DATATYPE datbind1 WITHTYPE_typbind_opt
			( DATATYPEDec(I(DATATYPEleft,WITHTYPE_typbind_optright),
				      datbind1, WITHTYPE_typbind_opt) )
	| DATATYPE tycon EQUALS DATATYPE longtycon
			( REPLICATIONDec(I(DATATYPEleft,longtyconright),
					 tycon, longtycon) )
	| ABSTYPE datbind WITHTYPE_typbind_opt WITH dec END
			( ABSTYPEDec(I(ABSTYPEleft,ENDright), datbind,
				     WITHTYPE_typbind_opt, dec) )
	| EXCEPTION exbind
			( EXCEPTIONDec(I(EXCEPTIONleft,exbindright), exbind) )
	| OPEN longstrid_list1
			( OPENDec(I(OPENleft,longstrid_list1right),
				  longstrid_list1) )
	| INFIX d_opt vid_list1
			( INFIXDec(I(INFIXleft,vid_list1right),
				   d_opt, vid_list1) )
	| INFIXR d_opt vid_list1
			( INFIXRDec(I(INFIXRleft,vid_list1right),
				    d_opt, vid_list1) )
	| NONFIX vid_list1
			( NONFIXDec(I(NONFIXleft,vid_list1right), vid_list1) )

     WITHTYPE_typbind_opt:
	  WITHTYPE typbind	( SOME typbind )
	| (*empty*)		( NONE )

     vid_list1:
	  vid vid_list1		( vid::vid_list1 )
	| vid			( vid::[] )

     longstrid_list1:
	  longstrid longstrid_list1	( longstrid::longstrid_list1 )
	| longstrid			( longstrid::[] )

     d_opt:
	  d			( SOME d )
	| (*empty*)		( NONE )



  (* Core: Bindings *)

  valbind:
	  pat EQUALS exp AND_valbind_opt
			( PLAINValBind(I(patleft,AND_valbind_optright),
				       pat, exp, AND_valbind_opt) )
	| REC valbind
			( RECValBind(I(RECleft,valbindright), valbind) )

      AND_valbind_opt:
	  AND valbind	( SOME valbind )
	| (*empty*)	( NONE )


  fvalbind:
	  fmatch AND_fvalbind_opt
			( FvalBind(I(fmatchleft,AND_fvalbind_optright),
				     fmatch, AND_fvalbind_opt) )
     AND_fvalbind_opt:
	  AND fvalbind	( SOME fvalbind )
	| (*empty*)	( NONE )

  fmatch:
	  fmrule BAR_fmatch_opt
			( Fmatch(I(fmruleleft,BAR_fmatch_optright),
				 fmrule, BAR_fmatch_opt) )

     BAR_fmatch_opt:
	  BAR fmatch	( SOME fmatch )
	| (*empty*)	( NONE )

  fmrule:
	  fpat EQUALS exp
			( Fmrule(I(fpatleft,expright), fpat, exp) )

  fpat:
	  pat		( pat )

  typbind:
	  tyvarseq tycon EQUALS ty AND_typbind_opt
			( TypBind(I(tyvarseqleft,AND_typbind_optright),
				  tyvarseq, tycon, ty, AND_typbind_opt) )

     AND_typbind_opt:
	  AND typbind	( SOME typbind )
	| (*empty*)	( NONE )


  datbind:
	  tyvarseq tycon EQUALS conbind AND_datbind_opt
			( DatBind(I(tyvarseqleft,AND_datbind_optright),
				  tyvarseq, tycon, conbind, AND_datbind_opt) )
     datbind0:
	  tycon EQUALS conbind AND_datbind_opt
			( DatBind(I(tyconleft,AND_datbind_optright),
				  TyVarSeq(I(defaultPos,defaultPos), []),
				  tycon, conbind, AND_datbind_opt) )
     datbind1:
	  tyvarseq1 tycon EQUALS conbind AND_datbind_opt
			( DatBind(I(tyvarseq1left,AND_datbind_optright),
				  tyvarseq1, tycon, conbind, AND_datbind_opt) )

     AND_datbind_opt:
	  AND datbind	( SOME datbind )
	| (*empty*)	( NONE )


  conbind:
	  OP_opt vid' OF_ty_opt BAR_conbind_opt
			( ConBind(I(OP_optleft,BAR_conbind_optright),
				  OP_opt, vid', OF_ty_opt, BAR_conbind_opt) )

     BAR_conbind_opt:
	  BAR conbind	( SOME conbind )
	| (*empty*)	( NONE )

     OF_ty_opt:
	  OF ty		( SOME ty )
	| (*empty*)	( NONE )


  exbind:
	  OP_opt vid' OF_ty_opt AND_exbind_opt
			( NEWExBind(I(OP_optleft,AND_exbind_optright),
				    OP_opt, vid', OF_ty_opt, AND_exbind_opt) )
	| OP_opt vid' EQUALS OP_opt longvid AND_exbind_opt
			( EQUALExBind(I(OP_opt1left,AND_exbind_optright),
				      OP_opt1, vid', OP_opt2, longvid,
				      AND_exbind_opt) )
     AND_exbind_opt:
	  AND exbind	( SOME exbind )
	| (*empty*)	( NONE )



  (* Core: Patterns *)

  atpat:
	  atpat'	( atpat' )
	| OP_opt longvid'
			( LONGVIDAtPat(I(OP_optleft,longvid'right),
				       OP_opt, longvid') )
     atpat':
	  UNDERBAR	( WILDCARDAtPat(I(UNDERBARleft,UNDERBARright)) )
	| scon		( SCONAtPat(I(sconleft,sconright), scon) )
	| LBRACE patrow_opt RBRACE
			( RECORDAtPat(I(LBRACEleft,RBRACEright), patrow_opt) )
	| LPAR RPAR	( UNITAtPat(I(LPARleft,RPARright)) )
	| LPAR pat_COMMA_list2 RPAR
			( TUPLEAtPat(I(LPARleft,RPARright), pat_COMMA_list2) )
	| LBRACK pat_COMMA_list0 RBRACK
			( LISTAtPat(I(LBRACKleft,RBRACKright),
				    pat_COMMA_list0) )
	| HASHBRACK pat_COMMA_list0 RBRACK
			( VECTORAtPat(I(HASHBRACKleft,RBRACKright),
				    pat_COMMA_list0) )
	| LPAR pat_BAR_list2 RPAR
			( ALTAtPat(I(LPARleft,RPARright),
				   pat_BAR_list2) )
	| LPAR pat RPAR ( PARAtPat(I(LPARleft,RPARright), pat) )


     pat_COMMA_list0:
	  pat_COMMA_list1		( pat_COMMA_list1 )
	| (*empty*)			( [] )

     pat_COMMA_list1:
	  pat COMMA pat_COMMA_list1	( pat::pat_COMMA_list1 )
	| pat				( pat::[] )

     pat_COMMA_list2:
	  pat COMMA pat_COMMA_list1	( pat::pat_COMMA_list1 )

     pat_BAR_list2:
	  pat BAR pat			( [pat1,pat2] )
	| pat BAR pat_BAR_list2		( pat::pat_BAR_list2 )


  patrow:
	  DOTS		( WILDCARDPatRow(I(DOTSleft,DOTSright)) )
	| lab EQUALS pat COMMA_patrow_opt
			( ROWPatRow(I(lableft,COMMA_patrow_optright),
				      lab, pat, COMMA_patrow_opt) )
	| vid' COLON_ty_opt AS_pat_opt COMMA_patrow_opt
			( VIDPatRow(I(vid'left,COMMA_patrow_optright),
				    vid', COLON_ty_opt, AS_pat_opt,
				    COMMA_patrow_opt) )
     COMMA_patrow_opt:
	  COMMA patrow	( SOME patrow )
	| (*empty*)	( NONE )

     COLON_ty_opt:
	  COLON ty	( SOME ty )
	| (*empty*)	( NONE )

     AS_pat_opt:
	  AS pat	( SOME pat )
	| (*empty*)	( NONE )

     patrow_opt:
	  patrow	( SOME patrow )
	| (*empty*)	( NONE )



  infpat:
	  atpat		( ATPATPat(I(atpatleft,atpatright), atpat) )
	| infpat atpat	( APPPat(I(infpatleft,atpatright), infpat, atpat) )
	(*OP_opt longvid atpat
			( included above... )*)
	(*pat vid pat	( included above... )*)

  pat:
	  infpat	( infpat )
	| pat COLON ty	( TYPEDPat(I(patleft,tyright), pat, ty) )
	| pat AS pat	( LAYEREDPat(I(pat1left,pat2right), pat1, pat2) )
	| pat WHEN atexp
			( GUARDPat(I(patleft,atexpright), pat, atexp) )



  (* Core: Types *)

  ty:
	  tupty		 ( tupty )
	| tupty ARROW ty ( ARROWTy(I(tuptyleft,tyright), tupty, ty) )

     tupty:
	  ty_STAR_list	 ( TUPLETy(I(ty_STAR_listleft,ty_STAR_listright),
				   ty_STAR_list) )

     ty_STAR_list:
	  consty STAR ty_STAR_list	( consty::ty_STAR_list )
	| consty	 		( consty::[] )	  

     consty:
	  atty			( atty )
	| tyseq longtycon	( TYCONTy(I(tyseqleft,longtyconright),
					  tyseq, longtycon) )
     atty:
	  tyvar		( TYVARTy(I(tyvarleft,tyvarright), tyvar) )
	| LBRACE tyrow_opt RBRACE
			( RECORDTy(I(LBRACEleft,RBRACEright), tyrow_opt) )
	| LPAR ty RPAR	( PARTy(I(LPARleft,RPARright), ty) )


  tyrow:
	  lab COLON ty COMMA_tyrow_opt
			( ROWTyRow(I(lableft,COMMA_tyrow_optright),
				   lab, ty, COMMA_tyrow_opt) )
     COMMA_tyrow_opt:
	  COMMA tyrow	( SOME tyrow )
	| (*empty*)	( NONE )

     tyrow_opt:
	  tyrow		( SOME tyrow )
	| (*empty*)	( NONE )



  (* Core: Sequences *)

  tyseq:
	  consty			( TySeq(I(constyleft,constyright),
						[consty]) )
	| (*empty*)			( TySeq(I(defaultPos,defaultPos), []) )
	| LPAR ty_COMMA_list2 RPAR	( TySeq(I(LPARleft,RPARright),
						ty_COMMA_list2) )
     ty_COMMA_list2:
	  ty COMMA ty_COMMA_list2	( ty::ty_COMMA_list2 )
	| ty COMMA ty			( [ty1, ty2] )


  tyvarseq:
	  tyvarseq1			( tyvarseq1 )
	| (*empty*)			( TyVarSeq(I(defaultPos,defaultPos),
						   []) )
     tyvarseq1:
	  tyvar				( TyVarSeq(I(tyvarleft,tyvarright),
						   [tyvar]) )
	| LPAR tyvar_COMMA_list1 RPAR	( TyVarSeq(I(LPARleft,RPARright),
						   tyvar_COMMA_list1) )
     tyvar_COMMA_list1:
	  tyvar COMMA tyvar_COMMA_list1	( tyvar::tyvar_COMMA_list1 )
	| tyvar				( tyvar::[] )




  (* Modules: Structures *)

  strexp:
	  strexp'	( strexp' )
	| strexp COLON sigexp
			( TRANSStrExp(I(strexpleft,sigexpright),
				      strexp, sigexp) )
	| strexp COLONGREATER sigexp
			( OPAQStrExp(I(strexpleft,sigexpright), strexp, sigexp))

     strexp':
	  STRUCT strdec END
			( STRUCTStrExp(I(STRUCTleft,ENDright), strdec) )
	| longstrid	( LONGSTRIDStrExp(I(longstridleft,longstridright),
					  longstrid) )
	| funid LPAR strexp RPAR
			( APPStrExp(I(funidleft,RPARright), funid, strexp) )
	| funid LPAR strdec RPAR
			( APPDECStrExp(I(funidleft,RPARright), funid, strdec) )
	| LET strdec IN strexp END
			( LETStrExp(I(LETleft,ENDright), strdec, strexp) )


  strdec:
	  strdec1	( strdec1 )
	| (*empty*)	( EMPTYStrDec(I(defaultPos,defaultPos)) )

     strdec1:
	  strdec1'	( strdec1' )
	| strdec1 strdec1 %prec SEMICOLON
			( SEQStrDec(I(strdec11left,strdec12right),
				    strdec11, strdec12) )
	| SEMICOLON	( EMPTYStrDec(I(SEMICOLONleft,SEMICOLONright)) )

     strdec1':
	  dec1'		( DECStrDec(I(dec1'left,dec1'right), dec1') )
	| STRUCTURE strbind
			( STRUCTUREStrDec(I(STRUCTUREleft,strbindright),
					  strbind) )
	| LOCAL strdec IN strdec END
			( LOCALStrDec(I(LOCALleft,ENDright), strdec1, strdec2) )


  strbind:
	  strid COLON_sigexp_opt EQUALS strexp__AND_strbind_opt
			( TRANSStrBind(I(stridleft,
					 strexp__AND_strbind_optright),
				       strid, COLON_sigexp_opt,
				       #1 strexp__AND_strbind_opt,
				       #2 strexp__AND_strbind_opt) )
	| strid COLONGREATER sigexp EQUALS strexp__AND_strbind_opt
			( OPAQStrBind(I(stridleft,strexp__AND_strbind_optright),
				      strid, sigexp, #1 strexp__AND_strbind_opt,
				      #2 strexp__AND_strbind_opt) )
     AND_strbind_opt:
	  AND strbind	( SOME strbind )
	| (*empty*)	( NONE )

     strexp__AND_strbind_opt:
	  strexp' AND_strbind_opt
			( ( strexp', AND_strbind_opt ) )
	| strexp COLON sigexp__AND_strbind_opt
			( ( TRANSStrExp(I(strexpleft,
					  sigexp__AND_strbind_optright),
					strexp, #1 sigexp__AND_strbind_opt),
			    #2 sigexp__AND_strbind_opt ) )
	| strexp COLONGREATER sigexp__AND_strbind_opt
			( ( OPAQStrExp(I(strexpleft,
					 sigexp__AND_strbind_optright),
				       strexp, #1 sigexp__AND_strbind_opt),
			    #2 sigexp__AND_strbind_opt ) )

     sigexp__AND_strbind_opt:
	  sigexp' AND_strbind_opt
			( ( sigexp', AND_strbind_opt ) )
	| sigexp WHERE tyreadesc__AND_strbind_opt
			( ( WHERETYPESigExp(I(sigexpleft,
					      tyreadesc__AND_strbind_optright),
					   sigexp,
					   #1 tyreadesc__AND_strbind_opt),
			    #2 tyreadesc__AND_strbind_opt ) )

     tyreadesc__AND_strbind_opt:
	  TYPE tyvarseq longtycon EQUALS ty AND_tyreadesc_opt__AND_strbind_opt
			( ( TyReaDesc(I(TYPEleft,
				       AND_tyreadesc_opt__AND_strbind_optright),
				      tyvarseq, longtycon, ty,
				      #1 AND_tyreadesc_opt__AND_strbind_opt),
			    #2 AND_tyreadesc_opt__AND_strbind_opt ) )

     AND_tyreadesc_opt__AND_strbind_opt:
	  AND_strbind_opt	( ( NONE, AND_strbind_opt ) )
	| AND tyreadesc__AND_strbind_opt
	  			( ( SOME(#1 tyreadesc__AND_strbind_opt),
				    #2 tyreadesc__AND_strbind_opt ) )


     COLON_sigexp_opt:
	  COLON sigexp	( SOME sigexp )
	| (*empty*)	( NONE )



  (* Modules: Signatures *)

  sigexp:
	  sigexp'	( sigexp' )
	| sigexp WHERE tyreadesc
			( WHERETYPESigExp(I(sigexpleft,tyreadescright),
					  sigexp, tyreadesc) )
     sigexp':
	  SIG spec END	( SIGSigExp(I(SIGleft,ENDright), spec) )
	| sigid		( SIGIDSigExp(I(sigidleft,sigidright), sigid) )
	| sigexp WHERE longstrid EQUALS longstrid
			( WHERESigExp(I(sigexpleft,longstrid2right),
				      sigexp, longstrid1, longstrid2) )

  sigdec:
	  SIGNATURE sigbind
			( SigDec(I(SIGNATUREleft,sigbindright), sigbind) )

  sigbind:
	  sigid EQUALS sigexp__AND_sigbind_opt
			( SigBind(I(sigidleft,sigexp__AND_sigbind_optright),
				  sigid, #1 sigexp__AND_sigbind_opt,
				  #2 sigexp__AND_sigbind_opt) )

     AND_sigbind_opt:
	  AND sigbind	( SOME sigbind )
	| (*empty*)	( NONE )

     sigexp__AND_sigbind_opt:
	  sigexp' AND_sigbind_opt
	  		( ( sigexp', AND_sigbind_opt ) )
	| sigexp WHERE tyreadesc__AND_sigbind_opt
			( ( WHERETYPESigExp(I(sigexpleft,
					      tyreadesc__AND_sigbind_optright),
					   sigexp,
					   #1 tyreadesc__AND_sigbind_opt),
			    #2 tyreadesc__AND_sigbind_opt ) )

     tyreadesc__AND_sigbind_opt:
	  TYPE tyvarseq longtycon EQUALS ty AND_tyreadesc_opt__AND_sigbind_opt
			( ( TyReaDesc(I(TYPEleft,
				       AND_tyreadesc_opt__AND_sigbind_optright),
				      tyvarseq, longtycon, ty,
				      #1 AND_tyreadesc_opt__AND_sigbind_opt),
			    #2 AND_tyreadesc_opt__AND_sigbind_opt ) )

     AND_tyreadesc_opt__AND_sigbind_opt:
	  AND_sigbind_opt	( ( NONE, AND_sigbind_opt) )
	| AND tyreadesc__AND_sigbind_opt
	  			( ( SOME(#1 tyreadesc__AND_sigbind_opt),
				    #2 tyreadesc__AND_sigbind_opt ) )


  tyreadesc:
	  TYPE tyvarseq longtycon EQUALS ty AND_tyreadesc_opt
			( TyReaDesc(I(TYPEleft,AND_tyreadesc_optright),
				    tyvarseq, longtycon, ty,
				    AND_tyreadesc_opt) )
     AND_tyreadesc_opt:
	  AND tyreadesc	( SOME tyreadesc )
	| (*empty*)	( NONE )



  (* Modules: Specifications *)

  spec:
	  spec1		( spec1 )
	| (*empty*)	( EMPTYSpec(I(defaultPos,defaultPos)) )

     spec1:
	  spec1'	( spec1' )
	| spec1 spec1' %prec SEMICOLON
			( SEQSpec(I(spec1left,spec1'right), spec1, spec1') )
	| SEMICOLON	( EMPTYSpec(I(defaultPos,defaultPos)) )
	| SHARING TYPE longtycon_EQUALS_list2
			( SHARINGTYPESpec(I(SHARINGleft,
					    longtycon_EQUALS_list2right),
					  EMPTYSpec(I(SHARINGleft,SHARINGleft)),
					  longtycon_EQUALS_list2) )
	| spec1 SHARING TYPE longtycon_EQUALS_list2
			( SHARINGTYPESpec(I(spec1left,
					    longtycon_EQUALS_list2right),
					  spec1, longtycon_EQUALS_list2) )
	| SHARING longstrid_EQUALS_list2
			( SHARINGSpec(I(SHARINGleft,
					longstrid_EQUALS_list2right),
				      EMPTYSpec(I(SHARINGleft,SHARINGleft)),
				      longstrid_EQUALS_list2) )
	| spec1 SHARING longstrid_EQUALS_list2
			( SHARINGSpec(I(spec1left,longstrid_EQUALS_list2right),
				      spec1, longstrid_EQUALS_list2) )

     spec1':
	  VAL valdesc	( VALSpec(I(VALleft,valdescright), valdesc) )
	| FUN valdesc	( FUNSpec(I(FUNleft,valdescright), valdesc) )
	| TYPE typdesc	( TYPESpec(I(TYPEleft,typdescright), typdesc) )
	| EQTYPE typdesc
	  		( EQTYPESpec(I(EQTYPEleft,typdescright), typdesc) )
	| TYPE syndesc
			( SYNSpec(I(TYPEleft,syndescright), syndesc) )
	| DATATYPE datdesc0 WITHTYPE_syndesc_opt
			( DATATYPESpec(I(DATATYPEleft,WITHTYPE_syndesc_optright),
				       datdesc0, WITHTYPE_syndesc_opt) )
	| DATATYPE datdesc1 WITHTYPE_syndesc_opt
			( DATATYPESpec(I(DATATYPEleft,WITHTYPE_syndesc_optright),
				       datdesc1, WITHTYPE_syndesc_opt) )
	| DATATYPE tycon EQUALS DATATYPE longtycon
			( REPLICATIONSpec(I(DATATYPEleft,longtyconright),
					  tycon, longtycon) )
	| EXCEPTION exdesc
			( EXCEPTIONSpec(I(EXCEPTIONleft,exdescright), exdesc) )
	| STRUCTURE strdesc
			( STRUCTURESpec(I(STRUCTUREleft,strdescright), strdesc))
	| INCLUDE sigexp
			( INCLUDESpec(I(INCLUDEleft,sigexpright), sigexp) )
	| INCLUDE sigid_list2
			( INCLUDEMULTISpec(I(INCLUDEleft,sigid_list2right),
					   sigid_list2) )
	| INFIX d_opt vid_list1
			( INFIXSpec(I(INFIXleft,vid_list1right), d_opt,
				    vid_list1) )
	| INFIXR d_opt vid_list1
			( INFIXRSpec(I(INFIXRleft,vid_list1right), d_opt,
				     vid_list1) )
	| NONFIX vid_list1
			( NONFIXSpec(I(NONFIXleft,vid_list1right), vid_list1) )

     WITHTYPE_syndesc_opt:
	  WITHTYPE syndesc	( SOME syndesc )
	| (*empty*)		( NONE )

     sigid_list2:
	  sigid sigid_list2	( sigid::sigid_list2 )
	| sigid	sigid		( sigid1::sigid2::[] )

     longtycon_EQUALS_list1:
	  longtycon EQUALS longtycon_EQUALS_list1
				( longtycon::longtycon_EQUALS_list1 )
	| longtycon		( longtycon::[] )

     longtycon_EQUALS_list2:
	  longtycon EQUALS longtycon_EQUALS_list1
				( longtycon::longtycon_EQUALS_list1 )
     longstrid_EQUALS_list1:
	  longstrid EQUALS longstrid_EQUALS_list1
				( longstrid::longstrid_EQUALS_list1 )
	| longstrid		( longstrid::[] )

     longstrid_EQUALS_list2:
	  longstrid EQUALS longstrid_EQUALS_list1
				( longstrid::longstrid_EQUALS_list1 )


  (* Modules: Descriptions *)

  valdesc:
	  vid' COLON ty AND_valdesc_opt
	  		( ValDesc(I(vid'left,AND_valdesc_optright),
				  vid', ty, AND_valdesc_opt) )
     AND_valdesc_opt:
	  AND valdesc	( SOME valdesc )
	| (*empty*)	( NONE )

  typdesc:
	  tyvarseq tycon AND_typdesc_opt
			( TypDesc(I(tyvarseqleft,AND_typdesc_optright),
				  tyvarseq, tycon, AND_typdesc_opt) )
     AND_typdesc_opt:
	  AND typdesc	( SOME typdesc )
	| (*empty*)	( NONE )

  syndesc:
	  tyvarseq tycon EQUALS ty AND_syndesc_opt
			( SynDesc(I(tyvarseqleft,AND_syndesc_optright),
				  tyvarseq, tycon, ty, AND_syndesc_opt) )
     AND_syndesc_opt:
	  AND syndesc	( SOME syndesc )
	| (*empty*)	( NONE )

  datdesc:
	  tyvarseq tycon EQUALS condesc AND_datdesc_opt
	  		( DatDesc(I(tyvarseqleft,AND_datdesc_optright),
	  			  tyvarseq, tycon, condesc, AND_datdesc_opt) )
     datdesc0:
	  tycon EQUALS condesc AND_datdesc_opt
	  		( DatDesc(I(tyconleft,AND_datdesc_optright),
	  			  TyVarSeq(I(defaultPos,defaultPos), []),
				  tycon, condesc, AND_datdesc_opt) )
     datdesc1:
	  tyvarseq1 tycon EQUALS condesc AND_datdesc_opt
	  		( DatDesc(I(tyvarseq1left,AND_datdesc_optright),
	  			  tyvarseq1, tycon, condesc, AND_datdesc_opt) )
     AND_datdesc_opt:
	  AND datdesc	( SOME datdesc )
	| (*empty*)	( NONE )

  condesc:
	  vid' OF_ty_opt BAR_condesc_opt
			( ConDesc(I(vid'left,BAR_condesc_optright),
				  vid', OF_ty_opt, BAR_condesc_opt) )
     BAR_condesc_opt:
	  BAR condesc	( SOME condesc )
	| (*empty*)	( NONE )

  exdesc:
	  vid' OF_ty_opt AND_exdesc_opt
	  		( ExDesc(I(vid'left,AND_exdesc_optright),
	  			 vid', OF_ty_opt, AND_exdesc_opt) )
     AND_exdesc_opt:
	  AND exdesc	( SOME exdesc )
	| (*empty*)	( NONE )

  strdesc:
	  strid COLON sigexp__AND_strdesc_opt
	  		( StrDesc(I(stridleft,sigexp__AND_strdesc_optright),
	  			  strid, #1 sigexp__AND_strdesc_opt,
				  #2 sigexp__AND_strdesc_opt) )
     AND_strdesc_opt:
	  AND strdesc	( SOME strdesc )
	| (*empty*)	( NONE )

     sigexp__AND_strdesc_opt:
	  sigexp' AND_strdesc_opt
			( ( sigexp', AND_strdesc_opt ) )
	| sigexp WHERE tyreadesc__AND_strdesc_opt
			( ( WHERETYPESigExp(I(sigexpleft,
					      tyreadesc__AND_strdesc_optright),
					   sigexp,
					   #1 tyreadesc__AND_strdesc_opt),
			    #2 tyreadesc__AND_strdesc_opt ) )

     tyreadesc__AND_strdesc_opt:
	  TYPE tyvarseq longtycon EQUALS ty AND_tyreadesc_opt__AND_strdesc_opt
			( ( TyReaDesc(I(TYPEleft,
				       AND_tyreadesc_opt__AND_strdesc_optright),
				      tyvarseq, longtycon, ty,
				      #1 AND_tyreadesc_opt__AND_strdesc_opt),
			    #2 AND_tyreadesc_opt__AND_strdesc_opt ) )

     AND_tyreadesc_opt__AND_strdesc_opt:
	  AND_strdesc_opt	( ( NONE, AND_strdesc_opt ) )
	| AND tyreadesc__AND_strdesc_opt
	  			( ( SOME(#1 tyreadesc__AND_strdesc_opt),
				    #2 tyreadesc__AND_strdesc_opt ) )




  (* Modules: Functors *)

  fundec:
	  FUNCTOR funbind	( FunDec(I(FUNCTORleft,funbindright), funbind) )

  funbind:
	  funid LPAR strid COLON sigexp RPAR COLON_sigexp_opt EQUALS
		strexp__AND_funbind_opt
			( TRANSFunBind(I(funidleft,
					 strexp__AND_funbind_optright),
				       funid, strid, sigexp, COLON_sigexp_opt,
				       #1 strexp__AND_funbind_opt,
				       #2 strexp__AND_funbind_opt) )
	| funid LPAR strid COLON sigexp RPAR COLONGREATER sigexp EQUALS
		strexp__AND_funbind_opt
			( OPAQFunBind(I(funidleft,strexp__AND_funbind_optright),
				      funid, strid, sigexp1, sigexp2,
				      #1 strexp__AND_funbind_opt,
				      #2 strexp__AND_funbind_opt) )
	| funid LPAR spec RPAR COLON_sigexp_opt EQUALS strexp__AND_funbind_opt
			( TRANSSPECFunBind(I(funidleft,
					     strexp__AND_funbind_optright),
					   funid, spec, COLON_sigexp_opt,
					   #1 strexp__AND_funbind_opt,
					   #2 strexp__AND_funbind_opt) )
	| funid LPAR spec RPAR COLONGREATER sigexp EQUALS
		strexp__AND_funbind_opt
			( OPAQSPECFunBind(I(funidleft,
					    strexp__AND_funbind_optright),
					  funid, spec, sigexp,
					  #1 strexp__AND_funbind_opt,
					  #2 strexp__AND_funbind_opt) )
     AND_funbind_opt:
	  AND funbind	( SOME funbind )
	| (*empty*)	( NONE )

     strexp__AND_funbind_opt:
	  strexp' AND_funbind_opt
			( ( strexp', AND_funbind_opt ) )
	| strexp COLON sigexp__AND_funbind_opt
			( ( TRANSStrExp(I(strexpleft,
					  sigexp__AND_funbind_optright),
					strexp, #1 sigexp__AND_funbind_opt),
			    #2 sigexp__AND_funbind_opt ) )
	| strexp COLONGREATER sigexp__AND_funbind_opt
			( ( OPAQStrExp(I(strexpleft,
					 sigexp__AND_funbind_optright),
				       strexp, #1 sigexp__AND_funbind_opt),
			    #2 sigexp__AND_funbind_opt ) )

     sigexp__AND_funbind_opt:
	  sigexp' AND_funbind_opt
			( ( sigexp', AND_funbind_opt ) )
	| sigexp WHERE tyreadesc__AND_funbind_opt
			( ( WHERETYPESigExp(I(sigexpleft,
					      tyreadesc__AND_funbind_optright),
					   sigexp,
					   #1 tyreadesc__AND_funbind_opt),
			    #2 tyreadesc__AND_funbind_opt ) )

     tyreadesc__AND_funbind_opt:
	  TYPE tyvarseq longtycon EQUALS ty AND_tyreadesc_opt__AND_funbind_opt
			( ( TyReaDesc(I(TYPEleft,
				       AND_tyreadesc_opt__AND_funbind_optright),
				      tyvarseq, longtycon, ty,
				      #1 AND_tyreadesc_opt__AND_funbind_opt),
			    #2 AND_tyreadesc_opt__AND_funbind_opt ) )

     AND_tyreadesc_opt__AND_funbind_opt:
	  AND_funbind_opt
			( ( NONE, AND_funbind_opt ) )
	| AND tyreadesc__AND_funbind_opt
	  		( ( SOME(#1 tyreadesc__AND_funbind_opt),
			    #2 tyreadesc__AND_funbind_opt ) )



  (* Modules: Top-level declarations *)

  topdec:
	  topdec1	( topdec1 )
	| (*empty*)	( STRDECTopDec(I(defaultPos,defaultPos),
				       EMPTYStrDec(I(defaultPos,defaultPos)),
				       NONE) )
     topdec1:
	  strdec1' topdec_opt
			( STRDECTopDec(I(strdec1'left,topdec_optright),
				       strdec1', topdec_opt) )
	| sigdec topdec_opt
			( SIGDECTopDec(I(sigdecleft,topdec_optright),
				       sigdec, topdec_opt) )
	| fundec topdec_opt
			( FUNDECTopDec(I(fundecleft,topdec_optright),
				       fundec, topdec_opt) )
     topdec_opt:
	  topdec1	( SOME topdec1 )
	| (*empty*)	( NONE )



  (* Programs *)

  program:
	  topdec SEMICOLON
	  		( TOPDECProgram(I(topdecleft,SEMICOLONright),
					topdec, NONE) )
	| exp SEMICOLON
	  		( EXPProgram(I(expleft,SEMICOLONright),
				     exp, NONE) )
