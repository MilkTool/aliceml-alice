(* src # 0 *)
(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 1999
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(* Hardwired *)

__prebound Prebound

datatype bool   = datatype Prebound.bool
type     int    = Prebound.int
type     word   = Prebound.word
type     real   = Prebound.real
type     string = Prebound.string
type     char   = Prebound.char
datatype list   = datatype Prebound.list
datatype ref    = datatype Prebound.ref
datatype exn    = datatype Prebound.exn

exception Match = Prebound.Match
exception Bind  = Prebound.Bind


(* Toplevel *)

infix  7  * / div mod
infix  6  + - ^
infixr 5  :: @
infix  4  = <> > >= < <=
infix  3  := o
infix  0  before

(*--** __primitive val use : string -> unit = "use" *)

__primitive val op=  : ''a * ''a -> bool = "="
__primitive val op<> : ''a * ''a -> bool = "<>"


(* Overloaded Identifiers *)

__primitive val op~ :	int -> int = "~"

__primitive val op+ :	int * int -> int = "+"
__primitive val op- :	int * int -> int = "-"
__primitive val op* :	int * int -> int = "*"
__primitive val op div:	int * int -> int = "div"
__primitive val op mod:	int * int -> int = "mod"

__primitive val op< :	int * int -> bool = "<"
__primitive val op> :	int * int -> bool = ">"
__primitive val op<= :	int * int -> bool = "<="
__primitive val op>= :	int * int -> bool = ">="


(* General *)

structure General =
  struct

    type unit = {}
    type exn  = exn

    exception Bind = Bind
    __primitive constructor Chr: exn = "General.Chr"
    __primitive constructor Div: exn = "General.Div"
    __primitive constructor Domain: exn = "General.Domain"
    __primitive constructor Fail of string: exn = "General.Fail"
    exception Match = Match
    __primitive constructor Overflow: exn = "General.Overflow"
    __primitive constructor Size: exn = "General.Size"
    __primitive constructor Span: exn = "General.Span"
    __primitive constructor Subscript: exn = "General.Subscript"

    datatype order = LESS | EQUAL | GREATER

    fun !(ref v) = v

    __primitive val op:= : 'a ref * 'a -> unit = ":="

    fun (f o g) a  = f(g a)
    fun a before b = a
    fun ignore a   = ()

  end

open General


(* Option *)

structure Option =
  struct

    datatype 'a option = NONE | SOME of 'a

    __primitive constructor Option: exn = "Option.Option"

    fun getOpt(SOME v, _) = v
      | getOpt(NONE,   a) = a

    fun isSome(SOME v) = true
      | isSome NONE    = false

    fun valOf(SOME v) = v
      | valOf NONE    = raise Option

    fun filter f a = if f a then SOME a else NONE

    fun join NONE    = NONE
      | join(SOME v) = v

    fun map f  NONE    = NONE
      | map f (SOME v) = SOME(f v)

    fun mapPartial f  NONE    = NONE
      | mapPartial f (SOME v) = f v

    fun compose (f,g) a =
	case g a
	  of NONE   => NONE
	   | SOME v => SOME(f v)

    fun composePartial (f,g) a =
	case g a
	  of NONE   => NONE
	   | SOME v => f v

  end

datatype option = datatype Option.option


(* Bool *)

structure Bool =
  struct

    datatype bool = datatype bool

    fun not true  = false
      | not false = true

    fun toString true  = "true"  : string
      | toString false = "false" : string

  end

val not = Bool.not


(* List *)

structure List =
  struct

    datatype list = datatype list

    __primitive constructor Empty: exn = "List.Empty"

    fun null [] = true
      | null _  = false

    fun length xs =
	let fun length'(nil,   n) = n
	      | length'(y::ys, n) = length'(ys,n+1)
	in length'(xs,0) end

    fun   nil   @ ys = ys
      | (x::xs) @ ys = x :: xs @ ys

    fun hd(x::xs) = x
      | hd  _     = raise Empty

    fun tl(x::xs) = xs
      | tl  _     = raise Empty

    fun last(x::nil) = x
      | last(x::xs)  = last xs
      | last  nil    = raise Empty

    fun getItem(x::xs) = SOME(x,xs)
      | getItem  nil   = NONE

    fun nth(l,i) =
	let fun nth'(x::xs, 0) = x
	      | nth'(x::xs, j) = nth'(xs, j-1)
	      | nth'(nil,   j) = raise Subscript
	in if i >= 0 then nth'(l,i) else raise Subscript end

    fun rev l =
	let fun rev'( nil,  ys) = ys
	      | rev'(x::xs, ys) = rev'(xs, x::ys)
	in rev'(l,nil) end

    fun take(l,i) =
	let fun take'(x::xs, 0, ys) = rev ys
	      | take'(x::xs, j, ys) = take'(xs, j-1, x::ys)
	      | take'(nil,   j, ys) = raise Subscript
	in if i >= 0 then take'(l,i,nil) else raise Subscript end

    fun drop(l,i) =
	let fun drop'(xs,    0) = xs
	      | drop'(x::xs, j) = drop'(xs, j-1)
	      | drop'(nil,   j) = raise Subscript
	in if i >= 0 then drop'(l,i) else raise Subscript end

    fun concat  nil   = nil
      | concat(l::ls) = l @ concat ls

    fun revAppend( nil,  ys) = ys
      | revAppend(x::xs, ys) = revAppend(xs, x::ys)

    fun app f   nil   = ()
      | app f (x::xs) = (f x ; app f xs)

    fun map f   nil   = nil
      | map f (x::xs) = f x :: map f xs

    fun mapPartial f   nil   = nil
      | mapPartial f (x::xs) =
	let val yo = f x
	    val ys = mapPartial f xs
	in case yo of NONE => ys | SOME y => y::ys end

    fun find f   nil   = NONE
      | find f (x::xs) = if f x then SOME x else find f xs

    fun filter f   nil   = nil
      | filter f (x::xs) =
	let val b  = f x
	    val ys = filter f xs
	in if b then x::ys else ys end

    fun partition f l =
	let fun partition'( nil,  pos, neg) = (rev pos, rev neg)
	      | partition'(x::xs, pos, neg) =
		if f x then partition'(xs, x::pos, neg)
		       else partition'(xs, pos, x::neg)
	in partition'(l,nil,nil) end

    fun foldl f b   nil   = b
      | foldl f b (x::xs) = foldl f (f(x,b)) xs

    fun foldr f b   nil   = b
      | foldr f b (x::xs) = f(x, foldr f b xs)

    fun exists f   nil   = false
      | exists f (x::xs) = f x orelse exists f xs

    fun all f   nil   = true
      | all f (x::xs) = f x andalso all f xs

    fun tabulate(n, f) =
	let fun tabulate'(i,l) = if i = n then rev l
					  else tabulate'(i+1, f i :: l)
	in if n >= 0 then tabulate'(0, nil) else raise Size end

  end


(* ListPair *)

structure ListPair =
  struct

    fun zip(l1, l2) =
	let fun zip'( nil,    _,   l) = List.rev l
	      | zip'(  _,    nil,  l) = List.rev l
	      | zip'(x::xs, y::ys, l) = zip'(xs, ys, (x,y)::l)
	in zip'(l1, l2, nil) end

    fun unzip l =
	let fun unzip'(    nil,   l1, l2) = (List.rev l1, List.rev l2)
	      | unzip'((x,y)::l', l1, l2) = unzip'(l', x::l1, y::l2)
	in unzip'(l, nil, nil) end

    fun map f ( nil,    _  ) = nil
      | map f (  _,    nil ) = nil
      | map f (x::xs, y::ys) = f(x,y) :: map f (xs,ys)

    fun app f ( nil,    _  ) = ()
      | app f (  _,    nil ) = ()
      | app f (x::xs, y::ys) = (f(x,y) ; app f (xs,ys))

    fun foldl f c ( nil,    _  ) = c
      | foldl f c (  _,    nil ) = c
      | foldl f c (x::xs, y::ys) = f(x, y, foldl f c (xs,ys))

    fun foldr f c ( nil,    _  ) = c
      | foldr f c (  _,    nil ) = c
      | foldr f c (x::xs, y::ys) = foldr f (f(x,y,c)) (xs,ys)

    fun exists f ( nil,    _  ) = false
      | exists f (  _,    nil ) = false
      | exists f (x::xs, y::ys) = f(x,y) orelse exists f (xs,ys)

    fun all f ( nil,    _  ) = true
      | all f (  _,    nil ) = true
      | all f (x::xs, y::ys) = f(x,y) andalso all f (xs,ys)

  end


(* Char *)

structure Char =
    struct
	type char = char

	__primitive val <= : char * char -> bool = "Char.<="

	__primitive val ord : char -> int = "Char.ord"
	__primitive val chr : int -> char = "Char.chr"

	__primitive val isDigit :    char -> bool = "Char.isDigit"
	__primitive val isHexDigit : char -> bool = "Char.isHexDigit"
	__primitive val isSpace :    char -> bool = "Char.isSpace"

	__primitive val toCString :  char -> string = "Char.toCString"
    end


(* String *)

structure String =
    struct
	type string = string

	__primitive val op^ : string * string -> string = "String.^"
	__primitive val str : char -> string = "String.str"
	__primitive val size : string -> int = "String.size"
	__primitive val substring : string * int * int -> string =
							"String.substring"
	__primitive val sub : string * int -> char = "String.sub"
	__primitive val explode : string -> char list = "String.explode"

	fun extract (s, i, NONE) = substring (s, i, size s - i)
	  | extract (s, i, SOME j) = substring (s, i, j)

	fun concat l = List.foldr (fn (s, rest) => s ^ rest) "" l

	fun toCString s =
		List.foldr (fn (c, rest) => Char.toCString c ^ rest) "" (explode s)

	fun implode l = concat (List.map str l)

	fun map f s = implode (List.map f (explode s))

	__primitive val compare : string * string -> order = "String.compare"

	fun s < t = compare (s, t) = LESS

	local
	    fun token (c::cr, f) =
		if f c then
		    let
			val (cs, rest) = token (cr, f)
		    in
			(c::cs, rest)
		    end
		else (nil, cr)
	      | token (nil, _) = (nil, nil)

	    fun tokens' (c::cr, f) =
		if f c then tokens' (cr, f)
		else
		    let
			val (cs, rest) = token (cr, f)
		    in
			implode (c::cs)::tokens' (rest, f)
		    end
	      | tokens' (nil, _) = nil
	in
	    fun tokens f s = tokens' (explode s, f)
	end
    end


(* StringCvt *)

signature STRING_CVT =
    sig
	datatype radix = BIN | OCT | DEC | HEX

	type ('a, 'b) reader = 'b -> ('a * 'b) option

	type cs

	val dropl: (char -> bool) -> (char, 'a) reader -> 'a -> 'a

	val skipWS: (char, 'a) reader -> 'a -> 'a

	val scanString:
	    ((char, cs) reader -> ('a, cs) reader) -> string -> 'a option
    end

structure StringCvt :> STRING_CVT =
    struct
	datatype radix = BIN | OCT | DEC | HEX

	type ('a, 'b) reader = 'b -> ('a * 'b) option

	type cs = int

	fun dropl p getc =
	    let
		fun h src =
		    case getc src of
			NONE => src
		      | SOME (c, rest) => if p c then h rest else src
	    in
		h
	    end

	fun skipWS getc = dropl Char.isSpace getc

	fun scanString scan s =
	    let
		val len = String.size s
		fun getc i =
		    if i < len then SOME (String.sub (s, i), i + 1)
		    else NONE
	    in
		case scan getc 0 of
		    NONE => NONE
		  | SOME (res, _) => SOME res
	    end
    end


(* Int *)

local

structure Int =
    struct
	type int = int

	open StringCvt

	val op+ = op+

	fun decval c = Char.ord c - Char.ord #"0"
	fun hexval c =
	    if Char.ord #"0" <= Char.ord c andalso Char.ord c <= Char.ord #"9"
	    then Char.ord c - Char.ord #"0"
	    else (Char.ord c - Char.ord #"A" + 10) mod 32
	fun skipWSget getc source = getc (dropl Char.isSpace getc source)

	fun isBinDigit #"0" = true
	  | isBinDigit #"1" = true
	  | isBinDigit _ = false

	fun isOctDigit c = Char.ord c >= Char.ord #"0" andalso
			   Char.ord c <= Char.ord #"7"

	fun scan radix getc source =
	    let
		val (isDigit, factor) =
		    case radix of
			BIN => (isBinDigit,       2)
		      | OCT => (isOctDigit,       8)
		      | DEC => (Char.isDigit,    10)
		      | HEX => (Char.isHexDigit, 16)
		fun dig1 sgn NONE = NONE
		  | dig1 sgn (SOME (c, rest)) =
		    let
			fun digr res src =
			    case getc src of
				NONE => SOME (sgn * res, src)
			      | SOME (c', rest') =>
				    if isDigit c' then
					digr (factor * res + hexval c') rest'
				    else
					SOME (sgn * res, src)
		    in
			if isDigit c then digr (hexval c) rest else NONE
		    end
		fun getdigs sgn after0 inp =
		    case dig1 sgn inp of
			NONE => SOME (0, after0)
		      | res => res
		fun hexopt sgn NONE = NONE
		  | hexopt sgn (SOME (#"0", after0)) =
		    if radix <> HEX then getdigs sgn after0 (getc after0)
		    else
			(case getc after0 of
			     NONE => SOME(0, after0)
			   | SOME ((#"x" | #"X"), rest) =>
				 getdigs sgn after0 (getc rest)
			   | inp => getdigs sgn after0 inp)
		  | hexopt sgn inp = dig1 sgn inp
		fun sign NONE = NONE
		  | sign (SOME (#"~", rest)) = hexopt ~1 (getc rest)
		  | sign (SOME (#"-", rest)) = hexopt ~1 (getc rest)
		  | sign (SOME (#"+", rest)) = hexopt 1 (getc rest)
		  | sign inp = hexopt  1 inp
	    in
		sign (skipWSget getc source)
	    end

	__primitive val compare: int * int -> order = "Int.compare"

	__primitive val toString : int -> string = "Int.toString"

	val op>= = op>=
	val op< = op<

	val fromString = scanString (scan DEC)   (*--** crashes *)

	fun min (i, j) = if i > j then j else i
	fun max (i, j) = if i < j then j else i

	fun fromInt i   = i
	fun fromLarge i = i
	fun toLarge i   = i
    end

structure LargeInt = Int

in

signature INTEGER =
    sig
	type int

	val + : int * int -> int
	val >= : int * int -> bool
	val < : int * int -> bool

	val scan:
	    StringCvt.radix -> (char, 'a) StringCvt.reader -> 'a ->
	    (int * 'a) option

	val compare: int * int -> order

	val toString: int -> string

	val fromString: string -> int option

	val min: int * int -> int
	val max: int * int -> int

	val fromInt: Int.int -> int
	val fromLarge: LargeInt.int -> int
	val toLarge: int -> LargeInt.int
    end

structure Int :> INTEGER where type int = int = Int
structure LargeInt :> INTEGER where type int = LargeInt.int = LargeInt

end (* local *)


(* Real *)

structure Real =
    struct
	type real = real

	fun scan(r: (char,'a) StringCvt.reader) = scan r   (*--** *)
	fun toString(x: real) = ""   (*--** *)
	fun fromString(s: string) = NONE (*--** *)
	fun compare(x: real, y:real) = EQUAL (*--** *)
	fun trunc(x: real) = 0 (*--** *)
	fun (x: real) < (y: real) = false (*--** *)
    end

structure LargeReal = Real


(* Array *)

structure Array =
    struct
	__eqtype 'a array

	__primitive val array : int * 'a -> 'a array = "Array.array"
	__primitive val fromList : 'a list -> 'a array = "Array.fromList"
	__primitive val length : 'a array -> int = "Array.length"
	__primitive val sub : 'a array * int -> 'a = "Array.sub"
	__primitive val update : 'a array * int * 'a -> unit = "Array.update"

	fun copy {src, si, len, dst, di} =
	    let
		val bound =
		    case len of
			NONE => length src
		      | SOME n => si + n
		val offset = di - si
		fun copy' i =
		    if i < bound then
			(update (dst, i + offset, sub (src, i));
			 copy' (i + 1))
		    else ()
	    in
		copy' si
	    end

	fun foldl f z a =
	    let
		val n = length a
		fun foldl' (i, z') =
		    if i < n then foldl' (i + 1, f (sub (a, i), z'))
		    else z'
	    in
		foldl' (0, z)
	    end

	fun app f a =
	    let
		val n = length a
		fun app' i =
		    if i < n then (f (sub (a, i)); app' (i + 1))
		    else ()
	    in
		app' 0
	    end
    end

type array = Array.array


(* Vector *)

structure Vector =
    struct
	eqtype 'a vector

	__primitive val fromList : 'a list -> 'a vector = "Vector.fromList"
	__primitive val sub : 'a vector * int -> 'a = "Vector.sub"

	fun tabulate (n, f) = fromList (List.tabulate (n, f))
    end

val vector = Vector.fromList


(* More members exported to toplevel *)

val getOpt = Option.getOpt
val isSome = Option.isSome
val valOf = Option.valOf

val null = List.null
val hd = List.hd
val tl = List.tl
val length = List.length
val rev = List.rev
val op@ = List.@
val app = List.app
val map = List.map
val foldr = List.foldr
val foldl = List.foldl

val ord = Char.ord
val chr = Char.chr

val str = String.str
val size = String.size
val concat = String.concat
val explode = String.explode
val implode = String.implode
val substring = String.substring
val op^ = String.^
(* src # 1 *)
(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 1999
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure Word =
    struct
	type word = word

	local
	    __primitive val fromInt' : int * int -> word = "Word.fromInt'"
	in
	    fun fromInt x = fromInt' (31, x)
	    fun fromLargeInt x = fromInt' (31, x)
	end

	__primitive val toInt : word -> int = "Word.toInt"
	__primitive val toLargeInt : word -> LargeInt.int = "Word.toInt"
	__primitive val toIntX : word -> int = "Word.toIntX"
	__primitive val op+ : word * word -> word = "Word.+"
	__primitive val op- : word * word -> word = "Word.-"
	__primitive val op* : word * word -> word = "Word.*"
	__primitive val op mod : word * word -> word = "Word.mod"
	__primitive val orb : word * word -> word = "Word.orb"
	__primitive val xorb : word * word -> word = "Word.xorb"
	__primitive val andb : word * word -> word = "Word.andb"
	__primitive val notb : word * word -> word = "Word.notb"
	__primitive val op<< : word * word -> word = "Word.<<"
	__primitive val op>> : word * word -> word = "Word.>>"
	__primitive val op~>> : word * word -> word = "Word.~>>"
	__primitive val toString : word -> string = "Word.toString"

	val op>= = op>=

	fun fromLargeWord w = w
	fun toLargeWord w = w

	local
	    open StringCvt
	    fun skipWSget getc source = getc (dropl Char.isSpace getc source)

	    (* Below, 48 = Char.ord #"0" and 55 = Char.ord #"A" - 10. *)
	    fun decval c = fromInt (Char.ord c) - fromInt 48;
	    fun hexval c =
		if Char.ord #"0" <= Char.ord c
		andalso Char.ord c <= Char.ord #"9" then
		    fromInt (Char.ord c) - fromInt 48
		else
		    (fromInt (Char.ord c) - fromInt 55) mod (fromInt 32);
	in
	    fun scan radix getc source =
		let open StringCvt
		    val source = skipWS getc source
		    val (isDigit, factor) =
			case radix of
			    BIN => (fn c => (Char.ord #"0" <= Char.ord c
				    andalso Char.ord c <= Char.ord #"1"),  2)
			  | OCT => (fn c => (Char.ord #"0" <= Char.ord c
				    andalso Char.ord c <= Char.ord #"7"),  8)
			  | DEC => (Char.isDigit,                          10)
			  | HEX => (Char.isHexDigit,                       16)
		    fun dig1 NONE              = NONE
		      | dig1 (SOME (c1, src1)) =
			let fun digr res src =
			    case getc src of
				NONE           => SOME (res, src)
			      | SOME (c, rest) =>
				    if isDigit c then
					digr (fromInt factor * res + hexval c)
					rest
				    else SOME (res, src)
			in
			    if isDigit c1 then digr (hexval c1) src1
			    else NONE
			end
		    fun getdigs after0 src =
			case dig1 (getc src) of
			    NONE => SOME(fromInt 0, after0)
			  | res  => res
		    fun hexprefix after0 src =
			if radix <> HEX then getdigs after0 src
			else
			    case getc src of
				SOME(#"x", rest) => getdigs after0 rest
			      | SOME(#"X", rest) => getdigs after0 rest
			      | SOME _           => getdigs after0 src
			      | NONE => SOME(fromInt 0, after0)
		in
		    case getc source of
			SOME(#"0", after0) =>
			    (case getc after0 of
				 SOME(#"w", src2) => hexprefix after0 src2
			       | SOME _           => hexprefix after0 after0
			       | NONE             => SOME(fromInt 0, after0))
		      | SOME _ => dig1 (getc source)
		      | NONE   => NONE
		end
	end
    end

structure LargeWord = Word
(* src # 2 *)
(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 1999
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure TextIO =
    struct
	type instream
	type outstream

	__primitive val stdIn : instream = "TextIO.stdIn"
	__primitive val openIn : string -> instream = "TextIO.openIn"
	__primitive val inputAll : instream -> string = "TextIO.inputAll"
	__primitive val closeIn : instream -> unit = "TextIO.closeIn"

	__primitive val stdOut : outstream = "TextIO.stdOut"
	__primitive val stdErr : outstream = "TextIO.stdErr"
	__primitive val openOut : string -> outstream = "TextIO.openOut"
	__primitive val output : outstream * string -> unit = "TextIO.output"
	__primitive val output1 : outstream * char -> unit = "TextIO.output1"
	__primitive val closeOut : outstream -> unit = "TextIO.closeOut"

	__primitive val print : string -> unit = "TextIO.print"
    end

val print = TextIO.print
(* src # 3 *)
(* ML-Yacc Parser Generator (c) 1989 Andrew W. Appel, David R. Tarditi 
 *
 * $Log$
 * Revision 1.3  2000-01-07 15:41:40  rossberg
 * Bug fixes in the translation of functors - can bootstrap again.
 *
 * Revision 1.3  1999/11/15 12:21:54  rossberg
 * Reverted to original state because we can deal with sharing now.
 *
 * Revision 1.2  1999/11/02 15:52:03  rossberg
 * Replaced sharing constraints by where constraints. I marked the original
 * code with (*SHAR ...*).
 *
 * Revision 1.1  1999/10/04 09:44:08  kornstae
 * Moved ML-YACC files here from distribution
 *    to give them a unique location for bootstrapping.
 *
 * Revision 1.1.1.1  1997/01/14 01:38:04  george
 *   Version 109.24
 *
 * Revision 1.1.1.1  1996/01/31  16:01:42  george
 * Version 109
 * 
 *)

(* base.sig: Base signature file for SML-Yacc.  This file contains signatures
   that must be loaded before any of the files produced by ML-Yacc are loaded
*)

(* STREAM: signature for a lazy stream.*)

signature STREAM =
 sig type 'xa stream
     val streamify : (unit -> '_a) -> '_a stream
     val cons : '_a * '_a stream -> '_a stream
     val get : '_a stream -> '_a * '_a stream
 end

(* LR_TABLE: signature for an LR Table.

   The list of actions and gotos passed to mkLrTable must be ordered by state
   number. The values for state 0 are the first in the list, the values for
    state 1 are next, etc.
*)

signature LR_TABLE =
    sig
        datatype ('a,'b) pairlist = EMPTY | PAIR of 'a * 'b * ('a,'b) pairlist
	datatype state = STATE of int
	datatype term = T of int
	datatype nonterm = NT of int
	datatype action = SHIFT of state
			| REDUCE of int
			| ACCEPT
			| ERROR
	type table
	
	val numStates : table -> int
	val numRules : table -> int
	val describeActions : table -> state ->
				(term,action) pairlist * action
	val describeGoto : table -> state -> (nonterm,state) pairlist
	val action : table -> state * term -> action
	val goto : table -> state * nonterm -> state
	val initialState : table -> state
	exception Goto of state * nonterm

	val mkLrTable : {actions : ((term,action) pairlist * action) array,
			 gotos : (nonterm,state) pairlist array,
			 numStates : int, numRules : int,
			 initialState : state} -> table
    end

(* TOKEN: signature revealing the internal structure of a token. This signature
   TOKEN distinct from the signature {parser name}_TOKENS produced by ML-Yacc.
   The {parser name}_TOKENS structures contain some types and functions to
    construct tokens from values and positions.

   The representation of token was very carefully chosen here to allow the
   polymorphic parser to work without knowing the types of semantic values
   or line numbers.

   This has had an impact on the TOKENS structure produced by SML-Yacc, which
   is a structure parameter to lexer functors.  We would like to have some
   type 'a token which functions to construct tokens would create.  A
   constructor function for a integer token might be

	  INT: int * 'a * 'a -> 'a token.
 
   This is not possible because we need to have tokens with the representation
   given below for the polymorphic parser.

   Thus our constructur functions for tokens have the form:

	  INT: int * 'a * 'a -> (svalue,'a) token

   This in turn has had an impact on the signature that lexers for SML-Yacc
   must match and the types that a user must declare in the user declarations
   section of lexers.
*)

signature TOKEN =
    sig
	structure LrTable : LR_TABLE
        datatype ('a,'b) token = TOKEN of LrTable.term * ('a * 'b * 'b)
	val sameToken : ('a,'b) token * ('a,'b) token -> bool
    end

(* LR_PARSER: signature for a polymorphic LR parser *)

signature LR_PARSER =
    sig
	structure Stream: STREAM
	structure LrTable : LR_TABLE
	structure Token : TOKEN
	sharing LrTable = Token.LrTable

	exception ParseError

	val parse : {table : LrTable.table,
		     lexer : ('_b,'_c) Token.token Stream.stream,
		     arg: 'arg,
		     saction : int *
			       '_c *
				(LrTable.state * ('_b * '_c * '_c)) list * 
				'arg ->
				     LrTable.nonterm *
				     ('_b * '_c * '_c) *
				     ((LrTable.state *('_b * '_c * '_c)) list),
		     void : '_b,
		     ec : { is_keyword : LrTable.term -> bool,
			    noShift : LrTable.term -> bool,
			    preferred_change : (LrTable.term list * LrTable.term list) list,
			    errtermvalue : LrTable.term -> '_b,
			    showTerminal : LrTable.term -> string,
			    terms: LrTable.term list,
			    error : string * '_c * '_c -> unit
			   },
		     lookahead : int  (* max amount of lookahead used in *)
				      (* error correction *)
			} -> '_b *
			     (('_b,'_c) Token.token Stream.stream)
    end

(* LEXER: a signature that most lexers produced for use with SML-Yacc's
   output will match.  The user is responsible for declaring type token,
   type pos, and type svalue in the UserDeclarations section of a lexer.

   Note that type token is abstract in the lexer.  This allows SML-Yacc to
   create a TOKENS signature for use with lexers produced by ML-Lex that
   treats the type token abstractly.  Lexers that are functors parametrized by
   a Tokens structure matching a TOKENS signature cannot examine the structure
   of tokens.
*)

signature LEXER =
   sig
       structure UserDeclarations :
	   sig
	        type ('a,'b) token
		type pos
		type svalue
	   end
	val makeLexer : (int -> string) -> unit -> 
         (UserDeclarations.svalue,UserDeclarations.pos) UserDeclarations.token
   end

(* ARG_LEXER: the %arg option of ML-Lex allows users to produce lexers which
   also take an argument before yielding a function from unit to a token
*)

signature ARG_LEXER =
   sig
       structure UserDeclarations :
	   sig
	        type ('a,'b) token
		type pos
		type svalue
		type arg
	   end
	val makeLexer : (int -> string) -> UserDeclarations.arg -> unit -> 
         (UserDeclarations.svalue,UserDeclarations.pos) UserDeclarations.token
   end

(* PARSER_DATA: the signature of ParserData structures in {parser name}LrValsFun
   produced by  SML-Yacc.  All such structures match this signature.  

   The {parser name}LrValsFun produces a structure which contains all the values
   except for the lexer needed to call the polymorphic parser mentioned
   before.

*)

signature PARSER_DATA =
   sig
        (* the type of line numbers *)

	type pos

	(* the type of semantic values *)

	type svalue

         (* the type of the user-supplied argument to the parser *)
 	type arg
 
	(* the intended type of the result of the parser.  This value is
	   produced by applying extract from the structure Actions to the
	   final semantic value resultiing from a parse.
	 *)

	type result

	structure LrTable : LR_TABLE
	structure Token : TOKEN
	sharing Token.LrTable = LrTable

	(* structure Actions contains the functions which mantain the
	   semantic values stack in the parser.  Void is used to provide
	   a default value for the semantic stack.
	 *)

	structure Actions : 
	  sig
	      val actions : int * pos *
		   (LrTable.state * (svalue * pos * pos)) list * arg->
		         LrTable.nonterm * (svalue * pos * pos) *
			 ((LrTable.state *(svalue * pos * pos)) list)
	      val void : svalue
	      val extract : svalue -> result
	  end

	(* structure EC contains information used to improve error
	   recovery in an error-correcting parser *)

	structure EC :
	   sig
	     val is_keyword : LrTable.term -> bool
	     val noShift : LrTable.term -> bool
 	     val preferred_change : (LrTable.term list * LrTable.term list) list
	     val errtermvalue : LrTable.term -> svalue
	     val showTerminal : LrTable.term -> string
	     val terms: LrTable.term list
	   end

	(* table is the LR table for the parser *)

	val table : LrTable.table
    end

(* signature PARSER is the signature that most user parsers created by 
   SML-Yacc will match.
*)

signature PARSER =
    sig
        structure Token : TOKEN
	structure Stream : STREAM
	exception ParseError

	(* type pos is the type of line numbers *)

	type pos

	(* type result is the type of the result from the parser *)

	type result

         (* the type of the user-supplied argument to the parser *)
 	type arg
	
	(* type svalue is the type of semantic values for the semantic value
	   stack
	 *)

	type svalue

	(* val makeLexer is used to create a stream of tokens for the parser *)

	val makeLexer : (int -> string) ->
			 (svalue,pos) Token.token Stream.stream

	(* val parse takes a stream of tokens and a function to print
	   errors and returns a value of type result and a stream containing
	   the unused tokens
	 *)

	val parse : int * ((svalue,pos) Token.token Stream.stream) *
		    (string * pos * pos -> unit) * arg ->
				result * (svalue,pos) Token.token Stream.stream

	val sameToken : (svalue,pos) Token.token * (svalue,pos) Token.token ->
				bool
     end

(* signature ARG_PARSER is the signature that will be matched by parsers whose
    lexer takes an additional argument.
*)

signature ARG_PARSER = 
    sig
        structure Token : TOKEN
	structure Stream : STREAM
	exception ParseError

	type arg
	type lexarg
	type pos
	type result
	type svalue

	val makeLexer : (int -> string) -> lexarg ->
			 (svalue,pos) Token.token Stream.stream
	val parse : int * ((svalue,pos) Token.token Stream.stream) *
		    (string * pos * pos -> unit) * arg ->
				result * (svalue,pos) Token.token Stream.stream

	val sameToken : (svalue,pos) Token.token * (svalue,pos) Token.token ->
				bool
     end

(* src # 4 *)
(* ML-Yacc Parser Generator (c) 1989 Andrew W. Appel, David R. Tarditi 
 *
 * $Log$
 * Revision 1.3  2000-01-07 15:41:40  rossberg
 * Bug fixes in the translation of functors - can bootstrap again.
 *
 * Revision 1.4  1999/11/15 12:21:54  rossberg
 * Reverted to original state because we can deal with sharing now.
 *
 * Revision 1.3  1999/11/02 16:09:35  rossberg
 * Ups.
 *
 * Revision 1.2  1999/11/02 15:52:03  rossberg
 * Replaced sharing constraints by where constraints. I marked the original
 * code with (*SHAR ...*).
 *
 * Revision 1.1  1999/10/04 09:44:08  kornstae
 * Moved ML-YACC files here from distribution
 *    to give them a unique location for bootstrapping.
 *
 * Revision 1.1.1.1  1997/01/14 01:38:04  george
 *   Version 109.24
 *
 * Revision 1.1.1.1  1996/01/31  16:01:42  george
 * Version 109
 * 
 *)

(* functor Join creates a user parser by putting together a Lexer structure,
   an LrValues structure, and a polymorphic parser structure.  Note that
   the Lexer and LrValues structure must share the type pos (i.e. the type
   of line numbers), the type svalues for semantic values, and the type
   of tokens.
*)

functor Join(structure Lex : LEXER
	     structure ParserData: PARSER_DATA
	     structure LrParser : LR_PARSER
	     sharing ParserData.LrTable = LrParser.LrTable
	     sharing ParserData.Token = LrParser.Token
	     sharing type Lex.UserDeclarations.svalue = ParserData.svalue
	     sharing type Lex.UserDeclarations.pos = ParserData.pos
	     sharing type Lex.UserDeclarations.token = ParserData.Token.token
)
		 : PARSER =
struct
    structure Token = ParserData.Token
    structure Stream = LrParser.Stream
 
    exception ParseError = LrParser.ParseError

    type arg = ParserData.arg
    type pos = ParserData.pos
    type result = ParserData.result
    type svalue = ParserData.svalue
    val makeLexer = LrParser.Stream.streamify o Lex.makeLexer
    val parse = fn (lookahead,lexer,error,arg) =>
	(fn (a,b) => (ParserData.Actions.extract a,b))
     (LrParser.parse {table = ParserData.table,
	        lexer=lexer,
		lookahead=lookahead,
		saction = ParserData.Actions.actions,
		arg=arg,
		void= ParserData.Actions.void,
	        ec = {is_keyword = ParserData.EC.is_keyword,
		      noShift = ParserData.EC.noShift,
		      preferred_change = ParserData.EC.preferred_change,
		      errtermvalue = ParserData.EC.errtermvalue,
		      error=error,
		      showTerminal = ParserData.EC.showTerminal,
		      terms = ParserData.EC.terms}}
      )
     val sameToken = Token.sameToken
end

(* functor JoinWithArg creates a variant of the parser structure produced 
   above.  In this case, the makeLexer take an additional argument before
   yielding a value of type unit -> (svalue,pos) token
 *)

functor JoinWithArg(structure Lex : ARG_LEXER
	     structure ParserData: PARSER_DATA
	     structure LrParser : LR_PARSER
	     sharing ParserData.LrTable = LrParser.LrTable
	     sharing ParserData.Token = LrParser.Token
	     sharing type Lex.UserDeclarations.svalue = ParserData.svalue
	     sharing type Lex.UserDeclarations.pos = ParserData.pos
	     sharing type Lex.UserDeclarations.token = ParserData.Token.token
)
		 : ARG_PARSER  =
struct
    structure Token = ParserData.Token
    structure Stream = LrParser.Stream

    exception ParseError = LrParser.ParseError

    type arg = ParserData.arg
    type lexarg = Lex.UserDeclarations.arg
    type pos = ParserData.pos
    type result = ParserData.result
    type svalue = ParserData.svalue

    val makeLexer = fn s => fn arg =>
		 LrParser.Stream.streamify (Lex.makeLexer s arg)
    val parse = fn (lookahead,lexer,error,arg) =>
	(fn (a,b) => (ParserData.Actions.extract a,b))
     (LrParser.parse {table = ParserData.table,
	        lexer=lexer,
		lookahead=lookahead,
		saction = ParserData.Actions.actions,
		arg=arg,
		void= ParserData.Actions.void,
	        ec = {is_keyword = ParserData.EC.is_keyword,
		      noShift = ParserData.EC.noShift,
		      preferred_change = ParserData.EC.preferred_change,
		      errtermvalue = ParserData.EC.errtermvalue,
		      error=error,
		      showTerminal = ParserData.EC.showTerminal,
		      terms = ParserData.EC.terms}}
      )
    val sameToken = Token.sameToken
end;
(* src # 5 *)
(* ML-Yacc Parser Generator (c) 1989 Andrew W. Appel, David R. Tarditi 
 *
 * $Log$
 * Revision 1.3  2000-01-07 15:41:40  rossberg
 * Bug fixes in the translation of functors - can bootstrap again.
 *
 * Revision 1.1  1999/10/04 09:44:08  kornstae
 * Moved ML-YACC files here from distribution
 *    to give them a unique location for bootstrapping.
 *
 * Revision 1.1.1.1  1997/01/14 01:38:04  george
 *   Version 109.24
 *
 * Revision 1.1.1.1  1996/01/31  16:01:42  george
 * Version 109
 * 
 *)

structure LrTable : LR_TABLE = 
    struct
	open Array List
	infix 9 sub
	datatype ('a,'b) pairlist = EMPTY
				  | PAIR of 'a * 'b * ('a,'b) pairlist
	datatype term = T of int
	datatype nonterm = NT of int
	datatype state = STATE of int
	datatype action = SHIFT of state
			| REDUCE of int (* rulenum from grammar *)
			| ACCEPT
			| ERROR
	exception Goto of state * nonterm
	type table = {states: int, rules : int,initialState: state,
		      action: ((term,action) pairlist * action) array,
		      goto :  (nonterm,state) pairlist array}
	val numStates = fn ({states,...} : table) => states
	val numRules = fn ({rules,...} : table) => rules
	val describeActions =
	   fn ({action,...} : table) => 
	           fn (STATE s) => action sub s
	val describeGoto =
	   fn ({goto,...} : table) =>
	           fn (STATE s) => goto sub s
	fun findTerm (T term,row,default) =
	    let fun find (PAIR (T key,data,r)) =
		       if key < term then find r
		       else if key=term then data
		       else default
		   | find EMPTY = default
	    in find row
	    end
	fun findNonterm (NT nt,row) =
	    let fun find (PAIR (NT key,data,r)) =
		       if key < nt then find r
		       else if key=nt then SOME data
		       else NONE
		   | find EMPTY = NONE
	    in find row
	    end
	val action = fn ({action,...} : table) =>
		fn (STATE state,term) =>
		  let val (row,default) = action sub state
		  in findTerm(term,row,default)
		  end
	val goto = fn ({goto,...} : table) =>
			fn (a as (STATE state,nonterm)) =>
			  case findNonterm(nonterm,goto sub state)
			  of SOME state => state
			   | NONE => raise (Goto a)
	val initialState = fn ({initialState,...} : table) => initialState
	val mkLrTable = fn {actions,gotos,initialState,numStates,numRules} =>
	     ({action=actions,goto=gotos,
	       states=numStates,
	       rules=numRules,
               initialState=initialState} : table)
end;
(* src # 6 *)
(* ML-Yacc Parser Generator (c) 1989 Andrew W. Appel, David R. Tarditi 
 *
 * $Log$
 * Revision 1.3  2000-01-07 15:41:40  rossberg
 * Bug fixes in the translation of functors - can bootstrap again.
 *
 * Revision 1.1  1999/10/04 09:44:08  kornstae
 * Moved ML-YACC files here from distribution
 *    to give them a unique location for bootstrapping.
 *
 * Revision 1.2  1997/08/26 19:18:55  jhr
 *   Replaced used of "abstraction" with ":>".
 *
# Revision 1.1.1.1  1997/01/14  01:38:04  george
#   Version 109.24
#
 * Revision 1.1.1.1  1996/01/31  16:01:43  george
 * Version 109
 * 
 *)

(* Stream: a structure implementing a lazy stream.  The signature STREAM
   is found in base.sig *)

structure Stream :> STREAM =
struct
   datatype 'a str = EVAL of 'a * 'a str ref | UNEVAL of (unit->'a)

   type 'a stream = 'a str ref

   fun get(ref(EVAL t)) = t
     | get(s as ref(UNEVAL f)) = 
	    let val t = (f(), ref(UNEVAL f)) in s := EVAL t; t end

   fun streamify f = ref(UNEVAL f)
   fun cons(a,s) = ref(EVAL(a,s))

end;
(* src # 7 *)
(* ML-Yacc Parser Generator (c) 1989 Andrew W. Appel, David R. Tarditi 
 *
 * $Log$
 * Revision 1.3  2000-01-07 15:41:40  rossberg
 * Bug fixes in the translation of functors - can bootstrap again.
 *
 * Revision 1.1  1999/10/04 09:44:08  kornstae
 * Moved ML-YACC files here from distribution
 *    to give them a unique location for bootstrapping.
 *
 * Revision 1.2  1997/08/26 19:18:54  jhr
 *   Replaced used of "abstraction" with ":>".
 *
# Revision 1.1.1.1  1997/01/14  01:38:04  george
#   Version 109.24
#
 * Revision 1.3  1996/10/03  03:36:58  jhr
 * Qualified identifiers that are no-longer top-level (quot, rem, min, max).
 *
 * Revision 1.2  1996/02/26  15:02:29  george
 *    print no longer overloaded.
 *    use of makestring has been removed and replaced with Int.toString ..
 *    use of IO replaced with TextIO
 *
 * Revision 1.1.1.1  1996/01/31  16:01:42  george
 * Version 109
 * 
 *)

(* parser.sml:  This is a parser driver for LR tables with an error-recovery
   routine added to it.  The routine used is described in detail in this
   article:

	'A Practical Method for LR and LL Syntactic Error Diagnosis and
	 Recovery', by M. Burke and G. Fisher, ACM Transactions on
	 Programming Langauges and Systems, Vol. 9, No. 2, April 1987,
	 pp. 164-197.

    This program is an implementation is the partial, deferred method discussed
    in the article.  The algorithm and data structures used in the program
    are described below.  

    This program assumes that all semantic actions are delayed.  A semantic
    action should produce a function from unit -> value instead of producing the
    normal value.  The parser returns the semantic value on the top of the
    stack when accept is encountered.  The user can deconstruct this value
    and apply the unit -> value function in it to get the answer.

    It also assumes that the lexer is a lazy stream.

    Data Structures:
    ----------------
	
	* The parser:

	   The state stack has the type

		 (state * (semantic value * line # * line #)) list

	   The parser keeps a queue of (state stack * lexer pair).  A lexer pair
	 consists of a terminal * value pair and a lexer.  This allows the 
	 parser to reconstruct the states for terminals to the left of a
	 syntax error, and attempt to make error corrections there.

	   The queue consists of a pair of lists (x,y).  New additions to
	 the queue are cons'ed onto y.  The first element of x is the top
	 of the queue.  If x is nil, then y is reversed and used
	 in place of x.

    Algorithm:
    ----------

	* The steady-state parser:  

	    This parser keeps the length of the queue of state stacks at
	a steady state by always removing an element from the front when
	another element is placed on the end.

	    It has these arguments:

	   stack: current stack
	   queue: value of the queue
	   lexPair ((terminal,value),lex stream)

	When SHIFT is encountered, the state to shift to and the value are
	are pushed onto the state stack.  The state stack and lexPair are
	placed on the queue.  The front element of the queue is removed.

	When REDUCTION is encountered, the rule is applied to the current
	stack to yield a triple (nonterm,value,new stack).  A new
	stack is formed by adding (goto(top state of stack,nonterm),value)
	to the stack.

	When ACCEPT is encountered, the top value from the stack and the
	lexer are returned.

	When an ERROR is encountered, fixError is called.  FixError
	takes the arguments to the parser, fixes the error if possible and
        returns a new set of arguments.

	* The distance-parser:

	This parser includes an additional argument distance.  It pushes
	elements on the queue until it has parsed distance tokens, or an
	ACCEPT or ERROR occurs.  It returns a stack, lexer, the number of
	tokens left unparsed, a queue, and an action option.
*)

signature FIFO = 
  sig type 'a queue
      val empty : 'a queue
      exception Empty
      val get : 'a queue -> 'a * 'a queue
      val put : 'a * 'a queue -> 'a queue
  end

(* drt (12/15/89) -- the functor should be used in development work, but
   it wastes space in the release version.

functor ParserGen(structure LrTable : LR_TABLE
		  structure Stream : STREAM) : LR_PARSER =
*)

structure LrParser :> LR_PARSER =
   struct
      structure LrTable = LrTable
      structure Stream = Stream

      structure Token : TOKEN =
	struct
	    structure LrTable = LrTable
	    datatype ('a,'b) token = TOKEN of LrTable.term * ('a * 'b * 'b)
	    val sameToken = fn (TOKEN(t,_),TOKEN(t',_)) => t=t'
        end

      open LrTable
      open Token

      val DEBUG1 = false
      val DEBUG2 = false
      exception ParseError
      exception ParseImpossible of int

      structure Fifo :> FIFO =
        struct
	  type 'a queue = ('a list * 'a list)
	  val empty = (nil,nil)
	  exception Empty
	  fun get(a::x, y) = (a, (x,y))
	    | get(nil, nil) = raise Empty
	    | get(nil, y) = get(rev y, nil)
 	  fun put(a,(x,y)) = (x,a::y)
        end

      type ('a,'b) elem = (state * ('a * 'b * 'b))
      type ('a,'b) stack = ('a,'b) elem list
      type ('a,'b) lexv = ('a,'b) token
      type ('a,'b) lexpair = ('a,'b) lexv * (('a,'b) lexv Stream.stream)
      type ('a,'b) distanceParse =
		 ('a,'b) lexpair *
		 ('a,'b) stack * 
		 (('a,'b) stack * ('a,'b) lexpair) Fifo.queue *
		 int ->
		   ('a,'b) lexpair *
		   ('a,'b) stack * 
		   (('a,'b) stack * ('a,'b) lexpair) Fifo.queue *
		   int *
		   action option

      type ('a,'b) ecRecord =
	 {is_keyword : term -> bool,
          preferred_change : (term list * term list) list,
	  error : string * 'b * 'b -> unit,
	  errtermvalue : term -> 'a,
	  terms : term list,
	  showTerminal : term -> string,
	  noShift : term -> bool}

      local 
	 val print = fn s => TextIO.output(TextIO.stdOut,s)
	 val println = fn s => (print s; print "\n")
	 val showState = fn (STATE s) => "STATE " ^ (Int.toString s)
      in
        fun printStack(stack: ('a,'b) stack, n: int) =
         case stack
           of (state,_) :: rest =>
                 (print("\t" ^ Int.toString n ^ ": ");
                  println(showState state);
                  printStack(rest, n+1))
            | nil => ()
                
        fun prAction showTerminal
		 (stack as (state,_) :: _, next as (TOKEN (term,_),_), action) =
             (println "Parse: state stack:";
              printStack(stack, 0);
              print("       state="
                         ^ showState state	
                         ^ " next="
                         ^ showTerminal term
                         ^ " action="
                        );
              case action
                of SHIFT state => println ("SHIFT " ^ (showState state))
                 | REDUCE i => println ("REDUCE " ^ (Int.toString i))
                 | ERROR => println "ERROR"
		 | ACCEPT => println "ACCEPT")
        | prAction _ (_,_,action) = ()
     end

    (* ssParse: parser which maintains the queue of (state * lexvalues) in a
	steady-state.  It takes a table, showTerminal function, saction
	function, and fixError function.  It parses until an ACCEPT is
	encountered, or an exception is raised.  When an error is encountered,
	fixError is called with the arguments of parseStep (lexv,stack,and
	queue).  It returns the lexv, and a new stack and queue adjusted so
	that the lexv can be parsed *)
	
    val ssParse =
      fn (table,showTerminal,saction,fixError,arg) =>
	let val prAction = prAction showTerminal
	    val action = LrTable.action table
	    val goto = LrTable.goto table
	    fun parseStep(args as
			 (lexPair as (TOKEN (terminal, value as (_,leftPos,_)),
				      lexer
				      ),
			  stack as (state,_) :: _,
			  queue)) =
	      let val nextAction = action (state,terminal)
	          val _ = if DEBUG1 then prAction(stack,lexPair,nextAction)
			  else ()
	      in case nextAction
		 of SHIFT s =>
		  let val newStack = (s,value) :: stack
		      val newLexPair = Stream.get lexer
		      val (_,newQueue) =Fifo.get(Fifo.put((newStack,newLexPair),
							    queue))
		  in parseStep(newLexPair,(s,value)::stack,newQueue)
		  end
		 | REDUCE i =>
		     (case saction(i,leftPos,stack,arg)
		      of (nonterm,value,stack as (state,_) :: _) =>
		          parseStep(lexPair,(goto(state,nonterm),value)::stack,
				    queue)
		       | _ => raise (ParseImpossible 197))
		 | ERROR => parseStep(fixError args)
		 | ACCEPT => 
			(case stack
			 of (_,(topvalue,_,_)) :: _ =>
				let val (token,restLexer) = lexPair
				in (topvalue,Stream.cons(token,restLexer))
				end
			  | _ => raise (ParseImpossible 202))
	      end
	    | parseStep _ = raise (ParseImpossible 204)
	in parseStep
	end

    (*  distanceParse: parse until n tokens are shifted, or accept or
	error are encountered.  Takes a table, showTerminal function, and
	semantic action function.  Returns a parser which takes a lexPair
	(lex result * lexer), a state stack, a queue, and a distance
	(must be > 0) to parse.  The parser returns a new lex-value, a stack
	with the nth token shifted on top, a queue, a distance, and action
	option. *)

    val distanceParse =
      fn (table,showTerminal,saction,arg) =>
	let val prAction = prAction showTerminal
	    val action = LrTable.action table
	    val goto = LrTable.goto table
	    fun parseStep(lexPair,stack,queue,0) = (lexPair,stack,queue,0,NONE)
	      | parseStep(lexPair as (TOKEN (terminal, value as (_,leftPos,_)),
				      lexer
				     ),
			  stack as (state,_) :: _,
			  queue,distance) =
	      let val nextAction = action(state,terminal)
	          val _ = if DEBUG1 then prAction(stack,lexPair,nextAction)
			  else ()
	      in case nextAction
		 of SHIFT s =>
		  let val newStack = (s,value) :: stack
		      val newLexPair = Stream.get lexer
		  in parseStep(newLexPair,(s,value)::stack,
			       Fifo.put((newStack,newLexPair),queue),distance-1)
		  end
		 | REDUCE i =>
		    (case saction(i,leftPos,stack,arg)
		      of (nonterm,value,stack as (state,_) :: _) =>
		         parseStep(lexPair,(goto(state,nonterm),value)::stack,
				 queue,distance)
		      | _ => raise (ParseImpossible 240))
		 | ERROR => (lexPair,stack,queue,distance,SOME nextAction)
		 | ACCEPT => (lexPair,stack,queue,distance,SOME nextAction)
	      end
	   | parseStep _ = raise (ParseImpossible 242)
	in parseStep : ('_a,'_b) distanceParse 
	end

(* mkFixError: function to create fixError function which adjusts parser state
   so that parse may continue in the presence of an error *)

fun mkFixError({is_keyword,terms,errtermvalue,
	      preferred_change,noShift,
	      showTerminal,error,...} : ('_a,'_b) ecRecord,
	     distanceParse : ('_a,'_b) distanceParse,
	     minAdvance,maxAdvance) 

            (lexv as (TOKEN (term,value as (_,leftPos,_)),_),stack,queue) =
    let val _ = if DEBUG2 then
			error("syntax error found at " ^ (showTerminal term),
			      leftPos,leftPos)
		else ()

        fun tokAt(t,p) = TOKEN(t,(errtermvalue t,p,p))

	val minDelta = 3

	(* pull all the state * lexv elements from the queue *)

	val stateList = 
	   let fun f q = let val (elem,newQueue) = Fifo.get q
			 in elem :: (f newQueue)
			 end handle Fifo.Empty => nil
	   in f queue
	   end

	(* now number elements of stateList, giving distance from
	   error token *)

	val (_, numStateList) =
	      List.foldr (fn (a,(num,r)) => (num+1,(a,num)::r)) (0, []) stateList

	(* Represent the set of potential changes as a linked list.

	   Values of datatype Change hold information about a potential change.

	   oper = oper to be applied
	   pos = the # of the element in stateList that would be altered.
	   distance = the number of tokens beyond the error token which the
	     change allows us to parse.
	   new = new terminal * value pair at that point
	   orig = original terminal * value pair at the point being changed.
	 *)

	datatype ('a,'b) change = CHANGE of
	   {pos : int, distance : int, leftPos: 'b, rightPos: 'b,
	    new : ('a,'b) lexv list, orig : ('a,'b) lexv list}


         val showTerms = concat o map (fn TOKEN(t,_) => " " ^ showTerminal t)

	 val printChange = fn c =>
	  let val CHANGE {distance,new,orig,pos,...} = c
	  in (print ("{distance= " ^ (Int.toString distance));
	      print (",orig ="); print(showTerms orig);
	      print (",new ="); print(showTerms new);
	      print (",pos= " ^ (Int.toString pos));
	      print "}\n")
	  end

	val printChangeList = app printChange

(* parse: given a lexPair, a stack, and the distance from the error
   token, return the distance past the error token that we are able to parse.*)

	fun parse (lexPair,stack,queuePos : int) =
	    case distanceParse(lexPair,stack,Fifo.empty,queuePos+maxAdvance+1)
             of (_,_,_,distance,SOME ACCEPT) => 
		        if maxAdvance-distance-1 >= 0 
			    then maxAdvance 
			    else maxAdvance-distance-1
	      | (_,_,_,distance,_) => maxAdvance - distance - 1

(* catList: concatenate results of scanning list *)

	fun catList l f = List.foldr (fn(a,r)=> f a @ r) [] l

        fun keywordsDelta new = if List.exists (fn(TOKEN(t,_))=>is_keyword t) new
	               then minDelta else 0

        fun tryChange{lex,stack,pos,leftPos,rightPos,orig,new} =
	     let val lex' = List.foldr (fn (t',p)=>(t',Stream.cons p)) lex new
		 val distance = parse(lex',stack,pos+length new-length orig)
	      in if distance >= minAdvance + keywordsDelta new 
		   then [CHANGE{pos=pos,leftPos=leftPos,rightPos=rightPos,
				distance=distance,orig=orig,new=new}] 
		   else []
	     end


(* tryDelete: Try to delete n terminals.
              Return single-element [success] or nil.
	      Do not delete unshiftable terminals. *)


    fun tryDelete n ((stack,lexPair as (TOKEN(term,(_,l,r)),_)),qPos) =
	let fun del(0,accum,left,right,lexPair) =
	          tryChange{lex=lexPair,stack=stack,
			    pos=qPos,leftPos=left,rightPos=right,
			    orig=rev accum, new=[]}
	      | del(n,accum,left,right,(tok as TOKEN(term,(_,_,r)),lexer)) =
		   if noShift term then []
		   else del(n-1,tok::accum,left,r,Stream.get lexer)
         in del(n,[],l,r,lexPair)
        end

(* tryInsert: try to insert tokens before the current terminal;
       return a list of the successes  *)

        fun tryInsert((stack,lexPair as (TOKEN(_,(_,l,_)),_)),queuePos) =
	       catList terms (fn t =>
		 tryChange{lex=lexPair,stack=stack,
			   pos=queuePos,orig=[],new=[tokAt(t,l)],
			   leftPos=l,rightPos=l})
			      
(* trySubst: try to substitute tokens for the current terminal;
       return a list of the successes  *)

        fun trySubst ((stack,lexPair as (orig as TOKEN (term,(_,l,r)),lexer)),
		      queuePos) =
	      if noShift term then []
	      else
		  catList terms (fn t =>
		      tryChange{lex=Stream.get lexer,stack=stack,
				pos=queuePos,
				leftPos=l,rightPos=r,orig=[orig],
				new=[tokAt(t,r)]})

     (* do_delete(toks,lexPair) tries to delete tokens "toks" from "lexPair".
         If it succeeds, returns SOME(toks',l,r,lp), where
	     toks' is the actual tokens (with positions and values) deleted,
	     (l,r) are the (leftmost,rightmost) position of toks', 
	     lp is what remains of the stream after deletion 
     *)
        fun do_delete(nil,lp as (TOKEN(_,(_,l,_)),_)) = SOME(nil,l,l,lp)
          | do_delete([t],(tok as TOKEN(t',(_,l,r)),lp')) =
	       if t=t'
		   then SOME([tok],l,r,Stream.get lp')
                   else NONE
          | do_delete(t::rest,(tok as TOKEN(t',(_,l,r)),lp')) =
	       if t=t'
		   then case do_delete(rest,Stream.get lp')
                         of SOME(deleted,l',r',lp'') =>
			       SOME(tok::deleted,l,r',lp'')
			  | NONE => NONE
		   else NONE
			     
        fun tryPreferred((stack,lexPair),queuePos) =
	    catList preferred_change (fn (delete,insert) =>
	       if List.exists noShift delete then [] (* should give warning at
						 parser-generation time *)
               else case do_delete(delete,lexPair)
                     of SOME(deleted,l,r,lp) => 
			    tryChange{lex=lp,stack=stack,pos=queuePos,
				      leftPos=l,rightPos=r,orig=deleted,
				      new=map (fn t=>(tokAt(t,r))) insert}
		      | NONE => [])

	val changes = catList numStateList tryPreferred @
	                catList numStateList tryInsert @
			  catList numStateList trySubst @
			    catList numStateList (tryDelete 1) @
			      catList numStateList (tryDelete 2) @
			        catList numStateList (tryDelete 3)

	val findMaxDist = fn l => 
	  foldr (fn (CHANGE {distance,...},high) => Int.max(distance,high)) 0 l

(* maxDist: max distance past error taken that we could parse *)

	val maxDist = findMaxDist changes

(* remove changes which did not parse maxDist tokens past the error token *)

        val changes = catList changes 
	      (fn(c as CHANGE{distance,...}) => 
		  if distance=maxDist then [c] else [])

      in case changes 
	  of (l as change :: _) =>
	      let fun print_msg (CHANGE {new,orig,leftPos,rightPos,...}) =
		  let val s = 
		      case (orig,new)
			  of (_::_,[]) => "deleting " ^ (showTerms orig)
	                   | ([],_::_) => "inserting " ^ (showTerms new)
			   | _ => "replacing " ^ (showTerms orig) ^
				 " with " ^ (showTerms new)
		  in error ("syntax error: " ^ s,leftPos,rightPos)
		  end
		   
		  val _ = 
		      (if length l > 1 andalso DEBUG2 then
			   (print "multiple fixes possible; could fix it by:\n";
			    app print_msg l;
			    print "chosen correction:\n")
		       else ();
		       print_msg change)

		  (* findNth: find nth queue entry from the error
		   entry.  Returns the Nth queue entry and the  portion of
		   the queue from the beginning to the nth-1 entry.  The
		   error entry is at the end of the queue.

		   Examples:

		   queue = a b c d e
		   findNth 0 = (e,a b c d)
		   findNth 1 =  (d,a b c)
		   *)

		  val findNth = fn n =>
		      let fun f (h::t,0) = (h,rev t)
			    | f (h::t,n) = f(t,n-1)
			    | f (nil,_) = let exception FindNth
					  in raise FindNth
					  end
		      in f (rev stateList,n)
		      end
		
		  val CHANGE {pos,orig,new,...} = change
		  val (last,queueFront) = findNth pos
		  val (stack,lexPair) = last

		  val lp1 = foldl(fn (_,(_,r)) => Stream.get r) lexPair orig
		  val lp2 = foldr(fn(t,r)=>(t,Stream.cons r)) lp1 new

		  val restQueue = 
		      Fifo.put((stack,lp2),
			       foldl Fifo.put Fifo.empty queueFront)

		  val (lexPair,stack,queue,_,_) =
		      distanceParse(lp2,stack,restQueue,pos)

	      in (lexPair,stack,queue)
	      end
	| nil => (error("syntax error found at " ^ (showTerminal term),
			leftPos,leftPos); raise ParseError)
    end

   val parse = fn {arg,table,lexer,saction,void,lookahead,
		   ec=ec as {showTerminal,...} : ('_a,'_b) ecRecord} =>
	let val distance = 15   (* defer distance tokens *)
	    val minAdvance = 1  (* must parse at least 1 token past error *)
	    val maxAdvance = Int.max(lookahead,0)(* max distance for parse check *)
	    val lexPair = Stream.get lexer
	    val (TOKEN (_,(_,leftPos,_)),_) = lexPair
	    val startStack = [(initialState table,(void,leftPos,leftPos))]
	    val startQueue = Fifo.put((startStack,lexPair),Fifo.empty)
	    val distanceParse = distanceParse(table,showTerminal,saction,arg)
	    val fixError = mkFixError(ec,distanceParse,minAdvance,maxAdvance)
	    val ssParse = ssParse(table,showTerminal,saction,fixError,arg)
	    fun loop (lexPair,stack,queue,_,SOME ACCEPT) =
		   ssParse(lexPair,stack,queue)
	      | loop (lexPair,stack,queue,0,_) = ssParse(lexPair,stack,queue)
	      | loop (lexPair,stack,queue,distance,SOME ERROR) =
		 let val (lexPair,stack,queue) = fixError(lexPair,stack,queue)
		 in loop (distanceParse(lexPair,stack,queue,distance))
		 end
	      | loop _ = let exception ParseInternal
			 in raise ParseInternal
			 end
	in loop (distanceParse(lexPair,startStack,startQueue,distance))
	end
 end;

(* drt (12/15/89) -- needed only when the code above is functorized

structure LrParser = ParserGen(structure LrTable=LrTable
			     structure Stream=Stream);
*)
(* src # 8 *)
(* This is a hack for SML/NJ until we are bootstrapped. Use
	Assert.assert(exp)
   for assertions and
	raise Assert.failure
   for definite failures.

   In Stockhausen assert will be a toplevel builtin (probably a keyword).
   Its type will be bool -> 'a (delivering a NoGood on return). Definite
   failures can then be written as
	assert false
   (very similar to O'Caml).

   Another design would be to have a derived form
	assert exp of pat => exp
   which is a derived form for
	case exp of pat => exp | _ => raise Assert(_)
   and an additional derived form
	assert exp => exp
   which expands to
	assert exp of true => exp
   (very much like if expands to case). But how could definite failure fit
   into this?
*)

structure Assert =
  struct

    exception Assert of string * int * int	(* (file, line, column) *)

    val failure = Assert("?", 0, 0)

    fun assert true  = ()
      | assert false = raise failure

  end
(* src # 9 *)
signature HASH_KEY =
  sig
    eqtype t
    val hash :  t -> int
  end
(* src # 10 *)
structure StringHashKey : HASH_KEY =
  struct

    type t = string

    open Word
    infix << >> andb xorb

    fun hash s =	(* hashpjw [Aho/Sethi/Ullman "Compilers"] *)
	let
	    val n = String.size s

	    fun iter(i,h) =
		if i = n then h else
		let
		    val c  = fromInt(Char.ord(String.sub(s,i)))
		    val h' = (h << 0w4) + c
		    val g  = h' andb 0wxf00000
		in
		    iter(Int.+(i,1), h' xorb g xorb (g >> 0w16))
		end
	in
	    toInt(iter(0,0w0))
	end
    
  end
(* src # 11 *)
(* Fake Wide{Char,String} structures, coz they are missing in SML/NJ *)

structure WideChar   = Char
structure WideString = String
(* src # 12 *)
(*
 * Stuff that should be in the standard structures.
 *)

signature MISC =
  sig

    val General_swap :	'a ref * 'a ref -> unit

    val Option_isNone :	'a option -> bool
    val Option_app :	('a -> unit) -> 'a option -> unit
    val Option_fold :	('a * 'b -> 'b) -> 'b -> 'a option -> 'b

    val List_appr :	('a -> unit) -> 'a list -> unit

    val ListPair_find :	('a * 'b -> bool) -> 'a list * 'b list -> ('a * 'b) option

    val Array_all :	('a -> bool) -> 'a array -> bool
    val Array_exists :	('a -> bool) -> 'a array -> bool

    val Char_toWide :		Char.char -> WideChar.char
    val Char_fromWide :		WideChar.char -> Char.char	(* Chr *)

    val String_toWide :		String.string -> WideString.string
    val String_fromWide :	WideString.string -> String.string (* Chr *)

  end
(* src # 13 *)
(*
 * Stuff that should be in the standard structures.
 *)

structure Misc :> MISC =
  struct

    fun General_swap(r1 as ref x1, r2 as ref x2) =
	( r1 := x2 ; r2 := x1 )

    fun Option_isNone NONE		= true
      | Option_isNone  _		= false

    fun Option_app f  NONE		= ()
      | Option_app f (SOME x)		= f x

    fun Option_fold f b  NONE		= b
      | Option_fold f b (SOME a)	= f(a,b)


    fun List_appr f  nil		= ()
      | List_appr f (x::xs)		= ( List_appr f xs ; f x )

    fun ListPair_find f (nil,_)		= NONE
      | ListPair_find f (_,nil)		= NONE
      | ListPair_find f (x::xs, y::ys)	= if f(x,y) then SOME(x,y)
						    else ListPair_find f (xs,ys)


    fun Array_all p a			= let val size   = Array.length a
					      fun iter i =
						  if i = size then true
				  		  else p(Array.sub(a,i))
							andalso iter(i+1)
					  in iter 0 end

    fun Array_exists p a		= let val size   = Array.length a
					      fun iter i =
						  if i = size then false
				  		  else p(Array.sub(a,i))
							orelse iter(i+1)
					  in iter 0 end

    val Char_toWide	= WideChar.chr o Char.ord
    val Char_fromWide	= Char.chr o WideChar.ord
    val String_toWide	= WideString.implode o List.map Char_toWide o String.explode
    val String_fromWide	= String.implode o List.map Char_fromWide o WideString.explode

  end
(* src # 14 *)
signature IMP_SET =
  sig

    eqtype item
    type set
    type t = set

    exception Delete    of item
    exception Collision of item

    val new :		unit -> set
    val copy :		set -> set

    val delete :	set * item -> unit
    val deleteExistent:	set * item -> unit		(* Delete *)
    val deleteWith :	(item -> unit) -> set * item -> unit

    val insert :	set * item -> unit
    val insertDisjoint:	set * item -> unit		(* Collision *)
    val insertWith :	(item -> unit) -> set * item -> unit

    val union :		set * set  -> unit
    val unionDisjoint :	set * set  -> unit		(* Collision *)
    val unionWith :	(item -> unit) -> set * set  -> unit

    val member :	set * item -> bool
    val size :		set -> int
    val isEmpty :	set -> bool

    val app :		(item -> unit) -> set -> unit
    val fold :		(item * 'a -> 'a) -> 'a -> set -> 'a

  end
(* src # 15 *)
functor MakeHashImpSet(Item: HASH_KEY) :> IMP_SET where type item = Item.t =
  struct

    type item = Item.t
    type set  = item list array ref * int ref
    type t    = set

    exception Delete    of item
    exception Collision of item


    val initialSize		= 19

    fun new()			= (ref(Array.array(initialSize,[])), ref 0)

    fun size(_, ref n)		= n
    fun isEmpty(_, ref n)	= n = 0

    fun app f (ref t, _)	= Array.app (List.app f) t
    fun fold f a (ref t, _)	= Array.foldl(fn(ks,a) => List.foldl f a ks) a t


    fun copy(ref t, ref n)	= let val t' = Array.array(Array.length t, [])
				  in
				      Array.copy{src=t, dst=t', si=0, di=0,
						 len=NONE} ;
				      (ref t', ref n)
				  end


    fun hash(t,k)		= Item.hash k mod Array.length t

    fun member((ref t,_), k)	= let val ks = Array.sub(t, hash(t,k)) in
				      List.exists (fn k' => k = k') ks
				  end


    exception Delete'

    fun delete'( [],   k')	= raise Delete'
      | delete'(k::ks, k')	= if k = k' then ks
					    else k :: delete'(ks,k')

    fun deleteWith f (s,k)	= let val (ref t,n) = s
				      val i   = hash(t,k)
				      val ks  = Array.sub(t,i)
				      val ks' = delete'(ks,k) before n := !n-1
						handle Delete' =>
						       (f k ; ks)
				  in
				      Array.update(t,i,ks')
				  end

    val delete			= deleteWith ignore
    val deleteExistent		= deleteWith(fn k => raise Delete k)


    fun reinsert t k		= let val i = hash(t,k) in
				      Array.update(t, i, k::Array.sub(t,i))
				  end

    fun resize(r as ref t,ref n)= if 3 * n < 2 * Array.length t then () else
				  let
				      val t'= Array.array(2*Array.length t-1,[])
				  in
				      Array.app(List.app (reinsert t')) t ;
				      r := t'
				  end

    fun insertWith f (s,k)	= let val _  = resize s
				      val (ref t,n) = s
				      val i  = hash(t,k)
				      val ks = Array.sub(t,i)
				  in
				      if List.exists (fn k' => k = k') ks
				      then f k
				      else ( Array.update(t, i, k::ks)
					   ; n := !n+1 )
				  end

    val insert			= insertWith ignore
    val insertDisjoint		= insertWith(fn k => raise Collision k)

    fun union(s1,s2)		= app (fn k => insert(s1,k)) s2
    fun unionDisjoint(s1,s2)	= app (fn k => insertDisjoint(s1,k)) s2
    fun unionWith f (s1,s2)	= app (fn k => insertWith f (s1,k)) s2

  end
(* src # 16 *)
signature IMP_MAP =
  sig

    eqtype key
    type 'a map
    type 'a t = 'a map

    exception Delete    of key
    exception Collision of key
    exception Lookup    of key

    val new :		unit -> 'a map
    val copy :		'a map -> 'a map

    val delete :	'a map * key -> unit
    val deleteExistent:	'a map * key -> unit		(* Delete *)
    val deleteWith :	(key -> unit) -> 'a map * key -> unit

    val insert :	'a map * key * 'a -> unit
    val insertDisjoint:	'a map * key * 'a -> unit	(* Collision *)
    val insertWith :	('a * 'a -> 'a) -> 'a map * key * 'a -> unit
    val insertWithi :	(key * 'a * 'a -> 'a) -> 'a map * key * 'a -> unit

    val union :		'a map * 'a map -> unit
    val unionDisjoint :	'a map * 'a map -> unit		(* Collision *)
    val unionWith :	('a * 'a -> 'a) -> 'a map * 'a map -> unit
    val unionWithi :	(key * 'a * 'a -> 'a) -> 'a map * 'a map -> unit

    val lookup :	'a map * key -> 'a option
    val lookupExistent:	'a map * key -> 'a		(* Lookup *)

    val member :	'a map * key -> bool
    val size :		'a map -> int
    val isEmpty :	'a map -> bool

    val app :		('a -> unit) -> 'a map -> unit
    val fold :		('a * 'b -> 'b) -> 'b -> 'a map -> 'b
    val appi :		(key * 'a -> unit) -> 'a map -> unit
    val foldi :		(key * 'a * 'b -> 'b) -> 'b -> 'a map -> 'b

  end
(* src # 17 *)
functor MakeHashImpMap(Key: HASH_KEY) :> IMP_MAP where type key = Key.t =
  struct

    type key    = Key.t
    type 'a map = (key * 'a) list array ref * int ref
    type 'a t   = 'a map

    exception Delete    of key
    exception Collision of key
    exception Lookup    of key


    val initialSize		= 19

    fun new()			= (ref(Array.array(initialSize,[])), ref 0)

    fun size(_, ref n)		= n
    fun isEmpty(_, ref n)	= n = 0

    fun appi f (ref t, _)	= Array.app (List.app f) t
    fun foldi f b (ref t, _)	= let fun f'((k,a),b) = f(k,a,b) in
				      Array.foldl (fn(kas,b) =>
							List.foldl f' b kas
						  ) b t
				  end
    fun app f			= appi(fn(k,a) => f a)
    fun fold f			= foldi(fn(k,a,b) => f(a,b))


    fun copy(ref t, ref n)	= let val t' = Array.array(Array.length t, [])
				  in
				      Array.copy{src=t, dst=t', si=0, di=0,
						 len=NONE} ;
				      (ref t', ref n)
				  end


    fun hash(t,k)		= Key.hash k mod Array.length t
    fun isEntryFor k (k',_)	= k = k'

    fun member((ref t,_), k)	= let val kas = Array.sub(t, hash(t,k)) in
				    List.exists (isEntryFor k) kas
				  end

    fun lookup((ref t,_), k)	= let val kas = Array.sub(t, hash(t,k)) in
				    Option.map #2 (List.find (isEntryFor k) kas)
				  end

    fun lookupExistent((ref t,_), k)
    				= let val kas = Array.sub(t, hash(t,k)) in
				    case List.find (isEntryFor k) kas
				      of NONE      => raise Lookup k
				       | SOME(k,a) => a
				  end

    exception Delete'

    fun delete'(  [],    k)	= raise Delete'
      | delete'(ka::kas, k)	= if #1 ka = k then kas : (key * 'a) list
					       else ka :: delete'(kas,k)

    fun deleteWith f (m,k)	= let val (ref t,n) = m
				      val i    = hash(t,k)
				      val kas  = Array.sub(t,i)
				      val kas' = delete'(kas,k) before n := !n-1
						 handle Delete' => (f k ; kas)
				  in
				      Array.update(t, i, kas')
				  end

    fun delete x		= deleteWith ignore x
    fun deleteExistent x	= deleteWith(fn k => raise Delete k) x


    fun reinsert t (ka as(k,_))	= let val i = hash(t,k) in
				      Array.update(t, i, ka::Array.sub(t,i))
				  end

    fun resize(r as ref t,ref n)= if 3 * n < 2 * Array.length t then () else
				  let
				      val t'= Array.array(2*Array.length t-1,[])
				  in
				      Array.app(List.app (reinsert t')) t ;
				      r := t'
				  end

    fun insertWithi f (m,k,a)	= let val _  = resize m
				      val (ref t,n) = m
				      val i    = hash(t,k)
				      val kas  = Array.sub(t,i)
				      val kas' =
					case List.find (isEntryFor k) kas
					  of NONE =>
						(k,a)::kas before n := !n+1
					   | SOME(k,a') =>
						(k, f(k,a',a))::delete'(kas,k)
				  in
				      Array.update(t, i, kas')
				  end

    fun insertWith f		= insertWithi(fn(k,a1,a2) => f(a1,a2))
    fun insert x		= insertWithi #3 x
    fun insertDisjoint x	= insertWithi(fn(k,_,_) => raise Collision k) x


    fun union' insert (m1,m2)	= appi (fn(k,a) => insert(m1,k,a)) m2
    fun union x			= union' insert x
    fun unionDisjoint x		= union' insertDisjoint x
    fun unionWith f		= union'(insertWith f)
    fun unionWithi f		= union'(insertWithi f)

  end
(* src # 18 *)
(*
 * A stateful scoped map (a stateful stack of stateful maps).
 *)

signature SCOPED_IMP_SET =
  sig

    type item
    type set
    type t = set

    exception Delete    of item
    exception Collision of item

    val new :			unit -> set

    val copy :			set -> set
    val copyScope :		set -> set

    val insertScope :		set -> unit
    val inheritScope :		set * set -> unit
    val deleteScope :		set -> unit
    val splitScope :		set -> set

    val mergeScope :		set -> unit
    val mergeDisjointScope :	set -> unit			(* Collision *)
    val mergeScopeWith :	(item -> unit) -> set -> unit

    val delete :		set * item -> unit
    val deleteExistent :	set * item -> unit		(* Delete *)
    val deleteWith :		(item -> unit) -> set * item -> unit

    val insert :		set * item -> unit
    val insertDisjoint :	set * item -> unit		(* Collision *)
    val insertWith :		(item -> unit) -> set * item -> unit

    val union :			set * set  -> unit
    val unionDisjoint :		set * set  -> unit		(* Collision *)
    val unionWith :		(item -> unit) -> set * set -> unit

    val member :		set * item -> bool
    val memberScope :		set * item -> bool

    val size :			set -> int
    val sizeScope :		set -> int

    val isEmpty :		set -> bool
    val isEmptyScope :		set -> bool

    val app :			(item -> unit) -> set -> unit
    val appScope :		(item -> unit) -> set -> unit

    val fold :			(item * 'a -> 'a) -> 'a -> set -> 'a
    val foldScope :		(item * 'a -> 'a) -> 'a -> set -> 'a

  end
(* src # 19 *)
functor MakeScopedImpSet(ImpSet: IMP_SET) :>
  SCOPED_IMP_SET where type item = ImpSet.item =
  struct

    type item = ImpSet.item
    type set  = ImpSet.t list ref
    type t    = set

    exception Delete    = ImpSet.Delete
    exception Collision = ImpSet.Collision


    val scopeSize = 19

    fun new()			= ref[ImpSet.new()]
    fun copy(ref ss)		= ref(List.map ImpSet.copy ss)
    fun copyScope(ref ss)	= ref[ImpSet.copy(List.hd ss)]
    fun insertScope r		= r := ImpSet.new() :: !r
    fun deleteScope r		= r := List.tl(!r)
    fun splitScope(r as ref ss)	= ( deleteScope r ; ref[List.hd ss] )
    fun inheritScope(r,r')	= r := List.hd(!(splitScope r')) :: !r

    fun mergeScope' unionSet (r as ref ss)
				= let val ss' = List.tl ss in
				      unionSet(List.hd ss', List.hd ss) ;
				      r := ss'
				  end

    fun mergeScope r		= mergeScope' ImpSet.union r
    fun mergeDisjointScope r	= mergeScope' ImpSet.unionDisjoint r
    fun mergeScopeWith f	= mergeScope'(ImpSet.unionWith f)


    fun member'( [],   i)	= false
      | member'(s::ss, i)	= ImpSet.member(s,i) orelse member'(ss,i)

    fun member(ref ss, i)	= member'(ss,i)

    fun memberScope(ref ss, i)	= ImpSet.member(List.hd ss, i)

    fun isEmptyScope(ref ss)	= ImpSet.isEmpty(List.hd ss)
    fun isEmpty(ref ss)		= List.all ImpSet.isEmpty ss

    fun sizeScope(ref ss)	= ImpSet.size(List.hd ss)
    fun size(ref ss)		= List.foldl (fn(s,n) => n + ImpSet.size s) 0 ss

    fun appScope f (ref ss)	= ImpSet.app f (List.hd ss)
    fun app f (ref ss)		= List.app (ImpSet.app f) (List.rev ss)
    fun foldScope f a (ref ss)	= ImpSet.fold f a (List.hd ss)
    fun fold f a (ref ss)	= List.foldr (fn(s,a') => ImpSet.fold f a' s)
					     a ss

    fun delete(ref ss, i)		= ImpSet.delete(List.hd ss, i)
    fun deleteExistent(ref ss, i)	= ImpSet.deleteExistent(List.hd ss, i)
    fun deleteWith f (ref ss, i)	= ImpSet.deleteWith f (List.hd ss, i)

    fun insert(ref ss, i)		= ImpSet.insert(List.hd ss, i)
    fun insertDisjoint(ref ss, i)	= ImpSet.insertDisjoint(List.hd ss, i)
    fun insertWith f (ref ss, i)	= ImpSet.insertWith f (List.hd ss, i)

    fun union' setUnion (ref ss1, ref ss2)
				= let val s1 = List.hd ss1 in
				      List.app (fn s2 => setUnion(s1,s2)) ss2
				  end

    fun union x			= union' ImpSet.union x
    fun unionDisjoint x		= union' ImpSet.unionDisjoint x
    fun unionWith f		= union'(ImpSet.unionWith f)

  end
(* src # 20 *)
functor MakeHashScopedImpSet(Item: HASH_KEY) =
	MakeScopedImpSet(MakeHashImpSet(Item))
(* src # 21 *)
 (*
 * A stateful scoped map (a stateful stack of stateful maps).
 *)

signature SCOPED_IMP_MAP =
  sig

    type key
    type 'a map
    type 'a t = 'a map

    exception Delete    of key
    exception Collision of key
    exception Lookup    of key

    val new :			unit -> 'a map

    val copy :			'a map -> 'a map
    val copyScope :		'a map -> 'a map

    val insertScope :		'a map -> unit
    val deleteScope :		'a map -> unit
    val inheritScope :		'a map * 'a map -> unit
    val splitScope :		'a map -> 'a map

    val mergeScope :		'a map -> unit
    val mergeDisjointScope :	'a map -> unit			(* Collision *)
    val mergeScopeWith :	('a * 'a -> 'a) -> 'a map -> unit
    val mergeScopeWithi :	(key * 'a * 'a -> 'a) -> 'a map -> unit

    val delete :		'a map * key -> unit
    val deleteExistent :	'a map * key -> unit		(* Delete *)
    val deleteWith :		(key -> unit) -> 'a map * key -> unit

    val insert :		'a map * key * 'a -> unit
    val insertDisjoint :	'a map * key * 'a -> unit	(* Collision *)
    val insertWith :		('a * 'a -> 'a) -> 'a map * key * 'a -> unit
    val insertWithi :		(key * 'a * 'a -> 'a) -> 'a map * key * 'a
									 -> unit
    val union :			'a map * 'a map -> unit
    val unionDisjoint :		'a map * 'a map -> unit		(* Collision *)
    val unionWith :		('a * 'a -> 'a) -> 'a map * 'a map -> unit
    val unionWithi :		(key * 'a * 'a -> 'a) -> 'a map * 'a map -> unit

    val lookup :		'a map * key -> 'a option
    val lookupScope :		'a map * key -> 'a option
    val lookupExistent :	'a map * key -> 'a		(* Lookup *)
    val lookupExistentScope :	'a map * key -> 'a		(* Lookup *)

    val member :		'a map * key -> bool
    val memberScope :		'a map * key -> bool

    val size :			'a map -> int
    val sizeScope :		'a map -> int

    val isEmpty :		'a map -> bool
    val isEmptyScope :		'a map -> bool

    val app :			('a -> unit) -> 'a map -> unit
    val appScope :		('a -> unit) -> 'a map -> unit
    val appi :			(key * 'a -> unit) -> 'a map -> unit
    val appiScope :		(key * 'a -> unit) -> 'a map -> unit

    val fold :			('a * 'b -> 'b) -> 'b -> 'a map -> 'b
    val foldScope :		('a * 'b -> 'b) -> 'b -> 'a map -> 'b
    val foldi :			(key * 'a * 'b -> 'b) -> 'b -> 'a map -> 'b
    val foldiScope :		(key * 'a * 'b -> 'b) -> 'b -> 'a map -> 'b

  end
(* src # 22 *)
functor MakeScopedImpMap(ImpMap: IMP_MAP) :>
  SCOPED_IMP_MAP where type key = ImpMap.key =
  struct

    type key    = ImpMap.key
    type 'a map = 'a ImpMap.t list ref
    type 'a t   = 'a map

    exception Delete    = ImpMap.Delete
    exception Collision = ImpMap.Collision
    exception Lookup    = ImpMap.Lookup


    fun new()			= ref[ImpMap.new()]
    fun copy(ref ms)		= ref(List.map ImpMap.copy ms)
    fun copyScope(ref ms)	= ref[ImpMap.copy(List.hd ms)]
    fun insertScope r		= r := ImpMap.new() :: !r
    fun deleteScope r		= r := List.tl(!r)
    fun splitScope(r as ref ms)	= ( deleteScope r ; ref[List.hd ms] )
    fun inheritScope(r,r')	= r := List.hd(!(splitScope r')) :: !r

    fun mergeScope' unionMap (r as ref ms)
				= let val ms' = List.tl ms in
				      unionMap(List.hd ms', List.hd ms) ;
				      r := ms'
				  end

    fun mergeScope r		= mergeScope' ImpMap.union r
    fun mergeDisjointScope r	= mergeScope' ImpMap.unionDisjoint r
    fun mergeScopeWith f	= mergeScope'(ImpMap.unionWith f)
    fun mergeScopeWithi f	= mergeScope'(ImpMap.unionWithi f)


    fun lookup'( [],   k)	= raise Lookup k
      | lookup'([m],   k)	= ImpMap.lookupExistent(m,k)
      | lookup'(m::ms, k)	= case ImpMap.lookup(m,k)
				    of NONE   => lookup'(ms,k)
				     | SOME a => a

    fun lookup(ref ms, k)		= SOME(lookup'(ms,k))
					  handle Lookup _ => NONE
    fun lookupExistent(ref ms, k)	= lookup'(ms,k)
    fun lookupScope(ref ms, k)		= ImpMap.lookup(List.hd ms, k)
    fun lookupExistentScope(ref ms, k)	= ImpMap.lookupExistent(List.hd ms, k)

    fun member(ref ms, k)	= ( lookup'(ms, k) ; true )
				  handle Lookup _ => false
    fun memberScope(ref ms, k)	= ImpMap.member(List.hd ms, k)

    fun isEmptyScope(ref ms)	= ImpMap.isEmpty(List.hd ms)
    fun isEmpty(ref ms)		= List.all ImpMap.isEmpty ms

    fun sizeScope(ref ms)	= ImpMap.size(List.hd ms)
    fun size(ref ms)		= List.foldl (fn(m,n) => n + ImpMap.size m) 0 ms

    fun appScope f (ref ms)	= ImpMap.app f (List.hd ms)
    fun app f (ref ms)		= List.app (ImpMap.app f) (List.rev ms)
    fun foldScope f b (ref ms)	= ImpMap.fold f b (List.hd ms)
    fun fold f b (ref ms)	= List.foldr (fn(m,b') => ImpMap.fold f b' m)
					     b ms
    fun appiScope f (ref ms)	= ImpMap.appi f (List.hd ms)
    fun appi f (ref ms)		= List.app (ImpMap.appi f) (List.rev ms)
    fun foldiScope f b (ref ms)	= ImpMap.foldi f b (List.hd ms)
    fun foldi f b (ref ms)	= List.foldr (fn(m,b') => ImpMap.foldi f b' m)
					     b ms

    fun delete(ref ms, k)		= ImpMap.delete(List.hd ms, k)
    fun deleteExistent(ref ms, k)	= ImpMap.deleteExistent(List.hd ms, k)
    fun deleteWith f (ref ms, k)	= ImpMap.deleteWith f (List.hd ms, k)

    fun insert(ref ms, k, a)		= ImpMap.insert(List.hd ms, k, a)
    fun insertDisjoint(ref ms, k, a)	= ImpMap.insertDisjoint(List.hd ms, k,a)
    fun insertWith f (ref ms, k, a)	= ImpMap.insertWith f (List.hd ms, k, a)
    fun insertWithi f (ref ms, k, a)	= ImpMap.insertWithi f (List.hd ms, k,a)

    fun union' mapUnion (ref ms1, ref ms2)
				= let val m = List.hd ms1 in
				      List.app (fn m' => mapUnion(m,m')) ms2
				  end

    fun union x			= union' ImpMap.union x
    fun unionDisjoint x		= union' ImpMap.unionDisjoint x
    fun unionWith f		= union'(ImpMap.unionWith f)
    fun unionWithi f		= union'(ImpMap.unionWithi f)

  end
(* src # 23 *)
functor MakeHashScopedImpMap(Key: HASH_KEY) =
	MakeScopedImpMap(MakeHashImpMap(Key))
(* src # 24 *)
(*
 * Stamp generator.
 *)


signature STAMP =
  sig

    eqtype stamp
    type t = stamp

    val new :		unit -> stamp
    val toString :	stamp -> string

    val reset :		unit -> unit

    val compare :	stamp * stamp -> order
    val hash :		stamp -> int

  end
(*DEBUG where type stamp = int*)
(* src # 25 *)
(*
 * Stamp generator.
 *)


functor MakeStamp() : (*DEBUG :>*) STAMP =
  struct

    type stamp = int
    type t     = stamp

    val r = ref 0

    fun reset()  =  r := 0
    fun new()    = (r := !r + 1; !r)

    val toString = Int.toString
    val compare  = Int.compare

    fun hash n   = n

  end
(* src # 26 *)
(*
 * A generic pretty printer.
 *
 * Based on:
 *    Philip Wadler. "A prettier printer"
 *    http://cm.bell-labs.com/cm/cs/who/wadler/
 * and Christian Lindig's port to OCaml.
 *
 * The semantics has been extended to allow 4 different kinds of
 * groups (`boxes'), 2 modes of nesting, and varying break representations.
 * This is no more easily described by an algebra though, and the `below'
 * combinator looses optimality.
 *)

signature PRETTY_PRINT =
  sig

    eqtype doc

    val empty :		doc			(* empty document *)
    val break :		doc			(* space or line break *)
    val ebreak :	doc			(* empty or line break *)
    val text :		string -> doc		(* raw text *)

    val ^^ :		doc * doc -> doc	(* concatenation *)
    val ^/^ :		doc * doc -> doc	(* concatenation with break *)

    val hbox :		doc -> doc		(* horizontal box *)
    val vbox :		doc -> doc		(* vertical box *)
    val fbox :		doc -> doc		(* fill box (h and v) *)
    val abox :		doc -> doc		(* auto box (h or v) *)

    val nest :		int -> doc -> doc	(* indentation by k char's *)
    val below :		doc -> doc		(* keep current indentation *)

    val isEmpty :	doc -> bool

    val toString :	doc * int -> string
    val output :	TextIO.outstream * doc * int -> unit

  end
(* src # 27 *)
(*
 * A generic pretty printer.
 *
 * Based on:
 *    Philip Wadler. "A prettier printer"
 *    http://cm.bell-labs.com/cm/cs/who/wadler/
 * and Christian Lindig's port to OCaml.
 *
 * The semantics has been extended to allow 4 different kinds of
 * groups (`boxes'), 2 modes of nesting, and varying break representations.
 * This is no more easily described by an algebra though, and the `below'
 * combinator looses optimality.
 *)

structure PrettyPrint :> PRETTY_PRINT =
  struct

    (* Types *)

    datatype mode = H | V | F | A

    datatype doc =
	  EMPTY
	| BREAK of string
	| TEXT  of string
	| CONS  of doc * doc
	| BOX   of mode * doc
	| NEST  of int * doc
	| BELOW of doc

    datatype prim =
	  PTEXT of string
	| PLINE of int


    (* Interface operators *)

    infixr ^^ ^/^

    val empty	= EMPTY
    val break	= BREAK " "
    val ebreak	= BREAK ""
    val text	= TEXT

    fun x ^^ EMPTY	= x
      | EMPTY ^^ y	= y
      | x ^^ y		= CONS(x, y)

    fun x ^/^ EMPTY	= x
      | EMPTY ^/^ y	= y
      | x ^/^ y		= CONS(x, CONS(break, y))

    fun below EMPTY	= EMPTY
      | below x		= BELOW x

    fun hbox EMPTY	= EMPTY
      | hbox x		= BOX(H, x)

    fun vbox EMPTY	= EMPTY
      | vbox x		= BOX(V, x)

    fun fbox EMPTY	= EMPTY
      | fbox x		= BOX(F, x)

    fun abox EMPTY	= EMPTY
      | abox x		= BOX(A, x)

    fun nest k EMPTY	= EMPTY
      | nest k x	= NEST(k, x)


    fun isEmpty EMPTY	= true
      | isEmpty _	= false


    (* Check whether the first line of a document fits into remaining characters *)

    (* We abuse the mode A (which can never occur in the lists passed to
     * fits) to flag breaks which occur inside swallowed vboxes.
     *)

    fun fits(w, z) =
	w >= 0 andalso
	case z
	  of []			=> true
	   | (i,m,EMPTY)::z	=> fits(w, z)
	   | (i,m,CONS(x,y))::z	=> fits(w, (i,m,x)::(i,m,y)::z)
	   | (i,m,TEXT s)::z	=> fits(w - String.size s, z)
	   | (i,H,BREAK s)::z	=> fits(w - String.size s, z)
	   | (i,A,BREAK s)::z	=> false
	   | (i,m,BREAK s)::z	=> true
	   | (i,m,BOX(V,x))::z	=> fits(w, (i,A,x)::z)
	   | (i,m,BOX(n,x))::z	=> fits(w, (i,H,x)::z)
	   | (i,m,NEST(j,x))::z	=> fits(w, (i,m,x)::z)
	   | (i,m,BELOW x)::z	=> fits(w, (i,m,x)::z)


    (* Layout *)

    fun best(w, k, z, a) =
	case z
	  of []			=> List.rev a
	   | (i,m,EMPTY)::z	=> best(w, k, z, a)
	   | (i,m,CONS(x,y))::z	=> best(w, k, (i,m,x)::(i,m,y)::z, a)
	   | (i,m,TEXT s)::z	=> best(w, k + String.size s, z, PTEXT(s)::a)
	   | (i,H,BREAK s)::z	=> horizontal(w, k, s, z, a)
	   | (i,V,BREAK s)::z	=> vertical(w, i, z, a)
	   | (i,F,BREAK s)::z	=> if fits(w - k - String.size s, z)
				   then horizontal(w, k, s, z, a)
				   else vertical(w, i, z, a)
	   | (i,A,BREAK s)::z	=> raise Fail "PrettyPrint.best"
	   | (i,m,BOX(A,x))::z	=> if fits(w - k, (i,H,x)::z)
				   then best(w, k, (i,H,x)::z, a)
				   else best(w, k, (i,V,x)::z, a)
	   | (i,m,BOX(n,x))::z	=> best(w, k, (i,n,x)::z, a)
	   | (i,m,NEST(j,x))::z	=> best(w, k, (i+j,m,x)::z, a)
	   | (i,m,BELOW x)::z	=> best(w, k, (k,m,x)::z, a)

    and horizontal(w, k, s, z, a) =
	    best(w, k + String.size s, z, PTEXT(s)::a)

    and vertical(w, i, z, a) =
	    best(w, i, z, PLINE(i)::a)


    fun layout(doc, w) = best(w, 0, [(0,V,doc)], [])



    (* Convert a document *)

    fun primToString(PTEXT s) = s
      | primToString(PLINE i) = 
	    String.implode(#"\n" :: List.tabulate(i, fn _ => #" "))

    val toString = String.concat o List.map primToString o layout



    (* Output a document directly (is MUCH faster!) *)

    fun loop 0 f = ()
      | loop n f = ( f() ; loop (n-1) f )

    fun outputPrim os (PTEXT s) = TextIO.output(os, s)
      | outputPrim os (PLINE i) =
	    ( TextIO.output1(os, #"\n")
	    ; loop i (fn() => TextIO.output1(os, #" "))
	    )

    fun output(os, doc, w) = List.app (outputPrim os) (layout(doc, w))

  end
(* src # 28 *)
(*
 * Miscellaneous pretty printing helpers
 *)

signature PP_MISC =
  sig

    type doc = PrettyPrint.doc

    val nest:		doc -> doc

    val paren:		doc -> doc
    val brace:		doc -> doc
    val brack:		doc -> doc

    val ppCommaList:	('a -> doc) -> 'a list -> doc
    val ppStarList:	('a -> doc) -> 'a list -> doc
    val ppSeq:		('a -> doc) -> 'a list -> doc
    val ppSeqPrec:	(int -> 'a -> doc) -> int -> 'a list -> doc

    val paragraph:	string list -> doc

  end
(* src # 29 *)
(*
 * Miscellaneous pretty printing helpers
 *)

structure PPMisc :> PP_MISC =
  struct

    (* Import *)

    open PrettyPrint

    infixr ^^ ^/^


    (* Some PP combinators *)

    val nest = nest 3

    fun paren doc = text "(" ^^ fbox(below doc) ^^ text ")"
    fun brace doc = text "{" ^^ fbox(below doc) ^^ text "}"
    fun brack doc = text "[" ^^ fbox(below doc) ^^ text "]"

    fun ppCommaList ppX   []    = empty
      | ppCommaList ppX   [x]   = ppX x
      | ppCommaList ppX (x::xs) = ppX x ^^ text "," ^^ break ^^
				  ppCommaList ppX xs

    fun ppStarList ppX   []     = empty
      | ppStarList ppX   [x]    = ppX x
      | ppStarList ppX (x::xs)  = hbox(ppX x ^^ break ^^ text "*") ^^ break ^^
				  ppStarList ppX xs

    fun ppSeqPrec ppXPrec n []  = empty
      | ppSeqPrec ppXPrec n [x] = ppXPrec n x
      | ppSeqPrec ppXPrec n  xs = paren(ppCommaList (ppXPrec 0) xs)

    fun ppSeq ppX = ppSeqPrec (fn _ => ppX) 0


    val paragraph = fbox o List.foldr (fn(s,doc) => text s ^/^ doc) empty

  end
(* src # 30 *)
(*
 * A source file.
 *)


signature SOURCE =
  sig

    type source = string
    type pos    = int * int
    type region = pos * pos

    val nowhere:	region
    val over:		region * region -> region
    val between:	region * region -> region

    val regionToString:	region -> string

  end
(* src # 31 *)
(*
 * A source file
 *)


structure Source :> SOURCE =
  struct

    type source = string
    type pos    = int * int
    type region = pos * pos

    val nowhere = ((0,0),(0,0))

    fun over(reg1: region, reg2: region)	= (#1 reg1, #2 reg2)
    fun between(reg1: region, reg2: region)	= (#2 reg1, #1 reg2)

    fun posToString(lin,col) =
	Int.toString lin ^ "." ^ Int.toString col

    fun regionToString(region as (pos1,pos2)) =
	if region = nowhere then
	    "(unknown position)"
	else
	    posToString pos1 ^ "-" ^ posToString pos2

  end
(* src # 32 *)
(*
 * Handling of internal inconsistencies.
 *)

signature CRASH =
  sig
    exception Crash of string
  end
(* src # 33 *)
(*
 * Handling of internal inconsistencies.
 *)

structure Crash :> CRASH =
  struct
    exception Crash of string
  end
(* src # 34 *)
(*
 * Error handling.
 *)


signature ERROR =
  sig

    (* Import *)

    type region = Source.region


    (* Export *)

    exception Error of region * string

    val error :	region * string -> 'a
    val warn :	region * string -> unit

  end
(* src # 35 *)
(*
 * Error handling.
 *)


structure Error :> ERROR =
  struct

    (* Import *)

    type region = Source.region


    (* Export *)

    exception Error of region * string

    fun print(reg, s) =
        TextIO.output(TextIO.stdErr,
		      Source.regionToString reg ^ ": " ^ s ^ "\n")

    fun error(reg, message) = ( print(reg,message) ; raise Error(reg,message) )
    fun warn (reg, message) =   print(reg, "warning: " ^ message)

  end
(* src # 36 *)
structure Stamp = MakeStamp()
(* src # 37 *)
signature INTERMEDIATE_GRAMMAR =
  sig

    (* Generic *)

    type info

    (* Literals *)

    datatype lit =
	  WordLit   of LargeWord.word
	| IntLit    of LargeInt.int
	| CharLit   of WideChar.char
	| StringLit of WideString.string
(*	| RealLit   of LargeReal.real
UNFINISHED: obsolete after bootstrapping:
*)	| RealLit   of string

    (* Identifiers *)

    type stamp      = Stamp.t

    datatype name   = ExId of string | InId

    datatype lab    = Lab     of info * string
    datatype id     = Id      of info * stamp * name
    datatype longid = ShortId of info * id
		    | LongId  of info * longid * lab

    (* Expressions *)

    datatype exp =
	  LitExp    of info * lit
	| PrimExp   of info * string
	| NewExp    of info * string option * bool (* has args *)
	| VarExp    of info * longid
	| ConExp    of info * longid * bool
	| RefExp    of info
	| TupExp    of info * exp list
	| RowExp    of info * exp field list
			(* all labels distinct *)
	| SelExp    of info * lab
	| VecExp    of info * exp list
	| FunExp    of info * id * exp
	| AppExp    of info * exp * exp
	| AdjExp    of info * exp * exp
	| AndExp    of info * exp * exp
	| OrExp     of info * exp * exp
	| IfExp     of info * exp * exp * exp
	| WhileExp  of info * exp * exp
	| SeqExp    of info * exp list
	| CaseExp   of info * exp * match list
	| RaiseExp  of info * exp
	| HandleExp of info * exp * match list
	| LetExp    of info * dec list * exp

    and 'a field = Field of info * lab * 'a

    and match    = Match of info * pat * exp

    (* Patterns (always linear) *)

    and pat =
	  WildPat   of info
	| LitPat    of info * lit
	| VarPat    of info * id
	| ConPat    of info * longid * pat option
			(* pat present iff longid has arguments *)
	| RefPat    of info * pat
	| TupPat    of info * pat list
	| RowPat    of info * pat field list * bool (* dots *)
			(* all labels distinct *)
	| VecPat    of info * pat list
	| AsPat     of info * pat * pat
	| AltPat    of info * pat list
			(* all patterns bind same ids *)
	| NegPat    of info * pat
	| GuardPat  of info * pat * exp
	| WithPat   of info * pat * dec list

    (* Declarations *)

    and dec =
	  ValDec    of info * pat * exp
	  		(* if inside RecDec, then
			 * (1) pat may not contain AltPat, NegPat, GuardPat,
			 *     WithPat
			 * (2) exp may only contain LitExp, VarExp, ConExp,
			 *     RefExp, TupExp, RowExp, VecExp, FunExp, AppExp
			 * (3) AppExps may only contain ConExp or RefExp
			 *     as first argument
			 * (4) if an VarExp on the LHS structurally corresponds
			 *     to an VarExp on the RHS then the RHS id may not
			 *     be bound on the LHS *)
	| RecDec    of info * dec list

    (* Components *)

    type component = (id * string) list * id list * dec list


    (* Operations *)

    val infoLab :	lab	-> info
    val infoId :	id	-> info
    val infoLongid :	longid	-> info
    val infoExp :	exp	-> info
    val infoField :	'a field-> info
    val infoMatch :	match	-> info
    val infoPat :	pat	-> info
    val infoDec :	dec	-> info

  end
(* src # 38 *)
functor MakeIntermediateGrammar(type info) :>
  INTERMEDIATE_GRAMMAR where type info = info =
  struct

    (* Generic *)

    type info = info

    (* Literals *)

    datatype lit =
	  WordLit   of LargeWord.word
	| IntLit    of LargeInt.int
	| CharLit   of WideChar.char
	| StringLit of WideString.string
(*	| RealLit   of LargeReal.real
UNFINISHED: obsolete after bootstrapping:
*)	| RealLit   of string

    (* Identifiers *)

    type stamp      = Stamp.t

    datatype name   = ExId of string | InId

    datatype lab    = Lab     of info * string
    datatype id     = Id      of info * stamp * name
    datatype longid = ShortId of info * id
		    | LongId  of info * longid * lab

    (* Expressions *)

    datatype exp =
	  LitExp    of info * lit
	| PrimExp   of info * string
	| NewExp    of info * string option * bool (* has args *)
	| VarExp    of info * longid
	| ConExp    of info * longid * bool
	| RefExp    of info
	| TupExp    of info * exp list
	| RowExp    of info * exp field list
			(* all labels distinct *)
	| SelExp    of info * lab
	| VecExp    of info * exp list
	| FunExp    of info * id * exp
	| AppExp    of info * exp * exp
	| AdjExp    of info * exp * exp
	| AndExp    of info * exp * exp
	| OrExp     of info * exp * exp
	| IfExp     of info * exp * exp * exp
	| WhileExp  of info * exp * exp
	| SeqExp    of info * exp list
	| CaseExp   of info * exp * match list
	| RaiseExp  of info * exp
	| HandleExp of info * exp * match list
	| LetExp    of info * dec list * exp

    and 'a field = Field of info * lab * 'a

    and match    = Match of info * pat * exp

    (* Patterns (always linear) *)

    and pat =
	  WildPat   of info
	| LitPat    of info * lit
	| VarPat    of info * id
	| ConPat    of info * longid * pat option
			(* pat present iff longid has arguments *)
	| RefPat    of info * pat
	| TupPat    of info * pat list
	| RowPat    of info * pat field list * bool (* dots *)
			(* all labels distinct *)
	| VecPat    of info * pat list
	| AsPat     of info * pat * pat
	| AltPat    of info * pat list
			(* all patterns bind same ids *)
	| NegPat    of info * pat
	| GuardPat  of info * pat * exp
	| WithPat   of info * pat * dec list

    (* Declarations *)

    and dec =
	  ValDec    of info * pat * exp
	  		(* if inside RecDec, then
			 * (1) pat may not contain AltPat, NegPat, GuardPat,
			 *     WithPat
			 * (2) exp may only contain LitExp, VarExp, ConExp,
			 *     RefExp, TupExp, RowExp, VecExp, FunExp, AppExp
			 * (3) AppExps may only contain ConExp or RefExp
			 *     as first argument
			 * (4) if an VarExp on the LHS structurally corresponds
			 *     to an VarExp on the RHS then the RHS id may not
			 *     be bound on the LHS *)
	| RecDec    of info * dec list

    (* Components *)

    type component = (id * string) list * id list * dec list


    (* Projections *)

    fun infoLab(Lab(i,_))		= i
    fun infoId(Id(i,_,_))		= i
    fun infoLongid(ShortId(i,_))	= i
      | infoLongid(LongId(i,_,_))	= i

    fun infoExp(LitExp(i,_))		= i
      | infoExp(PrimExp(i,_))		= i
      | infoExp(NewExp(i,_,_))		= i
      | infoExp(VarExp(i,_))		= i
      | infoExp(ConExp(i,_,_))		= i
      | infoExp(RefExp(i))		= i
      | infoExp(TupExp(i,_))		= i
      | infoExp(RowExp(i,_))		= i
      | infoExp(SelExp(i,_))		= i
      | infoExp(VecExp(i,_))		= i
      | infoExp(FunExp(i,_,_))		= i
      | infoExp(AppExp(i,_,_))		= i
      | infoExp(AdjExp(i,_,_))		= i
      | infoExp(AndExp(i,_,_))		= i
      | infoExp(OrExp(i,_,_))		= i
      | infoExp(IfExp(i,_,_,_))		= i
      | infoExp(WhileExp(i,_,_))	= i
      | infoExp(SeqExp(i,_))		= i
      | infoExp(CaseExp(i,_,_))		= i
      | infoExp(RaiseExp(i,_))		= i
      | infoExp(HandleExp(i,_,_))	= i
      | infoExp(LetExp(i,_,_))		= i

    fun infoField(Field(i,_,_))		= i
    fun infoMatch(Match(i,_,_))		= i

    fun infoPat(WildPat(i))		= i
      | infoPat(LitPat(i,_))		= i
      | infoPat(VarPat(i,_))		= i
      | infoPat(ConPat(i,_,_))		= i
      | infoPat(RefPat(i,_))		= i
      | infoPat(TupPat(i,_))		= i
      | infoPat(RowPat(i,_,_))		= i
      | infoPat(VecPat(i,_))		= i
      | infoPat(AsPat(i,_,_))		= i
      | infoPat(AltPat(i,_))		= i
      | infoPat(NegPat(i,_))		= i
      | infoPat(GuardPat(i,_,_))	= i
      | infoPat(WithPat(i,_,_))		= i

    fun infoDec(ValDec(i,_,_))		= i
      | infoDec(RecDec(i,_))		= i

  end
(* src # 39 *)
structure IntermediateGrammar =
		MakeIntermediateGrammar(type info = Source.region)
(* src # 40 *)
signature PREBOUND =
  sig

    type stamp = Stamp.t

    val stamp_false :	stamp
    val stamp_true :	stamp
    val stamp_nil :	stamp
    val stamp_cons :	stamp
    val stamp_ref :	stamp
    val stamp_Match :	stamp
    val stamp_Bind :	stamp

    val stamp_bool :	stamp
    val stamp_int :	stamp
    val stamp_word :	stamp
    val stamp_real :	stamp
    val stamp_string :	stamp
    val stamp_char :	stamp
    val stamp_list :	stamp
    val stamp_vec :	stamp
    val stamp_tref :	stamp
    val stamp_exn :	stamp

  end
(* src # 41 *)
structure Prebound :> PREBOUND =
  struct

    type stamp = Stamp.t

    val stamp_false	= Stamp.new()
    val stamp_true	= Stamp.new()
    val stamp_nil	= Stamp.new()
    val stamp_cons	= Stamp.new()
    val stamp_ref	= Stamp.new()
    val stamp_Match	= Stamp.new()
    val stamp_Bind	= Stamp.new()

    val stamp_bool	= Stamp.new()
    val stamp_int	= Stamp.new()
    val stamp_word	= Stamp.new()
    val stamp_real	= Stamp.new()
    val stamp_string	= Stamp.new()
    val stamp_char	= Stamp.new()
    val stamp_list	= Stamp.new()
    val stamp_vec	= Stamp.new()
    val stamp_tref	= Stamp.new()
    val stamp_exn	= Stamp.new()

  end
(* src # 42 *)
structure StringMap = MakeHashImpMap(StringHashKey)
(* src # 43 *)
structure StampMap = MakeHashImpMap(Stamp)
(* src # 44 *)
signature NAME =
  sig

    datatype name = ExId of string | InId
    type t        = name

    val compare :	name * name -> order
    val hash :		name -> int
    val toString :	name -> string

  end
(* src # 45 *)
structure Name :> NAME =
  struct

    datatype name = ExId of string | InId
    type     t    = name

    fun compare(ExId s1, ExId s2)	= String.compare(s1,s2)
      | compare(ExId _,  InId)		= GREATER
      | compare(InId,    ExId _)	= LESS
      | compare(InId,    InId)		= EQUAL

    fun hash(ExId s)			= StringHashKey.hash s
      | hash InId			= 0

    fun toString(ExId s)		= s
      | toString InId			= "?"

  end
(* src # 46 *)
signature LAB =
  sig

    eqtype lab					(* [lab,l] *)
    type t = lab


    (* Operations *)

    val fromString :	string -> lab
    val fromInt :	int    -> lab
    val fromName :	Name.t -> lab
    val toName :	lab    -> Name.t
    val toString :	lab    -> string

    val compare :	lab * lab -> order
    val hash :		lab -> int

  end
(* src # 47 *)
structure Lab :> LAB =
  struct

    datatype lab = NUM of int | ALPHA of string		(* [lab,l] *)

    type t   = lab


    (* Conversions *)

    fun fromInt n		= NUM n
    fun fromString s		= case Int.fromString s
				    of SOME n => NUM n
				     | NONE   => ALPHA s

    fun fromName(Name.ExId s)	= ALPHA s
      | fromName(Name.InId)	= ALPHA ""

    fun toName(ALPHA "")	= Name.InId
      | toName(ALPHA s)		= Name.ExId s
      | toName(NUM n)		= Name.ExId(Int.toString n)

    fun toString(NUM n)		= Int.toString n
      | toString(ALPHA s)	= s


    (* Ordering and hashing *)

    fun compare(NUM n1,   NUM n2)	= Int.compare(n1,n2)
      | compare(NUM n1,   ALPHA s2)	= String.compare(Int.toString n1, s2)
      | compare(ALPHA s1, NUM n2)	= String.compare(s1, Int.toString n2)
      | compare(ALPHA s1, ALPHA s2)	= String.compare(s1,s2)

    fun hash(NUM n)			= n
      | hash(ALPHA s)			= StringHashKey.hash s

  end
(* src # 48 *)
(* Since SML allows multiple definitions of the same id in a structure,
   labels are not enough for paths. So we added an index. *)

signature PATH =
  sig

  (* Types *)

    type lab   = Lab.t
    type name  = Name.t

    eqtype path
    type t = path

  (* Operations *)

    val invent :	unit -> path
    val fromLab :	lab  -> path
    val toLab :		path -> lab
    val path :		path * lab * int -> path

    val compare :	path * path -> order
    val hash :		path -> int

    val isDot :		path -> bool
    val asDot :		path -> path * lab * int

    val strengthen :	path * (path * lab * int) -> unit

    val instance :	('rea * path -> path option) -> 'rea * path -> path

  end
(* src # 49 *)
(* Notes:
 * - Paths are shared, i.e. each path has to be unique.
 * - Since SML allows multiple definitions of the same id in a structure,
 *   labels are not enough for paths. So we added an index.
 *)

structure PathPrivate =
  struct

  (* Types *)

    type lab   = Lab.t
    type name  = Name.t

    datatype path' =
	  PLAIN  of name
	| DOT    of path * lab * int
	(*UNFINISHED
	| IMPORT of string * lab * int
	*)

    withtype path = path' ref
    type t = path


  (* Creation and projection *)

    fun invent()		= ref(PLAIN(Name.InId))
    fun fromLab l		= ref(PLAIN(Lab.toName l))
    fun path pln		= ref(DOT pln)

    fun toLab(ref(PLAIN n))	= Lab.fromName n
      | toLab _			= raise Crash.Crash "Path.toLab"

    fun isDot(ref(DOT _))	= true
      | isDot _			= false

    fun asDot(ref(DOT pln))	= pln
      | asDot _			= raise Crash.Crash "Path.asDot"


  (* Ordering and hashing *)

    fun compare(p1 as ref p1', p2 as ref p2')	= if p1 = p2 then EQUAL
						  else compare'(p1', p2')
    and compare'(PLAIN _,       DOT _)		= LESS
      | compare'(DOT _,         PLAIN _)	= GREATER
      | compare'(PLAIN(x1),     PLAIN(x2))	= Name.compare(x1,x2)
      | compare'(DOT(p1,l1,n1), DOT(p2,l2,n2))	= (case compare(p1,p2)
						     of r as (LESS|GREATER) => r
						      | EQUAL =>
						   case Lab.compare(l1,l2)
						     of r as (LESS|GREATER) => r
						      | EQUAL =>
						   Int.compare(n1,n2))

    fun hash(ref(PLAIN x))	= Name.hash x
      | hash(ref(DOT(p,l,n)))	= Lab.hash l


  (* Strengthening *)

    (* Strengthening has to be used carefully, as it results in a new
     * hash value, thereby invalidating eventual hash maps and sets! *)

    fun strengthen(p1, (p as ref(PLAIN _),l,n)) = p := DOT(p1,l,n)
      | strengthen _                            = ()


  (* Cloning *)

    fun instance lookup (rea, p) =
	let
	    fun clone p1 =
		case lookup(rea, p1)
		 of SOME p2 => p2
		  | NONE    =>
		case !p1
		 of p' as PLAIN _ => ref p'
		  | DOT(p,l,n)    => ref(DOT(clone p, l, n))
	in
	    clone p
	end
  end


structure Path : PATH = PathPrivate
(* src # 50 *)
structure PathSet = MakeHashImpSet(Path)
structure PathMap = MakeHashImpMap(Path)
(* src # 51 *)
signature TYPE =
  sig

  (* Types *)

    datatype sort = OPEN | CLOSED
    datatype kind = STAR | ARROW of kind * kind		(* [kappa,k] *)

    type lab  = Lab.t					(* [lab,l] *)
    type path = Path.t					(* [pi,p] *)
    type con  = kind * sort * path			(* [chi,c] *)

    type row						(* [rho,r] *)
    type var						(* [alpha,a] *)
    type typ						(* [tau,t] *)
    type t = typ

    type path_rea = path PathMap.t
    type typ_rea  = typ PathMap.t


  (* Injections *)

    val unknown :	kind      -> typ
    val inArrow :	typ * typ -> typ
    val inTuple :	typ list  -> typ
    val inRow :		row       -> typ
    val inSum :		row       -> typ
    val inVar :		var       -> typ
    val inCon :		con       -> typ
    val inAll :		var * typ -> typ
    val inExist :	var * typ -> typ
    val inLambda :	var * typ -> typ
    val inApp :		typ * typ -> typ
    val inRec :		typ       -> typ

    val var :		kind -> var

  (* Inquiries *)

    val isUnknown :	typ -> bool
    val isArrow :	typ -> bool
    val isTuple :	typ -> bool
    val isRow :		typ -> bool
    val isSum :		typ -> bool
    val isVar :		typ -> bool
    val isCon :		typ -> bool
    val isAll :		typ -> bool
    val isExist :	typ -> bool
    val isLambda :	typ -> bool
    val isApp :		typ -> bool

  (* Projections *)

    exception Type

    val asArrow :	typ -> typ * typ	(* Type *)
    val asTuple :	typ -> typ list		(* Type *)
    val asRow :		typ -> row		(* Type *)
    val asSum :		typ -> row		(* Type *)
    val asVar :		typ -> var		(* Type *)
    val asCon :		typ -> con		(* Type *)
    val asAll :		typ -> var * typ	(* Type *)
    val asExist :	typ -> var * typ	(* Type *)
    val asLambda :	typ -> var * typ	(* Type *)
    val asApp :		typ -> typ * typ	(* Type *)

  (* Complex extractions *)

    val kind :		typ -> kind
    val kindVar :	var -> kind

    val path :		typ -> path			(* Type *)
    val pathCon :	con -> path

    val paths :		typ -> PathSet.t

  (* Operations on rows *)

    exception Row

    val unknownRow :	unit -> row
    val emptyRow :	unit -> row
    val extendRow :	lab * typ list * row -> row	(* Row *)

    val openRowType :	typ -> unit			(* Row *)

  (* Copying and instantiation *)

    val instance :	typ -> typ
    val skolem :	typ -> typ
    val clone :		typ -> typ

    val realise :	typ_rea  * typ -> unit
    val realisePath :	path_rea * typ -> unit

  (* Unification and closure *)

    exception Unify of typ * typ
    exception UnifyList of int * typ * typ
    exception Intersect

    val unify :		typ * typ -> unit		(* Unify *)
    val unifyList :	typ list  -> unit		(* UnifyList *)
    val intersect :	typ * typ -> unit
    val close :		typ -> typ
    val isClosed :	typ -> bool

  (* Comparison *)

    val equals :	typ * typ -> bool
    val matches :	typ * typ -> bool

  (* Level management *)

    exception Lift of var

    val lift :		typ  -> unit			(* Lift *)
    val enterLevel :	unit -> unit
    val exitLevel :	unit -> unit
    val resetLevel :	unit -> unit

  end
(* src # 52 *)
(* NOTE: Reduction is still a bit strange for recursive type functions -
	 we get some non-wellformed lambdas in-between.
	 Have to look into it later... *)

structure TypePrivate =
  struct

  (* Types *)

    datatype sort = OPEN | CLOSED
    datatype kind = STAR | ARROW of kind * kind		(* [kappa,k] *)

    type lab  = Lab.t					(* [lab,l] *)
    type path = Path.t					(* [pi,p] *)
    type con  = kind * sort * path			(* [chi,c] *)

    datatype typ' =					(* [tau',t'] *)
	  HOLE of kind * int	(* variable for inference *)
	| LINK of typ		(* forward (needed for unification) *)
	| MARK of typ'		(* for traversal *)
	| ARR  of typ * typ	(* arrow type *)
	| TUP  of typ list	(* tuple *)
	| ROW  of row		(* record *)
	| SUM  of row		(* sum type (datatype) *)
	| VAR  of kind * int	(* bound variable or skolem types *)
	| CON  of con		(* constructor (of arbitrary kind) *)
	| ALL  of var * typ	(* universal quantification *)
	| EX   of var * typ	(* existential quantification *)
	| LAM  of var * typ	(* abstraction (type function) *)
	| APP  of typ * typ	(* application *)
	| REC  of typ		(* recursive type barrier *)

    and row =						(* [rho,r] *)
	  NIL
	| RHO of int ref
	| FLD of lab * typ list * row
	(* NOTE: representation of rows is suboptimal - change it some day *)

    withtype typ = typ' ref				(* [tau,t] *)
    and      var = typ' ref				(* [alpha,a] *)

    type t = typ

    type path_rea = path PathMap.t
    type typ_rea  = typ PathMap.t

    (*
     * We establish the following invariants:
     * - rows are sorted by label
     * - types are always in head normal form
     * - sequential quantifiers are ordered such that the bound variables
     *   appear in depth-first leftmost traversal order inside the body
     *)


(*DEBUG*)
    fun pr(ARR _)	= "ARR"
      | pr(TUP _)	= "TUP"
      | pr(ROW _)	= "ROW"
      | pr(SUM _)	= "SUM"
      | pr(CON _)	= "CON"
      | pr(VAR _)	= "VAR"
      | pr(ALL _)	= "ALL"
      | pr(EX  _)	= "EX"
      | pr(LAM _)	= "LAM"
      | pr(APP _)	= "APP"
      | pr(REC _)	= "REC"
      | pr(LINK _)	= "LINK"
      | pr(MARK _)	= "MARK"
      | pr(HOLE _)	= "HOLE"


  (* Level management *)

    val level = ref 1

    fun enterLevel() = level := !level+1
    fun exitLevel()  = level := !level-1
    fun resetLevel() = level := 1


  (* Follow a path of links (performing path compression on the fly) *)

    fun follow(ref(LINK t))	= follow t
      | follow t		= t

(*DEBUG
    fun follow'(ref(LINK t))	= follow' t
      | follow' t		= t

    fun follow(t as ref(LINK u))= let val v = follow' u in t := LINK v ; v end
      | follow t		= t
*)


  (* Kind inference *)

    fun rangeKind(ARROW(k1,k2))	= k2
      | rangeKind  _		= raise Crash.Crash "Type.rangeKind: \
						    \kind mismatch"

    fun kind(ref t')		= kind' t'

    and kind'(LINK t | REC t)	= kind t
      | kind'(HOLE(k,_))	= k
      | kind'(VAR(k,_))		= k
      | kind'(CON(k,_,_))	= k
      | kind'(LAM(a,t))		= ARROW(kind a, kind t)
      | kind'(APP(t1,t2))	= rangeKind(kind t1)
      | kind'(MARK t')		= kind' t'
      | kind' _			= STAR

    val kindVar			= kind


  (* Type graph traversal *)

    fun app1'(( HOLE _
	      | VAR _
	      | CON _ ), f)		= ()
      | app1'(( LINK t
	      | REC t
	      | ALL(_,t)
	      | EX (_,t)
	      | LAM(_,t)), f)		= f t
      | app1'(( ARR(t1,t2)
	      | APP(t1,t2)), f)		= ( f t1 ; f t2 )
      | app1'(( TUP ts ), f)		= List.app f ts
      | app1'(( ROW r
	      | SUM r ), f)		= appRow(r,f)
      | app1'(( MARK _ ), f)		= raise Crash.Crash "Type.app: MARK"

    and appRow(FLD(_,ts,r), f)		= ( List.app f ts ; appRow(r,f) )
      | appRow(_, f)			= ()


    fun foldl1'(( HOLE _
		| VAR _
		| CON _ ), f, a)	= a
      | foldl1'(( LINK t
		| REC t
		| ALL(_,t)
		| EX (_,t)
		| LAM(_,t)), f, a)	= f(t,a)
      | foldl1'(( ARR(t1,t2)
		| APP(t1,t2)), f, a)	= f(t2, f(t1,a))
      | foldl1'(( TUP ts ), f, a)	= List.foldl f a ts
      | foldl1'(( ROW r
		| SUM r ), f, a)	= foldlRow(r,f,a)
      | foldl1'(( MARK _ ), f, a)	= raise Crash.Crash "Type.foldl: MARK"

    and foldlRow(FLD(_,ts,r), f, a)	= foldlRow(r, f, List.foldl f a ts)
      | foldlRow(_, f, a)		= a


    fun unmark(t as ref(MARK t')) 	=
(*ASSERT				  assert t' of non MARK _ => *)
( case t' of MARK _ => raise Assert.failure | _ =>
					  ( t := t' ; app1'(t', unmark) )
)
      | unmark _	            	= ()


    fun app f t =
	let
	    fun app(ref(MARK _)) = ()
	      | app t =
		let
		    val _  = f t
		    val t' = !t
		    val _  = t := MARK t'
		in
		    app1'(t',app)
		end
	in
	    app t before unmark t handle e => ( unmark t ; raise e )
	end

    fun foldl f a t =
	let
	    fun fold(ref(MARK _), a) = a
	      | fold(t, a) =
		let
		    val a' = f(t,a)
		    val t' = !t
		    val _  = t := MARK t'
		in
		    foldl1'(t',fold,a')
		end
	in
	    fold(t,a) before unmark t handle e => ( unmark t ; raise e )
	end


  (* Cloning *)

    fun clone t =
	let
	    (* We want to be able to handle recursive types, so we have to
	     * implement graph copying here.
	     *)

	    val trail = ref []

	    fun dup'(t1 as ref t1') =
		let
		    val _   = trail := (t1,t1') :: !trail
		    val t2  = ref(MARK t1')
		    val _   = t1 := LINK t2
		in
		    t2
		end

	    fun dup(t1 as ref t1') =
		let
		    val _   = trail := (t1,t1') :: !trail
		    val t2  = ref(MARK t1')
		    val _   = t1 := LINK t2
		    val t2' = MARK(clone' t1')
		    val _   = t2 := t2'
		in
		    t2
		end

	    and clone t1 =
		let val t11 = follow t1 in
		    case !t11 of (MARK _ | VAR _ | HOLE _) => t11
			       | t11'                      => dup t11
		end

	    and clone'(ARR(t1,t2))	= ARR(clone t1, clone t2)
	      | clone'(TUP ts)		= TUP(List.map clone ts)
	      | clone'(ROW r)		= ROW(cloneRow r)
	      | clone'(SUM r)		= SUM(cloneRow r)
	      | clone'(CON c)		= CON c
	      | clone'(ALL(a,t))	= ALL(dup' a, clone t)
	      | clone'(EX(a,t))		= EX(dup' a, clone t)
	      | clone'(LAM(a,t))	= LAM(dup' a, clone t)
	      | clone'(APP(t1,t2))	= APP(clone t1, clone t2)
	      | clone'(REC t)		= REC(clone t)
(*DEBUG*)
| clone'(LINK _) = raise Crash.Crash "Type.clone: LINK"
| clone'(MARK _) = raise Crash.Crash "Type.clone: MARK"
| clone'(HOLE _) = raise Crash.Crash "Type.clone: HOLE"
| clone'(VAR _)  = raise Crash.Crash "Type.clone: VAR"
(*
	      | clone' _		= raise Crash.Crash "Type.clone"
*)
	    and cloneRow(FLD(l,ts,r))	= FLD(l, List.map clone ts, cloneRow r)
	      | cloneRow r		= r

	    val t2 = clone t
	in
	    List.app op:= (!trail) ;
	    unmark t2 ;
	    t2
	end


  (* Occur check (not used by unification) *)

    exception Occurs

    fun occurs(t1,t2) =
	let
	    fun occurs t = if t1 = t then raise Occurs else ()
	in
	    ( app occurs t2 ; false ) handle Occurs => true
	end


  (* Reduction to head normal form *)

    (*UNFINISHED: avoid multiple cloning of curried lambdas somehow *)

    fun reduce(t as ref(APP(t1,t2))) =
	let
	    fun reduceApp(t1 as ref(LAM(a,_)), r) =
		( t := HOLE(kind a, !level)
		; case !(clone t1)
		    of LAM(a,t11) =>
			( a := LINK t2
			; t := (if r then REC else LINK) t11
			; reduce t
			)
		    | _ => raise Crash.Crash "Type.reduceApp"
		)
	      | reduceApp(ref(LINK t11), r) =
		    reduceApp(follow t11, r)

	      | reduceApp(ref(REC t11), r) =
		    reduceApp(follow t11, true)

	      | reduceApp _ = ()
	in
	    reduceApp(t1, false)
	end

      | reduce _ = ()


    (*
     * We don't normally do eta-reduction, since it is expensive.
     * During unification we curently allow no lambdas anyway.
     * Eta-reduction is still needed however for equals, to equate
     * eta-convertible type functions. It's done on demand.
     *)
 
    fun reduceEta(t as ref(LAM _)) =
	let
	    fun reduceLam(ref(LAM(a,t1)), vs) =
		reduceLam(t1, a::vs)

	      | reduceLam(ref(APP(t1,t2)), a::vs) =
		let
		    val t2' = follow t2
		    val a'  = follow a
		in
		    if t2' = a' andalso not(occurs(a',t1)) then
			reduceLam(t1, vs)
		    else
			()
		end

	      | reduceLam(t1, []) =
		    ( t := LINK t1 ; reduceEta t1 )

	      | reduceLam(ref(LINK t1), vs) =
		    reduceLam(t1, vs)

	      | reduceLam _ = ()
	in
	    reduceLam(t, [])
	end

      | reduceEta(ref(LINK t)) = reduceEta t

      | reduceEta _ = ()


  (* Creation and injections *)

    fun unknown' k	= HOLE(k, !level)
    fun unknown k	= ref(unknown' k)

    fun inArrow tt	= ref(ARR tt)
    fun inTuple ts	= ref(TUP ts)
    fun inRow r		= ref(ROW r)
    fun inSum r		= ref(SUM r)
    fun inVar a		= a
    fun inCon c		= ref(CON c)
    fun inAll at	= ref(ALL at)
    fun inExist at	= ref(EX at)
    fun inLambda at	= ref(LAM at)
    fun inApp(t1,t2)	= let val t = ref(APP(t1,t2)) in reduce t ; t end
    fun inRec t		= ref(REC t)

    fun var k		= ref(VAR(k, !level))


  (* Projections and extractions *)

    exception Type

    fun asType(ref(LINK t | REC t))	= asType t
      | asType(ref t')			= t'

    fun isUnknown t	= case asType t of HOLE _ => true | _ => false
    fun isArrow t	= case asType t of ARR _ => true | _ => false
    fun isTuple t	= case asType t of TUP _ => true | _ => false
    fun isRow t		= case asType t of ROW _ => true | _ => false
    fun isSum t		= case asType t of SUM _ => true | _ => false
    fun isVar t		= case asType t of VAR _ => true | _ => false
    fun isCon t		= case asType t of CON _ => true | _ => false
    fun isAll t		= case asType t of ALL _ => true | _ => false
    fun isExist t	= case asType t of EX  _ => true | _ => false
    fun isLambda t	= case asType t of LAM _ => true | _ => false
    fun isApp t		= case asType t of APP _ => true | _ => false

    fun asArrow t	= case asType t of ARR tt => tt | _ => raise Type
    fun asTuple t	= case asType t of TUP ts => ts | _ => raise Type
    fun asRow t		= case asType t of ROW r  => r  | _ => raise Type
    fun asSum t		= case asType t of SUM r  => r  | _ => raise Type
    fun asVar t		= case asType t of VAR _  => t  | _ => raise Type
    fun asCon t		= case asType t of CON c  => c  | _ => raise Type
    fun asAll t		= case asType t of ALL at => at | _ => raise Type
    fun asExist t	= case asType t of EX  at => at | _ => raise Type
    fun asLambda t	= case asType t of LAM at => at | _ => raise Type
    fun asApp t		= case asType t of APP tt => tt | _ => raise Type

    fun pathCon(_,_,p)	= p
    fun path t		= pathCon(asCon t)

(*
    fun holes t = foldl (fn(t as ref(HOLE _), a) => t::a | (t,a) => a) t
    fun paths t = foldl (fn(t as ref(CON c), a) => pathCon(c)::a | (t,a) => a) t
*)

    fun paths t =
    	let
	    val s = PathSet.new()
	in
	    app (fn(ref(CON c)) => PathSet.insert(s, pathCon c) | _ => ()) t ;
	    s
	end


    exception Unclosed

    fun checkClosedRow NIL		= ()
      | checkClosedRow(RHO _)		= raise Unclosed
      | checkClosedRow(FLD(l,t,r))	= checkClosedRow r

    fun checkClosed'(HOLE _)		= raise Unclosed
      | checkClosed'(ROW r | SUM r)	= checkClosedRow r
      | checkClosed' _			= ()

    fun isClosed t =
	( app (fn ref t' => checkClosed' t') t ; true )
	handle Unclosed => false


  (* Instantiation *)

    (* Instantiate universally quantified types, skolemise
     * existentially qualified types. If there is any quantification,
     * then we have to copy the type.
     * Skolemisation does it the other way round (needed for checking rank 2
     * signature applications and existential types).
     *)

    fun instance'(ref(ALL(a,t)))	= ( a := unknown'(kind a); instance' t )
      | instance'(ref(EX(a,t)))		= instance' t
      | instance' t			= t

    fun instance(t as ref(ALL _| EX _))	= instance'(clone t)
      | instance(ref(LINK t))		= instance t
      | instance t			= t

    fun skolem'(ref(ALL(a,t)))		= skolem' t
      | skolem'(ref(EX(a,t)))		= ( a := unknown' STAR ; skolem' t )
      | skolem' t			= t

    fun skolem(t as ref(ALL _| EX _))	= skolem'(clone t)
      | skolem(ref(LINK t))		= skolem t
      | skolem t			= t



  (* Operations on rows *)

    exception Row

    fun unknownRow()	= RHO(ref(!level))
    fun emptyRow()	= NIL

    fun extendRow(l,ts, r as (RHO _ | NIL))	= FLD(l,ts,r)
      | extendRow(l1,ts1, r1 as FLD(l2,ts2,r2)) =
	case Lab.compare(l1,l2)
	  of EQUAL   => raise Row
	   | LESS    => FLD(l1, ts1, r1)
	   | GREATER => FLD(l2, ts2, extendRow(l1,ts1,r2))

    fun tupToRow ts =
	let
	    fun loop(n,  []  ) = NIL
	      | loop(n, t::ts) = FLD(Lab.fromInt n, [t], loop(n+1,ts))
	in
	    loop(1,ts)
	end

    fun openRow NIL			= RHO(ref(!level))
      | openRow(r as RHO _)		= r
      | openRow(FLD(l,ts,r))		= FLD(l, ts, openRow r)

    fun openRowType(ref(LINK t))	= openRowType t
      | openRowType(t as ref(ROW r))	= t := ROW(openRow r)
      | openRowType(t as ref(SUM r))	= t := SUM(openRow r)
      | openRowType _			= raise Row


  (* Closure *)

    fun close t =
    	let
	    fun close(a as ref(HOLE(k,n)), f) =
		if n > !level then
		    ( a := VAR(k,n) ; fn t => f(inAll(a,t)) )
		else f

	      | close(a as ref(VAR(k,n)), f) =
		(* We have to quantify over VARs as well.
		 * The reason is that there may be several types being
		 * closed that share parts of their graphs.
		 * Note that this means we have to take care to choose
		 * a unique upper level when we use VAR for skolem types.
		 *)
		if n > !level then
		    fn t => f(inAll(a,t))
		else f

	      | close(ref(ALL(a,t) | EX(a,t)), f) =
		( a := MARK(!a) ; f )	(* bit of a hack... *)

	      | close(t as ref(ROW r), f) = ( t := ROW(closeRow r) ; f )
	      | close(t as ref(SUM r), f) = ( t := SUM(closeRow r) ; f )

	      | close(_, f) = f

	    and closeRow NIL              = NIL
	      | closeRow(r as RHO(ref n)) = if n > !level then NIL else r
	      | closeRow(FLD(l,t,r))      = FLD(l, t, closeRow r)
	in
	    foldl close (fn t => t) t t
	end


  (* Lifting a type to the current level *)

    exception Lift of var

    fun lift t =
	let
	    fun lift(t as ref(t' as HOLE(k,n))) =
		    if n > !level then t := HOLE(k,!level) else ()
	      | lift(t as ref(VAR(k,n))) =
		    if n > !level then raise Lift t else ()
	      | lift(ref(ROW r | SUM r)) = liftRow r
	      | lift t = ()
	in
	    app lift t
	end

    and liftRow(NIL)        = ()
      | liftRow(RHO n)      = if !n > !level then n := !level else ()
      | liftRow(FLD(l,t,r)) = liftRow r


  (* Unification *)

    exception Unify of typ * typ


    fun liftAndCheck(n,t1,t2) =
	let
	    fun lift(t as ref(t' as HOLE(k,n'))) =
		    t := MARK(if n' <= n then t' else HOLE(k,n))
	      | lift(ref(MARK _)) = ()
	      | lift(t as ref(t' as (ROW r | SUM r))) =
		    ( liftRow r ; t := MARK t' ; app1'(t', lift) )
	      | lift(t as ref t') = ( t := MARK t' ; app1'(t', lift) )

	    and liftRow(NIL)        = ()
	      | liftRow(RHO n')     = if !n' > n then n' := n else ()
	      | liftRow(FLD(l,t,r)) = liftRow r

	    fun check(t as ref t') =
		if t1 = t then
		    ( unmark t2 ; raise Unify(t1,t2) )
		else case t'
		  of HOLE(k,n') => t := MARK(if n' <= n then t' else HOLE(k,n))
		   | MARK _     => ()
		   | REC _      => ( t := MARK t' ; app1'(t', lift) )
		   | _          => ( t := MARK t' ; app1'(t', check) )
	in
	    check t2 ; unmark t2
	end


    fun unify(t1,t2) =
	let
	    val trail = ref []

	    fun unify(t1,t2) =
		let
		    val t1 as ref t1' = follow t1
		    val t2 as ref t2' = follow t2

		    fun recur f x =
			( t1 := LINK t2
			; trail := (t1,t1') :: !trail
			; f x
			)
		in
		    if t1 = t2 then () else
		    case (t1',t2')
		      of (HOLE(k1,n1), HOLE(k2,n2)) =>
(*ASSERT		 assert k1 = k2 =>*)
if k1 <> k2 then raise Assert.failure else
			 if n1 < n2 then t2 := LINK t1
				    else t1 := LINK t2

		       | (HOLE(k1,n), _) =>
(*ASSERT		 assert k1 = kind' t2' =>*)
if k1 <> kind' t2' then raise Assert.failure else
			 ( liftAndCheck(n,t1,t2) ; t1 := LINK t2 )

		       | (_, HOLE(k2,n)) =>
(*ASSERT		 assert kind' t1' = k2 =>*)
if kind' t1' <> k2 then raise Assert.failure else
			 ( liftAndCheck(n,t2,t1) ; t2 := LINK t1 )

		       | (REC(t11), REC(t21)) =>
			 recur unify (t11,t21)

		       | (REC(t11), _) =>
			 ( t2 := REC(ref t2') ; unify(t1,t2) )

		       | (_, REC(t21)) =>
			 ( t1 := REC(ref t1') ; unify(t1,t2) )

		       | (ARR(tt1), ARR(tt2)) =>
			 recur unifyPair (tt1,tt2)

		       | (TUP(ts1), TUP(ts2)) =>
			 recur (ListPair.app unify) (ts1,ts2)

		       | (TUP(ts), ROW(r)) =>
			 recur unifyRow (t1, t2, tupToRow ts, r, ROW)

		       | (ROW(r), TUP(ts)) =>
			 recur unifyRow (t1, t2, r, tupToRow ts, ROW)

		       | (ROW(r1), ROW(r2)) =>
			 recur unifyRow (t1, t2, r1, r2, ROW)

		       | (SUM(r1), SUM(r2)) =>
			 recur unifyRow (t1, t2, r1, r2, SUM)

		       | (CON(_,_,p1), CON(_,_,p2)) =>
			 if p1 = p2 then t1 := LINK t2
				    else raise Unify(t1,t2)

		       | (APP(tt1), APP(tt2)) =>
			 (* Note that we do not allow general lambdas during
			  * unification, so application is considered to be
			  * in normal form *)
			 recur unifyPair (tt1,tt2)

		       | (ALL(a1,t11), ALL(a2,t21)) =>
			 raise Crash.Crash "Type.unify: universal quantifier"

		       | (EX(a1,t11), EX(a2,t21)) =>
			 raise Crash.Crash "Type.unify: existential quantifier"

		       | (LAM(a1,t11), LAM(a2,t21)) =>
			 raise Crash.Crash "Type.unify: abstraction"

		       | _ => raise Unify(t1,t2)
		end

	    and unifyPair((t11,t12), (t21,t22)) =
		( unify(t11,t21) ; unify(t12,t22) )

	    and unifyRow(t1, t2, r1, r2, ROWorSUM) =
		let
		    fun loop(NIL, false, NIL, false) = NIL
		      | loop(NIL, false, RHO _, _  ) = NIL
		      | loop(RHO _, _,   NIL, false) = NIL
		      | loop(RHO n1, _,  RHO n2, _ ) =
			    RHO(ref(Int.min(!n1, !n2)))
		      | loop(rho as RHO _, _, FLD(l,ts,r), b2) =
			    FLD(l,ts, loop(rho, true, r, b2))
		      | loop(FLD(l,ts,r), b1, rho as RHO _, _) =
			    FLD(l,ts, loop(r, b1, rho, true))
		      | loop(r1 as FLD(l1,ts1,r1'), b1,
			     r2 as FLD(l2,ts2,r2'), b2) =
			(case Lab.compare(l1,l2)
			   of EQUAL   => ( ListPair.app unify (ts1,ts2)
					 ; FLD(l1,ts1, loop(r1',b1, r2',b2)) )
			    | LESS    => FLD(l1,ts1, loop(r1',b1, r2,true))
			    | GREATER => FLD(l2,ts2, loop(r1,true, r2',b2))
			)
		      | loop _ = raise Unify(t1,t2)
		in
		    t2 := ROWorSUM(loop(r1,false, r2,false))
		end
	in
	    unify(t1,t2)
	    handle Unify tt => ( List.app op:= (!trail) ; raise Unify tt )
	end


  (* Unification of lists *)

    exception UnifyList of int * typ * typ

    fun unifyList  []    = ()
      | unifyList(t::ts) = 
	let
	    fun loop(n,   []   ) = ()
	      | loop(n, t'::ts') =
	        ( unify(t,t')
		  handle Unify(t1,t2) => raise UnifyList(n,t1,t2)
		; loop(n+1, ts')
		)
	in
	    loop(0,ts)
	end


  (* Matching *)

    fun matches(t1,t2) =
	let
	    val t1' = instance t1
	    val t2' = skolem t2
	in
	    ( unify(t1',t2') ; true ) handle Unify _ => false
	end


  (* Comparison *)

    fun equals(t1,t2) =
	let
	    val trail = ref []

	    fun equals(t1,t2) =
		let
		    val t1 as ref t1' = follow t1
		    val t2 as ref t2' = follow t2

		    fun recur p x =
			( t1 := LINK t2
			; trail := (t1,!t1) :: !trail
			; p x
			)

		    fun recurBinder(a1 as ref a1', a2, t1, t2) =
			( a1 := LINK a2
			; trail := (a1,a1') :: !trail
			; recur equals (t1,t2)
			)
		in
		    t1 = t2 orelse
		    case (t1',t2')
		      of (REC(t11), REC(t21)) =>
			 recur equals (t11,t21)

		       | (REC(t11), _) =>
			 recur equals (t11,t2)

		       | (_, REC(t21)) =>
			 recur equals (t1,t21)

		       | (ARR(tt1), ARR(tt2)) =>
			 recur equalsPair (tt1,tt2)

		       | (TUP(ts1), TUP(ts2)) =>
			 recur (ListPair.all equals) (ts1,ts2)

		       | ( (TUP(ts), ROW(r))
			 | (ROW(r), TUP(ts)) ) =>
			 recur equalsRow (r, tupToRow ts)

		       | ( (ROW(r1), ROW(r2))
			 | (SUM(r1), SUM(r2)) ) =>
			 recur equalsRow (r1,r2)

		       | (CON(_,_,p1), CON(_,_,p2)) =>
			 p1 = p2

		       | (APP(tt1), APP(tt2)) =>
			 recur equalsPair (tt1,tt2)

		       | ( (LAM _, _) | (_, LAM _) ) =>
			 ( reduceEta t1
			 ; reduceEta t2
			 ; case (!t1,!t2)
			     of (LAM(a1,t11), LAM(a2,t21)) =>
				recurBinder(a1, a2, t11, t21)
			      | ( (LAM _, _) | (_, LAM _) ) => false
			      | _ => equals(t1,t2)
			 )
		       | ( (ALL(a1,t11), ALL(a2,t21))
			 | (EX(a1,t11), EX(a2,t21)) ) =>
			 recurBinder(a1, a2, t11, t21)

		       | _ => false
		end

	    and equalsPair((t11,t12), (t21,t22)) =
		equals(t11,t21) andalso equals (t12,t22)

	    and equalsRow(NIL,   NIL)   = true
	      | equalsRow(RHO _, RHO _) = true
	      | equalsRow(FLD(l1,ts1,r1), FLD(l2,ts2,r2)) =
		l1 = l2 andalso ListPair.all equals (ts1,ts2)
			andalso equalsRow(r1,r2)
	      | equalsRow _ = false
	in
	    equals(t1,t2) before List.app op:= (!trail)
	end


  (* Realisation *)

    fun realisePath(rea, t) =
	let
	    fun subst(t1 as ref(CON(k,s,p))) =
		( case PathMap.lookup(rea, p)
		    of SOME p' => t1 := CON(k,s,p')
		     | NONE    => ()
		)
	      | subst t1 = ()
	in
	    app subst t
	end

    (*
     * Realisations need not be fully expanded (would be nice to have this
     * property because it would make substitution more efficient, but
     * full expansion is difficult to achieve for the intersect function).
     *)

    fun realise(rea, t) =
	let
	    val apps = ref[]

	    fun subst(t1 as ref(CON(k,s,p))) =
		(case PathMap.lookup(rea, p)
		   of SOME t2 => t1 := LINK(clone t2)	(* expand *)
		    | NONE    => ()
		)
	      | subst(t1 as ref(APP _)) = apps := t1::(!apps)
	      | subst t1 = ()
	in
	    app subst t ; List.app reduce (!apps)
	end


  (* Intersection *)

    exception Intersect

    fun intersect(t1,t2) = ()
    (* UNFINISHED *)

  end


structure Type : TYPE = TypePrivate
(* src # 53 *)
signature INF =
  sig

  (* Types *)

    type lab   = Lab.t
    type name  = Name.t
    type stamp = Stamp.t
    type path  = Path.t
    type typ   = Type.t
    type tkind = Type.kind

    datatype val_sort = VALUE | CONSTRUCTOR	(* [w] *)
    datatype typ_sort = datatype Type.sort	(* [w] *)

    type kind					(* [kappa,k] *)
    type con  = kind * path			(* [chi,c]   *)
    type sign					(* [sigma,s] *)
    type inf					(* [jota,j] *)
    type t = inf    

  (* Realisations *)

    type val_rea = path PathMap.t
    type typ_rea = typ  PathMap.t
    type mod_rea = path PathMap.t
    type inf_rea = inf  PathMap.t

    type rea	 = { val_rea : val_rea
		   , typ_rea : typ_rea
		   , mod_rea : mod_rea
		   , inf_rea : inf_rea
		   }

  (* Injections *)

    val inTop :		unit		 -> inf
    val inCon :		con		 -> inf
    val inSig :		sign		 -> inf
    val inArrow :	path * inf * inf -> inf
    val inLambda :	path * inf * inf -> inf
    val inApp :		inf * path * inf -> inf

  (* Inquiries *)

    val isTop :		inf -> bool
    val isCon :		inf -> bool
    val isSig :		inf -> bool
    val isArrow :	inf -> bool
    val isLambda :	inf -> bool
    val isApp :		inf -> bool

  (* Projections *)

    exception Interface

    val asCon :		inf -> con			(* Interface *)
    val asSig :		inf -> sign			(* Interface *)
    val asArrow :	inf -> path * inf * inf		(* Interface *)
    val asLambda :	inf -> path * inf * inf		(* Interface *)
    val asApp :		inf -> inf * path * inf		(* Interface *)

  (* Cloning etc. *)

    val clone :		inf -> inf
    val instance :	inf -> inf
    val singleton :	inf -> inf
    val realise :	rea  * inf -> unit
    val strengthen :	path * inf -> unit
    val strengthenSig :	path * sign -> unit

  (* Kinds *)

    exception Kind

    val inGround :	unit -> kind
    val inDependent :	path * inf * kind -> kind

    val isGround :	kind -> bool
    val isDependent :	kind -> bool
    val asDependent :	kind -> path * inf * kind	(* Kind *)

    val kind :		inf -> kind

  (* Signature construction *)

    val empty :		unit -> sign

    val newVal :	sign * lab -> path
    val newTyp :	sign * lab -> path
    val newMod :	sign * lab -> path
    val newInf :	sign * lab -> path

    val extendVal :	sign * path *  typ  * val_sort * path option -> unit
    val extendTyp :	sign * path * tkind * typ_sort * typ  option -> unit
    val extendMod :	sign * path *  inf  * path option -> unit
    val extendInf :	sign * path *  kind * inf  option -> unit

  (* Signature lookup *)

    val lookupVal :	sign * lab -> typ
    val lookupTyp :	sign * lab -> typ
    val lookupMod :	sign * lab -> inf
    val lookupInf :	sign * lab -> inf

    val lookupVal' :	sign * lab * int -> typ
    val lookupTyp' :	sign * lab * int -> typ
    val lookupMod' :	sign * lab * int -> inf
    val lookupInf' :	sign * lab * int -> inf

    val lookupValPath :	sign * lab -> path
    val lookupModPath :	sign * lab -> path

  (* Closure check *)

    exception Unclosed of lab * int * typ

    val close :		sign -> unit			(* Unclosed *)

  (* Matching and intersection *)

    datatype mismatch =
	  MissingVal  of lab
	| MissingTyp  of lab
	| MissingMod  of lab
	| MissingInf  of lab
	| ManifestVal of lab
	| ManifestTyp of lab
	| ManifestMod of lab
	| ManifestInf of lab
	| MismatchVal of lab * typ * typ
	| MismatchTyp of lab * tkind * tkind
	| MismatchMod of lab * mismatch
	| MismatchInf of lab * mismatch
	| MismatchValSort of lab * val_sort * val_sort
	| MismatchTypSort of lab * typ_sort * typ_sort
	| MismatchDom     of mismatch
	| MismatchRan     of mismatch
	| Incompatible    of inf * inf
	| IncompatibleArg of path * path

    exception Mismatch of mismatch

    val match :		inf * inf -> rea		(* Mismatch *)
    val intersect :	inf * inf -> inf		(* Mismatch *)

  end
(* src # 54 *)
(* Interfaces contain state. This means that they must be instantiated
   at each occurance. *)

structure InfPrivate =
  struct

  (* Types *)

    type lab	= Lab.t
    type name	= Name.t
    type stamp	= Stamp.t
    type path	= Path.t
    type typ	= Type.t
    type tkind	= Type.kind

    datatype val_sort = VALUE | CONSTRUCTOR		(* [w] *)
    datatype typ_sort = datatype Type.sort		(* [w] *)

    type id	= path * lab * int			(* [x] *)
    type 'a def	= 'a option				(* [d] *)


    (* A map for signatures *)

    datatype space = VAL' | TYP' | MOD' | INF'

    structure Map = MakeHashImpMap(struct type t = space * lab
					  fun hash(_,l) = Lab.hash l end)


    datatype inf' =
	  TOP					(* top *)
	| CON of con				(* interface constructor *)
	| SIG of sign				(* signature *)
	| ARR of path * inf * inf		(* arrow (functor) *)
	| LAM of path * inf * inf		(* abstraction (dep. function)*)
	| APP of inf * path * inf		(* application *)
	| LINK of inf

    and item' =
	  VAL of id *  typ  * val_sort * path def	(* value *)
	| TYP of id * tkind * typ_sort * typ def	(* type *)
	| MOD of id *  inf  * path def			(* module *)
	| INF of id *  kind * inf def			(* interface *)

    and kind' =						(* [kappa,k] *)
	  GROUND					(* ordinary interface *)
	| DEP of path * inf * kind			(* dependent *)

    withtype inf  = inf' ref				(* [jota,j] *)
    and      kind = kind' ref				(* [kappa,k] *)
    and      con  = kind' ref * path			(* [chi,c] *)
    and      item = item' ref				(* [item] *)
    and      sign = item' ref list ref * item' ref list Map.t	(* [sigma,s] *)

    type t = inf


  (* Realisations *)

    type val_rea = path PathMap.t
    type typ_rea = typ  PathMap.t
    type mod_rea = path PathMap.t
    type inf_rea = inf  PathMap.t

    type rea	 = { val_rea : val_rea
		   , typ_rea : typ_rea
		   , mod_rea : mod_rea
		   , inf_rea : inf_rea
		   }

    fun emptyRea() = { val_rea = PathMap.new()
		     , typ_rea = PathMap.new()
		     , mod_rea = PathMap.new()
		     , inf_rea = PathMap.new()
		     } : rea


  (* Simple accessors *)

    fun idPath(p,l,n)		= p
    fun idLab(p,l,n)		= l
    fun idIndex(p,l,n)		= n

    fun itemId(ref item')	= itemId' item'
    and itemId'(VAL(id,_,_,_))	= id
      | itemId'(TYP(id,_,_,_))	= id
      | itemId'(MOD(id,_,_))	= id
      | itemId'(INF(id,_,_))	= id

    fun itemPath  item		= idPath(itemId item)
    fun itemLab   item		= idLab(itemId item)
    fun itemIndex item		= idIndex(itemId item)

    fun itemSpace(ref item')	= itemSpace' item'
    and itemSpace'(VAL _)	= VAL'
      | itemSpace'(TYP _)	= TYP'
      | itemSpace'(MOD _)	= MOD'
      | itemSpace'(INF _)	= INF'


  (* Follow a path of links (performing path compression on the fly) *)

    fun follow(ref(LINK j))	= follow j
      | follow j		= j

(*DEBUG
    fun follow'(ref(LINK j))	= follow' j
      | follow' j		= j

    fun follow(j as ref(LINK k))= let val l = follow' k in j := LINK l ; l end
      | follow j		= j
*)


  (* Signature construction *)

    fun empty()			= (ref [], Map.new())

    fun newItem(s, l)		= Path.fromLab l
    val newVal			= newItem
    val newTyp			= newItem
    val newMod			= newItem
    val newInf			= newItem

    fun hideId (p,l,n)		= (p,l,n+1)
    fun hide item		= item := hide'(!item)
    and hide'(VAL(id,t,w,d))	= VAL(hideId id, t, w, d)
      | hide'(TYP(id,k,w,d))	= TYP(hideId id, k, w, d)
      | hide'(MOD(id,j,d))	= MOD(hideId id, j, d)
      | hide'(INF(id,k,d))	= INF(hideId id, k, d)

    fun extend((itemsr,map), space, p, makeItem') =
	let
	    val l    = Path.toLab p
	    val item = ref(makeItem'(p,l,0))
	in
	    itemsr := item :: !itemsr ;
	    Map.insertWith (fn(items,_) => (List.app hide items ; item::items))
			   (map, (space,l), [item])
	end

    fun extendVal(s,p,t,w,d)	= extend(s, VAL', p, fn x => VAL(x,t,w,d))
    fun extendTyp(s,p,k,w,d)	= extend(s, TYP', p, fn x => TYP(x,k,w,d))
    fun extendMod(s,p,j,d)	= extend(s, MOD', p, fn x => MOD(x,j,d))
    fun extendInf(s,p,k,d)	= extend(s, INF', p, fn x => INF(x,k,d))


  (* Signature lookup *)

    fun selectVal'(VAL(x, t, w, d))	= t
      | selectVal' _			= raise Crash.Crash "Inf.selectVal'"

    fun selectVal(VAL(x, t, w, SOME p))	= p
      | selectVal(VAL(x, t, w, NONE))	= idPath x
      | selectVal _			= raise Crash.Crash "Inf.selectVal"

    fun selectTyp(TYP(x, k, w, SOME t))	= t
      | selectTyp(TYP(x, k, w, NONE))	= Type.inCon(k, w, idPath x)
      | selectTyp _			= raise Crash.Crash "Inf.selectTyp"

    fun selectMod'(MOD(x, j, d))	= j
      | selectMod' _			= raise Crash.Crash "Inf.selectMod'"

    fun selectMod(MOD(x, j, SOME p))	= p
      | selectMod(MOD(x, j, NONE))	= idPath x
      | selectMod _			= raise Crash.Crash "Inf.selectMod"

    fun selectInf(INF(x, k, SOME j))	= j
      | selectInf(INF(x, k, NONE))	= ref(CON(k, idPath x))	(* inCon *)
      | selectInf _			= raise Crash.Crash "Inf.selectInf"


    fun lookup space ((_,m), l) =
	case Map.lookup(m, (space,l))
	  of SOME(item::items) => !item
	   | _                 => raise Crash.Crash "Inf.lookup"

    fun lookup' space ((_,m), l, n) =
	case Map.lookup(m, (space,l))
	  of SOME(item::items) =>
		!(Option.valOf(List.find (fn item => itemIndex item = n) items))
	   | _ => raise Crash.Crash "Inf.lookup'"

    fun lookupVal args	= (selectVal' o lookup VAL') args
    fun lookupTyp args	= (selectTyp  o lookup TYP') args
    fun lookupMod args	= (selectMod' o lookup MOD') args
    fun lookupInf args	= (selectInf  o lookup INF') args

    fun lookupVal' args	= (selectVal' o lookup' VAL') args
    fun lookupTyp' args	= (selectTyp  o lookup' TYP') args
    fun lookupMod' args	= (selectMod' o lookup' MOD') args
    fun lookupInf' args	= (selectInf  o lookup' INF') args

    fun lookupValPath args = (selectVal o lookup VAL') args
    fun lookupModPath args = (selectMod o lookup MOD') args


  (* Closure check *)

    exception Unclosed of lab * int * typ

    fun close (ref items,_) = List.app closeItem items

    and closeItem(ref(VAL((p,l,n), t, w, d))) =
	if Type.isClosed t then () else
	    raise Unclosed(l,n,t)
      | closeItem _ = ()
	(* ASSUME that nested structures are always closed *)


  (* Reduction to head normal form *)

    (*UNFINISHED: avoid multiple cloning of curried lambdas somehow *)

    fun reduce(j as ref(APP(j1,p,j2)))	= reduceApp(j, j1, p, j2)
      | reduce(ref(LINK j))		= reduce j
      | reduce _			= ()

    and reduceApp(j, j1 as ref(LAM _), p, j2) =
	( case !(instance j1)
	    of LAM(p1, j11, j12) =>
		(*UNFINISHED: do realisation *)
		(*Path.replace(p1, p)*)
		( j := LINK j12
		; reduce j
		)
	    | _ => raise Crash.Crash "Type.reduceApp"
	)
      | reduceApp(j, j1, p, j2) = ()


  (* Realisation *)

    (* Applied realisations have to be complete:
     *
     *   Whenever there is a p in Dom(#mod_rea rea), then rea must also
     *   contain substitutions for all subitems of module p.
     *
     * This way we avoid substitutions inside paths (which would require
     * passing around a suitable environment), because if there is a
     * substitution for a subpath then there also is a substitution for
     * the complete path.
     *
     * Realisations need not be fully expanded (would be nice to have this
     * property because it would make substitution more efficient, but
     * full expansion is difficult to achieve for the intersect function).
     *)

    and realise (rea: rea, j as ref j')	= j := realise'(rea, j')

    and realise'(rea, LINK j)		= realise'(rea, !j)
      | realise'(rea, TOP)		= TOP
      | realise'(rea, CON c)		= realiseCon(rea, c)
      | realise'(rea, j' as SIG s)	= ( realiseSig(rea, s)
					  ; j'
					  )
      | realise'(rea, j' as ( ARR(_,j1,j2) | LAM(_,j1,j2) )) =
					  ( realise(rea, j1)
					  ; realise(rea, j2)
					  ; j'
					  )
      | realise'(rea, APP(j1,p,j2))	= ( realise(rea, j1)
					  ; realise(rea, j2)
					  (* UNFINISHED: do reduction *)
					  ; APP(j1, realisePath(#mod_rea rea, p), j2)
					  )

    and realiseKind (rea, ref k')	= realiseKind'(rea, k')
    and realiseKind'(rea, GROUND)	= ()
      | realiseKind'(rea, DEP(_,j,k))	= ( realise(rea, j)
					  ; realiseKind(rea, k)
					  )

    and realiseSig(rea, (ref items, _))	=
	    List.app (fn item => realiseItem(rea, item)) items

    and realiseItem(rea, item as ref(VAL(x, t, w, d))) =
	( realiseTyp(rea, t) ; item := VAL(x, t, w, realiseValDef(rea, d)))
      | realiseItem(rea, ref(TYP(x, k, w, d))) =
	  realiseTypDef(rea, d)
      | realiseItem(rea, item as ref(MOD(x, j, d))) =
	( realise(rea, j) ; item := MOD(x, j, realiseModDef(rea, d)) )
      | realiseItem(rea, ref(INF(x, k, d))) =
	( realiseKind(rea, k) ; realiseInfDef(rea, d) )

    and realiseCon(rea, kp as (k,p)) =
	case PathMap.lookup(#inf_rea rea, p)
	  of SOME j => let val j' = instance j in
			  realise(rea, j') ; LINK j'		(* expand *)
		       end
	   | NONE   => ( realiseKind(rea, k) ; CON kp )

    and realisePath(rea', p)		=
	 case PathMap.lookup(rea', p)
					    of NONE    => p
					     | SOME p' => realisePath(rea', p')
    and realisePathDef(rea', NONE  )	= NONE
      | realisePathDef(rea', SOME p)	= SOME(realisePath(rea', p))

    and realiseValDef(rea, d)		= realisePathDef(#val_rea rea, d)
    and realiseModDef(rea, d)		= realisePathDef(#mod_rea rea, d)

    and realiseTypDef(rea, NONE  )	= ()
      | realiseTypDef(rea, SOME t)	= realiseTyp(rea, t)

    and realiseInfDef(rea, NONE  )	= ()
      | realiseInfDef(rea, SOME j)	= realise(rea, j)

    and realiseTyp(rea, t)		= Type.realise(#typ_rea rea, t)


  (* Instantiation *)

    and instance j			= instanceInf(PathMap.new(), j)

    and instanceInf (rea, ref j')	= ref(instanceInf'(rea, j'))
    and instanceInf'(rea, LINK j)	= instanceInf'(rea, !j)
      | instanceInf'(rea, TOP)		= TOP
      | instanceInf'(rea, CON c)	= CON(instanceCon(rea, c))
      | instanceInf'(rea, SIG s)	= SIG(instanceSig(rea, s))
      | instanceInf'(rea, ARR(p,j1,j2))	= ARR(instancePath(rea, p),
					      instanceInf(rea, j1),
					      instanceInf(rea, j2))
      | instanceInf'(rea, LAM(p,j1,j2))	= LAM(instancePath(rea, p),
					      instanceInf(rea, j1),
					      instanceInf(rea, j2))
      | instanceInf'(rea, APP(j1,p,j2))	= APP(instanceInf(rea, j1),
					      realisePath(rea, p),
					      instanceInf(rea, j2))

    and instanceCon(rea, (k,p))		= ( instanceKind(rea, k),
					    realisePath(rea, p) )

    and instanceKind (rea, ref k')	= ref(instanceKind'(rea, k'))
    and instanceKind'(rea, GROUND)	= GROUND
      | instanceKind'(rea, DEP(p,j,k))	= DEP(instancePath(rea, p),
					      instanceInf(rea, j),
					      instanceKind(rea, k))
    and instancePath(rea, p) =
	let
	    val p' = Path.instance PathMap.lookup (rea, p)
	in
	    (*UNFINISHED: do we need to make the check? *)
	    if p' <> p then PathMap.insert(rea, p, p') else () ;
	    p'
	end

    and instanceSig(rea, (ref items,_)) =
	let
	    val s as (itemsr,map) = empty()

	    fun extendSig(space_l, item) =
		( itemsr := item :: !itemsr
		; Map.insertWith (fn(l1,l2) => l2 @ l1) (map, space_l, [item])
		)

	    fun instanceItem(ref item') = instanceItem' item'

	    and instanceItem'(VAL((p,l,n), t, w, d)) =
		let
		    val p'   = instancePath(rea, p)
		    val t'   = instanceTyp(rea, t)
		    val d'   = instancePathDef(rea, d)
		    val item = ref(VAL((p',l,n), t', w, d'))
		in
		    extendSig((VAL',l), item)
		end

	      | instanceItem'(TYP((p,l,n), k, w, d)) =
		let
		    val p'   = instancePath(rea, p)
		    val d'   = instanceTypDef(rea, d)
		    val item = ref(TYP((p',l,n), k, w, d'))
		in
		    extendSig((TYP',l), item)
		end

	      | instanceItem'(MOD((p,l,n), j, d)) =
		let
		    val p'   = instancePath(rea, p)
		    val j'   = instanceInf(rea, j)
		    val d'   = instancePathDef(rea, d)
		    val item = ref(MOD((p',l,n), j', d'))
		in
		    extendSig((MOD',l), item)
		end

	      | instanceItem'(INF((p,l,n), k, d)) =
		let
		    val p'   = instancePath(rea, p)
		    val k'   = instanceKind(rea, k)
		    val d'   = instanceInfDef(rea, d)
		    val item = ref(INF((p',l,n), k', d'))
		in
		    extendSig((INF',l), item)
		end
	in
	    Misc.List_appr instanceItem items ;
	    s
	end

    and instancePathDef(rea, NONE  )	= NONE
      | instancePathDef(rea, SOME p)	= SOME(realisePath(rea, p))

    and instanceTypDef(rea, NONE  )	= NONE
      | instanceTypDef(rea, SOME t)	= SOME(instanceTyp(rea, t))

    and instanceInfDef(rea, NONE  )	= NONE
      | instanceInfDef(rea, SOME j)	= SOME(instanceInf(rea, j))

    and instanceTyp(rea, t)		= let val t' = Type.clone t in
					     Type.realisePath(rea, t') ; t'
					  end


  (* Creation of singleton (shallow instantiation) *)

    and singleton j			= singletonInf(PathMap.new(), j)

    and singletonInf (rea, ref j')	= ref(singletonInf'(rea, j'))
    and singletonInf'(rea, LINK j)	= singletonInf'(rea, !j)
      | singletonInf'(rea, TOP)		= TOP
      | singletonInf'(rea, CON c)	= CON(singletonCon(rea, c))
      | singletonInf'(rea, SIG s)	= SIG(singletonSig(rea, s))
      | singletonInf'(rea,ARR(p,j1,j2))	= ARR(singletonPath(rea, p),
					      singletonInf(rea, j1),
					      singletonInf(rea, j2))
      | singletonInf'(rea,LAM(p,j1,j2))	= LAM(singletonPath(rea, p),
					      singletonInf(rea, j1),
					      singletonInf(rea, j2))
      | singletonInf'(rea,APP(j1,p,j2))	= APP(singletonInf(rea, j1),
					      realisePath(rea, p),
					      singletonInf(rea, j2))

    and singletonCon(rea, (k,p))	= ( singletonKind(rea, k),
					    realisePath(rea, p) )

    and singletonKind (rea, ref k')	= ref(singletonKind'(rea, k'))
    and singletonKind'(rea, GROUND)	= GROUND
      | singletonKind'(rea, DEP(p,j,k))	= DEP(singletonPath(rea, p),
					      singletonInf(rea, j),
					      singletonKind(rea, k))

    and singletonPath(rea, p) = Path.instance PathMap.lookup (rea, p)

    and singletonSig(rea, (ref items,_)) =
	let
	    val s as (itemsr,map) = empty()

	    fun extendSig(space_l, item) =
		( itemsr := item :: !itemsr
		; Map.insertWith (fn(l1,l2) => l2 @ l1) (map, space_l, [item])
		)

	    fun singletonItem(ref item') = singletonItem' item'

	    and singletonItem'(VAL((p,l,n), t, w, d)) =
		let
		    val p'   = singletonPath(rea, p)
		    val t'   = singletonTyp(rea, t)
		    val d'   = singletonPathDef(rea, d)
		    val item = ref(VAL((p',l,n), t', w, d'))
		in
		    extendSig((VAL',l), item)
		end

	      | singletonItem'(TYP((p,l,n), k, w, d)) =
		let
		    val p'   = singletonPath(rea, p)
		    val d'   = singletonTypDef(rea, d)
		    val item = ref(TYP((p',l,n), k, w, d'))
		in
		    extendSig((TYP',l), item)
		end

	      | singletonItem'(MOD((p,l,n), j, d)) =
		let
		    val p'   = singletonPath(rea, p)
		    val j'   = singletonInf(rea, j)
		    val d'   = singletonPathDef(rea, d)
		    val item = ref(MOD((p',l,n), j', d'))
		in
		    extendSig((MOD',l), item)
		end

	      | singletonItem'(INF((p,l,n), k, d)) =
		let
		    val p'   = singletonPath(rea, p)
		    val k'   = singletonKind(rea, k)
		    val d'   = singletonInfDef(rea, d)
		    val item = ref(INF((p',l,n), k', d'))
		in
		    extendSig((INF',l), item)
		end
	in
	    Misc.List_appr singletonItem items ;
	    s
	end

    and singletonPathDef(rea, NONE  )	= NONE
      | singletonPathDef(rea, SOME p)	= SOME(realisePath(rea, p))

    and singletonTypDef(rea, NONE  )	= NONE
      | singletonTypDef(rea, SOME t)	= SOME(singletonTyp(rea, t))

    and singletonInfDef(rea, NONE  )	= NONE
      | singletonInfDef(rea, SOME j)	= SOME(singletonInf(rea, j))

    and singletonTyp(rea, t)		= let val t' = Type.clone t in
					     Type.realisePath(rea, t') ; t'
					  end


  (* Cloning (does not instantiate paths!) *)

    fun clone(ref j')		= ref(clone' j')
    and clone'(LINK j)		= clone'(!j)
      | clone'(TOP)		= TOP
      | clone'(CON c)		= CON(cloneCon c)
      | clone'(SIG s)		= SIG(cloneSig s)
      | clone'(ARR(p,j1,j2))	= ARR(p, clone j1, clone j2)
      | clone'(LAM(p,j1,j2))	= LAM(p, clone j1, clone j2)
      | clone'(APP(j1,p,j2))	= APP(clone j1, p, clone j2)

    and cloneCon (k,p)		= (cloneKind k, p)

    and cloneKind (ref k')	= ref(cloneKind' k')
    and cloneKind'(GROUND)	= GROUND
      | cloneKind'(DEP(p,j,k))	= DEP(p, clone j, cloneKind k)

    and cloneSig (ref items, _)	=
	let
	    val s as (itemsr,map) = empty()

	    fun extendSig(space_l, item) =
		( itemsr := item :: !itemsr
		; Map.insertWith (fn(l1,l2) => l2 @ l1) (map, space_l, [item])
		)

	    fun cloneItem(ref item') = cloneItem' item'
	    and cloneItem'(item' as VAL(x,t,w,d)) =
		    extendSig((VAL', idLab x), ref item')
	      | cloneItem'(item' as TYP(x,k,w,d)) =
		    extendSig((TYP', idLab x), ref item')
	      | cloneItem'(MOD(x,j,d)) =
		let val item' = MOD(x, clone j, d) in
		    extendSig((MOD', idLab x), ref item')
		end
	      | cloneItem'(INF(x,k,d)) =
		let val item' = INF(x, cloneKind k, Option.map clone d) in
		    extendSig((INF', idLab x), ref item')
		end
	in
	    Misc.List_appr cloneItem items ;
	    s
	end


  (* Creation and injections *)

    fun inTop()		= ref TOP
    fun inCon c		= ref(CON c)
    fun inSig s		= ref(SIG s)
    fun inArrow pjj	= ref(ARR pjj)
    fun inLambda pjj	= ref(LAM pjj)
    fun inApp jpj	= let val j = ref(APP jpj) in reduce j ; j end

    fun pathToPath  p	= p
    fun pathToTyp k p	= Type.inCon(k, Type.CLOSED, p)
    fun pathToInf k p	= inCon(k,p)


  (* Projections and extractions *)

    exception Interface

    fun asInf j		= !(follow j)

    fun isTop j		= case asInf j of TOP   => true | _ => false
    fun isCon j		= case asInf j of CON _ => true | _ => false
    fun isSig j		= case asInf j of SIG _ => true | _ => false
    fun isArrow j	= case asInf j of ARR _ => true | _ => false
    fun isLambda j	= case asInf j of LAM _ => true | _ => false
    fun isApp j		= case asInf j of APP _ => true | _ => false

    fun asCon j		= case asInf j of CON c   => c   | _ => raise Interface
    fun asSig j		= case asInf j of SIG s   => s   | _ => raise Interface
    fun asArrow j	= case asInf j of ARR xjj => xjj | _ => raise Interface
    fun asLambda j	= case asInf j of LAM xjj => xjj | _ => raise Interface
    fun asApp j		= case asInf j of APP jpj => jpj | _ => raise Interface

    fun pathCon(_,p)	= p
    fun path j		= pathCon(asCon j)


  (* Strengthening *)

    fun strengthen(p, ref(SIG s))  = strengthenSig(p, s)
      | strengthen(p, ref(LINK j)) = strengthen(p, j)
      | strengthen(p, _)           = ()

    and strengthenSig(p, (ref items, _)) =
	    List.app (fn item => strengthenItem(p, item)) items

    and strengthenItem(p, item as ref item') =
	    item := strengthenItem'(p, item')

    and strengthenItem'(p, VAL(x, t, w, d)) =
	let
	    val _  = strengthenId(p, x)
	    val d' = strengthenPathDef(idPath x, d)
	in
	    VAL(x, t, w, d')
	end

      | strengthenItem'(p, TYP(x, k, w, d)) =
	let
	    val _  = strengthenId(p, x)
	    val d' = strengthenTypDef(idPath x, k, d)
	in
	    TYP(x, k, w, d')
	end

      | strengthenItem'(p, MOD(x, j, d)) =
	let
	    val _  = strengthenId(p, x)
	    val _  = strengthen(idPath x, j)
	    val d' = strengthenPathDef(idPath x, d)
	in
	    MOD(x, j, d')
	end

      | strengthenItem'(p, INF(x, k, d)) =
	let
	    val _  = strengthenId(p, x)
	    val d' = strengthenInfDef(idPath x, k, d)
	in
	    INF(x, k, d')
	end

    and strengthenId(p, pln)		= Path.strengthen(p, pln)

    and strengthenPathDef(p, NONE)	= SOME p
      | strengthenPathDef(p, d)		= d

    and strengthenTypDef(p, k, NONE)	= SOME(pathToTyp k p)
      | strengthenTypDef(p, k, d)	= d

    and strengthenInfDef(p, k, NONE)	= SOME(pathToInf k p)
      | strengthenInfDef(p, k, d)	= d


  (* Kinds *)

    exception Kind

    fun inGround ()		= ref GROUND
    fun inDependent pjk		= ref(DEP pjk)

    fun isGround(ref GROUND)	= true
      | isGround _		= false

    fun isDependent k		= not(isGround k)
    fun asDependent(ref(DEP x))	= x
      | asDependent _		= raise Kind

    fun kind(ref j')		= kind' j'
    and kind'( TOP
	     | SIG _
	     | ARR _ )		= inGround()
      | kind'(CON(k,p))		= k
      | kind'(LAM(p,j1,j2))	= inDependent(p, j1, kind j2)
      | kind'(APP(j1,p,j2))	= (*UNFINISHED*) inGround()
      | kind'(LINK j)		= kind j


  (* Matching *)

    datatype mismatch =
	  MissingVal  of lab
	| MissingTyp  of lab
	| MissingMod  of lab
	| MissingInf  of lab
	| ManifestVal of lab
	| ManifestTyp of lab
	| ManifestMod of lab
	| ManifestInf of lab
	| MismatchVal of lab * typ * typ
	| MismatchTyp of lab * tkind * tkind
	| MismatchMod of lab * mismatch
	| MismatchInf of lab * mismatch
	| MismatchValSort of lab * val_sort * val_sort
	| MismatchTypSort of lab * typ_sort * typ_sort
	| MismatchDom     of mismatch
	| MismatchRan     of mismatch
	| Incompatible    of inf * inf
	| IncompatibleArg of path * path

    exception Mismatch of mismatch


    fun matchDef (equals, err) (l ,_,       NONE   ) = ()
      | matchDef (equals, err) (l, NONE,    SOME _ ) = raise Mismatch(err l)
      | matchDef (equals, err) (l, SOME x1, SOME x2) =
	    if equals(x1,x2) then () else raise Mismatch(err l)

    fun matchValDef x = matchDef(op=, ManifestVal) x
    fun matchTypDef x = matchDef(Type.equals, ManifestTyp) x
    fun matchModDef x = matchDef(op=, ManifestMod) x
    fun matchInfDef x = matchDef(equals, ManifestInf) x

    and matchSig(rea, (ref items1, m1), s2 as (ref items2, m2)) =
	let
	    val {val_rea, typ_rea, mod_rea, inf_rea} = rea

	    fun pair(m1,      [],      pairs) = List.rev pairs
	      | pair(m1, item2::items, pairs) =
		let
		    val (p,l,n) = itemId item2
		    val  space  = itemSpace item2
		    val  item1  = List.hd(Map.lookupExistent(m1, (space,l)))
		in
		    if p = itemPath item1 then () else
		    case space
		     of VAL' => PathMap.insert(val_rea, p, selectVal(!item1))
		      | TYP' => PathMap.insert(typ_rea, p, selectTyp(!item1))
		      | INF' => PathMap.insert(inf_rea, p, selectInf(!item1))
		      | MOD' => let val p1 = selectMod(!item1)
				    val j1 = selectMod'(!item1)
				    val j2 = selectMod'(!item2)
				in
				    PathMap.insert(mod_rea, p, p1) ;
				    matchNested(j1, j2)
				    handle Mismatch mismatch =>
					raise Mismatch(MismatchMod(l, mismatch))
				end ;
		    pair(m1, items, (item1,item2)::pairs)
		end
		handle Map.Lookup (VAL',l) => raise Mismatch(MissingVal l)
		     | Map.Lookup (TYP',l) => raise Mismatch(MissingTyp l)
		     | Map.Lookup (MOD',l) => raise Mismatch(MissingMod l)
		     | Map.Lookup (INF',l) => raise Mismatch(MissingInf l)

	    (* Necessary to create complete realisation. *)
	    and matchNested(ref(SIG(_,m1)), ref(SIG(ref items2,_))) =
		    ignore(pair(m1, items2, []))
	      | matchNested(ref(ARR _), ref(ARR _)) =
		(*UNFINISHED: when introducing functor paths*) ()
	      | matchNested(ref(LINK j1), j2) = matchNested(j1, j2)
	      | matchNested(j1, ref(LINK j2)) = matchNested(j1, j2)
	      | matchNested _ = ()

	    val pairs = pair(m1, items2, [])
	in
	    realiseSig(rea, s2) ;
	    List.app matchItem pairs
	end

    and matchItem(ref item1', item2 as ref item2') =
	( matchItem'(item1', item2') ; item2 := item1' )

    and matchItem'(VAL(x1,t1,w1,d1), VAL(x2,t2,w2,d2)) =
	let val l = idLab x2 in
	    matchTyp(l, t1, t2) ;
	    matchValSort(l, w1, w2) ;
	    matchValDef(l, d1, d2)
	end
      | matchItem'(TYP(x1,k1,w1,d1), TYP(x2,k2,w2,d2)) =
	let val l = idLab x2 in
	    matchTKind(l, k1, k2) ;
	    matchTypSort(l, w1, w2) ;
	    matchTypDef(l, d1, d2)
	end
      | matchItem'(MOD(x1,j1,d1), MOD(x2,j2,d2)) =
	let val l = idLab x2 in
	    matchInf(l, j1, j2) ;
	    matchModDef(l, d1, d2)
	end
      | matchItem'(INF(x1,k1,d1), INF(x2,k2,d2)) =
	let val l = idLab x2 in
	    matchKind(l, k1, k2) ;
	    matchInfDef(l, d1, d2)
	end
      | matchItem' _ = raise Crash.Crash "Inf.matchItem"

    and matchTyp(l,t1,t2) =
	if Type.matches(t1,t2) then () else
	    raise Mismatch(MismatchVal(l,t1,t2))

    and matchTKind(l,k1,k2) =
	if k1 = k2 then () else
	    raise Mismatch(MismatchTyp(l,k1,k2))

    and matchInf(l,j1,j2) =
	match'(emptyRea(), j1, j2)
	handle Mismatch mismatch =>
	    raise Mismatch(MismatchMod(l, mismatch))

    and matchKind(l,k1,k2) =
	(*UNFINISHED: match contravariant*)
	equaliseKind(k1,k2)
	handle Mismatch mismatch =>
	    raise Mismatch(MismatchInf(l, mismatch))

    and matchValSort(l,w1,w2) =
	if w1 = CONSTRUCTOR orelse w2 = VALUE then () else
	    raise Mismatch(MismatchValSort(l, w1, w2))

    and matchTypSort(l,w1,w2) =
	if w1 = OPEN orelse w2 = CLOSED then () else
	    raise Mismatch(MismatchTypSort(l, w1, w2))


    and match'(rea, _, ref TOP) = ()
      | match'(rea, j1 as ref(CON(_,p1)), j2 as ref(CON(_,p2))) =
	if p1 = p2 then
	    ()
	else
	    raise Mismatch(Incompatible(j1,j2))

      | match'(rea, ref(SIG s1), ref(SIG s2)) = matchSig(rea, s1, s2)

      | match'(rea, ref(ARR(p1,j11,j12)), ref(ARR(p2,j21,j22))) =
	( realise(rea, j21)
	; match'(rea, j21, j11) handle Mismatch mismatch =>
		raise Mismatch(MismatchDom mismatch)
	; realise(rea, j12)
	; match'(rea, j12, j22) handle Mismatch mismatch =>
		raise Mismatch(MismatchRan mismatch)
	)

      | match'(rea, ref(LAM(p1,j11,j12)), ref(LAM(p2,j21,j22))) =
	(*UNFINISHED*)
	    ()

      | match'(rea, ref(APP(j11,p1,j12)), ref(APP(j21,p2,j22))) =
	( match'(rea, j11, j21)
	; if p1 = p2 then () else
	      raise Mismatch(IncompatibleArg(p1,p2))
	)

      | match'(rea, ref(LINK j1), j2)	= match'(rea, j1, j2)
      | match'(rea, j1, ref(LINK j2))	= match'(rea, j1, j2)
      | match'(rea, j1,j2)		= raise Mismatch(Incompatible(j1,j2))


    and equals(j1,j2) = (*UNFINISHED*) true

    and equaliseKind(k1,k2) = (*UNFINISHED*) ()


    fun match(j1,j2) =
	let
	    val rea = emptyRea()
	in
	    match'(rea, j1, j2) ;
	    rea
	end



  (* Intersection *)

    (* UNFINISHED: does ignore dependencies on second argument signature *)

    fun intersectDef (equals, err) (l, NONE,    NONE   ) = NONE
      | intersectDef (equals, err) (l, NONE,    SOME z ) = SOME z
      | intersectDef (equals, err) (l, SOME z,  NONE   ) = SOME z
      | intersectDef (equals, err) (l, SOME z1, SOME z2) =
	    if equals(z1,z2) then SOME z1 else raise Mismatch(err l)

    fun intersectValDef x = intersectDef(op=, ManifestVal) x
    fun intersectTypDef x = intersectDef(Type.equals, ManifestTyp) x
    fun intersectModDef x = intersectDef(op=, ManifestMod) x
    fun intersectInfDef x = intersectDef(equals, ManifestInf) x

    fun intersectSig(rea, s1 as (itemsr1 as ref items1, m1),
			  s2 as (itemsr2 as ref items2, m2)) =
	let
	    fun pairDef(rea', toZ, b, x1, NONE, x2, SOME z) =
		    ( if b then PathMap.insert(rea', idPath x1, z) else ()
		    ; false )
	      | pairDef(rea', toZ, b, x1, SOME z, x2, NONE) =
		    ( if b then PathMap.insert(rea', idPath x2, z) else ()
		    ; true )
	      | pairDef(rea', toZ, b, x1, SOME z1, x2, SOME z2) =
		    ( if b then PathMap.insert(rea', idPath x2, z1) else ()
		    ; true )
	      | pairDef(rea', toZ, b, x1, NONE, x2, NONE) =
		    ( if b then PathMap.insert(rea', idPath x2, toZ(idPath x1))
			   else ()
		    ; true )

	    fun pair1(b, VAL(x1,t1,w1,d1), VAL(x2,t2,w2,d2)) =
		    pairDef(#val_rea rea, pathToPath, b, x1, d1, x2, d2)
	      | pair1(b, TYP(x1,k1,w1,d1), TYP(x2,k2,w2,d2)) =
		    pairDef(#typ_rea rea, pathToTyp k1, b, x1, d1, x2, d2)
	      | pair1(b, MOD(x1,j1,d1), MOD(x2,j2,d2)) =
		    pairDef(#mod_rea rea, pathToPath, b, x1, d1, x2, d2)
		    before pairNested(j1,j2)
	      | pair1(b, INF(x1,k1,d1), INF(x2,k2,d2)) =
		    pairDef(#inf_rea rea, pathToInf k1, b, x1, d1, x2, d2)
	      | pair1 _ =
		    raise Crash.Crash "Inf.intersectSig: pairing"

	    and pair(m1, [], pairs, left) = ( List.rev pairs, List.rev left )
	      | pair(m1, item2::items, pairs, left) =
		case Map.lookup(m1, (itemSpace item2, itemLab item2))
		  of NONE => pair(m1, items, pairs, item2::left)
		   | SOME [] => raise Crash.Crash "Inf.intersectSig: lookup"
		   | SOME(item1::_) =>
		     (* Nested structures are already realised.
		      * We would loop during realisation if we inserted
		      * identity realisations. *)
		     ( if pair1(itemPath item1 <> itemPath item2,
				!item1, !item2) then () else
			  Misc.General_swap(item1, item2)
		     ; pair(m1, items, (item1,item2)::pairs, left)
		     )

	    (* Necessary to create complete realisation. *)
	    and pairNested(ref(SIG(_,m1)), ref(SIG(ref items2,_))) =
		    ignore(pair(m1, items2, [], []))
	      | pairNested(ref(ARR _), ref(ARR _)) =
		(*UNFINISHED: when introducing functor paths*) ()
	      | pairNested(ref(LINK j1), j2) = pairNested(j1, j2)
	      | pairNested(j1, ref(LINK j2)) = pairNested(j1, j2)
	      | pairNested _ = ()

	    val (pairs,left) = pair(m1, items2, [], [])
	in
	    realiseSig(rea, s1) ;
	    realiseSig(rea, s2) ;
	    List.app (intersectItem rea) pairs ;
	    itemsr1 := items1 @ left ;
	    itemsr2 := !itemsr1
	end
    and intersectItem rea (item1 as ref item1', ref item2') =
	    item1 := intersectItem'(rea, item1', item2')

    and intersectItem'(rea, VAL(x1,t1,w1,d1), VAL(x2,t2,w2,d2)) =
	let
	    val l = idLab x1
	    val t = intersectTyp(l, t1, t2)
	    val w = intersectValSort(l, w1, w2)
	    val d = intersectValDef(l, d1, d2)
	in
	    VAL(x1,t,w,d)
	end
      | intersectItem'(rea, TYP(x1,k1,w1,d1), TYP(x2,k2,w2,d2)) =
	let
	    val l = idLab x1
	    val k = intersectTKind(l, k1, k2)
	    val w = intersectTypSort(l, w1, w2)
	    val d = intersectTypDef(l, d1, d2)
	in
	    TYP(x1,k,w,d)
	end
      | intersectItem'(rea, MOD(x1,j1,d1), MOD(x2,j2,d2)) =
	let
	    val l = idLab x1
	    val j = intersectInf(l, j1, j2)
	    val d = intersectModDef(l, d1, d2)
	in
	    MOD(x1,j,d)
	end
      | intersectItem'(rea, INF(x1,k1,d1), INF(x2,k2,d2)) =
	let
	    val l = idLab x1
	    val k = intersectKind(l, k1, k2)
	    val d = intersectInfDef(l, d1, d2)
	in
	    INF(x1,k,d)
	end
      | intersectItem' _ = raise Crash.Crash "Inf.intersectItem"

    and intersectTyp(l,t1,t2) =
	( Type.intersect(t1,t2) ; t1 )
	handle Type.Intersect =>
	    raise Mismatch(MismatchVal(l,t1,t2))

    and intersectTKind(l,k1,k2) =
	if k1 = k2 then k1 else
	    raise Mismatch(MismatchTyp(l,k1,k2))

    and intersectInf(l,j1,j2) =
	intersect'(emptyRea(), j1, j2)
	handle Mismatch mismatch =>
	    raise Mismatch(MismatchMod(l, mismatch))

    and intersectKind(l,k1,k2) =
	( equaliseKind(k1,k2) ; k1 )
	handle Mismatch mismatch =>
	    raise Mismatch(MismatchInf(l, mismatch))

    and intersectValSort(l,w1,w2) =
	if w1 = CONSTRUCTOR orelse w2 = CONSTRUCTOR then
	    CONSTRUCTOR
	else
	    VALUE

    and intersectTypSort(l,w1,w2) =
	if w1 = OPEN orelse w2 = OPEN then
	    OPEN
	else
	    CLOSED


    and intersect'(rea, j1, ref TOP) = j1
      | intersect'(rea, ref TOP, j2) = j2
      | intersect'(rea, j1 as ref(CON(_,p1)), j2 as ref(CON(_,p2))) =
	if p1 = p2 then
	    j1
	else
	    raise Mismatch(Incompatible(j1,j2))

      | intersect'(rea, j1 as ref(SIG s1), ref(SIG s2)) =
	    ( intersectSig(rea, s1, s2) ; j1 )

      | intersect'(rea, ref(ARR(p1,j11,j12)), ref(ARR(p2,j21,j22))) =
	(*UNFINISHED*)
	    raise Crash.Crash "Inf.intersect: ARR"

      | intersect'(rea, ref(LAM(p1,j11,j12)), ref(LAM(p2,j21,j22))) =
	(*UNFINISHED*)
	    raise Crash.Crash "Inf.intersect: LAM"

      | intersect'(rea, j1 as ref(APP(j11,p1,j12)), ref(APP(j21,p2,j22))) =
	(*UNFINISHED*)
	    raise Crash.Crash "Inf.intersect: APP"

      | intersect'(rea, ref(LINK j1), j2) = intersect'(rea, j1, j2)
      | intersect'(rea, j1, ref(LINK j2)) = intersect'(rea, j1, j2)
      | intersect'(rea, j1,j2)            = raise Mismatch(Incompatible(j1,j2))


    fun intersect(j1,j2) =
	let
	    val j1' = clone j1
	    val j2' = clone j2
	    val rea = emptyRea()
	in
	    intersect'(rea, j1', j2')
	end

  end


structure Inf : INF = InfPrivate
(* src # 55 *)
signature ABSTRACT_GRAMMAR =
  sig

    (* Generic *)

    type info

    (* Literals *)

    datatype lit =
	  WordLit   of LargeWord.word		(* word *)
	| IntLit    of LargeInt.int		(* integer *)
	| CharLit   of WideChar.char		(* character *)
	| StringLit of WideString.string	(* string *)
	| RealLit   of LargeReal.real		(* floating point *)

    (* Identifiers *)

    type     stamp  = Stamp.t
    datatype name   = datatype Name.name
    datatype lab    = Lab     of info * string
    datatype id     = Id      of info * stamp * name
    datatype longid = ShortId of info * id
		    | LongId  of info * longid * lab

    (* Expressions *)

    datatype exp =
	  LitExp    of info * lit		(* literal *)
	| PrimExp   of info * string * typ	(* builtin values *)
	| VarExp    of info * longid		(* variable *)
	| ConExp    of info * int * longid	(* constructor *)
	| RefExp    of info			(* reference constructor *)
	| TupExp    of info * exp list		(* tuple *)
	| RowExp    of info * exp row		(* row (record) *)
	| SelExp    of info * lab		(* row selector *)
	| VecExp    of info * exp list		(* vector *)
	| FunExp    of info * id  * exp		(* function *)
	| AppExp    of info * exp * exp		(* application *)
	| CompExp   of info * exp * exp		(* adjunction *)
	| AndExp    of info * exp * exp		(* short-circuit conjunction *)
	| OrExp     of info * exp * exp		(* short-circuit disjunction *)
	| IfExp     of info * exp * exp * exp	(* conditional *)
	| WhileExp  of info * exp * exp		(* while loop *)
	| SeqExp    of info * exp list		(* sequential expressions *)
	| CaseExp   of info * exp * match list	(* case *)
	| RaiseExp  of info * exp		(* exception raising *)
	| HandleExp of info * exp * match list	(* exception handling *)
	| AnnExp    of info * exp * typ		(* type annotation *)
	| LetExp    of info * dec list * exp	(* let *)
	| PackExp   of info * mod		(* package introduction *)

    and 'a row   = Row   of info * 'a field list * bool
    and 'a field = Field of info * lab * 'a

    and match    = Match of info * pat * exp

    (* Patterns *)

    and pat =
	  JokPat    of info			(* joker (wildcard) *)
	| LitPat    of info * lit		(* literal *)
	| VarPat    of info * id		(* variable *)
	| ConPat    of info * longid * pat list	(* constructor (fully applied)*)
	| RefPat    of info * pat		(* reference *)
	| TupPat    of info * pat list		(* tuple *)
	| RowPat    of info * pat row		(* row (record) *)
	| VecPat    of info * pat list		(* vector *)
	| AsPat     of info * pat * pat		(* as (layered) pattern *)
	| AltPat    of info * pat list		(* alternative pattern *)
	| NegPat    of info * pat		(* negated pattern *)
	| GuardPat  of info * pat * exp		(* guarded pattern *)
	| AnnPat    of info * pat * typ		(* type annotation *)
	| WithPat   of info * pat * dec list	(* local declarations *)

    (* Types *)

    and typ =
	  AbsTyp    of info			(* abstract type *)
	| VarTyp    of info * id		(* variable *)
	| ConTyp    of info * longid		(* constructor *)
	| FunTyp    of info * id * typ		(* type function *)
	| AppTyp    of info * typ * typ		(* constructor application *)
	| RefTyp    of info * typ		(* reference type *)
	| TupTyp    of info * typ list		(* tuple (cartesian) type *)
	| RowTyp    of info * typ row		(* row (record) type *)
	| ArrTyp    of info * typ * typ		(* arrow (function) type *)
	| SumTyp    of info * con list		(* sum type (datatype) *)
	| ExtTyp    of info			(* extensible sum type *)
	| AllTyp    of info * id * typ		(* universal quantification *)
	| ExTyp     of info * id * typ		(* existential quantification *)
	| PackTyp   of info * inf		(* package type *)
	| SingTyp   of info * longid		(* singleton type *)

    and con =   Con of info * id * typ list	(* data constructor *)

    (* Modules *)

    and mod =
	  PrimMod   of info * string * inf	(* builtin modules *)
	| VarMod    of info * id		(* module id *)
	| StrMod    of info * dec list		(* structure *)
	| SelMod    of info * mod * lab		(* selection *)
	| FunMod    of info * id * inf * mod	(* functor *)
	| AppMod    of info * mod * mod		(* application *)
	| AnnMod    of info * mod * inf		(* annotation *)
	| UpMod     of info * mod * inf		(* coercion *)
	| LetMod    of info * dec list * mod	(* let *)
	| UnpackMod of info * exp * inf		(* package elimination *)

    (* Interfaces *)

    and inf =
	  TopInf    of info			(* top interface *)
	| AbsInf    of info			(* abstract interface *)
	| ConInf    of info * longid		(* interface constructor *)
	| SigInf    of info * spec list		(* signature *)
	| FunInf    of info * id * inf * inf	(* interface function *)
	| AppInf    of info * inf * mod		(* interface application *)
	| CompInf   of info * inf * inf		(* composition *)
	| ArrInf    of info * id * inf * inf	(* arrow (functor) interface *)
	| SingInf   of info * mod		(* singleton interface *)

    (* Declarations *)

    and dec =
	  ValDec    of info * pat * exp		(* values *)
	| ConDec    of info * con * typ		(* constructor *)
	| TypDec    of info * id * typ		(* type *)
	| DatDec    of info * id * typ		(* data type *)
	| ModDec    of info * id * mod		(* module *)
	| InfDec    of info * id * inf		(* interface *)
	| VarDec    of info * id * dec		(* scoped type variable *)
	| RecDec    of info * dec list		(* recursive declarations *)
	| LocalDec  of info * dec list		(* local declarations *)

    (* Specifications *)

    and spec =
	  ValSpec   of info * id * typ		(* value *)
	| ConSpec   of info * con * typ		(* constructor *)
	| TypSpec   of info * id * typ		(* type *)
	| DatSpec   of info * id * typ		(* data type *)
	| ModSpec   of info * id * inf		(* module *)
	| InfSpec   of info * id * inf		(* interface *)
	| VarSpec   of info * id * spec		(* scoped type variable *)
	| RecSpec   of info * spec list		(* recursive specifications *)
	| LocalSpec of info * spec list		(* local specifications *)
	| ExtSpec   of info * inf		(* extension (include) *)

    (* Components *)

    and comp = Comp of info * imp list * dec list

    and imp  = Imp of info * spec list * string

    type component = comp


    (* Operations *)

    val stamp :		id	-> stamp
    val name :		id	-> name
    val lab :		lab	-> string
    val idToLab :	id	-> lab
    val conToId :	con	-> id

    val infoLab :	lab	-> info
    val infoId :	id	-> info
    val infoLongid :	longid	-> info
    val infoExp :	exp	-> info
    val infoRow :	'a row	-> info
    val infoField :	'a field -> info
    val infoMatch :	match	-> info
    val infoPat :	pat	-> info
    val infoTyp :	typ	-> info
    val infoCon :	con	-> info
    val infoMod :	mod	-> info
    val infoInf :	inf	-> info
    val infoDec :	dec	-> info
    val infoSpec :	spec	-> info
    val infoComp :	comp	-> info
    val infoImp :	imp	-> info

  end
(* src # 56 *)
functor MakeAbstractGrammar(type info) :>
  ABSTRACT_GRAMMAR where type info = info =
  struct

    (* Generic *)

    type info = info

    (* Literals *)

    datatype lit =
	  WordLit   of LargeWord.word		(* word *)
	| IntLit    of LargeInt.int		(* integer *)
	| CharLit   of WideChar.char		(* character *)
	| StringLit of WideString.string	(* string *)
	| RealLit   of LargeReal.real		(* floating point *)

    (* Identifiers *)

    type     stamp  = Stamp.t
    datatype name   = datatype Name.name
    datatype lab    = Lab     of info * string
    datatype id     = Id      of info * stamp * name
    datatype longid = ShortId of info * id
		    | LongId  of info * longid * lab

    (* Expressions *)

    datatype exp =
	  LitExp    of info * lit		(* literal *)
	| PrimExp   of info * string * typ	(* builtin values *)
	| VarExp    of info * longid		(* variable *)
	| ConExp    of info * int * longid	(* constructor *)
	| RefExp    of info			(* reference constructor *)
	| TupExp    of info * exp list		(* tuple *)
	| RowExp    of info * exp row		(* row (record) *)
	| SelExp    of info * lab		(* row selector *)
	| VecExp    of info * exp list		(* vector *)
	| FunExp    of info * id  * exp		(* function *)
	| AppExp    of info * exp * exp		(* application *)
	| CompExp   of info * exp * exp		(* adjunction *)
	| AndExp    of info * exp * exp		(* short-circuit conjunction *)
	| OrExp     of info * exp * exp		(* short-circuit disjunction *)
	| IfExp     of info * exp * exp * exp	(* conditional *)
	| WhileExp  of info * exp * exp		(* while loop *)
	| SeqExp    of info * exp list		(* sequential expressions *)
	| CaseExp   of info * exp * match list	(* case *)
	| RaiseExp  of info * exp		(* exception raising *)
	| HandleExp of info * exp * match list	(* exception handling *)
	| AnnExp    of info * exp * typ		(* type annotation *)
	| LetExp    of info * dec list * exp	(* let *)
	| PackExp   of info * mod		(* package introduction *)

    and 'a row   = Row   of info * 'a field list * bool
    and 'a field = Field of info * lab * 'a

    and match    = Match of info * pat * exp

    (* Patterns *)

    and pat =
	  JokPat    of info			(* joker (wildcard) *)
	| LitPat    of info * lit		(* literal *)
	| VarPat    of info * id		(* variable *)
	| ConPat    of info * longid * pat list	(* constructor (fully applied)*)
	| RefPat    of info * pat		(* reference *)
	| TupPat    of info * pat list		(* tuple *)
	| RowPat    of info * pat row		(* row (record) *)
	| VecPat    of info * pat list		(* vector *)
	| AsPat     of info * pat * pat		(* as (layered) pattern *)
	| AltPat    of info * pat list		(* alternative pattern *)
	| NegPat    of info * pat		(* negated pattern *)
	| GuardPat  of info * pat * exp		(* guarded pattern *)
	| AnnPat    of info * pat * typ		(* type annotation *)
	| WithPat   of info * pat * dec list	(* local declarations *)

    (* Types *)

    and typ =
	  AbsTyp    of info			(* abstract type *)
	| VarTyp    of info * id		(* variable *)
	| ConTyp    of info * longid		(* constructor *)
	| FunTyp    of info * id * typ		(* type function *)
	| AppTyp    of info * typ * typ		(* constructor application *)
	| RefTyp    of info * typ		(* reference type *)
	| TupTyp    of info * typ list		(* tuple (cartesian) type *)
	| RowTyp    of info * typ row		(* row (record) type *)
	| ArrTyp    of info * typ * typ		(* arrow (function) type *)
	| SumTyp    of info * con list		(* sum type (datatype) *)
	| ExtTyp    of info			(* extensible sum type *)
	| AllTyp    of info * id * typ		(* universal quantification *)
	| ExTyp     of info * id * typ		(* existential quantification *)
	| PackTyp   of info * inf		(* package type *)
	| SingTyp   of info * longid		(* singleton type *)

    and con =   Con of info * id * typ list	(* data constructor *)

    (* Modules *)

    and mod =
	  PrimMod   of info * string * inf	(* builtin modules *)
	| VarMod    of info * id		(* module id *)
	| StrMod    of info * dec list		(* structure *)
	| SelMod    of info * mod * lab		(* selection *)
	| FunMod    of info * id * inf * mod	(* functor *)
	| AppMod    of info * mod * mod		(* application *)
	| AnnMod    of info * mod * inf		(* annotation *)
	| UpMod     of info * mod * inf		(* coercion *)
	| LetMod    of info * dec list * mod	(* let *)
	| UnpackMod of info * exp * inf		(* package elimination *)

    (* Interfaces *)

    and inf =
	  TopInf    of info			(* top interface *)
	| AbsInf    of info			(* abstract interface *)
	| ConInf    of info * longid		(* interface constructor *)
	| SigInf    of info * spec list		(* signature *)
	| FunInf    of info * id * inf * inf	(* interface function *)
	| AppInf    of info * inf * mod		(* interface application *)
	| CompInf   of info * inf * inf		(* composition *)
	| ArrInf    of info * id * inf * inf	(* arrow (functor) interface *)
	| SingInf   of info * mod		(* singleton interface *)

    (* Declarations *)

    and dec =
	  ValDec    of info * pat * exp		(* values *)
	| ConDec    of info * con * typ		(* constructor *)
	| TypDec    of info * id * typ		(* type *)
	| DatDec    of info * id * typ		(* data type *)
	| ModDec    of info * id * mod		(* module *)
	| InfDec    of info * id * inf		(* interface *)
	| VarDec    of info * id * dec		(* scoped type variable *)
	| RecDec    of info * dec list		(* recursive declarations *)
	| LocalDec  of info * dec list		(* local declarations *)

    (* Specifications *)

    and spec =
	  ValSpec   of info * id * typ		(* value *)
	| ConSpec   of info * con * typ		(* constructor *)
	| TypSpec   of info * id * typ		(* type *)
	| DatSpec   of info * id * typ		(* data type *)
	| ModSpec   of info * id * inf		(* module *)
	| InfSpec   of info * id * inf		(* interface *)
	| VarSpec   of info * id * spec		(* scoped type variable *)
	| RecSpec   of info * spec list		(* recursive specifications *)
	| LocalSpec of info * spec list		(* local specifications *)
	| ExtSpec   of info * inf		(* extension (include) *)

    (* Components *)

    and comp = Comp of info * imp list * dec list

    and imp  = Imp of info * spec list * string

    type component = comp


    (* Projections *)

    fun stamp(Id(_,x,_))		= x
    fun name(Id(_,_,n))			= n
    fun lab(Lab(_,a))			= a

    fun conToId(Con(_,x,_))		= x

    fun idToLab(Id(i,_,ExId s))		= Lab(i,s)
      | idToLab(Id(i,_,InId))		= Lab(i,"")

    fun infoLab(Lab(i,_))		= i
    fun infoId(Id(i,_,_))		= i
    fun infoLongid(ShortId(i,_))	= i
      | infoLongid(LongId(i,_,_))	= i

    fun infoExp(LitExp(i,_))		= i
      | infoExp(PrimExp(i,_,_))		= i
      | infoExp(VarExp(i,_))		= i
      | infoExp(ConExp(i,_,_))		= i
      | infoExp(RefExp(i))		= i
      | infoExp(TupExp(i,_))		= i
      | infoExp(RowExp(i,_))		= i
      | infoExp(SelExp(i,_))		= i
      | infoExp(VecExp(i,_))		= i
      | infoExp(FunExp(i,_,_))		= i
      | infoExp(AppExp(i,_,_))		= i
      | infoExp(CompExp(i,_,_))		= i
      | infoExp(AndExp(i,_,_))		= i
      | infoExp(OrExp(i,_,_))		= i
      | infoExp(IfExp(i,_,_,_))		= i
      | infoExp(WhileExp(i,_,_))	= i
      | infoExp(SeqExp(i,_))		= i
      | infoExp(CaseExp(i,_,_))		= i
      | infoExp(RaiseExp(i,_))		= i
      | infoExp(HandleExp(i,_,_))	= i
      | infoExp(AnnExp(i,_,_))		= i
      | infoExp(LetExp(i,_,_))		= i
      | infoExp(PackExp(i,_))		= i

    fun infoRow(Row(i,_,_))		= i
    fun infoField(Field(i,_,_))		= i
    fun infoMatch(Match(i,_,_))		= i

    fun infoPat(JokPat(i))		= i
      | infoPat(LitPat(i,_))		= i
      | infoPat(VarPat(i,_))		= i
      | infoPat(ConPat(i,_,_))		= i
      | infoPat(RefPat(i,_))		= i
      | infoPat(TupPat(i,_))		= i
      | infoPat(RowPat(i,_))		= i
      | infoPat(VecPat(i,_))		= i
      | infoPat(AsPat(i,_,_))		= i
      | infoPat(AltPat(i,_))		= i
      | infoPat(NegPat(i,_))		= i
      | infoPat(GuardPat(i,_,_))	= i
      | infoPat(AnnPat(i,_,_))		= i
      | infoPat(WithPat(i,_,_))		= i

    fun infoTyp(AbsTyp(i))		= i
      | infoTyp(VarTyp(i,_))		= i
      | infoTyp(ConTyp(i,_))		= i
      | infoTyp(FunTyp(i,_,_))		= i
      | infoTyp(AppTyp(i,_,_))		= i
      | infoTyp(RefTyp(i,_))		= i
      | infoTyp(TupTyp(i,_))		= i
      | infoTyp(RowTyp(i,_))		= i
      | infoTyp(ArrTyp(i,_,_))		= i
      | infoTyp(SumTyp(i,_))		= i
      | infoTyp(ExtTyp(i))		= i
      | infoTyp(AllTyp(i,_,_))		= i
      | infoTyp(ExTyp(i,_,_))		= i
      | infoTyp(PackTyp(i,_))		= i
      | infoTyp(SingTyp(i,_))		= i

    fun infoCon(Con(i,_,_))		= i

    fun infoMod(PrimMod(i,_,_))		= i
      | infoMod(VarMod(i,_))		= i
      | infoMod(StrMod(i,_))		= i
      | infoMod(SelMod(i,_,_))		= i
      | infoMod(FunMod(i,_,_,_))	= i
      | infoMod(AppMod(i,_,_))		= i
      | infoMod(AnnMod(i,_,_))		= i
      | infoMod(UpMod(i,_,_))		= i
      | infoMod(LetMod(i,_,_))		= i
      | infoMod(UnpackMod(i,_,_))	= i

    fun infoInf(TopInf(i))		= i
      | infoInf(AbsInf(i))		= i
      | infoInf(ConInf(i,_))		= i
      | infoInf(SigInf(i,_))		= i
      | infoInf(FunInf(i,_,_,_))	= i
      | infoInf(AppInf(i,_,_))		= i
      | infoInf(CompInf(i,_,_))		= i
      | infoInf(ArrInf(i,_,_,_))	= i
      | infoInf(SingInf(i,_))		= i

    fun infoDec(ValDec(i,_,_))		= i
      | infoDec(ConDec(i,_,_))		= i
      | infoDec(TypDec(i,_,_))		= i
      | infoDec(DatDec(i,_,_))		= i
      | infoDec(ModDec(i,_,_))		= i
      | infoDec(InfDec(i,_,_))		= i
      | infoDec(VarDec(i,_,_))		= i
      | infoDec(RecDec(i,_))		= i
      | infoDec(LocalDec(i,_))		= i

    fun infoSpec(ValSpec(i,_,_))	= i
      | infoSpec(ConSpec(i,_,_))	= i
      | infoSpec(TypSpec(i,_,_))	= i
      | infoSpec(DatSpec(i,_,_))	= i
      | infoSpec(ModSpec(i,_,_))	= i
      | infoSpec(InfSpec(i,_,_))	= i
      | infoSpec(VarSpec(i,_,_))	= i
      | infoSpec(RecSpec(i,_))		= i
      | infoSpec(LocalSpec(i,_))	= i
      | infoSpec(ExtSpec(i,_))		= i

    fun infoComp(Comp(i,_,_))		= i
    fun infoImp(Imp(i,_,_))		= i

  end
(* src # 57 *)
structure AbstractGrammar = MakeAbstractGrammar(type info = Source.region)
(* src # 58 *)
structure TypedInfo =
  struct
    datatype annotation = NON | TYP of Type.t | INF of Inf.t
    type     info       = Source.region * annotation
  end

structure TypedGrammar = MakeAbstractGrammar(TypedInfo)
(* src # 59 *)
signature ENV =
  sig

    type stamp = AbstractGrammar.stamp
    type id    = AbstractGrammar.id
    type path  = Path.t
    type typ   = Type.t
    type var   = Type.var
    type inf   = Inf.t

    type env
    type t = env

    type val_entry = { id: id, path: path, typ: typ, sort: Inf.val_sort }
    type typ_entry = { id: id, path: path, typ: typ, sort: Inf.typ_sort }
    type var_entry = { id: id, var: var }
    type mod_entry = { id: id, path: path, inf: inf }
    type inf_entry = { id: id, path: path, inf: inf }

    exception Collision of stamp
    exception Lookup    of stamp

    val new :		unit -> env
    val copy :		env -> env
    val copyScope :	env -> env
    val splitScope :	env -> env
    val insertScope :	env -> unit
    val deleteScope :	env -> unit
    val mergeScope :	env -> unit

    val union :		env * env -> unit		(* Collision *)

    val insertVal :	env * stamp * val_entry -> unit	(* Collision *)
    val insertTyp :	env * stamp * typ_entry -> unit	(* Collision *)
    val insertVar :	env * stamp * var_entry -> unit	(* Collision *)
    val insertMod :	env * stamp * mod_entry -> unit	(* Collision *)
    val insertInf :	env * stamp * inf_entry -> unit	(* Collision *)

    val lookupVal :	env * stamp -> val_entry	(* Lookup *)
    val lookupTyp :	env * stamp -> typ_entry	(* Lookup *)
    val lookupVar :	env * stamp -> var_entry	(* Lookup *)
    val lookupMod :	env * stamp -> mod_entry	(* Lookup *)
    val lookupInf :	env * stamp -> inf_entry	(* Lookup *)

    val appVals :	(stamp * val_entry -> unit) -> env -> unit
    val appTyps :	(stamp * typ_entry -> unit) -> env -> unit
    val appVars :	(stamp * var_entry -> unit) -> env -> unit
    val appMods :	(stamp * mod_entry -> unit) -> env -> unit
    val appInfs :	(stamp * inf_entry -> unit) -> env -> unit

    val foldVals :	(stamp * val_entry * 'a -> 'a) -> 'a -> env -> 'a
    val foldTyps :	(stamp * typ_entry * 'a -> 'a) -> 'a -> env -> 'a
    val foldVars :	(stamp * var_entry * 'a -> 'a) -> 'a -> env -> 'a
    val foldMods :	(stamp * mod_entry * 'a -> 'a) -> 'a -> env -> 'a
    val foldInfs :	(stamp * inf_entry * 'a -> 'a) -> 'a -> env -> 'a

  end
(* src # 60 *)
structure Env :> ENV =
  struct

    type stamp = AbstractGrammar.stamp
    type id    = AbstractGrammar.id
    type path  = Path.t
    type typ   = Type.t
    type var   = Type.var
    type inf   = Inf.t


    (* The map implementing the environment *)

    structure Map = MakeHashScopedImpMap(Stamp)

    datatype env = ENV of ran Map.t
    and      ran = VAL of val_entry
		 | TYP of typ_entry
		 | VAR of var_entry
		 | MOD of mod_entry
		 | INF of inf_entry

    withtype val_entry = { id: id, path: path, typ: typ, sort: Inf.val_sort }
    and      typ_entry = { id: id, path: path, typ: typ, sort: Inf.typ_sort }
    and      var_entry = { id: id, var: var }
    and      mod_entry = { id: id, path: path, inf: inf }
    and      inf_entry = { id: id, path: path, inf: inf }

    type t = env


    (* Conversions *)

    fun asVal(VAL x) = x | asVal _ = raise Crash.Crash "Env.asVal: inconsistent"
    fun asTyp(TYP x) = x | asTyp _ = raise Crash.Crash "Env.asTyp: inconsistent"
    fun asVar(VAR x) = x | asVar _ = raise Crash.Crash "Env.asVar: inconsistent"
    fun asMod(MOD x) = x | asMod _ = raise Crash.Crash "Env.asMod: inconsistent"
    fun asInf(INF x) = x | asInf _ = raise Crash.Crash "Env.asInf: inconsistent"

    fun appVal f (x, VAL y) = f(x,y) | appVal f _ = ()
    fun appTyp f (x, TYP y) = f(x,y) | appTyp f _ = ()
    fun appVar f (x, VAR y) = f(x,y) | appVar f _ = ()
    fun appMod f (x, MOD y) = f(x,y) | appMod f _ = ()
    fun appInf f (x, INF y) = f(x,y) | appInf f _ = ()

    fun foldVal f (x, VAL y, a) = f(x,y,a) | foldVal f (_,_,a) = a
    fun foldTyp f (x, TYP y, a) = f(x,y,a) | foldTyp f (_,_,a) = a
    fun foldVar f (x, VAR y, a) = f(x,y,a) | foldVar f (_,_,a) = a
    fun foldMod f (x, MOD y, a) = f(x,y,a) | foldMod f (_,_,a) = a
    fun foldInf f (x, INF y, a) = f(x,y,a) | foldInf f (_,_,a) = a


    (* Operation wrappers *)

    exception Collision = Map.Collision
    exception Lookup    = Map.Lookup

    fun new()				= ENV(Map.new())
    fun copy(ENV E)			= ENV(Map.copy E)
    fun copyScope(ENV E)		= ENV(Map.copyScope E)
    fun splitScope(ENV E)		= ENV(Map.splitScope E)
    fun insertScope(ENV E)		= Map.insertScope E
    fun deleteScope(ENV E)		= Map.deleteScope E
    fun mergeScope(ENV E)		= Map.mergeScope E

    fun union(ENV E1, ENV E2)		= Map.unionDisjoint(E1,E2)

    fun insertVal(ENV E, x, y)		= Map.insertDisjoint(E, x, VAL y)
    fun insertTyp(ENV E, x, y)		= Map.insertDisjoint(E, x, TYP y)
    fun insertVar(ENV E, x, y)		= Map.insertDisjoint(E, x, VAR y)
    fun insertMod(ENV E, x, y)		= Map.insertDisjoint(E, x, MOD y)
    fun insertInf(ENV E, x, y)		= Map.insertDisjoint(E, x, INF y)

    fun lookupVal(ENV E, x)		= asVal(Map.lookupExistent(E,x))
    fun lookupTyp(ENV E, x)		= asTyp(Map.lookupExistent(E,x))
    fun lookupVar(ENV E, x)		= asVar(Map.lookupExistent(E,x))
    fun lookupMod(ENV E, x)		= asMod(Map.lookupExistent(E,x))
    fun lookupInf(ENV E, x)		= asInf(Map.lookupExistent(E,x))

    fun appVals f (ENV E)		= Map.appi (appVal f) E
    fun appTyps f (ENV E)		= Map.appi (appTyp f) E
    fun appVars f (ENV E)		= Map.appi (appVar f) E
    fun appMods f (ENV E)		= Map.appi (appMod f) E
    fun appInfs f (ENV E)		= Map.appi (appInf f) E

    fun foldVals f a (ENV E)		= Map.foldi (foldVal f) a E
    fun foldTyps f a (ENV E)		= Map.foldi (foldTyp f) a E
    fun foldVars f a (ENV E)		= Map.foldi (foldVar f) a E
    fun foldMods f a (ENV E)		= Map.foldi (foldMod f) a E
    fun foldInfs f a (ENV E)		= Map.foldi (foldInf f) a E

  end
(* src # 61 *)
signature ENV0 =
  sig
    val E0 :	Env.t
  end
(* src # 62 *)
structure Env0 :> ENV0 =
  struct

    open Env

    structure P   = Prebound
    datatype id   = datatype AbstractGrammar.id
    datatype kind = datatype Type.kind
    datatype sort = datatype Type.sort


  (* Prebound *)

    val E0 = new()


  (* Type environment *)

    val s_int		= "int"
    val s_word		= "word"
    val s_char		= "char"
    val s_string	= "string"
    val s_real		= "real"
    val s_bool		= "bool"
    val s_exn		= "exn"
    val s_ref		= "ref"
    val s_vec		= "vector"
    val s_list		= "list"

    val path_int	= Path.fromLab(Lab.fromString s_int)
    val path_word	= Path.fromLab(Lab.fromString s_word)
    val path_char	= Path.fromLab(Lab.fromString s_char)
    val path_string	= Path.fromLab(Lab.fromString s_string)
    val path_real	= Path.fromLab(Lab.fromString s_real)
    val path_bool	= Path.fromLab(Lab.fromString s_bool)
    val path_exn	= Path.fromLab(Lab.fromString s_exn)
    val path_ref	= Path.fromLab(Lab.fromString s_ref)
    val path_vec	= Path.fromLab(Lab.fromString s_vec)
    val path_list	= Path.fromLab(Lab.fromString s_list)

    val con_word	= (STAR, CLOSED, path_word)
    val con_int		= (STAR, CLOSED, path_int)
    val con_char	= (STAR, CLOSED, path_char)
    val con_string	= (STAR, CLOSED, path_string)
    val con_real	= (STAR, CLOSED, path_real)
    val con_bool	= (STAR, CLOSED, path_bool)
    val con_exn		= (STAR, CLOSED, path_exn)
    val con_ref		= (ARROW(STAR,STAR), CLOSED, path_ref)
    val con_vec		= (ARROW(STAR,STAR), CLOSED, path_vec)
    val con_list	= (ARROW(STAR,STAR), CLOSED, path_list)

    val typ_int		= Type.inCon con_int	(* Always maximise sharing! *)
    val typ_word	= Type.inCon con_word
    val typ_char	= Type.inCon con_char
    val typ_string	= Type.inCon con_string
    val typ_real	= Type.inCon con_real
    val typ_bool	= Type.inCon con_bool
    val typ_exn		= Type.inCon con_exn
    val typ_ref		= Type.inCon con_ref
    val typ_vec		= Type.inCon con_vec
    val typ_list	= Type.inCon con_list

    fun insertTyp'(stamp, path, typ, sort, s) =
	let
	    val entry = { id   = Id(Source.nowhere, stamp, Name.ExId s)
			, path = path
			, typ  = typ
			, sort = sort
			}
	in
	    insertTyp(E0, stamp, entry)
	end

    val _ = insertTyp'(P.stamp_int,    path_int,   typ_int,    CLOSED, s_int)
    val _ = insertTyp'(P.stamp_word,   path_word,  typ_word,   CLOSED, s_word)
    val _ = insertTyp'(P.stamp_char,   path_char,  typ_char,   CLOSED, s_char)
    val _ = insertTyp'(P.stamp_string, path_string,typ_string, CLOSED, s_string)
    val _ = insertTyp'(P.stamp_real,   path_real,  typ_real,   CLOSED, s_real)
    val _ = insertTyp'(P.stamp_bool,   path_bool,  typ_bool,   CLOSED, s_bool)
    val _ = insertTyp'(P.stamp_exn,    path_exn,   typ_exn,    OPEN,   s_exn)
    val _ = insertTyp'(P.stamp_tref,   path_ref,   typ_ref,    CLOSED, s_ref)
    val _ = insertTyp'(P.stamp_vec,    path_vec,   typ_vec,    CLOSED, s_vec)
    val _ = insertTyp'(P.stamp_list,   path_list,  typ_list,   CLOSED, s_list)


  (* Value environment *)

    val s_false		= "false"
    val s_true		= "true"
    val s_nil		= "nil"
    val s_cons		= "cons"
    val s_ref		= "ref"
    val s_match		= "Match"
    val s_bind		= "Bind"

    val path_false	= Path.fromLab(Lab.fromString s_false)
    val path_true	= Path.fromLab(Lab.fromString s_true)
    val path_nil	= Path.fromLab(Lab.fromString s_nil)
    val path_cons	= Path.fromLab(Lab.fromString s_cons)
    val path_ref	= Path.fromLab(Lab.fromString s_ref)
    val path_match	= Path.fromLab(Lab.fromString s_match)
    val path_bind	= Path.fromLab(Lab.fromString s_bind)

    fun poly typF =
	let
	    val alpha = Type.var Type.STAR
	in
	    Type.inAll(alpha, typF(Type.inVar alpha))
	end

    val typ_false = typ_bool
    val typ_true  = typ_bool
    val typ_nil   = poly (fn a => Type.inApp(typ_list, a))
    val typ_cons  = poly (fn a => let val listA = Type.inApp(typ_list, a) in
				      Type.inArrow(Type.inTuple[a,listA], listA)
				  end)
    val typ_ref   = poly (fn a => Type.inArrow(a, Type.inApp(typ_ref, a)))
    val typ_Match = typ_exn
    val typ_Bind  = typ_exn

    fun insertCon'(stamp, path, typ, s) =
	let
	    val entry = { id   = Id(Source.nowhere, stamp, Name.ExId s)
			, path = path
			, typ  = typ
			, sort = Inf.CONSTRUCTOR
			}
	in
	    insertVal(E0, stamp, entry)
	end

    val _ = insertCon'(P.stamp_false, path_false, typ_false, s_false)
    val _ = insertCon'(P.stamp_true,  path_true,  typ_true,  s_true)
    val _ = insertCon'(P.stamp_nil,   path_nil,   typ_nil,   s_nil)
    val _ = insertCon'(P.stamp_cons,  path_cons,  typ_cons,  s_cons)
    val _ = insertCon'(P.stamp_ref,   path_ref,   typ_ref,   s_ref)
    val _ = insertCon'(P.stamp_Match, path_match, typ_Match, s_match)
    val _ = insertCon'(P.stamp_Bind,  path_bind,  typ_Bind,  s_bind)

  end
(* src # 63 *)
signature PP_PATH =
  sig

    type doc  = PrettyPrint.doc
    type path = Path.t

    val ppPath : path -> doc

  end
(* src # 64 *)
structure PPPath :> PP_PATH =
  struct

    (* Import *)

    open PathPrivate
    open PrettyPrint
    open PPMisc

    infixr ^^ ^/^


    fun ppName n		= text(Name.toString n)
    fun ppLab l			= text(Lab.toString l)

    fun ppHiddenLab(0,l)	= ppLab l
      | ppHiddenLab(i,l)	= text "?" ^^ ppHiddenLab(i-1, l)

    fun ppPath(ref(PLAIN n))	= ppName n
      | ppPath(ref(DOT(p,l,i)))	= ppPath p ^^ text "." ^^ ppHiddenLab(i, l)

  end
(* src # 65 *)
signature PP_TYPE =
  sig

    type doc  = PrettyPrint.doc
    type typ  = Type.typ
    type kind = Type.kind

    val ppTyp :		typ -> doc
    val ppKind :	kind -> doc

  end
(* src # 66 *)
structure PPType :> PP_TYPE =
  struct

    (* Import *)

    open TypePrivate
    open PrettyPrint
    open PPMisc

    infixr ^^ ^/^


    (* Helpers *)

    fun uncurry(ref(APP(t1,t2)))= let val (t,ts) = uncurry t1 in (t,ts@[t2]) end
      | uncurry t		= (t,[])

    fun parenPrec p (p',doc) =
	if p > p' then
	    paren doc
	else
	    doc


    (* Simple objects *)

    fun ppLab l		= text(Lab.toString l)
    fun ppCon (k,_,p)	= PPPath.ppPath p

    fun varToString(isBound, n) =
	let
	    fun rep(0,c) = c
	      | rep(n,c) = c ^ rep(n-1,c)

	    val c = String.str(Char.chr(Char.ord #"a" + n mod 26))
	in
	    (if isBound then "'" else "'_") ^ rep(n div 26, c)
	end


    (* Kinds *)

    (* Precedence:
     *	0 : arrow (ty1 -> ty2)
     *	1 : star
     *)

    fun ppKind k = fbox(below(ppKindPrec 0 k))

    and ppKindPrec p  STAR		= text "*"
      | ppKindPrec p (ARROW(k1,k2))	= 
	let
	    val doc = ppKindPrec 1 k1 ^/^ text "->" ^/^ ppKindPrec 0 k2
	in
	    parenPrec p (0, doc)
	end


    (* Types *)

    (* Precedence:
     *  0 : sums (con of ty1 | ... | con of tyn), kind annotation (ty : kind)
     *	1 : binders (LAM ty1 . ty2)
     *	2 : function arrow (ty1 -> ty2)
     *	3 : tuple (ty1 * ... * tyn)
     *	4 : constructed type (tyseq tycon)
     *)

    fun ppTyp t =
	let
	    val trail = ref []
	    val a     = ref 0

	    fun makeVar(isBound, t as ref t') =
		let
		    val k = kindVar t
		    val s = varToString(isBound, !a before a := !a+1)
		    val c = (k, CLOSED, Path.fromLab(Lab.fromString s))
		    val _ = t := CON c
		    val _ = if isBound then () else trail := (t,t')::(!trail)
		in
		    t'
		end

	    fun ppTyp t = fbox(below(ppTypPrec 0 t))

	    and ppTypPrec p (t as ref(HOLE(k,n))) =
		let
		    val t'  = makeVar(false, t)
		    val doc = ppTypPrec' p (!t)
		in
		    if k = STAR then
			doc
(*DEBUG*)
^^ text("_" ^ Int.toString n)
		    else
			parenPrec p (0, doc ^/^ text ":" ^/^ ppKind k)

		end

	      | ppTypPrec p (t as ref(REC t1 | MARK(REC t1))) =
(*DEBUG*)
((*print("[pp " ^ pr(!t) ^ "]");*)
		if occurs(t,t1) then
		    let
(*val _=print"recursive\n"
*)			val t'  = makeVar(true, t)
			val doc = (case t' of MARK _ => text "!MU"
					    | _      => text "MU") ^/^
				  abox(
					hbox(
					    ppTyp t ^/^
					    text "."
					) ^^
					below(break ^^
					    ppTypPrec 1 t1
					)
				  )
			val _   = t := t'
		    in
			parenPrec p (1, fbox(below(nest(doc))))
		    end
		else
(*(print"not recursive\n";*)
		    ppTypPrec p t1
)

	      | ppTypPrec p (t as ref(APP _)) =
	        ( reduce t ;
(*print("[pp APP]");*)
		  if isApp t then ppTypPrec' p (!t)
			     else ppTypPrec p t
		)

	      | ppTypPrec p (ref t') = ppTypPrec' p t'
(*(*DEBUG*)
	      | ppTypPrec p (t as ref t') =
let
val _=print("[pp " ^ pr t' ^ "]")
(*val _=TextIO.inputLine TextIO.stdIn*)
in
	if foldl1'(t', fn(t1,b) => b orelse occursIllegally(t,t1), false) then
		    let
(*DEBUG*)
val _=print"RECURSIVE!\n"
			val a'  = makeVar(true, t)
			val doc = text "MU" ^/^
				    abox(
					hbox(
					    ppTyp t ^/^
					    text "."
					) ^^
					below(break ^^
					    ppTypPrec' 1 t'
					)
				    )
			val _   = t := a'
		    in
			parenPrec p (1, fbox(below(nest(doc))))
		    end
		else
		    ppTypPrec' p t'
end
*)

	    and ppTypPrec' p (LINK t) =
(*DEBUG
text "@" ^^*)
		    ppTypPrec p t

	      | ppTypPrec' p (MARK t') =
		    text "!" ^^ ppTypPrec' p t'

	      | ppTypPrec' p (ARR(t1,t2)) =
		let
		    val doc = ppTypPrec 3 t1 ^/^ text "->" ^/^ ppTypPrec 2 t2
		in
		    parenPrec p (2, doc)
		end

	      | ppTypPrec' p (TUP [] | ROW NIL) =
		    text "unit"

	      | ppTypPrec' p (TUP ts) =
		let
		    val doc = ppStarList (ppTypPrec 4) ts
		in
		    parenPrec p (3, fbox(below(nest doc)))
		end

	      | ppTypPrec' p (ROW r) =
		    brace(fbox(below(ppRow r)))

	      | ppTypPrec' p (SUM r) =
		    paren(fbox(below(ppSum r)))

	      | ppTypPrec' p (VAR(k,n)) =
		if k = STAR then
		    text "'?"
(*DEBUG*)
^^ text("[" ^ Int.toString n ^ "]")
		else
		    paren (text "'?" ^/^ text ":" ^/^ ppKind k)

	      | ppTypPrec' p (CON c) =
		    ppCon c

	      | ppTypPrec' p (ALL(a,t)) =
		let
		    val doc = ppBinder("ALL",a,t)
		in
		    parenPrec p (1, fbox(below doc))
		end

	      | ppTypPrec' p (EX(a,t)) =
		let
		    val doc = ppBinder("EX",a,t)
		in
		    parenPrec p (1, fbox(below doc))
		end

	      | ppTypPrec' p (LAM(a,t)) =
		let
		    val doc = ppBinder("FN",a,t)
		in
		    parenPrec p (1, fbox(below doc))
		end

	      | ppTypPrec' p (t' as APP _) =
		let
		    val (t,ts) = uncurry(ref t')
		in
		    fbox(nest(ppSeqPrec ppTypPrec 4 ts ^/^ ppTypPrec 5 t))
		end

	      | ppTypPrec' p (HOLE _) =
		    raise Crash.Crash "PPType.ppTyp: bypassed HOLE"

	      | ppTypPrec' p (REC _) =
		    raise Crash.Crash "PPType.ppTyp: bypassed REC"


	    and ppRow NIL		= empty
	      | ppRow(RHO _)		= text "..."
	      | ppRow(FLD(l,ts,NIL))	= ppField(l,ts)
	      | ppRow(FLD(l,ts,r))	= ppField(l,ts) ^^ text "," ^/^ ppRow r

	    and ppSum NIL		= empty
	      | ppSum(RHO _)		= text "..."
	      | ppSum(FLD(l,ts,NIL))	= ppField(l,ts)
	      | ppSum(FLD(l,ts,r))	= ppField(l,ts) ^/^ text "|" ^/^ ppSum r

	    and ppField(l,[]) = ppLab l
	      | ppField(l,ts) =
		    abox(
			hbox(
			    ppLab l ^/^
			    text ":"
			) ^^
			below(break ^^
			    ppCommaList ppTyp ts
			)
		    )

	    and ppBinder(s,a,t) =
		let
		    val a' = makeVar(true, a)
		in
		    abox(
			hbox(
			    text s ^/^
			    ppTyp a ^/^
(*DEBUG*)
(*text"(" ^^ ppTypPrec' 0 a' ^^ text")" ^/^*)
			    text "."
			) ^^
			nest(break ^^
			    ppTyp t
			)
		    )
		    before a := a'
		end
	in
	    ppTyp t before List.app op:= (!trail)
	end

  end
(* src # 67 *)
signature PP_INF =
  sig

    type doc  = PrettyPrint.doc
    type inf  = Inf.inf
    type sign = Inf.sign

    val ppInf :	inf -> doc
    val ppSig : sign -> doc

  end
(* src # 68 *)
structure PPInf :> PP_INF =
  struct

    (* Import *)

    open InfPrivate
    open PrettyPrint
    open PPMisc

    infixr ^^ ^/^


    (* Helpers *)

    fun uncurry(ref(APP(j1,p,_)))= let val (j,ps) = uncurry j1 in (j,ps@[p]) end
      | uncurry j		 = (j,[])


    (* Simple objects *)

    fun ppLab l		= text(Lab.toString l)
    fun ppCon (k,p)	= PPPath.ppPath p


    (* Interfaces *)

    (* Precedence:
     *	0 : binders (LAM(id : inf1) . inf2)
     *	1 : constructed type (inf(path))
     *)

    fun ppInf(ref j') = fbox(below(ppInf' j'))

    and ppInf'(TOP) =
	    text "TOP"

      | ppInf'(CON c) =
	    ppCon c

      | ppInf'(SIG s) =
	    ppSig' s

      | ppInf'(ARR(p,j1,j2)) =
	let
	    val doc = ppBinder("FCT",p,j1,j2)
	in
	    fbox(below doc)
	end

      | ppInf'(LAM(p,j1,j2)) =
	let
	    val doc = ppBinder("LAM",p,j1,j2)
	in
	    fbox(below doc)
	end

      | ppInf'(j' as APP _) =
	let
	    val (j,ps) = uncurry(ref j')
	in
	    fbox(nest(List.foldl (fn(p,d) => d ^/^ paren(PPPath.ppPath p))
				 (ppInf j) ps))
	end

      | ppInf'(LINK j) =
(*DEBUG
text "@" ^^*)
	    ppInf j

    and ppBinder(s,p,j1,j2) =
	    abox(
		fbox(
		    text s ^^
		    text "(" ^/^
		    below(break ^^
			PPPath.ppPath p ^/^
			text ":" ^^
			nest(break ^^
			    ppInf j1
			)
		    ) ^/^
		    text ")" ^/^
		    text "."
		) ^^
		nest(break ^^
		    ppInf j2
		)
	    )


    (* Signatures *)

    and ppSig' s =
	let
	    val doc = ppSig s
	in
	    abox(below(
		text "sig" ^^
		(if isEmpty doc then
		    empty
		 else
		    nest(vbox(break ^^ doc))
		) ^^ break ^^
		text "end"
	    ))
	end

    and ppSig(ref items, _) = vbox(List.foldl ppItem empty items)

    and ppItem(ref item', doc) = ppItem'(item', doc)

    and ppItem'(VAL((p,l,0), t, w, d), doc) =
	    abox(
		hbox(
		    text(if w = VALUE then "val" else "constructor") ^/^
		    ppLab l ^/^
(*DEBUG
text "(" ^^ PPPath.ppPath p ^^ text ")" ^/^*)
		    text ":"
		) ^^
		nest(break ^^
		    abox(PPType.ppTyp t)
		) ^^
		(case d of NONE => empty | SOME p' =>
		if p' = p then empty else
		nest(break ^^
		    abox(text "=" ^/^ PPPath.ppPath p')
		))
	    ) ^/^ doc

      | ppItem'(TYP((p,l,0), k, w, d), doc) =
	    abox(
		hbox(
		    text(if w = CLOSED then "type" else "datatype") ^/^
		    ppLab l ^/^
(*DEBUG
text "(" ^^ PPPath.ppPath p ^^ text ")" ^/^*)
		    text ":"
		) ^^
		nest(break ^^
		    abox(PPType.ppKind k)
		) ^^
		(case d of NONE => empty | SOME t =>
		if Type.isCon t andalso #3(Type.asCon t) = p then empty else
		nest(break ^^
		    abox(text "=" ^/^ PPType.ppTyp t)
		))
	    ) ^/^ doc

      | ppItem'(MOD((p,l,0), j, d), doc) =
	    abox(
		hbox(
		    text(if isArrow j then "functor" else "structure") ^/^
		    ppLab l ^/^
(*DEBUG
text "(" ^^ PPPath.ppPath p ^^ text ")" ^/^*)
		    text ":"
		) ^^
		nest(break ^^
		    abox(ppInf j)
		) ^^
		(case d of NONE => empty | SOME p' =>
		if p' = p then empty else
		nest(break ^^
		    abox(text "=" ^/^ PPPath.ppPath p')
		))
	    ) ^/^ doc

      | ppItem'(INF((p,l,0), k, d), doc) =
	    abox(
		hbox(
		    text "signature" ^/^
		    ppLab l ^/^
(*DEBUG
text "(" ^^ PPPath.ppPath p ^^ text ")" ^/^*)
		    text ":"
		) ^^
		nest(break ^^
		    abox(ppKind k)
		) ^^
		(case d of NONE => empty | SOME j =>
		if isCon j andalso #2(asCon j) = p then empty else
		nest(break ^^
		    abox(text "=" ^/^ ppInf j)
		))
	    ) ^/^ doc

      | ppItem'(_, doc) = doc		(* hidden item *)


    (* Kinds *)

    and ppKind(ref k') = fbox(below(ppKind' k'))

    and ppKind'(GROUND) =
	    text "*"

      | ppKind'(DEP(p,j,k)) =
	    fbox(below(
		abox(
		    fbox(
			text "PI" ^/^
			text "(" ^^
			below(break ^^
			    PPPath.ppPath p ^/^
			    text ":" ^^
			    nest(break ^^
				ppInf j
			    )
			) ^/^
			text ")" ^/^
			text "."
		    ) ^^
		    nest(break ^^
			ppKind k
		    )
		)
	    ))

  end
(* src # 69 *)
signature ELABORATION_ERROR =
  sig

    type lab    = Lab.t
    type typ    = Type.t
    type var    = Type.var
    type kind   = Type.kind
    type inf	= Inf.t
    type id     = AbstractGrammar.id
    type longid = AbstractGrammar.longid

    type unify_error  = typ * typ * typ * typ
    type inf_mismatch = Inf.mismatch

    datatype error =
	(* Expressions *)
	  VecExpUnify		of unify_error
	| AppExpFunUnify	of unify_error
	| AppExpArgUnify	of unify_error
	| CompExpNoRow		of typ
	| CompExpUnify		of unify_error
	| AndExpUnify		of unify_error
	| OrExpUnify		of unify_error
	| IfExpCondUnify	of unify_error
	| IfExpBranchUnify	of unify_error
	| WhileExpCondUnify	of unify_error
	| RaiseExpUnify		of unify_error
	| HandleExpUnify	of unify_error
	| AnnExpUnify		of unify_error
	| MatchPatUnify		of unify_error
	| MatchExpUnify		of unify_error
	(* Patterns *)
	| ConPatFewArgs		of longid
	| ConPatManyArgs	of longid
	| ConPatUnify		of unify_error
	| VecPatUnify		of unify_error
	| AsPatUnify		of unify_error
	| AltPatUnify		of unify_error
	| GuardPatUnify		of unify_error
	| AnnPatUnify		of unify_error
	(* Types *)
	| StarTypKind		of kind
	| AppTypFunKind		of kind
	| AppTypArgKind		of kind * kind
	| RefTypKind		of kind
	(* Declarations *)
	| ValDecUnify		of unify_error
	| ValDecLift		of id * var
	(* Long ids *)
	| ModLongidInf		of longid * inf
	(* Modules *)
	| StrModUnclosed	of lab * int * typ
	| SelModInf		of inf
	| AppModFunMismatch	of inf
	| AppModArgMismatch	of inf_mismatch
	| AnnModMismatch	of inf_mismatch
	(* Interfaces *)
	| GroundInfKind		of Inf.kind
	| CompInfMismatch	of inf_mismatch
	| SingInfPath
	(* Components *)
	| CompUnclosed		of lab * int * typ

    datatype warning =
	  NotGeneralized	of id * typ

    val error :	Source.region * error -> 'a
    val warn :	Source.region * warning -> unit

  end
(* src # 70 *)
structure ElaborationError :> ELABORATION_ERROR =
  struct

  (* Pretty printer *)

    open PrettyPrint
    open PPMisc

    infixr ^^ ^/^

    val par = paragraph

  (* Types *)

    type lab    = Lab.t
    type typ    = Type.t
    type var    = Type.var
    type kind   = Type.kind
    type inf	= Inf.t
    type id     = AbstractGrammar.id
    type longid = AbstractGrammar.longid

    type unify_error  = typ * typ * typ * typ
    type inf_mismatch = Inf.mismatch

    datatype error =
	(* Expressions *)
	  VecExpUnify		of unify_error
	| AppExpFunUnify	of unify_error
	| AppExpArgUnify	of unify_error
	| CompExpNoRow		of typ
	| CompExpUnify		of unify_error
	| AndExpUnify		of unify_error
	| OrExpUnify		of unify_error
	| IfExpCondUnify	of unify_error
	| IfExpBranchUnify	of unify_error
	| WhileExpCondUnify	of unify_error
	| RaiseExpUnify		of unify_error
	| HandleExpUnify	of unify_error
	| AnnExpUnify		of unify_error
	| MatchPatUnify		of unify_error
	| MatchExpUnify		of unify_error
	(* Patterns *)
	| ConPatFewArgs		of longid
	| ConPatManyArgs	of longid
	| ConPatUnify		of unify_error
	| VecPatUnify		of unify_error
	| AsPatUnify		of unify_error
	| AltPatUnify		of unify_error
	| GuardPatUnify		of unify_error
	| AnnPatUnify		of unify_error
	(* Types *)
	| StarTypKind		of kind
	| AppTypFunKind		of kind
	| AppTypArgKind		of kind * kind
	| RefTypKind		of kind
	(* Declarations *)
	| ValDecUnify		of unify_error
	| ValDecLift		of id * var
	(* Long ids *)
	| ModLongidInf		of longid * inf
	(* Modules *)
	| StrModUnclosed	of lab * int * typ
	| SelModInf		of inf
	| AppModFunMismatch	of inf
	| AppModArgMismatch	of inf_mismatch
	| AnnModMismatch	of inf_mismatch
	(* Interfaces *)
	| GroundInfKind		of Inf.kind
	| CompInfMismatch	of inf_mismatch
	| SingInfPath
	(* Components *)
	| CompUnclosed		of lab * int * typ

    datatype warning =
	  NotGeneralized	of id * typ


  (* Pretty printing *)

    fun ppQuoted s	= "`" ^ s ^ "'"

    fun ppLab'(AbstractGrammar.Lab(_,l)) = l

    fun ppId'(AbstractGrammar.Id(_,_,name)) = Name.toString name
    fun ppId x = ppQuoted(ppId' x)

    fun ppLongid'(AbstractGrammar.ShortId(_,x))  = ppId' x
      | ppLongid'(AbstractGrammar.LongId(_,y,l)) = ppLongid' y ^ "." ^ ppLab' l
    fun ppLongid y = ppQuoted(ppLongid' y)


    fun ppLab l = ppQuoted(Lab.toString l)


    fun ppUnify2(d1, d2, (t1,t2,t3,t4)) =
	vbox(
	    d1 ^^
	    nest(break ^^ below(PPType.ppTyp t1)) ^/^
	    d2 ^^
	    nest(break ^^ below(PPType.ppTyp t2))
	)

    fun ppUnify4(d1, d2, (t1,t2,t3,t4)) =
	let
	    val td1 = PPType.ppTyp t1
	    val td2 = PPType.ppTyp t2
	    val td3 = PPType.ppTyp t3
	    val td4 = PPType.ppTyp t4
	in
	    if td3 = td1 andalso td4 = td2 then
		vbox(
		    d1 ^^
		    nest(break ^^ below td1) ^/^
		    d2 ^^
		    nest(break ^^ below td2)
		)
	    else
		vbox(
		    d1 ^^
		    nest(break ^^ below td1) ^/^
		    d2 ^^
		    nest(break ^^ below td2) ^/^
		    par["because","type"] ^^
		    nest(break ^^ below td3) ^/^
		    par["does","not","unify","with"] ^^
		    nest(break ^^ below td4)
		)
	end

    fun ppMismatch(d, im) =
        vbox(
	    d ^/^
	    par(ppMismatch' im)
	)

    and ppMismatch'(Inf.MissingVal l) =
	    ["value",ppLab l,"is","missing"]
      | ppMismatch'(Inf.MissingTyp  l) =
	    ["type",ppLab l,"is","missing"]
      | ppMismatch'(Inf.MissingMod  l) =
	    ["module",ppLab l,"is","missing"]
      | ppMismatch'(Inf.MissingInf  l) =
	    ["signature",ppLab l,"is","missing"]
      | ppMismatch'(Inf.ManifestVal l) =
	    ["value",ppLab l,"does","not","match","manifest","specification"]
      | ppMismatch'(Inf.ManifestTyp l) =
	    ["type",ppLab l,"does","not","match","manifest","specification"]
      | ppMismatch'(Inf.ManifestMod l) =
	    ["module",ppLab l,"does","not","match","manifest","specification"]
      | ppMismatch'(Inf.ManifestInf l) =
	    ["signature",ppLab l,
	     "does","not","match","manifest","specification"]
      | ppMismatch'(Inf.MismatchVal(l,t1,t2)) =
	    ["value",ppLab l,"has","incompatible","type"]
      | ppMismatch'(Inf.MismatchTyp(l,k1,k2)) =
	    ["type",ppLab l,"has","incompatible","arity"]
      | ppMismatch'(Inf.MismatchMod(l, Inf.Incompatible _)) =
	    ["module",ppLab l,"has","incompatible","signature"]
      | ppMismatch'(Inf.MismatchMod(l, im as Inf.IncompatibleArg _)) =
	    ["module",ppLab l,"has","incompatible","signature,","because"]
	    @ ppMismatch' im
      | ppMismatch'(Inf.MismatchMod(l,im)) =
	    ["module",ppLab l,"has","incompatible","signature,",
	     "because","nested"] @ ppMismatch' im
      | ppMismatch'(Inf.MismatchInf(l, Inf.Incompatible _)) =
	    ["signature",ppLab l,"is","incompatible"]
      | ppMismatch'(Inf.MismatchInf(l, im as Inf.IncompatibleArg _)) =
	    ["signature",ppLab l,"is","incompatible","because"]
	    @ ppMismatch' im
      | ppMismatch'(Inf.MismatchInf(l,im)) =
	    ["signature",ppLab l,"is","incompatible,","because","nested"]
	    @ ppMismatch' im
      | ppMismatch'(Inf.MismatchValSort(l,w1,w2)) =
	    ["value",ppLab l,"is","not","a","constructor"]
      | ppMismatch'(Inf.MismatchTypSort(l,w1,w2)) =
	    ["type",ppLab l,"is","not","an","open","datatype"]
      | ppMismatch'(Inf.MismatchDom im) =
	    ["functor","signature","is","incompatible","because","argument"]
	    @ ppMismatch' im
      | ppMismatch'(Inf.MismatchRan im) =
	    ["functor","signature","is","incompatible","because","result"]
	    @ ppMismatch' im
      | ppMismatch'(Inf.Incompatible(j1,j2)) =
	    ["signatures","are","incompatible"]
      | ppMismatch'(Inf.IncompatibleArg(p1,p2)) =
	    ["applied","signature","arguments","are","incompatible"]


    fun ppUnclosed(d, (l,n,t)) =
	vbox(
	    d ^^
	    nest(break ^^
		fbox(nest(
		    text(Lab.toString l) ^/^
		    text ":" ^/^
		    below(PPType.ppTyp t)
		))
	    ) ^/^
	    par["contains","free","type","variable",
		"or","unresolved","record","type"]
	)


    fun ppError(VecExpUnify ue) =
	ppUnify2(
	  par["inconsistent","types","in","vector","expression:"],
	  par["does","not","agree","with","previous","element","type"], ue)
      | ppError(AppExpFunUnify ue) =
	ppUnify2(
	  par["applied","value","is","not","a","function:"],
	  par["does","not","match","function","type"], ue)
      | ppError(AppExpArgUnify ue) =
	ppUnify4(
	  par["argument","type","mismatch:"],
	  par["does","not","match","argument","type"], ue)
      | ppError(CompExpNoRow t) =
	vbox(
	    par["specialization","type","is","not","a","record:"] ^^
	    nest(break ^^ PPType.ppTyp t)
	)
      | ppError(CompExpUnify ue) =
	ppUnify4(
	  par["mismatch","on","record","update:"],
	  par["does","not","match","type"], ue)
      | ppError(AndExpUnify ue) =
	ppUnify2(
	  par["operand","of","`andalso'","is","not","a","boolean:"],
	  par["does","not","match","type"], ue)
      | ppError(OrExpUnify ue) =
	ppUnify2(
	  par["operand","of","`orelse'","is","not","a","boolean:"],
	  par["does","not","match","type"], ue)
      | ppError(IfExpCondUnify ue) =
	ppUnify2(
	  par["operand","of","`if'","is","not","a","boolean:"],
	  par["does","not","match","type"], ue)
      | ppError(IfExpBranchUnify ue) =
	ppUnify4(
	  par["inconsistent","types","in","branches","of","`if':"],
	  par["does","not","agree","with","type"], ue)
      | ppError(WhileExpCondUnify ue) =
	ppUnify2(
	  par["operand","of","`while'","is","not","a","boolean:"],
	  par["does","not","match","type"], ue)
      | ppError(RaiseExpUnify ue) =
	ppUnify2(
	  par["operand","of","`raise'","is","not","an","exception:"],
	  par["does","not","match","type"], ue)
      | ppError(HandleExpUnify ue) =
	ppUnify4(
	  par["inconsistent","types","in","branches","of","`handle':"],
	  par["does","not","agree","with","type"], ue)
      | ppError(AnnExpUnify ue) =
	ppUnify4(
	  par["expression","does","not","match","annotation:"],
	  par["does","not","match","type"], ue)
      (* Patterns *)
      | ppError(MatchPatUnify ue) =
	ppUnify4(
	  par["inconsistent","types","in","`case'","patterns:"],
	  par["does","not","agree","with","previous","type"], ue)
      | ppError(MatchExpUnify ue) =
	ppUnify4(
	  par["inconsistent","types","in","branches","of","`case':"],
	  par["does","not","agree","with","previous","type"], ue)
      | ppError(ConPatFewArgs y) =
	  par["missing","argument","to","constructor",ppLongid y,"in","pattern"]
      | ppError(ConPatManyArgs y) =
	  par["surplus","argument","to","constructor",ppLongid y,"in","pattern"]
      | ppError(ConPatUnify ue) =
	ppUnify4(
	  par["ill-typed","constructor","argument:"],
	  par["does","not","match","argument","type"], ue)
      | ppError(VecPatUnify ue) =
	ppUnify2(
	  par["inconsistent","types","in","vector","pattern:"],
	  par["does","not","agree","with","previous","element","type"], ue)
      | ppError(AsPatUnify ue) =
	ppUnify4(
	  par["inconsistent","types","in","`as'","pattern:"],
	  par["does","not","agree","with","type"], ue)
      | ppError(AltPatUnify ue) =
	ppUnify4(
	  par["inconsistent","types","in","pattern","alternatives:"],
	  par["does","not","agree","with","previous","type"], ue)
      | ppError(GuardPatUnify ue) =
	ppUnify2(
	  par["pattern","guard","is","not","a","boolean:"],
	  par["does","not","match","type"], ue)
      | ppError(AnnPatUnify ue) =
	ppUnify4(
	  par["pattern","does","not","match","annotation:"],
	  par["does","not","match","type"], ue)
      (* Types *)
      | ppError(StarTypKind k) =
	  par["missing","arguments","in","type","expression"]
      | ppError(AppTypFunKind k) =
	  par["type","expression","is","not","a","type","function"]
      | ppError(AppTypArgKind(k1,k2)) =
	  par["missing","arguments","in","type","expression"]
      | ppError(RefTypKind k) =
	  par["missing","arguments","in","type","expression"]
      (* Declarations *)
      | ppError(ValDecUnify ue) =
	ppUnify4(
	  par["expression","does","not","match","pattern","type:"],
	  par["does","not","match","type"], ue)
      | ppError(ValDecLift(x,a)) =
	  par["could not generalize","type","of",ppId x,
	      "due","to","value","restriction",
	      "although","it","contains","explicit","type","variables"]
      (* Modules *)
      | ppError(ModLongidInf(y,j)) =
	  par["module",ppLongid y,"is","not","a","structure"]
      | ppError(StrModUnclosed lnt) =
	ppUnclosed(
	  par["structure","is","not","closed:"], lnt)
      | ppError(SelModInf j) =
	  par["module","expression","is","not","a","structure"]
      | ppError(AppModFunMismatch j) =
	  par["applied","module","is","not","a","functor"]
	  (* UNFINISHED: print actual signature j *)
      | ppError(AppModArgMismatch im) =
	ppMismatch(
	  par["module","expression","does","not","match",
	      "functor","parameter","signature:"], im)
      | ppError(AnnModMismatch im) =
	ppMismatch(
	  par["module","expression","does","not","match","signature:"], im)
      (* Interfaces *)
      | ppError(GroundInfKind k) =
	  par["missing","arguments","in","signature","expression"]
      | ppError(CompInfMismatch im) =
	ppMismatch(
	  par["inconsistency","at","signature","specialization:"], im)
      | ppError(SingInfPath) =
	  par["module","expression","is","not","a","path"]
      (* Components *)
      | ppError(CompUnclosed lnt) =
	ppUnclosed(
	  par["component","is","not","closed:"], lnt)

    fun ppWarning(NotGeneralized(x,t)) =
	vbox(
	    par["type","of",ppId x,"cannot","be","generalized","due","to",
		"value","restriction:"] ^^
	    nest(break ^^ PPType.ppTyp t)
	)

  (* Export *)

    fun errorToString e   = PrettyPrint.toString(ppError e, 75)
    fun warningToString w = PrettyPrint.toString(ppWarning w, 75)

    fun error(region, e)  = Error.error(region, errorToString e)
    fun warn(region, w)   = Error.warn(region, warningToString w)

  end
(* src # 71 *)
signature ELABORATION_PHASE =
  sig

    structure I : ABSTRACT_GRAMMAR = AbstractGrammar
    structure O : ABSTRACT_GRAMMAR = TypedGrammar

    type env = Env.t

    val elab :	env -> I.component -> O.component

  end
(* src # 72 *)
(* UNFINISHED:
   - packages
   - appropriate treatment of value paths
*)

(*
 * Note: We assume complete binding analysis and alpha conversion has been
 * performed on the input program. So we would not need to bother with scoping.
 * Nevertheless, we sometimes use scopes to reduce the size of the symbol
 * table.
 *)

structure ElaborationPhase :> ELABORATION_PHASE =
  struct

    structure I = AbstractGrammar
    structure O = TypedGrammar
    structure E = ElaborationError

    open Env

    nonfix mod

  (* Error *)

    val error = E.error

  (* Under construction... *)

    fun unfinished i funname casename =
	Error.warn(i, "Elab." ^ funname ^ ": " ^ casename ^ " not checked yet")


  (* Predefined types *)

    fun boolTyp E	= #typ(lookupTyp(E, Prebound.stamp_bool))
    fun exnTyp E	= #typ(lookupTyp(E, Prebound.stamp_exn))

    (* UNFINISHED: overloading *)
    fun wordTyp E	= #typ(lookupTyp(E, Prebound.stamp_word))
    fun intTyp E	= #typ(lookupTyp(E, Prebound.stamp_int))
    fun charTyp E	= #typ(lookupTyp(E, Prebound.stamp_char))
    fun stringTyp E	= #typ(lookupTyp(E, Prebound.stamp_string))
    fun realTyp E	= #typ(lookupTyp(E, Prebound.stamp_real))

    fun refTyp(E,t)	= Type.inApp(#typ(lookupTyp(E, Prebound.stamp_tref)), t)
    fun vecTyp(E,t)	= Type.inApp(#typ(lookupTyp(E, Prebound.stamp_vec)), t)
    fun listTyp(E,t)	= Type.inApp(#typ(lookupTyp(E, Prebound.stamp_list)), t)


  (* Output info field *)

    fun nonInfo(i)	= (i, TypedInfo.NON)
    fun typInfo(i,t)	= (i, TypedInfo.TYP t)
    fun infInfo(i,j)	= (i, TypedInfo.INF j)


  (* Check value restriction *)

    fun isValue( I.LitExp _
	       | I.PrimExp _
	       | I.VarExp _
	       | I.ConExp _
	       | I.SelExp _
	       | I.CompExp _
	       | I.FunExp _ )			= true
      | isValue( I.TupExp(_, exps)
	       | I.VecExp(_, exps) )		= List.all isValue exps
      | isValue( I.RowExp(_, exprow))		= isValueRow exprow
      | isValue( I.AppExp(_, exp1, exp2))	= isConstr exp1 andalso
						  isValue exp2
      | isValue( I.IfExp (_, exp1, exp2, exp3))	= isValue exp1 andalso
						  isValue exp2 andalso
						  isValue exp3
      | isValue( I.AnnExp(_, exp, _))		= isValue exp
      | isValue  _				= false

    and isValueRow(I.Row(_, fields, _))		= List.all isValueField fields
    and isValueField(I.Field(_, _, exp))	= isValue exp

    and isConstr( I.VarExp _
		| I.FunExp _ )			= false
      | isConstr  exp				= isValue exp


  (* Literals *)

    fun elabLit(E, I.WordLit w)		= ( wordTyp E, O.WordLit w )
      | elabLit(E, I.IntLit n)		= ( intTyp E, O.IntLit n )
      | elabLit(E, I.CharLit c)		= ( charTyp E, O.CharLit c )
      | elabLit(E, I.StringLit s)	= ( stringTyp E, O.StringLit s )
      | elabLit(E, I.RealLit x)		= ( realTyp E, O.RealLit x )


  (* Rows (polymorphic, thus put here) *)

    fun elabLab(E, I.Lab(i, s)) = ( Lab.fromString s, O.Lab(nonInfo(i), s) )

    fun elabRow(elabX, E, I.Row(i, fields, b)) =
	let
	    val  r0         = (if b then Type.unknownRow else Type.emptyRow)()
	    val (r,fields') = elabFields(elabX, E, r0, fields)
	    val  t          = Type.inRow r
	in
	    ( t, O.Row(nonInfo(i), fields', b) )
	end

    and elabField(elabX, E, I.Field(i, lab, x)) =
	let
	    val (l,lab') = elabLab(E, lab)
	    val (t,x')   = elabX(E, x)
	in
	    ( l, [t], O.Field(nonInfo(i), lab', x') )
	end

    and elabFields(elabX, E, r, fields) =
	let
	    fun elabField1(field, (r,fields')) =
		let
		    val (l,ts,field') = elabField(elabX, E, field)
		in
		    ( Type.extendRow(l, ts, r), field'::fields' )
		end
	in
	    List.foldr elabField1 (r,[]) fields
	end


  (* Expressions *)

    fun elabValId_bind(E, s, w, id as I.Id(i, stamp, name)) =
	let
(*DEBUG
val x=case Name.toString(I.name id) of "?" => "?" | x => x
val _=print("-- insert val " ^ x ^ "(" ^ Stamp.toString stamp ^ ")")
*)
	    val  p      = Inf.newVal(s, Lab.fromName name)
	    val  t      = Type.unknown(Type.STAR)
	    (*UNFINISHED: use punning: *)
	    val (p',t') = ( insertVal(E, stamp, {id=id, path=p, typ=t, sort=w})
			  ; (p,t) )
			  handle Collision _ =>	(* val rec or alt pat *)
			    let val {path=p', typ=t', ...} = lookupVal(E, stamp)
			    in (p',t') end
(*
before (print" (* found : ";
PrettyPrint.output(TextIO.stdOut, PPType.ppTyp t', 60);
print" *)")
val _=print "\n"
*)
	in
	    ( t', p', O.Id(typInfo(i,t'), stamp, name) )
	end

    fun elabValId(E, id as I.Id(i, stamp, name)) =
	let
(*DEBUG
val x=case Name.toString(I.name id) of "?" => "?" | x => x
val _=print("-- lookup val " ^ x ^ "(" ^ Stamp.toString stamp ^ ") : ")
val _=PrettyPrint.output(TextIO.stdOut, PPType.ppTyp(#typ(lookupVal(E, stamp))), 60)
val _=print "\n"
"*)
	    val t  = #typ(lookupVal(E, stamp))
	in
	    ( t, O.Id(typInfo(i,t), stamp, name) )
	end

    and elabValLongid(E, I.ShortId(i, id)) =
	let
	    val (t,id') = elabValId(E, id)
	in
	    ( t, O.ShortId(typInfo(i,t), id') )
	end

      | elabValLongid(E, I.LongId(i, longid, lab)) =
	let
	    val (s,longid') = elabModLongid_path(E, longid)
	    val (l,lab')    = elabLab(E, lab)
	    val  t          = Inf.lookupVal(s, l)
	in
	    ( t, O.LongId(typInfo(i,t), longid', lab') )
	end

    and elabValLongid_path(E, I.ShortId(_, I.Id(_, stamp, _))) =
	    #path(lookupVal(E, stamp))

      | elabValLongid_path(E, I.LongId(_, longid, I.Lab(_, l))) =
	let
	    val (s,_) = elabModLongid_path(E, longid)
	in
	    Inf.lookupValPath(s, Lab.fromString l)
	end


    and elabExp(E, I.LitExp(i, lit)) =
	let
	    val (t,lit') = elabLit(E, lit)
	in
	    ( t, O.LitExp(typInfo(i,t), lit') )
	end

      | elabExp(E, I.PrimExp(i, s, typ)) =
	let
	    val (t,typ') = elabStarTyp(E, typ)
	in
	    ( t, O.PrimExp(typInfo(i,t), s, typ') )
	end

      | elabExp(E, I.VarExp(i, longid)) =
	let
	    val (t,longid') = elabValLongid(E, longid)
	    val  t'         = Type.instance t
	in
	    ( t', O.VarExp(typInfo(i,t'), longid') )
	end

      | elabExp(E, I.ConExp(i, n, longid)) =
	let
	    val (t,longid') = elabValLongid(E, longid)
	    val  t'         = Type.instance t
	in
	    ( t', O.ConExp(typInfo(i,t'), n, longid') )
	end

      | elabExp(E, I.RefExp(i)) =
	let
	    val ta = Type.unknown(Type.STAR)
	    val t  = Type.inArrow(ta, refTyp(E, ta))
	in
	    ( t, O.RefExp(typInfo(i,t)) )
	end

      | elabExp(E, I.TupExp(i, exps)) =
	let
	    val (ts,exps') = elabExps(E, exps)
	    val  t         = Type.inTuple ts
	in
	    ( t, O.TupExp(typInfo(i,t), exps') )
	end

      | elabExp(E, I.RowExp(i, exprow)) =
	let
	    val (t,exprow') = elabRow(elabExp, E, exprow)
	in
	    ( t, O.RowExp(typInfo(i,t), exprow') )
	end

      | elabExp(E, I.SelExp(i, lab)) =
	let
	    val (l,lab') = elabLab(E, lab)
	    val  t1      = Type.unknown Type.STAR
	    val  r       = Type.extendRow(l, [t1], Type.unknownRow())
	    val  t       = Type.inArrow(Type.inRow r, t1)
	in
	    ( t, O.SelExp(typInfo(i,t), lab') )
	end

      | elabExp(E, I.VecExp(i, exps)) =
	let
	    val (ts,exps') = elabExps(E, exps)
	    val  t         = vecTyp(E, List.hd ts)
	    val  _         = Type.unifyList ts handle Type.UnifyList(n,t1,t2) =>
				error(I.infoExp(List.nth(exps,n)),
				      E.VecExpUnify(t, List.nth(ts,n), t1, t2))
	in
	    ( t, O.VecExp(typInfo(i,t), exps') )
	end

      | elabExp(E, I.FunExp(i, id, exp)) =
	let
	    val (t1,p,id') = elabValId_bind(E, Inf.empty(), Inf.VALUE, id)
	    val (t2,exp')  = elabExp(E, exp)
	    val  t         = Type.inArrow(t1,t2)
	in
	    ( t, O.FunExp(typInfo(i,t), id', exp') )
	end

      | elabExp(E, I.AppExp(i, exp1, exp2)) =
	let
	    val (t1,exp1') = elabExp(E, exp1)
	    val (t2,exp2') = elabExp(E, exp2)
	    val  t11       = Type.unknown Type.STAR
	    val  t12       = Type.unknown Type.STAR
	    val  t1'       = Type.inArrow(t11,t12)
	    val  _         = Type.unify(t1,t1') handle Type.Unify(t3,t4) =>
				error(I.infoExp exp1,
				      E.AppExpFunUnify(t1, t1', t3, t4))
	    val  _         = Type.unify(t11,t2) handle Type.Unify(t3,t4) =>
				error(i, E.AppExpArgUnify(t11, t2, t3, t4))
	in
	    ( t12, O.AppExp(typInfo(i,t12), exp1', exp2') )
	end

      | elabExp(E, I.CompExp(i, exp1, exp2)) =
	(* UNFINISHED: more polymorphic treatment *)
	let
	    val (t1,exp1') = elabExp(E, exp1)
	    val (t2,exp2') = elabExp(E, exp2)
	    val  _         = Type.openRowType t2 handle Type.Row =>
				error(I.infoExp exp2, E.CompExpNoRow t2)
	    val  _         = Type.unify(t1,t2) handle Type.Unify(t3,t4) =>
				error(i, E.CompExpUnify(t2, t1, t4, t3))
	in
	    ( t1, O.CompExp(typInfo(i,t1), exp1', exp2') )
	end

      | elabExp(E, I.AndExp(i, exp1, exp2)) =
	let
	    val (t1,exp1') = elabExp(E, exp1)
	    val (t2,exp2') = elabExp(E, exp2)
	    val  t         = boolTyp E
	    val  _         = Type.unify(t1,t) handle Type.Unify(t3,t4) =>
				error(I.infoExp exp1, E.AndExpUnify(t1,t,t3,t4))
	    val  _         = Type.unify(t2,t) handle Type.Unify(t3,t4) =>
				error(I.infoExp exp2, E.AndExpUnify(t2,t,t3,t4))
	in
	    ( t, O.AndExp(typInfo(i,t), exp1', exp2') )
	end

      | elabExp(E, I.OrExp(i, exp1, exp2)) =
	let
	    val (t1,exp1') = elabExp(E, exp1)
	    val (t2,exp2') = elabExp(E, exp2)
	    val  t         = boolTyp E
	    val  _         = Type.unify(t1,t) handle Type.Unify(t3,t4) =>
				error(I.infoExp exp1, E.OrExpUnify(t1,t,t3,t4))
	    val  _         = Type.unify(t2,t) handle Type.Unify(t3,t4) =>
				error(I.infoExp exp2, E.OrExpUnify(t2,t,t3,t4))
	in
	    ( t, O.OrExp(typInfo(i,t), exp1', exp2') )
	end

      | elabExp(E, I.IfExp(i, exp1, exp2, exp3)) =
	let
	    val (t1,exp1') = elabExp(E, exp1)
	    val (t2,exp2') = elabExp(E, exp2)
	    val (t3,exp3') = elabExp(E, exp3)
	    val  tb        = boolTyp E
	    val  _         = Type.unify(t1,tb) handle Type.Unify(t4,t5) =>
				error(I.infoExp exp1,
				      E.IfExpCondUnify(t1, tb, t4, t5))
	    val  _         = Type.unify(t2,t3) handle Type.Unify(t4,t5) =>
				error(i, E.IfExpBranchUnify(t2, t3, t4, t5))
	in
	    ( t2, O.IfExp(typInfo(i,t2), exp1', exp2', exp3') )
	end

      | elabExp(E, I.WhileExp(i, exp1, exp2)) =
	let
	    val (t1,exp1') = elabExp(E, exp1)
	    val (t2,exp2') = elabExp(E, exp2)
	    val  tb        = boolTyp E
	    val  t         = Type.inTuple[]
	    val  _         = Type.unify(t1,tb) handle Type.Unify(t3,t4) =>
				error(I.infoExp exp1,
				      E.WhileExpCondUnify(t1, tb, t3, t4))
	in
	    ( t, O.WhileExp(typInfo(i,t), exp1', exp2') )
	end

      | elabExp(E, I.SeqExp(i, exps)) =
	let
	    val (ts,exps') = elabExps(E, exps)
	    val  t         = List.last ts
	in
	    ( t, O.SeqExp(typInfo(i,t), exps') )
	end

      | elabExp(E, I.CaseExp(i, exp, matchs)) =
	(* UNFINISHED: check for exhaustiveness and redundancy *)
	let
	    val (t1,exp')    = elabExp(E, exp)
	    val (t2,matchs') = elabMatchs(E, t1, matchs)
	in
	    ( t2, O.CaseExp(typInfo(i,t2), exp', matchs') )
	end

      | elabExp(E, I.RaiseExp(i, exp)) =
	let
	    val (t1,exp') = elabExp(E, exp)
	    val  te       = exnTyp E
	    val  t        = Type.unknown Type.STAR
	    val  _        = Type.unify(t1,te) handle Type.Unify(t2,t3) =>
				error(I.infoExp exp,
				      E.RaiseExpUnify(t1, te, t2, t3))
	in
	    ( t, O.RaiseExp(typInfo(i,t), exp') )
	end

      | elabExp(E, I.HandleExp(i, exp, matchs)) =
	(* UNFINISHED: check for redundancy *)
	let
	    val (t1,exp')    = elabExp(E, exp)
	    val (t2,matchs') = elabMatchs(E, exnTyp E, matchs)
	    val  _           = Type.unify(t1,t2) handle Type.Unify(t3,t4) =>
				error(i, E.HandleExpUnify(t1, t2, t3, t4))
	in
	    ( t1, O.HandleExp(typInfo(i,t1), exp', matchs') )
	end

      | elabExp(E, I.AnnExp(i, exp, typ)) =
	let
	    val (t1,exp') = elabExp(E, exp)
	    val (t2,typ') = elabStarTyp(E, typ)
	    val  _        = Type.unify(t1,t2) handle Type.Unify(t3,t4) =>
				error(i, E.AnnExpUnify(t1, t2, t3, t4))
	in
	    ( t2, O.AnnExp(typInfo(i,t2), exp', typ') )
	end

      | elabExp(E, I.LetExp(i, decs, exp)) =
	let
	    val  _       = insertScope E
	    val  s       = Inf.empty()
	    val  decs'   = elabDecs(E, s, decs)
(*DEBUG*)
val _ = Inf.strengthenSig(Path.fromLab(Lab.fromString "?let"), s)
	    val  _       = Inf.strengthenSig(Path.invent(), s)
	    val (t,exp') = elabExp(E, exp)
	    val  _       = deleteScope E
	in
	    ( t, O.LetExp(typInfo(i,t), decs', exp') )
	end

      | elabExp(E, I.PackExp(i, mod)) =
	let
	    val (j,mod') = elabMod(E, mod)
	    (*UNFINISHED*)
	    val  t       = Type.unknown(Type.STAR)
	in
	    unfinished i "elabExp" "packages";
	    ( t, O.PackExp(typInfo(i,t), mod') )
	end

    and elabExps(E, exps) =
	ListPair.unzip(List.map (fn exp => elabExp(E,exp)) exps)


  (* Matches *)

    and elabMatch(E, t1, t2, I.Match(i, pat, exp)) =
	let
	    val  _        = insertScope E
	    val (t3,pat') = elabPat(E, Inf.empty(), pat)
	    val  _        = Type.unify(t1,t3) handle Type.Unify(t5,t6) =>
				error(I.infoPat pat,
				      E.MatchPatUnify(t1, t3, t5, t6))
	    val (t4,exp') = elabExp(E, exp)
	    val  _        = Type.unify(t2,t4) handle Type.Unify(t5,t6) =>
				error(I.infoExp exp,
				      E.MatchExpUnify(t2, t4, t5, t6))
	    val  _        = deleteScope E
	in
	    O.Match(nonInfo(i), pat', exp')
	end

    and elabMatchs(E, t1, matchs) =
	let
	    val t2 = Type.unknown Type.STAR

	    fun elabMatch1 match = elabMatch(E, t1, t2, match)
	in
	    ( t2, List.map elabMatch1 matchs )
	end


  (* Patterns *)

    and elabPat(E, s, I.JokPat(i)) =
	let
	    val t = Type.unknown Type.STAR
	in
	    ( t, O.JokPat(typInfo(i,t)) )
	end

      | elabPat(E, s, I.LitPat(i, lit)) =
	let
	    val (t,lit') = elabLit(E, lit)
	in
	    ( t, O.LitPat(typInfo(i,t), lit') )
	end

      | elabPat(E, s, I.VarPat(i, id)) =
	let
	    val (t,p,id') = elabValId_bind(E, s, Inf.VALUE, id)
	in
	    ( t, O.VarPat(typInfo(i,t), id') )
	end

      | elabPat(E, s, I.ConPat(i, longid, pats)) =
	let
	    fun elabArgs(t1, []) =
		if Type.isArrow t1 then
		    error(i, E.ConPatFewArgs(longid))
		else
		    t1

	      | elabArgs(t1, t2::ts) =
		let
		    val  t11  = Type.unknown Type.STAR
		    val  t12  = Type.unknown Type.STAR
		    val  t1'  = Type.inArrow(t11,t12)
		    val  _    = Type.unify(t1',t1) handle Type.Unify(t3,t4) =>
				    error(i, E.ConPatManyArgs(longid))
		    val  _    = Type.unify(t11,t2) handle Type.Unify(t3,t4) =>
				    error(i, E.ConPatUnify(t11, t2, t3, t4))
		in
		    elabArgs(t12, ts)
		end

	    val (t1,longid') = elabValLongid(E, longid)
	    val  t1'         = Type.instance t1
	    val (ts,pats')   = elabPats(E, s, pats)
	    val  t           = elabArgs(t1',ts)
	in
	    ( t, O.ConPat(typInfo(i,t), longid', pats') )
	end

      | elabPat(E, s, I.RefPat(i, pat)) =
	let
	    val (t1,pat') = elabPat(E, s, pat)
	    val  t        = refTyp(E, t1)
	in
	    ( t, O.RefPat(typInfo(i,t), pat') )
	end

      | elabPat(E, s, I.TupPat(i, pats)) =
	let
	    val (ts,pats') = elabPats(E, s, pats)
	    val  t         = Type.inTuple ts
	in
	    ( t, O.TupPat(typInfo(i,t), pats') )
	end

      | elabPat(E, s, I.RowPat(i, patrow)) =
	let
	    val (t,patrow') = elabRow(fn(E,pat) => elabPat(E,s,pat), E, patrow)
	in
	    ( t, O.RowPat(typInfo(i,t), patrow') )
	end

      | elabPat(E, s, I.VecPat(i, pats)) =
	let
	    val (ts,pats') = elabPats(E, s, pats)
	    val  t         = vecTyp(E, List.hd ts)
	    val  _         = Type.unifyList ts handle Type.UnifyList(n,t1,t2) =>
				error(I.infoPat(List.nth(pats,n)),
				      E.VecPatUnify(t, List.nth(ts,n), t1, t2))
	in
	    ( t, O.VecPat(typInfo(i,t), pats') )
	end

      | elabPat(E, s, I.AsPat(i, pat1, pat2)) =
	let
	    val (t1,pat1') = elabPat(E, s, pat1)
	    val (t2,pat2') = elabPat(E, s, pat2)
	    val  _         = Type.unify(t1,t2) handle Type.Unify(t3,t4) =>
				error(i, E.AsPatUnify(t1, t2, t3, t4))
	in
	    ( t2, O.AsPat(typInfo(i,t2), pat1', pat2') )
	end

      | elabPat(E, s, I.AltPat(i, pats)) =
	let
	    val (ts,pats') = elabPats(E, s, pats)
	    val  t         = List.hd ts
	    val  _         = Type.unifyList ts handle Type.UnifyList(n,t1,t2) =>
				error(I.infoPat(List.nth(pats,n)),
				      E.AltPatUnify(t, List.nth(ts,n), t1, t2))
	in
	    ( t, O.AltPat(typInfo(i,t), pats') )
	end

      | elabPat(E, s, I.NegPat(i, pat)) =
	let
	    val (t,pat') = elabPat(E, s, pat)
	in
	    ( t, O.NegPat(typInfo(i,t), pat') )
	end

      | elabPat(E, s, I.GuardPat(i, pat, exp)) =
	let
	    val (t1,pat') = elabPat(E, s, pat)
	    val (t2,exp') = elabExp(E, exp)
	    val  tb       = boolTyp E
	    val  _        = Type.unify(t2,tb) handle Type.Unify(t3,t4) =>
				error(i, E.GuardPatUnify(t2, tb, t3, t4))
	in
	    ( t1, O.GuardPat(typInfo(i,t1), pat', exp') )
	end

      | elabPat(E, s, I.AnnPat(i, pat, typ)) =
	let
	    val (t1,pat') = elabPat(E, s, pat)
	    val (t2,typ') = elabStarTyp(E, typ)
	    val  _        = Type.unify(t1,t2) handle Type.Unify(t3,t4) =>
				error(i, E.AnnPatUnify(t1, t2, t3, t4))
	in
	    ( t2, O.AnnPat(typInfo(i,t2), pat', typ') )
	end

      | elabPat(E, s, I.WithPat(i, pat, decs)) =
	let
	    val (t,pat') = elabPat(E, s, pat)
	    val  decs'   = elabDecs(E, s, decs)
	in
	    ( t, O.WithPat(typInfo(i,t), pat', decs') )
	end


    and elabPats(E, s, pats) =
	ListPair.unzip(List.map (fn pat => elabPat(E,s,pat)) pats)


  (* Types *)

    and elabVarId_bind'(E, id as I.Id(i, stamp, name)) =
	    O.Id(nonInfo(i), stamp, name)

    and elabVarId_bind(E, k, id as I.Id(i, stamp, name)) =
	let
	    val a = Type.var k
	    (*UNFINISHED: use punning: *)
	    val _ = insertVar(E, stamp, {id=id, var=a})
	in
	    ( a, O.Id(nonInfo(i), stamp, name) )
	end

    and elabVarId(E, id as I.Id(i, stamp, name)) =
	let
(*DEBUG
val x=case Name.toString(I.name id) of "?" => "?" | x => x
val _=print("-- lookup type variable " ^ x ^ "(" ^ Stamp.toString stamp ^ ") = ")
val _=PrettyPrint.output(TextIO.stdOut, PPType.ppTyp(Type.inVar(#var(lookupVar(E, stamp)))), 60)
val _=print "\n"
*)
	    val a = #var(lookupVar(E, stamp))
	in
	    ( a, O.Id(nonInfo(i), stamp, name) )
	end


    and elabTypId_bind(E, p, t, w, id as I.Id(i, stamp, name)) =
	let
(*DEBUG
val x=case Name.toString(I.name id) of "?" => "?" | x => x
val _=print("-- insert type " ^ x ^ "(" ^ Stamp.toString stamp ^ ") = ")
val _=PrettyPrint.output(TextIO.stdOut, PPType.ppTyp t, 60)
val _=print "\n"
*)
	    (*UNFINISHED: use punning: *)
	    val _ = insertTyp(E, stamp, {id=id, path=p, typ=t, sort=w})
	in
	    O.Id(typInfo(i,t), stamp, name)
	end

    and elabTypId(E, id as I.Id(i, stamp, name)) =
	let
(*DEBUG
val x=case Name.toString(I.name id) of "?" => "?" | x => x
val _=print("-- lookup type " ^ x ^ "(" ^ Stamp.toString stamp ^ ") = ")
val _=PrettyPrint.output(TextIO.stdOut, PPType.ppTyp(#typ(lookupTyp(E, stamp))), 60)
val _=print "\n"
*)
	    val {typ=t, path=p, ...} = lookupTyp(E, stamp)
	in
	    ( t, p, O.Id(typInfo(i,t), stamp, name) )
	end

    and elabTypLongid(E, I.ShortId(i, id)) =
	let
	    val (t,_,id') = elabTypId(E, id)
	in
	    ( t, O.ShortId(typInfo(i,t), id') )
	end

      | elabTypLongid(E, I.LongId(i, longid, lab)) =
	let
	    val (s,longid') = elabModLongid_path(E, longid)
	    val (l,lab')    = elabLab(E, lab)
	    val  t          = Inf.lookupTyp(s, l)
	in
	    ( t, O.LongId(typInfo(i,t), longid', lab') )
	end


    and elabTypKind(E, I.FunTyp(i, id, typ)) =
	    Type.ARROW(Type.STAR, elabTypKind(E, typ))

      | elabTypKind(E, I.ConTyp(i, longid)) =
	let
	    val (t,_) = elabTypLongid(E, longid)
	in
	    Type.kind t
	end

      | elabTypKind(E, I.VarTyp(i, id)) =
	let
	    val (a,_) = elabVarId(E, id)
	in
	    Type.kindVar a
	end

      | elabTypKind(E, I.AppTyp(i, typ1, typ2)) =
	let
	    val k = elabTypKind(E, typ1)
	in
	    case k
	      of Type.ARROW(k1,k2) => k2
	       | _                 => error(i, E.AppTypFunKind(k))
	end

      | elabTypKind(E, _) =
	    Type.STAR


    and elabStarTyp(E, typ) =
	let
	    val ttyp' as (t,typ') = elabTyp(E, typ)
	in
	    case Type.kind t
	      of Type.STAR => ttyp'
	       | k         => error(I.infoTyp typ, E.StarTypKind(k))
	end

    and elabStarTyps(E, typs) =
	ListPair.unzip(List.map (fn typ => elabStarTyp(E, typ)) typs)


    and elabTyp(E, I.VarTyp(i, id)) =
	let
	    val (a,id') = elabVarId(E, id)
	    val  t      = Type.inVar a
	in
	    ( t, O.VarTyp(typInfo(i,t), id') )
	end

      | elabTyp(E, I.ConTyp(i, longid)) =
	let
	    val (t,longid') = elabTypLongid(E, longid)
	in
	    ( t, O.ConTyp(typInfo(i,t), longid') )
	end

      | elabTyp(E, I.FunTyp(i, id, typ)) =
	let
	    val (a,id')   = elabVarId_bind(E, Type.STAR, id)
	    val (t1,typ') = elabTyp(E, typ)
	    val  t        = Type.inLambda(a,t1)
	in
	    ( t, O.FunTyp(typInfo(i,t), id', typ') )
	end

      | elabTyp(E, I.AppTyp(i, typ1, typ2)) =
	let
	    val (t1,typ1') = elabTyp(E, typ1)
	    val (t2,typ2') = elabTyp(E, typ2)
	    val  k1        = Type.kind t1
	    val  k2        = Type.kind t2
	    val  _         = case k1
			       of Type.STAR =>
					error(i, E.AppTypFunKind(k1))
				| Type.ARROW(k11,k12) =>
				    if k11 = k2 then () else
					error(i, E.AppTypArgKind(k11, k2))
	    val  t         = Type.inApp(t1,t2)
	in
	    ( t, O.AppTyp(typInfo(i,t), typ1', typ2') )
	end

      | elabTyp(E, I.RefTyp(i, typ)) =
	let
	    val (t1,typ') = elabTyp(E, typ)
	    val  _        = case Type.kind t1 of Type.STAR => () | k =>
				error(I.infoTyp typ, E.RefTypKind(k))
	    val  t        = refTyp(E, t1)
	in
	    ( t, O.RefTyp(typInfo(i,t), typ') )
	end

      | elabTyp(E, I.TupTyp(i, typs)) =
	let
	    val (ts,typs') = elabStarTyps(E, typs)
	    val  t         = Type.inTuple ts
	in
	    ( t, O.TupTyp(typInfo(i,t), typs') )
	end

      | elabTyp(E, I.RowTyp(i, typrow)) =
	let
	    val (t,typrow') = elabRow(elabStarTyp, E, typrow)
	in
	    ( t, O.RowTyp(typInfo(i,t), typrow') )
	end

      | elabTyp(E, I.ArrTyp(i, typ1, typ2)) =
	let
	    val (t1,typ1') = elabStarTyp(E, typ1)
	    val (t2,typ2') = elabStarTyp(E, typ2)
	    val  t         = Type.inArrow(t1,t2)
	in
	    ( t, O.ArrTyp(typInfo(i,t), typ1', typ2') )
	end

      | elabTyp(E, I.SumTyp(i, cons)) =
	let
	    val (t,cons') = elabCons(E, cons)
	in
	    ( t, O.SumTyp(typInfo(i,t), cons') )
	end

      | elabTyp(E, I.AllTyp(i, id, typ)) =
	let
	    val (a,id')   = elabVarId_bind(E, Type.STAR, id)
	    val (t1,typ') = elabTyp(E, typ)
	    val  t        = Type.inAll(a,t1)
	in
	    ( t, O.AllTyp(typInfo(i,t), id', typ') )
	end

      | elabTyp(E, I.ExTyp(i, id, typ)) =
	let
	    val (a,id')   = elabVarId_bind(E, Type.STAR, id)
	    val (t1,typ') = elabTyp(E, typ)
	    val  t        = Type.inExist(a,t1)
	in
	    ( t, O.ExTyp(typInfo(i,t), id', typ') )
	end

      | elabTyp(E, I.PackTyp(i, inf)) =
	let
	    val (j,inf') = elabInf(E, inf)
	    (*UNFINISHED*)
	    val  t       = Type.unknown(Type.STAR)
	in
	    unfinished i "elabTyp" "packages";
	    ( t, O.PackTyp(typInfo(i,t), inf') )
	end

      | elabTyp(E, I.SingTyp(i, longid)) =
	let
	    val (t,longid') = elabValLongid(E, longid)
	in
	    ( t, O.SingTyp(typInfo(i,t), longid') )
	end

      | elabTyp(E, I.AbsTyp(i)) =
	raise Crash.Crash "Elab.elabTyp: AbsTyp"

      | elabTyp(E, I.ExtTyp(i)) =
	raise Crash.Crash "Elab.elabTyp: ExtTyp"


    and elabCon(E, I.Con(i, id as I.Id(i', stamp, name), typs)) =
	let
	    val  id'       = O.Id(nonInfo(i'), stamp, name)
	    val  l         = Lab.fromName name
	    val (ts,typs') = elabStarTyps(E, typs)
	in
	    ( l, ts, O.Con(nonInfo(i), id', typs') )
	end

    and elabCons(E, cons) =
	let
	    fun elabCon1(con, (r,cons')) =
		let
		    val (l,ts,con') = elabCon(E, con)
		in
		    ( Type.extendRow(l,ts,r), con'::cons' )
		end

	    val (r,cons') = List.foldr elabCon1 (Type.emptyRow(), []) cons
	    val  t        = Type.inSum r
	in
	    ( t, cons' )
	end


  (* Type representations *)

    (*UNFINISHED: do full traversal to enter all nested constructors
    		  (not needed for SML frontend though...)  *)

    and elabTypRep(E, s, p, t0, buildTyp, buildKind, I.AbsTyp(i))=
	let
	    val t = Type.inCon(buildKind Type.STAR, Type.CLOSED, p)
	in
	    ( t, true, Type.CLOSED, O.AbsTyp(typInfo(i,t)) )
	end

      | elabTypRep(E, s, p, t0, buildTyp, buildKind, I.ExtTyp(i))=
	let
	    val t = Type.inCon(buildKind Type.STAR, Type.OPEN, p)
	in
	    ( t, true, Type.OPEN, O.ExtTyp(typInfo(i,t)) )
	end

      | elabTypRep(E, s, p, t0, buildTyp, buildKind, I.FunTyp(i, id, typ)) =
	let
	    val  k             = Type.STAR
	    val (a,id')        = elabVarId_bind(E, k, id)
	    val (t,gen,w,typ') = elabTypRep(E, s, p,
				      Type.inApp(t0, Type.inVar a),
				      fn t' => Type.inLambda(a,t'),
				      fn k' => Type.ARROW(k, buildKind k'), typ)
	in
	    ( t, gen, w, O.FunTyp(typInfo(i,t), id', typ') )
	end

      | elabTypRep(E, s, p, t0, buildTyp, buildKind, I.SumTyp(i, cons)) =
	let
	    val  t        = Type.inCon (buildKind Type.STAR, Type.CLOSED, p)
	    val (_,cons') = elabConReps(E, s, t0, cons)
	in
	    ( t, true, Type.CLOSED, O.SumTyp(typInfo(i,t), cons') )
	end
	(* Note: structural datatypes would work this way:
	let
	    val (t,cons') = elabConReps(E, s, t0, cons)
	in
	    ( buildTyp t, false, O.SumTyp(typInfo(i,t), cons') )
	end
	*)

      | elabTypRep(E, s, p, t0, buildTyp, buildKind, typ) =
	let
	    val (t,typ') = elabTyp(E, typ)
	in
	    ( t, false, Type.CLOSED, typ' )
	end


    and elabConRep(E, s, t0, I.Con(i, id, typs)) =
	let
	    val  l         = Lab.fromName(I.name id)
	    val (ts,typs') = elabStarTyps(E, typs)
	    val (t,p,id')  = elabValId_bind(E, s, Inf.CONSTRUCTOR, id)
	    val  _         = Type.unify(t, List.foldr Type.inArrow t0 ts)
	in
	    ( l, ts, O.Con(nonInfo(i), id', typs') )
	end

    and elabConReps(E, s, t0, cons) =
	let
	    fun elabCon1(con, (r,cons')) =
		let
		    val (l,ts,con') = elabConRep(E, s, t0, con)
		in
		    ( Type.extendRow(l,ts,r), con'::cons' )
		end

	    val (r,cons') = List.foldr elabCon1 (Type.emptyRow(), []) cons
	    val  t        = Type.inSum r
	in
	    ( t, cons' )
	end


  (* Modules *)

    and elabModId_bind(E, p, j, id as I.Id(i, stamp, name)) =
	let
(*DEBUG
val _ = if false then "" else let
val x=case Name.toString(I.name id) of "?" => "?" | x => x
val _=print("-- insert module " ^ x ^ "(" ^ Stamp.toString stamp ^ ") :\n")
val _=PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j, 75)
val _=print "\n"
in ""(*TextIO.inputLine TextIO.stdIn*) end
*)
	    (*UNFINISHED: use punning: *)
	    val _ = insertMod(E, stamp, {id=id, path=p, inf=j})
	in
	    O.Id(infInfo(i,j), stamp, name)
	end

    and elabModId(E, id as I.Id(i, stamp, name)) =
	let
(*DEBUG
val x=case Name.toString(I.name id) of "?" => "?" | x => x
val _=print("-- lookup module " ^ x ^ "(" ^ Stamp.toString stamp ^ ") :\n")
val _=PrettyPrint.output(TextIO.stdOut, PPInf.ppInf(#inf(lookupMod(E, stamp))), 75)
val _=print "\n"
*)
	    val j = #inf(lookupMod(E, stamp))
	in
	    ( j, O.Id(infInfo(i,j), stamp, name) )
	end

    and elabModLongid(E, I.ShortId(i, id)) =
	let
	    val (j,id') = elabModId(E, id)
	in
	    ( j, O.ShortId(infInfo(i,j), id') )
	end

      | elabModLongid(E, I.LongId(i, longid, lab)) =
	let
	    val (s,longid') = elabModLongid_path(E, longid)
	    val (l,lab')    = elabLab(E, lab)
	    val  j          = Inf.lookupMod(s, l)
	in
	    ( j, O.LongId(infInfo(i,j), longid', lab') )
	end

    and elabModLongid_path(E, longid) =
	let
	    val (j,longid') = elabModLongid(E, longid)
	    val  s          = Inf.asSig j handle Inf.Interface =>
				error(I.infoLongid longid,
				      E.ModLongidInf(longid, j))
	in
	    ( s, longid' )
	end


    and elabMod(E, I.PrimMod(i, s, inf)) =
	let
	    val (j,inf') = elabGroundInf(E, inf)
	in
	    ( j, O.PrimMod(infInfo(i,j), s, inf') )
	end

      | elabMod(E, I.VarMod(i, id)) =
	let
	    val (j,id') = elabModId(E, id)
	in
	    ( j, O.VarMod(infInfo(i,j), id') )
	end

      | elabMod(E, I.StrMod(i, decs)) =
	let
	    val s     = Inf.empty()
	    val decs' = elabDecs(E, s, decs)
	    val _     = Inf.close s handle Inf.Unclosed lnt =>
			    error(i, E.StrModUnclosed lnt)
	    val j     = Inf.inSig s
	in
	    ( j, O.StrMod(infInfo(i,j), decs') )
	end

      | elabMod(E, I.SelMod(i, mod, lab)) =
	let
	    val (j1,mod') = elabMod(E, mod)
	    val (l,lab')  = elabLab(E, lab)
	    val  s        = Inf.asSig j1 handle Inf.Interface =>
				error(I.infoMod mod, E.SelModInf j1)
	    val  j        = Inf.lookupMod(s, l)
	in
	    ( j, O.SelMod(infInfo(i,j), mod', lab') )
	end

      | elabMod(E, I.FunMod(i, id, inf, mod)) =
	let
	    val  _        = insertScope E
	    val (j1,inf') = elabGroundInf(E, inf)
	    val  j1'      = Inf.clone j1
	    val  p        = Path.fromLab(Lab.fromName(I.name id))
	    val  _        = Inf.strengthen(p, j1')
	    val  id'      = elabModId_bind(E, p, j1', id)
	    val (j2,mod') = elabMod(E, mod)
	    val  _        = deleteScope E
	    val  j        = Inf.inArrow(p, j1, j2)
	in
	    ( j, O.FunMod(infInfo(i,j), id', inf', mod') )
	end

      | elabMod(E, I.AppMod(i, mod1, mod2)) =
	let
	    val (j1,mod1')  = elabMod(E, mod1)
	    val (j2,mod2')  = elabMod(E, mod2)
	    val (p,j11,j12) = if Inf.isArrow j1 then
				 Inf.asArrow(Inf.instance j1)
			      else
				 error(I.infoMod mod1, E.AppModFunMismatch j1)
(*DEBUG
val _ = (
print "#### Application ####\n\
\#### j_param =\n";
PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j11, 75);
print "\n\
\#### j_arg =\n";
PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j2, 75);
print "\n"
)*)
	    val  p2         = case elabMod_path(E, mod2)
				of SOME(p2,_) => p2
(*DEBUG*)
| NONE => Path.fromLab(Lab.fromString "?arg")(*
				 | NONE       => Path.invent()
*)
	    val  _          = Inf.strengthen(p2, j2)
(*val _ = (
print "#### p_arg = ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p2, 75);
print "\n\
\#### j_arg' =\n";
PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j2, 75);
print "\n"
)*)
	    val  rea        = Inf.match(j2,j11) handle Inf.Mismatch mismatch =>
				  error(i, E.AppModArgMismatch mismatch)
	    val  _          = PathMap.insert(#mod_rea rea, p, p2)
	    val  _          = Inf.realise(rea, j12)
	    val  j          = j12
	in
	    ( j, O.AppMod(infInfo(i,j), mod1', mod2') )
	end

      | elabMod(E, I.AnnMod(i, mod, inf)) =
	let
	    val (j1,mod') = elabMod(E, mod)
	    val (j2,inf') = elabGroundInf(E, inf)
	    val  _        = Inf.match(j1, j2) handle Inf.Mismatch mismatch =>
				error(i, E.AnnModMismatch mismatch)
	    val  j        = j2
	in
	    ( j, O.AnnMod(infInfo(i,j), mod', inf') )
	end

      | elabMod(E, I.UpMod(i, mod, inf)) =
	let
	    val (j1,mod') = elabMod(E, mod)
	    val (j2,inf') = elabGroundInf(E, inf)
	    val  j        = Inf.instance j2	(* opaque *)
	    val  _        = Inf.match(j1, j2) handle Inf.Mismatch mismatch =>
				error(i, E.AnnModMismatch mismatch)
	in
	    ( j, O.UpMod(infInfo(i,j), mod', inf') )
	end

      | elabMod(E, I.LetMod(i, decs, mod)) =
	let
	    val  _       = insertScope E
	    val  s       = Inf.empty()
	    val  decs'   = elabDecs(E, s, decs)
	    val  p       = Path.invent()
(*DEBUG*)
val p = Path.fromLab(Lab.fromString "?let")
	    val  _       = Inf.strengthenSig(Path.invent(), s)
	    val (j,mod') = elabMod(E, mod)
	    val  _       = deleteScope E
	in
	    ( j, O.LetMod(infInfo(i,j), decs', mod') )
	end

      | elabMod(E, I.UnpackMod(i, exp, inf)) =
	let
	    val (t,exp') = elabExp(E, exp)
	    val (j,inf') = elabInf(E, inf)
	    val  j'      = Inf.instance j
	    (*UNFINISHED*)
	in
	    unfinished i "elabMod" "packages";
	    ( j', O.UnpackMod(infInfo(i,j), exp', inf') )
	end


    and elabMod_path(E, I.VarMod(i, I.Id(_, stamp, _))) =
	let
	    val {path=p, inf=j, ...} = lookupMod(E, stamp)
	in
	    SOME (p,j)
	end

      | elabMod_path(E, I.SelMod(_, mod, I.Lab(_, l))) =
	(case elabMod_path(E, mod)
	   of NONE      => NONE
	    | SOME(_,j) =>
	      let
		  val s = Inf.asSig j
		  val l = Lab.fromString l
		  val j = Inf.lookupMod(s, l)
		  val p = Inf.lookupModPath(s, l)
	      in
		  SOME (p,j)
	      end
	)

      | elabMod_path(E, I.AnnMod(_, mod, inf))=
	    elabMod_path(E, mod)

      | elabMod_path _ = NONE


  (* Interfaces *)

    and elabInfId_bind(E, p, j, id as I.Id(i, stamp, name)) =
	let
(*DEBUG
val x=case Name.toString(I.name id) of "?" => "?" | x => x
val _=print("-- insert interface " ^ x ^ "(" ^ Stamp.toString stamp ^ ") =\n")
val _=PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j, 75)
val _=print "\n"
*)
	    (*UNFINISHED: use punning: *)
	    val _ = insertInf(E, stamp, {id=id, path=p, inf=j})
	in
	    O.Id(infInfo(i,j), stamp, name)
	end

    and elabInfId(E, id as I.Id(i, stamp, name)) =
	let
(*DEBUG
val x=case Name.toString(I.name id) of "?" => "?" | x => x
val _=print("-- lookup interface " ^ x ^ "(" ^ Stamp.toString stamp ^ ") =\n")
val _=PrettyPrint.output(TextIO.stdOut, PPInf.ppInf(#inf(lookupInf(E, stamp))), 75)
val _=print "\n"
*)
	    val j = #inf(lookupInf(E, stamp))
	in
	    ( j, O.Id(infInfo(i,j), stamp, name) )
	end

    and elabInfLongid(E, I.ShortId(i, id)) =
	let
	    val (j,id') = elabInfId(E, id)
	in
	    ( j, O.ShortId(infInfo(i,j), id') )
	end

      | elabInfLongid(E, I.LongId(i, longid, lab)) =
	let
	    val (s,longid') = elabModLongid_path(E, longid)
	    val (l,lab')    = elabLab(E, lab)
	    val  j          = Inf.lookupInf(s, l)
	in
	    ( j, O.LongId(infInfo(i,j), longid', lab') )
	end


    and elabGroundInf(E, inf) =
	let
	    val jinf' as (j,_) = elabInf(E, inf)
	    val k              = Inf.kind j
	in
	    if Inf.isGround k then
		jinf'
	    else
		error(I.infoInf inf, E.GroundInfKind(k))
	end


    and elabInf(E, I.TopInf(i)) =
	let
	    val j = Inf.inTop()
	in
	    ( j, O.TopInf(infInfo(i,j)) )
	end

      | elabInf(E, I.ConInf(i, longid)) =
	let
	    val (j,longid') = elabInfLongid(E, longid)
	    val  j'         = Inf.instance j
	in
	    ( j', O.ConInf(infInfo(i,j'), longid') )
	end

      | elabInf(E, I.SigInf(i, specs)) =
	let
	    val s      = Inf.empty()
	    val specs' = elabSpecs(E, s, specs)
	    val j      = Inf.inSig s
	in
	    ( j, O.SigInf(infInfo(i,j), specs') )
	end

      | elabInf(E, I.FunInf(i, id, inf1, inf2)) =
	let
	    val  _         = insertScope E
	    val (j1,inf1') = elabGroundInf(E, inf1)
	    val  j1'       = Inf.clone j1
	    val  p         = Path.fromLab(Lab.fromName(I.name id))
	    val  _         = Inf.strengthen(p, j1')
	    (* UNFINISHED: revert renaming of paths somehow *)
	    val  id'       = elabModId_bind(E, p, j1', id)
	    val (j2,inf2') = elabInf(E, inf2)
	    val  _         = deleteScope E
	    val  j         = Inf.inLambda(p, j1, j2)
	in
	    ( j, O.FunInf(infInfo(i,j), id', inf1', inf2') )
	end

      | elabInf(E, I.AppInf(i, inf, mod)) =
	let
	    val (j1,inf') = elabInf(E, inf)
	    val (j2,mod') = elabMod(E, mod)
	(*UNFINISHED*)
	    val j = j1
	in
	    unfinished i "elabMod" "interface application";
	    ( j, O.AppInf(infInfo(i,j), inf', mod') )
	end

      | elabInf(E, I.CompInf(i, inf1, inf2)) =
	let
	    val (j1,inf1') = elabGroundInf(E, inf1)
	    val (j2,inf2') = elabGroundInf(E, inf2)
(*DEBUG
val _ = (
print "#### Intersection ####\n\
\#### j1 =\n";
PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j1, 75);
print "\n\
\#### j2 =\n";
PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j2, 75);
print "\n"
)*)
	    val  j         = Inf.intersect(j1,j2) handle Inf.Mismatch mismatch=>
				error(i, E.CompInfMismatch mismatch)
(*val _ = (
print "#### j =\n";
PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j, 75);
print "\n\
\#### End Intersection ####\n"
)*)
	in
	    ( j, O.CompInf(infInfo(i,j), inf1', inf2') )
	end

      | elabInf(E, I.ArrInf(i, id, inf1, inf2)) =
	let
	    val  _         = insertScope E
	    val (j1,inf1') = elabGroundInf(E, inf1)
	    val  j1'       = Inf.clone j1
	    val  p         = Path.fromLab(Lab.fromName(I.name id))
	    val  _         = Inf.strengthen(p, j1')
	    val  id'       = elabModId_bind(E, p, j1', id)
	    val (j2,inf2') = elabGroundInf(E, inf2)
	    val  _         = deleteScope E
	    val  j         = Inf.inArrow(p, j1, j2)
	in
	    ( j, O.ArrInf(infInfo(i,j), id', inf1', inf2') )
	end

      | elabInf(E, I.SingInf(i, mod)) =
	let
	    val (j,mod') = elabMod(E, mod)
(*DEBUG*)
val _ = Inf.strengthen(Path.fromLab(Lab.fromString "?singleton"), j)
	    val  _       = Inf.strengthen(Path.invent(), j)
(*DEBUG
val _ = (
print "#### Singleton ####\n\
\#### j =\n";
PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j, 75);
print "\n"
)*)
	    val  j'      = Inf.singleton j
(*val _ = (
print "#### j' =\n";
PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j', 75);
print "\n\
\#### End Singleton ####\n"
)*)
	in
	    ( j', O.SingInf(infInfo(i,j'), mod') )
	end

      | elabInf(E, I.AbsInf(i)) =
	    raise Crash.Crash "Elab.elabInf: AbsInf"


    and elabInfRep(E, p, buildKind, I.AbsInf(i)) =
	let
	    val c = (buildKind(Inf.inGround()), p)
	    val j = Inf.inCon c
	in
	    ( j, true, O.AbsInf(infInfo(i,j)) )
	end

      | elabInfRep(E, p', buildKind, I.FunInf(i, id, inf1, inf2)) =
	let
	    val  _             = insertScope E
	    val (j1,inf1')     = elabGroundInf(E, inf1)
	    val  j1'           = Inf.clone j1
	    val  p             = Path.fromLab(Lab.fromName(I.name id))
	    val  _             = Inf.strengthen(p, j1')
	    val  id'           = elabModId_bind(E, p, j1', id)
	    val (j2,gen,inf2') = elabInfRep(E, p',
				     fn k => Inf.inDependent(p,j1,buildKind k),
				     inf2)
	    val  _             = deleteScope E
	    val  j             = Inf.inLambda(p, j1, j2)
	in
	    ( j, gen, O.FunInf(infInfo(i,j), id', inf1', inf2') )
	end

      | elabInfRep(E, p, buildKind, inf) =
	let
	    val (j,inf') = elabInf(E, inf)
	in
	    ( j, false, inf' )
	end


  (* Declarations *)

    and elabDec(E, s, vars, I.ValDec(i, pat, exp)) =
	let
	    val  _        = insertScope E
	    val  _        = Type.enterLevel()
	    val  _        = enterVars(E, vars)
	    val  _        = insertScope E
	    val (t2,exp') = elabExp(E, exp)
	    val  _        = deleteScope E
	    val (t1,pat') = elabPat(E, s, pat)
	    val  _        = Type.exitLevel()
	    val  E'       = splitScope E
	    val  _        = Type.unify(t1,t2) handle Type.Unify(t3,t4) =>
				error(i, E.ValDecUnify(t1, t2, t3, t4))
	    (* UNFINISHED: if pat = x and exp = y then equate x to y *)
	    val  _        = appVals (generaliseVal
					(E, s, SOME NONE, isValue exp)) E'
	in
	    O.ValDec(nonInfo(i), pat', exp')
	end

      | elabDec(E, s, vars, I.ConDec(i, con, typ)) =
	let
	    val  _          = insertScope E
	    val  _          = Type.enterLevel()
	    val  _          = enterVars(E, vars)
	    val (t,typ')    = elabStarTyp(E, typ)
	    val (l,ts,con') = elabConRep(E, s, t, con)
	    val  _          = Type.exitLevel()
	    val  E'         = splitScope E
	    val  d          = case typ
				of I.SingTyp(_, longid) =>
					SOME(elabValLongid_path(E, longid))
				 | _ => NONE
	    val  _          = appVals (generaliseVal (E, s, SOME d, true)) E'
	in
	    O.ConDec(nonInfo(i), con', typ')
	end

      | elabDec(E, s, vars, I.TypDec(i, id, typ)) =
	let
	    val  p       = Inf.newTyp(s, Lab.fromName(I.name id))
	    val (t,typ') = elabTyp(E, typ)
	    val  id'     = elabTypId_bind(E, p, t, Type.CLOSED, id)
	    val  _       = Inf.extendTyp(s, p, Type.kind t, Type.CLOSED, SOME t)
(*DEBUG
val x=case Name.toString(I.name id) of "?" => "?" ^ Stamp.toString(I.stamp id) | x => x
val _=print("type " ^ x ^ " = ")
val _=PrettyPrint.output(TextIO.stdOut, PPType.ppTyp t, 60)
val _=print "\n"
*)
	in
	    O.TypDec(nonInfo(i), id', typ')
	end

      | elabDec(E, s, vars, I.DatDec(i, id, typ)) =
	let
	    val  p           = Inf.newTyp(s, Lab.fromName(I.name id))
	    val  _           = insertScope E
	    val  _           = Type.enterLevel()
	    val  k           = elabTypKind(E, typ)
	    val  t0          = Type.unknown k
	    val (t,_,w,typ') = elabTypRep(E,s, p, t0, fn t'=>t', fn k'=>k', typ)
	    val  _           = Type.unify(t, t0)
	    val  _           = Type.exitLevel()
	    val  E'          = splitScope E
(*DEBUG
val x= case Name.toString(I.name id) of "?" => "?" ^ Stamp.toString(I.stamp id) | x => x
val _= print("datatype " ^ x ^ " = ")
val _=PrettyPrint.output(TextIO.stdOut, PPType.ppTyp t, 60)
val _=print "\n"
*)
	    val  id'         = elabTypId_bind(E, p, t, w, id)
	    val  _           = Inf.extendTyp(s, p, k, w, SOME t)
	    val  _           = appVals (generaliseVal (E,s, SOME NONE, true)) E'
	in
	    O.DatDec(nonInfo(i), id', typ')
	end

      | elabDec(E, s, vars, I.ModDec(i, id, mod)) =
	let
	    val  p       = Inf.newMod(s, Lab.fromName(I.name id))
	    val (j,mod') = elabMod(E, mod)
	    val  _       = Inf.strengthen(p, j)
	    val  p'      = case elabMod_path(E, mod)
			     of SOME (p',_) => p'
			      | NONE        => p
	    val  id'     = elabModId_bind(E, p', j, id)
	    val  _       = Inf.extendMod(s, p, j, SOME p')
	in
	    O.ModDec(nonInfo(i), id', mod')
	end

      | elabDec(E, s, vars, I.InfDec(i, id, inf)) =
	let
	    val  p         = Inf.newInf(s, Lab.fromName(I.name id))
	    val (j,_,inf') = elabInfRep(E, p, fn k'=>k', inf)
	    val  k         = Inf.kind j
	    val  id'       = elabInfId_bind(E, p, j, id)
	    val  _         = Inf.extendInf(s, p, k, SOME j)
	in
	    O.InfDec(nonInfo(i), id', inf')
	end

      | elabDec(E, s, vars, I.VarDec(i, id, dec)) =
	let
	    val id'  = elabVarId_bind'(E, id)
	    val dec' = elabDec(E, s, id::vars, dec)
	in
	    O.VarDec(nonInfo(i), id', dec')
	end

      | elabDec(E, s, vars, I.RecDec(i, decs)) =
	let
	    val _      = insertScope E
	    val _      = Type.enterLevel()
	    val _      = enterVars(E, vars)
	    val tpats' = elabLHSRecDecs(E, s, decs)
	    val decs'  = elabRHSRecDecs(E, s, ref tpats', decs)
	    val _      = Type.exitLevel()
	    val E'     = splitScope E
	    (* ASSUME that only ValDec and DatDec are under RecDec *)
	    (* ASSUME that recursive ValDecs are never expansive *)
	    (* ASSUME that recursive ValDecs are never equatable *)
	    val _      = appTyps (fn(x,entry) => insertTyp(E,x,entry)) E'
	    val _      = appVals (generaliseVal (E, s, SOME NONE, true)) E'
	in
	    O.RecDec(nonInfo(i), decs')
	end

      | elabDec(E, s, vars, I.LocalDec(i, decs)) =
	let
	    val s'    = Inf.empty()
	    val decs' = elabDecs(E, s', decs)
	    val p     = Path.invent()
(*DEBUG*)
val p = Path.fromLab(Lab.fromString "?local")
	    val _     = Inf.strengthenSig(p, s')
	in
	    O.LocalDec(nonInfo(i), decs')
	end


    and enterVars(E, vars) =
	List.app (fn id as I.Id(_, stamp, name) =>
		  (*UNFINISHED: use punning: *)
		  insertVar(E, stamp, {id=id, var = Type.var(Type.STAR)})) vars

    and generaliseVal (E, s, poo, isPoly) (x, {id, path=p, typ=t, sort=w}) =
	let
	    val t' = if isPoly then Type.close t
			       else (Type.lift t ; t) handle Type.Lift a =>
				   error(I.infoId id, E.ValDecLift(id, a))
	    val d  = Option.map (fn po => Option.getOpt(po, p)) poo
	in
	    (*UNFINISHED: use record update: *)
	    (*insertVal(E, x, {entry where typ=t'}));*)
	    insertVal(E, x, {id=id, path=p, typ=t', sort=w});
	    Inf.extendVal(s, p, t', w, d)
(*DEBUG
;let val x= case Name.toString(I.name id) of "?" => "?" ^ Stamp.toString x | x => x
in print("val " ^ x ^ " : ") end;
PrettyPrint.output(TextIO.stdOut, PPType.ppTyp t', 60);
print(if w = Inf.CONSTRUCTOR then " (* constructor *)\n" else if isPoly then "\n" else " (* not generalised *)\n")
"*)
	end


    and elabDecs(E, s, decs) = List.map (fn dec => elabDec(E, s, [], dec)) decs


  (* Recursive declarations *)

    and elabLHSRecDecs(E, s, decs) =
	List.foldr (fn(dec,xs) => elabLHSRecDec(E,s,dec) @ xs) [] decs

    and elabLHSRecDec(E, s, I.ValDec(i, pat, exp)) =
	    [elabPat(E, s, pat)]

      | elabLHSRecDec(E, s, I.DatDec(i, id, typ)) =
	let
	    val p = Inf.newTyp(s, Lab.fromName(I.name id))
	    val k = elabTypKind(E, typ)
	    val t = Type.inRec(Type.unknown k)
	    (* ASSUME that typ does not contain ExtTyp *)
	    val _ = elabTypId_bind(E, p, t, Type.CLOSED, id)
	in
	    []
	end

      | elabLHSRecDec(E, s, I.RecDec(i, decs)) =
	    elabLHSRecDecs(E, s, decs)

      | elabLHSRecDec(E, s, _) = raise Crash.Crash "elabLHSRecDec"


    and elabRHSRecDecs(E, s, rtpats', decs) =
	    List.map (fn dec => elabRHSRecDec(E, s, rtpats', dec)) decs

    and elabRHSRecDec(E, s, r as ref((t1,pat')::tpats'), I.ValDec(i, pat, exp))=
	let
	    val  _        = insertScope E
	    val (t2,exp') = elabExp(E, exp)
	    val  _        = deleteScope E
	    val  _        = r := tpats'
	    val  _        = Type.unify(t1,t2) handle Type.Unify(t3,t4) =>
				error(i, E.ValDecUnify(t1, t2, t3, t4))
	in
	    O.ValDec(nonInfo(i), pat', exp')
	end

      | elabRHSRecDec(E, s, rtpats', I.DatDec(i, id, typ)) =
	let
	    val (t0,p,id')   = elabTypId(E, id)
	    val (t,_,w,typ') = elabTypRep(E,s, p, t0, fn t'=>t', fn k'=>k', typ)
	    val  _           = Type.unify(t, t0)
	    val  _           = Inf.extendTyp(s, p, Type.kind t, w, SOME t)
(*DEBUG
val x= case Name.toString(I.name id) of "?" => "?" ^ Stamp.toString(I.stamp id) | x => x
val _= print("datatype " ^ x ^ " = ")
val _=PrettyPrint.output(TextIO.stdOut, PPType.ppTyp t, 60)
val _=print "\n"
*)
	in
	    O.DatDec(nonInfo(i), id', typ')
	end

      | elabRHSRecDec(E, s, rtpats', I.RecDec(i, decs)) =
	let
	    val dec' = elabRHSRecDecs(E, s, rtpats', decs)
	in
	    O.RecDec(nonInfo(i), dec')
	end

      | elabRHSRecDec(E, s, rtpats', dec) =
	    raise Crash.Crash "elabRHSRecDec"



  (* Specifications *)

    and elabSpec(E, s, vars, I.ValSpec(i, id, typ)) =
	let
	    val (t0,p,id') = elabValId_bind(E, s, Inf.VALUE, id)
	    val (t,typ')   = elabStarTyp(E, typ)
	    val  _         = Type.unify(t,t0)
	    val  _         = Inf.extendVal(s, p, t, Inf.VALUE, NONE)
	in
	    O.ValSpec(nonInfo(i), id', typ')
	end

      | elabSpec(E, s, vars, I.ConSpec(i, con, typ)) =
	let
	    val  _          = insertScope E
	    val  _          = Type.enterLevel()
	    val  _          = enterVars(E, vars)
	    val (t,typ')    = elabStarTyp(E, typ)
	    val (l,ts,con') = elabConRep(E, s, t, con)
	    val  _          = Type.exitLevel()
	    val  E'         = splitScope E
	    val  od         = case typ
				of I.SingTyp(_, longid) =>
					SOME(SOME(elabValLongid_path(E,longid)))
				 | _ => NONE
	    val  _          = appVals (generaliseVal (E, s, od, true)) E'
	in
	    O.ConSpec(nonInfo(i), con', typ')
	end

      | elabSpec(E, s, vars, I.TypSpec(i, id, typ)) =
	let
	    val  p       = Inf.newTyp(s, Lab.fromName(I.name id))
	    val (t,typ') = elabTyp(E, typ)
	    val  id'     = elabTypId_bind(E, p, t, Type.CLOSED, id)
	    val  _       = Inf.extendTyp(s, p, Type.kind t, Type.CLOSED, SOME t)
	in
	    O.TypSpec(nonInfo(i), id', typ')
	end

      | elabSpec(E, s, vars, I.DatSpec(i, id, typ)) =
	let
	    val  p             = Inf.newTyp(s, Lab.fromName(I.name id))
	    val  _             = insertScope E
	    val  _             = Type.enterLevel()
	    val  k             = elabTypKind(E, typ)
	    val  t0            = Type.unknown k
	    val (t,gen,w,typ') = elabTypRep(E, s, p, t0,
					    fn t'=>t', fn k'=>k', typ)
	    val  _             = Type.unify(t, t0)
	    val  _             = Type.exitLevel()
	    val  E'            = splitScope E
	    val  id'           = elabTypId_bind(E, p, t, w, id)
	    val  _             = Inf.extendTyp(s, p, k, w,
					       if gen then NONE else SOME t)
	    val  _             = appVals (generaliseVal (E, s, NONE, true)) E'
	in
	    O.DatSpec(nonInfo(i), id', typ')
	end

      | elabSpec(E, s, vars, I.ModSpec(i, id, inf)) =
	let
	    val  p       = Inf.newMod(s, Lab.fromName(I.name id))
	    val (j,inf') = elabGroundInf(E, inf)
	    val  j'      = Inf.clone j
(*DEBUG
val _ = (
print "#### Mod Spec ####\n\
\#### j =\n";
PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j, 75);
print "\n\
\#### j' =\n";
PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j', 75);
print "\n"
)*)
	    val  _       = Inf.strengthen(p, j')
(*val _ = (
print "#### j =\n";
PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j, 75);
print "\n\
\#### j' =\n";
PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j', 75);
print "\n\
\#### End Mod Spec ####\n"
)*)
	    (* UNFINISHED: revert renaming of paths somehow *)
	    val (p',d)   = case inf
			     of I.SingInf(i', mod) =>
				(case elabMod_path(E, mod)
				   of NONE        => error(i', E.SingInfPath)
				    | SOME (p',_) => (p', SOME p')
				)
			      | _ => (p, NONE)
	    val  id'     = elabModId_bind(E, p', j', id)
	    val  _       = Inf.extendMod(s, p, j, d)
	in
	    O.ModSpec(nonInfo(i), id', inf')
	end

      | elabSpec(E, s, vars, I.InfSpec(i, id, inf)) =
	let
	    val  p           = Inf.newInf(s, Lab.fromName(I.name id))
	    val (j,gen,inf') = elabInfRep(E, p, fn k'=>k', inf)
	    val  k           = Inf.kind j
	    val  id'         = elabInfId_bind(E, p, j, id)
	    val  _           = Inf.extendInf(s, p, k,
					     if gen then NONE else SOME j)
	in
	    O.InfSpec(nonInfo(i), id', inf')
	end

      | elabSpec(E, s, vars, I.VarSpec(i, id, spec)) =
	let
	    val id'   = elabVarId_bind'(E, id)
	    val spec' = elabSpec(E, s, id::vars, spec)
	in
	    O.VarSpec(nonInfo(i), id', spec')
	end

      | elabSpec(E, s, vars, I.RecSpec(i, specs)) =
	let
	    val _      = insertScope E
	    val _      = Type.enterLevel()
	    val _      = elabLHSRecSpecs(E, s, specs)
	    val specs' = elabRHSRecSpecs(E, s, specs)
	    val _      = Type.exitLevel()
	    val E'     = splitScope E
	    (* ASSUME that only DatSpec is under RecSpec *)
	    val _      = appTyps (fn(x,entry) => insertTyp(E,x,entry)) E'
	    val _      = appVals (generaliseVal (E, s, NONE, true)) E'
	in
	    O.RecSpec(nonInfo(i), specs')
	end

      | elabSpec(E, s, vars, I.LocalSpec(i, specs)) =
	let
	    val s'     = Inf.empty()
	    val specs' = elabSpecs(E, s, specs)
	    val p      = Path.invent()
(*DEBUG*)
val p = Path.fromLab(Lab.fromString "?localSpec")
	    val _      = Inf.strengthenSig(p, s')
	in
	    O.LocalSpec(nonInfo(i), specs')
	end

      | elabSpec(E, s, vars, I.ExtSpec(i, inf)) =
	let
	    val (j,inf') = elabGroundInf(E, inf)
	(*UNFINISHED: insert stuff*)
	in
	    unfinished i "elabSpec" "signature extension";
	    O.ExtSpec(nonInfo(i), inf')
	end


    and elabSpecs(E, s, specs) =
	List.map (fn spec => elabSpec(E, s, [], spec)) specs


  (* Recursive specifications *)

    and elabLHSRecSpecs(E, s, specs) =
	List.app (fn spec => elabLHSRecSpec(E,s,spec)) specs

    and elabLHSRecSpec(E, s, I.DatSpec(i, id, typ)) =
	let
	    val p = Inf.newTyp(s, Lab.fromName(I.name id))
	    val k = elabTypKind(E, typ)
	    val t = Type.inRec(Type.unknown k)
	    (* ASSUME that typ does not contain ExtTyp *)
	    val _ = elabTypId_bind(E, p, t, Type.CLOSED, id)
	in
	    ()
	end

      | elabLHSRecSpec(E, s, I.RecSpec(i, specs)) =
	    elabLHSRecSpecs(E, s, specs)

      | elabLHSRecSpec(E, s, _) = ()


    and elabRHSRecSpecs(E, s, specs) =
	List.map (fn spec => elabRHSRecSpec(E, s, spec)) specs

    and elabRHSRecSpec(E, s, I.RecSpec(i, specs)) =
	let
	    val spec' = elabRHSRecSpecs(E, s, specs)
	in
	    O.RecSpec(nonInfo(i), spec')
	end

      | elabRHSRecSpec(E, s, I.DatSpec(i, id, typ)) =
	let
	    val (t0,p,id')     = elabTypId(E, id)
	    val (t,gen,w,typ') = elabTypRep(E, s, p, t0,
					    fn t'=>t', fn k'=>k', typ)
	    val  _             = Type.unify(t, t0)
	    val  _             = Inf.extendTyp(s, p, Type.kind t, w,
					       if gen then NONE else SOME t)
	in
	    O.DatSpec(nonInfo(i), id', typ')
	end

      | elabRHSRecSpec(E, s, spec) =
	    elabSpec(E, s, [], spec)



  (* Components *)

    fun elabComp(E, I.Comp(i, imps, decs)) =
	let
	    val imps' = elabImps(E, imps)
	    val s     = Inf.empty()
	    val decs' = elabDecs(E, s, decs)
	    val _     = Inf.close s handle Inf.Unclosed lnt =>
			    error(i, E.CompUnclosed lnt)
(*DEBUG*)
val _ = print "Component signature:\n"
val _ = PrettyPrint.output(TextIO.stdOut, PPInf.ppSig s, 78)
val _ = print "\n"
	in
	    O.Comp(nonInfo(i), imps', decs')
	end

    and elabImp(E, I.Imp(i, specs, url)) =
	let
	    val specs' = elabSpecs(E, Inf.empty(), specs)
	in
	    O.Imp(nonInfo(i), specs', url)
	end

    and elabImps(E, imps) = List.map (fn imp => elabImp(E, imp)) imps



    fun elab E component =
	let
	    val _         = insertScope E
	    val impsdecs' = elabComp(E, component)
	    val _         = mergeScope E
	in
	    impsdecs'
	end
	handle Error.Error x =>
	    ( deleteScope E
	    ; Type.resetLevel()
	    ; raise Error.Error x
	    )

  end
(* src # 73 *)
signature TRANSLATION_PHASE =
  sig

    structure I : ABSTRACT_GRAMMAR     = AbstractGrammar
    structure O : INTERMEDIATE_GRAMMAR = IntermediateGrammar

    val translate :	I.component -> O.component

  end
(* src # 74 *)
(* Untyped translation *)

structure TranslationPhase :> TRANSLATION_PHASE =
  struct

    structure I = AbstractGrammar
    structure O = IntermediateGrammar


    (* Create fields for all structures and values in an environment *)

    fun idToField(x' as O.Id(i,_,O.ExId s)) =
	    O.Field(i, O.Lab(i,s), O.VarExp(i, O.ShortId(i, x')))

      | idToField _ = raise Crash.Crash"TranslationPhase.idToField: internal id"

    fun idToDec(x' as O.Id(i, z, O.ExId s), y) =
	    O.ValDec(i, O.VarPat(i, O.Id(i, z, O.ExId s)),
			O.AppExp(i, O.SelExp(i, O.Lab(i,s)), O.VarExp(i,y)))

      | idToDec _ = raise Crash.Crash "TranslationPhase.idToDec: internal id"


    (* Curry-convert expressions *)

    fun funExp(i,    [],     exp') = exp'
      | funExp(i, id'::ids', exp') = O.FunExp(i, id', funExp(i, ids', exp'))

    fun curryExp(i, (0|1), exp') = exp'
      | curryExp(i,   k,   exp') =
	let
	    val ids'  = List.tabulate(k, fn _ => O.Id(i,Stamp.new(),O.InId))
	    val exps' = List.map (fn id' => O.VarExp(i, O.ShortId(i,id'))) ids'
	in
	    funExp(i, ids', O.AppExp(i, exp', O.TupExp(i, exps')))
	end


    (* Literals *)

    fun trLit(I.WordLit w)		= O.WordLit w
      | trLit(I.IntLit n)		= O.IntLit n
      | trLit(I.CharLit c)		= O.CharLit c
      | trLit(I.StringLit s)		= O.StringLit s
(*      | trLit(I.RealLit x)		= O.RealLit x
UNFINISHED: obsolete after bootstrapping:
*)      | trLit(I.RealLit x)		= O.RealLit(LargeReal.toString x)


    (* Identifiers *)

    fun trName  s			= s
    fun trName' s			= "$" ^ s

    fun trLab(I.Lab(i,s))		= O.Lab(i, trName  s)
    fun trLab'(I.Lab(i,s))		= O.Lab(i, trName' s)

    fun trId(I.Id(i,z,I.InId))		= O.Id(i, z, O.InId)
      | trId(I.Id(i,z,I.ExId s))	= O.Id(i, z, O.ExId(trName s))

    fun trId'(I.Id(i,z,I.InId))		= O.Id(i, z, O.InId)
      | trId'(I.Id(i,z,I.ExId s))	= O.Id(i, z, O.ExId(trName' s))

    fun trLongid'(I.ShortId(i,x))	= O.ShortId(i, trId' x)
      | trLongid'(I.LongId(i,y,a))	= O.LongId(i, trLongid' y, trLab' a)

    fun trLongid(I.ShortId(i,x))	= O.ShortId(i, trId x)
      | trLongid(I.LongId(i,y,a))	= O.LongId(i, trLongid' y, trLab a)


    (* Extract bound ids from declarations. *)

    fun idsId trId xs' x =
	case trId x
	  of x' as O.Id(_,_,O.ExId s') => StringMap.insert(xs', s', x')
	   | _                         => ()

    fun idsRow    idsZ xs' (I.Row(i,fs,_))   = idsFields idsZ xs' fs
    and idsField  idsZ xs' (I.Field(i,a,z))  = idsZ xs' z
    and idsFields idsZ xs' 		     = List.app(idsField idsZ xs')

    fun idsDec xs' (I.ValDec(i,p,e))	= idsPat xs' p
      | idsDec xs' (I.ConDec(i,c,t))	= idsCon xs' c
      | idsDec xs' (I.TypDec(i,x,t))	= ()
      | idsDec xs' (I.DatDec(i,x,t))	= idsTyp xs' t
      | idsDec xs' (I.ModDec(i,x,m))	= idsId trId' xs' x
      | idsDec xs' (I.InfDec(i,x,j))	= ()
      | idsDec xs' (I.VarDec(i,x,d))	= idsDec xs' d
      | idsDec xs' (I.RecDec(i,ds))	= idsDecs xs' ds
      | idsDec xs' (I.LocalDec(i,ds))	= ()
    and idsDecs xs'			= List.app(idsDec xs')

    and idsPat xs' (I.JokPat(i))	= ()
      | idsPat xs' (I.LitPat(i,l))	= ()
      | idsPat xs' (I.VarPat(i,x))	= idsId trId xs' x
      | idsPat xs' (I.ConPat(i,y,ps))	= idsPats xs' ps
      | idsPat xs' (I.RefPat(i,p))	= idsPat xs' p
      | idsPat xs' (I.TupPat(i,ps))	= idsPats xs' ps
      | idsPat xs' (I.RowPat(i,r))	= idsRow idsPat xs' r
      | idsPat xs' (I.VecPat(i,ps))	= idsPats xs' ps
      | idsPat xs' (I.AsPat(i,p1,p2))	= ( idsPat xs' p1 ; idsPat xs' p2 )
      | idsPat xs' (I.AltPat(i,ps))	= idsPats xs' ps
      | idsPat xs' (I.NegPat(i,p))	= idsPat xs' p
      | idsPat xs' (I.GuardPat(i,p,e))	= idsPat xs' p
      | idsPat xs' (I.AnnPat(i,p,t))	= idsPat xs' p
      | idsPat xs' (I.WithPat(i,p,ds))	= ( idsPat xs' p ; idsDecs xs' ds )
    and idsPats xs'			= List.app(idsPat xs')

    and idsCon xs' (I.Con(i,x,ts))	= idsId trId xs' x
    and idsCons xs'			= List.app(idsCon xs')

    and idsTyp xs' (I.AbsTyp(i))	= ()
      | idsTyp xs' (I.VarTyp(i,x))	= ()
      | idsTyp xs' (I.ConTyp(i,y))	= ()
      | idsTyp xs' (I.FunTyp(i,x,t))	= idsTyp xs' t
      | idsTyp xs' (I.AppTyp(i,t1,t2))	= ( idsTyp xs' t1 ; idsTyp xs' t2 )
      | idsTyp xs' (I.RefTyp(i,t))	= idsTyp xs' t
      | idsTyp xs' (I.TupTyp(i,ts))	= idsTyps xs' ts
      | idsTyp xs' (I.RowTyp(i,r))	= idsRow idsTyp xs' r
      | idsTyp xs' (I.ArrTyp(i,t1,t2))	= ( idsTyp xs' t1 ; idsTyp xs' t2 )
      | idsTyp xs' (I.SumTyp(i,cs))	= idsCons xs' cs
      | idsTyp xs' (I.ExtTyp(i))	= ()
      | idsTyp xs' (I.AllTyp(i,x,t))	= idsTyp xs' t
      | idsTyp xs' (I.ExTyp(i,x,t))	= idsTyp xs' t
      | idsTyp xs' (I.PackTyp(i,j))	= ()
      | idsTyp xs' (I.SingTyp(i,y))	= ()
    and idsTyps xs'			= List.app(idsTyp xs')

    fun ids ds				= let val xs' = StringMap.new() in
					      idsDecs xs' ds ;
					      StringMap.fold op:: [] xs'
					  end


    (* Expressions *)

    fun trExp(I.LitExp(i,l))		= O.LitExp(i, trLit l)
      | trExp(I.PrimExp(i,s,t))		= O.PrimExp(i, s)
      | trExp(I.VarExp(i,y))		= O.VarExp(i, trLongid y)
      | trExp(I.ConExp(i,k,y))		= let val y' = trLongid y in
					      curryExp(i,k,O.ConExp(i,y',k>0))
					  end
      | trExp(I.RefExp(i))		= O.RefExp(i)
      | trExp(I.TupExp(i,es))		= O.TupExp(i, trExps es)
      | trExp(I.RowExp(i,r))		= O.RowExp(i, trExpRow r)
      | trExp(I.SelExp(i,a))		= O.SelExp(i, trLab a)
      | trExp(I.VecExp(i,es))		= O.VecExp(i, trExps es)
      | trExp(I.FunExp(i,x,e))		= O.FunExp(i, trId x, trExp e)
      | trExp(I.AppExp(i,e1,e2))	= O.AppExp(i, trExp e1, trExp e2)
      | trExp(I.CompExp(i,e1,e2))	= O.AdjExp(i, trExp e2, trExp e2)
      | trExp(I.AndExp(i,e1,e2))	= O.AndExp(i, trExp e1, trExp e2)
      | trExp(I.OrExp(i,e1,e2))		= O.OrExp(i, trExp e1, trExp e2)
      | trExp(I.IfExp(i,e1,e2,e3))	= O.IfExp(i, trExp e1, trExp e2, trExp e3)
      | trExp(I.WhileExp(i,e1,e2))	= O.WhileExp(i, trExp e1, trExp e2)
      | trExp(I.SeqExp(i,es))		= O.SeqExp(i, trExps es)
      | trExp(I.CaseExp(i,e,ms))	= O.CaseExp(i, trExp e, trMatchs ms)
      | trExp(I.RaiseExp(i,e))		= O.RaiseExp(i, trExp e)
      | trExp(I.HandleExp(i,e,ms))	= O.HandleExp(i, trExp e, trMatchs ms)
      | trExp(I.AnnExp(i,e,t))		= trExp e
      | trExp(I.LetExp(i,ds,e))		= O.LetExp(i, trDecs ds, trExp e)
      | trExp(I.PackExp(i,m))		= trMod m

    and trExps es			= List.map trExp es

    and trExpRow(I.Row(i,fs,_))		= trExpFields fs
    and trExpField(I.Field(i,a,e))	= O.Field(i, trLab a, trExp e)
    and trExpFields fs			= List.map trExpField fs


    (* Matches and Patterns *)

    and trMatch(I.Match(i,p,e))		= O.Match(i, trPat p, trExp e)
    and trMatchs ms			= List.map trMatch ms

    and trPat(I.JokPat(i))		= O.WildPat(i)
      | trPat(I.LitPat(i,l))		= O.LitPat(i, trLit l)
      | trPat(I.VarPat(i,x))		= O.VarPat(i, trId x)
      | trPat(I.ConPat(i,y,ps))		= O.ConPat(i, trLongid y, trArgPats ps)
      | trPat(I.RefPat(i,p))		= O.RefPat(i, trPat p)
      | trPat(I.TupPat(i,ps))		= O.TupPat(i, trPats ps)
      | trPat(I.RowPat(i,r))		= let val (fs',b') = trPatRow r in
					      O.RowPat(i, fs', b')
					  end
      | trPat(I.VecPat(i,ps))		= O.VecPat(i, trPats ps)
      | trPat(I.AsPat(i,p1,p2))		= O.AsPat(i, trPat p1, trPat p2)
      | trPat(I.AltPat(i,ps))		= O.AltPat(i, trPats ps)
      | trPat(I.NegPat(i,p))		= O.NegPat(i, trPat p)
      | trPat(I.GuardPat(i,p,e))	= O.GuardPat(i, trPat p, trExp e)
      | trPat(I.AnnPat(i,p,t))		= trPat p
      | trPat(I.WithPat(i,p,ds))	= O.WithPat(i, trPat p, trDecs ds)

    and trPats ps			= List.map trPat ps

    and trArgPats []			= NONE
      | trArgPats[p]			= SOME(trPat p)
      | trArgPats ps			= SOME(O.TupPat(I.infoPat(List.hd ps),
							trPats ps))

    and trPatRow(I.Row(i,fs,b))		= (trPatFields fs, b)
    and trPatField(I.Field(i,a,p))	= O.Field(i, trLab a, trPat p)
    and trPatFields fs			= List.map trPatField fs


    (* Modules *)

    and trMod(I.PrimMod(i,s,j))		= O.PrimExp(i, s)
      | trMod(I.VarMod(i,x))		= let val x' as O.Id(i',_,_)= trId' x in
					      O.VarExp(i, O.ShortId(i', x'))
					  end
      | trMod(I.StrMod(i,ds))		= let val ids' = ids ds
					      val fs'  = List.map idToField ids'
					      val ds'  = trDecs ds in
					      O.LetExp(i, ds', O.RowExp(i, fs'))
					  end
      | trMod(I.SelMod(i,m,a))		= O.AppExp(i, O.SelExp(i, trLab' a),
						      trMod m)
      | trMod(I.FunMod(i,x,j,m))	= O.FunExp(i, trId' x, trMod m)
      | trMod(I.AppMod(i,m1,m2))	= O.AppExp(i, trMod m1, trMod m2)
      | trMod(I.AnnMod(i,m,j))		= trMod m
      | trMod(I.UpMod(i,m,j))		= trMod m
      | trMod(I.LetMod(i,ds,m))		= O.LetExp(i, trDecs ds, trMod m)
      | trMod(I.UnpackMod(i,e,j))	= trExp e



    (* Declarations *)

    and trDec(I.ValDec(i,p,e), ds')	= O.ValDec(i, trPat p, trExp e) :: ds'
      | trDec(I.ConDec(i,c,t), ds')	= (case t
					   of I.SingTyp(_,y) =>
						trEqCon(c,trLongid y,ds')
					    | _ => trNewCon(c,ds')
					  )
      | trDec(I.TypDec(i,x,t), ds')	= ds'
      | trDec(I.DatDec(i,x,t), ds')	= trTyp(t, ds')
      | trDec(I.ModDec(i,x,m), ds')	= let val x' as O.Id(i',_,_)= trId' x in
					      O.ValDec(i, O.VarPat(i',x'),
							  trMod m) :: ds'
					  end
      | trDec(I.InfDec(i,x,j), ds')	= ds'
      | trDec(I.VarDec(i,x,d), ds')	= trDec(d, ds')
      | trDec(I.RecDec(i,ds), ds')	= O.RecDec(i, trDecs ds) :: ds'
      | trDec(I.LocalDec(i,ds), ds')	= trDecs'(ds, ds')

    and trDecs ds			= trDecs'(ds, [])
    and trDecs'(ds, ds')		= List.foldr trDec ds' ds

    and trEqCon(I.Con(i,x,ts), y', ds')	= O.ValDec(i, O.VarPat(i,trId x),
						   O.VarExp(i,y')):: ds'
    and trNewCon(I.Con(i,x,ts), ds')	= O.ValDec(i, O.VarPat(i,trId x),
						   O.NewExp(i, NONE,
						      List.length ts > 0)):: ds'
    and trCon(I.Con(i,x,ts), ds')	= O.ValDec(i,
						O.VarPat(i,trId x),
						O.NewExp(i,
						  SOME(Name.toString(I.name x)),
						  List.length ts > 0)):: ds'
    and trCons(cs, ds')			= List.foldr trCon ds' cs

    and trTyp(I.AbsTyp(i), ds')		= ds'
      | trTyp(I.VarTyp(i,x), ds')	= ds'
      | trTyp(I.ConTyp(i,y), ds')	= ds'
      | trTyp(I.FunTyp(i,x,t), ds')	= trTyp(t, ds')
      | trTyp(I.AppTyp(i,t1,t2), ds')	= trTyp(t1, trTyp(t2, ds'))
      | trTyp(I.RefTyp(i,t), ds')	= trTyp(t, ds')
      | trTyp(I.TupTyp(i,ts), ds')	= trTyps(ts, ds')
      | trTyp(I.RowTyp(i,r), ds')	= trTypRow(r, ds')
      | trTyp(I.ArrTyp(i,t1,t2), ds')	= trTyp(t1, trTyp(t2, ds'))
      | trTyp(I.SumTyp(i,cs), ds')	= trCons(cs, ds')
      | trTyp(I.ExtTyp(i), ds')		= ds'
      | trTyp(I.AllTyp(i,x,t), ds')	= trTyp(t, ds')
      | trTyp(I.ExTyp(i,x,t), ds')	= trTyp(t, ds')
      | trTyp(I.PackTyp(i,j), ds')	= ds'
      | trTyp(I.SingTyp(i,y), ds')	= ds'

    and trTyps(ts, ds')			= List.foldr trTyp ds' ts

    and trTypRow(I.Row(i,fs,b), ds')	= trTypFields(fs, ds')
    and trTypField(I.Field(i,a,t), ds')	= trTyp(t, ds')
    and trTypFields(fs, ds')		= List.foldr trTypField ds' fs


    (* Components *)

    fun trComp(I.Comp(i,is,ds))		=
	let
	    val (xus',ds') = trImps'(is, trDecs ds)
	in
	    ( xus', ids ds, ds' )
	end

    and trImps'(is, ds')		= List.foldr trImp ([],ds') is

    and trImp(I.Imp(i,ss,u),(xus',ds'))	=
	let
	    val x'  = O.Id(i, Stamp.new(), O.InId)
	    val y'  = O.ShortId(i, x')
	    val ds' = trSpecs(ss, y', ds')
	in
	    ( (x',u)::xus', ds' )
	end

    and trSpecs(ss, y, ds')		= List.foldr (trSpec y) ds' ss

    and trSpec y (I.ValSpec(i,x,e),ds')	= idToDec(trId x, y)::ds'
      | trSpec y (I.ConSpec(i,c,t),ds')	= idToDec(trId(I.conToId c), y)::ds'
      | trSpec y (I.TypSpec(i,x,t),ds')	= ds'
      | trSpec y (I.DatSpec(i,x,t),ds')	= trRep(t, y, ds')
      | trSpec y (I.ModSpec(i,x,m),ds')	= idToDec(trId' x, y)::ds'
      | trSpec y (I.InfSpec(i,x,j),ds')	= ds'
      | trSpec y (I.VarSpec(i,x,s),ds') = trSpec y (s, ds')
      | trSpec y (I.RecSpec(i,ss), ds')	= trSpecs(ss, y, ds')
      | trSpec y (I.LocalSpec(i,ss),ds')= ds'
      | trSpec y (I.ExtSpec(i,j),  ds')	=
		raise Crash.Crash "Translation: ExtSpec"

    and trCons'(cs, y, ds')		=
	List.foldr (fn(c as I.Con(i,x,ts), ds') =>
			trEqCon(c, O.LongId(i,y, trLab(I.idToLab x)), ds')
		   ) ds' cs

    and trRep(I.AbsTyp(i), y, ds')	= ds'
      | trRep(I.VarTyp(i,x), y, ds')	= ds'
      | trRep(I.ConTyp(i,y'), y, ds')	= ds'
      | trRep(I.FunTyp(i,x,t), y, ds')	= trRep(t, y, ds')
      | trRep(I.AppTyp(i,t1,t2), y,ds')	= trRep(t1, y, trRep(t2, y, ds'))
      | trRep(I.RefTyp(i,t), y, ds')	= trRep(t, y, ds')
      | trRep(I.TupTyp(i,ts), y, ds')	= trReps(ts, y, ds')
      | trRep(I.RowTyp(i,r), y, ds')	= trRepRow(r, y, ds')
      | trRep(I.ArrTyp(i,t1,t2), y,ds')	= trRep(t1, y, trRep(t2, y, ds'))
      | trRep(I.SumTyp(i,cs), y, ds')	= trCons'(cs, y, ds')
      | trRep(I.ExtTyp(i), y, ds')	= ds'
      | trRep(I.AllTyp(i,x,t), y, ds')	= trRep(t, y, ds')
      | trRep(I.ExTyp(i,x,t), y, ds')	= trRep(t, y, ds')
      | trRep(I.PackTyp(i,j), y, ds')	= ds'
      | trRep(I.SingTyp(i,y'), y, ds')	= ds'

    and trReps(ts, y, ds')		=
	List.foldr (fn(t,ds') => trRep(t,y,ds')) ds' ts

    and trRepRow(I.Row(i,fs,b), y, ds')	= trRepFields(fs, y, ds')
    and trRepField y(I.Field(i,a,t),ds')= trRep(t, y, ds')
    and trRepFields(fs, y, ds')		= List.foldr (trRepField y) ds' fs


    val translate = trComp

  end
(* src # 75 *)
(*
 * Standard ML label identifiers
 *
 * Definition, section 2.4
 *)


signature LAB =
  sig

    eqtype Lab
    type t = Lab

    val fromString:	string       -> Lab
    val fromInt:	int          -> Lab
    val fromLargeInt:	LargeInt.int -> Lab
    val toString:	Lab          -> string

    val equalsNum:	Lab * LargeInt.int -> bool

    val compare:	Lab * Lab -> order

  end
(*DEBUG*) where type Lab = string
(* src # 76 *)
(*
 * Standard ML label identifiers
 *
 * Definition, section 2.4
 *)


structure Lab :> LAB =
  struct

    type Lab = string
    type t   = Lab

    fun fromString s   = s
    fun fromInt n      = Int.toString n
    fun fromLargeInt n = LargeInt.toString n
    fun toString s     = s

    fun compare(s1,s2) =
      case (LargeInt.fromString s1, LargeInt.fromString s2)
	of (SOME n1, SOME n2) => LargeInt.compare(n1,n2)
	 |     _              => String.compare(s1,s2)

    fun equalsNum(s,n) =
      case LargeInt.fromString s
	of SOME n' => n = n'
	 | NONE    => false

  end
(* src # 77 *)
(*
 * Standard ML identifiers
 *
 * Definition, section 2.4
 *
 * Note:
 *   This is a generic signature to represent all kinds of identifiers (except
 *   for labels and tyvars).
 *)


signature ID =
  sig

    eqtype Id
    type t = Id

    val invent:		unit -> Id
    val inventAs:	Id   -> Id

    val fromString:	string -> Id
    val toString:	Id -> string

    val compare:	Id * Id -> order

  end
(*DEBUG*) where type Id = string
(* src # 78 *)
(*
 * Standard ML identifiers
 *
 * Definition, section 2.4
 *
 * Note:
 *   This is a generic functor to represent all kinds of identifiers (except
 *   for labels tyvars).
 *)


functor MakeId(Stamp: STAMP) : (*DEBUG :>*) ID =
  struct

    type Id = string
    type t  = Id

    fun invent()    = "_id" ^ Stamp.toString(Stamp.new())
    fun inventAs id = "_" ^ id ^ Stamp.toString(Stamp.new())

    fun fromString s = s
    fun toString s   = s

    val compare = String.compare

  end
(* src # 79 *)
(*
 * Standard ML basic objects (shared between syntax and semantics)
 *
 * Definition, sections 2.2, 2.4, 3.2, 4.1, 5.1, 6.2, and 7.2
 *
 * Modifications:
 *   Longids are not included since they have been moved to the context-free
 *   grammar.
 *)


local
structure Stamp	= MakeStamp()
in
structure VId	= MakeId(Stamp)
structure TyCon	= MakeId(Stamp)
structure TyVar	= MakeId(Stamp)
structure StrId	= MakeId(Stamp)
structure SigId = MakeId(Stamp)
end
(* src # 80 *)
(*
 * Standard ML special constants
 *
 * Definition, section 2.2
 *
 * Note:
 *   I would like to use WideChar and WideString, but SML/NJ does not
 *   support it.
 *)


signature SCON =    
  sig 

    datatype SCon =
	  INT    of LargeInt.int
	| WORD   of LargeWord.word
	| STRING of WideString.string
	| CHAR   of WideChar.char
	| REAL   of LargeReal.real

    type t = SCon

    val toString: SCon -> string

  end
(* src # 81 *)
(*
 * Standard ML special constants
 *
 * Definition, section 2.2
 *)


structure SCon :> SCON =
  struct

    datatype SCon =
	  INT    of LargeInt.int
	| WORD   of LargeWord.word
	| STRING of WideString.string
	| CHAR   of WideChar.char
	| REAL   of LargeReal.real

    type t = SCon

    fun toString(INT i)    = LargeInt.toString i
      | toString(WORD w)   = "0wx" ^ LargeWord.toString w
      | toString(STRING s) = "\""  ^ WideString.toCString s ^ "\""
      | toString(CHAR c)   = "\"#" ^ WideChar.toCString c   ^ "\""
      | toString(REAL r)   = LargeReal.toString r

  end
(* src # 82 *)
(*
 * Stockhausen input grammar
 *
 * Extensions and modifications to core language:
 *   - unified dec and topdec (i.e. top declarations can appear in let)
 *   - record update expressions
 *   - vector expressions and patterns
 *   - generalized layered patterns
 *   - alternative patterns
 *   - guarded patterns
 *   - negated patterns
 *   - withval patterns
 *   - abstract type declarations
 *   - open datatypes and free construct declarations
 *   - package types and expressions
 *   - removed exception declarations (made into a derived form)
 *   - removed abstype (made into a derived form with local)
 *   - simplified open and fixity declarations to single id (multi ids made DF)
 *   - some hacks to build libraries: primitive value declarations,
 *     overloading declarations, special eqtype declarations and specifications
 *
 * Extensions and modifications to module language:
 *   - components
 *   - unified strdec and topdec
 *   - unified strid and funid
 *   - functor expressions
 *   - removed functor declarations (made into a derived form)
 *   - package elimination
 *   - parameterized signatures
 *   - open datatypes and free constructor specifications
 *   - straightified type specifications (synonyms are kept)
 *   - signature specifications
 *   - definitional value, constructor, and structure specifications
 *   - functor signatures
 *   - top signature
 *   - generalized where
 *   - sharing for signatures
 *   - let for signature expressions
 *   - functor parameters as a separate syntactic class StrPat
 *   - parenthesized structure and signature expressions
 *   - fixity directives in signatures
 *   - op keyword in signatures
 *
 * Notes:
 *   For easier interfacing with the back end we keep several derived forms:
 *   - tuple expressions, patterns, and types
 *   - selector functions
 *   - case, if, orelse, andalso expressions
 *   - sequential expressions
 *   - while expressions
 *   Optional semicolons are omitted.
 *   Because of delayed infix resolution we have to keep fvalbind forms and
 *   need a special app pattern form.
 *   Constructor patterns with arguments are represented as APPPats.
 *   We must also keep parentheses and stuff because of delayed infix resolving.
 *   The structure where and sharing derived forms [Definition, Appendix A]
 *   have been kept because they cannot be derived purely syntactically.
 *)

signature INPUT_GRAMMAR =
  sig

    (* Import *)

    type Info


    (* Identifiers and constants *)

    datatype SCon  = SCon  of Info * SCon.t
    datatype Lab   = Lab   of Info * Lab.t
    datatype VId   = VId   of Info * VId.t
    datatype TyCon = TyCon of Info * TyCon.t
    datatype TyVar = TyVar of Info * TyVar.t
    datatype StrId = StrId of Info * StrId.t
    datatype SigId = SigId of Info * SigId.t

    datatype 'a Long =
	  SHORTLong of Info * 'a
	| DOTLong   of Info * LongStrId * 'a

    withtype LongVId   = VId Long
    and      LongTyCon = TyCon Long
    and      LongStrId = StrId Long
    and      LongSigId = SigId Long


    (* Optional keyword `op' *)

    datatype Op = SANSOp | WITHOp


    (* Expressions *)

    datatype AtExp =
	  SCONAtExp      of Info * SCon
	| LONGVIDAtExp   of Info * Op * LongVId
	| RECORDAtExp    of Info * ExpRow option
	| UPDATEAtExp    of Info * AtExp * ExpRow
	| HASHAtExp      of Info * Lab
	| TUPLEAtExp     of Info * Exp list
	| VECTORAtExp    of Info * Exp list
	| SEQAtExp       of Info * Exp list
	| LETAtExp       of Info * Dec * Exp
	| PARAtExp       of Info * Exp

    and ExpRow =
	  ROWExpRow      of Info * Lab * Exp * ExpRow option

    and Exp =
	  ATEXPExp       of Info * AtExp
	| APPExp         of Info * Exp * AtExp
	| TYPEDExp       of Info * Exp * Ty
	| ANDALSOExp     of Info * Exp * Exp
	| ORELSEExp      of Info * Exp * Exp
	| HANDLEExp      of Info * Exp * Match
	| RAISEExp       of Info * Exp
	| IFExp          of Info * Exp * Exp * Exp
	| WHILEExp       of Info * Exp * Exp
	| CASEExp        of Info * Exp * Match
	| FNExp          of Info * Match
	| PACKExp        of Info * LongStrId

    (* Matches *)      

    and Match =
	  Match          of Info * Mrule * Match option

    and Mrule =
	  Mrule          of Info * Pat * Exp

    (* Declarations *)

    and Dec =
	  VALDec          of Info * TyVarSeq * ValBind
	| FUNDec          of Info * TyVarSeq * FvalBind
	| TYPEDec         of Info * TypBind
	| EQTYPEDec       of Info * TypBind
	| EQEQTYPEDec     of Info * TypBind
	| DATATYPEDec     of Info * DatBind
	| REPLICATIONDec  of Info * TyCon * LongTyCon
	| CONSTRUCTORDec  of Info * DconBind
	| STRUCTUREDec    of Info * StrBind
	| SIGNATUREDec    of Info * SigBind
	| LOCALDec        of Info * Dec * Dec
	| OPENDec         of Info * LongStrId
	| EMPTYDec        of Info
	| SEQDec          of Info * Dec * Dec
	| PREBOUNDDec     of Info * StrId
	| PRIMITIVEVALDec         of Info * Op * VId * Ty * string
	| PRIMITIVECONSTRUCTORDec of Info * Op * VId * Ty option
					       * TyVarSeq * LongTyCon * string
	| PRIMITIVESTRUCTUREDec   of Info * StrId * SigExp * string
	| OVERLOADDec     of Info * Op * VId * TyVar * Ty
	| INSTANCEDec     of Info * Op * VId * LongTyCon * LongVId
	| INSTANCESCONDec of Info * SCon * LongTyCon
	| INFIXDec        of Info * int * VId
	| INFIXRDec       of Info * int * VId
	| NONFIXDec       of Info * VId

    (* Bindings *)

    and ValBind =
	  PLAINValBind   of Info * Pat * Exp * ValBind option
	| RECValBind     of Info * ValBind

    and FvalBind =
	  FvalBind       of Info * Match * FvalBind option

    and TypBind =
	  NEWTypBind     of Info * TyVarSeq * TyCon * TypBind option
	| EQUALTypBind   of Info * TyVarSeq * TyCon * Ty * TypBind option

    and DatBind =
	  CLOSEDDatBind  of Info * TyVarSeq * TyCon * ConBind * DatBind option
	| OPENDatBind    of Info * TyVarSeq * TyCon * DatBind option

    and ConBind =
	  ConBind        of Info * Op * VId * Ty option * ConBind option

    and DconBind =
	  NEWDconBind    of Info * Op * VId * Ty option * TyVarSeq * LongTyCon
							* DconBind option
	| EQUALDconBind  of Info * Op * VId * Op * LongVId * DconBind option

    and StrBind =
          StrBind        of Info * StrId * StrExp * StrBind option

    and SigBind =
          SigBind        of Info * SigId * StrPat list * SigExp * SigBind option

    (* Patterns *)

    and AtPat =
	  WILDCARDAtPat  of Info
	| SCONAtPat      of Info * SCon
	| LONGVIDAtPat   of Info * Op * LongVId
	| RECORDAtPat    of Info * PatRow option
	| TUPLEAtPat     of Info * Pat list
	| VECTORAtPat    of Info * Pat list
	| ALTAtPat       of Info * Pat list
	| PARAtPat       of Info * Pat

    and PatRow =
	  WILDCARDPatRow of Info
	| ROWPatRow      of Info * Lab * Pat * PatRow option

    and Pat =
	  ATPATPat       of Info * AtPat
	| APPPat         of Info * Pat * AtPat
	| TYPEDPat       of Info * Pat * Ty
	| NONPat         of Info * Pat
	| ASPat          of Info * Pat * Pat
	| WHENPat        of Info * Pat * AtExp
	| WITHVALPat     of Info * Pat * ValBind
	| WITHFUNPat     of Info * Pat * FvalBind

    (* Type expressions *)

    and Ty =
	  TYVARTy        of Info * TyVar
	| RECORDTy       of Info * TyRow option
	| TUPLETy        of Info * Ty list
	| TYCONTy        of Info * TySeq * LongTyCon
	| ARROWTy        of Info * Ty * Ty
	| PACKTy         of Info * LongSigId
	| PARTy          of Info * Ty

    and TyRow =
	  ROWTyRow       of Info * Lab * Ty * TyRow option

    (* Structures *)

    and AtStrExp =
	  STRUCTAtStrExp    of Info * Dec
	| LONGSTRIDAtStrExp of Info * LongStrId
	| LETAtStrExp       of Info * Dec * StrExp
	| PARAtStrExp       of Info * StrExp

    and StrExp =
	  ATSTREXPStrExp    of Info * AtStrExp
	| APPStrExp         of Info * StrExp * AtStrExp
	| TRANSStrExp       of Info * StrExp * SigExp
	| OPAQStrExp        of Info * StrExp * SigExp
	| FCTStrExp         of Info * StrPat * StrExp
	| UNPACKStrExp      of Info * Exp * SigExp

    and StrPat =
	  StrPat            of Info * StrId * SigExp

    (* Signatures *)

    and AtSigExp =
	  ANYAtSigExp       of Info
	| SIGAtSigExp       of Info * Spec
	| LONGSIGIDAtSigExp of Info * LongSigId
	| LETAtSigExp       of Info * Dec * SigExp
	| PARAtSigExp       of Info * SigExp

    and SigExp =
	  ATSIGEXPSigExp    of Info * AtSigExp
	| APPSigExp         of Info * SigExp * AtStrExp
	| FCTSigExp         of Info * StrPat * SigExp
	| WHERESigExp       of Info * SigExp * SigExp

    (* Specifications *)

    and Spec =
	  VALSpec          of Info * ValDesc
	| TYPESpec         of Info * TypDesc
	| EQTYPESpec       of Info * TypDesc
	| EQEQTYPESpec     of Info * TypDesc
	| DATATYPESpec     of Info * DatDesc
	| REPLICATIONSpec  of Info * TyCon * LongTyCon
	| CONSTRUCTORSpec  of Info * DconDesc
	| STRUCTURESpec    of Info * StrDesc
	| SIGNATURESpec    of Info * SigDesc
	| INCLUDESpec      of Info * SigExp
	| EMPTYSpec        of Info
	| SEQSpec          of Info * Spec * Spec
	| SHARINGTYPESpec  of Info * Spec * LongTyCon list
	| SHARINGSIGNATURESpec of Info * Spec * LongSigId list
	| SHARINGSpec      of Info * Spec * LongStrId list
	| PREBOUNDSpec     of Info * StrId
	| OVERLOADSpec     of Info * Op * VId * TyVar * Ty
	| INSTANCESpec     of Info * Op * VId * LongTyCon * LongVId
	| INSTANCESCONSpec of Info * SCon * LongTyCon
	| INFIXSpec        of Info * int * VId
	| INFIXRSpec       of Info * int * VId
	| NONFIXSpec       of Info * VId

    and ValDesc =
	  NEWValDesc      of Info * Op * VId * Ty * ValDesc option
	| EQUALValDesc    of Info * Op * VId * Op * LongVId * ValDesc option

    and TypDesc =
	  NEWTypDesc      of Info * TyVarSeq * TyCon * TypDesc option
	| EQUALTypDesc    of Info * TyVarSeq * TyCon * Ty * TypDesc option

    and DatDesc =
	  CLOSEDDatDesc   of Info * TyVarSeq * TyCon * ConDesc * DatDesc option
	| OPENDatDesc     of Info * TyVarSeq * TyCon * DatDesc option

    and ConDesc =
	  ConDesc         of Info * Op * VId * Ty option * ConDesc option

    and DconDesc =
	  NEWDconDesc     of Info * Op * VId * Ty option * TyVarSeq * LongTyCon
			 				      * DconDesc option
	| EQUALDconDesc   of Info * Op * VId * Op * LongVId * DconDesc option

    and StrDesc =
          NEWStrDesc      of Info * StrId * SigExp * StrDesc option
	| EQUALStrDesc    of Info * StrId * SigExp option * LongStrId
							    * StrDesc option
    and SigDesc =
          NEWSigDesc      of Info * SigId * StrPat list * SigDesc option
	| EQUALSigDesc    of Info * SigId * StrPat list * SigExp
							* SigDesc option
    (* Programs *)

    and Program = Program of Info * Dec * Program option

    (* Components *)

    and Component = Component of Info * Import * Program option

    and Import =
	  IMPORTImport of Info * Spec * string
	| EMPTYImport  of Info
	| SEQImport    of Info * Import * Import

    (* Sequences *)

    and 'a Seq    = Seq of Info * 'a list

    withtype TySeq    = Ty Seq
    and      TyVarSeq = TyVar Seq


    (* Operations *)

    val infoSCon :	SCon		-> Info
    val infoLab :	Lab		-> Info
    val infoVId :	VId		-> Info
    val infoTyCon :	TyCon		-> Info
    val infoTyVar :	TyVar		-> Info
    val infoStrId :	StrId		-> Info
    val infoSigId :	SigId		-> Info
    val infoLong :	'a Long		-> Info
    val infoAtExp :	AtExp		-> Info
    val infoExpRow :	ExpRow		-> Info
    val infoExp :	Exp		-> Info
    val infoMatch :	Match		-> Info
    val infoMrule :	Mrule		-> Info
    val infoDec :	Dec		-> Info
    val infoValBind :	ValBind		-> Info
    val infoFvalBind :	FvalBind	-> Info
    val infoTypBind :	TypBind		-> Info
    val infoDatBind :	DatBind		-> Info
    val infoConBind :	ConBind		-> Info
    val infoDconBind :	DconBind	-> Info
    val infoStrBind :	StrBind		-> Info
    val infoSigBind :	SigBind		-> Info
    val infoAtPat :	AtPat		-> Info
    val infoPatRow :	PatRow		-> Info
    val infoPat :	Pat		-> Info
    val infoTy :	Ty		-> Info
    val infoTyRow :	TyRow		-> Info
    val infoAtStrExp :	AtStrExp	-> Info
    val infoStrExp :	StrExp		-> Info
    val infoStrPat :	StrPat		-> Info
    val infoAtSigExp :	AtSigExp	-> Info
    val infoSigExp :	SigExp		-> Info
    val infoSpec :	Spec		-> Info
    val infoValDesc :	ValDesc		-> Info
    val infoTypDesc :	TypDesc		-> Info
    val infoDatDesc :	DatDesc		-> Info
    val infoConDesc :	ConDesc		-> Info
    val infoDconDesc :	DconDesc	-> Info
    val infoStrDesc :	StrDesc		-> Info
    val infoSigDesc :	SigDesc		-> Info
    val infoProgram :	Program		-> Info
    val infoComponent :	Component	-> Info
    val infoImport :	Import		-> Info
    val infoSeq :	'a Seq		-> Info

    val idLab :		Lab		-> Lab.t
    val idVId :		VId		-> VId.t
    val idTyCon :	TyCon		-> TyCon.t
    val idTyVar :	TyVar		-> TyVar.t
    val idStrId :	StrId		-> StrId.t
    val idSigId :	SigId		-> SigId.t

    val explodeLong :	'a Long		-> StrId list * 'a

  end
(* src # 83 *)
(*
 * Stockhausen input grammar
 *
 * Extensions and modifications to core language:
 *   - unified dec and topdec (i.e. top declarations can appear in let)
 *   - record update expressions
 *   - vector expressions and patterns
 *   - generalized layered patterns
 *   - alternative patterns
 *   - guarded patterns
 *   - negated patterns
 *   - withval patterns
 *   - abstract type declarations
 *   - open datatypes and free construct declarations
 *   - package types and expressions
 *   - removed exception declarations (made into a derived form)
 *   - removed abstype (made into a derived form with local)
 *   - simplified open and fixity declarations to single id (multi ids made DF)
 *   - some hacks to build libraries: primitive value declarations,
 *     overloading declarations, special eqtype declarations and specifications
 *
 * Extensions and modifications to module language:
 *   - components
 *   - unified strdec and topdec
 *   - unified strid and funid
 *   - functor expressions
 *   - removed functor declarations (made into a derived form)
 *   - package elimination
 *   - parameterized signatures
 *   - open datatypes and free constructor specifications
 *   - straightified type specifications (synonyms are kept)
 *   - signature specifications
 *   - definitional value, constructor, and structure specifications
 *   - functor signatures
 *   - top signature
 *   - generalized where
 *   - sharing for signatures
 *   - let for signature expressions
 *   - functor parameters as a separate syntactic class StrPat
 *   - parenthesized structure and signature expressions
 *   - fixity directives in signatures
 *   - op keyword in signatures
 *
 * Notes:
 *   For easier interfacing with the back end we keep several derived forms:
 *   - tuple expressions, patterns, and types
 *   - selector functions
 *   - case, if, orelse, andalso expressions
 *   - sequential expressions
 *   - while expressions
 *   Optional semicolons are omitted.
 *   Because of delayed infix resolution we have to keep fvalbind forms and
 *   need a special app pattern form.
 *   Constructor patterns with arguments are represented as APPPats.
 *   We must also keep parentheses and stuff because of delayed infix resolving.
 *   The structure where and sharing derived forms [Definition, Appendix A]
 *   have been kept because they cannot be derived purely syntactically.
 *)

functor MakeInputGrammar(type Info) :> INPUT_GRAMMAR where type Info = Info =
  struct

    (* Import *)

    type Info = Info


    (* Identifiers and constants *)

    datatype SCon  = SCon  of Info * SCon.t
    datatype Lab   = Lab   of Info * Lab.t
    datatype VId   = VId   of Info * VId.t
    datatype TyCon = TyCon of Info * TyCon.t
    datatype TyVar = TyVar of Info * TyVar.t
    datatype StrId = StrId of Info * StrId.t
    datatype SigId = SigId of Info * SigId.t

    datatype 'a Long =
	  SHORTLong of Info * 'a
	| DOTLong   of Info * LongStrId * 'a

    withtype LongVId   = VId Long
    and      LongTyCon = TyCon Long
    and      LongStrId = StrId Long
    and      LongSigId = SigId Long


    (* Optional keyword `op' *)

    datatype Op = SANSOp | WITHOp


    (* Expressions *)

    datatype AtExp =
	  SCONAtExp      of Info * SCon
	| LONGVIDAtExp   of Info * Op * LongVId
	| RECORDAtExp    of Info * ExpRow option
	| UPDATEAtExp    of Info * AtExp * ExpRow
	| HASHAtExp      of Info * Lab
	| TUPLEAtExp     of Info * Exp list
	| VECTORAtExp    of Info * Exp list
	| SEQAtExp       of Info * Exp list
	| LETAtExp       of Info * Dec * Exp
	| PARAtExp       of Info * Exp

    and ExpRow =
	  ROWExpRow      of Info * Lab * Exp * ExpRow option

    and Exp =
	  ATEXPExp       of Info * AtExp
	| APPExp         of Info * Exp * AtExp
	| TYPEDExp       of Info * Exp * Ty
	| ANDALSOExp     of Info * Exp * Exp
	| ORELSEExp      of Info * Exp * Exp
	| HANDLEExp      of Info * Exp * Match
	| RAISEExp       of Info * Exp
	| IFExp          of Info * Exp * Exp * Exp
	| WHILEExp       of Info * Exp * Exp
	| CASEExp        of Info * Exp * Match
	| FNExp          of Info * Match
	| PACKExp        of Info * LongStrId

    (* Matches *)      

    and Match =
	  Match          of Info * Mrule * Match option

    and Mrule =
	  Mrule          of Info * Pat * Exp

    (* Declarations *)

    and Dec =
	  VALDec          of Info * TyVarSeq * ValBind
	| FUNDec          of Info * TyVarSeq * FvalBind
	| TYPEDec         of Info * TypBind
	| EQTYPEDec       of Info * TypBind
	| EQEQTYPEDec     of Info * TypBind
	| DATATYPEDec     of Info * DatBind
	| REPLICATIONDec  of Info * TyCon * LongTyCon
	| CONSTRUCTORDec  of Info * DconBind
	| STRUCTUREDec    of Info * StrBind
	| SIGNATUREDec    of Info * SigBind
	| LOCALDec        of Info * Dec * Dec
	| OPENDec         of Info * LongStrId
	| EMPTYDec        of Info
	| SEQDec          of Info * Dec * Dec
	| PREBOUNDDec     of Info * StrId
	| PRIMITIVEVALDec         of Info * Op * VId * Ty * string
	| PRIMITIVECONSTRUCTORDec of Info * Op * VId * Ty option
					       * TyVarSeq * LongTyCon * string
	| PRIMITIVESTRUCTUREDec   of Info * StrId * SigExp * string
	| OVERLOADDec     of Info * Op * VId * TyVar * Ty
	| INSTANCEDec     of Info * Op * VId * LongTyCon * LongVId
	| INSTANCESCONDec of Info * SCon * LongTyCon
	| INFIXDec        of Info * int * VId
	| INFIXRDec       of Info * int * VId
	| NONFIXDec       of Info * VId

    (* Bindings *)

    and ValBind =
	  PLAINValBind   of Info * Pat * Exp * ValBind option
	| RECValBind     of Info * ValBind

    and FvalBind =
	  FvalBind       of Info * Match * FvalBind option

    and TypBind =
	  NEWTypBind     of Info * TyVarSeq * TyCon * TypBind option
	| EQUALTypBind   of Info * TyVarSeq * TyCon * Ty * TypBind option

    and DatBind =
	  CLOSEDDatBind  of Info * TyVarSeq * TyCon * ConBind * DatBind option
	| OPENDatBind    of Info * TyVarSeq * TyCon * DatBind option

    and ConBind =
	  ConBind        of Info * Op * VId * Ty option * ConBind option

    and DconBind =
	  NEWDconBind    of Info * Op * VId * Ty option * TyVarSeq * LongTyCon
							* DconBind option
	| EQUALDconBind  of Info * Op * VId * Op * LongVId * DconBind option

    and StrBind =
          StrBind        of Info * StrId * StrExp * StrBind option

    and SigBind =
          SigBind        of Info * SigId * StrPat list * SigExp * SigBind option

    (* Patterns *)

    and AtPat =
	  WILDCARDAtPat  of Info
	| SCONAtPat      of Info * SCon
	| LONGVIDAtPat   of Info * Op * LongVId
	| RECORDAtPat    of Info * PatRow option
	| TUPLEAtPat     of Info * Pat list
	| VECTORAtPat    of Info * Pat list
	| ALTAtPat       of Info * Pat list
	| PARAtPat       of Info * Pat

    and PatRow =
	  WILDCARDPatRow of Info
	| ROWPatRow      of Info * Lab * Pat * PatRow option

    and Pat =
	  ATPATPat       of Info * AtPat
	| APPPat         of Info * Pat * AtPat
	| TYPEDPat       of Info * Pat * Ty
	| NONPat         of Info * Pat
	| ASPat          of Info * Pat * Pat
	| WHENPat        of Info * Pat * AtExp
	| WITHVALPat     of Info * Pat * ValBind
	| WITHFUNPat     of Info * Pat * FvalBind

    (* Type expressions *)

    and Ty =
	  TYVARTy        of Info * TyVar
	| RECORDTy       of Info * TyRow option
	| TUPLETy        of Info * Ty list
	| TYCONTy        of Info * TySeq * LongTyCon
	| ARROWTy        of Info * Ty * Ty
	| PACKTy         of Info * LongSigId
	| PARTy          of Info * Ty

    and TyRow =
	  ROWTyRow       of Info * Lab * Ty * TyRow option

    (* Structures *)

    and AtStrExp =
	  STRUCTAtStrExp    of Info * Dec
	| LONGSTRIDAtStrExp of Info * LongStrId
	| LETAtStrExp       of Info * Dec * StrExp
	| PARAtStrExp       of Info * StrExp

    and StrExp =
	  ATSTREXPStrExp    of Info * AtStrExp
	| APPStrExp         of Info * StrExp * AtStrExp
	| TRANSStrExp       of Info * StrExp * SigExp
	| OPAQStrExp        of Info * StrExp * SigExp
	| FCTStrExp         of Info * StrPat * StrExp
	| UNPACKStrExp      of Info * Exp * SigExp

    and StrPat =
	  StrPat            of Info * StrId * SigExp

    (* Signatures *)

    and AtSigExp =
	  ANYAtSigExp       of Info
	| SIGAtSigExp       of Info * Spec
	| LONGSIGIDAtSigExp of Info * LongSigId
	| LETAtSigExp       of Info * Dec * SigExp
	| PARAtSigExp       of Info * SigExp

    and SigExp =
	  ATSIGEXPSigExp    of Info * AtSigExp
	| APPSigExp         of Info * SigExp * AtStrExp
	| FCTSigExp         of Info * StrPat * SigExp
	| WHERESigExp       of Info * SigExp * SigExp

    (* Specifications *)

    and Spec =
	  VALSpec          of Info * ValDesc
	| TYPESpec         of Info * TypDesc
	| EQTYPESpec       of Info * TypDesc
	| EQEQTYPESpec     of Info * TypDesc
	| DATATYPESpec     of Info * DatDesc
	| REPLICATIONSpec  of Info * TyCon * LongTyCon
	| CONSTRUCTORSpec  of Info * DconDesc
	| STRUCTURESpec    of Info * StrDesc
	| SIGNATURESpec    of Info * SigDesc
	| INCLUDESpec      of Info * SigExp
	| EMPTYSpec        of Info
	| SEQSpec          of Info * Spec * Spec
	| SHARINGTYPESpec  of Info * Spec * LongTyCon list
	| SHARINGSIGNATURESpec of Info * Spec * LongSigId list
	| SHARINGSpec      of Info * Spec * LongStrId list
	| PREBOUNDSpec     of Info * StrId
	| OVERLOADSpec     of Info * Op * VId * TyVar * Ty
	| INSTANCESpec     of Info * Op * VId * LongTyCon * LongVId
	| INSTANCESCONSpec of Info * SCon * LongTyCon
	| INFIXSpec        of Info * int * VId
	| INFIXRSpec       of Info * int * VId
	| NONFIXSpec       of Info * VId

    and ValDesc =
	  NEWValDesc      of Info * Op * VId * Ty * ValDesc option
	| EQUALValDesc    of Info * Op * VId * Op * LongVId * ValDesc option

    and TypDesc =
	  NEWTypDesc      of Info * TyVarSeq * TyCon * TypDesc option
	| EQUALTypDesc    of Info * TyVarSeq * TyCon * Ty * TypDesc option

    and DatDesc =
	  CLOSEDDatDesc   of Info * TyVarSeq * TyCon * ConDesc * DatDesc option
	| OPENDatDesc     of Info * TyVarSeq * TyCon * DatDesc option

    and ConDesc =
	  ConDesc         of Info * Op * VId * Ty option * ConDesc option

    and DconDesc =
	  NEWDconDesc     of Info * Op * VId * Ty option * TyVarSeq * LongTyCon
			 				      * DconDesc option
	| EQUALDconDesc   of Info * Op * VId * Op * LongVId * DconDesc option

    and StrDesc =
          NEWStrDesc      of Info * StrId * SigExp * StrDesc option
	| EQUALStrDesc    of Info * StrId * SigExp option * LongStrId
							    * StrDesc option
    and SigDesc =
          NEWSigDesc      of Info * SigId * StrPat list * SigDesc option
	| EQUALSigDesc    of Info * SigId * StrPat list * SigExp
							* SigDesc option
    (* Programs *)

    and Program = Program of Info * Dec * Program option

    (* Components *)

    and Component = Component of Info * Import * Program option

    and Import =
	  IMPORTImport of Info * Spec * string
	| EMPTYImport  of Info
	| SEQImport    of Info * Import * Import

    (* Sequences *)

    and 'a Seq    = Seq of Info * 'a list

    withtype TySeq    = Ty Seq
    and      TyVarSeq = TyVar Seq


    (* Extracting info fields *)

    fun infoSCon(SCon(I,_))				= I
    fun infoLab(Lab(I,_))				= I
    fun infoVId(VId(I,_))				= I
    fun infoTyCon(TyCon(I,_))				= I
    fun infoTyVar(TyVar(I,_))				= I
    fun infoStrId(StrId(I,_))				= I
    fun infoSigId(SigId(I,_))				= I

    fun infoLong(SHORTLong(I,_))			= I
      | infoLong(DOTLong(I,_,_))			= I

    fun infoAtExp(SCONAtExp(I,_))			= I
      | infoAtExp(LONGVIDAtExp(I,_,_))			= I
      | infoAtExp(RECORDAtExp(I,_))			= I
      | infoAtExp(UPDATEAtExp(I,_,_))			= I
      | infoAtExp(HASHAtExp(I,_))			= I
      | infoAtExp(TUPLEAtExp(I,_))			= I
      | infoAtExp(VECTORAtExp(I,_))			= I
      | infoAtExp(SEQAtExp(I,_))			= I
      | infoAtExp(LETAtExp(I,_,_))			= I
      | infoAtExp(PARAtExp(I,_))			= I

    fun infoExpRow(ROWExpRow(I,_,_,_))			= I

    fun infoExp(ATEXPExp(I,_))				= I
      | infoExp(APPExp(I,_,_))				= I
      | infoExp(TYPEDExp(I,_,_))			= I
      | infoExp(ANDALSOExp(I,_,_))			= I
      | infoExp(ORELSEExp(I,_,_))			= I
      | infoExp(HANDLEExp(I,_,_))			= I
      | infoExp(RAISEExp(I,_))				= I
      | infoExp(IFExp(I,_,_,_))				= I
      | infoExp(WHILEExp(I,_,_))			= I
      | infoExp(CASEExp(I,_,_))				= I
      | infoExp(FNExp(I,_))				= I
      | infoExp(PACKExp(I,_))				= I

    fun infoMatch(Match(I,_,_))				= I

    fun infoMrule(Mrule(I,_,_))				= I

    fun infoDec(VALDec(I,_,_))				= I
      | infoDec(FUNDec(I,_,_))				= I
      | infoDec(TYPEDec(I,_))				= I
      | infoDec(EQTYPEDec(I,_))				= I
      | infoDec(EQEQTYPEDec(I,_))			= I
      | infoDec(DATATYPEDec(I,_))			= I
      | infoDec(REPLICATIONDec(I,_,_))			= I
      | infoDec(CONSTRUCTORDec(I,_))			= I
      | infoDec(STRUCTUREDec(I,_))			= I
      | infoDec(SIGNATUREDec(I,_))			= I
      | infoDec(LOCALDec(I,_,_))			= I
      | infoDec(OPENDec(I,_))				= I
      | infoDec(EMPTYDec(I))				= I
      | infoDec(SEQDec(I,_,_))				= I
      | infoDec(PREBOUNDDec(I,_))			= I
      | infoDec(PRIMITIVEVALDec(I,_,_,_,_))		= I
      | infoDec(PRIMITIVECONSTRUCTORDec(I,_,_,_,_,_,_))	= I
      | infoDec(PRIMITIVESTRUCTUREDec(I,_,_,_))		= I
      | infoDec(OVERLOADDec(I,_,_,_,_))			= I
      | infoDec(INSTANCEDec(I,_,_,_,_))			= I
      | infoDec(INSTANCESCONDec(I,_,_))			= I
      | infoDec(INFIXDec(I,_,_))			= I
      | infoDec(INFIXRDec(I,_,_))			= I
      | infoDec(NONFIXDec(I,_))				= I

    fun infoValBind(PLAINValBind(I,_,_,_))		= I
      | infoValBind(RECValBind(I,_))			= I

    fun infoFvalBind(FvalBind(I,_,_))			= I

    fun infoTypBind(NEWTypBind(I,_,_,_))		= I
      | infoTypBind(EQUALTypBind(I,_,_,_,_))		= I

    fun infoDatBind(CLOSEDDatBind(I,_,_,_,_))		= I
      | infoDatBind(OPENDatBind(I,_,_,_))		= I

    fun infoConBind(ConBind(I,_,_,_,_))			= I

    fun infoDconBind(NEWDconBind(I,_,_,_,_,_,_))	= I
      | infoDconBind(EQUALDconBind(I,_,_,_,_,_))	= I

    fun infoStrBind(StrBind(I,_,_,_))			= I

    fun infoSigBind(SigBind(I,_,_,_,_))			= I

    fun infoAtPat(WILDCARDAtPat(I))			= I
      | infoAtPat(SCONAtPat(I,_))			= I
      | infoAtPat(LONGVIDAtPat(I,_,_))			= I
      | infoAtPat(RECORDAtPat(I,_))			= I
      | infoAtPat(TUPLEAtPat(I,_))			= I
      | infoAtPat(VECTORAtPat(I,_))			= I
      | infoAtPat(ALTAtPat(I,_))			= I
      | infoAtPat(PARAtPat(I,_))			= I

    fun infoPatRow(WILDCARDPatRow(I))			= I
      | infoPatRow(ROWPatRow(I,_,_,_))			= I

    fun infoPat(ATPATPat(I,_))				= I
      | infoPat(APPPat(I,_,_))				= I
      | infoPat(TYPEDPat(I,_,_))			= I
      | infoPat(NONPat(I,_))				= I
      | infoPat(ASPat(I,_,_))				= I
      | infoPat(WHENPat(I,_,_))				= I
      | infoPat(WITHVALPat(I,_,_))			= I
      | infoPat(WITHFUNPat(I,_,_))			= I

    fun infoTy(TYVARTy(I,_))				= I
      | infoTy(RECORDTy(I,_))				= I
      | infoTy(TUPLETy(I,_))				= I
      | infoTy(TYCONTy(I,_,_))				= I
      | infoTy(ARROWTy(I,_,_))				= I
      | infoTy(PACKTy(I,_))				= I
      | infoTy(PARTy(I,_))				= I

    fun infoTyRow(ROWTyRow(I,_,_,_))			= I

    fun infoAtStrExp(STRUCTAtStrExp(I,_))		= I
      | infoAtStrExp(LONGSTRIDAtStrExp(I,_))		= I
      | infoAtStrExp(LETAtStrExp(I,_,_))		= I
      | infoAtStrExp(PARAtStrExp(I,_))			= I

    fun infoStrExp(ATSTREXPStrExp(I,_))			= I
      | infoStrExp(APPStrExp(I,_,_))			= I
      | infoStrExp(TRANSStrExp(I,_,_))			= I
      | infoStrExp(OPAQStrExp(I,_,_))			= I
      | infoStrExp(FCTStrExp(I,_,_))			= I
      | infoStrExp(UNPACKStrExp(I,_,_))			= I

    fun infoStrPat(StrPat(I,_,_))			= I

    fun infoAtSigExp(ANYAtSigExp(I))			= I
      | infoAtSigExp(SIGAtSigExp(I,_))			= I
      | infoAtSigExp(LONGSIGIDAtSigExp(I,_))		= I
      | infoAtSigExp(LETAtSigExp(I,_,_))		= I
      | infoAtSigExp(PARAtSigExp(I,_))			= I

    fun infoSigExp(ATSIGEXPSigExp(I,_))			= I
      | infoSigExp(APPSigExp(I,_,_))			= I
      | infoSigExp(FCTSigExp(I,_,_))			= I
      | infoSigExp(WHERESigExp(I,_,_))			= I

    fun infoSpec(VALSpec(I,_))				= I
      | infoSpec(TYPESpec(I,_))				= I
      | infoSpec(EQTYPESpec(I,_))			= I
      | infoSpec(EQEQTYPESpec(I,_))			= I
      | infoSpec(DATATYPESpec(I,_))			= I
      | infoSpec(REPLICATIONSpec(I,_,_))		= I
      | infoSpec(CONSTRUCTORSpec(I,_))			= I
      | infoSpec(STRUCTURESpec(I,_))			= I
      | infoSpec(SIGNATURESpec(I,_))			= I
      | infoSpec(INCLUDESpec(I,_))			= I
      | infoSpec(EMPTYSpec(I))				= I
      | infoSpec(SEQSpec(I,_,_))			= I
      | infoSpec(SHARINGTYPESpec(I,_,_))		= I
      | infoSpec(SHARINGSIGNATURESpec(I,_,_))		= I
      | infoSpec(SHARINGSpec(I,_,_))			= I
      | infoSpec(PREBOUNDSpec(I,_))			= I
      | infoSpec(OVERLOADSpec(I,_,_,_,_))		= I
      | infoSpec(INSTANCESpec(I,_,_,_,_))		= I
      | infoSpec(INSTANCESCONSpec(I,_,_))		= I
      | infoSpec(INFIXSpec(I,_,_))			= I
      | infoSpec(INFIXRSpec(I,_,_))			= I
      | infoSpec(NONFIXSpec(I,_))			= I

    fun infoValDesc(NEWValDesc(I,_,_,_,_))		= I
      | infoValDesc(EQUALValDesc(I,_,_,_,_,_))		= I

    fun infoTypDesc(NEWTypDesc(I,_,_,_))		= I
      | infoTypDesc(EQUALTypDesc(I,_,_,_,_))		= I

    fun infoDatDesc(CLOSEDDatDesc(I,_,_,_,_))		= I
      | infoDatDesc(OPENDatDesc(I,_,_,_))		= I

    fun infoConDesc(ConDesc(I,_,_,_,_))			= I

    fun infoDconDesc(NEWDconDesc(I,_,_,_,_,_,_))	= I
      | infoDconDesc(EQUALDconDesc(I,_,_,_,_,_))	= I

    fun infoStrDesc(NEWStrDesc(I,_,_,_))		= I
      | infoStrDesc(EQUALStrDesc(I,_,_,_,_))		= I

    fun infoSigDesc(NEWSigDesc(I,_,_,_))		= I
      | infoSigDesc(EQUALSigDesc(I,_,_,_,_))		= I

    fun infoProgram(Program(I,_,_))			= I

    fun infoComponent(Component(I,_,_))			= I

    fun infoImport(IMPORTImport(I,_,_))			= I
      | infoImport(EMPTYImport(I))			= I
      | infoImport(SEQImport(I,_,_))			= I

    fun infoSeq(Seq(I,_))				= I


    fun idLab(Lab(_,id))				= id
    fun idVId(VId(_,id))				= id
    fun idTyCon(TyCon(_,id))				= id
    fun idTyVar(TyVar(_,id))				= id
    fun idStrId(StrId(_,id))				= id
    fun idSigId(SigId(_,id))				= id


    fun explodeLong(SHORTLong(_,id))		= ([], id)
      | explodeLong(DOTLong(_,longid,id))	= (explodeLong'(longid,[]), id)

    and explodeLong'(SHORTLong(_,id),      ids)	= id::ids
      | explodeLong'(DOTLong(_,longid,id), ids)	= explodeLong'(longid, id::ids)

  end
(* src # 84 *)
structure InputGrammar = MakeInputGrammar(type Info = Source.region)
(* src # 85 *)
signature PARSING_ERROR =
  sig

    type VId = VId.t

    datatype error =
	(* Lexer *)
	  UnclosedComment
	| InvalidChar		of char
	| InvalidString
	| IntTooLarge
	| WordTooLarge
	| RealTooLarge
	| CharLengthInvalid	of string
	| EscapeCharTooLarge	of bool
	(* Parser *)
	| SyntaxError		of string
	(* Derived forms *)
	| WithtypeInvalid
	| WithtypeArityMismatch
	(* Infix *)
	| InfixMisplaced	of VId
	| AssocConflict		of VId * VId

    type warning	(* yet empty *)

    val error :	Source.region * error -> 'a
    val warn :	Source.region * warning -> unit

  end
(* src # 86 *)
structure ParsingError :> PARSING_ERROR =
  struct

  (* Pretty printer *)

    open PrettyPrint
    open PPMisc

    infixr ^^ ^/^

    val par = paragraph

  (* Types *)

    type VId = VId.t

    datatype error =
	(* Lexer *)
	  UnclosedComment
	| InvalidChar		of char
	| InvalidString
	| IntTooLarge
	| WordTooLarge
	| RealTooLarge
	| CharLengthInvalid	of string
	| EscapeCharTooLarge	of bool
	(* Parser *)
	| SyntaxError		of string
	(* Derived forms *)
	| WithtypeInvalid
	| WithtypeArityMismatch
	(* Infix *)
	| InfixMisplaced	of VId
	| AssocConflict		of VId * VId


    type warning = unit		(* yet empty *)


  (* Pretty printing *)

    fun ppQuoted s	= "`" ^ s ^ "'"
    fun ppVId vid	= ppQuoted(VId.toString vid)

    fun ppError(UnclosedComment) =
	  par["unclosed","comment"]
      | ppError(InvalidChar c) =
	  par["invalid","character",ppQuoted(Char.toCString c)]
      | ppError(InvalidString) =
	  par["invalid","string","constant"]
      | ppError(IntTooLarge) =
	  par["integer","constant","too","large"]
      | ppError(WordTooLarge) =
	  par["word","constant","too","large"]
      | ppError(RealTooLarge) =
	  par["real","constant","too","large"]
      | ppError(CharLengthInvalid "") =
	  par["empty","character","constant"]
      | ppError(CharLengthInvalid s) =
	  par["multiple","characters","in","character","constant"]
      | ppError(EscapeCharTooLarge uc) =
	  par[if uc then "unicode" else "ASCII",
	      "escape","character","too","large"]
      (* Parser *)
      | ppError(SyntaxError s) =
	  par(String.tokens (fn c => c = #" ") s)
      (* Derived forms *)
      | ppError(WithtypeInvalid) =
	  par["invalid","type","binding","inside","withtype"]
      | ppError(WithtypeArityMismatch) =
	  par["type","has","wrong","arity"]
      (* Infix *)
      | ppError(InfixMisplaced vid) =
	  par["misplaced","infix","identifier",ppVId vid]
      | ppError(AssocConflict(vid1,vid2)) =
	  par["conflicting","infix","associativity","between","operators",
	      ppVId vid1,"and",ppVId vid2]


    fun ppWarning w = empty


  (* Export *)

    fun errorToString e   = PrettyPrint.toString(ppError e, 75)
    fun warningToString w = PrettyPrint.toString(ppWarning w, 75)

    fun error(region, e)  = Error.error(region, errorToString e)
    fun warn(region, w)   = Error.warn(region, warningToString w)

  end
(* src # 87 *)
signature ABSTRACTION_ERROR =
  sig

    type Lab	= Lab.t
    type VId	= VId.t
    type TyVar	= TyVar.t
    type TyCon	= TyCon.t
    type StrId	= StrId.t
    type SigId	= SigId.t
    type id	= AbstractGrammar.id

    datatype error =
	(* Identifiers *)
	  VIdUnbound		of VId
	| TyConUnbound		of TyCon
	| TyVarUnbound		of TyVar
	| StrIdUnbound		of StrId
	| SigIdUnbound		of SigId
	| PreboundFirstClass
	(* Expressions *)
	| ExpRowLabDuplicate	of Lab
	(* Patterns *)
	| PatVIdDuplicate	of VId
	| WithPatVIdDuplicate	of VId
	| PatLongVIdVar
	| PatRowLabDuplicate	of Lab
	| AppPatNonCon
	| AltPatInconsistent
	(* Types *)
	| TyRowLabDuplicate	of Lab
	| TyVarSeqDuplicate	of TyVar
	| ValTyVarSeqDuplicate	of TyVar
	(* Declarations and bindings *)
	| FvalBindDuplicate	of VId
	| FvalBindArityInconsistent
	| FvalBindArityZero
	| FvalBindNameInconsistent of VId
	| FvalBindNameMissing
	| FvalBindNameCon	of VId
	| FvalBindPatInvalid
	| TypBindDuplicate	of TyCon
	| DatBindDuplicate	of TyCon
	| DatBindConDuplicate	of VId
	| ConBindDuplicate	of VId
	| DconBindDuplicate	of VId
	| DconBindNonCon
	| StrBindDuplicate	of StrId
	| SigBindDuplicate	of SigId
	(* Specifications and descriptions *)
	| SpecFixDuplicate	of VId
	| SpecVIdDuplicate	of VId
	| SpecTyConDuplicate	of TyCon
	| SpecStrIdDuplicate	of StrId
	| SpecSigIdDuplicate	of SigId
	| ConDescDuplicate	of VId
	| DconDescNonCon
	(* Sharing translation *)
	| SharingExternalTy	of id
	| SharingExternalSig	of id
	| SharingExternalStr	of id

    datatype warning =
	(* Shadowing *)
	  VIdShadowed		of VId
	| TyConShadowed		of TyCon
	| TyVarShadowed		of TyVar
	| StrIdShadowed		of StrId
	| SigIdShadowed		of SigId

    val error :	Source.region * error -> 'a
    val warn :	Source.region * warning -> unit

  end
(* src # 88 *)
structure AbstractionError :> ABSTRACTION_ERROR =
  struct

  (* Pretty printer *)

    open PrettyPrint
    open PPMisc

    infixr ^^ ^/^

    val par = paragraph

  (* Types *)

    type Lab	= Lab.t
    type VId	= VId.t
    type TyVar	= TyVar.t
    type TyCon	= TyCon.t
    type StrId	= StrId.t
    type SigId	= SigId.t
    type id	= AbstractGrammar.id

    datatype error =
	(* Identifiers *)
	  VIdUnbound		of VId
	| TyConUnbound		of TyCon
	| TyVarUnbound		of TyVar
	| StrIdUnbound		of StrId
	| SigIdUnbound		of SigId
	| PreboundFirstClass
	(* Expressions *)
	| ExpRowLabDuplicate	of Lab
	(* Patterns *)
	| PatVIdDuplicate	of VId
	| WithPatVIdDuplicate	of VId
	| PatLongVIdVar
	| PatRowLabDuplicate	of Lab
	| AppPatNonCon
	| AltPatInconsistent
	(* Types *)
	| TyRowLabDuplicate	of Lab
	| TyVarSeqDuplicate	of TyVar
	| ValTyVarSeqDuplicate	of TyVar
	(* Declarations and bindings *)
	| FvalBindDuplicate	of VId
	| FvalBindArityInconsistent
	| FvalBindArityZero
	| FvalBindNameInconsistent of VId
	| FvalBindNameMissing
	| FvalBindNameCon	of VId
	| FvalBindPatInvalid
	| TypBindDuplicate	of TyCon
	| DatBindDuplicate	of TyCon
	| DatBindConDuplicate	of VId
	| ConBindDuplicate	of VId
	| DconBindDuplicate	of VId
	| DconBindNonCon
	| StrBindDuplicate	of StrId
	| SigBindDuplicate	of SigId
	(* Specifications and descriptions *)
	| SpecFixDuplicate	of VId
	| SpecVIdDuplicate	of VId
	| SpecTyConDuplicate	of TyCon
	| SpecStrIdDuplicate	of StrId
	| SpecSigIdDuplicate	of SigId
	| ConDescDuplicate	of VId
	| DconDescNonCon
	(* Sharing translation *)
	| SharingExternalTy	of id
	| SharingExternalSig	of id
	| SharingExternalStr	of id

    datatype warning =
	(* Shadowing *)
	  VIdShadowed		of VId
	| TyConShadowed		of TyCon
	| TyVarShadowed		of TyVar
	| StrIdShadowed		of StrId
	| SigIdShadowed		of SigId


  (* Pretty printing *)

    fun ppQuoted s	= "`" ^ s ^ "'"

    fun ppLab lab	= ppQuoted(Lab.toString lab)
    fun ppVId vid	= ppQuoted(VId.toString vid)
    fun ppTyCon tycon	= ppQuoted(TyCon.toString tycon)
    fun ppTyVar tyvar	= ppQuoted(TyVar.toString tyvar)
    fun ppStrId strid	= ppQuoted(StrId.toString strid)
    fun ppSigId sigid	= ppQuoted(SigId.toString sigid)

    fun ppLab'(AbstractGrammar.Lab(_,l)) = l

    fun ppId'(AbstractGrammar.Id(_,_,name)) = Name.toString name
    fun ppId x = ppQuoted(ppId' x)

    fun ppLongid'(AbstractGrammar.ShortId(_,x))  = ppId' x
      | ppLongid'(AbstractGrammar.LongId(_,y,l)) = ppLongid' y ^ "." ^ ppLab' l
    fun ppLongid y = ppQuoted(ppLongid' y)


    val classLab	= (ppLab,   ["label"])
    val classVId	= (ppVId,   ["value","or","constructor"])
    val classTyCon	= (ppTyCon, ["type"])
    val classTyVar	= (ppTyVar, ["type","variable"])
    val classStrId	= (ppStrId, ["structure","or","functor"])
    val classSigId	= (ppSigId, ["signature"])

    fun ppUnbound((ppId,class), id) =
	  par(["unknown"] @ class @ [ppId id])

    fun ppError(VIdUnbound vid) =
	  ppUnbound(classVId, vid)
      | ppError(TyConUnbound tycon) =
	  ppUnbound(classTyCon, tycon)
      | ppError(TyVarUnbound tyvar) =
	  ppUnbound(classTyVar, tyvar)
      | ppError(StrIdUnbound strid) =
	  ppUnbound(classStrId, strid)
      | ppError(SigIdUnbound sigid) =
	  ppUnbound(classSigId, sigid)
      | ppError(PreboundFirstClass) =
	  par["invalid","use","of","pseudo","structure"]
      (* Expressions *)
      | ppError(ExpRowLabDuplicate lab) =
	  par(["duplicate"] @ #2 classLab @ [ppLab lab,"in","record"])
      (* Patterns *)
      | ppError(PatVIdDuplicate vid) =
	  par["duplicate","variable",ppVId vid,"in","pattern",
	      "or","binding","group"]
      | ppError(WithPatVIdDuplicate vid) =
	  par["pattern","variable",ppVId vid,"redefined",
	      "inside","value","binding"]
      | ppError(PatLongVIdVar) =
	  par["non-constructor","long","identifier","in","pattern"]
      | ppError(PatRowLabDuplicate lab) =
	  par(["duplicate"] @ #2 classLab @ [ppLab lab,"in","record"])
      | ppError(AppPatNonCon) =
	  par["application","of","non-constructor","in","pattern"]
      | ppError(AltPatInconsistent) =
	  par["inconsistent","pattern","alternative"]
      (* Types *)
      | ppError(TyRowLabDuplicate lab) =
	  par(["duplicate"] @ #2 classLab @ [ppLab lab,"in","record"])
      | ppError(TyVarSeqDuplicate tyvar) =
	  par(["duplicate"] @ #2 classTyVar @ [ppTyVar tyvar])
      | ppError(ValTyVarSeqDuplicate tyvar) =
	  par(["duplicate","or","shadowing"] @ #2 classTyVar @ [ppTyVar tyvar])
      (* Declarations and bindings *)
      | ppError(FvalBindDuplicate vid) =
	  par["duplicate","function",ppVId vid,"in","binding","group"]
      | ppError(FvalBindArityInconsistent) =
	  par["inconistent","function","arity","in","function","clause"]
      | ppError(FvalBindArityZero) =
	  par["no","arguments","in","function","clause"]
      | ppError(FvalBindNameInconsistent vid) =
	  par["inconistent","function","name",ppVId vid,
	      "in","function","clause"]
      | ppError(FvalBindNameMissing) =
	  par["no","function","name","in","function","clause"]
      | ppError(FvalBindNameCon vid) =
	  par["redefining","constructor",ppVId vid,"as","value"]
      | ppError(FvalBindPatInvalid) =
	  par["invalid","function","clause"]
      | ppError(TypBindDuplicate tycon) =
	  par(["duplicate"] @ #2 classTyCon @
	      [ppTyCon tycon,"in","binding","group"])
      | ppError(DatBindDuplicate tycon) =
	  par(["duplicate"] @ #2 classTyCon @
	      [ppTyCon tycon,"in","binding","group"])
      | ppError(DatBindConDuplicate vid) =
	  par["duplicate","constructor",ppVId vid,"in","binding","group"]
      | ppError(ConBindDuplicate vid) =
	  par["duplicate","constructor",ppVId vid,"in","datatype"]
      | ppError(DconBindDuplicate vid) =
	  par["duplicate","constructor",ppVId vid,"in","binding","group"]
      | ppError(DconBindNonCon) =
	  par["non-constructor","on","constructor","binding",
	      "right","hand","side"]
      | ppError(StrBindDuplicate strid) =
	  par(["duplicate"] @ #2 classStrId @
	      [ppStrId strid,"in","binding","group"])
      | ppError(SigBindDuplicate sigid) =
	  par(["duplicate"] @ #2 classSigId @
	      [ppSigId sigid,"in","binding","group"])
      (* Specifications and descriptions *)
      | ppError(SpecFixDuplicate vid) =
	  par(["duplicate","fixity","specification","for"] @ #2 classVId @
	      [ppVId vid,"in","signature"])
      | ppError(SpecVIdDuplicate vid) =
	  par(["duplicate"] @ #2 classVId @ [ppVId vid,"in","signature"])
      | ppError(SpecTyConDuplicate tycon) =
	  par(["duplicate"] @ #2 classTyCon @ [ppTyCon tycon,"in","signature"])
      | ppError(SpecStrIdDuplicate strid) =
	  par(["duplicate"] @ #2 classStrId @ [ppStrId strid,"in","signature"])
      | ppError(SpecSigIdDuplicate sigid) =
	  par(["duplicate"] @ #2 classSigId @ [ppSigId sigid,"in","signature"])
      | ppError(ConDescDuplicate vid) =
	  par["duplicate","constructor",ppVId vid,"in","datatype"]
      | ppError(DconDescNonCon) =
	  par["non-constructor","on","constructor","description",
	      "right","hand","side"]
      (* Sharing translation *)
      | ppError(SharingExternalTy x) =
	  par(#2 classTyCon @ [ppId x,"is","external","to","signature"])
      | ppError(SharingExternalSig x) =
	  par(#2 classSigId @ [ppId x,"is","external","to","signature"])
      | ppError(SharingExternalStr x) =
	  par(#2 classStrId @ [ppId x,"is","external","to","signature"])


    fun ppShadowed((ppId,class), id) =
	  par(class @ [ppId id,"shadows","previous","one"])

    fun ppWarning(VIdShadowed vid) =
	  ppShadowed(classVId, vid)
      | ppWarning(TyConShadowed tycon) =
	  ppShadowed(classTyCon, tycon)
      | ppWarning(TyVarShadowed tyvar) =
	  ppShadowed(classTyVar, tyvar)
      | ppWarning(StrIdShadowed strid) =
	  ppShadowed(classStrId, strid)
      | ppWarning(SigIdShadowed sigid) =
	  ppShadowed(classSigId, sigid)


  (* Export *)

    fun errorToString e   = PrettyPrint.toString(ppError e, 75)
    fun warningToString w = PrettyPrint.toString(ppWarning w, 75)

    fun error(region, e)  = Error.error(region, errorToString e)
    fun warn(region, w)   = Error.warn(region, warningToString w)

  end
(* src # 89 *)
(*
 * Standard ML infix resolution
 *
 * Definition, section 2.6
 *)


signature INFIX =
  sig

    (* Import *)

    structure Grammar: INPUT_GRAMMAR = InputGrammar


    (* Infix environment *)

    datatype Assoc = LEFT | RIGHT
    type InfStatus = (Assoc * int) option

    type InfEnv    = VId.t -> InfStatus


    (* Resolving phrases containing infixed identifiers *)

    val exp :	InfEnv -> Grammar.Exp -> Grammar.Exp
    val pat :	InfEnv -> Grammar.Pat -> Grammar.Pat

  end
(* src # 90 *)
(*
 * Standard ML infix resolution
 *
 * Definition, section 2.6
 *)


structure Infix :> INFIX =
  struct

  (* Import *)

    structure Grammar = InputGrammar
    structure E       = ParsingError

    open Grammar

    val error = E.error


  (* Type definitions *)

    datatype Assoc = LEFT | RIGHT

    type InfStatus = (Assoc * int) option

    type InfEnv    = VId.t -> InfStatus


    (* Categorisation of atomic expressions and patterns *)

    datatype 'a FixityCategory = NONFIX of 'a
			       | INFIX  of Assoc * int * VId

    fun categoriseVId IE (at, vid as VId(i,vid')) =
	case IE vid'
	  of NONE             => NONFIX(at)
	   | SOME(assoc,prec) => INFIX(assoc, prec, vid)


    fun categoriseLongVId IE (at, SHORTLong(i, vid)) =
	    categoriseVId IE (at, vid)
      | categoriseLongVId IE (at, longvid) = NONFIX(at)

    fun categoriseAtExp IE (atexp as LONGVIDAtExp(i, SANSOp, longvid)) =
	    categoriseLongVId IE (atexp, longvid)
      | categoriseAtExp IE (atexp) = NONFIX(atexp)

    fun categoriseAtPat IE (atpat as LONGVIDAtPat(i, SANSOp, longvid)) =
	    categoriseLongVId IE (atpat, longvid)
      | categoriseAtPat IE (atpat) = NONFIX(atpat)



    (* Converting app expressions and patterns into atomic lists *)

    fun flattenExp'(ATEXPExp(i,atexp))   = atexp :: []
      | flattenExp'(APPExp(i,exp,atexp)) = atexp :: flattenExp' exp
      | flattenExp' _ = raise Crash.Crash "Infix.flattenExp: invalid expression"

    fun flattenExp exp = List.rev(flattenExp' exp)

    fun flattenPat'(ATPATPat(i,atpat))   = atpat :: []
      | flattenPat'(APPPat(i,pat,atpat)) = atpat :: flattenPat' pat
      | flattenPat' _ = raise Crash.Crash "Infix.flattenPat: invalid pattern"

    fun flattenPat pat = List.rev(flattenPat' pat)



    (* Resolving infixed expressions and patterns *)

    datatype ('a,'b) x = ATOMIC of 'a | NONATOMIC of 'b

    fun parse (ATXx, APPx, PARAtX, TUPLEAtX, LONGVIDAtX,
	       infoX, infoAtX, categorise, flatten) IE x =
	let
	    fun info(ATOMIC x)         = infoAtX x
	      | info(NONATOMIC x)      = infoX x

	    fun atomic(ATOMIC x)       = x
	      | atomic(NONATOMIC x)    = PARAtX(infoX x, x)

	    fun nonatomic(ATOMIC x)    = ATXx(infoAtX x, x)
	      | nonatomic(NONATOMIC x) = x

	    fun pair(x1,x2) =
		let
		    val x1' = nonatomic x1
		    val x2' = nonatomic x2
		in
		    TUPLEAtX(Source.over(info x1,info x2), [x1', x2'])
		end

	    fun apply(x1,x2) =
		let
		    val x1' = nonatomic x1
		    val x2' = atomic x2
		    val x'  = APPx(Source.over(info x1, info x2), x1', x2')
		in
		    NONATOMIC x'
		end

	    fun infapply(x1,vid,x2) =
		let
		    val i       = Source.over(info x1, info x2)
		    val i_vid   = infoVId vid
		    val longvid	= SHORTLong(i_vid, vid)
		    val x1'	= LONGVIDAtX(i_vid, WITHOp, longvid)
		    val x2'	= pair(x1,x2)
		    val x'      = APPx(i, ATXx(i_vid, x1'), x2')
		in
		    NONATOMIC x'
		end


	    fun loop(NONFIX(x)::[], []) = x

	      | loop(NONFIX(x2)::NONFIX(x1)::s', i) =
		    (* reduce nonfix application *)
		    loop(NONFIX(apply(x1, x2))::s', i)

	      | loop(s, NONFIX(x)::i') =
		    (* shift *)
		    loop(NONFIX(ATOMIC x)::s, i')

	      | loop(s as NONFIX(x)::[], INFIX(q)::i') =
		    (* shift *)
		    loop(INFIX(q)::s, i')

	      | loop(NONFIX(x2)::INFIX(a,p,vid)::NONFIX(x1)::s', []) =
		    (* reduce infix application *)
		    loop(NONFIX(infapply(x1, vid, x2))::s', [])

	      | loop(s as NONFIX(x2)::INFIX(a1,p1,vid1)::NONFIX(x1)::s',
		       i as INFIX(q2 as (a2,p2,vid2))::i') =
		if p1 > p2 then
		    (* reduce infix application *)
		    loop(NONFIX(infapply(x1, vid1, x2))::s', i)
		else if p1 < p2 then
		    (* shift *)
		    loop(INFIX(q2)::s, i')
		else if a1 <> a2 then
		    let
		        val VId(i1,vid1') = vid1
		        val VId(i2,vid2') = vid2
		    in
			error(Source.over(i1,i2), E.AssocConflict(vid1',vid2'))
		    end
		else if a1 = LEFT then
		    (* reduce infix application *)
		    loop(NONFIX(infapply(x1, vid1, x2))::s', i)
		else (* a1 = RIGHT *)
		    (* shift *)
		    loop(INFIX(q2)::s, i')

	      | loop(INFIX(a,p,VId(i,vid'))::s', []) =
		    error(i, E.InfixMisplaced vid')

	      | loop(INFIX(x)::s', INFIX(a,p,VId(i,vid'))::i') =
		    error(i, E.InfixMisplaced vid')

	      | loop([], INFIX(a,p,VId(i,vid'))::i') =
		    error(i, E.InfixMisplaced vid')

	      | loop _ = raise Crash.Crash "Infix.parse: inconsistency"

	    val x' = loop([], List.map (categorise IE) (flatten x))
	in
	    nonatomic x'
	end


    (* Expressions *)

    val exp = parse(ATEXPExp, APPExp, PARAtExp, TUPLEAtExp, LONGVIDAtExp,
		    infoExp, infoAtExp, categoriseAtExp, flattenExp)

    (* Patterns *)

    val pat = parse(ATPATPat, APPPat, PARAtPat, TUPLEAtPat, LONGVIDAtPat,
		    infoPat, infoAtPat, categoriseAtPat, flattenPat)

  end
(* src # 91 *)
signature BIND_ENV =
  sig

    type Lab   = Lab.t
    type VId   = VId.t
    type TyVar = TyVar.t
    type TyCon = TyCon.t
    type StrId = StrId.t
    type SigId = SigId.t

    type Info  = Source.region
    type stamp = AbstractGrammar.stamp

    datatype InfAssoc  = datatype Infix.Assoc
    type     InfStatus = Infix.InfStatus
    datatype IdStatus  = V | C of int | R

    type Env
    type Inf = Info * InfStatus
    type Fld = Info
    type Var = Info * stamp
    type Val = Info * stamp * IdStatus
    type Ty  = Info * stamp * Env
    type Str = Info * stamp * Env
    type Sig = Info * stamp * Env


    exception CollisionInf of VId
    exception CollisionFld of Lab
    exception CollisionVal of VId
    exception CollisionTy  of TyCon
    exception CollisionVar of TyVar
    exception CollisionStr of StrId
    exception CollisionSig of SigId


    val new :			unit -> Env

    val size :			Env -> int
    val sizeScope :		Env -> int

    val copy :			Env -> Env
    val copyScope :		Env -> Env

    val insertScope :		Env -> unit
    val deleteScope :		Env -> unit
    val mergeScope :		Env -> unit
    val mergeDisjointScope :	Env -> unit		(* Collision* *)
    val inheritScope :		Env * Env -> unit
    val splitScope :		Env -> Env

    val union :			Env * Env -> unit
    val unionDisjoint :		Env * Env -> unit	(* Collision* *)
    val unionCompose :		Env * Env -> unit
    val unionInf :		Env * Env -> unit

    val insertInf :		Env *  VId  * Inf -> unit
    val insertFld :		Env *  Lab  * Fld -> unit
    val insertVal :		Env *  VId  * Val -> unit
    val insertTy :		Env * TyCon * Ty  -> unit
    val insertVar :		Env * TyVar * Var -> unit
    val insertStr :		Env * StrId * Str -> unit
    val insertSig :		Env * SigId * Sig -> unit
    val insertDisjointInf :	Env *  VId  * Inf -> unit   (* CollisionInf *)
    val insertDisjointFld :	Env *  Lab  * Fld -> unit   (* CollisionFld *)
    val insertDisjointVal :	Env *  VId  * Val -> unit   (* CollisionVal *)
    val insertDisjointTy :	Env * TyCon * Ty  -> unit   (* CollisionTy *)
    val insertDisjointVar :	Env * TyVar * Var -> unit   (* CollisionVar *)
    val insertDisjointStr :	Env * StrId * Str -> unit   (* CollisionStr *)
    val insertDisjointSig :	Env * SigId * Sig -> unit   (* CollisionSig *)

    val lookupInf :		Env *  VId  -> Inf option
    val lookupFld :		Env *  Lab  -> Fld option
    val lookupVar :		Env * TyVar -> Var option
    val lookupVal :		Env *  VId  -> Val option
    val lookupTy :		Env * TyCon -> Ty  option
    val lookupStr :		Env * StrId -> Str option
    val lookupSig :		Env * SigId -> Sig option
    val lookupScopeInf :	Env *  VId  -> Inf option
    val lookupScopeFld :	Env *  Lab  -> Fld option
    val lookupScopeVar :	Env * TyVar -> Var option
    val lookupScopeVal :	Env *  VId  -> Val option
    val lookupScopeTy :		Env * TyCon -> Ty  option
    val lookupScopeStr :	Env * StrId -> Str option
    val lookupScopeSig :	Env * SigId -> Sig option

    val appiInfs :		( VId  * Inf -> unit) -> Env -> unit
    val appiFlds :		( Lab  * Fld -> unit) -> Env -> unit
    val appiVars :		(TyVar * Var -> unit) -> Env -> unit
    val appiVals :		( VId  * Val -> unit) -> Env -> unit
    val appiTys :		(TyCon * Ty  -> unit) -> Env -> unit
    val appiStrs :		(StrId * Str -> unit) -> Env -> unit
    val appiSigs :		(SigId * Sig -> unit) -> Env -> unit
    val appiScopeVals :		( VId  * Val -> unit) -> Env -> unit

    val foldiInfs :		( VId  * Inf * 'a -> 'a) -> 'a -> Env -> 'a
    val foldiFlds :		( Lab  * Fld * 'a -> 'a) -> 'a -> Env -> 'a
    val foldiVars :		(TyVar * Var * 'a -> 'a) -> 'a -> Env -> 'a
    val foldiVals :		( VId  * Val * 'a -> 'a) -> 'a -> Env -> 'a
    val foldiTys :		(TyCon * Ty  * 'a -> 'a) -> 'a -> Env -> 'a
    val foldiStrs :		(StrId * Str * 'a -> 'a) -> 'a -> Env -> 'a
    val foldiSigs :		(SigId * Sig * 'a -> 'a) -> 'a -> Env -> 'a

    val infEnv :		Env -> VId -> InfStatus

  end
(* src # 92 *)
structure BindEnv :> BIND_ENV =
  struct

    type Info  = Source.region
    type stamp = AbstractGrammar.stamp


    (* The environment's domain *)

    type Lab   = Lab.t
    type VId   = VId.t
    type TyVar = TyVar.t
    type TyCon = TyCon.t
    type StrId = StrId.t
    type SigId = SigId.t

    datatype Dom = INFIX of VId
		 | LAB   of Lab
		 | TYVAR of TyVar
		 | VID   of VId
		 | TYCON of TyCon
		 | STRID of StrId
		 | SIGID of SigId

    fun hashDom(INFIX id) = StringHashKey.hash(  VId.toString id)
      | hashDom(LAB   id) = StringHashKey.hash(  Lab.toString id)
      | hashDom(TYVAR id) = StringHashKey.hash(TyVar.toString id)
      | hashDom(VID   id) = StringHashKey.hash(  VId.toString id)
      | hashDom(TYCON id) = StringHashKey.hash(TyCon.toString id)
      | hashDom(STRID id) = StringHashKey.hash(StrId.toString id)
      | hashDom(SIGID id) = StringHashKey.hash(SigId.toString id)


    (* The map implementing the environment *)

    structure Map = MakeHashScopedImpMap(type t = Dom val hash = hashDom)


    (* The environment's range *)

    datatype InfAssoc  = datatype Infix.Assoc
    type     InfStatus = Infix.InfStatus
    datatype IdStatus  = V | C of int | R

    datatype Env = ENV of Ran Map.t
    and      Ran = INF of Inf
		 | FLD of Fld
		 | VAR of Var
		 | VAL of Val
		 | TY  of Ty
		 | STR of Str
		 | SIG of Sig

    withtype Inf = Info * InfStatus
    and      Fld = Info
    and      Var = Info * stamp
    and      Val = Info * stamp * IdStatus
    and      Ty  = Info * stamp * Env
    and      Str = Info * stamp * Env
    and      Sig = Info * stamp * Env

    fun asInfo(SOME(INF x)) = SOME x | asInfo _ = NONE
    fun asFldo(SOME(FLD x)) = SOME x | asFldo _ = NONE
    fun asVaro(SOME(VAR x)) = SOME x | asVaro _ = NONE
    fun asValo(SOME(VAL x)) = SOME x | asValo _ = NONE
    fun asTyo (SOME(TY  x)) = SOME x | asTyo  _ = NONE
    fun asStro(SOME(STR x)) = SOME x | asStro _ = NONE
    fun asSigo(SOME(SIG x)) = SOME x | asSigo _ = NONE

    fun appInf f (INFIX id, INF x) = f(id,x) | appInf f _ = ()
    fun appFld f (LAB   id, FLD x) = f(id,x) | appFld f _ = ()
    fun appVar f (TYVAR id, VAR x) = f(id,x) | appVar f _ = ()
    fun appVal f (VID   id, VAL x) = f(id,x) | appVal f _ = ()
    fun appTy  f (TYCON id, TY  x) = f(id,x) | appTy  f _ = ()
    fun appStr f (STRID id, STR x) = f(id,x) | appStr f _ = ()
    fun appSig f (SIGID id, SIG x) = f(id,x) | appSig f _ = ()

    fun foldInf f (INFIX id, INF x, a) = f(id,x,a) | foldInf f (_,_,a) = a
    fun foldFld f (LAB   id, FLD x, a) = f(id,x,a) | foldFld f (_,_,a) = a
    fun foldVar f (TYVAR id, VAR x, a) = f(id,x,a) | foldVar f (_,_,a) = a
    fun foldVal f (VID   id, VAL x, a) = f(id,x,a) | foldVal f (_,_,a) = a
    fun foldTy  f (TYCON id, TY  x, a) = f(id,x,a) | foldTy  f (_,_,a) = a
    fun foldStr f (STRID id, STR x, a) = f(id,x,a) | foldStr f (_,_,a) = a
    fun foldSig f (SIGID id, SIG x, a) = f(id,x,a) | foldSig f (_,_,a) = a


    (* Collision exceptions *)

    exception CollisionInf of VId
    exception CollisionFld of Lab
    exception CollisionVal of VId
    exception CollisionTy  of TyCon
    exception CollisionVar of TyVar
    exception CollisionStr of StrId
    exception CollisionSig of SigId

    fun transformCollision(INFIX id)	= raise CollisionInf id
      | transformCollision(LAB   id)	= raise CollisionFld id
      | transformCollision(TYVAR id)	= raise CollisionVar id
      | transformCollision(VID   id)	= raise CollisionVal id
      | transformCollision(TYCON id)	= raise CollisionTy  id
      | transformCollision(STRID id)	= raise CollisionStr id
      | transformCollision(SIGID id)	= raise CollisionSig id


    (* Actual operations *)

    fun new()				= ENV(Map.new())
    fun copy(ENV E)			= ENV(Map.copy E)
    fun copyScope(ENV E)		= ENV(Map.copyScope E)
    fun splitScope(ENV E)		= ENV(Map.splitScope E)

    fun insertScope(ENV E)		= Map.insertScope E
    fun inheritScope(ENV E1, ENV E2)	= Map.inheritScope(E1,E2)
    fun deleteScope(ENV E)		= Map.deleteScope E
    fun mergeScope(ENV E)		= Map.mergeScope E
    fun mergeDisjointScope(ENV E)	= Map.mergeDisjointScope E
					  handle Map.Collision coll =>
						 transformCollision coll

    fun union(ENV E1, ENV E2)		= Map.union(E1,E2)
    fun unionDisjoint(ENV E1, ENV E2)	= Map.unionDisjoint(E1,E2)
					  handle Map.Collision coll =>
						 transformCollision coll

    fun size(ENV E)			= Map.size E
    fun sizeScope(ENV E)		= Map.sizeScope E

    fun insertInf(ENV E, id, x)		= Map.insert(E, INFIX id, INF x)
    fun insertFld(ENV E, id, x)		= Map.insert(E, LAB   id, FLD x)
    fun insertVar(ENV E, id, x)		= Map.insert(E, TYVAR id, VAR x)
    fun insertVal(ENV E, id, x)		= Map.insert(E, VID   id, VAL x)
    fun insertTy (ENV E, id, x)		= Map.insert(E, TYCON id, TY  x)
    fun insertStr(ENV E, id, x)		= Map.insert(E, STRID id, STR x)
    fun insertSig(ENV E, id, x)		= Map.insert(E, SIGID id, SIG x)

    fun insertDisjointInf(ENV E, id, x)	= Map.insertDisjoint(E, INFIX id, INF x)
					  handle Map.Collision(INFIX id) =>
						 raise CollisionInf id
    fun insertDisjointFld(ENV E, id, x)	= Map.insertDisjoint(E, LAB id, FLD x)
					  handle Map.Collision(LAB id) =>
						 raise CollisionFld id
    fun insertDisjointVar(ENV E, id, x)	= Map.insertDisjoint(E, TYVAR id, VAR x)
					  handle Map.Collision(TYVAR id) =>
						 raise CollisionVar id
    fun insertDisjointVal(ENV E, id, x)	= Map.insertDisjoint(E, VID id, VAL x)
					  handle Map.Collision(VID id) =>
						 raise CollisionVal id
    fun insertDisjointTy(ENV E, id, x)	= Map.insertDisjoint(E, TYCON id, TY x)
					  handle Map.Collision(TYCON id) =>
						 raise CollisionTy id
    fun insertDisjointStr(ENV E, id, x)	= Map.insertDisjoint(E, STRID id, STR x)
					  handle Map.Collision(STRID id) =>
						 raise CollisionStr id
    fun insertDisjointSig(ENV E, id, x)	= Map.insertDisjoint(E, SIGID id, SIG x)
					  handle Map.Collision(SIGID id) =>
						 raise CollisionSig id

    fun lookupInf(ENV E, id)		= asInfo(Map.lookup(E, INFIX id))
    fun lookupFld(ENV E, id)		= asFldo(Map.lookup(E, LAB   id))
    fun lookupVar(ENV E, id)		= asVaro(Map.lookup(E, TYVAR id))
    fun lookupVal(ENV E, id)		= asValo(Map.lookup(E, VID   id))
    fun lookupTy (ENV E, id)		= asTyo (Map.lookup(E, TYCON id))
    fun lookupStr(ENV E, id)		= asStro(Map.lookup(E, STRID id))
    fun lookupSig(ENV E, id)		= asSigo(Map.lookup(E, SIGID id))

    fun lookupScopeInf(ENV E, id)	= asInfo(Map.lookupScope(E, INFIX id))
    fun lookupScopeFld(ENV E, id)	= asFldo(Map.lookupScope(E, LAB   id))
    fun lookupScopeVar(ENV E, id)	= asVaro(Map.lookupScope(E, TYVAR id))
    fun lookupScopeVal(ENV E, id)	= asValo(Map.lookupScope(E, VID   id))
    fun lookupScopeTy (ENV E, id)	= asTyo (Map.lookupScope(E, TYCON id))
    fun lookupScopeStr(ENV E, id)	= asStro(Map.lookupScope(E, STRID id))
    fun lookupScopeSig(ENV E, id)	= asSigo(Map.lookupScope(E, SIGID id))

    fun appiInfs f (ENV E)		= Map.appi (appInf f) E
    fun appiFlds f (ENV E)		= Map.appi (appFld f) E
    fun appiVars f (ENV E)		= Map.appi (appVar f) E
    fun appiVals f (ENV E)		= Map.appi (appVal f) E
    fun appiTys  f (ENV E)		= Map.appi (appTy  f) E
    fun appiStrs f (ENV E)		= Map.appi (appStr f) E
    fun appiSigs f (ENV E)		= Map.appi (appSig f) E
    fun appiScopeVals f (ENV E)		= Map.appiScope (appVal f) E

    fun foldiInfs f a (ENV E)		= Map.foldi (foldInf f) a E
    fun foldiFlds f a (ENV E)		= Map.foldi (foldFld f) a E
    fun foldiVars f a (ENV E)		= Map.foldi (foldVar f) a E
    fun foldiVals f a (ENV E)		= Map.foldi (foldVal f) a E
    fun foldiTys  f a (ENV E)		= Map.foldi (foldTy  f) a E
    fun foldiStrs f a (ENV E)		= Map.foldi (foldStr f) a E
    fun foldiSigs f a (ENV E)		= Map.foldi (foldSig f) a E


    fun unionInf(E1,E2)			= appiInfs (fn(id,x) =>
						     insertInf(E1,id,x)) E2

    fun unionCompose(ENV E1, ENV E2)		= Map.unionWith compose (E1,E2)

    and compose(INF(I1,fix1),   INF(I2,fix2))	= INF(I1,fix2)
      | compose(FLD(I1),        FLD(I2))	= FLD(I1)
      | compose(VAR(I1,z1),     VAR(I2,z2))	= VAR(I1,z1)
      | compose(VAL(I1,z1,is1), VAL(I2,z2,is2))	= VAL(I1,z1,
						    composeIdStatus(is1,is2))
      | compose(TY (I1,z1,E1),  TY (I2,z2,E2))	= ( unionCompose(E1,E2)
						  ; TY(I1,z1,E1) )
      | compose(STR(I1,z1,E1),  STR(I2,z2,E2))	= ( unionCompose(E1,E2)
						  ; STR(I1,z1,E1) )
      | compose(SIG(I1,z1,E1),  SIG(I2,z2,E2))	= ( unionCompose(E1,E2)
						  ; SIG(I1,z1,E1) )
      | compose _				= raise Crash.Crash
							"BindEnv.compose"
    and composeIdStatus(V, is)			= is
      | composeIdStatus(is, V)			= is
      | composeIdStatus(is1, is2)		= is2


    fun infEnv E vid				= case lookupInf(E, vid)
						    of NONE        => NONE
						     | SOME(_,inf) => inf

  end
(* src # 93 *)
signature SHARING =
  sig

    type spec   = AbstractGrammar.spec
    type longid = AbstractGrammar.longid

    val shareTyp :	spec list * longid list -> spec list  (* -> reversed *)
    val shareSig :	spec list * longid list -> spec list  (* -> reversed *)
    val shareStr :	spec list * longid list -> spec list  (* -> reversed *)

  end
(* src # 94 *)
(*
 * Translation of sharing constraints.
 *
 * The algorithm takes a list of specs and a list of longids inducing sharing
 * upon the specs and works as follows:
 * 1. Build annotated specs, that pair each longid with the spec it refers to.
 * 2. Look for the first spec now annotated with a longid, take this longid as
 *    the original object.
 * 3. Transform each remaining annotated spec to express the induced sharing
 *    equivalence. For a type or signature spec this is done by replacing it
 *    with an appropriate manifest spec (blindly overwriting the spec - there is
 *    no check for either rigidness or kind consistency). For a structures its
 *    signature is intersected with an appropriate specialisation. Note that
 *    even type sharing constraints with longids effect only structure specs.
 *)

structure Sharing :> SHARING =
  struct

    open AbstractGrammar

    nonfix mod

  (* Class *)

    datatype class = TYP | SIG | STR

  (* Error handling *)

    structure E = AbstractionError

    fun error(class, LongId(_, longid, _)) = error(STR, longid)
      | error(TYP, ShortId(i,id)) = E.error(i, E.SharingExternalTy id)
      | error(SIG, ShortId(i,id)) = E.error(i, E.SharingExternalSig id)
      | error(STR, ShortId(i,id)) = E.error(i, E.SharingExternalStr id)

  (* Find ids in a list of longids *)

    fun isRootedAt(ShortId(_, id),       stamp') = stamp id = stamp'
      | isRootedAt(LongId(_, longid, _), stamp') = isRootedAt(longid, stamp')

    fun findId(stamp, [], longids') = NONE
      | findId(stamp, longid::longids, longids') =
	if isRootedAt(longid, stamp)
	then SOME(longid, longids' @ longids)
	else findId(stamp, longids, longid::longids')


  (* Annotated specifications *)

    datatype annotated_spec =
	  Plain     of spec
	| Annotated of spec * longid
	| Recursive of info * annotated_spec list
	| Local     of info * annotated_spec list
	(* UNFINISHED: what about ExtSpec? *)


    fun cons1st(x, (xs,y)) = (x::xs, y)

    fun annotate( spec as ( TypSpec(_, id, _)
			  | DatSpec(_, id, _)
			  | ModSpec(_, id, _)
			  | InfSpec(_, id, _) ), longids) =
	(case findId(stamp id, longids, [])
	   of SOME(longid,longids') => ( Annotated(spec,longid), longids' )
	    | NONE                  => ( Plain(spec), longids )
	)
      | annotate(RecSpec(i, specs), longids) =
	let val (specs',longids') = annotateList(specs, longids) in
	    ( Recursive(i, specs'), longids' )
	end
      | annotate(LocalSpec(i, specs), longids) =
	let val (specs',longids') = annotateList(specs, longids) in
	    ( Local(i, specs'), longids' )
	end
      | annotate(spec, longids) =
	    ( Plain(spec), longids )

    and annotateList(    [],      longids) = ([], longids)
      | annotateList(spec::specs, longids) =
	let val (spec',longids') = annotate(spec, longids) in
	    cons1st(spec', annotateList(specs, longids'))
	end


  (* Convert annotated spec to spec with where constraints *)

    fun longidToMod(ShortId(i, id))         = VarMod(i, id)
      | longidToMod(LongId(i, longid, lab)) = SelMod(i, longidToMod longid, lab)

    fun singleton(inf, longid) =
	let
	    val i   = Source.over(infoInf inf, infoLongid longid)
	    val mod = AnnMod(i, longidToMod longid, inf)
	in
	    SingInf(i, mod)
	end

    fun labToId(Lab(i, s))  = Id(i, Stamp.new(), Name.ExId s)

    fun constrain(class, inf1, ShortId _, longid) =
	    raise Crash.Crash "Sharing.constrain"
      | constrain(class, inf1, LongId(i, longid', lab), longid) =
	let
	    fun buildSig(ShortId(i, id), inf) = inf
	      | buildSig(LongId(_, longid, lab), inf) =
		let val i = infoLab lab in
		    SigInf(i, [ModSpec(i, labToId lab, inf)])
		end

	    val i0    = infoLab lab
	    val i1    = infoLongid longid
	    val id0   = labToId lab
	    val spec0 = case class
			  of TYP => TypSpec(i0, id0, ConTyp(i1, longid))
			   | SIG => InfSpec(i0, id0, ConInf(i1, longid))
			   | STR => ModSpec(i0, id0,
					    SingInf(i1, longidToMod longid))
	    val inf2  = buildSig(longid', SigInf(i0, [spec0]))
	in
	    CompInf(Source.over(infoInf inf1, i), inf1, inf2)
	end


    (* UNFINISHED: no error checks for non-qualified types and interfaces *)

    fun withWhere(TYP, TypSpec(i, id, typ), _, longid) =
	    TypSpec(i, id, ConTyp(infoLongid longid, longid))
      | withWhere(TYP, DatSpec(i, id, typ), _, longid) =
	    DatSpec(i, id, ConTyp(infoLongid longid, longid))
      | withWhere(SIG, InfSpec(i, id, inf), _, longid) =
	    InfSpec(i, id, ConInf(infoLongid longid, longid))
      | withWhere(STR, ModSpec(i, id, inf), ShortId _, longid) =
	    ModSpec(i, id, singleton(inf, longid))
      | withWhere(class, ModSpec(i, id, inf), longid', longid) =
	    ModSpec(i, id, constrain(class, inf, longid', longid))
      | withWhere _ = raise Crash.Crash "Sharing.withWhere"


  (* Map where constraints over list of annotated specs *)

    (* find 1st annotation *)
    fun mapWhere(class, []) = raise Crash.Crash "Sharing.mapWhere"
      | mapWhere(class, Plain(spec)::specs') =
	    spec :: mapWhere(class, specs')
      | mapWhere(class, Annotated(spec, longid)::specs') =
	    spec :: mapWhere''(class, specs', longid)
      | mapWhere(class, Recursive(i, specs'')::specs') =
	(case mapWhere'(class, specs'')
	   of (specs, NONE) =>
		RecSpec(i,specs) :: mapWhere(class, specs')
	    | (specs, SOME longid) =>
		RecSpec(i,specs) :: mapWhere''(class, specs', longid)
	)
      | mapWhere(class, Local(i, specs'')::specs') =
	(case mapWhere'(class, specs'')
	   of (specs, NONE) =>
		LocalSpec(i,specs) :: mapWhere(class, specs')
	    | (specs, SOME longid) => 
		LocalSpec(i,specs) :: mapWhere''(class, specs', longid)
	)

    (* find 1st annotation in nested lists *)
    and mapWhere'(class, []) = raise Crash.Crash "Sharing.mapWhere'"
      | mapWhere'(class, Plain(spec)::specs') =
	    cons1st(spec, mapWhere'(class, specs'))
      | mapWhere'(class, Annotated(spec, longid)::specs') =
	    ( spec :: mapWhere''(class, specs', longid), SOME longid )
      | mapWhere'(class, Recursive(i, specs'')::specs') =
	(case mapWhere'(class, specs'')
	   of (specs, NONE) =>
		cons1st(RecSpec(i,specs), mapWhere'(class, specs'))
	    | (specs, some as SOME longid) =>
		( RecSpec(i,specs) :: mapWhere''(class, specs', longid), some )
	)
      | mapWhere'(class, Local(i, specs'')::specs') =
	(case mapWhere'(class, specs'')
	   of (specs, NONE) =>
		cons1st(LocalSpec(i,specs), mapWhere'(class, specs'))
	    | (specs, some as SOME longid) =>
		( LocalSpec(i,specs) :: mapWhere''(class, specs',longid), some )
	)

    (* transform remaining annotations *)
    and mapWhere''(class, [], longid) = []
      | mapWhere''(class, Plain(spec)::specs', longid) =
	    spec :: mapWhere''(class, specs', longid)
      | mapWhere''(class, Annotated(spec, longid')::specs', longid) =
	    withWhere(class, spec, longid', longid)
		:: mapWhere''(class, specs', longid)
      | mapWhere''(class, Recursive(i, specs'')::specs', longid) =
	    RecSpec(i, mapWhere''(class, specs'',longid))
		:: mapWhere''(class, specs',longid)
      | mapWhere''(class, Local(i, specs'')::specs', longid) =
	    LocalSpec(i, mapWhere''(class, specs'',longid))
		:: mapWhere''(class, specs',longid)


  (* Sharing *)

    fun share class (specs, longids) =
	case annotateList(specs, longids)
	  of (specs', longid::_) => error(class, longid)
	   | (specs',       [] ) => mapWhere(class, specs')

    val shareTyp = share TYP
    val shareSig = share SIG
    val shareStr = share STR

  end
(* src # 95 *)
signature ABSTRACTION_PHASE =
  sig

    structure I : INPUT_GRAMMAR    = InputGrammar
    structure O : ABSTRACT_GRAMMAR = AbstractGrammar

    type Env = BindEnv.Env

    val translate :	Env -> I.Component -> O.component

  end
(* src # 96 *)
structure AbstractionPhase :> ABSTRACTION_PHASE =
  struct

    structure I   = InputGrammar
    structure O   = AbstractGrammar
    structure E   = AbstractionError
    structure Env = BindEnv

    open I
    open Env


  (* Error handling *)

    val error = E.error
    val warn  = E.warn

    fun errorVId(E, vid', Error) =
	error((#1 o Option.valOf o lookupVal)(E, vid'), Error vid')


  (* Miscellanous helpers *)

    fun prebound E =
	case lookupStr(E, StrId.fromString "")
	  of SOME x => x
	   | NONE   => raise Crash.Crash "AbstractionPhase: prebounds not found"

    fun stamp_prebound E = #2 (prebound E)
    fun Env_prebound   E = #3 (prebound E)

    fun inventId i = O.Id(i, Stamp.new(), O.InId)

    fun idToLab(O.Id(i, stamp, O.ExId s)) = O.Lab(i, s)
      | idToLab _ = raise Crash.Crash "idToLab: InId encountered"

    fun longidToMod(O.ShortId(i, id))         = O.VarMod(i, id)
      | longidToMod(O.LongId(i, longid, lab)) =
	    O.SelMod(i, longidToMod longid, lab)

    fun tupexp(i, [exp]) = exp
      | tupexp(i,  exps) = O.TupExp(i, exps)

    fun tuppat(i, [pat]) = pat
      | tuppat(i,  pats) = O.TupPat(i, pats)

    fun annexp(exp,    []    ) = exp
      | annexp(exp, typ::typs) = annexp(O.AnnExp(O.infoTyp typ, exp, typ), typs)


    fun alltyp(ids,typ) =
	List.foldr (fn(id,typ) => O.AllTyp(O.infoTyp typ, id, typ)) typ ids

    fun funtyp(ids,typ) =
	List.foldr (fn(id,typ) => O.FunTyp(O.infoTyp typ, id, typ)) typ ids

    fun apptyp(typs,typ) =
	List.foldl (fn(typ1,typ2) =>
	      O.AppTyp(Source.over(O.infoTyp typ1, O.infoTyp typ2), typ2, typ1)
	    ) typ typs

    fun arrtyp(typs,typ) =
	List.foldr (fn(typ1,typ2) =>
	      O.ArrTyp(Source.over(O.infoTyp typ1, O.infoTyp typ2), typ1, typ2)
	    ) typ typs

    fun funinf(idinfs,inf) =
	List.foldr (fn((id,inf1),inf2) =>
	      O.FunInf(Source.over(O.infoId id, O.infoInf inf2), id, inf1, inf2)
	    ) inf idinfs

    fun vardec(ids,dec) =
	List.foldr (fn(id,dec) => O.VarDec(O.infoId id, id, dec)) dec ids

    fun varspec(ids,spec) =
	List.foldr (fn(id,spec) => O.VarSpec(O.infoId id, id, spec)) spec ids


    fun lookupIdStatus(E, vid') =
	case lookupVal(E, vid')
	  of NONE             => V
	   | SOME(i,stamp,is) => is



  (* Constants and identifiers *)

    fun trSCon E =
	fn SCon(i, SCon.INT n)		=> O.IntLit n
	 | SCon(i, SCon.WORD w)		=> O.WordLit w
	 | SCon(i, SCon.CHAR c)		=> O.CharLit c
	 | SCon(i, SCon.STRING s)	=> O.StringLit s
	 | SCon(i, SCon.REAL x)		=> O.RealLit x

    fun trLab E (Lab(i, lab)) = O.Lab(i, Lab.toString lab)

    fun trTyVar E (tyvar as TyVar(i, tyvar')) =
	let
	    val (_,stamp) =
		case lookupVar(E, tyvar')
		  of SOME xx => xx
		   | NONE    => error(i, E.TyVarUnbound tyvar')
	in
	    O.Id(i, stamp, O.ExId(TyVar.toString tyvar'))
	end

    fun trId (lookup,infoId,idId,toString,Unbound) E id =
	let
	    val i   = infoId id
	    val id' = idId id
	    val (_,stamp,x) = case lookup(E, id')
				of SOME xx => xx
				 | NONE    => error(i, Unbound id')
	in
	    ( O.Id(i, stamp, O.ExId(toString id')), x )
	end

    val trVId   = trId(lookupVal, infoVId, idVId, VId.toString, E.VIdUnbound)
    val trTyCon = trId(lookupTy, infoTyCon, idTyCon,
			TyCon.toString, E.TyConUnbound)
    val trStrId = trId(lookupStr, infoStrId, idStrId,
			StrId.toString, E.StrIdUnbound)
    val trSigId = trId(lookupSig, infoSigId, idSigId,
			SigId.toString, E.SigIdUnbound)


    fun trId_bind (lookup,infoId,idId,toString,Shadowed) E id =
	let
	    val i     = infoId id
	    val id'   = idId id
	    val name  = toString id'
	    val stamp = Stamp.new()
	    val _     = if not(Option.isSome(lookup(E, id'))) then () else
			   warn(i, Shadowed id')
	in
	    ( O.Id(i, stamp, O.ExId name), stamp )
	end


    val trTyVar_bind = trId_bind(lookupVar, infoTyVar, idTyVar, TyVar.toString,
				 E.TyVarShadowed)
    val trVId_bind   = trId_bind(lookupVal, infoVId,   idVId,   VId.toString,
				 E.VIdShadowed)
    val trTyCon_bind = trId_bind(lookupTy,  infoTyCon, idTyCon, TyCon.toString,
				 E.TyConShadowed)
    val trStrId_bind = trId_bind(lookupStr, infoStrId, idStrId, StrId.toString,
				 E.StrIdShadowed)
    val trSigId_bind = trId_bind(lookupSig, infoSigId, idSigId, SigId.toString,
				 E.SigIdShadowed)


    (* With polymorphic recursion we could avoid the following code
       duplication... *)

    fun trLongStrId' E =
	fn SHORTLong(i, strid) =>
	   let
		val (id',E') = trStrId E strid
	   in
		if O.stamp id' = stamp_prebound E then
		    ( NONE, E' )
		else
		    ( SOME(O.ShortId(i,id')), E' )
	   end

	 | DOTLong(i, longstrid, strid) =>
	   let
		val (longido',E') = trLongStrId' E longstrid
		val (id',x)       = trStrId E' strid
		val  longid'      =
		     case longido'
		       of SOME longid' => O.LongId(i, longid', idToLab id')
			| NONE         => O.ShortId(i, id')

	   in
		( SOME longid', x )
	   end

    fun trLongId trId E =
	fn SHORTLong(i, id) =>
	   let
		val (id',x) = trId E id
	   in
		if O.stamp id' = stamp_prebound E then
		    error(i, E.PreboundFirstClass)
		else
		    ( O.ShortId(i,id'), x )
	   end

	 | DOTLong(i, longstrid, id) =>
	   let
		val (longido',E') = trLongStrId' E longstrid
		val (id',x)       = trId E' id
	   in
		case longido'
		  of SOME longid' => ( O.LongId(i,longid', idToLab id'), x )
		   | NONE         => ( O.ShortId(i,id'), x )
	   end

    val trLongVId   = trLongId trVId
    val trLongTyCon = trLongId trTyCon
    val trLongStrId = trLongId trStrId
    val trLongSigId = trLongId trSigId



  (* Calculate sets of unguarded explicit type variables [Section 4.6] *)

    fun ? tyvarsX E  NONE    = []
      | ? tyvarsX E (SOME x) = tyvarsX E x

    fun unguardedTyVarsAtExp E (RECORDAtExp(_, exprow_opt)) =
	    ?unguardedTyVarsExpRow E exprow_opt

      | unguardedTyVarsAtExp E ( TUPLEAtExp(_, exps)
			       | VECTORAtExp(_, exps)
			       | SEQAtExp(_, exps) ) =
	    List.concat(List.map (unguardedTyVarsExp E) exps)

      | unguardedTyVarsAtExp E (LETAtExp(_, dec, exp)) =
	    unguardedTyVarsDec E dec @ unguardedTyVarsExp E exp

      | unguardedTyVarsAtExp E (PARAtExp(_, exp)) =
	    unguardedTyVarsExp E exp

      | unguardedTyVarsAtExp E _ = []

    and unguardedTyVarsExpRow E (ROWExpRow(_, lab, exp, exprow_opt)) =
	    unguardedTyVarsExp E exp @ ?unguardedTyVarsExpRow E exprow_opt

    and unguardedTyVarsExp E (ATEXPExp(_, atexp)) =
	    unguardedTyVarsAtExp E atexp

      | unguardedTyVarsExp E (APPExp(_, exp, atexp)) =
	    unguardedTyVarsExp E exp @ unguardedTyVarsAtExp E atexp

      | unguardedTyVarsExp E (TYPEDExp(_, exp, ty)) =
	    unguardedTyVarsExp E exp @ unguardedTyVarsTy E ty

      | unguardedTyVarsExp E ( ANDALSOExp(_, exp1, exp2)
			     | ORELSEExp(_, exp1, exp2)
			     | WHILEExp(_, exp1, exp2) ) =
	    unguardedTyVarsExp E exp1 @ unguardedTyVarsExp E exp2

      | unguardedTyVarsExp E (HANDLEExp(_, exp, match)) =
	    unguardedTyVarsExp E exp @ unguardedTyVarsMatch E match

      | unguardedTyVarsExp E (RAISEExp(_, exp)) =
	    unguardedTyVarsExp E exp

      | unguardedTyVarsExp E (IFExp(_, exp1, exp2, exp3)) =
	    unguardedTyVarsExp E exp1 @ unguardedTyVarsExp E exp2 @
	    unguardedTyVarsExp E exp3

      | unguardedTyVarsExp E (CASEExp(_, exp, match)) =
	    unguardedTyVarsExp E exp @ unguardedTyVarsMatch E match

      | unguardedTyVarsExp E (FNExp(_, match)) =
	    unguardedTyVarsMatch E match

      | unguardedTyVarsExp E (PACKExp(_, longstrid)) =
	    []

    and unguardedTyVarsMatch E (Match(_, mrule, match_opt)) =
	    unguardedTyVarsMrule E mrule @ ?unguardedTyVarsMatch E match_opt

    and unguardedTyVarsMrule E (Mrule(_, pat, exp)) =
	    unguardedTyVarsPat E pat @ unguardedTyVarsExp E exp

    and unguardedTyVarsDec E (CONSTRUCTORDec(_, dconbind)) =
	    unguardedTyVarsDconBind E dconbind

      | unguardedTyVarsDec E (STRUCTUREDec(_, strbind)) =
	    unguardedTyVarsStrBind E strbind

      | unguardedTyVarsDec E ( LOCALDec(_, dec1, dec2)
			     | SEQDec(_, dec1, dec2) ) =
	    unguardedTyVarsDec E dec1 @ unguardedTyVarsDec E dec2

      | unguardedTyVarsDec E _ = []

    and unguardedTyVarsValBind E (PLAINValBind(_, pat, exp, valbind_opt)) =
	    unguardedTyVarsPat E pat @ unguardedTyVarsExp E exp @
	    ?unguardedTyVarsValBind E valbind_opt

      | unguardedTyVarsValBind E (RECValBind(_, valbind)) =
	    unguardedTyVarsValBind E valbind

    and unguardedTyVarsFvalBind E (FvalBind(_, match, fvalbind_opt)) =
	    unguardedTyVarsMatch E match @
	    ?unguardedTyVarsFvalBind E fvalbind_opt

    and unguardedTyVarsDconBind E (NEWDconBind(_, _, vid, ty_opt, tyvarseq,
						     longtycon, dconbind_opt)) =
	let
	    val  _   = insertScope E
	    val  _   = trTyVarSeq E tyvarseq
	    val  _   = insertScope E
	    val ids' = ?unguardedTyVarsTy E ty_opt
	    val  E'  = splitScope E
	    val  _   = deleteScope E
	    val  _   = union(E,E')
	in
	    ids' @ ?unguardedTyVarsDconBind E dconbind_opt
	end

      | unguardedTyVarsDconBind E (EQUALDconBind(_, _,vid, _,longvid,
								dconbind_opt)) =
	    ?unguardedTyVarsDconBind E dconbind_opt

    and unguardedTyVarsStrBind E (StrBind(_, strid, strexp, strbind_opt)) =
	    unguardedTyVarsStrExp E strexp @
	    ?unguardedTyVarsStrBind E strbind_opt

    and unguardedTyVarsAtPat E (RECORDAtPat(_, patrow_opt)) =
	    ?unguardedTyVarsPatRow E patrow_opt

      | unguardedTyVarsAtPat E ( TUPLEAtPat(_, pats)
			       | VECTORAtPat(_, pats)
			       | ALTAtPat(_, pats) ) =
	    List.concat(List.map (unguardedTyVarsPat E) pats)

      | unguardedTyVarsAtPat E (PARAtPat(_, pat)) =
	    unguardedTyVarsPat E pat

      | unguardedTyVarsAtPat E _ = []

    and unguardedTyVarsPatRow E (WILDCARDPatRow(_)) = []

      | unguardedTyVarsPatRow E (ROWPatRow(_, lab, pat, patrow_opt)) =
	    unguardedTyVarsPat E pat @ ?unguardedTyVarsPatRow E patrow_opt

    and unguardedTyVarsPat E (ATPATPat(_, atpat)) =
	    unguardedTyVarsAtPat E atpat

      | unguardedTyVarsPat E (APPPat(_, pat, atpat)) =
	    unguardedTyVarsPat E pat @ unguardedTyVarsAtPat E atpat

      | unguardedTyVarsPat E (TYPEDPat(_, pat, ty)) =
	    unguardedTyVarsPat E pat @ unguardedTyVarsTy E ty

      | unguardedTyVarsPat E (NONPat(_, pat)) =
	    unguardedTyVarsPat E pat

      | unguardedTyVarsPat E (ASPat(_, pat1, pat2)) =
	    unguardedTyVarsPat E pat1 @ unguardedTyVarsPat E pat2

      | unguardedTyVarsPat E (WHENPat(_, pat, atexp)) =
	    unguardedTyVarsPat E pat @ unguardedTyVarsAtExp E atexp

      | unguardedTyVarsPat E (WITHVALPat(_, pat, valbind)) =
	    unguardedTyVarsPat E pat @ unguardedTyVarsValBind E valbind

      | unguardedTyVarsPat E (WITHFUNPat(_, pat, fvalbind)) =
	    unguardedTyVarsPat E pat @ unguardedTyVarsFvalBind E fvalbind

    and unguardedTyVarsTy E (TYVARTy(_, tyvar as TyVar(i,tyvar'))) =
	if Option.isSome(lookupVar(E, tyvar')) then
	    []
	else
	let
	    val (id',stamp) = trTyVar_bind E tyvar
	    val  _          = insertVar(E, tyvar', (i, stamp))
	in
	    [id']
	end

      | unguardedTyVarsTy E (RECORDTy(_, tyrow_opt)) =
	    ?unguardedTyVarsTyRow E tyrow_opt

      | unguardedTyVarsTy E (TUPLETy(_, tys)) =
	    List.concat(List.map (unguardedTyVarsTy E) tys)

      | unguardedTyVarsTy E (TYCONTy(_, tyseq, longtycon)) =
	    unguardedTyVarsTyseq E tyseq

      | unguardedTyVarsTy E (ARROWTy(_, ty, ty')) =
	    unguardedTyVarsTy E ty @ unguardedTyVarsTy E ty'

      | unguardedTyVarsTy E (PACKTy(_, longsigid)) =
	    []

      | unguardedTyVarsTy E (PARTy(_, ty)) =
	    unguardedTyVarsTy E ty

    and unguardedTyVarsTyRow E (ROWTyRow(_, lab, ty, tyrow_opt)) =
	    unguardedTyVarsTy E ty @ ?unguardedTyVarsTyRow E tyrow_opt

    and unguardedTyVarsTyseq E (Seq(_, tys)) =
	    List.concat(List.map (unguardedTyVarsTy E) tys)

    and unguardedTyVarsAtStrExp E (STRUCTAtStrExp(_, dec)) =
	    unguardedTyVarsDec E dec

      | unguardedTyVarsAtStrExp E (LONGSTRIDAtStrExp(_, longstrid)) =
	    []

      | unguardedTyVarsAtStrExp E (LETAtStrExp(_, dec, strexp)) =
	    unguardedTyVarsDec E dec @ unguardedTyVarsStrExp E strexp

      | unguardedTyVarsAtStrExp E (PARAtStrExp(_, strexp)) =
	    unguardedTyVarsStrExp E strexp

    and unguardedTyVarsStrExp E (ATSTREXPStrExp(_, atstrexp)) =
	    unguardedTyVarsAtStrExp E atstrexp

      | unguardedTyVarsStrExp E (APPStrExp(_, strexp, atstrexp)) =
	    unguardedTyVarsStrExp E strexp @ unguardedTyVarsAtStrExp E atstrexp

      | unguardedTyVarsStrExp E ( TRANSStrExp(_, strexp, _)
				| OPAQStrExp(_, strexp, _)
				| FCTStrExp(_, _, strexp) ) =
	    unguardedTyVarsStrExp E strexp

      | unguardedTyVarsStrExp E (UNPACKStrExp(_, exp, sigexp)) =
	    unguardedTyVarsExp E exp

      (*UNFINISHED: if we have LETSigExp then we must check sigexps as well*)



  (* Expressions *)

    and trAtExp E =
	fn SCONAtExp(i, scon)		=> O.LitExp(i, trSCon E scon)
	 | LONGVIDAtExp(i, _, longvid)	=>
	   (case trLongVId E longvid
	      of (longid', V) =>
		 O.VarExp(i, longid')

	       | (longid', C k) =>
		 O.ConExp(i, k, longid')

	       | (longid', R) =>
		 O.RefExp(i)
	   )
	 | RECORDAtExp(i, exprowo) =>
	   let
		val  _   = insertScope E
		val row' = trExpRowo E exprowo
		val  _   = deleteScope E
	   in
		O.RowExp(i, row')
	   end
	 | UPDATEAtExp(i, atexp, exprow) =>
	   let
		val exp' = trAtExp E atexp
		val  _   = insertScope E
		val row' = trExpRowo E (SOME exprow)
		val  _   = deleteScope E
	   in
		O.CompExp(i, exp', O.RowExp(infoExpRow exprow, row'))
	   end
	 | HASHAtExp(i, lab)		=> O.SelExp(i, trLab E lab)
	 | TUPLEAtExp(i, exps)		=> O.TupExp(i, trExps E exps)
	 | VECTORAtExp(i, exps)		=> O.VecExp(i, trExps E exps)
	 | SEQAtExp(i, exps)		=> O.SeqExp(i, trExps E exps)
	 | LETAtExp(i, dec, exp)	=>
	   let
		val  _   = insertScope E
		val dec' = trDec E dec
		val exp' = trExp E exp
		val  _   = deleteScope E
	   in
		O.LetExp(i, dec', exp')
	   end
	 | PARAtExp(i, exp)		=> trExp E exp


    and trExpRowo E =
	fn NONE => O.Row(Source.nowhere, [], false)

	 | SOME(ROWExpRow(i, lab as Lab(i',lab'), exp, exprowo)) =>
	   let
		val i1'    = Source.over(i', infoExp exp)
		val field' = O.Field(i1', trLab E lab, trExp E exp)
		val _      = insertFld(E, lab', i') handle CollisionFld _ =>
				error(i', E.ExpRowLabDuplicate lab')
		val O.Row(_,fields',_) = trExpRowo E exprowo
	   in
		O.Row(i, field'::fields', false)
	   end


    and trExp E =
	fn exp as (ATEXPExp _|APPExp _)	=> trAppExp E (Infix.exp (infEnv E) exp)
 	 | TYPEDExp(i, exp, ty)		=> O.AnnExp(i,trExp E exp, trTy E ty)
	 | ANDALSOExp(i, exp1, exp2)	=> O.AndExp(i,trExp E exp1,trExp E exp2)
	 | ORELSEExp(i, exp1, exp2)	=> O.OrExp(i,trExp E exp1, trExp E exp2)
	 | HANDLEExp(i, exp, match)	=>
		O.HandleExp(i, trExp E exp, trMatcho E (SOME match))

	 | RAISEExp(i, exp)		=> O.RaiseExp(i, trExp E exp)
	 | IFExp(i, exp1, exp2, exp3)	=>
		O.IfExp(i, trExp E exp1, trExp E exp2, trExp E exp3)

	 | WHILEExp(i, exp1, exp2) =>
		O.WhileExp(i, trExp E exp1, trExp E exp2)

	 | CASEExp(i, exp, match) =>
		O.CaseExp(i, trExp E exp, trMatcho E (SOME match))

	 | FNExp(i, match) =>
	   let
		val i'       = infoMatch match
		val matches' = trMatcho E (SOME match)

		val (id',exp') =
		    case matches'
		      of [O.Match(_,O.JokPat(i),exp')]     => (inventId i, exp')
		       | [O.Match(_,O.VarPat(i,id'),exp')] => (id',exp')
		       | _                                 =>
			 let
			    val id'      = inventId i
			    val varexp'  = O.VarExp(i, O.ShortId(i, id'))
			 in
			    (id', O.CaseExp(i', varexp', matches'))
			 end
	   in
		O.FunExp(i, id', exp')
	   end

	| PACKExp(i, longstrid) =>
	  let
		val (longid',E') = trLongStrId E longstrid
		val  mod'        = longidToMod longid'
	  in
		O.PackExp(i, mod')
	  end


    and trAppExp E =
	fn APPExp(i, exp, atexp) => O.AppExp(i, trAppExp E exp, trAtExp E atexp)
	 | ATEXPExp(i, atexp)    => trAtExp E atexp
	 | exp                   => trExp E exp

    and trExps E = List.map(trExp E)



  (* Matches and patterns *)

    and trMatcho  E matcho = List.rev(trMatcho' (E,[]) matcho)
    and trMatcho'(E,acc) =
	fn NONE => acc
	 | SOME(Match(i, mrule, matcho)) =>
	   let
		val match' = trMrule E mrule
	   in
		trMatcho' (E, match'::acc) matcho
	   end

    and trMrule E (Mrule(i, pat, exp)) =
	let
		val E'   = Env.new()
		val pat' = trPat (E,E') pat
		val  _   = inheritScope(E,E')
		val exp' = trExp E exp
		val  _   = deleteScope E
	in
		O.Match(i, pat', exp')
	end


    and trAtPat (E,E') =
	fn WILDCARDAtPat(i)	=> O.JokPat(i)
	 | SCONAtPat(i, scon)	=> O.LitPat(i, trSCon E scon)
	 | LONGVIDAtPat(_, _, longvid as SHORTLong(i, vid as VId(i',vid'))) =>
	   (case lookupIdStatus(E, vid')
	      of C _ => O.ConPat(i, #1(trLongVId E longvid), [])
	       | R   => O.RefPat(i, O.JokPat(i)) (* BUG: a real hack! *)
	       | V   =>
		 let
		    (* If inside an alternative pattern then E' contains
		     * an upper scope where the variable is already bound.
		     * We have to reuse the stamp found there.
		     *)
		    val _ = if Option.isSome(lookupScopeVal(E', vid')) then
			       error(i', E.PatVIdDuplicate vid')
			    else ()
		    val (id',stamp) =
			case lookupVal(E', vid')
			  of NONE            => trVId_bind E vid
			   | SOME(_,stamp,_) => ( O.Id(i', stamp,
						      O.ExId(VId.toString vid'))
						, stamp )
		    val _ = insertVal(E', vid', (i',stamp,V))
		 in
		    O.VarPat(i, id')
		 end
	   )
	 | LONGVIDAtPat(i, _, longvid) =>
	   (case trLongVId E longvid
	      of (longid', C _) => O.ConPat(i, longid', [])
	       | (longid', R)   => O.RefPat(i, O.JokPat(i)) (* BUG: HACK! *)
	       | (longid', V)   => error(i, E.PatLongVIdVar)
	   )
	 | RECORDAtPat(i, patrowo) =>
	   let
		val  _   = insertScope E
		val row' = trPatRowo (E,E') patrowo
		val  _   = deleteScope E
	   in
		O.RowPat(i, row')
	   end

	 | TUPLEAtPat(i, pats)     => O.TupPat(i, trPats (E,E') pats)
	 | VECTORAtPat(i, pats)    => O.VecPat(i, trPats (E,E') pats)
	 | ALTAtPat(i, pats)       =>
	   let
		val  _    = insertScope E'
		val pat'  = trPat (E,E') (List.hd pats)
		val pats' = trAltPats (E,E') (List.tl pats)
		val  _    = mergeDisjointScope E' handle CollisionVal vid' =>
				errorVId(E', vid', E.PatVIdDuplicate)
	   in
		O.AltPat(i, pat'::pats')
	   end

	 | PARAtPat(i, pat) => trPat (E,E') pat


    and trPatRowo (E,E') =
	fn NONE => O.Row(Source.nowhere, [], false)

	 | SOME(WILDCARDPatRow(i)) => O.Row(i, [], true)

	 | SOME(ROWPatRow(i, lab as Lab(i',lab'), pat, patrowo)) =>
	   let
		val i1'    = Source.over(i', infoPat pat)
		val field' = O.Field(i1', trLab E lab, trPat (E,E') pat)
		val _      = insertFld(E, lab', i') handle CollisionFld _ =>
				error(i', E.PatRowLabDuplicate lab')
		val O.Row(_,fields',dots') = trPatRowo (E,E') patrowo
	   in
		O.Row(i, field'::fields', dots')
	   end


    and trPat (E,E') =
	fn pat as (ATPATPat _|APPPat _) =>
		trAppPat (E,E') (Infix.pat (infEnv E) pat)

	 | TYPEDPat(i, pat, ty)	=> O.AnnPat(i, trPat (E,E') pat, trTy E ty)
	 | NONPat(i, pat)	=> O.NegPat(i, trPat (E,Env.new()) pat)
	 | ASPat(i, pat1, pat2) => O.AsPat(i,trPat (E,E') pat1,trPat(E,E') pat2)
	 | WHENPat(i, pat, atexp) =>
	   let
		val  _   = insertScope E'
		val pat' = trPat (E,E') pat
		val  _   = inheritScope(E, copyScope E')
		val exp' = trAtExp E atexp
		val  _   = deleteScope E
		val  _   = mergeDisjointScope E' handle CollisionVal vid' =>
				errorVId(E', vid', E.PatVIdDuplicate)
	   in
		O.GuardPat(i, pat', exp')
	   end

	 | WITHVALPat(i, pat, valbind) =>
	   let
		val  _   = insertScope E'
		val pat' = trPat (E,E') pat
		val  _   = inheritScope(E, copyScope E')
		val  _   = insertScope E'
		val decs'= trValBindo (E,E') (SOME valbind)
		val  _   = deleteScope E
		val  _   = mergeDisjointScope E' handle CollisionVal vid' =>
				errorVId(E', vid', E.WithPatVIdDuplicate)
		val  _   = mergeDisjointScope E' handle CollisionVal vid' =>
				errorVId(E', vid', E.PatVIdDuplicate)
	   in
		O.WithPat(i, pat', decs')
	   end

	 | WITHFUNPat(i, pat, fvalbind) =>
	   let
		val  _   = insertScope E'
		val pat' = trPat (E,E') pat
		val  _   = inheritScope(E, copyScope E')
		val  _   = insertScope E'
		val ids' = trFvalBindo_lhs (E,E') (SOME fvalbind)
		val  _   = inheritScope(E, copyScope E')
		val exps'= trFvalBindo_rhs E (SOME fvalbind)
		val decs'= ListPair.map
				(fn(id',exp') =>
				 O.ValDec(O.infoExp exp',
					  O.VarPat(O.infoId id', id'), exp'))
				(ids',exps')
		val  _   = deleteScope E
		val  _   = deleteScope E
		val  _   = mergeDisjointScope E' handle CollisionVal vid' =>
				errorVId(E', vid', E.WithPatVIdDuplicate)
		val  _   = mergeDisjointScope E' handle CollisionVal vid' =>
				errorVId(E', vid', E.PatVIdDuplicate)
	   in
		O.WithPat(i, pat', [O.RecDec(infoFvalBind fvalbind, decs')])
	   end

    and trAppPat (E,E') =
	fn APPPat(i, pat, atpat) =>
	   let
		val pat1' = trAppPat (E,E') pat
		val pat2' = trAtPat (E,E') atpat
	   in
		case pat1'
		  of O.ConPat(i', longid, pats') =>
			O.ConPat(i, longid, pats'@[pat2'])

		   | O.RefPat(i', O.JokPat _) =>  (* BUG: a real hack! *)
			O.RefPat(i, pat2')

		   | _ => error(i, E.AppPatNonCon)
	   end

	 | ATPATPat(i, atpat) => trAtPat (E,E') atpat

	 | pat => trPat (E,E') pat


    and trPats (E,E') = List.map(trPat (E,E'))

    and trAltPats (E,E') = List.map(trAltPat (E,E'))

    and trAltPat (E,E') pat =
	let
	    val _    = insertScope E'
	    val pat' = trPat (E,E') pat
	    val E''  = splitScope E'
	    val _    = if Env.sizeScope E' = Env.sizeScope E'' then () else
			  error(infoPat pat, E.AltPatInconsistent)
	    val _    = Env.appiScopeVals
			    (fn(vid,_) =>
				if Option.isSome(lookupVal(E'',vid)) then ()
				else error(infoPat pat, E.AltPatInconsistent)
			    ) E'
	in
	    pat'
	end



  (* Types *)

    and trTy E =
	fn TYVARTy(i, tyvar as TyVar(i',tyvar')) =>
		O.VarTyp(i, trTyVar E tyvar)

	 | TYCONTy(i, tyseq, longtycon) =>
	   let
		val (longid',_) = trLongTyCon E longtycon
		val  typs'      = trTySeq E tyseq
	   in
		apptyp(typs', O.ConTyp(i, longid'))
	   end

	 | RECORDTy(i, tyrowo) =>
	   let
		val  _   = insertScope E
		val row' = trTyRowo E tyrowo
		val  _   = deleteScope E
	   in
		O.RowTyp(i, row')
	   end

	 | TUPLETy(i, tys) =>
	   let
		val typs' = trTys E tys
	   in
		O.TupTyp(i, typs')
	   end

	 | ARROWTy(i, ty1, ty2) => O.ArrTyp(i, trTy E ty1, trTy E ty2)

	 | PACKTy(i, longsigid) =>
	   let
		val (longid',E') = trLongSigId E longsigid
		val  inf'        = O.ConInf(infoLong longsigid, longid')
	   in
		O.PackTyp(i, inf')
	   end

	 | PARTy(i, ty) => trTy E ty

    and trTys E = List.map (trTy E)


    and trTyRowo E =
	fn NONE => O.Row(Source.nowhere, [], false)

	 | SOME(ROWTyRow(i, lab as Lab(i',lab'), ty, tyrowo)) =>
	   let
		val i1'    = Source.over(i', infoTy ty)
		val field' = O.Field(i1', trLab E lab, trTy E ty)
		val _      = insertFld(E, lab', i') handle CollisionFld _ =>
				error(i', E.TyRowLabDuplicate lab')
		val O.Row(_,fields',_) = trTyRowo E tyrowo
	   in
		O.Row(i, field'::fields', false)
	   end



    and trTySeq E (Seq(i, tys)) = List.map (trTy E) tys


    and trTyVarSeq E (Seq(i, tyvars)) = List.map (trSeqTyVar E) tyvars

    and trSeqTyVar E (tyvar as TyVar(i, tyvar')) =
	let
	    val (id',stamp) = trTyVar_bind E tyvar
	    val  _          = insertDisjointVar(E, tyvar', (i, stamp))
			      handle CollisionVar _ =>
				error(i, E.TyVarSeqDuplicate tyvar')
	in
	    id'
	end


    (* Tyvarseqs at a val or fun *)

    and trValTyVarSeq E (Seq(i, tyvars)) = List.map (trValSeqTyVar E) tyvars

    and trValSeqTyVar E (tyvar as TyVar(i, tyvar')) =
	if Option.isSome(lookupVar(E, tyvar')) then
	    error(i, E.ValTyVarSeqDuplicate tyvar')
	else
	let
	    val (id',stamp) = trTyVar_bind E tyvar
	    val  _          = insertVar(E, tyvar', (i, stamp))
	in
	    id'
	end


    (* Extract type variables from a type (as implicitly quantified) *)

    and trAllTy E =
	fn TYVARTy(i, tyvar as TyVar(i',tyvar')) =>
	   if Option.isSome(lookupVar(E, tyvar')) then
		[]
	   else
	   let
		val (id',stamp) = trTyVar_bind E tyvar
		val  _          = insertVar(E, tyvar', (i, stamp))
	   in
		[id']
	   end

	 | TYCONTy(i, tyseq, longtycon) => trAllTySeq E tyseq
	 | RECORDTy(i, tyrowo)   => trAllTyRowo E tyrowo
	 | TUPLETy(i, tys)       => List.concat(List.map (trAllTy E) tys)
	 | ARROWTy(i, ty1, ty2)  => trAllTy E ty1 @ trAllTy E ty2
	 | PACKTy(i, longsigid)  => []
	 | PARTy(i, ty)          => trAllTy E ty

    and trAllTyRowo E =
	fn NONE                               => []
	 | SOME(ROWTyRow(i, lab, ty, tyrowo)) =>
		trAllTy E ty @ trAllTyRowo E tyrowo

    and trAllTySeq E (Seq(i, tys)) = List.concat(List.map (trAllTy E) tys)



  (* Declarations *)

    and trDec  E dec  = List.rev(trDec' (E,[]) dec)
    and trDec'(E,acc) =
	fn VALDec(i, tyvarseq, valbind) =>
	   let
		val  E'   = Env.new()
		val  _    = insertScope E
		val ids'  = trValTyVarSeq E tyvarseq @
			    unguardedTyVarsValBind E valbind
		val decs' = (if List.null ids'
			     then trValBindo'(E,E',acc)
			     else trValBindo (E,E') ) (SOME valbind)
		val  _    = deleteScope E
		val  _    = union(E,E')
	   in
		if List.null ids'
		then decs'
		else List.map (fn dec' => vardec(ids', dec')) decs' @ acc
	   (* UNFINISHED: violates uniqueness of stamps in bindings *)
	   end

	 | FUNDec(i, tyvarseq, fvalbind) =>
	   let
		val E'    = Env.new()
		val ids'  = trFvalBindo_lhs (E,E') (SOME fvalbind)
		val  _    = union(E,E')
		val  _    = insertScope E
		val ids'' = trValTyVarSeq E tyvarseq @
			    unguardedTyVarsFvalBind E fvalbind
		val exps' = trFvalBindo_rhs E (SOME fvalbind)
		val  _    = deleteScope E
		val decs' = ListPair.map
				(fn(id',exp') =>
				 O.ValDec(O.infoExp exp',
					  O.VarPat(O.infoId id', id'), exp'))
				(ids',exps')
	   in
		vardec(ids'', O.RecDec(i, decs')) :: acc
	   end

	 | TYPEDec(i, typbind) =>
	   let
		val E'    = Env.new()
		val decs' = trTypBindo' (E,E',acc) (SOME typbind)
		val  _    = union(E,E')
	   in
		decs'
	   end

	 | EQTYPEDec(i, typbind) =>
	   (* UNFINISHED *)
	   let
		val E'    = Env.new()
		val decs' = trTypBindo' (E,E',acc) (SOME typbind)
		val  _    = union(E,E')
	   in
		decs'
	   end

	 | EQEQTYPEDec(i, typbind) =>
	   (* UNFINISHED *)
	   let
		val E'    = Env.new()
		val decs' = trTypBindo' (E,E',acc) (SOME typbind)
		val  _    = union(E,E')
	   in
		decs'
	   end

	 | DATATYPEDec(i, datbind) =>
	   let
		val E'    = Env.new()
		val  _    = trDatBindo_lhs (E,E') (SOME datbind)
		val  _    = union(E,E')
		val decs' = trDatBindo_rhs (E,E') (SOME datbind)
		val  _    = union(E,E')
	   in
		O.RecDec(i, decs') :: acc
	   end

	 | REPLICATIONDec(i, tycon as TyCon(i',tycon'), longtycon) =>
	   let
		val (id',stamp)  = trTyCon_bind E tycon
		val (longid',E') = trLongTyCon E longtycon
		val  longido'    = case longid'
				     of O.LongId(_,longid',_) => SOME longid'
				      | O.ShortId _           => NONE
		val _            = insertTy(E, tycon', (i', stamp, E'))
	   in
		foldiVals (trOpenDecVal (E,i,longido'))
		  (O.TypDec(i, id', O.ConTyp(infoLong longtycon, longid'))::acc)
		  E'
	   end

	 | CONSTRUCTORDec(i, dconbind) =>
	   let
		val E'    = Env.new()
		val decs' = trDconBindo' (E,E',acc) (SOME dconbind)
		val  _    = union(E,E')
	   in
		decs'
	   end

	 | STRUCTUREDec(i, strbind) =>
	   let
		val E'    = Env.new()
		val decs' = trStrBindo' (E,E',acc) (SOME strbind)
		val  _    = union(E,E')
	   in
		decs'
	   end

	 | SIGNATUREDec(i, sigbind) =>
	   let
		val E'    = Env.new()
		val decs' = trSigBindo' (E,E',acc) (SOME sigbind)
		val _     = union(E,E')
	   in
		decs'
	   end

	 | LOCALDec(i, dec1, dec2) =>
	   let
		val  _     = insertScope E
		val decs1' = trDec E dec1
		val  _     = insertScope E
		val decs2' = trDec' (E, O.LocalDec(i, decs1')::acc) dec2
		val  E'    = splitScope E
		val  _     = deleteScope E
		val  _     = union(E,E')
	   in
		decs2'
	   end

	 | OPENDec(i, longstrid) =>
	   let
		val (longid', E') = trLongStrId E longstrid
		val   _           = unionInf(E,E')
	   in
		(foldiVals (trOpenDecVal(E,i,SOME longid'))
		(foldiTys  (trOpenDecTy (E,i,longid'))
		(foldiStrs (trOpenDecStr(E,i,longid'))
		(foldiSigs (trOpenDecSig(E,i,longid')) acc E') E') E') E')
	   end

	 | EMPTYDec(i) =>
		acc

	 | SEQDec(i, dec1, dec2) =>
		trDec' (E, trDec' (E,acc) dec1) dec2

	 | PREBOUNDDec(i, strid as StrId(i',strid')) =>
	   let
		val  _           = trStrId_bind E strid
		val (_,stamp,E') = prebound E
		val  _           = insertStr(E, strid', (i',stamp,E'))
	   in
		acc
	   end

	 | PRIMITIVEVALDec(i, _, vid as VId(i',vid'), ty, s) =>
	   let
		val (id',stamp) = trVId_bind E vid
		val  _          = insertScope E
		val  ids'       = trAllTy E ty
		val  typ'       = trTy E ty
		val  _          = deleteScope E
		val  pat'       = O.VarPat(i', id')
		val  exp'       = O.PrimExp(i, s, typ')
		val  dec'       = O.ValDec(i, pat', exp')
		val  _          = insertVal(E, vid', (i, stamp, V))
	   in
		vardec(ids', dec') :: acc
	   end

	 | PRIMITIVECONSTRUCTORDec
		(i, _, vid as VId(i',vid'), tyo, tyvarseq, longtycon, s) =>
	   let
		val  id1'        = inventId i
		val (id2',stamp) = trVId_bind E vid
		val  _           = insertScope E
		val (ids',typ')  = trTyVarSeqLongTyCon E (tyvarseq, longtycon)
		val  typs'       = trTyo E tyo
		val  _           = deleteScope E
		val  typ1'       = arrtyp(typs',typ')
		val  pat1'       = O.VarPat(i', id1')
		val  exp1'       = O.PrimExp(i, s, typ1')
		val  dec1'       = O.ValDec(i, pat1', exp1')
		val  con'        = O.Con(i', id2', [])
		val  typ2'       = O.SingTyp(i, O.ShortId(i',id1'))
		val  dec2'       = O.ConDec(i, con', typ2')
		val  k           = List.length typs'
		val  _           = insertVal(E, vid', (i', stamp, C k))
	   in
		dec2' :: vardec(ids', dec1') :: acc
	   end

	 | PRIMITIVESTRUCTUREDec(i, strid as StrId(i',strid'), sigexp, s) =>
	   let
		val (id',stamp) = trStrId_bind E strid
		val (inf',E')   = trSigExp E sigexp
		val  mod'       = O.PrimMod(i, s, inf')
		val  dec'       = O.ModDec(i, id', mod')
		val  _          = insertStr(E, strid', (i, stamp, E'))
	   in
		dec' :: acc
	   end

	 | OVERLOADDec(i, _, vid, tyvar, ty) =>
	   (*UNFINISHED*)
	   let
		val (id',stamp) = trVId_bind E vid
		val _           = insertScope E
		val id1'        = trTyVar_bind E tyvar
		val _           = insertScope E
		val ids'        = trAllTy E ty
		val typ'        = alltyp(ids', trTy E ty)
		val _           = deleteScope E
		val _           = deleteScope E
	   in
		acc
	   end

	 | INSTANCEDec(i, _, vid, longtycon, longvid) =>
	   (*UNFINISHED*)
		acc

	 | INSTANCESCONDec(i, scon, longtycon) =>
	   (*UNFINISHED*)
		acc

	 | INFIXDec(i, n, VId(i',vid')) =>
		( insertInf(E, vid', (i', SOME(LEFT, n)))
		; acc
		)

	 | INFIXRDec(i, n, VId(i',vid')) =>
		( insertInf(E, vid', (i', SOME(RIGHT, n)))
		; acc
		)

	 | NONFIXDec(i, VId(i',vid')) =>
		( insertInf(E, vid', (i', NONE))
		; acc
		)


    and trOpenDecVal (E,i,longido') (vid', (_,stamp1,is), acc) =
	let
	    val name    = VId.toString vid'
	    val stamp2  = Stamp.new()
	    val id1'    = O.Id(i, stamp1, O.ExId name)
	    val id2'    = O.Id(i, stamp2, O.ExId name)
	    val longid' = case longido'
			    of SOME longid' => O.LongId(i,longid',O.Lab(i,name))
			     | NONE         => O.ShortId(i, id1')
	    val pat'    = O.VarPat(i, id2')
	    val exp'    = O.VarExp(i, longid')
	    val _       = insertVal(E, vid', (i,stamp2,is))
	in
	    (case is
	       of V => O.ValDec(i, O.VarPat(i, id2'), O.VarExp(i, longid'))
		| _ => O.ConDec(i, O.Con(i, id2', []), O.SingTyp(i, longid'))
	    ) :: acc
	end

    and trOpenDecTy (E,i,longid) (tycon', (_,stamp1,E'), acc) =
	let
	    val name    = TyCon.toString tycon'
	    val stamp2  = Stamp.new()
	    val id'     = O.Id(i, stamp2, O.ExId name)
	    val lab'    = O.Lab(i, name)
	    val longid' = O.LongId(i, longid, lab')
	    val typ'    = O.ConTyp(i, longid')
	    val _       = insertTy(E, tycon', (i,stamp2,E'))
	in
	    O.TypDec(i, id', typ') :: acc
	end

    and trOpenDecStr (E,i,longid) (strid', (_,stamp1,E'), acc) =
	let
	    val name    = StrId.toString strid'
	    val stamp2  = Stamp.new()
	    val id'     = O.Id(i, stamp2, O.ExId name)
	    val lab'    = O.Lab(i, name)
	    val longid' = O.LongId(i, longid, lab')
	    val mod'    = longidToMod longid'
	    val _       = insertStr(E, strid', (i,stamp2,E'))
	in
	    O.ModDec(i, id', mod') :: acc
	end

    and trOpenDecSig (E,i,longid) (sigid', (_,stamp1,E'), acc) =
	let
	    val name    = SigId.toString sigid'
	    val stamp2  = Stamp.new()
	    val id'     = O.Id(i, stamp2, O.ExId name)
	    val lab'    = O.Lab(i, name)
	    val longid' = O.LongId(i, longid, lab')
	    val inf'    = O.ConInf(i, longid')
	    val _       = insertSig(E, sigid', (i,stamp2,E'))
	in
	    O.InfDec(i, id', inf') :: acc
	end



  (* Value bindings *)

    and trValBindo (E,E') valbindo = List.rev(trValBindo' (E,E',[]) valbindo)
    and trValBindo'(E,E',acc) =
	fn NONE => acc

	 | SOME(PLAINValBind(_, pat, exp, valbindo)) =>
	   let
		val i    = Source.over(infoPat pat, infoExp exp)
		val pat' = trPat (E,E') pat
		val exp' = trExp E exp
		val dec' = O.ValDec(i, pat', exp')
	   in
		trValBindo' (E,E', dec'::acc) valbindo
	   end

	| SOME(RECValBind(i, valbind)) =>
	   let
		val pats' = trRecValBindo_lhs' (E,E',[]) (SOME valbind)
		val  _    = union(E,E')
		val exps' = trRecValBindo_rhs' (E,[]) (SOME valbind)
		val decs' = ListPair.map
				(fn(pat',exp') =>
				 O.ValDec(Source.over(O.infoPat pat',
						      O.infoExp exp'),
					  pat', exp'))
				(pats',exps')
	   in
		O.RecDec(i, decs') :: acc
	   end


    and trRecValBindo_lhs' (E,E',acc) =
	fn NONE => acc

	 | SOME(PLAINValBind(i, pat, exp, valbindo)) =>
	   let
		val pat' = trPat (E,E') pat
	   in
		trRecValBindo_lhs' (E,E', pat'::acc) valbindo
	   end

	 | SOME(RECValBind(i, valbind)) =>
		trRecValBindo_lhs' (E,E',acc) (SOME valbind)


    and trRecValBindo_rhs' (E,acc) =
	fn NONE => acc

	 | SOME(PLAINValBind(i, pat, exp, valbindo)) =>
	   (* BUG: no check for admissibility *)
	   let
		val exp' = trExp E exp
	   in
		trRecValBindo_rhs' (E, exp'::acc) valbindo
	   end

	 | SOME(RECValBind(i, valbind)) =>
		trRecValBindo_rhs' (E,acc) (SOME valbind)



  (* Function bindings *)

    and trFvalBindo_lhs (E,E') fvalbindo =
	    List.rev(trFvalBindo_lhs' (E,E',[]) fvalbindo)

    and trFvalBindo_lhs'(E,E',acc) =
	fn NONE => acc
	 | SOME(FvalBind(i, fmatch, fvalbindo)) =>
	   let
		val id' = trFmatch_lhs (E,E') fmatch
	   in
		trFvalBindo_lhs' (E,E', id'::acc) fvalbindo
	   end


    and trFmatch_lhs (E,E') (Match(i, fmrule, fmatcho)) =
	   let
		val vid as VId(i',vid') = trFmrule_lhs E fmrule
		val (id',stamp)         = trVId_bind E vid
		val _ = trFmatcho_lhs (E,vid) fmatcho
		val _ = insertDisjointVal(E', vid', (i',stamp,V))
			handle CollisionVal _ =>
			       error(i', E.FvalBindDuplicate vid')
	   in
		id'
	   end

    and trFmatcho_lhs (E,vid1) =
	fn NONE => ()
	 | SOME(Match(i, fmrule, fmatcho)) =>
	   let
		val vid2 as VId(i',vid2') = trFmrule_lhs E fmrule
	   in
		if idVId vid1 = idVId vid2 then
		    trFmatcho_lhs (E,vid1) fmatcho
		else
		    error(i', E.FvalBindNameInconsistent vid2')
	   end

    and trFmrule_lhs E (Mrule(i, fpat, exp)) =
	   trFpat_lhs E fpat

    and trFpat_lhs E =
	fn fpat as (ATPATPat _ | APPPat _) =>
		trFappPat_lhs E (Infix.pat (infEnv E) fpat)
	 | ( TYPEDPat(i, fpat, _)
	   | WHENPat(i, fpat, _) )	=> trFpat_lhs E fpat
	 | ( NONPat(i,_)
	   | ASPat(i,_,_)
	   | WITHVALPat(i,_,_)
	   | WITHFUNPat(i,_,_) )	=> error(i, E.FvalBindPatInvalid)

    and trFappPat_lhs E =
	fn APPPat(i, fpat, atpat)	=> trFappPat_lhs E fpat
	 | ATPATPat(i, atpat)		=> trFatPat_lhs E atpat
	 | fpat				=> trFpat_lhs E fpat

    and trFatPat_lhs E =
	fn LONGVIDAtPat(i, _, SHORTLong(_, vid as VId(i', vid'))) =>
	   (case lookupIdStatus(E, vid')
	      of  V        => vid
	       | (R | C _) => error(i', E.FvalBindNameCon vid')
	   )

	 | ALTAtPat(i, fpats) =>
	   let
		val vids               = trFpats_lhs E fpats
		val vid as VId(_,vid') = List.hd vids
	   in
		case List.find (fn(VId(_,vid'')) => vid'<>vid'') (List.tl vids)
		  of NONE                => vid
		   | SOME(VId(i',vid2')) =>
			error(i', E.FvalBindNameInconsistent vid2')
	   end

	 | PARAtPat(i, fpat) =>
		trFpat_lhs E fpat

	 | atpat =>
		error(infoAtPat atpat, E.FvalBindNameMissing)

    and trFpats_lhs E = List.map(trFpat_lhs E)



    and trFvalBindo_rhs E fvalbindo =
	    List.rev(trFvalBindo_rhs' (E,[]) fvalbindo)

    and trFvalBindo_rhs'(E,acc) =
	fn NONE => acc
	 | SOME(FvalBind(i, fmatch, fvalbindo)) =>
	   let
		val exp' = trFmatch_rhs E fmatch
	   in
		trFvalBindo_rhs' (E, exp'::acc) fvalbindo
	   end

    and trFmatch_rhs E (Match(i, fmrule, fmatcho)) =
	   let
		val (match',arity) = trFmrule_rhs E fmrule
		val  matches'      = trFmatcho_rhs (E,arity) fmatcho

		val ids'           = List.tabulate(arity, fn _ => inventId i)
		val exps'          = List.map(fn id' =>
						O.VarExp(Source.nowhere,
						O.ShortId(Source.nowhere, id')))
					      ids'
		val i'             = O.infoMatch match'
		val tupexp'        = tupexp(i', exps')
		val caseexp'       = O.CaseExp(i', tupexp', match'::matches')

		fun funexp    []      = caseexp'
		  | funexp(id'::ids') = O.FunExp(i', id', funexp ids')
	   in
		funexp ids'
	   end

    and trFmatcho_rhs (E,arity) fmatcho =
	    List.rev(trFmatcho_rhs' (E,arity,[]) fmatcho)

    and trFmatcho_rhs' (E,arity,acc) =
	fn NONE => acc

	 | SOME(Match(i, fmrule, fmatcho)) =>
	   let
		val (match',arity') = trFmrule_rhs E fmrule
	   in
		if arity <> arity' then
		    error(infoMrule fmrule, E.FvalBindArityInconsistent)
		else
		    trFmatcho_rhs' (E, arity, match'::acc) fmatcho
	   end

    and trFmrule_rhs E (Mrule(i, fpat, exp)) =
	   let
		val  E'                = Env.new()
		val (pat',arity,typs') = trFpat_rhs (E,E') fpat
		val  _                 = inheritScope(E,E')
		val  exp'              = trExp E exp
		val  _                 = deleteScope E
	   in
		( O.Match(i, pat', annexp(exp',typs')), arity )
	   end

    and trFpat_rhs (E,E') =
	fn fpat as (ATPATPat _ | APPPat _) =>
		trFappPat_rhs (E,E') (Infix.pat (infEnv E) fpat)

	 | TYPEDPat(i, fpat, ty) =>
	   let
		val (pat',arity,typs') = trFpat_rhs (E,E') fpat
		val  typ'              = trTy E ty
	   in
		( pat', arity, typ'::typs' )
	   end

	 | WHENPat(i, fpat, atexp) =>
	   let
		val  _   = insertScope E'
		val (pat',arity,typs') = trFpat_rhs (E,E') fpat
		val  _   = inheritScope(E, copyScope E')
		val exp' = trAtExp E atexp
		val  _   = deleteScope E
		val  _   = mergeDisjointScope E' handle CollisionVal vid' =>
				errorVId(E', vid', E.PatVIdDuplicate)
	   in
		( O.GuardPat(i, pat', exp'), arity, typs' )
	   end

	 | ( NONPat(i,_) | ASPat(i,_,_)
	   | WITHVALPat(i,_,_) | WITHFUNPat(i,_,_) ) =>
		error(i, E.FvalBindPatInvalid)

    and trFappPat_rhs (E,E') =
	fn fpat as APPPat _ =>
	   let
		val pats' = trAppliedFappPat_rhs (E,E') fpat
	   in
		( tuppat(infoPat fpat, pats'), List.length pats', [] )
	   end
	 | ATPATPat(i, atpat)		=> trFatPat_rhs (E,E') atpat
	 | fpat				=> trFpat_rhs (E,E') fpat

    and trFatPat_rhs (E,E') =
	fn ALTAtPat(i, fpats) =>
	   let
		val  _                 = insertScope E'
		val (pat',arity,typs') = trFpat_rhs (E,E') (List.hd fpats)
		val  pat'aritytyps's   = trAltFpats_rhs (E,E') (List.tl fpats)
		val (pats',arities,typs'') =
			 List.foldr (fn((p,a,ts), (pl,al,tl)) =>
					(p::pl, a::al, ts@tl)
				    ) ([],[],[]) pat'aritytyps's
		val  _ = mergeDisjointScope E'
			 handle CollisionVal vid' =>
				errorVId(E', vid', E.PatVIdDuplicate)
	   in
		case List.find (fn(_,arity',_) => arity<>arity') pat'aritytyps's
		  of NONE => ( O.AltPat(i, pat'::pats'), arity, typs' @ typs'' )
		   | SOME(pat',_,_) =>
			error(O.infoPat pat', E.FvalBindArityInconsistent)
	   end

	 | PARAtPat(i, fpat)	=> trFpat_rhs (E,E') fpat
	 | LONGVIDAtPat(i,_,_)	=> error(i, E.FvalBindArityZero)
	 | fatpat		=> error(infoAtPat fatpat, E.FvalBindPatInvalid)

    and trAltFpats_rhs (E,E') = List.map(trAltFpat_rhs (E,E'))

    and trAltFpat_rhs (E,E') fpat =
	let
	    val _    = insertScope E'
	    val pat'aritytyps' = trFpat_rhs (E,E') fpat
	    val E''  = splitScope E'
	    val _    = if Env.sizeScope E' = Env.sizeScope E'' then () else
			  error(infoPat fpat, E.AltPatInconsistent)
	    val _    = Env.appiVals
			    (fn(vid,_) =>
				if Option.isSome(lookupVal(E'',vid)) then ()
				else error(infoPat fpat, E.AltPatInconsistent)
			    ) E'
	in
	    pat'aritytyps'
	end


    and trAppliedFpat_rhs (E,E') =
	fn fpat as (ATPATPat _ | APPPat _) =>
		trAppliedFappPat_rhs (E,E') (Infix.pat (infEnv E) fpat)
	 | fpat => error(infoPat fpat, E.FvalBindPatInvalid)

    and trAppliedFappPat_rhs (E,E') =
	fn ATPATPat(i, fatpat)	  => trAppliedFatPat_rhs (E,E') fatpat
	 | APPPat(i, fpat, atpat) => trAppliedFappPat_rhs (E,E') fpat
				     @ [trAtPat (E,E') atpat]
	 | fpat => error(infoPat fpat, E.FvalBindPatInvalid)

    and trAppliedFatPat_rhs (E,E') =
	fn LONGVIDAtPat _	=> []
	 | PARAtPat(i, fpat)	=> trAppliedFpat_rhs (E,E') fpat
	 | fatpat => error(infoAtPat fatpat, E.FvalBindPatInvalid)



  (* Type and constructor bindings *)

    and trTypBindo' (E,E',acc) =
	fn NONE => acc

	 | SOME(NEWTypBind(_, tyvarseq, tycon as TyCon(i',tycon'), typbindo)) =>
	   let
		val i           = Source.over(infoSeq tyvarseq, i')
		val (id',stamp) = trTyCon_bind E tycon
		val _           = insertScope E
		val ids'        = trTyVarSeq E tyvarseq
		val _           = deleteScope E
		val funtyp'     = funtyp(ids', O.AbsTyp(i'))
		val dec'        = O.DatDec(i, id', funtyp')
		val _           = insertDisjointTy(E', tycon',
						  (i', stamp, Env.new()))
				  handle CollisionTy _ =>
				      error(i', E.TypBindDuplicate tycon')
	   in
		trTypBindo' (E,E', dec'::acc) typbindo
	   end

	 | SOME(EQUALTypBind(_, tyvarseq, tycon as TyCon(i',tycon'), ty,
								typbindo)) =>
	   let
		val i           = Source.over(infoSeq tyvarseq, infoTy ty)
		val (id',stamp) = trTyCon_bind E tycon
		val _           = insertScope E
		val ids'        = trTyVarSeq E tyvarseq
		val typ'        = trTy E ty
		val _           = deleteScope E
		val funtyp'     = funtyp(ids', typ')
		val dec'        = O.TypDec(i', id', funtyp')
		val _           = insertDisjointTy(E', tycon',
						   (i', stamp, Env.new()))
				  handle CollisionTy _ =>
				      error(i', E.TypBindDuplicate tycon')
	   in
		trTypBindo' (E,E', dec'::acc) typbindo
	   end


    and trDatBindo_lhs (E,E') =
	fn NONE => ()

	 | ( SOME(CLOSEDDatBind(i, tyvarseq, tycon, _, datbindo))
	   | SOME(OPENDatBind(i, tyvarseq, tycon, datbindo)) ) =>
	   let
		val TyCon(i',tycon') = tycon
		val (id',stamp)      = trTyCon_bind E tycon
		val  _               = insertDisjointTy(E', tycon',
							(i', stamp, Env.new()))
				       handle CollisionTy _ =>
					   error(i', E.DatBindDuplicate tycon')
	   in
		trDatBindo_lhs (E,E') datbindo
	   end

    and trDatBindo_rhs (E,E') datbindo =
	    List.rev(trDatBindo_rhs' (E,E',[]) datbindo)

    and trDatBindo_rhs'(E,E',acc) =
	fn NONE => acc

	 | SOME(CLOSEDDatBind(_, tyvarseq, tycon, conbind, datbindo)) =>
	   let
		val i'        = infoConBind conbind
		val i         = Source.over(infoSeq tyvarseq, i')
		val (id',E'') = trTyCon E tycon		(* bound before *)
		val _         = insertScope E
		val ids'      = trTyVarSeq E tyvarseq
		val cons'     = trConBindo (E,E'') (SOME conbind)
		val _         = deleteScope E
		val funtyp'   = funtyp(ids', O.SumTyp(i', cons'))
		val dec'      = O.DatDec(i, id', funtyp')
		val  _        = unionDisjoint(E',E'')
				handle CollisionVal vid' =>
				    errorVId(E'', vid', E.DatBindConDuplicate)
	   in
		trDatBindo_rhs' (E,E', dec'::acc) datbindo
	   end

	 | SOME(OPENDatBind(_, tyvarseq, tycon, datbindo)) =>
	   let
		val i'        = infoTyCon tycon
		val i         = Source.over(infoSeq tyvarseq, i')
		val (id',E'') = trTyCon E tycon		(* bound before *)
		val _         = insertScope E
		val ids'      = trTyVarSeq E tyvarseq
		val _         = deleteScope E
		val funtyp'   = funtyp(ids', O.ExtTyp(i'))
		val dec'      = O.DatDec(i, id', funtyp')
	   in
		trDatBindo_rhs' (E,E', dec'::acc) datbindo
	   end


    and trConBindo (E,E') conbindo = List.rev(trConBindo' (E,E',[]) conbindo)
    and trConBindo'(E,E',acc) =
	fn NONE => acc

	 | SOME(ConBind(i, _, vid as VId(i',vid'), tyo, conbindo)) =>
	   let
		val (id',stamp) = trVId_bind E vid
		val  typs'      = trTyo E tyo
		val  con'       = O.Con(i, id', typs')
		val  k          = List.length typs'
		val  _          = insertDisjointVal(E', vid', (i', stamp, C k))
				  handle CollisionVal _ =>
				      error(i', E.ConBindDuplicate vid')
	   in
		trConBindo' (E,E', con'::acc) conbindo
	   end

    and trDconBindo' (E,E',acc) =
	fn NONE => acc

	 | SOME(NEWDconBind(_, _, vid as VId(i',vid'), tyo, tyvarseq, longtycon,
								 dconbindo)) =>
	   let
		val  i          = Source.over(i', infoLong longtycon)
		val (id',stamp) = trVId_bind E vid
		val  _          = insertScope E
		val (ids',typ') = trTyVarSeqLongTyCon E (tyvarseq, longtycon)
		val  typs'      = trTyo E tyo
		val  con'       = O.Con(i', id', typs')
		val  dec'       = O.ConDec(i, con', typ')
		val  _          = deleteScope E
		val  k          = List.length typs'
		val  _          = insertDisjointVal(E', vid', (i', stamp, C k))
				  handle CollisionVal _ =>
				      error(i', E.DconBindDuplicate vid')
	   in
		trDconBindo' (E,E', vardec(ids', dec')::acc) dconbindo
	   end

	 | SOME(EQUALDconBind(_, _, vid as VId(i',vid'), _,
							longvid, dconbindo)) =>
	   let
		val  i           = Source.over(i', infoLong longvid)
		val (id',stamp)  = trVId_bind E vid
		val (longid',is) = trLongVId E longvid
		val  _           = if is <> V then () else
				      error(i, E.DconBindNonCon)
		val  con'        = O.Con(i', id', [])
		val  typ'        = O.SingTyp(O.infoLongid longid', longid')
		val  dec'        = O.ConDec(i, con', typ')
		val  _           = insertDisjointVal(E', vid', (i', stamp, is))
				   handle CollisionVal _ =>
				       error(i', E.DconBindDuplicate vid')
	   in
		trDconBindo' (E,E', dec'::acc) dconbindo
	   end


    and trTyo E  NONE     = []
      | trTyo E (SOME ty) = [trTy E ty]


    and trTyVarSeqLongTyCon E (tyvarseq, longtycon) =
	let
	    val (longid',_) = trLongTyCon E longtycon
	    val  typ'  = O.ConTyp(O.infoLongid longid', longid')
	    val  ids'  = trTyVarSeq E tyvarseq
	    val  typs' = List.map (fn id' => O.VarTyp(O.infoId id', id')) ids'
	in
	    ( ids', apptyp(typs', typ') )
	end


  (* Structure and signature bindings *)

    and trStrBindo' (E,E',acc) =
	fn NONE => acc

	 | SOME(StrBind(_, strid as StrId(i',strid'), strexp, strbindo)) =>
	   let
		val i           = Source.over(i', infoStrExp strexp)
		val (id',stamp) = trStrId_bind E strid
		val (mod',E'')  = trStrExp E strexp
		val  dec'       = O.ModDec(i, id', mod')
		val  _          = insertDisjointStr(E', strid', (i',stamp,E''))
				  handle CollisionStr _ =>
				      error(i', E.StrBindDuplicate strid')
	   in
		trStrBindo' (E,E', dec'::acc) strbindo
	   end


    and trSigBindo' (E,E',acc) =
	fn NONE => acc

	 | SOME(SigBind(_, sigid as SigId(i',sigid'), strpats, sigexp,
								sigbindo)) =>
	   let
		val  i          = Source.over(i', infoSigExp sigexp)
		val (id',stamp) = trSigId_bind E sigid
		val  _          = insertScope E
		val  idinfs'    = trStrPats E strpats
		val (inf',E'')  = trSigExp E sigexp
		val  _          = deleteScope E
		val  dec'       = O.InfDec(i, id', funinf(idinfs',inf'))
		val  _          = insertDisjointSig(E', sigid', (i',stamp,E''))
				  handle CollisionSig _ =>
				      error(i', E.SigBindDuplicate sigid')
	   in
		trSigBindo' (E,E', dec'::acc) sigbindo
	   end


  (* Structure expressions *)

    and trAtStrExp E =
	fn STRUCTAtStrExp(i, dec) =>
	   let
		val _     = insertScope E
		val decs' = trDec E dec
		val E'    = splitScope E
	   in
		( O.StrMod(i, decs'), E' )
	   end

	 | LONGSTRIDAtStrExp(i, longstrid) =>
	   let
		val (longid',E') = trLongStrId E longstrid
	   in
		( longidToMod longid', E' )
	   end

	 | LETAtStrExp(i, dec, strexp) =>
	   let
		val  _        = insertScope E
		val  decs'    = trDec E dec
		val (mod',E') = trStrExp E strexp
		val  _        = deleteScope E
	   in
		( O.LetMod(i, decs', mod'), E' )
	   end

	 | PARAtStrExp(i, strexp) => trStrExp E strexp

    and trStrExp E =
	fn ATSTREXPStrExp(i, atstrexp) => trAtStrExp E atstrexp

	 | APPStrExp(i, strexp, atstrexp) =>
	   let
		val (mod1',E1') = trStrExp E strexp
		val (mod2',E2') = trAtStrExp E atstrexp
	   in
		( O.AppMod(i, mod1', mod2'), E1' )
	   end

	 | TRANSStrExp(i, strexp, sigexp) =>
	   let
		val (mod',E')  = trStrExp E strexp
		val (inf',E'') = trSigExp E sigexp
	   in
		( O.AnnMod(i, mod', inf'), E'' )
	   end

	 | OPAQStrExp (i, strexp, sigexp) =>
	   let
		val (mod',E')  = trStrExp E strexp
		val (inf',E'') = trSigExp E sigexp
	   in
		( O.UpMod(i, mod', inf'), E'' )
	   end

	 | FCTStrExp(i, strpat, strexp) =>
	   let
		val  _         = insertScope E
		val (id',inf') = trStrPat E strpat
		val (mod',E')  = trStrExp E strexp
		val  _         = deleteScope E
	   in
		( O.FunMod(i, id', inf', mod'), E' )
	   end

	 | UNPACKStrExp(i, exp, sigexp) =>
	   let
		val  exp'     = trExp E exp
		val (inf',E') = trSigExp E sigexp
	   in
		( O.UnpackMod(i, exp', inf'), E' )
	   end


    and trStrPat E (StrPat(i, strid as StrId(i', strid'), sigexp)) =
	let
	    val (id',stamp) = trStrId_bind E strid
	    val (inf',E')   = trSigExp E sigexp
	    val  _          = insertStr(E, strid', (i', stamp, E'))
	in
	    (id', inf')
	end

    and trStrPats E = List.map (trStrPat E)



  (* Signatures and specifications *)

    and trAtSigExp E =
	fn ANYAtSigExp(i) =>
	   let
		val E' = Env.new()
	   in
		( O.TopInf(i), E' )
	   end

	 | SIGAtSigExp(i, spec) =>
	   let
		val _      = insertScope E
		val specs' = trSpec E spec
		val E'     = splitScope E
	   in
		( O.SigInf(i, specs'), E' )
	   end

	 | LONGSIGIDAtSigExp(i, sigid) =>
	   let
		val (longid',E') = trLongSigId E sigid
	   in
		( O.ConInf(i, longid'), E' )
	   end

	 | LETAtSigExp(i, dec, sigexp) =>
	   let
		val  _        = insertScope E
		val  decs'    = trDec E dec
		val (inf',E') = trSigExp E sigexp
		val  _        = deleteScope E
	   in
		(*UNFINISHED*)
		(* Mmh, is there really no better way than having LetInf? *)
		(inf',E')
	   end

	 | PARAtSigExp(i, sigexp) => trSigExp E sigexp


    and trSigExp E =
	fn ATSIGEXPSigExp(i, atsigexp) => trAtSigExp E atsigexp

	 | APPSigExp(i, sigexp, atstrexp) =>
	   let
		val (inf',E') = trSigExp E sigexp
		val (mod',_)  = trAtStrExp E atstrexp
	   in
		( O.AppInf(i, inf', mod'), E' )
	   end

	 | FCTSigExp(i, strpat, sigexp) =>
	   let
		val  _          = insertScope E
		val (id',inf1') = trStrPat E strpat
		val (inf2',E')  = trSigExp E sigexp
		val  _          = deleteScope E
	   in
		( O.ArrInf(i, id', inf1', inf2'), E' )
	   end

	 | WHERESigExp(i, sigexp1, sigexp2) =>
	   let
		val (inf1',E1) = trSigExp E sigexp1
		val (inf2',E2) = trSigExp E sigexp2
		val  _         = unionCompose(E1, E2)
	   in
		( O.CompInf(i, inf1', inf2'), E1 )
	   end


    and trSpec  E spec = List.rev(trSpec' (E,[]) spec)
    and trSpec'(E,acc) =
	fn VALSpec(i, valdesc) =>
		trValDesco' (E,acc) (SOME valdesc)

	 | TYPESpec(i, typdesc) =>
		trTypDesco' (E,acc) (SOME typdesc)

	 | EQTYPESpec(i, typdesc) =>
		(* UNFINISHED *)
		trTypDesco' (E,acc) (SOME typdesc)

	 | EQEQTYPESpec(i, typdesc) =>
		(* UNFINISHED *)
		trTypDesco' (E,acc) (SOME typdesc)

	 | DATATYPESpec(i, datdesc) =>
	   let
		val  _     = trDatDesco_lhs E (SOME datdesc)
		val specs' = trDatDesco_rhs E (SOME datdesc)
	   in
		O.RecSpec(i, specs') :: acc
	   end

	 | REPLICATIONSpec(i, tycon as TyCon(i', tycon'), longtycon) =>
	   let
		val (id',stamp)  = trTyCon_bind E tycon
		val (longid',E') = trLongTyCon E longtycon
		val  longido'    = case longid'
				     of O.LongId(_,longid',_) => SOME longid'
				      | O.ShortId _           => NONE
		val  _           = insertDisjointTy(E, tycon', (i', stamp, E'))
				   handle CollisionTy _ =>
				       error(i', E.SpecTyConDuplicate tycon')
	   in
		foldiVals (trOpenSpecVal (E,i,longido'))
		 (O.TypSpec(i, id', O.ConTyp(infoLong longtycon, longid'))::acc)
		 E'
	   end

	 | CONSTRUCTORSpec(i, dcondesc) =>
		trDconDesco' (E,acc) (SOME dcondesc)

	 | STRUCTURESpec(i, strdesc) =>
		trStrDesco' (E,acc) (SOME strdesc)

	 | SIGNATURESpec(i, sigdesc) =>
		trSigDesco' (E,acc) (SOME sigdesc)

	 | INCLUDESpec(i, sigexp) =>
	   let
		val (inf',E') = trSigExp E sigexp
		val _ =
		    unionDisjoint(E,E')
		    handle CollisionInf x => error(i, E.SpecFixDuplicate x)
			 | CollisionVal x => error(i, E.SpecVIdDuplicate x)
			 | CollisionTy  x => error(i, E.SpecTyConDuplicate x)
			 | CollisionStr x => error(i, E.SpecStrIdDuplicate x)
			 | CollisionSig x => error(i, E.SpecSigIdDuplicate x)
	   in
		O.ExtSpec(i, inf') :: acc
	   end

	 | EMPTYSpec(i) =>
		acc

	 | SEQSpec(i, spec1, spec2) =>
		trSpec' (E, trSpec' (E,acc) spec1) spec2

	 | SHARINGTYPESpec(i, spec, longtycons) =>
	   let
		val specs'   = trSpec E spec
		val longids' = List.map (#1 o trLongTyCon E) longtycons
		val rspecs'  = List.rev(Sharing.shareTyp(specs', longids'))
	   in
		rspecs' @ acc
	   end

	 | SHARINGSIGNATURESpec(i, spec, longsigids) =>
	   let
		val specs'   = trSpec E spec
		val longids' = List.map (#1 o trLongSigId E) longsigids
		val rspecs'  = List.rev(Sharing.shareSig(specs', longids'))
	   in
		rspecs' @ acc
	   end

	 | SHARINGSpec(i, spec, longstrids) =>
	   let
		val specs'   = trSpec E spec
		val longids' = List.map (#1 o trLongStrId E) longstrids
		val rspecs'  = List.rev(Sharing.shareStr(specs', longids'))
	   in
		rspecs' @ acc
	   end

	 | PREBOUNDSpec(i, strid as StrId(i',strid')) =>
	   let
		val  _           = trStrId_bind E strid
		val (_,stamp,E') = prebound E
		val  _           = insertStr(E, strid', (i',stamp,E'))
	   in
		acc
	   end

	 | OVERLOADSpec(i, _, vid, tyvar, ty) =>
	   (*UNFINISHED*)
		acc

	 | INSTANCESpec(i, _, vid, longtycon, longvid) =>
	   (*UNFINISHED*)
		acc

	 | INSTANCESCONSpec(i, scon, longtycon) =>
	   (*UNFINISHED*)
		acc

	 | INFIXSpec(i, n, vid as VId(i',vid')) =>
		(insertDisjointInf(E, vid', (i', SOME(Infix.LEFT, n)))
		 handle CollisionInf vid' => error(i', E.SpecFixDuplicate vid')
		; acc
		)

	 | INFIXRSpec(i, n, vid as VId(i',vid')) =>
		(insertDisjointInf(E, vid', (i', SOME(Infix.RIGHT, n)))
		 handle CollisionInf vid' => error(i', E.SpecFixDuplicate vid')
		; acc
		)

	 | NONFIXSpec(i, vid as VId(i',vid')) =>
		(insertDisjointInf(E, vid', (i', NONE))
		 handle CollisionInf vid' => error(i', E.SpecFixDuplicate vid')
		; acc
		)


    and trOpenSpecVal (E,i,longido') (vid', (_,stamp1,is), acc) =
	let
	    val name    = VId.toString vid'
	    val stamp2  = Stamp.new()
	    val id1'    = O.Id(i, stamp1, O.ExId name)
	    val id2'    = O.Id(i, stamp2, O.ExId name)
	    val longid' = case longido'
			    of SOME longid' => O.LongId(i,longid',O.Lab(i,name))
			     | NONE         => O.ShortId(i, id1')
	    val typ'    = O.SingTyp(i, longid')
	    val _       = insertDisjointVal(E, vid', (i,stamp2,is))
			  handle CollisionVal _ =>
			      error(i, E.SpecVIdDuplicate vid')
	in
	    (case is
	       of V => O.ValSpec(i, id2', typ')
	        | _ => O.ConSpec(i, O.Con(i, id2', []), typ')
	    ) :: acc
	end




  (* Descriptions *)

    and trValDesco' (E,acc) =
	fn NONE => acc

	 | SOME(NEWValDesc(_, _, vid as VId(i',vid'), ty, valdesco)) =>
	   let
		val  i          = Source.over(i', infoTy ty)
		val (id',stamp) = trVId_bind E vid
		val  _          = insertScope E
		val  ids'       = trAllTy E ty
		val  typ'       = alltyp(ids', trTy E ty)
		val  _          = deleteScope E
		val  spec'      = O.ValSpec(i, id', typ')
		val  _          = insertDisjointVal(E, vid', (i', stamp, V))
				  handle CollisionVal vid' =>
				      error(i', E.SpecVIdDuplicate vid')
	   in
		trValDesco' (E, spec'::acc) valdesco
	   end

	 | SOME(EQUALValDesc(i, _, vid as VId(i',vid'), _, longvid, valdesco))=>
	   let
		val (id',stamp)  = trVId_bind E vid
		val (longid',is) = trLongVId E longvid
		val  typ'        = O.SingTyp(O.infoLongid longid', longid')
		val  spec'       = O.ValSpec(i, id', typ')
		val  _           = insertDisjointVal(E, vid', (i', stamp, V))
				   handle CollisionVal vid' =>
				      error(i', E.SpecVIdDuplicate vid')
	   in
		trValDesco' (E, spec'::acc) valdesco
	   end


    and trTypDesco' (E,acc) =
	fn NONE => acc

	 | SOME(NEWTypDesc(_, tyvarseq, tycon as TyCon(i',tycon'), typdesco)) =>
	   let
		val i           = Source.over(infoSeq tyvarseq, i')
		val (id',stamp) = trTyCon_bind E tycon
		val _           = insertScope E
		val ids'        = trTyVarSeq E tyvarseq
		val _           = deleteScope E
		val funtyp'     = funtyp(ids', O.AbsTyp(i'))
		val spec'       = O.DatSpec(i, id', funtyp')
		val _           = insertDisjointTy(E, tycon',
						   (i', stamp, Env.new()))
				  handle CollisionTy _ =>
				      error(i', E.SpecTyConDuplicate tycon')
	   in
		trTypDesco' (E, spec'::acc) typdesco
	   end

	 | SOME(EQUALTypDesc(_, tyvarseq, tycon as TyCon(i',tycon'),
							ty, typdesco)) =>
	   let
		val i           = Source.over(infoSeq tyvarseq, infoTy ty)
		val (id',stamp) = trTyCon_bind E tycon
		val _           = insertScope E
		val ids'        = trTyVarSeq E tyvarseq
		val typ'        = trTy E ty
		val _           = deleteScope E
		val funtyp'     = funtyp(ids', typ')
		val spec'       = O.TypSpec(i, id', funtyp')
		val _           = insertDisjointTy(E, tycon',
						   (i', stamp, Env.new()))
				  handle CollisionTy _ =>
				      error(i', E.SpecTyConDuplicate tycon')
	   in
		trTypDesco' (E, spec'::acc) typdesco
	   end


    and trDatDesco_lhs E =
	fn NONE => ()

	 | ( SOME(CLOSEDDatDesc(i, tyvarseq, tycon, _, datdesco))
	   | SOME(OPENDatDesc(i, tyvarseq, tycon, datdesco)) ) =>
	   let
		val TyCon(i',tycon') = tycon
		val (id',stamp)      = trTyCon_bind E tycon
		val _                = insertDisjointTy(E, tycon',
						        (i', stamp, Env.new()))
				       handle CollisionTy _ =>
					 error(i', E.SpecTyConDuplicate tycon')
	   in
		trDatDesco_lhs E datdesco
	   end

    and trDatDesco_rhs E datdesco = List.rev(trDatDesco_rhs' (E,[]) datdesco)
    and trDatDesco_rhs' (E,acc) =
	fn NONE => acc

	 | SOME(CLOSEDDatDesc(_, tyvarseq, tycon, condesc, datdesco)) =>
	   let
		val i'       = infoConDesc condesc
		val i        = Source.over(infoSeq tyvarseq, i')
		val (id',E') = trTyCon E tycon
		val _        = insertScope E
		val ids'     = trTyVarSeq E tyvarseq
		val cons'    = trConDesco (E,E') (SOME condesc)
		val _        = deleteScope E
		val funtyp'  = funtyp(ids', O.SumTyp(i', cons'))
		val spec'    = O.DatSpec(i, id', funtyp')
		val _        = unionDisjoint(E,E') handle CollisionVal vid' =>
				   errorVId(E', vid', E.SpecVIdDuplicate)
	   in
		trDatDesco_rhs' (E, spec'::acc) datdesco
	   end

	 | SOME(OPENDatDesc(_, tyvarseq, tycon, datdesco)) =>
	   let
		val i'       = infoTyCon tycon
		val i        = Source.over(infoSeq tyvarseq, i')
		val (id',E') = trTyCon E tycon
		val _        = insertScope E
		val ids'     = trTyVarSeq E tyvarseq
		val _        = deleteScope E
		val funtyp'  = funtyp(ids', O.ExtTyp(i'))
		val spec'    = O.DatSpec(i, id', funtyp')
	   in
		trDatDesco_rhs' (E, spec'::acc) datdesco
	   end


    and trConDesco (E,E') condesco = List.rev(trConDesco' (E,E',[]) condesco)
    and trConDesco'(E,E',acc) =
	fn NONE => acc

	 | SOME(ConDesc(i, _, vid as VId(i',vid'), tyo, condesco)) =>
	   let
		val (id',stamp) = trVId_bind E vid
		val  typs'      = trTyo E tyo
		val  con'       = O.Con(i, id', typs')
		val  k          = List.length typs'
		val  _          = insertDisjointVal(E', vid', (i', stamp, C k))
				  handle CollisionVal _ =>
				      error(i', E.ConDescDuplicate vid')
	   in
		trConDesco' (E,E', con'::acc) condesco
	   end


    and trDconDesco' (E,acc) =
	fn NONE => acc

	 | SOME(NEWDconDesc(_, _, vid as VId(i',vid'), tyo, tyvarseq, longtycon,
								 dcondesco)) =>
	   let
		val  i          = Source.over(i', infoLong longtycon)
		val (id',stamp) = trVId_bind E vid
		val  _          = insertScope E
		val (ids',typ') = trTyVarSeqLongTyCon E (tyvarseq, longtycon)
		val  typs'      = trTyo E tyo
		val  con'       = O.Con(i', id', typs')
		val  _          = deleteScope E
		val  k          = List.length typs'
		val  spec'      = O.ConSpec(i', con', typ')
		val  _          = insertDisjointVal(E, vid', (i', stamp, C k))
				  handle CollisionVal _ =>
				      error(i', E.SpecVIdDuplicate vid')
	   in
		trDconDesco' (E, varspec(ids', spec')::acc) dcondesco
	   end

	 | SOME(EQUALDconDesc(_, _, vid as VId(i',vid'), _, longvid,
								dcondesco)) =>
	   let
		val  i           = Source.over(i', infoLong longvid)
		val (id',stamp)  = trVId_bind E vid
		val (longid',is) = trLongVId E longvid
		val  _           = if is <> V then () else
				   error(i, E.DconDescNonCon)
		val  con'        = O.Con(i', id', [])
		val  typ'        = O.SingTyp(O.infoLongid longid', longid')
		val  spec'       = O.ConSpec(i', con', typ')
		val  _           = insertDisjointVal(E, vid', (i', stamp, is))
				   handle CollisionVal _ =>
				       error(i', E.SpecVIdDuplicate vid')
	   in
		trDconDesco' (E, spec'::acc) dcondesco
	   end



    and trStrDesco' (E,acc) =
	fn NONE => acc

	 | SOME(NEWStrDesc(_, strid as StrId(i',strid'), sigexp, strdesco)) =>
	   let
		val  i          = Source.over(i', infoSigExp sigexp)
		val (id',stamp) = trStrId_bind E strid
		val (inf',E')   = trSigExp E sigexp
		val  spec'      = O.ModSpec(i, id', inf')
		val  _          = insertDisjointStr(E, strid', (i', stamp, E'))
				  handle CollisionStr strid' =>
				      error(i', E.SpecStrIdDuplicate strid')
	   in
		trStrDesco' (E, spec'::acc) strdesco
	   end

	 | SOME(EQUALStrDesc(_, strid as StrId(i',strid'), sigexpo, longstrid,
								strdesco)) =>
	   let
		val  i           = Source.over(i', infoLong longstrid)
		val (id',stamp)  = trStrId_bind E strid
		val (longid',E') = trLongStrId E longstrid
		val  mod'        = longidToMod longid'
		val (mod'',E'')  = case sigexpo
				     of NONE => (mod',E')
				      | SOME sigexp =>
					let
					    val (inf',E'') = trSigExp E sigexp
					    val i''   = Source.over(
							  infoSigExp sigexp,
							  O.infoLongid longid')
					    val mod'' = O.AnnMod(i'', mod',inf')
					in
					    (mod'',E'')
					end
		val  inf'        = O.SingInf(O.infoMod mod'', mod'')
		val  spec'       = O.ModSpec(i, id', inf')
		val  _           = insertDisjointStr(E, strid', (i', stamp, E''))
				   handle CollisionStr strid' =>
				       error(i', E.SpecStrIdDuplicate strid')
	   in
		trStrDesco' (E, spec'::acc) strdesco
	   end



    and trSigDesco' (E,acc) =
	fn NONE => acc

	 | SOME(NEWSigDesc(_, sigid as SigId(i',sigid'), strpats, sigdesco)) =>
	   let
		val (id',stamp) = trSigId_bind E sigid
		val  _          = insertScope E
		val  idinfs'    = trStrPats E strpats
		val  inf'       = funinf(idinfs', O.AbsInf(i'))
		val  _          = deleteScope E
		val  spec'      = O.InfSpec(i', id', inf')
		val  _          = insertDisjointSig(E, sigid',
						    (i', stamp, Env.new()))
				  handle CollisionSig _ =>
				      error(i', E.SpecSigIdDuplicate sigid')
	   in
		trSigDesco' (E, spec'::acc) sigdesco
	   end

	 | SOME(EQUALSigDesc(_, sigid as SigId(i',sigid'), strpats, sigexp,
								sigdesco)) =>
	   let
		val  i          = Source.over(i', infoSigExp sigexp)
		val (id',stamp) = trSigId_bind E sigid
		val  _          = insertScope E
		val  idinfs'    = trStrPats E strpats
		val (inf',E')   = trSigExp E sigexp
		val  inf''      = funinf(idinfs', inf')
		val  _          = deleteScope E
		val  spec'      = O.InfSpec(i', id', inf'')
		val  _          = insertDisjointSig(E, sigid', (i', stamp, E'))
				  handle CollisionSig _ =>
				      error(i', E.SpecSigIdDuplicate sigid')
	   in
		trSigDesco' (E, spec'::acc) sigdesco
	   end



  (* Programs and components *)

    fun trProgramo  E programo = List.rev(trProgramo' (E,[]) programo)
    and trProgramo'(E,acc) =
	fn NONE => acc

	 | SOME(Program(i, dec, programo)) =>
	   let
		val acc' = trDec' (E,acc) dec
	   in
		trProgramo' (E,acc') programo
	   end


    fun trComponent E (Component(i, imp, programo)) =
	let
	    val imps' = trImport E imp
	    val decs' = trProgramo E programo
	in
	    O.Comp(i, imps', decs')
	end


    and trImport  E imp  = List.rev(trImport' (E,[]) imp)
    and trImport'(E,acc) =
	fn IMPORTImport(i, spec, s) =>
	   let
		val specs' = trSpec E spec
	   in
		O.Imp(i, specs', s) :: acc
	   end

	 | EMPTYImport(i) =>
		acc

	 | SEQImport(i, imp1, imp2) =>
		trImport' (E, trImport' (E,acc) imp1) imp2


    val translate = trComponent

  end
(* src # 97 *)
(*
 * Standard ML derived forms
 *
 * Definition, Appendix A
 *
 * Extensions and modifications:
 *   - recursive expressions:
 *	rec pat => exp     ==>     let val rec x as pat = exp in x end
 *     where x is a fresh identifier.
 *   - exception declarations have been made a derived form:
 *	exception exbind          ==>  con exbind'
 *	vid <of ty> <and exbind>  ==>  vid <of ty> : exn <and exbind'>
 *   - abstype has been made a derived form:
 *	abstype datbind <withtype tybind> with dec end
 *	  ==>
 *	<type typbind> local datatype datbind in type typbind' dec end
 *     where typbind' contains a binding t = t for each tycon t bound in
 *     datbind. Note that this results in a different treatment of equality.
 *   - include takes longsigids:
 *	include longsigid_1 ... longsigid_n
 *	==>
 *	include longsigid_1 ; ... ; include longsigid_n
 *   - derived forms for primitive declarations similar to specifications:
 *   - where constraints have been made a derived form of intersection:
 *	sigexp where type tyvarseq strid_1....strid_n.tycon = ty
 *	==>
 *      sigexp where sig structure strid_1 :
 *			...
 *			   sig structure strid_n :
 *			      sig type tyvarseq tycon = ty end
 *			   end
 *			...
 *		     end
 *
 *	sigexp where strid_1....strid_n.strid = longstrid
 *	==>
 *      sigexp where sig structure strid_1 :
 *			...
 *			   sig structure strid_n :
 *			      sig structure strid = longstrid end
 *			   end
 *			...
 *		     end
 *
 * We did NOT introduce a sharing signature ... and signature ... derived form
 * similar to types, because we consider that one completely broken.
 *
 * Notes:
 * - Two phrases named Fmatch and Fmrule have been added to factorize FvalBind.
 * - A phrase named TyReaDesc has been added to factorize type
 *   realisation signature expressions.
 *)


signature DERIVED_FORMS =
  sig

    (* Import *)

    structure Grammar: INPUT_GRAMMAR = InputGrammar

    type Info      = Grammar.Info

    type Lab       = Grammar.Lab
    type VId       = Grammar.VId
    type StrId     = Grammar.StrId
    type LongVId   = Grammar.LongVId
    type LongTyCon = Grammar.LongTyCon
    type LongStrId = Grammar.LongStrId
    type LongSigId = Grammar.LongSigId

    type Op        = Grammar.Op
    type AtExp     = Grammar.AtExp
    type AppExp    = Grammar.Exp
    type InfExp    = Grammar.Exp
    type Exp       = Grammar.Exp
    type ExpRow    = Grammar.ExpRow
    type Match     = Grammar.Match
    type Mrule     = Grammar.Mrule
    type Dec       = Grammar.Dec
    type ValBind   = Grammar.ValBind
    type FvalBind  = Grammar.FvalBind
    type ExBind    = Grammar.DconBind
    type Fmatch    = Grammar.Match
    type Fmrule    = Grammar.Mrule
    type Fpat      = Grammar.Pat
    type TypBind   = Grammar.TypBind
    type DatBind   = Grammar.DatBind
    type AtPat     = Grammar.AtPat
    type PatRow    = Grammar.PatRow
    type Pat       = Grammar.Pat
    type Ty        = Grammar.Ty
    type TyVarSeq  = Grammar.TyVarSeq
    type AtStrExp  = Grammar.AtStrExp
    type AppStrExp = Grammar.StrExp
    type StrExp    = Grammar.StrExp
    type StrPat    = Grammar.StrPat
    type StrBind   = Grammar.StrBind
    type AppSigExp = Grammar.SigExp
    type SigExp    = Grammar.SigExp
    type Spec      = Grammar.Spec
    type ValDesc   = Grammar.ValDesc
    type TypDesc   = Grammar.TypDesc
    type DatDesc   = Grammar.DatDesc
    type ExDesc    = Grammar.DconDesc
    type FunBind
    type FunDesc
    type Rea
    type Program   = Grammar.Program

    (* Expressions *)

    val UNITAtExp:   Info                                      -> AtExp
    val TUPLEAtExp:  Info * Exp list                           -> AtExp
    val HASHAtExp:   Info * Lab                                -> AtExp
    val CASEExp:     Info * Exp * Match                        -> Exp
    val IFExp:       Info * Exp * Exp * Exp                    -> Exp
    val ANDALSOExp:  Info * Exp * Exp                          -> Exp
    val ORELSEExp:   Info * Exp * Exp                          -> Exp
    val SEQAtExp:    Info * Exp list                           -> AtExp
    val LETAtExp:    Info * Dec * Exp list                     -> AtExp
    val WHILEExp:    Info * Exp * Exp                          -> Exp
    val LISTAtExp:   Info * Exp list                           -> AtExp
    val RECExp:      Info * Pat * Exp                          -> Exp

    val VIDExpRow:   Info * VId * Ty option * ExpRow option    -> ExpRow

    (* Patterns *)

    val UNITAtPat:   Info                                      -> AtPat
    val TUPLEAtPat:  Info * Pat list                           -> AtPat
    val LISTAtPat:   Info * Pat list                           -> AtPat

    val VIDPatRow:   Info * VId * Ty option * Pat option * PatRow option
                                                               -> PatRow
    val WITHFUNPat:  Info * Pat * FvalBind                     -> Pat

    (* Types *)

    val TUPLETy:     Info * Ty list                            -> Ty

    (* Bindings *)

    val FvalBind:    Info * Fmatch * FvalBind option           -> FvalBind
    val Fmatch:      Info * Fmrule * Fmatch option             -> Fmatch
    val Fmrule:      Info * Fpat * Exp                         -> Fmrule

    (* Declarations *)

    val FUNDec:		Info * TyVarSeq * FvalBind		-> Dec
    val DATATYPEDec:	Info * DatBind * TypBind option		-> Dec
    val ABSTYPEDec:	Info * DatBind * TypBind option * Dec	-> Dec
    val EXCEPTIONDec:	Info * ExBind				-> Dec
    val FUNCTORDec:     Info * FunBind                          -> Dec
    val OPENMULTIDec:	Info * LongStrId list			-> Dec
    val INFIXMULTIDec:	Info * int option * VId list		-> Dec
    val INFIXRMULTIDec:	Info * int option * VId list		-> Dec
    val NONFIXMULTIDec:	Info * VId list				-> Dec

    val NEWExBind:    Info * Op * VId * Ty option * ExBind option    -> ExBind
    val EQUALExBind:  Info * Op * VId * Op * LongVId * ExBind option -> ExBind

    (* Structure bindings *)

    val TRANSStrBind:     Info * StrId * SigExp option * StrExp
			       * StrBind option                    -> StrBind
    val OPAQStrBind:      Info * StrId * SigExp * StrExp
			       * StrBind option                    -> StrBind
    val WILDCARDStrBind:  Info * SigExp option * StrExp
			       * StrBind option                    -> StrBind

    (* Structure expressions *)

    val DECAtStrExp:      Info * Dec -> AtStrExp
    val FCTStrExp:        Info * StrPat * StrExp -> StrExp

    val STRIDStrPat:      Info * StrId * SigExp -> StrPat
    val WILDCARDStrPat:   Info * SigExp         -> StrPat
    val SPECStrPat:       Info * Spec           -> StrPat

    (* Functor bindings *)

    val TRANSFunBind:     Info * StrId * StrPat list * SigExp option
			       * StrExp * FunBind option           -> FunBind
    val OPAQFunBind:      Info * StrId * StrPat list * SigExp
			       * StrExp * FunBind option           -> FunBind

    (* Specifications *)

    val FUNSpec:          Info * ValDesc                           -> Spec
    val DATATYPESpec:     Info * DatDesc * TypDesc option          -> Spec
    val EXCEPTIONSpec:    Info * ExDesc                            -> Spec
    val FUNCTORSpec:      Info * FunDesc                           -> Spec
    val SHARINGSpec:      Info * Spec * LongStrId list             -> Spec
    val INCLUDEMULTISpec: Info * LongSigId list                    -> Spec
    val INFIXMULTISpec:   Info * int option * VId list             -> Spec
    val INFIXRMULTISpec:  Info * int option * VId list             -> Spec
    val NONFIXMULTISpec:  Info * VId list                          -> Spec

    val NEWExDesc:        Info * Op * VId * Ty option * ExDesc option -> ExDesc
    val EQUALExDesc:      Info * Op * VId * Op * LongVId
						      * ExDesc option -> ExDesc

    val FunDesc:          Info * StrId * StrPat list * SigExp * FunDesc option
								   -> FunDesc

    (* Signature expressions *)

    val WHEREREASigExp:   Info * SigExp * Rea                      -> SigExp
    val WHERELONGSTRIDSigExp:
			  Info * SigExp * LongStrId * LongStrId    -> SigExp

    val VALRea:           Info * Op * LongVId * Op * LongVId * Rea option -> Rea
    val FUNRea:           Info * Op * LongVId * Op * LongVId * Rea option -> Rea
    val CONSTRUCTORRea:   Info * Op * LongVId * Op * LongVId * Rea option -> Rea
    val EXCEPTIONRea:     Info * Op * LongVId * Op * LongVId * Rea option -> Rea
    val TYPERea:          Info * TyVarSeq * LongTyCon * Ty * Rea option   -> Rea
    val STRUCTURERea:     Info * LongStrId * SigExp option * LongStrId
							   * Rea option   -> Rea
    val FUNCTORRea:       Info * LongStrId * SigExp option * LongStrId
							   * Rea option   -> Rea
    val SIGNATURERea:     Info * LongSigId * StrPat list * AppSigExp
							 * Rea option     -> Rea

    (* Programs *)

    val DECProgram:       Info * Dec * Program option -> Program
    val EXPProgram:       Info * Exp * Program option -> Program

  end
(* src # 98 *)
signature Parser_TOKENS =
sig
type ('a,'b) token
type svalue
val ETYVAR: (string) *  'a * 'a -> (svalue,'a) token
val TYVAR: (string) *  'a * 'a -> (svalue,'a) token
val STAR:  'a * 'a -> (svalue,'a) token
val SYMBOL: (string) *  'a * 'a -> (svalue,'a) token
val ALPHA: (string) *  'a * 'a -> (svalue,'a) token
val CHAR: (WideChar.char) *  'a * 'a -> (svalue,'a) token
val STRING: (WideString.string) *  'a * 'a -> (svalue,'a) token
val REAL: (LargeReal.real) *  'a * 'a -> (svalue,'a) token
val WORD: (LargeWord.word) *  'a * 'a -> (svalue,'a) token
val INT: (LargeInt.int) *  'a * 'a -> (svalue,'a) token
val NUMERIC: (LargeInt.int) *  'a * 'a -> (svalue,'a) token
val DIGIT: (int) *  'a * 'a -> (svalue,'a) token
val ZERO:  'a * 'a -> (svalue,'a) token
val COLONGREATER:  'a * 'a -> (svalue,'a) token
val WHERE:  'a * 'a -> (svalue,'a) token
val STRUCTURE:  'a * 'a -> (svalue,'a) token
val STRUCT:  'a * 'a -> (svalue,'a) token
val SIGNATURE:  'a * 'a -> (svalue,'a) token
val SIG:  'a * 'a -> (svalue,'a) token
val SHARING:  'a * 'a -> (svalue,'a) token
val INCLUDE:  'a * 'a -> (svalue,'a) token
val FUNCTOR:  'a * 'a -> (svalue,'a) token
val EQTYPE:  'a * 'a -> (svalue,'a) token
val EQEQTYPE:  'a * 'a -> (svalue,'a) token
val PREBOUND:  'a * 'a -> (svalue,'a) token
val INSTANCE:  'a * 'a -> (svalue,'a) token
val OVERLOAD:  'a * 'a -> (svalue,'a) token
val PRIMITIVE:  'a * 'a -> (svalue,'a) token
val FROM:  'a * 'a -> (svalue,'a) token
val IMPORT:  'a * 'a -> (svalue,'a) token
val UNPACK:  'a * 'a -> (svalue,'a) token
val PACK:  'a * 'a -> (svalue,'a) token
val FCT:  'a * 'a -> (svalue,'a) token
val ANY:  'a * 'a -> (svalue,'a) token
val HASHBRACK:  'a * 'a -> (svalue,'a) token
val DOT:  'a * 'a -> (svalue,'a) token
val WITHVAL:  'a * 'a -> (svalue,'a) token
val WITHFUN:  'a * 'a -> (svalue,'a) token
val NON:  'a * 'a -> (svalue,'a) token
val CONSTRUCTOR:  'a * 'a -> (svalue,'a) token
val HASH:  'a * 'a -> (svalue,'a) token
val ARROW:  'a * 'a -> (svalue,'a) token
val DARROW:  'a * 'a -> (svalue,'a) token
val EQUALS:  'a * 'a -> (svalue,'a) token
val BAR:  'a * 'a -> (svalue,'a) token
val UNDERBAR:  'a * 'a -> (svalue,'a) token
val DOTS:  'a * 'a -> (svalue,'a) token
val SEMICOLON:  'a * 'a -> (svalue,'a) token
val COLON:  'a * 'a -> (svalue,'a) token
val COMMA:  'a * 'a -> (svalue,'a) token
val RBRACE:  'a * 'a -> (svalue,'a) token
val LBRACE:  'a * 'a -> (svalue,'a) token
val RBRACK:  'a * 'a -> (svalue,'a) token
val LBRACK:  'a * 'a -> (svalue,'a) token
val RPAR:  'a * 'a -> (svalue,'a) token
val LPAR:  'a * 'a -> (svalue,'a) token
val WHILE:  'a * 'a -> (svalue,'a) token
val WITHTYPE:  'a * 'a -> (svalue,'a) token
val WITH:  'a * 'a -> (svalue,'a) token
val VAL:  'a * 'a -> (svalue,'a) token
val TYPE:  'a * 'a -> (svalue,'a) token
val THEN:  'a * 'a -> (svalue,'a) token
val REC:  'a * 'a -> (svalue,'a) token
val RAISE:  'a * 'a -> (svalue,'a) token
val ORELSE:  'a * 'a -> (svalue,'a) token
val OPEN:  'a * 'a -> (svalue,'a) token
val OP:  'a * 'a -> (svalue,'a) token
val OF:  'a * 'a -> (svalue,'a) token
val NONFIX:  'a * 'a -> (svalue,'a) token
val LOCAL:  'a * 'a -> (svalue,'a) token
val LET:  'a * 'a -> (svalue,'a) token
val INFIXR:  'a * 'a -> (svalue,'a) token
val INFIX:  'a * 'a -> (svalue,'a) token
val IN:  'a * 'a -> (svalue,'a) token
val IF:  'a * 'a -> (svalue,'a) token
val HANDLE:  'a * 'a -> (svalue,'a) token
val FUN:  'a * 'a -> (svalue,'a) token
val FN:  'a * 'a -> (svalue,'a) token
val EXCEPTION:  'a * 'a -> (svalue,'a) token
val END:  'a * 'a -> (svalue,'a) token
val ELSE:  'a * 'a -> (svalue,'a) token
val DATATYPE:  'a * 'a -> (svalue,'a) token
val DO:  'a * 'a -> (svalue,'a) token
val CASE:  'a * 'a -> (svalue,'a) token
val AS:  'a * 'a -> (svalue,'a) token
val ANDALSO:  'a * 'a -> (svalue,'a) token
val AND:  'a * 'a -> (svalue,'a) token
val ABSTYPE:  'a * 'a -> (svalue,'a) token
val EOF:  'a * 'a -> (svalue,'a) token
end
signature Parser_LRVALS=
sig
structure Tokens : Parser_TOKENS
structure ParserData:PARSER_DATA
sharing type ParserData.Token.token = Tokens.token
sharing type ParserData.svalue = Tokens.svalue
end
(* src # 99 *)

functor LrVals(structure Token:        TOKEN
			structure DerivedForms: DERIVED_FORMS
		       )
	 = 
struct
structure ParserData=
struct
structure Header = 
struct
(*										*)
(* Standard ML syntactic analysis						*)
(*										*)
(* Definition, sections 2, 3, and 8, Appendix A and B				*)
(*										*)
(* Extensions:									*)
(*   - allow = to be bound as vid (in a pattern it must be prefixed by op)	*)
(*   - record update expressions:						*)
(*	  atexp ::= { atexp where exprow }					*)
(*   - vector expressions and patterns:						*)
(*	  atexp ::= #[ exp_1 , ... , exp_n ] 	(n>=0)				*)
(*	  atpat ::= #[ pat_1 , ... , pat_n ]	(n>=0)				*)
(*   - punning in record expressions (derived form):				*)
(*	  exprow ::= vid <: ty> <, exprow>					*)
(*   - recursive expressions (derived form):					*)
(*	  exp ::= rec pat => exp						*)
(*   - more relaxed constructor pattern syntax:					*)
(*	  pat ::= pat atpat			(R)				*)
(*   - generalized layered patterns:						*)
(*	  pat ::= pat as pat			(R)				*)
(*   - alternative and guarded patterns:					*)
(*	  atpat ::= ( pat_1 | ... | pat_n )	(n>=2)				*)
(*	  pat   ::= pat where atexp		(L)				*)
(*   - negated patterns:							*)
(*	  pat ::= non pat							*)
(*   - with patterns:								*)
(*	  pat ::= pat withval valbind end					*)
(*	      ::= pat withfun fvalbind end	(derived form)			*)
(*   - open datatypes (exception declarations become a derived form),		*)
(*     constructor synonym specifications:					*)
(*        dec      ::= constructor dconbind					*)
(*	  datbind  ::= tyvarseq tycon						*)
(*	  dconbind ::= <op> vid <of ty> : tyvarseq longtycon <and dconbind>	*)
(*		   ::= <op> vid = <op> longvid <and dconbind>			*)
(*        spec     ::= constructor dcondesc					*)
(*	  datdesc  ::= tyvarseq tycon						*)
(*	  dcondesc ::= vid <of ty> : tyvarseq longtycon <and dcondesc>		*)
(*		   ::= vid = longvid <and dcondesc>				*)
(*   - abstract type declarations:						*)
(*	  typbind  ::= tyvarseq tycon						*)
(*	  dec      ::= eqtype typbind						*)
(*   - straightified type specifications:					*)
(*	  typdesc ::= tyvarseq tycon						*)
(*		      tyvarseq tycon = ty					*)
(*   - where for structures:							*)
(*	  sigexp ::= sigexp where longstrid_1 = longstrid_2			*)
(*   - definitional structure specifications:					*)
(*	  strdesc ::= strid <: sigexp> = longstrid <and strdesc>		*)
(*   - top signature:								*)
(*	  sigexp ::= any							*)
(*   - parenthesised structure and signature expressions (derived forms):	*)
(*        strexp ::= ( strexp )							*)
(*        sigexp ::= ( sigexp )							*)
(*   - fun keyword in signatures (derived form):				*)
(*	  spec ::= fun valdesc							*)
(*   - op keyword in signatures:						*)
(*	  valdesc  ::= <op> vid : ty <and valdesc>				*)
(*	  condesc  ::= <op> vid <of ty> <| condesc>				*)
(*	  exdesc   ::= <op> vid <of ty> <and exdesc>				*)
(*	  dcondesc ::= <op> vid <of ty> : tyvarseq longtycon <and dcondesc>	*)
(*		   ::= <op> vid = <op> longvid <and dcondesc>			*)
(*   - withtype in signatures (derived form):					*)
(*	  spec ::= datatype datdesc <withtype syndesc>				*)
(*   - fixity directives in signatures:						*)
(*	  spec ::= infix <d> vid_1 ... vid_n	(n>=1)				*)
(*		   infixr <d> vid_1 ... vid_n	(n>=1)				*)
(*		   nonfix vid_1 ... vid_n	(n>=1)				*)
(*   - no distinction between dec, strdec, and topdec				*)
(*   - long signature identifiers:						*)
(*	  sigexp  ::= longsigid							*)
(*	  spec    ::= include longsigid_1 ... longsigid_n			*)
(*   - functor specifications:							*)
(*	  spec    ::= functor fundesc						*)
(*	  fundesc ::= strid ( strid : sigexp ) : sigexp <and fundesc>		*)
(*	          ::= strid ( spec ) : sigexp <and fundesc>			*)
(*   - signature specifications:						*)
(*	  spec    ::= signature sigdesc						*)
(*	  sigdesc ::= sigid <and sigdesc>					*)
(*	          ::= sigid = sigexp <and sigdesc>				*)
(*   - sharing and where for signature:						*)
(*	  spec   ::= spec sharing signature longsigid_1 = ... = longsigid_n	*)
(*	  sigexp ::= sigexp where signature longsigid_1 = sigexp		*)
(*   - components:								*)
(*	  component ::= import <program>					*)
(*	  import    ::= import spec from string					*)
(*			<>							*)
(*			import <;> import					*)
(*										*)
(* We did NOT introduce a sharing signature ... and signature ... derived form	*)
(* similar to types, because we consider that completely broken.		*)
(*										*)
(* To avoid hardwiring certain library issues, we further added the following	*)
(* low-level constructs:							*)
(*	  dec     ::= __prebound strid						*)
(*	          ::= __primitive val <op> vid : ty = string			*)
(*	          ::= __primitive constructor <op> vid <of ty> : ty = string	*)
(*	          ::= __primitive structure strid : sigexp = string		*)
(*	          ::= __overload <op> vid with tyvar : ty			*)
(*	          ::= __instance <op> vid with longtycon = longvid		*)
(*	          ::= __instance scon with longtycon				*)
(*	          ::= __eqtype typbind						*)
(*	  spec    ::= __eqtype typdesc						*)
(*	          ::= __prebound strid						*)
(*	          ::= __overload <op> vid with tyvar : ty			*)
(*	          ::= __instance <op> vid with longtycon = longvid		*)
(*	          ::= __instance scon with longtycon				*)
(*										*)
(* Notes:									*)
(*   - Two phrases named Fmatch and Fmrule have been added to factorize		*)
(*     Fvalbind.								*)
(*   - A phrase named SynDesc has been added to factorize type synonym		*)
(*     specifications. Similarly, a phrase named Rea has been added to		*)
(*     factorize realisation signature expressions.				*)
(*   - Infix expressions [Definition, section 2.6] are resolved during		*)
(*     elaboration because we allow fixity specifications in signatures that	*)
(*     come into effect by an open declaration. Infix status is completely	*)
(*     ignored here.								*)
(*   - Syntactic restrictions [Definition, sections 2.9 and 3.5] are checked	*)
(*     during elaboration, as well as the Fvalbind derived form.		*)
(*   - The Definition is not clear about whether `=' should also be legal as	*)
(*     a tycon. Since this would result in massive conflicts, and a type named	*)
(*     `=' could only be used legally if an implementation would be mad enough	*)
(*     to predefine it anyway, we simply disallow it.				*)
(*   - Datatype replication requires rules for datatype to be duplicated to	*)
(*     avoid conflicts on empty tyvarseqs.					*)
(*   - The messy `sigexp where type ... and type ...' syntax requires some	*)
(*     really ugly transformations (in absence of a lookahead of 2), watch out	*)
(*     for non-terminals of the form xxx__AND_yyybind_opt.			*)
(*   - We do NOT support declarations like					*)
(*	  fun f p1 = case e1 of p2 => e2					*)
(*	    | f p3 = e3								*)
(*     (without parentheses around the case) because the transformations	*)
(*     required to support this would be even a magnitude uglier than those	*)
(*     above. In fact, no compiler I know of supports this.			*)
(*   - ML-Yacc does not seem to like comments that stretch over several		*)
(*     lines... Similarly, comments in semantic actions make it puke...		*)
(*										*)



    (* Import *)

    open InputGrammar
    open DerivedForms


    (* Helper to build position fields *)

    fun I(left, right) = (left, right)



end
structure LrTable = Token.LrTable
structure Token = Token
local open LrTable in 
val table=let val actionRows =
"\
\\001\000\001\000\000\000\000\000\
\\001\000\001\000\225\004\002\000\225\004\003\000\225\004\004\000\225\004\
\\005\000\225\004\007\000\225\004\008\000\225\004\009\000\225\004\
\\010\000\225\004\011\000\225\004\013\000\225\004\014\000\225\004\
\\016\000\225\004\017\000\225\004\018\000\225\004\019\000\225\004\
\\020\000\225\004\021\000\225\004\022\000\225\004\023\000\225\004\
\\024\000\225\004\025\000\225\004\028\000\225\004\029\000\225\004\
\\030\000\225\004\034\000\225\004\035\000\225\004\036\000\225\004\
\\037\000\225\004\038\000\225\004\039\000\225\004\040\000\225\004\
\\041\000\225\004\042\000\225\004\044\000\225\004\045\000\225\004\
\\046\000\225\004\047\000\225\004\049\000\225\004\050\000\225\004\
\\052\000\225\004\053\000\225\004\054\000\231\004\055\000\225\004\
\\061\000\225\004\062\000\225\004\063\000\225\004\064\000\225\004\
\\065\000\225\004\066\000\225\004\067\000\225\004\068\000\225\004\
\\069\000\225\004\070\000\225\004\072\000\225\004\074\000\225\004\
\\075\000\225\004\076\000\225\004\077\000\225\004\078\000\225\004\
\\079\000\225\004\080\000\225\004\081\000\225\004\082\000\225\004\
\\083\000\225\004\084\000\225\004\085\000\225\004\086\000\225\004\
\\087\000\225\004\000\000\
\\001\000\001\000\228\004\002\000\228\004\003\000\228\004\004\000\228\004\
\\005\000\228\004\007\000\228\004\008\000\228\004\009\000\228\004\
\\010\000\228\004\011\000\228\004\013\000\228\004\014\000\228\004\
\\016\000\228\004\017\000\228\004\018\000\228\004\020\000\228\004\
\\021\000\228\004\022\000\228\004\024\000\228\004\025\000\228\004\
\\028\000\228\004\029\000\228\004\030\000\228\004\031\000\228\004\
\\032\000\228\004\035\000\228\004\037\000\228\004\039\000\228\004\
\\040\000\228\004\041\000\228\004\042\000\228\004\045\000\228\004\
\\046\000\228\004\047\000\228\004\048\000\228\004\050\000\228\004\
\\052\000\228\004\053\000\228\004\054\000\231\004\061\000\228\004\
\\062\000\228\004\063\000\228\004\064\000\228\004\065\000\228\004\
\\066\000\228\004\067\000\228\004\068\000\228\004\069\000\228\004\
\\070\000\228\004\072\000\228\004\074\000\228\004\075\000\228\004\
\\076\000\228\004\085\000\228\004\086\000\228\004\087\000\228\004\000\000\
\\001\000\001\000\232\004\002\000\232\004\003\000\232\004\004\000\232\004\
\\005\000\232\004\007\000\232\004\008\000\232\004\009\000\232\004\
\\010\000\232\004\011\000\232\004\013\000\232\004\014\000\232\004\
\\016\000\232\004\017\000\232\004\018\000\232\004\019\000\232\004\
\\020\000\232\004\021\000\232\004\022\000\232\004\024\000\232\004\
\\025\000\232\004\028\000\232\004\029\000\232\004\030\000\232\004\
\\031\000\232\004\032\000\232\004\034\000\232\004\035\000\232\004\
\\037\000\232\004\039\000\232\004\040\000\232\004\041\000\232\004\
\\042\000\232\004\045\000\232\004\046\000\232\004\047\000\232\004\
\\048\000\232\004\050\000\232\004\052\000\232\004\053\000\232\004\
\\054\000\231\004\061\000\232\004\062\000\232\004\063\000\232\004\
\\064\000\232\004\065\000\232\004\066\000\232\004\067\000\232\004\
\\068\000\232\004\069\000\232\004\070\000\232\004\072\000\232\004\
\\073\000\232\004\074\000\232\004\075\000\232\004\076\000\232\004\
\\085\000\232\004\086\000\232\004\087\000\232\004\000\000\
\\001\000\001\000\158\005\002\000\158\005\003\000\158\005\004\000\158\005\
\\005\000\158\005\007\000\158\005\008\000\158\005\009\000\158\005\
\\010\000\158\005\011\000\158\005\013\000\158\005\014\000\158\005\
\\016\000\158\005\017\000\158\005\018\000\158\005\020\000\158\005\
\\021\000\158\005\022\000\158\005\024\000\158\005\025\000\158\005\
\\028\000\158\005\029\000\158\005\030\000\158\005\031\000\158\005\
\\032\000\158\005\035\000\158\005\037\000\158\005\039\000\158\005\
\\040\000\158\005\041\000\158\005\042\000\158\005\045\000\158\005\
\\046\000\158\005\047\000\158\005\048\000\158\005\050\000\158\005\
\\052\000\158\005\053\000\158\005\061\000\158\005\062\000\158\005\
\\063\000\158\005\064\000\158\005\065\000\158\005\066\000\158\005\
\\067\000\158\005\068\000\158\005\069\000\158\005\070\000\158\005\
\\072\000\158\005\074\000\158\005\075\000\158\005\076\000\158\005\
\\085\000\170\005\086\000\170\005\087\000\156\001\000\000\
\\001\000\001\000\200\005\002\000\200\005\003\000\165\002\008\000\200\005\
\\010\000\200\005\011\000\200\005\013\000\200\005\016\000\200\005\
\\017\000\200\005\018\000\200\005\019\000\131\001\020\000\200\005\
\\021\000\200\005\024\000\200\005\029\000\200\005\030\000\200\005\
\\034\000\130\001\035\000\200\005\041\000\188\005\042\000\200\005\
\\050\000\200\005\062\000\200\005\063\000\200\005\064\000\200\005\
\\065\000\200\005\066\000\200\005\067\000\200\005\068\000\200\005\
\\072\000\200\005\073\000\129\001\074\000\200\005\076\000\188\005\
\\085\000\104\000\000\000\
\\001\000\001\000\200\005\002\000\200\005\003\000\165\002\008\000\200\005\
\\010\000\200\005\011\000\200\005\013\000\200\005\016\000\200\005\
\\017\000\200\005\018\000\200\005\020\000\200\005\021\000\200\005\
\\024\000\200\005\029\000\200\005\030\000\200\005\035\000\200\005\
\\041\000\229\005\042\000\200\005\050\000\200\005\062\000\200\005\
\\063\000\200\005\064\000\200\005\065\000\200\005\066\000\200\005\
\\067\000\200\005\068\000\200\005\072\000\200\005\074\000\200\005\
\\075\000\229\005\076\000\229\005\000\000\
\\001\000\001\000\200\005\002\000\200\005\003\000\170\004\008\000\200\005\
\\010\000\200\005\011\000\200\005\013\000\200\005\016\000\200\005\
\\017\000\200\005\018\000\200\005\019\000\131\001\020\000\200\005\
\\021\000\200\005\024\000\200\005\029\000\200\005\030\000\200\005\
\\034\000\130\001\035\000\200\005\041\000\006\006\042\000\200\005\
\\050\000\200\005\062\000\200\005\063\000\200\005\064\000\200\005\
\\065\000\200\005\066\000\200\005\067\000\200\005\068\000\200\005\
\\072\000\200\005\073\000\129\001\074\000\200\005\075\000\006\006\
\\076\000\006\006\085\000\104\000\000\000\
\\001\000\001\000\200\005\002\000\200\005\003\000\170\004\008\000\200\005\
\\010\000\200\005\011\000\200\005\013\000\200\005\016\000\200\005\
\\017\000\200\005\018\000\200\005\020\000\200\005\021\000\200\005\
\\024\000\200\005\029\000\200\005\030\000\200\005\035\000\200\005\
\\041\000\006\006\042\000\200\005\050\000\200\005\054\000\041\001\
\\062\000\200\005\063\000\200\005\064\000\200\005\065\000\200\005\
\\066\000\200\005\067\000\200\005\068\000\200\005\072\000\200\005\
\\074\000\200\005\075\000\006\006\076\000\006\006\000\000\
\\001\000\001\000\200\005\002\000\200\005\003\000\170\004\008\000\200\005\
\\010\000\200\005\011\000\200\005\013\000\200\005\016\000\200\005\
\\017\000\200\005\018\000\200\005\020\000\200\005\021\000\200\005\
\\024\000\200\005\029\000\200\005\030\000\200\005\035\000\200\005\
\\041\000\006\006\042\000\200\005\050\000\200\005\062\000\200\005\
\\063\000\200\005\064\000\200\005\065\000\200\005\066\000\200\005\
\\067\000\200\005\068\000\200\005\072\000\200\005\074\000\200\005\
\\075\000\006\006\076\000\006\006\000\000\
\\001\000\001\000\238\005\002\000\238\005\003\000\170\002\008\000\238\005\
\\010\000\238\005\011\000\238\005\013\000\238\005\016\000\238\005\
\\017\000\238\005\018\000\238\005\020\000\238\005\021\000\238\005\
\\024\000\238\005\029\000\238\005\030\000\238\005\035\000\238\005\
\\042\000\238\005\050\000\238\005\062\000\238\005\063\000\238\005\
\\064\000\238\005\065\000\238\005\066\000\238\005\067\000\238\005\
\\068\000\238\005\072\000\238\005\074\000\238\005\075\000\229\005\000\000\
\\001\000\001\000\238\005\002\000\238\005\003\000\095\004\008\000\238\005\
\\010\000\238\005\011\000\238\005\013\000\238\005\016\000\238\005\
\\017\000\238\005\018\000\238\005\019\000\131\001\020\000\238\005\
\\021\000\238\005\024\000\238\005\029\000\238\005\030\000\238\005\
\\034\000\130\001\035\000\238\005\042\000\238\005\050\000\238\005\
\\062\000\238\005\063\000\238\005\064\000\238\005\065\000\238\005\
\\066\000\238\005\067\000\238\005\068\000\238\005\072\000\238\005\
\\073\000\129\001\074\000\238\005\075\000\006\006\085\000\104\000\000\000\
\\001\000\001\000\238\005\002\000\238\005\003\000\095\004\008\000\238\005\
\\010\000\238\005\011\000\238\005\013\000\238\005\016\000\238\005\
\\017\000\238\005\018\000\238\005\020\000\238\005\021\000\238\005\
\\024\000\238\005\029\000\238\005\030\000\238\005\035\000\238\005\
\\042\000\238\005\050\000\238\005\054\000\041\001\062\000\238\005\
\\063\000\238\005\064\000\238\005\065\000\238\005\066\000\238\005\
\\067\000\238\005\068\000\238\005\072\000\238\005\074\000\238\005\
\\075\000\006\006\000\000\
\\001\000\001\000\238\005\002\000\238\005\003\000\095\004\008\000\238\005\
\\010\000\238\005\011\000\238\005\013\000\238\005\016\000\238\005\
\\017\000\238\005\018\000\238\005\020\000\238\005\021\000\238\005\
\\024\000\238\005\029\000\238\005\030\000\238\005\035\000\238\005\
\\042\000\238\005\050\000\238\005\062\000\238\005\063\000\238\005\
\\064\000\238\005\065\000\238\005\066\000\238\005\067\000\238\005\
\\068\000\238\005\072\000\238\005\074\000\238\005\075\000\006\006\000\000\
\\001\000\001\000\013\006\002\000\013\006\003\000\024\003\008\000\013\006\
\\010\000\013\006\011\000\013\006\013\000\013\006\016\000\013\006\
\\017\000\013\006\018\000\013\006\019\000\131\001\020\000\013\006\
\\021\000\013\006\024\000\013\006\029\000\013\006\030\000\013\006\
\\034\000\130\001\035\000\013\006\041\000\188\005\042\000\013\006\
\\050\000\013\006\062\000\013\006\063\000\013\006\064\000\013\006\
\\065\000\013\006\066\000\013\006\067\000\013\006\068\000\013\006\
\\072\000\013\006\073\000\129\001\074\000\013\006\076\000\188\005\
\\085\000\104\000\000\000\
\\001\000\001\000\013\006\002\000\013\006\003\000\024\003\008\000\013\006\
\\010\000\013\006\011\000\013\006\013\000\013\006\016\000\013\006\
\\017\000\013\006\018\000\013\006\020\000\013\006\021\000\013\006\
\\024\000\013\006\029\000\013\006\030\000\013\006\035\000\013\006\
\\041\000\229\005\042\000\013\006\050\000\013\006\062\000\013\006\
\\063\000\013\006\064\000\013\006\065\000\013\006\066\000\013\006\
\\067\000\013\006\068\000\013\006\072\000\013\006\074\000\013\006\
\\075\000\229\005\076\000\229\005\000\000\
\\001\000\001\000\013\006\002\000\013\006\003\000\194\004\008\000\013\006\
\\010\000\013\006\011\000\013\006\013\000\013\006\016\000\013\006\
\\017\000\013\006\018\000\013\006\019\000\131\001\020\000\013\006\
\\021\000\013\006\024\000\013\006\029\000\013\006\030\000\013\006\
\\034\000\130\001\035\000\013\006\041\000\006\006\042\000\013\006\
\\050\000\013\006\062\000\013\006\063\000\013\006\064\000\013\006\
\\065\000\013\006\066\000\013\006\067\000\013\006\068\000\013\006\
\\072\000\013\006\073\000\129\001\074\000\013\006\075\000\006\006\
\\076\000\006\006\085\000\104\000\000\000\
\\001\000\001\000\013\006\002\000\013\006\003\000\194\004\008\000\013\006\
\\010\000\013\006\011\000\013\006\013\000\013\006\016\000\013\006\
\\017\000\013\006\018\000\013\006\020\000\013\006\021\000\013\006\
\\024\000\013\006\029\000\013\006\030\000\013\006\035\000\013\006\
\\041\000\006\006\042\000\013\006\050\000\013\006\054\000\041\001\
\\062\000\013\006\063\000\013\006\064\000\013\006\065\000\013\006\
\\066\000\013\006\067\000\013\006\068\000\013\006\072\000\013\006\
\\074\000\013\006\075\000\006\006\076\000\006\006\000\000\
\\001\000\001\000\013\006\002\000\013\006\003\000\194\004\008\000\013\006\
\\010\000\013\006\011\000\013\006\013\000\013\006\016\000\013\006\
\\017\000\013\006\018\000\013\006\020\000\013\006\021\000\013\006\
\\024\000\013\006\029\000\013\006\030\000\013\006\035\000\013\006\
\\041\000\006\006\042\000\013\006\050\000\013\006\062\000\013\006\
\\063\000\013\006\064\000\013\006\065\000\013\006\066\000\013\006\
\\067\000\013\006\068\000\013\006\072\000\013\006\074\000\013\006\
\\075\000\006\006\076\000\006\006\000\000\
\\001\000\003\000\248\001\008\000\124\006\010\000\124\006\011\000\124\006\
\\013\000\124\006\017\000\124\006\018\000\124\006\021\000\124\006\
\\029\000\124\006\030\000\124\006\035\000\124\006\050\000\124\006\
\\061\000\124\006\063\000\124\006\064\000\124\006\065\000\124\006\
\\066\000\124\006\067\000\124\006\068\000\124\006\069\000\124\006\
\\070\000\124\006\072\000\124\006\074\000\124\006\075\000\229\005\000\000\
\\001\000\003\000\105\002\008\000\106\006\010\000\106\006\011\000\106\006\
\\013\000\106\006\017\000\106\006\018\000\106\006\021\000\106\006\
\\029\000\106\006\030\000\106\006\035\000\106\006\046\000\229\005\
\\050\000\106\006\061\000\106\006\063\000\106\006\064\000\106\006\
\\065\000\106\006\066\000\106\006\067\000\106\006\068\000\106\006\
\\069\000\106\006\070\000\106\006\072\000\106\006\074\000\106\006\
\\075\000\229\005\000\000\
\\001\000\003\000\236\002\008\000\141\006\010\000\141\006\011\000\141\006\
\\013\000\141\006\017\000\141\006\018\000\141\006\021\000\141\006\
\\029\000\141\006\030\000\141\006\035\000\141\006\050\000\141\006\
\\061\000\141\006\063\000\141\006\064\000\141\006\065\000\141\006\
\\066\000\141\006\067\000\141\006\068\000\141\006\069\000\141\006\
\\070\000\141\006\072\000\141\006\074\000\141\006\075\000\229\005\000\000\
\\001\000\003\000\059\004\008\000\106\006\010\000\106\006\011\000\106\006\
\\013\000\106\006\017\000\106\006\018\000\106\006\019\000\131\001\
\\021\000\106\006\029\000\106\006\030\000\106\006\034\000\130\001\
\\035\000\106\006\046\000\006\006\050\000\106\006\061\000\106\006\
\\063\000\106\006\064\000\106\006\065\000\106\006\066\000\106\006\
\\067\000\106\006\068\000\106\006\069\000\106\006\070\000\106\006\
\\072\000\106\006\073\000\129\001\074\000\106\006\075\000\006\006\
\\085\000\104\000\000\000\
\\001\000\003\000\059\004\008\000\106\006\010\000\106\006\011\000\106\006\
\\013\000\106\006\017\000\106\006\018\000\106\006\021\000\106\006\
\\029\000\106\006\030\000\106\006\035\000\106\006\046\000\006\006\
\\050\000\106\006\054\000\041\001\061\000\106\006\063\000\106\006\
\\064\000\106\006\065\000\106\006\066\000\106\006\067\000\106\006\
\\068\000\106\006\069\000\106\006\070\000\106\006\072\000\106\006\
\\074\000\106\006\075\000\006\006\000\000\
\\001\000\003\000\059\004\008\000\106\006\010\000\106\006\011\000\106\006\
\\013\000\106\006\017\000\106\006\018\000\106\006\021\000\106\006\
\\029\000\106\006\030\000\106\006\035\000\106\006\046\000\006\006\
\\050\000\106\006\061\000\106\006\063\000\106\006\064\000\106\006\
\\065\000\106\006\066\000\106\006\067\000\106\006\068\000\106\006\
\\069\000\106\006\070\000\106\006\072\000\106\006\074\000\106\006\
\\075\000\006\006\000\000\
\\001\000\003\000\118\004\008\000\124\006\010\000\124\006\011\000\124\006\
\\013\000\124\006\017\000\124\006\018\000\124\006\019\000\131\001\
\\021\000\124\006\029\000\124\006\030\000\124\006\034\000\130\001\
\\035\000\124\006\050\000\124\006\061\000\124\006\063\000\124\006\
\\064\000\124\006\065\000\124\006\066\000\124\006\067\000\124\006\
\\068\000\124\006\069\000\124\006\070\000\124\006\072\000\124\006\
\\073\000\129\001\074\000\124\006\075\000\006\006\085\000\104\000\000\000\
\\001\000\003\000\118\004\008\000\124\006\010\000\124\006\011\000\124\006\
\\013\000\124\006\017\000\124\006\018\000\124\006\021\000\124\006\
\\029\000\124\006\030\000\124\006\035\000\124\006\050\000\124\006\
\\054\000\041\001\061\000\124\006\063\000\124\006\064\000\124\006\
\\065\000\124\006\066\000\124\006\067\000\124\006\068\000\124\006\
\\069\000\124\006\070\000\124\006\072\000\124\006\074\000\124\006\
\\075\000\006\006\000\000\
\\001\000\003\000\118\004\008\000\124\006\010\000\124\006\011\000\124\006\
\\013\000\124\006\017\000\124\006\018\000\124\006\021\000\124\006\
\\029\000\124\006\030\000\124\006\035\000\124\006\050\000\124\006\
\\061\000\124\006\063\000\124\006\064\000\124\006\065\000\124\006\
\\066\000\124\006\067\000\124\006\068\000\124\006\069\000\124\006\
\\070\000\124\006\072\000\124\006\074\000\124\006\075\000\006\006\000\000\
\\001\000\003\000\128\004\008\000\141\006\010\000\141\006\011\000\141\006\
\\013\000\141\006\017\000\141\006\018\000\141\006\019\000\131\001\
\\021\000\141\006\029\000\141\006\030\000\141\006\034\000\130\001\
\\035\000\141\006\050\000\141\006\061\000\141\006\063\000\141\006\
\\064\000\141\006\065\000\141\006\066\000\141\006\067\000\141\006\
\\068\000\141\006\069\000\141\006\070\000\141\006\072\000\141\006\
\\073\000\129\001\074\000\141\006\075\000\006\006\085\000\104\000\000\000\
\\001\000\003\000\128\004\008\000\141\006\010\000\141\006\011\000\141\006\
\\013\000\141\006\017\000\141\006\018\000\141\006\021\000\141\006\
\\029\000\141\006\030\000\141\006\035\000\141\006\050\000\141\006\
\\054\000\041\001\061\000\141\006\063\000\141\006\064\000\141\006\
\\065\000\141\006\066\000\141\006\067\000\141\006\068\000\141\006\
\\069\000\141\006\070\000\141\006\072\000\141\006\074\000\141\006\
\\075\000\006\006\000\000\
\\001\000\003\000\128\004\008\000\141\006\010\000\141\006\011\000\141\006\
\\013\000\141\006\017\000\141\006\018\000\141\006\021\000\141\006\
\\029\000\141\006\030\000\141\006\035\000\141\006\050\000\141\006\
\\061\000\141\006\063\000\141\006\064\000\141\006\065\000\141\006\
\\066\000\141\006\067\000\141\006\068\000\141\006\069\000\141\006\
\\070\000\141\006\072\000\141\006\074\000\141\006\075\000\006\006\000\000\
\\001\000\004\000\099\000\007\000\056\001\014\000\098\000\025\000\097\000\
\\041\000\096\000\000\000\
\\001\000\004\000\099\000\009\000\093\002\014\000\098\000\025\000\097\000\
\\041\000\096\000\000\000\
\\001\000\004\000\099\000\014\000\098\000\022\000\108\001\025\000\097\000\
\\041\000\096\000\000\000\
\\001\000\004\000\099\000\014\000\098\000\025\000\097\000\028\000\090\001\
\\041\000\096\000\000\000\
\\001\000\004\000\099\000\014\000\098\000\025\000\097\000\035\000\053\001\
\\040\000\052\001\041\000\096\000\042\000\051\001\000\000\
\\001\000\004\000\099\000\014\000\098\000\025\000\097\000\041\000\096\000\
\\042\000\095\000\000\000\
\\001\000\005\000\225\004\039\000\225\004\040\000\225\004\041\000\225\004\
\\046\000\218\004\000\000\
\\001\000\005\000\226\004\039\000\226\004\040\000\226\004\041\000\226\004\
\\046\000\219\004\075\000\226\004\000\000\
\\001\000\005\000\227\004\039\000\227\004\040\000\227\004\041\000\227\004\
\\046\000\220\004\075\000\227\004\000\000\
\\001\000\005\000\063\001\035\000\214\001\040\000\213\001\041\000\062\001\
\\045\000\212\001\052\000\060\001\053\000\059\001\075\000\058\001\000\000\
\\001\000\005\000\063\001\041\000\062\001\046\000\061\001\052\000\060\001\
\\053\000\059\001\075\000\058\001\000\000\
\\001\000\005\000\063\001\041\000\062\001\047\000\082\001\052\000\060\001\
\\053\000\059\001\075\000\058\001\000\000\
\\001\000\005\000\063\001\041\000\062\001\047\000\097\001\052\000\060\001\
\\053\000\059\001\075\000\058\001\000\000\
\\001\000\006\000\068\000\012\000\065\000\015\000\063\000\019\000\060\000\
\\023\000\057\000\026\000\055\000\027\000\054\000\033\000\051\000\
\\034\000\050\000\035\000\152\000\036\000\049\000\038\000\048\000\
\\046\000\047\000\049\000\046\000\055\000\044\000\058\000\043\000\
\\077\000\033\000\078\000\032\000\079\000\031\000\080\000\030\000\
\\081\000\029\000\082\000\028\000\083\000\027\000\084\000\026\000\
\\085\000\025\000\086\000\024\000\087\000\023\000\000\000\
\\001\000\006\000\068\000\012\000\065\000\015\000\063\000\019\000\060\000\
\\023\000\057\000\026\000\055\000\027\000\054\000\033\000\051\000\
\\034\000\050\000\036\000\049\000\038\000\048\000\046\000\047\000\
\\049\000\046\000\055\000\044\000\058\000\043\000\077\000\033\000\
\\078\000\032\000\079\000\031\000\080\000\030\000\081\000\029\000\
\\082\000\028\000\083\000\027\000\084\000\026\000\085\000\025\000\
\\086\000\024\000\087\000\023\000\000\000\
\\001\000\010\000\017\002\000\000\
\\001\000\010\000\080\002\000\000\
\\001\000\010\000\081\002\000\000\
\\001\000\010\000\091\002\000\000\
\\001\000\010\000\092\002\000\000\
\\001\000\010\000\128\002\000\000\
\\001\000\010\000\201\002\000\000\
\\001\000\010\000\234\002\075\000\126\001\000\000\
\\001\000\010\000\072\003\041\000\130\002\076\000\129\002\000\000\
\\001\000\011\000\007\002\013\000\006\002\029\000\005\002\030\000\004\002\
\\050\000\003\002\068\000\002\002\072\000\001\002\074\000\000\002\000\000\
\\001\000\011\000\007\002\013\000\006\002\029\000\005\002\030\000\004\002\
\\050\000\003\002\068\000\002\002\072\000\001\002\074\000\000\002\
\\085\000\104\000\000\000\
\\001\000\011\000\212\002\013\000\211\002\029\000\210\002\030\000\209\002\
\\050\000\208\002\068\000\207\002\072\000\206\002\074\000\205\002\
\\085\000\104\000\000\000\
\\001\000\011\000\017\003\013\000\016\003\029\000\015\003\030\000\014\003\
\\050\000\013\003\068\000\012\003\072\000\011\003\074\000\010\003\
\\085\000\104\000\000\000\
\\001\000\011\000\017\003\013\000\016\003\029\000\015\003\030\000\014\003\
\\050\000\013\003\068\000\012\003\072\000\011\003\074\000\010\003\
\\085\000\108\000\000\000\
\\001\000\011\000\058\003\013\000\057\003\029\000\056\003\030\000\055\003\
\\050\000\054\003\068\000\053\003\072\000\052\003\074\000\051\003\
\\085\000\104\000\000\000\
\\001\000\011\000\058\003\013\000\057\003\029\000\056\003\030\000\055\003\
\\050\000\054\003\068\000\053\003\072\000\052\003\074\000\051\003\
\\085\000\108\000\000\000\
\\001\000\011\000\082\003\013\000\081\003\029\000\080\003\030\000\079\003\
\\050\000\078\003\068\000\077\003\072\000\076\003\074\000\075\003\
\\085\000\104\000\000\000\
\\001\000\011\000\176\003\013\000\175\003\029\000\174\003\030\000\173\003\
\\044\000\105\000\050\000\172\003\068\000\171\003\072\000\170\003\
\\074\000\169\003\085\000\104\000\000\000\
\\001\000\011\000\176\003\013\000\175\003\029\000\174\003\030\000\173\003\
\\050\000\172\003\068\000\171\003\072\000\170\003\074\000\169\003\
\\085\000\104\000\000\000\
\\001\000\011\000\253\003\013\000\252\003\029\000\251\003\030\000\250\003\
\\050\000\249\003\068\000\248\003\072\000\247\003\074\000\246\003\
\\085\000\104\000\000\000\
\\001\000\016\000\086\001\000\000\
\\001\000\016\000\087\001\000\000\
\\001\000\016\000\020\002\000\000\
\\001\000\016\000\136\002\000\000\
\\001\000\019\000\060\000\023\000\057\000\034\000\050\000\036\000\049\000\
\\038\000\048\000\046\000\047\000\049\000\046\000\055\000\044\000\
\\077\000\033\000\078\000\032\000\079\000\031\000\080\000\030\000\
\\081\000\029\000\082\000\028\000\083\000\027\000\084\000\026\000\
\\085\000\025\000\086\000\024\000\087\000\023\000\000\000\
\\001\000\019\000\235\000\034\000\234\000\056\000\233\000\057\000\232\000\
\\071\000\231\000\085\000\230\000\000\000\
\\001\000\019\000\235\000\034\000\234\000\056\000\233\000\057\000\245\001\
\\071\000\231\000\085\000\230\000\000\000\
\\001\000\019\000\235\000\034\000\234\000\056\000\233\000\057\000\059\002\
\\071\000\231\000\085\000\230\000\000\000\
\\001\000\019\000\235\000\034\000\234\000\056\000\233\000\057\000\111\002\
\\071\000\231\000\085\000\230\000\000\000\
\\001\000\019\000\235\000\034\000\234\000\056\000\233\000\057\000\142\002\
\\071\000\231\000\085\000\230\000\000\000\
\\001\000\019\000\235\000\034\000\234\000\056\000\233\000\057\000\002\003\
\\071\000\231\000\085\000\230\000\000\000\
\\001\000\019\000\235\000\034\000\234\000\056\000\233\000\057\000\116\003\
\\071\000\231\000\085\000\230\000\000\000\
\\001\000\019\000\235\000\034\000\234\000\056\000\233\000\071\000\231\000\
\\085\000\230\000\000\000\
\\001\000\019\000\131\001\034\000\130\001\057\000\014\002\059\000\013\002\
\\073\000\129\001\085\000\104\000\000\000\
\\001\000\019\000\131\001\034\000\130\001\057\000\053\002\059\000\052\002\
\\073\000\129\001\085\000\104\000\000\000\
\\001\000\019\000\131\001\034\000\130\001\057\000\179\002\059\000\178\002\
\\073\000\129\001\085\000\104\000\000\000\
\\001\000\023\000\168\000\027\000\167\000\034\000\166\000\036\000\165\000\
\\038\000\164\000\044\000\163\000\051\000\162\000\055\000\161\000\
\\077\000\033\000\078\000\032\000\079\000\031\000\080\000\030\000\
\\081\000\029\000\082\000\028\000\083\000\027\000\084\000\026\000\
\\085\000\025\000\086\000\024\000\087\000\023\000\088\000\115\000\000\000\
\\001\000\023\000\168\000\027\000\167\000\034\000\171\000\036\000\165\000\
\\038\000\164\000\044\000\163\000\051\000\162\000\055\000\161\000\
\\077\000\033\000\078\000\032\000\079\000\031\000\080\000\030\000\
\\081\000\029\000\082\000\028\000\083\000\027\000\084\000\026\000\
\\085\000\025\000\086\000\024\000\087\000\023\000\000\000\
\\001\000\023\000\168\000\034\000\166\000\036\000\165\000\038\000\164\000\
\\044\000\163\000\051\000\162\000\055\000\161\000\077\000\033\000\
\\078\000\032\000\079\000\031\000\080\000\030\000\081\000\029\000\
\\082\000\028\000\083\000\027\000\084\000\026\000\085\000\025\000\
\\086\000\024\000\087\000\023\000\088\000\115\000\000\000\
\\001\000\023\000\168\000\034\000\171\000\035\000\079\001\036\000\165\000\
\\038\000\164\000\044\000\163\000\051\000\162\000\055\000\161\000\
\\077\000\033\000\078\000\032\000\079\000\031\000\080\000\030\000\
\\081\000\029\000\082\000\028\000\083\000\027\000\084\000\026\000\
\\085\000\025\000\086\000\024\000\087\000\023\000\000\000\
\\001\000\023\000\168\000\034\000\171\000\035\000\079\001\036\000\165\000\
\\038\000\164\000\044\000\163\000\051\000\162\000\055\000\161\000\
\\077\000\033\000\078\000\032\000\079\000\031\000\080\000\030\000\
\\081\000\029\000\082\000\028\000\083\000\027\000\084\000\026\000\
\\085\000\025\000\086\000\024\000\087\000\023\000\088\000\115\000\000\000\
\\001\000\023\000\168\000\034\000\171\000\036\000\165\000\038\000\164\000\
\\044\000\163\000\051\000\162\000\055\000\161\000\077\000\033\000\
\\078\000\032\000\079\000\031\000\080\000\030\000\081\000\029\000\
\\082\000\028\000\083\000\027\000\084\000\026\000\085\000\025\000\
\\086\000\024\000\087\000\023\000\000\000\
\\001\000\029\000\222\000\072\000\221\000\085\000\104\000\000\000\
\\001\000\029\000\113\001\072\000\112\001\085\000\104\000\000\000\
\\001\000\030\000\125\000\050\000\124\000\074\000\123\000\000\000\
\\001\000\031\000\036\001\000\000\
\\001\000\031\000\140\001\000\000\
\\001\000\031\000\180\001\000\000\
\\001\000\031\000\182\001\000\000\
\\001\000\031\000\238\001\000\000\
\\001\000\031\000\025\002\000\000\
\\001\000\031\000\027\002\000\000\
\\001\000\034\000\116\000\085\000\208\000\086\000\207\000\088\000\115\000\000\000\
\\001\000\034\000\030\001\000\000\
\\001\000\035\000\054\001\000\000\
\\001\000\035\000\055\001\000\000\
\\001\000\035\000\178\001\000\000\
\\001\000\035\000\215\001\000\000\
\\001\000\035\000\216\001\000\000\
\\001\000\035\000\019\002\075\000\126\001\000\000\
\\001\000\035\000\046\002\000\000\
\\001\000\035\000\048\002\040\000\047\002\000\000\
\\001\000\035\000\060\002\000\000\
\\001\000\035\000\131\002\041\000\130\002\076\000\129\002\000\000\
\\001\000\035\000\133\002\000\000\
\\001\000\035\000\019\003\075\000\126\001\000\000\
\\001\000\035\000\020\003\075\000\126\001\000\000\
\\001\000\037\000\043\001\000\000\
\\001\000\037\000\050\001\000\000\
\\001\000\037\000\207\001\000\000\
\\001\000\037\000\211\001\000\000\
\\001\000\039\000\225\004\040\000\225\004\041\000\225\004\046\000\218\004\
\\054\000\231\004\075\000\225\004\000\000\
\\001\000\039\000\140\005\040\000\140\005\041\000\048\001\075\000\235\004\000\000\
\\001\000\039\000\045\001\000\000\
\\001\000\039\000\208\001\000\000\
\\001\000\039\000\044\002\000\000\
\\001\000\039\000\076\002\000\000\
\\001\000\041\000\183\001\000\000\
\\001\000\041\000\021\002\000\000\
\\001\000\041\000\031\002\046\000\030\002\000\000\
\\001\000\041\000\045\002\000\000\
\\001\000\041\000\061\002\000\000\
\\001\000\041\000\062\002\000\000\
\\001\000\041\000\072\002\000\000\
\\001\000\041\000\073\002\000\000\
\\001\000\041\000\147\002\000\000\
\\001\000\041\000\163\002\076\000\162\002\000\000\
\\001\000\041\000\183\002\000\000\
\\001\000\041\000\185\002\000\000\
\\001\000\041\000\231\002\000\000\
\\001\000\041\000\241\002\000\000\
\\001\000\041\000\006\003\000\000\
\\001\000\041\000\022\003\076\000\021\003\000\000\
\\001\000\041\000\120\003\000\000\
\\001\000\043\000\074\001\078\000\137\000\079\000\136\000\085\000\073\001\
\\086\000\144\000\087\000\143\000\000\000\
\\001\000\044\000\105\000\085\000\104\000\000\000\
\\001\000\046\000\221\004\075\000\209\004\000\000\
\\001\000\046\000\222\004\075\000\210\004\000\000\
\\001\000\046\000\047\000\085\000\025\000\086\000\024\000\087\000\023\000\000\000\
\\001\000\046\000\180\000\085\000\025\000\086\000\024\000\087\000\023\000\000\000\
\\001\000\046\000\180\000\085\000\179\000\086\000\024\000\087\000\023\000\000\000\
\\001\000\046\000\049\001\000\000\
\\001\000\046\000\092\001\000\000\
\\001\000\046\000\118\001\054\000\041\001\000\000\
\\001\000\046\000\164\001\000\000\
\\001\000\046\000\167\001\000\000\
\\001\000\046\000\168\001\000\000\
\\001\000\046\000\210\001\000\000\
\\001\000\046\000\241\001\000\000\
\\001\000\046\000\251\001\000\000\
\\001\000\046\000\253\001\000\000\
\\001\000\046\000\054\002\075\000\126\001\000\000\
\\001\000\046\000\063\002\000\000\
\\001\000\046\000\119\002\054\000\041\001\000\000\
\\001\000\046\000\180\002\075\000\126\001\000\000\
\\001\000\046\000\182\002\000\000\
\\001\000\046\000\184\002\075\000\126\001\000\000\
\\001\000\046\000\240\002\000\000\
\\001\000\046\000\032\003\000\000\
\\001\000\046\000\062\003\000\000\
\\001\000\046\000\063\003\000\000\
\\001\000\046\000\064\003\000\000\
\\001\000\046\000\065\003\000\000\
\\001\000\046\000\066\003\000\000\
\\001\000\046\000\067\003\000\000\
\\001\000\046\000\068\003\000\000\
\\001\000\046\000\069\003\000\000\
\\001\000\046\000\193\003\000\000\
\\001\000\046\000\194\003\000\000\
\\001\000\046\000\195\003\000\000\
\\001\000\046\000\196\003\000\000\
\\001\000\046\000\197\003\000\000\
\\001\000\046\000\198\003\000\000\
\\001\000\046\000\199\003\000\000\
\\001\000\046\000\200\003\000\000\
\\001\000\046\000\201\003\000\000\
\\001\000\046\000\237\003\000\000\
\\001\000\046\000\238\003\000\000\
\\001\000\046\000\239\003\000\000\
\\001\000\046\000\240\003\000\000\
\\001\000\046\000\241\003\000\000\
\\001\000\046\000\242\003\000\000\
\\001\000\046\000\243\003\000\000\
\\001\000\046\000\244\003\000\000\
\\001\000\046\000\009\004\000\000\
\\001\000\046\000\010\004\000\000\
\\001\000\046\000\011\004\000\000\
\\001\000\046\000\012\004\000\000\
\\001\000\046\000\013\004\000\000\
\\001\000\046\000\014\004\000\000\
\\001\000\046\000\015\004\000\000\
\\001\000\046\000\016\004\000\000\
\\001\000\046\000\022\004\000\000\
\\001\000\046\000\023\004\000\000\
\\001\000\046\000\024\004\000\000\
\\001\000\046\000\025\004\000\000\
\\001\000\046\000\026\004\000\000\
\\001\000\046\000\027\004\000\000\
\\001\000\046\000\028\004\000\000\
\\001\000\046\000\029\004\000\000\
\\001\000\046\000\085\004\000\000\
\\001\000\046\000\086\004\000\000\
\\001\000\046\000\087\004\000\000\
\\001\000\046\000\088\004\000\000\
\\001\000\046\000\089\004\000\000\
\\001\000\046\000\090\004\000\000\
\\001\000\046\000\091\004\000\000\
\\001\000\046\000\092\004\000\000\
\\001\000\046\000\150\004\000\000\
\\001\000\046\000\151\004\000\000\
\\001\000\046\000\152\004\000\000\
\\001\000\046\000\153\004\000\000\
\\001\000\046\000\154\004\000\000\
\\001\000\046\000\155\004\000\000\
\\001\000\046\000\156\004\000\000\
\\001\000\046\000\157\004\000\000\
\\001\000\047\000\232\002\000\000\
\\001\000\047\000\007\003\000\000\
\\001\000\047\000\121\003\000\000\
\\001\000\048\000\018\002\000\000\
\\001\000\048\000\213\002\000\000\
\\001\000\048\000\018\003\000\000\
\\001\000\048\000\059\003\000\000\
\\001\000\048\000\083\003\000\000\
\\001\000\048\000\177\003\000\000\
\\001\000\048\000\254\003\000\000\
\\001\000\054\000\101\000\000\000\
\\001\000\054\000\132\001\000\000\
\\001\000\054\000\252\001\000\000\
\\001\000\061\000\214\000\000\000\
\\001\000\075\000\046\001\000\000\
\\001\000\075\000\171\002\000\000\
\\001\000\075\000\215\002\000\000\
\\001\000\075\000\237\002\000\000\
\\001\000\078\000\137\000\079\000\136\000\085\000\135\000\086\000\134\000\
\\087\000\133\000\000\000\
\\001\000\078\000\137\000\079\000\136\000\085\000\073\001\086\000\144\000\
\\087\000\143\000\000\000\
\\001\000\083\000\114\001\000\000\
\\001\000\083\000\030\003\000\000\
\\001\000\083\000\123\003\000\000\
\\001\000\083\000\255\003\000\000\
\\001\000\085\000\104\000\000\000\
\\001\000\085\000\108\000\000\000\
\\001\000\085\000\208\000\086\000\207\000\000\000\
\\001\000\085\000\230\000\000\000\
\\001\000\085\000\125\001\086\000\207\000\000\000\
\\001\000\088\000\115\000\000\000\
\\208\004\000\000\
\\209\004\000\000\
\\210\004\000\000\
\\211\004\000\000\
\\212\004\000\000\
\\213\004\000\000\
\\214\004\000\000\
\\215\004\000\000\
\\216\004\000\000\
\\217\004\000\000\
\\218\004\000\000\
\\219\004\000\000\
\\220\004\000\000\
\\221\004\000\000\
\\222\004\000\000\
\\223\004\000\000\
\\224\004\000\000\
\\225\004\000\000\
\\226\004\000\000\
\\227\004\000\000\
\\228\004\000\000\
\\229\004\000\000\
\\230\004\000\000\
\\231\004\000\000\
\\232\004\000\000\
\\233\004\000\000\
\\234\004\000\000\
\\235\004\000\000\
\\236\004\000\000\
\\237\004\000\000\
\\238\004\000\000\
\\239\004\000\000\
\\240\004\000\000\
\\241\004\000\000\
\\242\004\000\000\
\\243\004\000\000\
\\244\004\008\000\233\001\023\000\121\000\000\000\
\\244\004\008\000\039\002\023\000\121\000\000\000\
\\244\004\023\000\121\000\000\000\
\\244\004\023\000\121\000\077\000\033\000\078\000\032\000\079\000\031\000\
\\080\000\030\000\081\000\029\000\082\000\028\000\083\000\027\000\
\\084\000\026\000\000\000\
\\245\004\000\000\
\\246\004\000\000\
\\247\004\000\000\
\\248\004\000\000\
\\249\004\000\000\
\\250\004\000\000\
\\251\004\000\000\
\\252\004\000\000\
\\253\004\000\000\
\\254\004\000\000\
\\255\004\000\000\
\\000\005\000\000\
\\001\005\000\000\
\\002\005\000\000\
\\003\005\006\000\068\000\012\000\065\000\015\000\063\000\019\000\060\000\
\\023\000\057\000\026\000\055\000\027\000\054\000\033\000\051\000\
\\034\000\050\000\036\000\049\000\038\000\048\000\046\000\047\000\
\\049\000\046\000\055\000\044\000\058\000\043\000\077\000\033\000\
\\078\000\032\000\079\000\031\000\080\000\030\000\081\000\029\000\
\\082\000\028\000\083\000\027\000\084\000\026\000\085\000\025\000\
\\086\000\024\000\087\000\023\000\000\000\
\\004\005\000\000\
\\005\005\004\000\099\000\014\000\098\000\025\000\097\000\040\000\042\001\
\\041\000\096\000\000\000\
\\006\005\000\000\
\\007\005\000\000\
\\008\005\004\000\099\000\014\000\098\000\025\000\097\000\041\000\096\000\
\\042\000\079\002\000\000\
\\009\005\000\000\
\\010\005\000\000\
\\011\005\000\000\
\\012\005\000\000\
\\013\005\004\000\099\000\014\000\098\000\025\000\097\000\040\000\193\001\
\\041\000\096\000\000\000\
\\013\005\040\000\193\001\000\000\
\\014\005\000\000\
\\015\005\019\000\060\000\023\000\057\000\034\000\050\000\036\000\049\000\
\\038\000\048\000\046\000\047\000\049\000\046\000\055\000\044\000\
\\077\000\033\000\078\000\147\000\079\000\146\000\080\000\030\000\
\\081\000\029\000\082\000\028\000\083\000\027\000\084\000\026\000\
\\085\000\145\000\086\000\144\000\087\000\143\000\000\000\
\\016\005\000\000\
\\017\005\000\000\
\\018\005\019\000\060\000\023\000\057\000\034\000\050\000\036\000\049\000\
\\038\000\048\000\046\000\047\000\049\000\046\000\055\000\044\000\
\\077\000\033\000\078\000\032\000\079\000\031\000\080\000\030\000\
\\081\000\029\000\082\000\028\000\083\000\027\000\084\000\026\000\
\\085\000\025\000\086\000\024\000\087\000\023\000\000\000\
\\019\005\000\000\
\\020\005\000\000\
\\021\005\004\000\099\000\041\000\096\000\000\000\
\\022\005\004\000\099\000\025\000\097\000\041\000\096\000\000\000\
\\023\005\000\000\
\\024\005\004\000\099\000\014\000\098\000\025\000\097\000\041\000\096\000\000\000\
\\025\005\004\000\099\000\014\000\098\000\025\000\097\000\041\000\096\000\000\000\
\\026\005\004\000\099\000\014\000\098\000\025\000\097\000\041\000\096\000\000\000\
\\027\005\000\000\
\\028\005\000\000\
\\029\005\004\000\099\000\014\000\098\000\025\000\097\000\041\000\096\000\000\000\
\\030\005\054\000\041\001\000\000\
\\031\005\000\000\
\\032\005\000\000\
\\033\005\045\000\099\001\000\000\
\\034\005\004\000\099\000\014\000\098\000\025\000\097\000\041\000\096\000\000\000\
\\035\005\002\000\069\000\008\000\067\000\011\000\066\000\013\000\064\000\
\\017\000\062\000\018\000\061\000\020\000\059\000\021\000\058\000\
\\024\000\056\000\029\000\053\000\030\000\052\000\042\000\184\000\
\\050\000\045\000\062\000\042\000\063\000\041\000\064\000\040\000\
\\065\000\039\000\066\000\038\000\067\000\037\000\068\000\036\000\
\\072\000\035\000\074\000\034\000\000\000\
\\036\005\002\000\069\000\008\000\067\000\011\000\066\000\013\000\064\000\
\\017\000\062\000\018\000\061\000\019\000\131\001\020\000\059\000\
\\021\000\058\000\024\000\056\000\029\000\053\000\030\000\052\000\
\\034\000\130\001\042\000\184\000\050\000\045\000\057\000\014\002\
\\059\000\013\002\062\000\042\000\063\000\041\000\064\000\040\000\
\\065\000\039\000\066\000\038\000\067\000\037\000\068\000\036\000\
\\072\000\035\000\073\000\129\001\074\000\034\000\085\000\104\000\000\000\
\\036\005\002\000\069\000\008\000\067\000\011\000\066\000\013\000\064\000\
\\017\000\062\000\018\000\061\000\020\000\059\000\021\000\058\000\
\\024\000\056\000\029\000\053\000\030\000\052\000\042\000\184\000\
\\050\000\045\000\062\000\042\000\063\000\041\000\064\000\040\000\
\\065\000\039\000\066\000\038\000\067\000\037\000\068\000\036\000\
\\072\000\035\000\074\000\034\000\000\000\
\\037\005\000\000\
\\038\005\002\000\069\000\008\000\067\000\011\000\066\000\013\000\064\000\
\\017\000\062\000\018\000\061\000\020\000\059\000\021\000\058\000\
\\024\000\056\000\029\000\053\000\030\000\052\000\050\000\045\000\
\\062\000\042\000\063\000\041\000\064\000\040\000\065\000\039\000\
\\066\000\038\000\067\000\037\000\068\000\036\000\072\000\035\000\
\\074\000\034\000\000\000\
\\039\005\000\000\
\\040\005\000\000\
\\041\005\002\000\069\000\008\000\067\000\011\000\066\000\013\000\064\000\
\\017\000\062\000\018\000\061\000\020\000\059\000\021\000\058\000\
\\024\000\056\000\029\000\053\000\030\000\052\000\050\000\045\000\
\\062\000\042\000\063\000\041\000\064\000\040\000\065\000\039\000\
\\066\000\038\000\067\000\037\000\068\000\036\000\072\000\035\000\
\\074\000\034\000\000\000\
\\042\005\000\000\
\\043\005\000\000\
\\044\005\000\000\
\\045\005\000\000\
\\046\005\000\000\
\\047\005\000\000\
\\048\005\000\000\
\\049\005\000\000\
\\050\005\000\000\
\\051\005\000\000\
\\052\005\000\000\
\\053\005\000\000\
\\054\005\000\000\
\\055\005\000\000\
\\056\005\000\000\
\\057\005\000\000\
\\058\005\000\000\
\\059\005\000\000\
\\060\005\000\000\
\\061\005\000\000\
\\062\005\000\000\
\\063\005\000\000\
\\064\005\000\000\
\\065\005\000\000\
\\066\005\000\000\
\\067\005\000\000\
\\068\005\000\000\
\\069\005\000\000\
\\070\005\000\000\
\\071\005\000\000\
\\072\005\032\000\103\001\000\000\
\\073\005\000\000\
\\074\005\046\000\180\000\085\000\179\000\086\000\024\000\087\000\023\000\000\000\
\\075\005\000\000\
\\076\005\054\000\041\001\085\000\104\000\000\000\
\\077\005\000\000\
\\078\005\077\000\189\000\078\000\188\000\000\000\
\\079\005\000\000\
\\080\005\000\000\
\\081\005\000\000\
\\082\005\003\000\083\002\004\000\099\000\014\000\098\000\025\000\097\000\
\\041\000\096\000\000\000\
\\083\005\000\000\
\\084\005\000\000\
\\085\005\003\000\096\001\000\000\
\\086\005\000\000\
\\087\005\000\000\
\\088\005\045\000\094\001\000\000\
\\089\005\004\000\099\000\014\000\098\000\025\000\097\000\041\000\096\000\000\000\
\\090\005\005\000\063\001\041\000\062\001\052\000\060\001\053\000\059\001\
\\075\000\058\001\000\000\
\\091\005\000\000\
\\092\005\000\000\
\\093\005\000\000\
\\094\005\003\000\177\001\000\000\
\\094\005\003\000\177\001\046\000\176\001\000\000\
\\095\005\000\000\
\\096\005\000\000\
\\097\005\000\000\
\\098\005\000\000\
\\099\005\000\000\
\\100\005\000\000\
\\101\005\000\000\
\\102\005\003\000\107\001\000\000\
\\102\005\003\000\107\001\046\000\106\001\000\000\
\\102\005\003\000\107\001\046\000\229\001\000\000\
\\102\005\003\000\107\001\046\000\237\001\000\000\
\\103\005\000\000\
\\104\005\000\000\
\\105\005\045\000\039\003\000\000\
\\106\005\000\000\
\\107\005\022\000\189\001\000\000\
\\107\005\022\000\189\001\046\000\188\001\000\000\
\\107\005\022\000\189\001\046\000\227\001\000\000\
\\107\005\022\000\189\001\046\000\029\002\000\000\
\\107\005\022\000\189\001\046\000\033\002\000\000\
\\108\005\000\000\
\\109\005\000\000\
\\110\005\000\000\
\\111\005\003\000\035\003\000\000\
\\112\005\000\000\
\\113\005\000\000\
\\114\005\000\000\
\\115\005\003\000\095\002\000\000\
\\116\005\000\000\
\\117\005\000\000\
\\118\005\000\000\
\\119\005\000\000\
\\120\005\000\000\
\\121\005\000\000\
\\122\005\000\000\
\\123\005\000\000\
\\124\005\000\000\
\\125\005\000\000\
\\126\005\000\000\
\\127\005\000\000\
\\128\005\023\000\168\000\034\000\171\000\036\000\165\000\038\000\164\000\
\\044\000\163\000\051\000\162\000\055\000\161\000\077\000\033\000\
\\078\000\032\000\079\000\031\000\080\000\030\000\081\000\029\000\
\\082\000\028\000\083\000\027\000\084\000\026\000\085\000\025\000\
\\086\000\024\000\087\000\023\000\000\000\
\\129\005\000\000\
\\130\005\005\000\063\001\040\000\206\001\041\000\062\001\052\000\060\001\
\\053\000\059\001\075\000\058\001\000\000\
\\131\005\000\000\
\\132\005\005\000\063\001\041\000\062\001\045\000\212\001\052\000\060\001\
\\053\000\059\001\075\000\058\001\000\000\
\\133\005\000\000\
\\134\005\000\000\
\\135\005\000\000\
\\136\005\000\000\
\\137\005\000\000\
\\138\005\005\000\063\001\040\000\192\002\041\000\062\001\052\000\060\001\
\\053\000\059\001\075\000\058\001\000\000\
\\138\005\040\000\192\002\000\000\
\\139\005\000\000\
\\140\005\041\000\048\001\000\000\
\\141\005\005\000\063\001\041\000\062\001\052\000\060\001\053\000\059\001\
\\075\000\058\001\000\000\
\\142\005\005\000\086\002\000\000\
\\143\005\000\000\
\\144\005\043\000\074\001\078\000\137\000\079\000\136\000\085\000\073\001\
\\086\000\144\000\087\000\143\000\000\000\
\\145\005\000\000\
\\146\005\000\000\
\\147\005\023\000\168\000\034\000\171\000\036\000\165\000\038\000\164\000\
\\044\000\163\000\055\000\161\000\077\000\033\000\078\000\032\000\
\\079\000\031\000\080\000\030\000\081\000\029\000\082\000\028\000\
\\083\000\027\000\084\000\026\000\085\000\025\000\086\000\024\000\
\\087\000\023\000\000\000\
\\148\005\000\000\
\\149\005\041\000\062\001\000\000\
\\150\005\005\000\063\001\041\000\062\001\000\000\
\\151\005\000\000\
\\152\005\000\000\
\\153\005\000\000\
\\154\005\048\000\157\001\000\000\
\\155\005\000\000\
\\156\005\000\000\
\\157\005\000\000\
\\159\005\000\000\
\\160\005\000\000\
\\161\005\000\000\
\\162\005\000\000\
\\163\005\000\000\
\\164\005\000\000\
\\165\005\000\000\
\\166\005\000\000\
\\167\005\040\000\254\002\000\000\
\\168\005\000\000\
\\169\005\078\000\137\000\079\000\136\000\085\000\135\000\086\000\134\000\
\\087\000\133\000\000\000\
\\171\005\034\000\017\001\038\000\016\001\058\000\015\001\088\000\115\000\000\000\
\\172\005\000\000\
\\173\005\000\000\
\\174\005\040\000\047\002\000\000\
\\175\005\000\000\
\\176\005\034\000\116\000\088\000\115\000\000\000\
\\177\005\000\000\
\\178\005\000\000\
\\179\005\000\000\
\\180\005\040\000\179\001\000\000\
\\181\005\000\000\
\\182\005\054\000\041\001\000\000\
\\183\005\000\000\
\\184\005\000\000\
\\185\005\000\000\
\\186\005\000\000\
\\187\005\000\000\
\\188\005\019\000\131\001\034\000\130\001\073\000\129\001\085\000\104\000\000\000\
\\189\005\075\000\126\001\000\000\
\\189\005\075\000\097\003\000\000\
\\189\005\075\000\187\003\000\000\
\\190\005\075\000\126\001\000\000\
\\190\005\075\000\097\003\000\000\
\\190\005\075\000\187\003\000\000\
\\191\005\041\000\130\002\076\000\129\002\000\000\
\\192\005\075\000\126\001\000\000\
\\192\005\075\000\097\003\000\000\
\\192\005\075\000\187\003\000\000\
\\193\005\000\000\
\\194\005\000\000\
\\195\005\000\000\
\\196\005\000\000\
\\197\005\000\000\
\\198\005\000\000\
\\199\005\000\000\
\\201\005\000\000\
\\202\005\000\000\
\\203\005\000\000\
\\204\005\000\000\
\\205\005\000\000\
\\206\005\000\000\
\\207\005\000\000\
\\208\005\000\000\
\\209\005\000\000\
\\210\005\000\000\
\\211\005\000\000\
\\212\005\000\000\
\\213\005\000\000\
\\214\005\000\000\
\\215\005\000\000\
\\216\005\000\000\
\\217\005\000\000\
\\218\005\000\000\
\\219\005\000\000\
\\220\005\075\000\126\001\000\000\
\\220\005\075\000\106\002\000\000\
\\221\005\041\000\025\001\000\000\
\\221\005\041\000\025\001\054\000\041\001\000\000\
\\221\005\041\000\025\001\076\000\024\001\000\000\
\\221\005\041\000\025\001\076\000\174\001\000\000\
\\221\005\041\000\116\001\000\000\
\\222\005\000\000\
\\223\005\000\000\
\\224\005\000\000\
\\225\005\000\000\
\\226\005\000\000\
\\227\005\000\000\
\\228\005\000\000\
\\229\005\000\000\
\\230\005\000\000\
\\231\005\000\000\
\\232\005\019\000\131\001\034\000\130\001\073\000\129\001\085\000\104\000\000\000\
\\233\005\054\000\041\001\000\000\
\\234\005\000\000\
\\235\005\000\000\
\\236\005\034\000\030\001\000\000\
\\237\005\000\000\
\\239\005\000\000\
\\240\005\000\000\
\\241\005\000\000\
\\242\005\000\000\
\\243\005\000\000\
\\244\005\000\000\
\\245\005\000\000\
\\246\005\000\000\
\\247\005\000\000\
\\248\005\000\000\
\\249\005\000\000\
\\250\005\000\000\
\\251\005\000\000\
\\252\005\000\000\
\\253\005\000\000\
\\254\005\000\000\
\\255\005\000\000\
\\000\006\000\000\
\\001\006\000\000\
\\002\006\000\000\
\\003\006\000\000\
\\004\006\000\000\
\\005\006\000\000\
\\006\006\003\000\211\003\000\000\
\\006\006\003\000\211\003\019\000\131\001\034\000\130\001\073\000\129\001\
\\085\000\104\000\000\000\
\\006\006\003\000\211\003\054\000\041\001\000\000\
\\007\006\000\000\
\\008\006\000\000\
\\009\006\000\000\
\\010\006\034\000\030\001\000\000\
\\011\006\000\000\
\\012\006\000\000\
\\014\006\000\000\
\\015\006\000\000\
\\016\006\000\000\
\\017\006\000\000\
\\018\006\000\000\
\\019\006\000\000\
\\020\006\000\000\
\\021\006\000\000\
\\022\006\000\000\
\\023\006\000\000\
\\024\006\000\000\
\\025\006\000\000\
\\026\006\000\000\
\\027\006\000\000\
\\028\006\000\000\
\\029\006\000\000\
\\030\006\000\000\
\\031\006\000\000\
\\032\006\000\000\
\\033\006\008\000\092\000\011\000\091\000\013\000\090\000\017\000\089\000\
\\018\000\088\000\021\000\087\000\029\000\086\000\030\000\085\000\
\\050\000\083\000\063\000\082\000\064\000\081\000\065\000\080\000\
\\066\000\079\000\067\000\078\000\068\000\077\000\069\000\076\000\
\\070\000\213\000\072\000\074\000\074\000\073\000\000\000\
\\034\006\008\000\092\000\011\000\091\000\013\000\090\000\017\000\089\000\
\\018\000\088\000\021\000\087\000\029\000\086\000\030\000\085\000\
\\042\000\084\000\044\000\172\001\050\000\083\000\063\000\082\000\
\\064\000\081\000\065\000\080\000\066\000\079\000\067\000\078\000\
\\068\000\077\000\069\000\076\000\070\000\075\000\072\000\074\000\
\\074\000\073\000\085\000\104\000\000\000\
\\034\006\008\000\092\000\011\000\091\000\013\000\090\000\017\000\089\000\
\\018\000\088\000\021\000\087\000\029\000\086\000\030\000\085\000\
\\042\000\084\000\050\000\083\000\063\000\082\000\064\000\081\000\
\\065\000\080\000\066\000\079\000\067\000\078\000\068\000\077\000\
\\069\000\076\000\070\000\075\000\072\000\074\000\074\000\073\000\000\000\
\\035\006\000\000\
\\036\006\000\000\
\\037\006\000\000\
\\038\006\000\000\
\\039\006\000\000\
\\040\006\000\000\
\\041\006\000\000\
\\042\006\000\000\
\\043\006\000\000\
\\044\006\000\000\
\\045\006\000\000\
\\046\006\000\000\
\\047\006\000\000\
\\048\006\000\000\
\\049\006\000\000\
\\050\006\000\000\
\\051\006\000\000\
\\052\006\000\000\
\\053\006\000\000\
\\054\006\000\000\
\\055\006\000\000\
\\056\006\000\000\
\\057\006\075\000\126\001\000\000\
\\058\006\000\000\
\\059\006\000\000\
\\060\006\000\000\
\\061\006\000\000\
\\062\006\000\000\
\\063\006\000\000\
\\064\006\000\000\
\\065\006\000\000\
\\066\006\032\000\148\001\000\000\
\\067\006\000\000\
\\068\006\046\000\219\002\000\000\
\\069\006\000\000\
\\070\006\000\000\
\\071\006\046\000\218\002\000\000\
\\072\006\000\000\
\\073\006\000\000\
\\074\006\046\000\113\002\054\000\041\001\000\000\
\\075\006\000\000\
\\076\006\000\000\
\\077\006\000\000\
\\078\006\000\000\
\\079\006\003\000\246\002\000\000\
\\080\006\000\000\
\\081\006\000\000\
\\082\006\000\000\
\\083\006\003\000\024\002\000\000\
\\083\006\003\000\024\002\046\000\023\002\000\000\
\\084\006\000\000\
\\085\006\000\000\
\\086\006\000\000\
\\087\006\000\000\
\\088\006\000\000\
\\089\006\000\000\
\\090\006\000\000\
\\091\006\003\000\153\001\000\000\
\\091\006\003\000\153\001\046\000\152\001\000\000\
\\091\006\003\000\153\001\046\000\036\002\000\000\
\\091\006\003\000\153\001\046\000\252\002\000\000\
\\092\006\000\000\
\\093\006\000\000\
\\094\006\045\000\093\003\000\000\
\\095\006\000\000\
\\096\006\000\000\
\\097\006\000\000\
\\098\006\003\000\088\003\000\000\
\\099\006\000\000\
\\100\006\000\000\
\\101\006\000\000\
\\102\006\003\000\152\002\000\000\
\\103\006\000\000\
\\104\006\000\000\
\\105\006\000\000\
\\106\006\003\000\105\002\054\000\041\001\000\000\
\\107\006\000\000\
\\108\006\000\000\
\\109\006\000\000\
\\110\006\000\000\
\\111\006\000\000\
\\112\006\000\000\
\\113\006\000\000\
\\114\006\000\000\
\\115\006\000\000\
\\116\006\000\000\
\\117\006\000\000\
\\118\006\000\000\
\\119\006\000\000\
\\120\006\000\000\
\\121\006\000\000\
\\122\006\000\000\
\\123\006\000\000\
\\124\006\003\000\248\001\046\000\247\001\000\000\
\\125\006\000\000\
\\126\006\000\000\
\\127\006\000\000\
\\128\006\000\000\
\\129\006\000\000\
\\130\006\000\000\
\\131\006\000\000\
\\132\006\000\000\
\\133\006\000\000\
\\134\006\000\000\
\\135\006\000\000\
\\136\006\000\000\
\\137\006\000\000\
\\138\006\000\000\
\\139\006\000\000\
\\140\006\000\000\
\\142\006\000\000\
\\143\006\000\000\
\\144\006\000\000\
\\145\006\000\000\
\\146\006\000\000\
\\147\006\000\000\
\\148\006\000\000\
\\149\006\000\000\
\\150\006\000\000\
\\151\006\000\000\
\\152\006\000\000\
\\153\006\000\000\
\\154\006\000\000\
\\155\006\000\000\
\\156\006\002\000\069\000\008\000\067\000\011\000\066\000\013\000\064\000\
\\017\000\062\000\018\000\061\000\020\000\059\000\021\000\058\000\
\\024\000\056\000\029\000\053\000\030\000\052\000\042\000\094\000\
\\050\000\045\000\062\000\042\000\063\000\041\000\064\000\040\000\
\\065\000\039\000\066\000\038\000\067\000\037\000\068\000\036\000\
\\072\000\035\000\074\000\034\000\000\000\
\\157\006\000\000\
\\158\006\000\000\
\\159\006\000\000\
\\160\006\002\000\069\000\006\000\068\000\008\000\067\000\011\000\066\000\
\\012\000\065\000\013\000\064\000\015\000\063\000\017\000\062\000\
\\018\000\061\000\019\000\060\000\020\000\059\000\021\000\058\000\
\\023\000\057\000\024\000\056\000\026\000\055\000\027\000\054\000\
\\029\000\053\000\030\000\052\000\033\000\051\000\034\000\050\000\
\\036\000\049\000\038\000\048\000\042\000\006\001\046\000\047\000\
\\049\000\046\000\050\000\045\000\055\000\044\000\058\000\043\000\
\\062\000\042\000\063\000\041\000\064\000\040\000\065\000\039\000\
\\066\000\038\000\067\000\037\000\068\000\036\000\072\000\035\000\
\\074\000\034\000\077\000\033\000\078\000\032\000\079\000\031\000\
\\080\000\030\000\081\000\029\000\082\000\028\000\083\000\027\000\
\\084\000\026\000\085\000\025\000\086\000\024\000\087\000\023\000\000\000\
\\160\006\002\000\069\000\006\000\068\000\008\000\067\000\011\000\066\000\
\\012\000\065\000\013\000\064\000\015\000\063\000\017\000\062\000\
\\018\000\061\000\019\000\060\000\020\000\059\000\021\000\058\000\
\\023\000\057\000\024\000\056\000\026\000\055\000\027\000\054\000\
\\029\000\053\000\030\000\052\000\033\000\051\000\034\000\050\000\
\\036\000\049\000\038\000\048\000\046\000\047\000\049\000\046\000\
\\050\000\045\000\055\000\044\000\058\000\043\000\062\000\042\000\
\\063\000\041\000\064\000\040\000\065\000\039\000\066\000\038\000\
\\067\000\037\000\068\000\036\000\072\000\035\000\074\000\034\000\
\\077\000\033\000\078\000\032\000\079\000\031\000\080\000\030\000\
\\081\000\029\000\082\000\028\000\083\000\027\000\084\000\026\000\
\\085\000\025\000\086\000\024\000\087\000\023\000\000\000\
\\161\006\000\000\
\\162\006\000\000\
\\163\006\000\000\
\\164\006\042\000\006\000\060\000\005\000\000\000\
\\165\006\042\000\006\000\060\000\005\000\000\000\
\\166\006\000\000\
\\167\006\060\000\005\000\000\000\
\\168\006\000\000\
\"
val actionRowNumbers =
"\236\002\235\002\231\002\101\002\
\\239\002\238\002\234\002\229\002\
\\091\001\086\001\226\002\036\000\
\\067\001\066\001\064\001\232\000\
\\021\001\037\001\027\001\023\001\
\\036\001\015\001\014\001\001\000\
\\002\001\001\001\003\001\000\001\
\\255\000\254\000\253\000\252\000\
\\141\000\247\000\246\000\232\001\
\\232\001\246\000\035\001\034\001\
\\090\000\246\000\050\001\034\001\
\\240\000\022\001\063\001\050\001\
\\044\000\045\000\082\000\232\001\
\\087\000\045\000\246\000\144\000\
\\146\000\085\001\085\001\127\001\
\\127\001\045\000\084\000\087\000\
\\034\001\098\000\045\000\232\001\
\\102\002\099\002\235\000\246\000\
\\247\000\088\000\071\000\246\000\
\\232\001\232\001\246\000\035\001\
\\034\001\034\001\104\002\034\001\
\\232\001\146\000\127\001\127\001\
\\034\001\034\001\098\000\087\001\
\\230\002\230\002\227\001\045\000\
\\087\000\045\000\065\001\145\000\
\\106\001\029\002\019\001\027\002\
\\107\001\046\002\020\001\108\001\
\\099\000\231\001\248\000\098\001\
\\233\001\018\001\251\000\099\001\
\\110\001\146\000\091\000\031\001\
\\146\000\246\000\034\001\034\001\
\\078\001\052\001\049\001\113\000\
\\104\001\146\000\041\001\008\001\
\\007\001\006\001\010\001\009\001\
\\119\000\062\001\236\000\118\000\
\\147\000\039\000\038\000\117\000\
\\143\000\142\000\114\000\035\000\
\\100\000\101\000\042\001\031\000\
\\083\000\041\000\205\001\203\001\
\\093\001\174\001\176\001\185\001\
\\087\000\173\001\202\001\185\001\
\\086\000\083\000\144\000\097\001\
\\042\000\085\000\072\001\109\001\
\\125\001\038\001\119\001\011\001\
\\123\001\013\001\012\001\088\001\
\\083\001\066\000\089\001\067\000\
\\146\000\126\001\005\001\004\001\
\\146\000\034\000\087\000\139\001\
\\148\000\137\001\134\001\095\001\
\\043\000\081\001\076\001\105\001\
\\146\000\248\000\121\001\121\001\
\\153\001\017\001\016\001\033\000\
\\248\000\121\001\103\002\089\000\
\\242\000\121\002\031\002\122\002\
\\046\002\109\002\149\000\249\000\
\\250\000\039\002\124\002\042\002\
\\037\002\034\002\233\000\029\001\
\\003\000\101\002\099\000\032\002\
\\071\000\085\001\123\002\046\002\
\\114\002\248\000\115\002\125\002\
\\146\000\092\000\146\000\119\002\
\\146\000\111\002\146\000\113\002\
\\131\002\146\000\146\000\112\002\
\\120\002\146\000\133\002\133\002\
\\248\000\160\002\227\002\232\002\
\\230\002\228\002\250\000\216\001\
\\004\000\214\001\212\001\068\001\
\\218\001\249\000\226\001\227\001\
\\070\001\071\001\069\001\028\001\
\\024\001\150\000\071\000\071\000\
\\151\000\045\002\152\000\077\002\
\\100\002\030\002\144\001\102\000\
\\236\001\093\000\250\000\094\000\
\\123\000\146\000\146\000\246\000\
\\045\000\045\001\161\001\039\001\
\\241\000\061\001\227\001\045\000\
\\044\001\045\000\045\000\048\001\
\\046\001\043\001\045\000\094\001\
\\070\000\083\000\087\000\045\000\
\\227\001\087\000\204\001\187\001\
\\184\001\115\000\207\001\120\000\
\\201\001\198\001\153\000\037\000\
\\191\001\116\000\040\000\103\000\
\\104\000\178\001\129\001\175\001\
\\045\000\124\001\122\001\090\001\
\\085\001\045\000\118\001\117\001\
\\045\000\096\001\045\000\135\001\
\\087\000\132\001\087\000\045\000\
\\079\001\087\000\162\001\154\001\
\\101\001\232\001\100\001\147\001\
\\032\001\232\001\087\000\155\001\
\\095\000\110\002\249\000\250\000\
\\237\002\154\000\072\000\195\002\
\\246\000\107\002\155\000\105\002\
\\234\000\156\000\025\001\002\000\
\\056\000\038\002\238\001\085\001\
\\084\001\085\001\249\000\046\000\
\\225\000\105\000\068\000\124\000\
\\151\002\096\000\250\000\097\000\
\\163\001\125\000\130\002\129\002\
\\164\001\117\002\232\001\116\002\
\\161\002\154\002\033\001\232\001\
\\233\002\217\001\227\001\227\001\
\\221\001\121\000\225\001\126\000\
\\106\000\107\000\080\000\157\000\
\\025\002\080\000\073\000\078\002\
\\108\000\127\000\128\000\158\000\
\\071\000\140\001\227\001\232\001\
\\234\001\251\000\250\000\116\001\
\\251\000\071\000\160\001\129\000\
\\051\001\130\000\034\001\227\001\
\\122\000\198\001\058\001\241\000\
\\197\001\060\001\055\001\056\001\
\\053\001\074\001\209\001\047\000\
\\048\000\131\001\206\001\208\001\
\\087\000\181\001\177\001\200\001\
\\087\000\180\001\087\000\087\000\
\\183\001\182\001\179\001\077\001\
\\049\000\050\000\032\000\138\001\
\\136\001\133\001\082\001\080\001\
\\172\001\034\001\149\001\034\001\
\\120\001\152\001\146\000\250\000\
\\151\001\075\001\145\001\034\001\
\\085\001\108\002\106\002\246\000\
\\174\002\020\000\026\002\099\000\
\\192\002\074\000\247\000\142\002\
\\141\002\249\000\250\000\250\000\
\\041\002\159\000\246\000\249\000\
\\246\000\034\001\034\001\232\001\
\\034\001\034\001\051\000\109\000\
\\244\001\242\001\110\000\070\000\
\\099\000\069\000\030\001\033\002\
\\071\000\036\002\071\000\075\000\
\\147\002\227\001\232\001\250\000\
\\128\002\251\000\131\000\034\001\
\\034\001\227\001\173\002\034\001\
\\132\002\156\002\034\001\159\002\
\\146\000\250\000\158\002\248\000\
\\215\001\213\001\219\001\227\001\
\\228\001\227\001\220\001\002\002\
\\132\000\005\000\070\000\099\000\
\\080\000\004\002\044\002\010\000\
\\237\000\099\000\001\002\071\000\
\\071\000\081\000\160\000\143\001\
\\142\001\235\001\161\000\133\000\
\\162\000\134\000\227\001\232\001\
\\144\000\159\001\040\001\059\001\
\\057\001\045\000\210\001\211\001\
\\128\001\083\000\186\001\196\001\
\\087\000\195\001\189\001\190\001\
\\188\001\092\001\047\001\045\000\
\\169\001\034\001\144\000\152\001\
\\148\001\160\001\102\001\152\001\
\\052\000\177\002\178\002\246\000\
\\057\000\226\000\193\002\019\000\
\\238\000\099\000\194\002\246\000\
\\139\002\138\002\026\001\136\002\
\\135\002\246\000\028\002\046\002\
\\028\002\144\000\144\000\250\000\
\\144\000\144\000\237\001\071\000\
\\071\000\239\001\243\001\240\001\
\\135\000\222\000\079\000\040\002\
\\053\000\210\002\021\000\239\000\
\\099\000\150\002\149\002\163\000\
\\136\000\232\001\144\000\144\000\
\\146\002\170\002\034\001\144\000\
\\159\002\155\002\160\001\118\002\
\\162\002\224\001\229\001\230\001\
\\076\000\076\000\006\002\141\000\
\\137\000\223\000\003\002\048\002\
\\247\000\058\000\227\000\111\000\
\\112\000\075\002\138\000\014\000\
\\070\000\099\000\081\000\141\001\
\\144\000\227\001\243\000\232\001\
\\164\000\250\000\168\001\054\001\
\\130\001\193\001\140\000\199\001\
\\192\001\073\001\171\001\172\001\
\\150\001\158\001\146\001\103\001\
\\175\002\176\002\180\002\246\000\
\\249\000\246\000\034\001\034\001\
\\232\001\034\001\034\001\072\000\
\\196\002\060\000\228\000\140\002\
\\249\000\250\000\043\002\165\000\
\\166\000\167\000\168\000\169\000\
\\170\000\171\000\172\000\248\001\
\\245\001\071\000\079\000\054\000\
\\035\002\212\002\246\000\062\000\
\\229\000\148\002\144\000\227\001\
\\250\000\169\002\146\002\143\002\
\\034\001\172\002\173\002\157\002\
\\165\002\152\002\034\001\222\001\
\\240\000\006\000\249\001\008\002\
\\099\000\246\001\007\002\005\002\
\\076\000\080\000\047\002\050\002\
\\246\000\249\000\246\000\034\001\
\\034\001\232\001\034\001\034\001\
\\073\000\255\001\000\002\077\000\
\\077\000\080\002\246\000\139\000\
\\224\000\076\002\115\001\114\001\
\\113\001\250\000\244\000\168\001\
\\166\001\034\001\194\001\170\001\
\\156\001\034\001\028\002\046\002\
\\028\002\144\000\144\000\250\000\
\\144\000\144\000\179\002\040\002\
\\198\002\246\000\249\000\246\000\
\\034\001\034\001\232\001\034\001\
\\034\001\074\000\137\002\134\002\
\\246\000\078\000\246\000\034\001\
\\034\001\227\001\034\001\034\001\
\\252\001\251\001\241\001\211\002\
\\214\002\246\000\249\000\246\000\
\\034\001\034\001\232\001\034\001\
\\034\001\075\000\127\002\126\002\
\\169\002\167\002\034\001\144\002\
\\145\002\171\002\163\002\034\001\
\\159\002\223\001\011\002\064\000\
\\230\000\253\001\010\002\009\002\
\\132\000\028\002\046\002\028\002\
\\144\000\144\000\250\000\144\000\
\\144\000\049\002\040\002\082\002\
\\015\000\250\001\099\000\081\002\
\\247\001\079\002\077\000\081\000\
\\173\000\111\001\165\001\167\001\
\\157\001\174\000\175\000\176\000\
\\177\000\178\000\179\000\180\000\
\\181\000\028\002\046\002\028\002\
\\144\000\144\000\250\000\144\000\
\\144\000\197\002\040\002\073\002\
\\069\002\072\002\073\002\144\000\
\\144\000\071\002\144\000\144\000\
\\028\002\046\002\028\002\144\000\
\\144\000\250\000\144\000\144\000\
\\213\002\040\002\166\002\168\002\
\\164\002\153\002\013\002\246\000\
\\249\000\246\000\034\001\034\001\
\\232\001\034\001\034\001\076\000\
\\182\000\183\000\184\000\185\000\
\\186\000\187\000\188\000\189\000\
\\085\002\065\000\231\000\084\002\
\\254\001\083\002\138\000\245\000\
\\246\000\078\000\246\000\034\001\
\\034\001\227\001\034\001\034\001\
\\190\000\191\000\192\000\193\000\
\\194\000\195\000\196\000\197\000\
\\067\002\055\000\074\002\068\002\
\\071\002\071\002\066\002\071\002\
\\071\002\198\000\199\000\200\000\
\\201\000\202\000\203\000\204\000\
\\205\000\028\002\046\002\028\002\
\\144\000\144\000\250\000\144\000\
\\144\000\040\002\012\002\246\000\
\\078\000\246\000\034\001\034\001\
\\227\001\034\001\034\001\087\002\
\\246\000\249\000\246\000\034\001\
\\034\001\232\001\034\001\034\001\
\\077\000\112\001\023\000\188\002\
\\022\000\023\000\144\000\144\000\
\\024\000\144\000\144\000\246\000\
\\078\000\246\000\034\001\034\001\
\\227\001\034\001\034\001\070\002\
\\064\002\062\002\063\002\065\002\
\\246\000\078\000\246\000\034\001\
\\034\001\227\001\034\001\034\001\
\\206\000\207\000\208\000\209\000\
\\210\000\211\000\212\000\213\000\
\\012\000\058\002\011\000\012\000\
\\144\000\144\000\013\000\144\000\
\\144\000\028\002\046\002\028\002\
\\144\000\144\000\250\000\144\000\
\\144\000\086\002\040\002\186\002\
\\189\002\057\000\191\002\187\002\
\\024\000\024\000\185\002\024\000\
\\024\000\026\000\206\002\025\000\
\\026\000\144\000\144\000\027\000\
\\144\000\144\000\029\000\222\002\
\\028\000\029\000\144\000\144\000\
\\030\000\144\000\144\000\246\000\
\\078\000\246\000\034\001\034\001\
\\227\001\034\001\034\001\056\002\
\\059\002\059\000\061\002\057\002\
\\013\000\013\000\055\002\013\000\
\\013\000\214\000\215\000\216\000\
\\217\000\218\000\219\000\220\000\
\\221\000\190\002\183\002\181\002\
\\182\002\184\002\204\002\207\002\
\\061\000\209\002\205\002\027\000\
\\027\000\203\002\027\000\027\000\
\\220\002\223\002\062\000\225\002\
\\221\002\030\000\030\000\219\002\
\\030\000\030\000\008\000\007\000\
\\021\002\008\000\144\000\144\000\
\\009\000\144\000\144\000\060\002\
\\053\002\051\002\052\002\054\002\
\\246\000\078\000\246\000\034\001\
\\034\001\227\001\034\001\034\001\
\\208\002\201\002\199\002\200\002\
\\202\002\224\002\217\002\215\002\
\\216\002\218\002\019\002\022\002\
\\063\000\024\002\020\002\009\000\
\\009\000\018\002\009\000\009\000\
\\017\000\095\002\016\000\017\000\
\\144\000\144\000\018\000\144\000\
\\144\000\023\002\016\002\014\002\
\\015\002\017\002\093\002\096\002\
\\065\000\098\002\094\002\018\000\
\\018\000\092\002\018\000\018\000\
\\097\002\090\002\088\002\089\002\
\\091\002\000\000"
val gotoT =
"\
\\165\000\205\004\166\000\002\000\167\000\001\000\000\000\
\\167\000\005\000\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\025\000\013\000\
\\026\000\012\000\027\000\011\000\032\000\010\000\034\000\009\000\
\\035\000\008\000\162\000\007\000\163\000\006\000\000\000\
\\120\000\070\000\121\000\069\000\122\000\068\000\000\000\
\\000\000\
\\167\000\005\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\032\000\091\000\034\000\009\000\035\000\008\000\000\000\
\\000\000\
\\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\098\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\101\000\090\000\100\000\000\000\
\\009\000\105\000\102\000\104\000\000\000\
\\008\000\108\000\112\000\107\000\000\000\
\\007\000\112\000\048\000\111\000\083\000\110\000\084\000\109\000\000\000\
\\007\000\112\000\048\000\115\000\083\000\110\000\084\000\109\000\000\000\
\\008\000\116\000\000\000\
\\001\000\118\000\015\000\117\000\000\000\
\\015\000\120\000\000\000\
\\000\000\
\\008\000\018\000\013\000\124\000\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\017\000\127\000\
\\018\000\126\000\025\000\013\000\026\000\012\000\027\000\125\000\000\000\
\\015\000\129\000\057\000\128\000\000\000\
\\003\000\130\000\000\000\
\\000\000\
\\001\000\020\000\003\000\140\000\005\000\139\000\008\000\018\000\
\\010\000\017\000\011\000\016\000\013\000\015\000\016\000\138\000\
\\022\000\137\000\023\000\136\000\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\017\000\146\000\
\\018\000\126\000\025\000\013\000\026\000\012\000\027\000\125\000\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\019\000\149\000\
\\021\000\148\000\025\000\013\000\026\000\012\000\027\000\147\000\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\025\000\013\000\
\\026\000\012\000\027\000\151\000\000\000\
\\001\000\158\000\005\000\019\000\007\000\112\000\008\000\018\000\
\\011\000\157\000\013\000\015\000\040\000\156\000\061\000\155\000\
\\071\000\154\000\072\000\153\000\084\000\152\000\000\000\
\\007\000\112\000\048\000\167\000\083\000\110\000\084\000\109\000\000\000\
\\001\000\158\000\005\000\019\000\008\000\018\000\011\000\157\000\
\\013\000\015\000\061\000\155\000\071\000\154\000\072\000\168\000\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\025\000\013\000\
\\026\000\012\000\027\000\170\000\000\000\
\\008\000\018\000\013\000\172\000\038\000\171\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\173\000\011\000\016\000\
\\013\000\015\000\000\000\
\\004\000\176\000\005\000\175\000\037\000\174\000\000\000\
\\031\000\181\000\033\000\180\000\034\000\179\000\035\000\008\000\000\000\
\\031\000\183\000\033\000\180\000\034\000\179\000\035\000\008\000\000\000\
\\002\000\185\000\039\000\184\000\000\000\
\\002\000\185\000\039\000\188\000\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\025\000\013\000\
\\026\000\012\000\027\000\189\000\000\000\
\\001\000\158\000\005\000\019\000\007\000\112\000\008\000\018\000\
\\011\000\157\000\013\000\015\000\042\000\195\000\044\000\194\000\
\\046\000\193\000\047\000\192\000\061\000\155\000\071\000\154\000\
\\072\000\191\000\084\000\190\000\000\000\
\\001\000\158\000\005\000\019\000\008\000\018\000\011\000\157\000\
\\013\000\015\000\028\000\198\000\030\000\197\000\061\000\155\000\
\\071\000\154\000\072\000\196\000\000\000\
\\015\000\200\000\059\000\199\000\000\000\
\\006\000\204\000\007\000\112\000\051\000\203\000\052\000\202\000\
\\084\000\201\000\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\025\000\013\000\
\\026\000\012\000\027\000\207\000\000\000\
\\007\000\112\000\050\000\209\000\083\000\208\000\084\000\109\000\000\000\
\\000\000\
\\122\000\210\000\000\000\
\\000\000\
\\008\000\214\000\144\000\213\000\000\000\
\\009\000\216\000\150\000\215\000\000\000\
\\008\000\018\000\013\000\218\000\129\000\217\000\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\223\000\100\000\222\000\101\000\221\000\000\000\
\\008\000\235\000\156\000\234\000\000\000\
\\007\000\112\000\083\000\237\000\084\000\109\000\132\000\236\000\000\000\
\\007\000\112\000\083\000\237\000\084\000\109\000\132\000\238\000\000\000\
\\008\000\239\000\000\000\
\\001\000\241\000\015\000\240\000\000\000\
\\015\000\242\000\000\000\
\\015\000\244\000\140\000\243\000\000\000\
\\000\000\
\\015\000\246\000\130\000\245\000\000\000\
\\007\000\112\000\083\000\237\000\084\000\109\000\132\000\247\000\000\000\
\\004\000\176\000\005\000\175\000\037\000\248\000\000\000\
\\002\000\185\000\039\000\249\000\000\000\
\\002\000\185\000\039\000\250\000\000\000\
\\015\000\246\000\130\000\251\000\000\000\
\\015\000\253\000\142\000\252\000\000\000\
\\006\000\001\001\007\000\112\000\084\000\000\001\135\000\255\000\
\\136\000\254\000\000\000\
\\032\000\091\000\034\000\009\000\035\000\008\000\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\025\000\013\000\
\\026\000\012\000\027\000\011\000\032\000\010\000\034\000\009\000\
\\035\000\008\000\162\000\007\000\163\000\003\001\164\000\002\001\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\025\000\013\000\
\\026\000\012\000\027\000\011\000\032\000\010\000\034\000\009\000\
\\035\000\008\000\162\000\007\000\163\000\003\001\164\000\005\001\000\000\
\\007\000\012\001\073\000\011\001\074\000\010\001\075\000\009\001\
\\076\000\008\001\077\000\007\001\081\000\006\001\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\025\000\013\000\
\\026\000\012\000\027\000\016\001\000\000\
\\001\000\158\000\005\000\019\000\008\000\018\000\011\000\157\000\
\\013\000\015\000\028\000\017\001\030\000\197\000\061\000\155\000\
\\071\000\154\000\072\000\196\000\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\025\000\013\000\
\\026\000\012\000\027\000\018\001\000\000\
\\000\000\
\\004\000\020\001\005\000\175\000\008\000\019\001\000\000\
\\000\000\
\\097\000\021\001\000\000\
\\000\000\
\\097\000\024\001\000\000\
\\000\000\
\\089\000\027\001\103\000\026\001\113\000\025\001\000\000\
\\000\000\
\\000\000\
\\089\000\027\001\113\000\029\001\000\000\
\\000\000\
\\006\000\030\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\007\000\032\001\085\000\031\001\000\000\
\\000\000\
\\000\000\
\\004\000\033\001\005\000\175\000\000\000\
\\000\000\
\\000\000\
\\004\000\035\001\005\000\175\000\000\000\
\\008\000\036\001\000\000\
\\015\000\037\001\000\000\
\\015\000\038\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\004\000\042\001\005\000\175\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\069\000\045\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\158\000\005\000\019\000\008\000\018\000\011\000\157\000\
\\013\000\015\000\040\000\055\001\061\000\155\000\071\000\154\000\
\\072\000\153\000\000\000\
\\000\000\
\\001\000\158\000\005\000\019\000\008\000\018\000\011\000\157\000\
\\013\000\015\000\061\000\062\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\158\000\005\000\019\000\008\000\018\000\011\000\157\000\
\\013\000\015\000\061\000\155\000\062\000\065\001\063\000\064\001\
\\071\000\154\000\072\000\063\001\000\000\
\\001\000\158\000\005\000\019\000\008\000\018\000\011\000\157\000\
\\013\000\015\000\061\000\155\000\071\000\154\000\072\000\066\001\000\000\
\\000\000\
\\003\000\070\001\005\000\069\001\066\000\068\001\067\000\067\001\000\000\
\\001\000\158\000\005\000\019\000\008\000\018\000\011\000\157\000\
\\013\000\015\000\061\000\155\000\062\000\073\001\063\000\064\001\
\\071\000\154\000\072\000\063\001\000\000\
\\001\000\158\000\005\000\019\000\007\000\032\001\008\000\018\000\
\\011\000\157\000\013\000\015\000\061\000\155\000\064\000\076\001\
\\065\000\075\001\071\000\154\000\072\000\074\001\085\000\031\001\000\000\
\\001\000\158\000\005\000\019\000\008\000\018\000\011\000\157\000\
\\013\000\015\000\040\000\078\001\061\000\155\000\071\000\154\000\
\\072\000\153\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\079\001\011\000\016\000\
\\013\000\015\000\000\000\
\\000\000\
\\000\000\
\\001\000\158\000\005\000\019\000\008\000\018\000\011\000\157\000\
\\013\000\015\000\061\000\155\000\064\000\076\001\065\000\075\001\
\\071\000\154\000\072\000\074\001\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\013\000\172\000\038\000\081\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\004\000\176\000\005\000\175\000\037\000\082\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\033\000\083\001\034\000\179\000\035\000\008\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\004\000\176\000\005\000\175\000\037\000\086\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\004\000\176\000\005\000\175\000\037\000\087\001\000\000\
\\000\000\
\\001\000\158\000\005\000\019\000\008\000\018\000\011\000\157\000\
\\013\000\015\000\042\000\089\001\044\000\194\000\046\000\193\000\
\\047\000\192\000\061\000\155\000\071\000\154\000\072\000\191\000\000\000\
\\000\000\
\\000\000\
\\045\000\091\001\000\000\
\\043\000\093\001\000\000\
\\000\000\
\\000\000\
\\029\000\096\001\000\000\
\\000\000\
\\000\000\
\\004\000\098\001\005\000\175\000\000\000\
\\006\000\099\001\000\000\
\\036\000\100\001\000\000\
\\036\000\102\001\000\000\
\\053\000\103\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\006\000\107\001\000\000\
\\036\000\108\001\000\000\
\\000\000\
\\008\000\018\000\013\000\218\000\129\000\109\001\000\000\
\\000\000\
\\000\000\
\\097\000\113\001\000\000\
\\000\000\
\\089\000\027\001\103\000\115\001\113\000\025\001\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\118\001\
\\127\000\117\001\000\000\
\\006\000\122\001\008\000\018\000\012\000\121\001\013\000\120\001\
\\125\000\119\001\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\013\000\126\001\086\000\125\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\120\000\131\001\121\000\069\000\122\000\068\000\000\000\
\\089\000\132\001\000\000\
\\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\223\000\100\000\133\001\101\000\221\000\000\000\
\\031\000\134\001\033\000\180\000\034\000\179\000\035\000\008\000\000\000\
\\000\000\
\\089\000\027\001\103\000\135\001\113\000\025\001\000\000\
\\000\000\
\\006\000\136\001\000\000\
\\000\000\
\\000\000\
\\004\000\137\001\005\000\175\000\000\000\
\\000\000\
\\004\000\139\001\005\000\175\000\000\000\
\\000\000\
\\004\000\140\001\005\000\175\000\000\000\
\\000\000\
\\004\000\141\001\005\000\175\000\000\000\
\\000\000\
\\000\000\
\\004\000\176\000\005\000\175\000\037\000\142\001\000\000\
\\004\000\176\000\005\000\175\000\037\000\143\001\000\000\
\\000\000\
\\000\000\
\\004\000\144\001\005\000\175\000\000\000\
\\123\000\145\001\000\000\
\\123\000\147\001\000\000\
\\006\000\148\001\000\000\
\\137\000\149\001\000\000\
\\000\000\
\\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\025\000\013\000\
\\026\000\012\000\027\000\011\000\032\000\010\000\034\000\009\000\
\\035\000\008\000\162\000\007\000\163\000\003\001\164\000\152\001\000\000\
\\000\000\
\\006\000\122\001\008\000\018\000\012\000\153\001\013\000\120\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\156\001\000\000\
\\003\000\159\001\078\000\158\001\079\000\157\001\000\000\
\\007\000\012\001\073\000\161\001\074\000\010\001\075\000\009\001\
\\076\000\008\001\077\000\007\001\081\000\006\001\082\000\160\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\223\000\100\000\163\001\101\000\221\000\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\223\000\100\000\164\001\101\000\221\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\089\000\027\001\113\000\167\001\000\000\
\\008\000\169\001\120\000\168\001\121\000\069\000\122\000\068\000\000\000\
\\097\000\171\001\000\000\
\\049\000\173\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\006\000\122\001\008\000\018\000\012\000\179\001\013\000\120\001\000\000\
\\000\000\
\\000\000\
\\004\000\182\001\005\000\175\000\000\000\
\\004\000\183\001\005\000\175\000\000\000\
\\008\000\019\001\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\018\000\184\001\
\\025\000\013\000\026\000\012\000\027\000\125\000\000\000\
\\000\000\
\\056\000\185\001\000\000\
\\000\000\
\\003\000\140\000\005\000\189\001\022\000\188\001\000\000\
\\024\000\190\001\000\000\
\\007\000\012\001\073\000\192\001\074\000\010\001\075\000\009\001\
\\076\000\008\001\077\000\007\001\081\000\006\001\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\025\000\013\000\
\\026\000\012\000\027\000\193\001\000\000\
\\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\020\000\195\001\
\\025\000\013\000\026\000\012\000\027\000\194\001\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\018\000\196\001\
\\025\000\013\000\026\000\012\000\027\000\125\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\025\000\013\000\
\\026\000\012\000\027\000\197\001\000\000\
\\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\198\001\000\000\
\\001\000\158\000\005\000\019\000\008\000\018\000\011\000\157\000\
\\013\000\015\000\040\000\199\001\061\000\155\000\071\000\154\000\
\\072\000\153\000\000\000\
\\001\000\158\000\005\000\019\000\008\000\018\000\011\000\157\000\
\\013\000\015\000\042\000\200\001\044\000\194\000\046\000\193\000\
\\047\000\192\000\061\000\155\000\071\000\154\000\072\000\191\000\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\025\000\013\000\
\\026\000\012\000\027\000\201\001\000\000\
\\007\000\012\001\073\000\202\001\074\000\010\001\075\000\009\001\
\\076\000\008\001\077\000\007\001\081\000\006\001\000\000\
\\001\000\158\000\005\000\019\000\008\000\018\000\011\000\157\000\
\\013\000\015\000\061\000\155\000\071\000\154\000\072\000\203\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\069\000\207\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\025\000\013\000\
\\026\000\012\000\027\000\215\001\000\000\
\\000\000\
\\000\000\
\\033\000\083\001\034\000\179\000\035\000\008\000\000\000\
\\031\000\216\001\033\000\180\000\034\000\179\000\035\000\008\000\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\020\000\217\001\
\\025\000\013\000\026\000\012\000\027\000\194\001\000\000\
\\000\000\
\\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\025\000\013\000\
\\026\000\012\000\027\000\218\001\000\000\
\\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\025\000\013\000\
\\026\000\012\000\027\000\219\001\000\000\
\\000\000\
\\001\000\158\000\005\000\019\000\008\000\018\000\011\000\157\000\
\\013\000\015\000\044\000\220\001\046\000\193\000\047\000\192\000\
\\061\000\155\000\071\000\154\000\072\000\191\000\000\000\
\\000\000\
\\001\000\158\000\005\000\019\000\008\000\018\000\011\000\157\000\
\\013\000\015\000\042\000\221\001\044\000\194\000\046\000\193\000\
\\047\000\192\000\061\000\155\000\071\000\154\000\072\000\191\000\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\025\000\013\000\
\\026\000\012\000\027\000\222\001\000\000\
\\000\000\
\\001\000\158\000\005\000\019\000\008\000\018\000\011\000\157\000\
\\013\000\015\000\028\000\223\001\030\000\197\000\061\000\155\000\
\\071\000\154\000\072\000\196\000\000\000\
\\056\000\224\001\000\000\
\\053\000\226\001\000\000\
\\000\000\
\\007\000\112\000\048\000\228\001\083\000\110\000\084\000\109\000\000\000\
\\000\000\
\\000\000\
\\015\000\230\001\054\000\229\001\000\000\
\\007\000\112\000\050\000\232\001\083\000\208\000\084\000\109\000\000\000\
\\001\000\158\000\005\000\019\000\008\000\018\000\011\000\157\000\
\\013\000\015\000\028\000\233\001\030\000\197\000\061\000\155\000\
\\071\000\154\000\072\000\196\000\000\000\
\\053\000\234\001\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\118\001\
\\127\000\237\001\000\000\
\\006\000\122\001\008\000\018\000\012\000\121\001\013\000\120\001\
\\125\000\238\001\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\223\000\100\000\242\001\101\000\241\001\
\\146\000\240\001\000\000\
\\151\000\244\001\000\000\
\\008\000\018\000\013\000\248\001\128\000\247\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\013\000\253\001\109\000\252\001\000\000\
\\000\000\
\\000\000\
\\031\000\006\002\033\000\180\000\034\000\179\000\035\000\008\000\000\000\
\\008\000\018\000\013\000\126\001\031\000\010\002\033\000\180\000\
\\034\000\179\000\035\000\008\000\086\000\009\002\087\000\008\002\
\\088\000\007\002\000\000\
\\031\000\013\002\033\000\180\000\034\000\179\000\035\000\008\000\000\000\
\\008\000\019\001\009\000\014\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\133\000\020\002\000\000\
\\000\000\
\\006\000\122\001\008\000\018\000\012\000\024\002\013\000\120\001\000\000\
\\000\000\
\\056\000\026\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\056\000\030\002\000\000\
\\000\000\
\\007\000\112\000\083\000\237\000\084\000\109\000\132\000\032\002\000\000\
\\000\000\
\\137\000\033\002\000\000\
\\000\000\
\\015\000\036\002\138\000\035\002\000\000\
\\007\000\112\000\083\000\039\002\084\000\109\000\134\000\038\002\000\000\
\\000\000\
\\000\000\
\\007\000\012\001\075\000\040\002\076\000\008\001\077\000\007\001\
\\081\000\006\001\000\000\
\\007\000\012\001\073\000\041\002\074\000\010\001\075\000\009\001\
\\076\000\008\001\077\000\007\001\081\000\006\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\013\000\126\001\086\000\009\002\087\000\049\002\
\\088\000\048\002\092\000\047\002\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\013\000\126\001\086\000\009\002\087\000\049\002\
\\088\000\048\002\092\000\053\002\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\223\000\100\000\056\002\101\000\055\002\
\\105\000\054\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\223\000\100\000\062\002\101\000\221\000\000\000\
\\000\000\
\\007\000\012\001\073\000\063\002\074\000\010\001\075\000\009\001\
\\076\000\008\001\077\000\007\001\081\000\006\001\000\000\
\\007\000\112\000\048\000\064\002\083\000\110\000\084\000\109\000\000\000\
\\000\000\
\\007\000\032\001\085\000\065\002\000\000\
\\006\000\122\001\008\000\018\000\012\000\066\002\013\000\120\001\000\000\
\\000\000\
\\007\000\067\002\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\223\000\100\000\068\002\101\000\221\000\000\000\
\\056\000\069\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\015\000\072\002\000\000\
\\007\000\012\001\073\000\073\002\074\000\010\001\075\000\009\001\
\\076\000\008\001\077\000\007\001\081\000\006\001\000\000\
\\000\000\
\\069\000\045\001\000\000\
\\000\000\
\\003\000\140\000\005\000\189\001\022\000\075\002\000\000\
\\000\000\
\\024\000\076\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\041\000\080\002\000\000\
\\000\000\
\\000\000\
\\001\000\158\000\005\000\019\000\008\000\018\000\011\000\157\000\
\\013\000\015\000\061\000\155\000\063\000\082\002\071\000\154\000\
\\072\000\063\001\000\000\
\\000\000\
\\000\000\
\\070\000\083\002\000\000\
\\001\000\158\000\005\000\019\000\008\000\018\000\011\000\157\000\
\\013\000\015\000\061\000\155\000\071\000\154\000\072\000\085\002\000\000\
\\000\000\
\\001\000\158\000\005\000\019\000\008\000\018\000\011\000\157\000\
\\013\000\015\000\061\000\155\000\065\000\087\002\071\000\154\000\
\\072\000\086\002\000\000\
\\001\000\158\000\005\000\019\000\008\000\018\000\011\000\157\000\
\\013\000\015\000\061\000\155\000\063\000\088\002\071\000\154\000\
\\072\000\063\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\060\000\092\002\000\000\
\\015\000\094\002\000\000\
\\000\000\
\\015\000\230\001\054\000\095\002\000\000\
\\000\000\
\\053\000\096\002\000\000\
\\004\000\097\002\005\000\175\000\000\000\
\\006\000\122\001\008\000\018\000\012\000\098\002\013\000\120\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\015\000\230\001\054\000\099\002\000\000\
\\031\000\100\002\033\000\180\000\034\000\179\000\035\000\008\000\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\013\000\101\002\000\000\
\\000\000\
\\145\000\102\002\000\000\
\\000\000\
\\089\000\105\002\000\000\
\\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\223\000\100\000\108\002\101\000\107\002\
\\152\000\106\002\000\000\
\\009\000\216\000\150\000\110\002\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\113\002\
\\126\000\112\002\000\000\
\\006\000\114\002\008\000\019\001\000\000\
\\006\000\122\001\008\000\018\000\012\000\116\002\013\000\120\001\
\\124\000\115\002\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\013\000\118\002\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\119\002\000\000\
\\008\000\018\000\013\000\120\002\000\000\
\\015\000\121\002\000\000\
\\015\000\122\002\000\000\
\\007\000\112\000\083\000\123\002\084\000\109\000\000\000\
\\015\000\124\002\000\000\
\\015\000\125\002\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\013\000\126\001\086\000\130\002\000\000\
\\000\000\
\\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\025\000\013\000\
\\026\000\132\002\000\000\
\\089\000\133\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\223\000\100\000\135\002\101\000\221\000\000\000\
\\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\223\000\100\000\136\002\101\000\221\000\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\223\000\100\000\139\002\101\000\138\002\
\\158\000\137\002\000\000\
\\000\000\
\\007\000\012\001\073\000\141\002\074\000\010\001\075\000\009\001\
\\076\000\008\001\077\000\007\001\081\000\006\001\000\000\
\\007\000\112\000\083\000\237\000\084\000\109\000\132\000\142\002\000\000\
\\006\000\122\001\008\000\018\000\012\000\143\002\013\000\120\001\000\000\
\\000\000\
\\007\000\144\002\000\000\
\\000\000\
\\015\000\146\002\000\000\
\\015\000\147\002\000\000\
\\007\000\012\001\073\000\148\002\074\000\010\001\075\000\009\001\
\\076\000\008\001\077\000\007\001\081\000\006\001\000\000\
\\143\000\149\002\000\000\
\\015\000\151\002\000\000\
\\000\000\
\\000\000\
\\015\000\036\002\138\000\152\002\000\000\
\\137\000\153\002\000\000\
\\004\000\154\002\005\000\175\000\000\000\
\\006\000\122\001\008\000\018\000\012\000\155\002\013\000\120\001\000\000\
\\000\000\
\\006\000\156\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\007\000\012\001\073\000\157\002\074\000\010\001\075\000\009\001\
\\076\000\008\001\077\000\007\001\081\000\006\001\000\000\
\\000\000\
\\007\000\012\001\073\000\159\002\074\000\010\001\075\000\009\001\
\\076\000\008\001\077\000\007\001\081\000\006\001\082\000\158\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\013\000\126\001\086\000\130\002\091\000\162\002\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\025\000\013\000\
\\026\000\164\002\000\000\
\\089\000\165\002\000\000\
\\008\000\018\000\013\000\126\001\086\000\009\002\087\000\049\002\
\\088\000\048\002\092\000\166\002\000\000\
\\000\000\
\\000\000\
\\104\000\167\002\000\000\
\\000\000\
\\089\000\170\002\000\000\
\\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\223\000\100\000\171\002\101\000\221\000\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\223\000\100\000\172\002\101\000\221\000\000\000\
\\008\000\018\000\013\000\126\001\086\000\009\002\087\000\175\002\
\\088\000\174\002\115\000\173\002\000\000\
\\000\000\
\\049\000\179\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\007\000\012\001\073\000\184\002\074\000\010\001\075\000\009\001\
\\076\000\008\001\077\000\007\001\081\000\006\001\000\000\
\\007\000\112\000\083\000\185\002\084\000\109\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\186\002\011\000\016\000\
\\013\000\015\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\020\000\187\002\
\\025\000\013\000\026\000\012\000\027\000\194\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\158\000\005\000\019\000\008\000\018\000\011\000\157\000\
\\013\000\015\000\040\000\188\002\061\000\155\000\071\000\154\000\
\\072\000\153\000\000\000\
\\000\000\
\\068\000\189\002\000\000\
\\001\000\158\000\005\000\019\000\008\000\018\000\011\000\157\000\
\\013\000\015\000\061\000\155\000\071\000\154\000\072\000\191\002\000\000\
\\068\000\192\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\025\000\013\000\
\\026\000\012\000\027\000\193\002\000\000\
\\000\000\
\\015\000\200\000\059\000\194\002\000\000\
\\005\000\019\000\008\000\018\000\010\000\195\002\011\000\016\000\
\\013\000\015\000\000\000\
\\053\000\196\002\000\000\
\\000\000\
\\056\000\197\002\000\000\
\\000\000\
\\053\000\198\002\000\000\
\\000\000\
\\145\000\200\002\000\000\
\\000\000\
\\008\000\214\000\144\000\201\002\000\000\
\\008\000\018\000\013\000\253\001\109\000\252\001\147\000\202\002\000\000\
\\000\000\
\\000\000\
\\151\000\212\002\000\000\
\\000\000\
\\089\000\214\002\000\000\
\\000\000\
\\008\000\018\000\013\000\248\001\128\000\215\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\013\000\218\002\000\000\
\\097\000\219\002\000\000\
\\089\000\027\001\103\000\220\002\113\000\025\001\000\000\
\\097\000\221\002\000\000\
\\005\000\019\000\008\000\018\000\010\000\222\002\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\223\002\011\000\016\000\
\\013\000\015\000\000\000\
\\006\000\122\001\008\000\018\000\012\000\224\002\013\000\120\001\000\000\
\\005\000\019\000\008\000\018\000\010\000\225\002\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\226\002\011\000\016\000\
\\013\000\015\000\000\000\
\\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\223\000\100\000\227\002\101\000\221\000\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\223\000\100\000\228\002\101\000\221\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\013\000\126\001\086\000\009\002\087\000\008\002\
\\088\000\231\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\157\000\233\002\000\000\
\\000\000\
\\089\000\236\002\000\000\
\\133\000\237\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\007\000\112\000\083\000\240\002\084\000\109\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\241\002\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\242\002\011\000\016\000\
\\013\000\015\000\000\000\
\\131\000\243\002\000\000\
\\000\000\
\\015\000\253\000\142\000\245\002\000\000\
\\005\000\019\000\008\000\018\000\010\000\246\002\011\000\016\000\
\\013\000\015\000\000\000\
\\137\000\247\002\000\000\
\\000\000\
\\056\000\248\002\000\000\
\\000\000\
\\137\000\249\002\000\000\
\\080\000\251\002\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\093\000\255\002\098\000\224\000\099\000\223\000\100\000\254\002\
\\101\000\253\002\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\093\000\002\003\098\000\224\000\099\000\223\000\100\000\001\003\
\\101\000\253\002\000\000\
\\000\000\
\\008\000\101\000\090\000\003\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\009\000\105\000\102\000\006\003\000\000\
\\008\000\018\000\013\000\253\001\106\000\007\003\109\000\252\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\013\000\126\001\086\000\130\002\114\000\021\003\000\000\
\\001\000\020\000\005\000\019\000\008\000\018\000\010\000\017\000\
\\011\000\016\000\013\000\015\000\016\000\014\000\025\000\013\000\
\\026\000\023\003\000\000\
\\089\000\024\003\000\000\
\\008\000\018\000\013\000\126\001\086\000\009\002\087\000\175\002\
\\088\000\174\002\115\000\025\003\000\000\
\\000\000\
\\005\000\019\000\008\000\018\000\010\000\026\003\011\000\016\000\
\\013\000\015\000\000\000\
\\007\000\012\001\073\000\027\003\074\000\010\001\075\000\009\001\
\\076\000\008\001\077\000\007\001\081\000\006\001\000\000\
\\000\000\
\\007\000\112\000\083\000\029\003\084\000\109\000\000\000\
\\000\000\
\\006\000\122\001\008\000\018\000\012\000\031\003\013\000\120\001\000\000\
\\058\000\032\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\003\000\070\001\005\000\069\001\066\000\034\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\060\000\035\003\000\000\
\\000\000\
\\055\000\036\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\013\000\038\003\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\039\003\000\000\
\\008\000\018\000\013\000\040\003\000\000\
\\015\000\041\003\000\000\
\\015\000\042\003\000\000\
\\007\000\112\000\083\000\043\003\084\000\109\000\000\000\
\\015\000\044\003\000\000\
\\015\000\045\003\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\223\000\100\000\047\003\101\000\241\001\
\\146\000\046\003\000\000\
\\000\000\
\\008\000\018\000\013\000\253\001\109\000\252\001\153\000\048\003\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\113\002\
\\126\000\058\003\000\000\
\\006\000\122\001\008\000\018\000\012\000\116\002\013\000\120\001\
\\124\000\059\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\223\000\100\000\068\003\101\000\221\000\000\000\
\\008\000\018\000\013\000\126\001\086\000\009\002\087\000\008\002\
\\088\000\069\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\235\000\156\000\071\003\000\000\
\\008\000\018\000\013\000\253\001\109\000\252\001\159\000\072\003\000\000\
\\000\000\
\\000\000\
\\005\000\019\000\008\000\018\000\010\000\082\003\011\000\016\000\
\\013\000\015\000\000\000\
\\007\000\012\001\073\000\083\003\074\000\010\001\075\000\009\001\
\\076\000\008\001\077\000\007\001\081\000\006\001\000\000\
\\006\000\122\001\008\000\018\000\012\000\084\003\013\000\120\001\000\000\
\\141\000\085\003\000\000\
\\131\000\087\003\000\000\
\\000\000\
\\015\000\246\000\130\000\088\003\000\000\
\\000\000\
\\143\000\089\003\000\000\
\\000\000\
\\139\000\090\003\000\000\
\\000\000\
\\015\000\036\002\138\000\092\003\000\000\
\\000\000\
\\003\000\159\001\078\000\093\003\000\000\
\\091\000\094\003\000\000\
\\000\000\
\\000\000\
\\089\000\096\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\093\000\098\003\098\000\224\000\099\000\223\000\100\000\097\003\
\\101\000\253\002\000\000\
\\008\000\018\000\013\000\126\001\086\000\009\002\087\000\049\002\
\\088\000\100\003\092\000\099\003\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\013\000\101\003\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\102\003\000\000\
\\008\000\018\000\013\000\103\003\000\000\
\\015\000\104\003\000\000\
\\015\000\105\003\000\000\
\\007\000\112\000\083\000\106\003\084\000\109\000\000\000\
\\015\000\107\003\000\000\
\\015\000\108\003\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\223\000\100\000\110\003\101\000\055\002\
\\105\000\109\003\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\223\000\100\000\113\003\101\000\112\003\
\\116\000\111\003\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\223\000\100\000\116\003\101\000\112\003\
\\116\000\115\003\000\000\
\\000\000\
\\008\000\108\000\112\000\117\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\006\000\122\001\008\000\018\000\012\000\120\003\013\000\120\001\000\000\
\\000\000\
\\058\000\122\003\000\000\
\\000\000\
\\015\000\129\000\057\000\123\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\015\000\230\001\054\000\124\003\000\000\
\\097\000\125\003\000\000\
\\089\000\027\001\103\000\126\003\113\000\025\001\000\000\
\\097\000\127\003\000\000\
\\005\000\019\000\008\000\018\000\010\000\128\003\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\129\003\011\000\016\000\
\\013\000\015\000\000\000\
\\006\000\122\001\008\000\018\000\012\000\130\003\013\000\120\001\000\000\
\\005\000\019\000\008\000\018\000\010\000\131\003\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\132\003\011\000\016\000\
\\013\000\015\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\013\000\133\003\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\134\003\000\000\
\\008\000\018\000\013\000\135\003\000\000\
\\015\000\136\003\000\000\
\\015\000\137\003\000\000\
\\007\000\112\000\083\000\138\003\084\000\109\000\000\000\
\\015\000\139\003\000\000\
\\015\000\140\003\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\223\000\100\000\142\003\101\000\107\002\
\\152\000\141\003\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\013\000\143\003\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\145\003\111\000\144\003\000\000\
\\008\000\018\000\013\000\146\003\000\000\
\\015\000\147\003\000\000\
\\015\000\148\003\000\000\
\\007\000\012\001\073\000\149\003\074\000\010\001\075\000\009\001\
\\076\000\008\001\077\000\007\001\081\000\006\001\000\000\
\\015\000\150\003\000\000\
\\015\000\151\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\013\000\152\003\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\153\003\000\000\
\\008\000\018\000\013\000\154\003\000\000\
\\015\000\155\003\000\000\
\\015\000\156\003\000\000\
\\007\000\112\000\083\000\157\003\084\000\109\000\000\000\
\\015\000\158\003\000\000\
\\015\000\159\003\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\223\000\100\000\161\003\101\000\138\002\
\\158\000\160\003\000\000\
\\000\000\
\\000\000\
\\141\000\162\003\000\000\
\\000\000\
\\015\000\244\000\140\000\163\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\015\000\036\002\138\000\164\003\000\000\
\\137\000\165\003\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\013\000\253\001\094\000\166\003\109\000\252\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\097\000\176\003\000\000\
\\089\000\027\001\103\000\177\003\113\000\025\001\000\000\
\\097\000\178\003\000\000\
\\005\000\019\000\008\000\018\000\010\000\179\003\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\180\003\011\000\016\000\
\\013\000\015\000\000\000\
\\006\000\122\001\008\000\018\000\012\000\181\003\013\000\120\001\000\000\
\\005\000\019\000\008\000\018\000\010\000\182\003\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\183\003\011\000\016\000\
\\013\000\015\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\114\000\184\003\000\000\
\\000\000\
\\089\000\186\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\223\000\100\000\188\003\101\000\112\003\
\\116\000\187\003\000\000\
\\008\000\018\000\013\000\126\001\086\000\009\002\087\000\175\002\
\\088\000\190\003\115\000\189\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\097\000\200\003\000\000\
\\089\000\027\001\103\000\201\003\113\000\025\001\000\000\
\\097\000\202\003\000\000\
\\005\000\019\000\008\000\018\000\010\000\203\003\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\204\003\011\000\016\000\
\\013\000\015\000\000\000\
\\006\000\122\001\008\000\018\000\012\000\205\003\013\000\120\001\000\000\
\\005\000\019\000\008\000\018\000\010\000\206\003\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\207\003\011\000\016\000\
\\013\000\015\000\000\000\
\\000\000\
\\000\000\
\\110\000\208\003\000\000\
\\000\000\
\\008\000\018\000\013\000\126\001\086\000\125\001\110\000\210\003\000\000\
\\110\000\211\003\000\000\
\\005\000\019\000\008\000\018\000\010\000\212\003\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\213\003\011\000\016\000\
\\013\000\015\000\000\000\
\\110\000\214\003\000\000\
\\005\000\019\000\008\000\018\000\010\000\215\003\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\216\003\011\000\016\000\
\\013\000\015\000\000\000\
\\097\000\217\003\000\000\
\\089\000\027\001\103\000\218\003\113\000\025\001\000\000\
\\097\000\219\003\000\000\
\\005\000\019\000\008\000\018\000\010\000\220\003\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\221\003\011\000\016\000\
\\013\000\015\000\000\000\
\\006\000\122\001\008\000\018\000\012\000\222\003\013\000\120\001\000\000\
\\005\000\019\000\008\000\018\000\010\000\223\003\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\224\003\011\000\016\000\
\\013\000\015\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\013\000\225\003\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\226\003\000\000\
\\008\000\018\000\013\000\227\003\000\000\
\\015\000\228\003\000\000\
\\015\000\229\003\000\000\
\\007\000\112\000\083\000\230\003\084\000\109\000\000\000\
\\015\000\231\003\000\000\
\\015\000\232\003\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\093\000\234\003\098\000\224\000\099\000\223\000\100\000\233\003\
\\101\000\253\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\013\000\253\001\109\000\252\001\117\000\243\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\013\000\254\003\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\000\004\111\000\144\003\149\000\255\003\000\000\
\\008\000\018\000\013\000\001\004\000\000\
\\015\000\002\004\000\000\
\\015\000\003\004\000\000\
\\007\000\012\001\073\000\004\004\074\000\010\001\075\000\009\001\
\\076\000\008\001\077\000\007\001\081\000\006\001\000\000\
\\015\000\005\004\000\000\
\\015\000\006\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\109\000\015\004\000\000\
\\000\000\
\\000\000\
\\110\000\016\004\000\000\
\\110\000\017\004\000\000\
\\000\000\
\\110\000\018\004\000\000\
\\110\000\019\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\097\000\028\004\000\000\
\\089\000\027\001\103\000\029\004\113\000\025\001\000\000\
\\097\000\030\004\000\000\
\\005\000\019\000\008\000\018\000\010\000\031\004\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\032\004\011\000\016\000\
\\013\000\015\000\000\000\
\\006\000\122\001\008\000\018\000\012\000\033\004\013\000\120\001\000\000\
\\005\000\019\000\008\000\018\000\010\000\034\004\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\035\004\011\000\016\000\
\\013\000\015\000\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\013\000\036\004\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\038\004\108\000\037\004\111\000\144\003\000\000\
\\008\000\018\000\013\000\039\004\000\000\
\\015\000\040\004\000\000\
\\015\000\041\004\000\000\
\\007\000\012\001\073\000\042\004\074\000\010\001\075\000\009\001\
\\076\000\008\001\077\000\007\001\081\000\006\001\000\000\
\\015\000\043\004\000\000\
\\015\000\044\004\000\000\
\\000\000\
\\008\000\018\000\013\000\045\004\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\046\004\000\000\
\\008\000\018\000\013\000\047\004\000\000\
\\015\000\048\004\000\000\
\\015\000\049\004\000\000\
\\007\000\112\000\083\000\050\004\084\000\109\000\000\000\
\\015\000\051\004\000\000\
\\015\000\052\004\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\223\000\100\000\054\004\101\000\112\003\
\\116\000\053\004\000\000\
\\000\000\
\\110\000\208\003\145\000\056\004\148\000\055\004\000\000\
\\000\000\
\\008\000\018\000\013\000\126\001\086\000\125\001\110\000\210\003\
\\145\000\056\004\148\000\058\004\000\000\
\\110\000\211\003\145\000\056\004\148\000\059\004\000\000\
\\005\000\019\000\008\000\018\000\010\000\060\004\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\061\004\011\000\016\000\
\\013\000\015\000\000\000\
\\110\000\214\003\145\000\056\004\148\000\062\004\000\000\
\\005\000\019\000\008\000\018\000\010\000\063\004\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\064\004\011\000\016\000\
\\013\000\015\000\000\000\
\\008\000\018\000\013\000\065\004\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\067\004\111\000\144\003\155\000\066\004\000\000\
\\008\000\018\000\013\000\068\004\000\000\
\\015\000\069\004\000\000\
\\015\000\070\004\000\000\
\\007\000\012\001\073\000\071\004\074\000\010\001\075\000\009\001\
\\076\000\008\001\077\000\007\001\081\000\006\001\000\000\
\\015\000\072\004\000\000\
\\015\000\073\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\013\000\074\004\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\076\004\111\000\144\003\161\000\075\004\000\000\
\\008\000\018\000\013\000\077\004\000\000\
\\015\000\078\004\000\000\
\\015\000\079\004\000\000\
\\007\000\012\001\073\000\080\004\074\000\010\001\075\000\009\001\
\\076\000\008\001\077\000\007\001\081\000\006\001\000\000\
\\015\000\081\004\000\000\
\\015\000\082\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\104\000\092\004\107\000\091\004\110\000\208\003\000\000\
\\000\000\
\\008\000\018\000\013\000\126\001\086\000\125\001\104\000\092\004\
\\107\000\094\004\110\000\210\003\000\000\
\\104\000\092\004\107\000\095\004\110\000\211\003\000\000\
\\005\000\019\000\008\000\018\000\010\000\096\004\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\097\004\011\000\016\000\
\\013\000\015\000\000\000\
\\104\000\092\004\107\000\098\004\110\000\214\003\000\000\
\\005\000\019\000\008\000\018\000\010\000\099\004\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\100\004\011\000\016\000\
\\013\000\015\000\000\000\
\\097\000\101\004\000\000\
\\089\000\027\001\103\000\102\004\113\000\025\001\000\000\
\\097\000\103\004\000\000\
\\005\000\019\000\008\000\018\000\010\000\104\004\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\105\004\011\000\016\000\
\\013\000\015\000\000\000\
\\006\000\122\001\008\000\018\000\012\000\106\004\013\000\120\001\000\000\
\\005\000\019\000\008\000\018\000\010\000\107\004\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\108\004\011\000\016\000\
\\013\000\015\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\214\000\109\000\015\004\144\000\201\002\147\000\109\004\000\000\
\\000\000\
\\000\000\
\\110\000\016\004\145\000\056\004\148\000\110\004\000\000\
\\110\000\017\004\145\000\056\004\148\000\111\004\000\000\
\\000\000\
\\110\000\018\004\145\000\056\004\148\000\112\004\000\000\
\\110\000\019\004\145\000\056\004\148\000\113\004\000\000\
\\110\000\208\003\151\000\115\004\154\000\114\004\000\000\
\\000\000\
\\008\000\018\000\013\000\126\001\086\000\125\001\110\000\210\003\
\\151\000\115\004\154\000\117\004\000\000\
\\110\000\211\003\151\000\115\004\154\000\118\004\000\000\
\\005\000\019\000\008\000\018\000\010\000\119\004\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\120\004\011\000\016\000\
\\013\000\015\000\000\000\
\\110\000\214\003\151\000\115\004\154\000\121\004\000\000\
\\005\000\019\000\008\000\018\000\010\000\122\004\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\123\004\011\000\016\000\
\\013\000\015\000\000\000\
\\110\000\208\003\157\000\125\004\160\000\124\004\000\000\
\\000\000\
\\008\000\018\000\013\000\126\001\086\000\125\001\110\000\210\003\
\\157\000\125\004\160\000\127\004\000\000\
\\110\000\211\003\157\000\125\004\160\000\128\004\000\000\
\\005\000\019\000\008\000\018\000\010\000\129\004\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\130\004\011\000\016\000\
\\013\000\015\000\000\000\
\\110\000\214\003\157\000\125\004\160\000\131\004\000\000\
\\005\000\019\000\008\000\018\000\010\000\132\004\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\133\004\011\000\016\000\
\\013\000\015\000\000\000\
\\008\000\018\000\013\000\134\004\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\096\000\136\004\098\000\224\000\099\000\135\004\111\000\144\003\000\000\
\\008\000\018\000\013\000\137\004\000\000\
\\015\000\138\004\000\000\
\\015\000\139\004\000\000\
\\007\000\012\001\073\000\140\004\074\000\010\001\075\000\009\001\
\\076\000\008\001\077\000\007\001\081\000\006\001\000\000\
\\015\000\141\004\000\000\
\\015\000\142\004\000\000\
\\000\000\
\\000\000\
\\009\000\105\000\102\000\006\003\106\000\143\004\109\000\015\004\000\000\
\\000\000\
\\000\000\
\\104\000\092\004\107\000\144\004\110\000\016\004\000\000\
\\104\000\092\004\107\000\145\004\110\000\017\004\000\000\
\\000\000\
\\104\000\092\004\107\000\146\004\110\000\018\004\000\000\
\\104\000\092\004\107\000\147\004\110\000\019\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\009\000\216\000\109\000\015\004\150\000\110\002\153\000\156\004\000\000\
\\000\000\
\\000\000\
\\110\000\016\004\151\000\115\004\154\000\157\004\000\000\
\\110\000\017\004\151\000\115\004\154\000\158\004\000\000\
\\000\000\
\\110\000\018\004\151\000\115\004\154\000\159\004\000\000\
\\110\000\019\004\151\000\115\004\154\000\160\004\000\000\
\\000\000\
\\000\000\
\\008\000\235\000\109\000\015\004\156\000\071\003\159\000\161\004\000\000\
\\000\000\
\\000\000\
\\110\000\016\004\157\000\125\004\160\000\162\004\000\000\
\\110\000\017\004\157\000\125\004\160\000\163\004\000\000\
\\000\000\
\\110\000\018\004\157\000\125\004\160\000\164\004\000\000\
\\110\000\019\004\157\000\125\004\160\000\165\004\000\000\
\\091\000\167\004\095\000\166\004\110\000\208\003\000\000\
\\008\000\018\000\013\000\126\001\086\000\125\001\091\000\167\004\
\\095\000\169\004\110\000\210\003\000\000\
\\000\000\
\\091\000\167\004\095\000\170\004\110\000\211\003\000\000\
\\005\000\019\000\008\000\018\000\010\000\171\004\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\172\004\011\000\016\000\
\\013\000\015\000\000\000\
\\091\000\167\004\095\000\173\004\110\000\214\003\000\000\
\\005\000\019\000\008\000\018\000\010\000\174\004\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\175\004\011\000\016\000\
\\013\000\015\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\018\000\013\000\176\004\000\000\
\\008\000\018\000\009\000\227\000\013\000\226\000\014\000\225\000\
\\098\000\224\000\099\000\178\004\111\000\144\003\119\000\177\004\000\000\
\\008\000\018\000\013\000\179\004\000\000\
\\015\000\180\004\000\000\
\\015\000\181\004\000\000\
\\007\000\012\001\073\000\182\004\074\000\010\001\075\000\009\001\
\\076\000\008\001\077\000\007\001\081\000\006\001\000\000\
\\015\000\183\004\000\000\
\\015\000\184\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\101\000\090\000\003\003\094\000\185\004\109\000\015\004\000\000\
\\000\000\
\\000\000\
\\091\000\167\004\095\000\186\004\110\000\016\004\000\000\
\\091\000\167\004\095\000\187\004\110\000\017\004\000\000\
\\000\000\
\\091\000\167\004\095\000\188\004\110\000\018\004\000\000\
\\091\000\167\004\095\000\189\004\110\000\019\004\000\000\
\\110\000\208\003\114\000\191\004\118\000\190\004\000\000\
\\000\000\
\\008\000\018\000\013\000\126\001\086\000\125\001\110\000\210\003\
\\114\000\191\004\118\000\193\004\000\000\
\\110\000\211\003\114\000\191\004\118\000\194\004\000\000\
\\005\000\019\000\008\000\018\000\010\000\195\004\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\196\004\011\000\016\000\
\\013\000\015\000\000\000\
\\110\000\214\003\114\000\191\004\118\000\197\004\000\000\
\\005\000\019\000\008\000\018\000\010\000\198\004\011\000\016\000\
\\013\000\015\000\000\000\
\\005\000\019\000\008\000\018\000\010\000\199\004\011\000\016\000\
\\013\000\015\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\108\000\109\000\015\004\112\000\117\003\117\000\200\004\000\000\
\\000\000\
\\000\000\
\\110\000\016\004\114\000\191\004\118\000\201\004\000\000\
\\110\000\017\004\114\000\191\004\118\000\202\004\000\000\
\\000\000\
\\110\000\018\004\114\000\191\004\118\000\203\004\000\000\
\\110\000\019\004\114\000\191\004\118\000\204\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\"
val numstates = 1230
val numrules = 473
val s = ref "" and index = ref 0
val string_to_int = fn () => 
let val i = !index
in index := i+2; Char.ord(String.sub(!s,i)) + Char.ord(String.sub(!s,i+1)) * 256
end
val string_to_list = fn s' =>
    let val len = String.size s'
        fun f () =
           if !index < len then string_to_int() :: f()
           else nil
   in index := 0; s := s'; f ()
   end
val string_to_pairlist = fn (conv_key,conv_entry) =>
     let fun f () =
         case string_to_int()
         of 0 => EMPTY
          | n => PAIR(conv_key (n-1),conv_entry (string_to_int()),f())
     in f
     end
val string_to_pairlist_default = fn (conv_key,conv_entry) =>
    let val conv_row = string_to_pairlist(conv_key,conv_entry)
    in fn () =>
       let val default = conv_entry(string_to_int())
           val row = conv_row()
       in (row,default)
       end
   end
val string_to_table = fn (convert_row,s') =>
    let val len = String.size s'
        fun f ()=
           if !index < len then convert_row() :: f()
           else nil
     in (s := s'; index := 0; f ())
     end
local
  val memo = Array.array(numstates+numrules,ERROR)
  val _ =let fun g i=(Array.update(memo,i,REDUCE(i-numstates)); g(i+1))
       fun f i =
            if i=numstates then g i
            else (Array.update(memo,i,SHIFT (STATE i)); f (i+1))
          in f 0 handle Subscript => ()
          end
in
val entry_to_action = fn 0 => ACCEPT | 1 => ERROR | j => Array.sub(memo,(j-2))
end
val gotoT=Array.fromList(string_to_table(string_to_pairlist(NT,STATE),gotoT))
val actionRows=string_to_table(string_to_pairlist_default(T,entry_to_action),actionRows)
val actionRowNumbers = string_to_list actionRowNumbers
val actionT = let val actionRowLookUp=
let val a=Array.fromList(actionRows) in fn i=>Array.sub(a,i) end
in Array.fromList(map actionRowLookUp actionRowNumbers)
end
in LrTable.mkLrTable {actions=actionT,gotos=gotoT,numRules=numrules,
numStates=numstates,initialState=STATE 0}
end
end
local open Header in
type pos = Source.pos
type arg = unit
structure MlyValue = 
struct
datatype svalue = VOID | ntVOID of unit ->  unit
 | ETYVAR of unit ->  (string) | TYVAR of unit ->  (string)
 | SYMBOL of unit ->  (string) | ALPHA of unit ->  (string)
 | CHAR of unit ->  (WideChar.char)
 | STRING of unit ->  (WideString.string)
 | REAL of unit ->  (LargeReal.real)
 | WORD of unit ->  (LargeWord.word) | INT of unit ->  (LargeInt.int)
 | NUMERIC of unit ->  (LargeInt.int) | DIGIT of unit ->  (int)
 | import1 of unit ->  (Import) | import0 of unit ->  (Import)
 | component of unit ->  (Component)
 | program_opt' of unit ->  (Program option)
 | program_opt of unit ->  (Program option)
 | program of unit ->  (Program)
 | sigexp__AND_rea_opt__AND_fundesc_opt of unit ->  (SigExp*Rea option*FunDesc option)
 | AND_rea_opt__AND_fundesc_opt of unit ->  (Rea option*FunDesc option)
 | rea__AND_fundesc_opt of unit ->  (Rea*FunDesc option)
 | sigexp__AND_fundesc_opt of unit ->  (SigExp*FunDesc option)
 | AND_fundesc_opt of unit ->  (FunDesc option)
 | fundesc of unit ->  (FunDesc)
 | sigexp__AND_rea_opt__AND_sigdesc_opt of unit ->  (SigExp*Rea option*SigDesc option)
 | AND_rea_opt__AND_sigdesc_opt of unit ->  (Rea option*SigDesc option)
 | rea__AND_sigdesc_opt of unit ->  (Rea*SigDesc option)
 | sigexp__AND_sigdesc_opt of unit ->  (SigExp*SigDesc option)
 | AND_sigdesc_opt of unit ->  (SigDesc option)
 | sigdesc of unit ->  (SigDesc)
 | sigexp__AND_rea_opt__AND_strdesc_opt of unit ->  (SigExp*Rea option*StrDesc option)
 | AND_rea_opt__AND_strdesc_opt of unit ->  (Rea option*StrDesc option)
 | rea__AND_strdesc_opt of unit ->  (Rea*StrDesc option)
 | sigexp__AND_strdesc_opt of unit ->  (SigExp*StrDesc option)
 | AND_strdesc_opt of unit ->  (StrDesc option)
 | strdesc of unit ->  (StrDesc)
 | AND_exdesc_opt of unit ->  (ExDesc option)
 | exdesc of unit ->  (ExDesc)
 | AND_dcondesc_opt of unit ->  (DconDesc option)
 | dcondesc of unit ->  (DconDesc)
 | BAR_condesc_opt of unit ->  (ConDesc option)
 | condesc of unit ->  (ConDesc)
 | AND_datdesc_opt of unit ->  (DatDesc option)
 | datdesc1 of unit ->  (DatDesc) | datdesc0 of unit ->  (DatDesc)
 | datdesc of unit ->  (DatDesc)
 | AND_typdesc_opt of unit ->  (TypDesc option)
 | typdesc of unit ->  (TypDesc)
 | AND_valdesc_opt of unit ->  (ValDesc option)
 | valdesc of unit ->  (ValDesc)
 | longstrid_EQUALS_list2 of unit ->  (LongStrId list)
 | longstrid_EQUALS_list1 of unit ->  (LongStrId list)
 | longsigid_EQUALS_list2 of unit ->  (LongSigId list)
 | longsigid_EQUALS_list1 of unit ->  (LongSigId list)
 | longtycon_EQUALS_list2 of unit ->  (LongTyCon list)
 | longtycon_EQUALS_list1 of unit ->  (LongTyCon list)
 | WITHTYPE_typdesc_opt of unit ->  (TypDesc option)
 | spec1' of unit ->  (Spec) | spec1 of unit ->  (Spec)
 | spec of unit ->  (Spec)
 | sigexp__AND_rea_opt__AND_funbind_opt of unit ->  (SigExp*Rea option*FunBind option)
 | AND_rea_opt__AND_funbind_opt of unit ->  (Rea option*FunBind option)
 | rea__AND_funbind_opt of unit ->  (Rea*FunBind option)
 | sigexp__AND_funbind_opt of unit ->  (SigExp*FunBind option)
 | strexp__AND_funbind_opt of unit ->  (StrExp*FunBind option)
 | AND_funbind_opt of unit ->  (FunBind option)
 | strpat_list1 of unit ->  (StrPat list)
 | funbind of unit ->  (FunBind)
 | sigexp__AND_rea_opt of unit ->  (SigExp*Rea option)
 | AND_rea_opt of unit ->  (Rea option) | rea of unit ->  (Rea)
 | sigexp__AND_rea_opt__AND_sigbind_opt of unit ->  (SigExp*Rea option*SigBind option)
 | AND_rea_opt__AND_sigbind_opt of unit ->  (Rea option*SigBind option)
 | rea__AND_sigbind_opt of unit ->  (Rea*SigBind option)
 | sigexp__AND_sigbind_opt of unit ->  (SigExp*SigBind option)
 | AND_sigbind_opt of unit ->  (SigBind option)
 | strpat_list0 of unit ->  (StrPat list)
 | sigbind of unit ->  (SigBind) | sigexp' of unit ->  (SigExp)
 | sigexp of unit ->  (SigExp) | appsigexp of unit ->  (AppSigExp)
 | atsigexp of unit ->  (AtSigExp)
 | COLON_sigexp_opt of unit ->  (SigExp option)
 | sigexp__AND_rea_opt__AND_strbind_opt of unit ->  (SigExp*Rea option*StrBind option)
 | AND_rea_opt__AND_strbind_opt of unit ->  (Rea option*StrBind option)
 | rea__AND_strbind_opt of unit ->  (Rea*StrBind option)
 | sigexp__AND_strbind_opt of unit ->  (SigExp*StrBind option)
 | strexp__AND_strbind_opt of unit ->  (StrExp*StrBind option)
 | AND_strbind_opt of unit ->  (StrBind option)
 | strbind of unit ->  (StrBind) | strpat of unit ->  (StrPat)
 | strexp of unit ->  (StrExp) | appstrexp of unit ->  (AppStrExp)
 | atstrexp of unit ->  (AtStrExp)
 | tyvar_COMMA_list1 of unit ->  (TyVar list)
 | tyvarseq1 of unit ->  (TyVarSeq) | tyvarseq of unit ->  (TyVarSeq)
 | ty_COMMA_list2 of unit ->  (Ty list) | tyseq of unit ->  (TySeq)
 | COMMA_tyrow_opt of unit ->  (TyRow option)
 | tyrow_opt of unit ->  (TyRow option) | tyrow of unit ->  (TyRow)
 | atty of unit ->  (Ty) | consty of unit ->  (Ty)
 | ty_STAR_list of unit ->  (Ty list) | tupty of unit ->  (Ty)
 | ty of unit ->  (Ty) | pat of unit ->  (Pat)
 | infpat of unit ->  (Pat) | AS_pat_opt of unit ->  (Pat option)
 | COLON_ty_opt of unit ->  (Ty option)
 | COMMA_patrow_opt of unit ->  (PatRow option)
 | patrow_opt of unit ->  (PatRow option)
 | patrow of unit ->  (PatRow) | pat_BAR_list2 of unit ->  (Pat list)
 | pat_COMMA_list2 of unit ->  (Pat list)
 | pat_COMMA_list1 of unit ->  (Pat list)
 | pat_COMMA_list0 of unit ->  (Pat list) | atpat of unit ->  (AtPat)
 | AND_exbind_opt of unit ->  (ExBind option)
 | exbind of unit ->  (ExBind)
 | AND_dconbind_opt of unit ->  (DconBind option)
 | dconbind of unit ->  (DconBind) | OF_ty_opt of unit ->  (Ty option)
 | BAR_conbind_opt of unit ->  (ConBind option)
 | conbind of unit ->  (ConBind)
 | AND_datbind_opt of unit ->  (DatBind option)
 | datbind1 of unit ->  (DatBind) | datbind0 of unit ->  (DatBind)
 | datbind of unit ->  (DatBind)
 | AND_typbind_opt of unit ->  (TypBind option)
 | typbind of unit ->  (TypBind) | fpat of unit ->  (Fpat)
 | fmrule of unit ->  (Fmrule)
 | BAR_fmatch_opt of unit ->  (Fmatch option)
 | fmatch of unit ->  (Fmatch)
 | AND_fvalbind_opt of unit ->  (FvalBind option)
 | fvalbind of unit ->  (FvalBind)
 | AND_valbind_opt of unit ->  (ValBind option)
 | valbind of unit ->  (ValBind) | d_opt of unit ->  (int option)
 | longstrid_list1 of unit ->  (LongStrId list)
 | vid_list1 of unit ->  (VId list)
 | WITHTYPE_typbind_opt of unit ->  (TypBind option)
 | dec1'' of unit ->  (Dec) | dec1' of unit ->  (Dec)
 | dec1 of unit ->  (Dec) | dec' of unit ->  (Dec)
 | dec of unit ->  (Dec) | mrule of unit ->  (Mrule)
 | BAR_match_opt of unit ->  (Match option)
 | match of unit ->  (Match) | exp of unit ->  (Exp)
 | infexp of unit ->  (InfExp) | appexp of unit ->  (AppExp)
 | COMMA_exprow_opt of unit ->  (ExpRow option)
 | exprow_opt of unit ->  (ExpRow option)
 | exprow of unit ->  (ExpRow)
 | exp_SEMICOLON_list2 of unit ->  (Exp list)
 | exp_SEMICOLON_list1 of unit ->  (Exp list)
 | exp_COMMA_list2 of unit ->  (Exp list)
 | exp_COMMA_list1 of unit ->  (Exp list)
 | exp_COMMA_list0 of unit ->  (Exp list) | atexp of unit ->  (AtExp)
 | OP_opt of unit ->  (Op) | longsigid of unit ->  (LongSigId)
 | longstrid of unit ->  (LongStrId)
 | longtycon of unit ->  (LongTyCon) | longvid' of unit ->  (LongVId)
 | longvid of unit ->  (LongVId) | sigid of unit ->  (SigId)
 | strid of unit ->  (StrId) | tyvar of unit ->  (TyVar)
 | tycon of unit ->  (TyCon) | vid' of unit ->  (VId)
 | vid of unit ->  (VId) | lab of unit ->  (Lab) | d of unit ->  (int)
 | scon of unit ->  (SCon)
end
type svalue = MlyValue.svalue
type result = Component
end
structure EC=
struct
open LrTable
val is_keyword =
fn (T 1) => true | (T 2) => true | (T 3) => true | (T 4) => true | (T 
5) => true | (T 6) => true | (T 7) => true | (T 8) => true | (T 9)
 => true | (T 10) => true | (T 11) => true | (T 12) => true | (T 13)
 => true | (T 14) => true | (T 15) => true | (T 16) => true | (T 17)
 => true | (T 18) => true | (T 19) => true | (T 20) => true | (T 21)
 => true | (T 22) => true | (T 23) => true | (T 24) => true | (T 25)
 => true | (T 26) => true | (T 27) => true | (T 28) => true | (T 29)
 => true | (T 30) => true | (T 31) => true | (T 32) => true | (T 66)
 => true | (T 67) => true | (T 68) => true | (T 69) => true | (T 70)
 => true | (T 71) => true | (T 72) => true | (T 73) => true | (T 74)
 => true | (T 49) => true | (T 50) => true | (T 51) => true | (T 52)
 => true | (T 55) => true | (T 56) => true | (T 57) => true | (T 58)
 => true | (T 59) => true | (T 60) => true | (T 61) => true | (T 62)
 => true | (T 63) => true | (T 64) => true | (T 65) => true | _ => false
val preferred_change = 
nil
val noShift = 
fn (T 0) => true | _ => false
val showTerminal =
fn (T 0) => "EOF"
  | (T 1) => "ABSTYPE"
  | (T 2) => "AND"
  | (T 3) => "ANDALSO"
  | (T 4) => "AS"
  | (T 5) => "CASE"
  | (T 6) => "DO"
  | (T 7) => "DATATYPE"
  | (T 8) => "ELSE"
  | (T 9) => "END"
  | (T 10) => "EXCEPTION"
  | (T 11) => "FN"
  | (T 12) => "FUN"
  | (T 13) => "HANDLE"
  | (T 14) => "IF"
  | (T 15) => "IN"
  | (T 16) => "INFIX"
  | (T 17) => "INFIXR"
  | (T 18) => "LET"
  | (T 19) => "LOCAL"
  | (T 20) => "NONFIX"
  | (T 21) => "OF"
  | (T 22) => "OP"
  | (T 23) => "OPEN"
  | (T 24) => "ORELSE"
  | (T 25) => "RAISE"
  | (T 26) => "REC"
  | (T 27) => "THEN"
  | (T 28) => "TYPE"
  | (T 29) => "VAL"
  | (T 30) => "WITH"
  | (T 31) => "WITHTYPE"
  | (T 32) => "WHILE"
  | (T 33) => "LPAR"
  | (T 34) => "RPAR"
  | (T 35) => "LBRACK"
  | (T 36) => "RBRACK"
  | (T 37) => "LBRACE"
  | (T 38) => "RBRACE"
  | (T 39) => "COMMA"
  | (T 40) => "COLON"
  | (T 41) => "SEMICOLON"
  | (T 42) => "DOTS"
  | (T 43) => "UNDERBAR"
  | (T 44) => "BAR"
  | (T 45) => "EQUALS"
  | (T 46) => "DARROW"
  | (T 47) => "ARROW"
  | (T 48) => "HASH"
  | (T 49) => "CONSTRUCTOR"
  | (T 50) => "NON"
  | (T 51) => "WITHFUN"
  | (T 52) => "WITHVAL"
  | (T 53) => "DOT"
  | (T 54) => "HASHBRACK"
  | (T 55) => "ANY"
  | (T 56) => "FCT"
  | (T 57) => "PACK"
  | (T 58) => "UNPACK"
  | (T 59) => "IMPORT"
  | (T 60) => "FROM"
  | (T 61) => "PRIMITIVE"
  | (T 62) => "OVERLOAD"
  | (T 63) => "INSTANCE"
  | (T 64) => "PREBOUND"
  | (T 65) => "EQEQTYPE"
  | (T 66) => "EQTYPE"
  | (T 67) => "FUNCTOR"
  | (T 68) => "INCLUDE"
  | (T 69) => "SHARING"
  | (T 70) => "SIG"
  | (T 71) => "SIGNATURE"
  | (T 72) => "STRUCT"
  | (T 73) => "STRUCTURE"
  | (T 74) => "WHERE"
  | (T 75) => "COLONGREATER"
  | (T 76) => "ZERO"
  | (T 77) => "DIGIT"
  | (T 78) => "NUMERIC"
  | (T 79) => "INT"
  | (T 80) => "WORD"
  | (T 81) => "REAL"
  | (T 82) => "STRING"
  | (T 83) => "CHAR"
  | (T 84) => "ALPHA"
  | (T 85) => "SYMBOL"
  | (T 86) => "STAR"
  | (T 87) => "TYVAR"
  | (T 88) => "ETYVAR"
  | _ => "bogus-term"
local open Header in
val errtermvalue=
fn _ => MlyValue.VOID
end
val terms = (T 0) :: (T 1) :: (T 2) :: (T 3) :: (T 4) :: (T 5) :: (T 6
) :: (T 7) :: (T 8) :: (T 9) :: (T 10) :: (T 11) :: (T 12) :: (T 13)
 :: (T 14) :: (T 15) :: (T 16) :: (T 17) :: (T 18) :: (T 19) :: (T 20)
 :: (T 21) :: (T 22) :: (T 23) :: (T 24) :: (T 25) :: (T 26) :: (T 27)
 :: (T 28) :: (T 29) :: (T 30) :: (T 31) :: (T 32) :: (T 33) :: (T 34)
 :: (T 35) :: (T 36) :: (T 37) :: (T 38) :: (T 39) :: (T 40) :: (T 41)
 :: (T 42) :: (T 43) :: (T 44) :: (T 45) :: (T 46) :: (T 47) :: (T 48)
 :: (T 49) :: (T 50) :: (T 51) :: (T 52) :: (T 53) :: (T 54) :: (T 55)
 :: (T 56) :: (T 57) :: (T 58) :: (T 59) :: (T 60) :: (T 61) :: (T 62)
 :: (T 63) :: (T 64) :: (T 65) :: (T 66) :: (T 67) :: (T 68) :: (T 69)
 :: (T 70) :: (T 71) :: (T 72) :: (T 73) :: (T 74) :: (T 75) :: (T 76)
 :: (T 86) :: nil
end
structure Actions =
struct 
exception mlyAction of int
local open Header in
val actions = 
fn (i392,defaultPos,stack,
    (()):arg) =>
case (i392,stack)
of (0,(_,(_,ZEROleft as ZERO1left,ZEROright as ZERO1right))::rest671)
 => let val result=MlyValue.scon(fn _ => (
 SCon(I(ZEROleft,ZEROright),
				SCon.INT(LargeInt.fromInt 0)) ))
 in (LrTable.NT 0,(result,ZERO1left,ZERO1right),rest671) end
| (1,(_,(MlyValue.DIGIT DIGIT1,DIGITleft as DIGIT1left,DIGITright as 
DIGIT1right))::rest671) => let val result=MlyValue.scon(fn _ => let 
val DIGIT as DIGIT1=DIGIT1 ()
 in (
 SCon(I(DIGITleft,DIGITright),
				SCon.INT(LargeInt.fromInt DIGIT)) )
 end
)
 in (LrTable.NT 0,(result,DIGIT1left,DIGIT1right),rest671) end
| (2,(_,(MlyValue.NUMERIC NUMERIC1,NUMERICleft as NUMERIC1left,
NUMERICright as NUMERIC1right))::rest671) => let val result=
MlyValue.scon(fn _ => let val NUMERIC as NUMERIC1=NUMERIC1 ()
 in ( SCon(I(NUMERICleft,NUMERICright),
							SCon.INT NUMERIC) ) end
)
 in (LrTable.NT 0,(result,NUMERIC1left,NUMERIC1right),rest671) end
| (3,(_,(MlyValue.INT INT1,INTleft as INT1left,INTright as INT1right))
::rest671) => let val result=MlyValue.scon(fn _ => let val INT as INT1
=INT1 ()
 in ( SCon(I(INTleft,INTright),     SCon.INT INT) ) end
)
 in (LrTable.NT 0,(result,INT1left,INT1right),rest671) end
| (4,(_,(MlyValue.WORD WORD1,WORDleft as WORD1left,WORDright as 
WORD1right))::rest671) => let val result=MlyValue.scon(fn _ => let 
val WORD as WORD1=WORD1 ()
 in ( SCon(I(WORDleft,WORDright),   SCon.WORD WORD) ) end
)
 in (LrTable.NT 0,(result,WORD1left,WORD1right),rest671) end
| (5,(_,(MlyValue.STRING STRING1,STRINGleft as STRING1left,STRINGright
 as STRING1right))::rest671) => let val result=MlyValue.scon(fn _ => 
let val STRING as STRING1=STRING1 ()
 in ( SCon(I(STRINGleft,STRINGright),
							SCon.STRING STRING)) end
)
 in (LrTable.NT 0,(result,STRING1left,STRING1right),rest671) end
| (6,(_,(MlyValue.CHAR CHAR1,CHARleft as CHAR1left,CHARright as 
CHAR1right))::rest671) => let val result=MlyValue.scon(fn _ => let 
val CHAR as CHAR1=CHAR1 ()
 in ( SCon(I(CHARleft,CHARright),   SCon.CHAR CHAR) ) end
)
 in (LrTable.NT 0,(result,CHAR1left,CHAR1right),rest671) end
| (7,(_,(MlyValue.REAL REAL1,REALleft as REAL1left,REALright as 
REAL1right))::rest671) => let val result=MlyValue.scon(fn _ => let 
val REAL as REAL1=REAL1 ()
 in ( SCon(I(REALleft,REALright),   SCon.REAL REAL) ) end
)
 in (LrTable.NT 0,(result,REAL1left,REAL1right),rest671) end
| (8,(_,(_,ZERO1left,ZERO1right))::rest671) => let val result=
MlyValue.d(fn _ => ( 0 ))
 in (LrTable.NT 1,(result,ZERO1left,ZERO1right),rest671) end
| (9,(_,(MlyValue.DIGIT DIGIT1,DIGIT1left,DIGIT1right))::rest671) => 
let val result=MlyValue.d(fn _ => let val DIGIT as DIGIT1=DIGIT1 ()
 in ( DIGIT ) end
)
 in (LrTable.NT 1,(result,DIGIT1left,DIGIT1right),rest671) end
| (10,(_,(MlyValue.ALPHA ALPHA1,ALPHAleft as ALPHA1left,ALPHAright as 
ALPHA1right))::rest671) => let val result=MlyValue.lab(fn _ => let 
val ALPHA as ALPHA1=ALPHA1 ()
 in ( Lab(I(ALPHAleft,ALPHAright),   Lab.fromString ALPHA) ) end
)
 in (LrTable.NT 2,(result,ALPHA1left,ALPHA1right),rest671) end
| (11,(_,(MlyValue.SYMBOL SYMBOL1,SYMBOLleft as SYMBOL1left,
SYMBOLright as SYMBOL1right))::rest671) => let val result=MlyValue.lab
(fn _ => let val SYMBOL as SYMBOL1=SYMBOL1 ()
 in ( Lab(I(SYMBOLleft,SYMBOLright), Lab.fromString SYMBOL)) end
)
 in (LrTable.NT 2,(result,SYMBOL1left,SYMBOL1right),rest671) end
| (12,(_,(_,STARleft as STAR1left,STARright as STAR1right))::rest671)
 => let val result=MlyValue.lab(fn _ => (
 Lab(I(STARleft,STARright),     Lab.fromString "*") ))
 in (LrTable.NT 2,(result,STAR1left,STAR1right),rest671) end
| (13,(_,(MlyValue.DIGIT DIGIT1,DIGITleft as DIGIT1left,DIGITright as 
DIGIT1right))::rest671) => let val result=MlyValue.lab(fn _ => let 
val DIGIT as DIGIT1=DIGIT1 ()
 in ( Lab(I(DIGITleft,DIGITright),   Lab.fromInt DIGIT) ) end
)
 in (LrTable.NT 2,(result,DIGIT1left,DIGIT1right),rest671) end
| (14,(_,(MlyValue.NUMERIC NUMERIC1,NUMERICleft as NUMERIC1left,
NUMERICright as NUMERIC1right))::rest671) => let val result=
MlyValue.lab(fn _ => let val NUMERIC as NUMERIC1=NUMERIC1 ()
 in ( Lab(I(NUMERICleft,NUMERICright),
						Lab.fromLargeInt NUMERIC)
) end
)
 in (LrTable.NT 2,(result,NUMERIC1left,NUMERIC1right),rest671) end
| (15,(_,(MlyValue.vid' vid'1,vid'1left,vid'1right))::rest671) => let 
val result=MlyValue.vid(fn _ => let val vid' as vid'1=vid'1 ()
 in ( vid' ) end
)
 in (LrTable.NT 3,(result,vid'1left,vid'1right),rest671) end
| (16,(_,(_,EQUALSleft as EQUALS1left,EQUALSright as EQUALS1right))::
rest671) => let val result=MlyValue.vid(fn _ => (
 VId(I(EQUALSleft,EQUALSright), VId.fromString "=") ))
 in (LrTable.NT 3,(result,EQUALS1left,EQUALS1right),rest671) end
| (17,(_,(MlyValue.ALPHA ALPHA1,ALPHAleft as ALPHA1left,ALPHAright as 
ALPHA1right))::rest671) => let val result=MlyValue.vid'(fn _ => let 
val ALPHA as ALPHA1=ALPHA1 ()
 in ( VId(I(ALPHAleft,ALPHAright),   VId.fromString ALPHA) ) end
)
 in (LrTable.NT 4,(result,ALPHA1left,ALPHA1right),rest671) end
| (18,(_,(MlyValue.SYMBOL SYMBOL1,SYMBOLleft as SYMBOL1left,
SYMBOLright as SYMBOL1right))::rest671) => let val result=
MlyValue.vid'(fn _ => let val SYMBOL as SYMBOL1=SYMBOL1 ()
 in ( VId(I(SYMBOLleft,SYMBOLright), VId.fromString SYMBOL)) end
)
 in (LrTable.NT 4,(result,SYMBOL1left,SYMBOL1right),rest671) end
| (19,(_,(_,STARleft as STAR1left,STARright as STAR1right))::rest671)
 => let val result=MlyValue.vid'(fn _ => (
 VId(I(STARleft,STARright),     VId.fromString "*") ))
 in (LrTable.NT 4,(result,STAR1left,STAR1right),rest671) end
| (20,(_,(MlyValue.ALPHA ALPHA1,ALPHAleft as ALPHA1left,ALPHAright as 
ALPHA1right))::rest671) => let val result=MlyValue.tycon(fn _ => let 
val ALPHA as ALPHA1=ALPHA1 ()
 in ( TyCon(I(ALPHAleft,ALPHAright),
				TyCon.fromString ALPHA) ) end
)
 in (LrTable.NT 5,(result,ALPHA1left,ALPHA1right),rest671) end
| (21,(_,(MlyValue.SYMBOL SYMBOL1,SYMBOLleft as SYMBOL1left,
SYMBOLright as SYMBOL1right))::rest671) => let val result=
MlyValue.tycon(fn _ => let val SYMBOL as SYMBOL1=SYMBOL1 ()
 in ( TyCon(I(SYMBOLleft,SYMBOLright),
				TyCon.fromString SYMBOL) )
 end
)
 in (LrTable.NT 5,(result,SYMBOL1left,SYMBOL1right),rest671) end
| (22,(_,(MlyValue.TYVAR TYVAR1,TYVARleft as TYVAR1left,TYVARright as 
TYVAR1right))::rest671) => let val result=MlyValue.tyvar(fn _ => let 
val TYVAR as TYVAR1=TYVAR1 ()
 in ( TyVar(I(TYVARleft,TYVARright),
				TyVar.fromString TYVAR) ) end
)
 in (LrTable.NT 6,(result,TYVAR1left,TYVAR1right),rest671) end
| (23,(_,(MlyValue.ALPHA ALPHA1,ALPHAleft as ALPHA1left,ALPHAright as 
ALPHA1right))::rest671) => let val result=MlyValue.strid(fn _ => let 
val ALPHA as ALPHA1=ALPHA1 ()
 in ( StrId(I(ALPHAleft,ALPHAright),
				StrId.fromString ALPHA) ) end
)
 in (LrTable.NT 7,(result,ALPHA1left,ALPHA1right),rest671) end
| (24,(_,(MlyValue.ALPHA ALPHA1,ALPHAleft as ALPHA1left,ALPHAright as 
ALPHA1right))::rest671) => let val result=MlyValue.sigid(fn _ => let 
val ALPHA as ALPHA1=ALPHA1 ()
 in ( SigId(I(ALPHAleft,ALPHAright),
				SigId.fromString ALPHA) ) end
)
 in (LrTable.NT 8,(result,ALPHA1left,ALPHA1right),rest671) end
| (25,(_,(MlyValue.longvid' longvid'1,longvid'1left,longvid'1right))::
rest671) => let val result=MlyValue.longvid(fn _ => let val longvid'
 as longvid'1=longvid'1 ()
 in ( longvid' ) end
)
 in (LrTable.NT 9,(result,longvid'1left,longvid'1right),rest671) end
| (26,(_,(_,EQUALSleft as EQUALS1left,EQUALSright as EQUALS1right))::
rest671) => let val result=MlyValue.longvid(fn _ => (
 SHORTLong(I(EQUALSleft,EQUALSright),
					    VId(I(EQUALSleft,EQUALSright),
						VId.fromString "=")) 
))
 in (LrTable.NT 9,(result,EQUALS1left,EQUALS1right),rest671) end
| (27,(_,(MlyValue.vid' vid'1,vid'left as vid'1left,vid'right as 
vid'1right))::rest671) => let val result=MlyValue.longvid'(fn _ => 
let val vid' as vid'1=vid'1 ()
 in ( SHORTLong(I(vid'left,vid'right), vid') ) end
)
 in (LrTable.NT 10,(result,vid'1left,vid'1right),rest671) end
| (28,(_,(MlyValue.vid vid1,_,vidright as vid1right))::_::(_,(
MlyValue.longstrid longstrid1,longstridleft as longstrid1left,_))::
rest671) => let val result=MlyValue.longvid'(fn _ => let val longstrid
 as longstrid1=longstrid1 ()
val vid as vid1=vid1 ()
 in ( DOTLong(I(longstridleft,vidright),
					  longstrid, vid) ) end
)
 in (LrTable.NT 10,(result,longstrid1left,vid1right),rest671) end
| (29,(_,(MlyValue.tycon tycon1,tyconleft as tycon1left,tyconright as 
tycon1right))::rest671) => let val result=MlyValue.longtycon(fn _ => 
let val tycon as tycon1=tycon1 ()
 in ( SHORTLong(I(tyconleft,tyconright), tycon) ) end
)
 in (LrTable.NT 11,(result,tycon1left,tycon1right),rest671) end
| (30,(_,(MlyValue.tycon tycon1,_,tyconright as tycon1right))::_::(_,(
MlyValue.longstrid longstrid1,longstridleft as longstrid1left,_))::
rest671) => let val result=MlyValue.longtycon(fn _ => let val 
longstrid as longstrid1=longstrid1 ()
val tycon as tycon1=tycon1 ()
 in ( DOTLong(I(longstridleft,tyconright),
					  longstrid, tycon) )
 end
)
 in (LrTable.NT 11,(result,longstrid1left,tycon1right),rest671) end
| (31,(_,(MlyValue.strid strid1,stridleft as strid1left,stridright as 
strid1right))::rest671) => let val result=MlyValue.longstrid(fn _ => 
let val strid as strid1=strid1 ()
 in ( SHORTLong(I(stridleft,stridright), strid) ) end
)
 in (LrTable.NT 12,(result,strid1left,strid1right),rest671) end
| (32,(_,(MlyValue.strid strid1,_,stridright as strid1right))::_::(_,(
MlyValue.longstrid longstrid1,longstridleft as longstrid1left,_))::
rest671) => let val result=MlyValue.longstrid(fn _ => let val 
longstrid as longstrid1=longstrid1 ()
val strid as strid1=strid1 ()
 in ( DOTLong(I(longstridleft,stridright),
					  longstrid, strid) )
 end
)
 in (LrTable.NT 12,(result,longstrid1left,strid1right),rest671) end
| (33,(_,(MlyValue.sigid sigid1,sigidleft as sigid1left,sigidright as 
sigid1right))::rest671) => let val result=MlyValue.longsigid(fn _ => 
let val sigid as sigid1=sigid1 ()
 in ( SHORTLong(I(sigidleft,sigidright), sigid) ) end
)
 in (LrTable.NT 13,(result,sigid1left,sigid1right),rest671) end
| (34,(_,(MlyValue.sigid sigid1,_,sigidright as sigid1right))::_::(_,(
MlyValue.longstrid longstrid1,longstridleft as longstrid1left,_))::
rest671) => let val result=MlyValue.longsigid(fn _ => let val 
longstrid as longstrid1=longstrid1 ()
val sigid as sigid1=sigid1 ()
 in ( DOTLong(I(longstridleft,sigidright),
					  longstrid, sigid) )
 end
)
 in (LrTable.NT 13,(result,longstrid1left,sigid1right),rest671) end
| (35,(_,(_,OP1left,OP1right))::rest671) => let val result=
MlyValue.OP_opt(fn _ => ( WITHOp ))
 in (LrTable.NT 14,(result,OP1left,OP1right),rest671) end
| (36,rest671) => let val result=MlyValue.OP_opt(fn _ => ( SANSOp ))
 in (LrTable.NT 14,(result,defaultPos,defaultPos),rest671) end
| (37,(_,(MlyValue.scon scon1,sconleft as scon1left,sconright as 
scon1right))::rest671) => let val result=MlyValue.atexp(fn _ => let 
val scon as scon1=scon1 ()
 in ( SCONAtExp(I(sconleft,sconright), scon) ) end
)
 in (LrTable.NT 15,(result,scon1left,scon1right),rest671) end
| (38,(_,(MlyValue.longvid longvid1,longvidleft as longvid1left,
longvidright as longvid1right))::rest671) => let val result=
MlyValue.atexp(fn _ => let val longvid as longvid1=longvid1 ()
 in (
 LONGVIDAtExp(I(longvidleft,longvidright),
				       SANSOp, longvid) 
) end
)
 in (LrTable.NT 15,(result,longvid1left,longvid1right),rest671) end
| (39,(_,(MlyValue.longvid longvid1,_,longvidright as longvid1right))
::(_,(_,OPleft as OP1left,_))::rest671) => let val result=
MlyValue.atexp(fn _ => let val longvid as longvid1=longvid1 ()
 in (
 LONGVIDAtExp(I(OPleft,longvidright),
				       WITHOp, longvid) )
 end
)
 in (LrTable.NT 15,(result,OP1left,longvid1right),rest671) end
| (40,(_,(_,_,RBRACEright as RBRACE1right))::(_,(MlyValue.exprow_opt 
exprow_opt1,_,_))::(_,(_,LBRACEleft as LBRACE1left,_))::rest671) => 
let val result=MlyValue.atexp(fn _ => let val exprow_opt as 
exprow_opt1=exprow_opt1 ()
 in ( RECORDAtExp(I(LBRACEleft,RBRACEright), exprow_opt) ) end
)
 in (LrTable.NT 15,(result,LBRACE1left,RBRACE1right),rest671) end
| (41,(_,(_,_,RBRACEright as RBRACE1right))::(_,(MlyValue.exprow 
exprow1,_,_))::_::(_,(MlyValue.atexp atexp1,_,_))::(_,(_,LBRACEleft
 as LBRACE1left,_))::rest671) => let val result=MlyValue.atexp(fn _
 => let val atexp as atexp1=atexp1 ()
val exprow as exprow1=exprow1 ()
 in ( UPDATEAtExp(I(LBRACEleft,RBRACEright), atexp, exprow)) end
)
 in (LrTable.NT 15,(result,LBRACE1left,RBRACE1right),rest671) end
| (42,(_,(MlyValue.lab lab1,_,labright as lab1right))::(_,(_,HASHleft
 as HASH1left,_))::rest671) => let val result=MlyValue.atexp(fn _ => 
let val lab as lab1=lab1 ()
 in ( HASHAtExp(I(HASHleft,labright), lab) ) end
)
 in (LrTable.NT 15,(result,HASH1left,lab1right),rest671) end
| (43,(_,(_,_,RPARright as RPAR1right))::(_,(_,LPARleft as LPAR1left,_
))::rest671) => let val result=MlyValue.atexp(fn _ => (
 UNITAtExp(I(LPARleft,RPARright)) ))
 in (LrTable.NT 15,(result,LPAR1left,RPAR1right),rest671) end
| (44,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.exp_COMMA_list2 
exp_COMMA_list21,_,_))::(_,(_,LPARleft as LPAR1left,_))::rest671) => 
let val result=MlyValue.atexp(fn _ => let val exp_COMMA_list2 as 
exp_COMMA_list21=exp_COMMA_list21 ()
 in ( TUPLEAtExp(I(LPARleft,RPARright), exp_COMMA_list2) ) end
)
 in (LrTable.NT 15,(result,LPAR1left,RPAR1right),rest671) end
| (45,(_,(_,_,RBRACKright as RBRACK1right))::(_,(
MlyValue.exp_COMMA_list0 exp_COMMA_list01,_,_))::(_,(_,LBRACKleft as 
LBRACK1left,_))::rest671) => let val result=MlyValue.atexp(fn _ => 
let val exp_COMMA_list0 as exp_COMMA_list01=exp_COMMA_list01 ()
 in ( LISTAtExp(I(LBRACKleft,RBRACKright),
				    exp_COMMA_list0 ))
 end
)
 in (LrTable.NT 15,(result,LBRACK1left,RBRACK1right),rest671) end
| (46,(_,(_,_,RBRACKright as RBRACK1right))::(_,(
MlyValue.exp_COMMA_list0 exp_COMMA_list01,_,_))::(_,(_,HASHBRACKleft
 as HASHBRACK1left,_))::rest671) => let val result=MlyValue.atexp(fn _
 => let val exp_COMMA_list0 as exp_COMMA_list01=exp_COMMA_list01 ()
 in (
 VECTORAtExp(I(HASHBRACKleft,RBRACKright),
				    exp_COMMA_list0 ))
 end
)
 in (LrTable.NT 15,(result,HASHBRACK1left,RBRACK1right),rest671) end
| (47,(_,(_,_,RPARright as RPAR1right))::(_,(
MlyValue.exp_SEMICOLON_list2 exp_SEMICOLON_list21,_,_))::(_,(_,
LPARleft as LPAR1left,_))::rest671) => let val result=MlyValue.atexp(
fn _ => let val exp_SEMICOLON_list2 as exp_SEMICOLON_list21=
exp_SEMICOLON_list21 ()
 in ( SEQAtExp(I(LPARleft,RPARright), exp_SEMICOLON_list2) ) end
)
 in (LrTable.NT 15,(result,LPAR1left,RPAR1right),rest671) end
| (48,(_,(_,_,ENDright as END1right))::(_,(
MlyValue.exp_SEMICOLON_list1 exp_SEMICOLON_list11,_,_))::_::(_,(
MlyValue.dec dec1,_,_))::(_,(_,LETleft as LET1left,_))::rest671) => 
let val result=MlyValue.atexp(fn _ => let val dec as dec1=dec1 ()
val exp_SEMICOLON_list1 as exp_SEMICOLON_list11=exp_SEMICOLON_list11 
()
 in ( LETAtExp(I(LETleft,ENDright),
				   dec, exp_SEMICOLON_list1) )
 end
)
 in (LrTable.NT 15,(result,LET1left,END1right),rest671) end
| (49,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.exp exp1,_,_))::
(_,(_,LPARleft as LPAR1left,_))::rest671) => let val result=
MlyValue.atexp(fn _ => let val exp as exp1=exp1 ()
 in ( PARAtExp(I(LPARleft,RPARright), exp) ) end
)
 in (LrTable.NT 15,(result,LPAR1left,RPAR1right),rest671) end
| (50,(_,(MlyValue.exp_COMMA_list1 exp_COMMA_list11,
exp_COMMA_list11left,exp_COMMA_list11right))::rest671) => let val 
result=MlyValue.exp_COMMA_list0(fn _ => let val exp_COMMA_list1 as 
exp_COMMA_list11=exp_COMMA_list11 ()
 in ( exp_COMMA_list1 ) end
)
 in (LrTable.NT 16,(result,exp_COMMA_list11left,exp_COMMA_list11right)
,rest671) end
| (51,rest671) => let val result=MlyValue.exp_COMMA_list0(fn _ => (
 [] ))
 in (LrTable.NT 16,(result,defaultPos,defaultPos),rest671) end
| (52,(_,(MlyValue.exp_COMMA_list1 exp_COMMA_list11,_,
exp_COMMA_list11right))::_::(_,(MlyValue.exp exp1,exp1left,_))::
rest671) => let val result=MlyValue.exp_COMMA_list1(fn _ => let val 
exp as exp1=exp1 ()
val exp_COMMA_list1 as exp_COMMA_list11=exp_COMMA_list11 ()
 in ( exp::exp_COMMA_list1 ) end
)
 in (LrTable.NT 17,(result,exp1left,exp_COMMA_list11right),rest671)
 end
| (53,(_,(MlyValue.exp exp1,exp1left,exp1right))::rest671) => let val 
result=MlyValue.exp_COMMA_list1(fn _ => let val exp as exp1=exp1 ()
 in ( exp::[] ) end
)
 in (LrTable.NT 17,(result,exp1left,exp1right),rest671) end
| (54,(_,(MlyValue.exp_COMMA_list1 exp_COMMA_list11,_,
exp_COMMA_list11right))::_::(_,(MlyValue.exp exp1,exp1left,_))::
rest671) => let val result=MlyValue.exp_COMMA_list2(fn _ => let val 
exp as exp1=exp1 ()
val exp_COMMA_list1 as exp_COMMA_list11=exp_COMMA_list11 ()
 in ( exp::exp_COMMA_list1 ) end
)
 in (LrTable.NT 18,(result,exp1left,exp_COMMA_list11right),rest671)
 end
| (55,(_,(MlyValue.exp_SEMICOLON_list1 exp_SEMICOLON_list11,_,
exp_SEMICOLON_list11right))::_::(_,(MlyValue.exp exp1,exp1left,_))::
rest671) => let val result=MlyValue.exp_SEMICOLON_list1(fn _ => let 
val exp as exp1=exp1 ()
val exp_SEMICOLON_list1 as exp_SEMICOLON_list11=exp_SEMICOLON_list11 
()
 in ( exp::exp_SEMICOLON_list1 ) end
)
 in (LrTable.NT 19,(result,exp1left,exp_SEMICOLON_list11right),rest671
) end
| (56,(_,(MlyValue.exp exp1,exp1left,exp1right))::rest671) => let val 
result=MlyValue.exp_SEMICOLON_list1(fn _ => let val exp as exp1=exp1 
()
 in ( exp::[] ) end
)
 in (LrTable.NT 19,(result,exp1left,exp1right),rest671) end
| (57,(_,(MlyValue.exp_SEMICOLON_list1 exp_SEMICOLON_list11,_,
exp_SEMICOLON_list11right))::_::(_,(MlyValue.exp exp1,exp1left,_))::
rest671) => let val result=MlyValue.exp_SEMICOLON_list2(fn _ => let 
val exp as exp1=exp1 ()
val exp_SEMICOLON_list1 as exp_SEMICOLON_list11=exp_SEMICOLON_list11 
()
 in ( exp::exp_SEMICOLON_list1 ) end
)
 in (LrTable.NT 20,(result,exp1left,exp_SEMICOLON_list11right),rest671
) end
| (58,(_,(MlyValue.COMMA_exprow_opt COMMA_exprow_opt1,_,
COMMA_exprow_optright as COMMA_exprow_opt1right))::(_,(MlyValue.exp 
exp1,_,_))::_::(_,(MlyValue.lab lab1,lableft as lab1left,_))::rest671)
 => let val result=MlyValue.exprow(fn _ => let val lab as lab1=lab1 ()
val exp as exp1=exp1 ()
val COMMA_exprow_opt as COMMA_exprow_opt1=COMMA_exprow_opt1 ()
 in (
 ROWExpRow(I(lableft,COMMA_exprow_optright),
	  				    lab, exp, COMMA_exprow_opt) 
) end
)
 in (LrTable.NT 21,(result,lab1left,COMMA_exprow_opt1right),rest671)
 end
| (59,(_,(MlyValue.COMMA_exprow_opt COMMA_exprow_opt1,_,
COMMA_exprow_optright as COMMA_exprow_opt1right))::(_,(
MlyValue.COLON_ty_opt COLON_ty_opt1,_,_))::(_,(MlyValue.vid' vid'1,
vid'left as vid'1left,_))::rest671) => let val result=MlyValue.exprow(
fn _ => let val vid' as vid'1=vid'1 ()
val COLON_ty_opt as COLON_ty_opt1=COLON_ty_opt1 ()
val COMMA_exprow_opt as COMMA_exprow_opt1=COMMA_exprow_opt1 ()
 in (
 VIDExpRow(I(vid'left,COMMA_exprow_optright),
	  				    vid', COLON_ty_opt,
					    COMMA_exprow_opt) 
) end
)
 in (LrTable.NT 21,(result,vid'1left,COMMA_exprow_opt1right),rest671)
 end
| (60,(_,(MlyValue.exprow exprow1,_,exprow1right))::(_,(_,COMMA1left,_
))::rest671) => let val result=MlyValue.COMMA_exprow_opt(fn _ => let 
val exprow as exprow1=exprow1 ()
 in ( SOME exprow ) end
)
 in (LrTable.NT 23,(result,COMMA1left,exprow1right),rest671) end
| (61,rest671) => let val result=MlyValue.COMMA_exprow_opt(fn _ => (
 NONE ))
 in (LrTable.NT 23,(result,defaultPos,defaultPos),rest671) end
| (62,(_,(MlyValue.exprow exprow1,exprow1left,exprow1right))::rest671)
 => let val result=MlyValue.exprow_opt(fn _ => let val exprow as 
exprow1=exprow1 ()
 in ( SOME exprow ) end
)
 in (LrTable.NT 22,(result,exprow1left,exprow1right),rest671) end
| (63,rest671) => let val result=MlyValue.exprow_opt(fn _ => ( NONE ))
 in (LrTable.NT 22,(result,defaultPos,defaultPos),rest671) end
| (64,(_,(MlyValue.atexp atexp1,atexpleft as atexp1left,atexpright as 
atexp1right))::rest671) => let val result=MlyValue.appexp(fn _ => let 
val atexp as atexp1=atexp1 ()
 in ( ATEXPExp(I(atexpleft,atexpright), atexp) ) end
)
 in (LrTable.NT 24,(result,atexp1left,atexp1right),rest671) end
| (65,(_,(MlyValue.atexp atexp1,_,atexpright as atexp1right))::(_,(
MlyValue.appexp appexp1,appexpleft as appexp1left,_))::rest671) => 
let val result=MlyValue.appexp(fn _ => let val appexp as appexp1=
appexp1 ()
val atexp as atexp1=atexp1 ()
 in ( APPExp(I(appexpleft,atexpright),
					 appexp, atexp) ) end
)
 in (LrTable.NT 24,(result,appexp1left,atexp1right),rest671) end
| (66,(_,(MlyValue.appexp appexp1,appexp1left,appexp1right))::rest671)
 => let val result=MlyValue.infexp(fn _ => let val appexp as appexp1=
appexp1 ()
 in ( appexp ) end
)
 in (LrTable.NT 25,(result,appexp1left,appexp1right),rest671) end
| (67,(_,(MlyValue.infexp infexp1,infexp1left,infexp1right))::rest671)
 => let val result=MlyValue.exp(fn _ => let val infexp as infexp1=
infexp1 ()
 in ( infexp ) end
)
 in (LrTable.NT 26,(result,infexp1left,infexp1right),rest671) end
| (68,(_,(MlyValue.ty ty1,_,tyright as ty1right))::_::(_,(MlyValue.exp
 exp1,expleft as exp1left,_))::rest671) => let val result=MlyValue.exp
(fn _ => let val exp as exp1=exp1 ()
val ty as ty1=ty1 ()
 in ( TYPEDExp(I(expleft,tyright), exp, ty) ) end
)
 in (LrTable.NT 26,(result,exp1left,ty1right),rest671) end
| (69,(_,(MlyValue.exp exp2,_,exp2right))::_::(_,(MlyValue.exp exp1,
exp1left,_))::rest671) => let val result=MlyValue.exp(fn _ => let val 
exp1=exp1 ()
val exp2=exp2 ()
 in ( ANDALSOExp(I(exp1left,exp2right), exp1, exp2)) end
)
 in (LrTable.NT 26,(result,exp1left,exp2right),rest671) end
| (70,(_,(MlyValue.exp exp2,_,exp2right))::_::(_,(MlyValue.exp exp1,
exp1left,_))::rest671) => let val result=MlyValue.exp(fn _ => let val 
exp1=exp1 ()
val exp2=exp2 ()
 in ( ORELSEExp(I(exp1left,exp2right), exp1, exp2) ) end
)
 in (LrTable.NT 26,(result,exp1left,exp2right),rest671) end
| (71,(_,(MlyValue.match match1,_,matchright as match1right))::_::(_,(
MlyValue.exp exp1,expleft as exp1left,_))::rest671) => let val result=
MlyValue.exp(fn _ => let val exp as exp1=exp1 ()
val match as match1=match1 ()
 in ( HANDLEExp(I(expleft,matchright), exp, match) ) end
)
 in (LrTable.NT 26,(result,exp1left,match1right),rest671) end
| (72,(_,(MlyValue.exp exp1,_,expright as exp1right))::(_,(_,RAISEleft
 as RAISE1left,_))::rest671) => let val result=MlyValue.exp(fn _ => 
let val exp as exp1=exp1 ()
 in ( RAISEExp(I(RAISEleft,expright), exp) ) end
)
 in (LrTable.NT 26,(result,RAISE1left,exp1right),rest671) end
| (73,(_,(MlyValue.exp exp3,_,exp3right))::_::(_,(MlyValue.exp exp2,_,
_))::_::(_,(MlyValue.exp exp1,_,_))::(_,(_,IFleft as IF1left,_))::
rest671) => let val result=MlyValue.exp(fn _ => let val exp1=exp1 ()
val exp2=exp2 ()
val exp3=exp3 ()
 in ( IFExp(I(IFleft,exp3right), exp1, exp2, exp3) ) end
)
 in (LrTable.NT 26,(result,IF1left,exp3right),rest671) end
| (74,(_,(MlyValue.exp exp2,_,exp2right))::_::(_,(MlyValue.exp exp1,_,
_))::(_,(_,WHILEleft as WHILE1left,_))::rest671) => let val result=
MlyValue.exp(fn _ => let val exp1=exp1 ()
val exp2=exp2 ()
 in ( WHILEExp(I(WHILEleft,exp2right), exp1, exp2) ) end
)
 in (LrTable.NT 26,(result,WHILE1left,exp2right),rest671) end
| (75,(_,(MlyValue.match match1,_,matchright as match1right))::_::(_,(
MlyValue.exp exp1,_,_))::(_,(_,CASEleft as CASE1left,_))::rest671) => 
let val result=MlyValue.exp(fn _ => let val exp as exp1=exp1 ()
val match as match1=match1 ()
 in ( CASEExp(I(CASEleft,matchright), exp, match) ) end
)
 in (LrTable.NT 26,(result,CASE1left,match1right),rest671) end
| (76,(_,(MlyValue.match match1,_,matchright as match1right))::(_,(_,
FNleft as FN1left,_))::rest671) => let val result=MlyValue.exp(fn _
 => let val match as match1=match1 ()
 in ( FNExp(I(FNleft,matchright), match) ) end
)
 in (LrTable.NT 26,(result,FN1left,match1right),rest671) end
| (77,(_,(MlyValue.exp exp1,_,expright as exp1right))::_::(_,(
MlyValue.pat pat1,_,_))::(_,(_,RECleft as REC1left,_))::rest671) => 
let val result=MlyValue.exp(fn _ => let val pat as pat1=pat1 ()
val exp as exp1=exp1 ()
 in ( RECExp(I(RECleft,expright), pat, exp) ) end
)
 in (LrTable.NT 26,(result,REC1left,exp1right),rest671) end
| (78,(_,(MlyValue.longstrid longstrid1,_,longstridright as 
longstrid1right))::(_,(_,PACKleft as PACK1left,_))::rest671) => let 
val result=MlyValue.exp(fn _ => let val longstrid as longstrid1=
longstrid1 ()
 in ( PACKExp(I(PACKleft,longstridright),
					  longstrid) ) end
)
 in (LrTable.NT 26,(result,PACK1left,longstrid1right),rest671) end
| (79,(_,(MlyValue.BAR_match_opt BAR_match_opt1,_,BAR_match_optright
 as BAR_match_opt1right))::(_,(MlyValue.mrule mrule1,mruleleft as 
mrule1left,_))::rest671) => let val result=MlyValue.match(fn _ => let 
val mrule as mrule1=mrule1 ()
val BAR_match_opt as BAR_match_opt1=BAR_match_opt1 ()
 in (
 Match(I(mruleleft,BAR_match_optright),
					mrule, BAR_match_opt) )
 end
)
 in (LrTable.NT 27,(result,mrule1left,BAR_match_opt1right),rest671)
 end
| (80,(_,(MlyValue.match match1,_,match1right))::(_,(_,BAR1left,_))::
rest671) => let val result=MlyValue.BAR_match_opt(fn _ => let val 
match as match1=match1 ()
 in ( SOME match ) end
)
 in (LrTable.NT 28,(result,BAR1left,match1right),rest671) end
| (81,rest671) => let val result=MlyValue.BAR_match_opt(fn _ => (
 NONE ))
 in (LrTable.NT 28,(result,defaultPos,defaultPos),rest671) end
| (82,(_,(MlyValue.exp exp1,_,expright as exp1right))::_::(_,(
MlyValue.pat pat1,patleft as pat1left,_))::rest671) => let val result=
MlyValue.mrule(fn _ => let val pat as pat1=pat1 ()
val exp as exp1=exp1 ()
 in ( Mrule(I(patleft,expright), pat, exp) ) end
)
 in (LrTable.NT 29,(result,pat1left,exp1right),rest671) end
| (83,(_,(MlyValue.dec1 dec11,dec11left,dec11right))::rest671) => let 
val result=MlyValue.dec(fn _ => let val dec1 as dec11=dec11 ()
 in ( dec1 ) end
)
 in (LrTable.NT 30,(result,dec11left,dec11right),rest671) end
| (84,rest671) => let val result=MlyValue.dec(fn _ => (
 EMPTYDec(I(defaultPos,defaultPos)) ))
 in (LrTable.NT 30,(result,defaultPos,defaultPos),rest671) end
| (85,(_,(MlyValue.dec1' dec1'1,dec1'1left,dec1'1right))::rest671) => 
let val result=MlyValue.dec'(fn _ => let val dec1' as dec1'1=dec1'1 ()
 in ( dec1' ) end
)
 in (LrTable.NT 31,(result,dec1'1left,dec1'1right),rest671) end
| (86,(_,(MlyValue.dec' dec'2,_,dec'2right))::(_,(MlyValue.dec' dec'1,
dec'1left,_))::rest671) => let val result=MlyValue.dec'(fn _ => let 
val dec'1=dec'1 ()
val dec'2=dec'2 ()
 in ( SEQDec(I(dec'1left,dec'2right), dec'1, dec'2) ) end
)
 in (LrTable.NT 31,(result,dec'1left,dec'2right),rest671) end
| (87,(_,(MlyValue.dec1' dec1'1,dec1'1left,dec1'1right))::rest671) => 
let val result=MlyValue.dec1(fn _ => let val dec1' as dec1'1=dec1'1 ()
 in ( dec1' ) end
)
 in (LrTable.NT 32,(result,dec1'1left,dec1'1right),rest671) end
| (88,(_,(_,SEMICOLONleft as SEMICOLON1left,SEMICOLON1right))::rest671
) => let val result=MlyValue.dec1(fn _ => (
 EMPTYDec(I(SEMICOLONleft,SEMICOLONleft)) ))
 in (LrTable.NT 32,(result,SEMICOLON1left,SEMICOLON1right),rest671)
 end
| (89,(_,(MlyValue.dec1 dec12,_,dec12right))::(_,(MlyValue.dec1 dec11,
dec11left,_))::rest671) => let val result=MlyValue.dec1(fn _ => let 
val dec11=dec11 ()
val dec12=dec12 ()
 in ( SEQDec(I(dec11left,dec12right), dec11, dec12) ) end
)
 in (LrTable.NT 32,(result,dec11left,dec12right),rest671) end
| (90,(_,(MlyValue.dec1'' dec1''1,dec1''1left,dec1''1right))::rest671)
 => let val result=MlyValue.dec1'(fn _ => let val dec1'' as dec1''1=
dec1''1 ()
 in ( dec1'' ) end
)
 in (LrTable.NT 33,(result,dec1''1left,dec1''1right),rest671) end
| (91,(_,(_,_,ENDright as END1right))::(_,(MlyValue.dec dec2,_,_))::_
::(_,(MlyValue.dec dec1,_,_))::(_,(_,LOCALleft as LOCAL1left,_))::
rest671) => let val result=MlyValue.dec1'(fn _ => let val dec1=dec1 ()
val dec2=dec2 ()
 in ( LOCALDec(I(LOCALleft,ENDright), dec1, dec2) ) end
)
 in (LrTable.NT 33,(result,LOCAL1left,END1right),rest671) end
| (92,(_,(MlyValue.valbind valbind1,_,valbindright as valbind1right))
::(_,(_,VALleft as VAL1left,_))::rest671) => let val result=
MlyValue.dec1''(fn _ => let val valbind as valbind1=valbind1 ()
 in (
 VALDec(I(VALleft,valbindright),
				 Seq(I(defaultPos,defaultPos), []), valbind) 
) end
)
 in (LrTable.NT 34,(result,VAL1left,valbind1right),rest671) end
| (93,(_,(MlyValue.valbind valbind1,_,valbindright as valbind1right))
::(_,(MlyValue.tyvarseq1 tyvarseq11,_,_))::(_,(_,VALleft as VAL1left,_
))::rest671) => let val result=MlyValue.dec1''(fn _ => let val 
tyvarseq1 as tyvarseq11=tyvarseq11 ()
val valbind as valbind1=valbind1 ()
 in ( VALDec(I(VALleft,valbindright), tyvarseq1, valbind) ) end
)
 in (LrTable.NT 34,(result,VAL1left,valbind1right),rest671) end
| (94,(_,(MlyValue.fvalbind fvalbind1,_,fvalbindright as 
fvalbind1right))::(_,(_,FUNleft as FUN1left,_))::rest671) => let val 
result=MlyValue.dec1''(fn _ => let val fvalbind as fvalbind1=fvalbind1
 ()
 in (
 FUNDec(I(FUNleft,fvalbindright),
				 Seq(I(defaultPos,defaultPos), []), fvalbind) 
) end
)
 in (LrTable.NT 34,(result,FUN1left,fvalbind1right),rest671) end
| (95,(_,(MlyValue.fvalbind fvalbind1,_,fvalbindright as 
fvalbind1right))::(_,(MlyValue.tyvarseq1 tyvarseq11,_,_))::(_,(_,
FUNleft as FUN1left,_))::rest671) => let val result=MlyValue.dec1''(
fn _ => let val tyvarseq1 as tyvarseq11=tyvarseq11 ()
val fvalbind as fvalbind1=fvalbind1 ()
 in ( FUNDec(I(FUNleft,fvalbindright), tyvarseq1, fvalbind)) end
)
 in (LrTable.NT 34,(result,FUN1left,fvalbind1right),rest671) end
| (96,(_,(MlyValue.typbind typbind1,_,typbindright as typbind1right))
::(_,(_,TYPEleft as TYPE1left,_))::rest671) => let val result=
MlyValue.dec1''(fn _ => let val typbind as typbind1=typbind1 ()
 in ( TYPEDec(I(TYPEleft,typbindright), typbind) ) end
)
 in (LrTable.NT 34,(result,TYPE1left,typbind1right),rest671) end
| (97,(_,(MlyValue.typbind typbind1,_,typbindright as typbind1right))
::(_,(_,EQTYPEleft as EQTYPE1left,_))::rest671) => let val result=
MlyValue.dec1''(fn _ => let val typbind as typbind1=typbind1 ()
 in ( EQTYPEDec(I(EQTYPEleft,typbindright), typbind) ) end
)
 in (LrTable.NT 34,(result,EQTYPE1left,typbind1right),rest671) end
| (98,(_,(MlyValue.typbind typbind1,_,typbindright as typbind1right))
::(_,(_,EQEQTYPEleft as EQEQTYPE1left,_))::rest671) => let val result=
MlyValue.dec1''(fn _ => let val typbind as typbind1=typbind1 ()
 in ( EQEQTYPEDec(I(EQEQTYPEleft,typbindright), typbind) ) end
)
 in (LrTable.NT 34,(result,EQEQTYPE1left,typbind1right),rest671) end
| (99,(_,(MlyValue.WITHTYPE_typbind_opt WITHTYPE_typbind_opt1,_,
WITHTYPE_typbind_optright as WITHTYPE_typbind_opt1right))::(_,(
MlyValue.datbind0 datbind01,_,_))::(_,(_,DATATYPEleft as DATATYPE1left
,_))::rest671) => let val result=MlyValue.dec1''(fn _ => let val 
datbind0 as datbind01=datbind01 ()
val WITHTYPE_typbind_opt as WITHTYPE_typbind_opt1=
WITHTYPE_typbind_opt1 ()
 in (
 DATATYPEDec(I(DATATYPEleft,WITHTYPE_typbind_optright),
				      datbind0, WITHTYPE_typbind_opt) 
) end
)
 in (LrTable.NT 34,(result,DATATYPE1left,WITHTYPE_typbind_opt1right),
rest671) end
| (100,(_,(MlyValue.WITHTYPE_typbind_opt WITHTYPE_typbind_opt1,_,
WITHTYPE_typbind_optright as WITHTYPE_typbind_opt1right))::(_,(
MlyValue.datbind1 datbind11,_,_))::(_,(_,DATATYPEleft as DATATYPE1left
,_))::rest671) => let val result=MlyValue.dec1''(fn _ => let val 
datbind1 as datbind11=datbind11 ()
val WITHTYPE_typbind_opt as WITHTYPE_typbind_opt1=
WITHTYPE_typbind_opt1 ()
 in (
 DATATYPEDec(I(DATATYPEleft,WITHTYPE_typbind_optright),
				      datbind1, WITHTYPE_typbind_opt) 
) end
)
 in (LrTable.NT 34,(result,DATATYPE1left,WITHTYPE_typbind_opt1right),
rest671) end
| (101,(_,(MlyValue.longtycon longtycon1,_,longtyconright as 
longtycon1right))::_::_::(_,(MlyValue.tycon tycon1,_,_))::(_,(_,
DATATYPEleft as DATATYPE1left,_))::rest671) => let val result=
MlyValue.dec1''(fn _ => let val tycon as tycon1=tycon1 ()
val longtycon as longtycon1=longtycon1 ()
 in (
 REPLICATIONDec(I(DATATYPEleft,longtyconright),
					 tycon, longtycon) 
) end
)
 in (LrTable.NT 34,(result,DATATYPE1left,longtycon1right),rest671) end
| (102,(_,(_,_,ENDright as END1right))::(_,(MlyValue.dec dec1,_,_))::_
::(_,(MlyValue.WITHTYPE_typbind_opt WITHTYPE_typbind_opt1,_,_))::(_,(
MlyValue.datbind datbind1,_,_))::(_,(_,ABSTYPEleft as ABSTYPE1left,_))
::rest671) => let val result=MlyValue.dec1''(fn _ => let val datbind
 as datbind1=datbind1 ()
val WITHTYPE_typbind_opt as WITHTYPE_typbind_opt1=
WITHTYPE_typbind_opt1 ()
val dec as dec1=dec1 ()
 in (
 ABSTYPEDec(I(ABSTYPEleft,ENDright), datbind,
				     WITHTYPE_typbind_opt, dec) 
) end
)
 in (LrTable.NT 34,(result,ABSTYPE1left,END1right),rest671) end
| (103,(_,(MlyValue.dconbind dconbind1,_,dconbindright as 
dconbind1right))::(_,(_,CONSTRUCTORleft as CONSTRUCTOR1left,_))::
rest671) => let val result=MlyValue.dec1''(fn _ => let val dconbind
 as dconbind1=dconbind1 ()
 in (
 CONSTRUCTORDec(I(CONSTRUCTORleft,dconbindright),
					 dconbind) )
 end
)
 in (LrTable.NT 34,(result,CONSTRUCTOR1left,dconbind1right),rest671)
 end
| (104,(_,(MlyValue.exbind exbind1,_,exbindright as exbind1right))::(_
,(_,EXCEPTIONleft as EXCEPTION1left,_))::rest671) => let val result=
MlyValue.dec1''(fn _ => let val exbind as exbind1=exbind1 ()
 in ( EXCEPTIONDec(I(EXCEPTIONleft,exbindright), exbind) ) end
)
 in (LrTable.NT 34,(result,EXCEPTION1left,exbind1right),rest671) end
| (105,(_,(MlyValue.strbind strbind1,_,strbindright as strbind1right))
::(_,(_,STRUCTUREleft as STRUCTURE1left,_))::rest671) => let val 
result=MlyValue.dec1''(fn _ => let val strbind as strbind1=strbind1 ()
 in ( STRUCTUREDec(I(STRUCTUREleft,strbindright), strbind) ) end
)
 in (LrTable.NT 34,(result,STRUCTURE1left,strbind1right),rest671) end
| (106,(_,(MlyValue.sigbind sigbind1,_,sigbindright as sigbind1right))
::(_,(_,SIGNATUREleft as SIGNATURE1left,_))::rest671) => let val 
result=MlyValue.dec1''(fn _ => let val sigbind as sigbind1=sigbind1 ()
 in ( SIGNATUREDec(I(SIGNATUREleft,sigbindright), sigbind) ) end
)
 in (LrTable.NT 34,(result,SIGNATURE1left,sigbind1right),rest671) end
| (107,(_,(MlyValue.funbind funbind1,_,funbindright as funbind1right))
::(_,(_,FUNCTORleft as FUNCTOR1left,_))::rest671) => let val result=
MlyValue.dec1''(fn _ => let val funbind as funbind1=funbind1 ()
 in ( FUNCTORDec(I(FUNCTORleft,funbindright), funbind) ) end
)
 in (LrTable.NT 34,(result,FUNCTOR1left,funbind1right),rest671) end
| (108,(_,(MlyValue.longstrid_list1 longstrid_list11,_,
longstrid_list1right as longstrid_list11right))::(_,(_,OPENleft as 
OPEN1left,_))::rest671) => let val result=MlyValue.dec1''(fn _ => let 
val longstrid_list1 as longstrid_list11=longstrid_list11 ()
 in (
 OPENMULTIDec(I(OPENleft,longstrid_list1right),
				       longstrid_list1) 
) end
)
 in (LrTable.NT 34,(result,OPEN1left,longstrid_list11right),rest671)
 end
| (109,(_,(MlyValue.strid strid1,_,stridright as strid1right))::(_,(_,
PREBOUNDleft as PREBOUND1left,_))::rest671) => let val result=
MlyValue.dec1''(fn _ => let val strid as strid1=strid1 ()
 in ( PREBOUNDDec(I(PREBOUNDleft,stridright), strid) ) end
)
 in (LrTable.NT 34,(result,PREBOUND1left,strid1right),rest671) end
| (110,(_,(MlyValue.STRING STRING1,_,STRINGright as STRING1right))::_
::(_,(MlyValue.ty ty1,_,_))::_::(_,(MlyValue.vid vid1,_,_))::(_,(
MlyValue.OP_opt OP_opt1,_,_))::_::(_,(_,PRIMITIVEleft as 
PRIMITIVE1left,_))::rest671) => let val result=MlyValue.dec1''(fn _
 => let val OP_opt as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val ty as ty1=ty1 ()
val STRING as STRING1=STRING1 ()
 in (
 PRIMITIVEVALDec(I(PRIMITIVEleft,STRINGright),
					  OP_opt, vid, ty, STRING) 
) end
)
 in (LrTable.NT 34,(result,PRIMITIVE1left,STRING1right),rest671) end
| (111,(_,(MlyValue.STRING STRING1,_,STRINGright as STRING1right))::_
::(_,(MlyValue.longtycon longtycon1,_,_))::(_,(MlyValue.tyvarseq 
tyvarseq1,_,_))::_::(_,(MlyValue.OF_ty_opt OF_ty_opt1,_,_))::(_,(
MlyValue.vid vid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::_::(_,(_,
PRIMITIVEleft as PRIMITIVE1left,_))::rest671) => let val result=
MlyValue.dec1''(fn _ => let val OP_opt as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val OF_ty_opt as OF_ty_opt1=OF_ty_opt1 ()
val tyvarseq as tyvarseq1=tyvarseq1 ()
val longtycon as longtycon1=longtycon1 ()
val STRING as STRING1=STRING1 ()
 in (
 PRIMITIVECONSTRUCTORDec(I(PRIMITIVEleft,STRINGright),
						  OP_opt, vid, OF_ty_opt,
						  tyvarseq, longtycon, STRING) 
) end
)
 in (LrTable.NT 34,(result,PRIMITIVE1left,STRING1right),rest671) end
| (112,(_,(MlyValue.STRING STRING1,_,STRINGright as STRING1right))::_
::(_,(MlyValue.sigexp sigexp1,_,_))::_::(_,(MlyValue.strid strid1,_,_)
)::_::(_,(_,PRIMITIVEleft as PRIMITIVE1left,_))::rest671) => let val 
result=MlyValue.dec1''(fn _ => let val strid as strid1=strid1 ()
val sigexp as sigexp1=sigexp1 ()
val STRING as STRING1=STRING1 ()
 in (
 PRIMITIVESTRUCTUREDec(I(PRIMITIVEleft,STRINGright),
						strid, sigexp, STRING) 
) end
)
 in (LrTable.NT 34,(result,PRIMITIVE1left,STRING1right),rest671) end
| (113,(_,(MlyValue.ty ty1,_,tyright as ty1right))::_::(_,(
MlyValue.tyvar tyvar1,_,_))::_::(_,(MlyValue.vid vid1,_,_))::(_,(
MlyValue.OP_opt OP_opt1,_,_))::(_,(_,OVERLOADleft as OVERLOAD1left,_))
::rest671) => let val result=MlyValue.dec1''(fn _ => let val OP_opt
 as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val tyvar as tyvar1=tyvar1 ()
val ty as ty1=ty1 ()
 in (
 OVERLOADDec(I(OVERLOADleft,tyright),
				      OP_opt, vid, tyvar, ty) 
) end
)
 in (LrTable.NT 34,(result,OVERLOAD1left,ty1right),rest671) end
| (114,(_,(MlyValue.longvid longvid1,_,longvidright as longvid1right))
::_::(_,(MlyValue.longtycon longtycon1,_,_))::_::(_,(MlyValue.vid vid1
,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,INSTANCEleft as 
INSTANCE1left,_))::rest671) => let val result=MlyValue.dec1''(fn _ => 
let val OP_opt as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val longtycon as longtycon1=longtycon1 ()
val longvid as longvid1=longvid1 ()
 in (
 INSTANCEDec(I(INSTANCEleft,longvidright),
				      OP_opt, vid, longtycon, longvid) 
) end
)
 in (LrTable.NT 34,(result,INSTANCE1left,longvid1right),rest671) end
| (115,(_,(MlyValue.longtycon longtycon1,_,longtyconright as 
longtycon1right))::_::(_,(MlyValue.scon scon1,_,_))::(_,(_,
INSTANCEleft as INSTANCE1left,_))::rest671) => let val result=
MlyValue.dec1''(fn _ => let val scon as scon1=scon1 ()
val longtycon as longtycon1=longtycon1 ()
 in (
 INSTANCESCONDec(I(INSTANCEleft,longtyconright),
					  scon, longtycon) 
) end
)
 in (LrTable.NT 34,(result,INSTANCE1left,longtycon1right),rest671) end
| (116,(_,(MlyValue.vid_list1 vid_list11,_,vid_list1right as 
vid_list11right))::(_,(MlyValue.d_opt d_opt1,_,_))::(_,(_,INFIXleft
 as INFIX1left,_))::rest671) => let val result=MlyValue.dec1''(fn _
 => let val d_opt as d_opt1=d_opt1 ()
val vid_list1 as vid_list11=vid_list11 ()
 in (
 INFIXMULTIDec(I(INFIXleft,vid_list1right),
					d_opt, vid_list1) )
 end
)
 in (LrTable.NT 34,(result,INFIX1left,vid_list11right),rest671) end
| (117,(_,(MlyValue.vid_list1 vid_list11,_,vid_list1right as 
vid_list11right))::(_,(MlyValue.d_opt d_opt1,_,_))::(_,(_,INFIXRleft
 as INFIXR1left,_))::rest671) => let val result=MlyValue.dec1''(fn _
 => let val d_opt as d_opt1=d_opt1 ()
val vid_list1 as vid_list11=vid_list11 ()
 in (
 INFIXRMULTIDec(I(INFIXRleft,vid_list1right),
					 d_opt, vid_list1) 
) end
)
 in (LrTable.NT 34,(result,INFIXR1left,vid_list11right),rest671) end
| (118,(_,(MlyValue.vid_list1 vid_list11,_,vid_list1right as 
vid_list11right))::(_,(_,NONFIXleft as NONFIX1left,_))::rest671) => 
let val result=MlyValue.dec1''(fn _ => let val vid_list1 as vid_list11
=vid_list11 ()
 in ( NONFIXMULTIDec(I(NONFIXleft,vid_list1right),
					 vid_list1) )
 end
)
 in (LrTable.NT 34,(result,NONFIX1left,vid_list11right),rest671) end
| (119,(_,(MlyValue.typbind typbind1,_,typbind1right))::(_,(_,
WITHTYPE1left,_))::rest671) => let val result=
MlyValue.WITHTYPE_typbind_opt(fn _ => let val typbind as typbind1=
typbind1 ()
 in ( SOME typbind ) end
)
 in (LrTable.NT 35,(result,WITHTYPE1left,typbind1right),rest671) end
| (120,rest671) => let val result=MlyValue.WITHTYPE_typbind_opt(fn _
 => ( NONE ))
 in (LrTable.NT 35,(result,defaultPos,defaultPos),rest671) end
| (121,(_,(MlyValue.vid_list1 vid_list11,_,vid_list11right))::(_,(
MlyValue.vid vid1,vid1left,_))::rest671) => let val result=
MlyValue.vid_list1(fn _ => let val vid as vid1=vid1 ()
val vid_list1 as vid_list11=vid_list11 ()
 in ( vid::vid_list1 ) end
)
 in (LrTable.NT 36,(result,vid1left,vid_list11right),rest671) end
| (122,(_,(MlyValue.vid vid1,vid1left,vid1right))::rest671) => let 
val result=MlyValue.vid_list1(fn _ => let val vid as vid1=vid1 ()
 in ( vid::[] ) end
)
 in (LrTable.NT 36,(result,vid1left,vid1right),rest671) end
| (123,(_,(MlyValue.longstrid_list1 longstrid_list11,_,
longstrid_list11right))::(_,(MlyValue.longstrid longstrid1,
longstrid1left,_))::rest671) => let val result=
MlyValue.longstrid_list1(fn _ => let val longstrid as longstrid1=
longstrid1 ()
val longstrid_list1 as longstrid_list11=longstrid_list11 ()
 in ( longstrid::longstrid_list1 ) end
)
 in (LrTable.NT 37,(result,longstrid1left,longstrid_list11right),
rest671) end
| (124,(_,(MlyValue.longstrid longstrid1,longstrid1left,
longstrid1right))::rest671) => let val result=MlyValue.longstrid_list1
(fn _ => let val longstrid as longstrid1=longstrid1 ()
 in ( longstrid::[] ) end
)
 in (LrTable.NT 37,(result,longstrid1left,longstrid1right),rest671)
 end
| (125,(_,(MlyValue.d d1,d1left,d1right))::rest671) => let val result=
MlyValue.d_opt(fn _ => let val d as d1=d1 ()
 in ( SOME d ) end
)
 in (LrTable.NT 38,(result,d1left,d1right),rest671) end
| (126,rest671) => let val result=MlyValue.d_opt(fn _ => ( NONE ))
 in (LrTable.NT 38,(result,defaultPos,defaultPos),rest671) end
| (127,(_,(MlyValue.AND_valbind_opt AND_valbind_opt1,_,
AND_valbind_optright as AND_valbind_opt1right))::(_,(MlyValue.exp exp1
,_,_))::_::(_,(MlyValue.pat pat1,patleft as pat1left,_))::rest671) => 
let val result=MlyValue.valbind(fn _ => let val pat as pat1=pat1 ()
val exp as exp1=exp1 ()
val AND_valbind_opt as AND_valbind_opt1=AND_valbind_opt1 ()
 in (
 PLAINValBind(I(patleft,AND_valbind_optright),
				       pat, exp, AND_valbind_opt) 
) end
)
 in (LrTable.NT 39,(result,pat1left,AND_valbind_opt1right),rest671)
 end
| (128,(_,(MlyValue.valbind valbind1,_,valbindright as valbind1right))
::(_,(_,RECleft as REC1left,_))::rest671) => let val result=
MlyValue.valbind(fn _ => let val valbind as valbind1=valbind1 ()
 in ( RECValBind(I(RECleft,valbindright), valbind) ) end
)
 in (LrTable.NT 39,(result,REC1left,valbind1right),rest671) end
| (129,(_,(MlyValue.valbind valbind1,_,valbind1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_valbind_opt(fn _ => let 
val valbind as valbind1=valbind1 ()
 in ( SOME valbind ) end
)
 in (LrTable.NT 40,(result,AND1left,valbind1right),rest671) end
| (130,rest671) => let val result=MlyValue.AND_valbind_opt(fn _ => (
 NONE ))
 in (LrTable.NT 40,(result,defaultPos,defaultPos),rest671) end
| (131,(_,(MlyValue.AND_fvalbind_opt AND_fvalbind_opt1,_,
AND_fvalbind_optright as AND_fvalbind_opt1right))::(_,(MlyValue.fmatch
 fmatch1,fmatchleft as fmatch1left,_))::rest671) => let val result=
MlyValue.fvalbind(fn _ => let val fmatch as fmatch1=fmatch1 ()
val AND_fvalbind_opt as AND_fvalbind_opt1=AND_fvalbind_opt1 ()
 in (
 FvalBind(I(fmatchleft,AND_fvalbind_optright),
				     fmatch, AND_fvalbind_opt) 
) end
)
 in (LrTable.NT 41,(result,fmatch1left,AND_fvalbind_opt1right),rest671
) end
| (132,(_,(MlyValue.fvalbind fvalbind1,_,fvalbind1right))::(_,(_,
AND1left,_))::rest671) => let val result=MlyValue.AND_fvalbind_opt(fn 
_ => let val fvalbind as fvalbind1=fvalbind1 ()
 in ( SOME fvalbind ) end
)
 in (LrTable.NT 42,(result,AND1left,fvalbind1right),rest671) end
| (133,rest671) => let val result=MlyValue.AND_fvalbind_opt(fn _ => (
 NONE ))
 in (LrTable.NT 42,(result,defaultPos,defaultPos),rest671) end
| (134,(_,(MlyValue.BAR_fmatch_opt BAR_fmatch_opt1,_,
BAR_fmatch_optright as BAR_fmatch_opt1right))::(_,(MlyValue.fmrule 
fmrule1,fmruleleft as fmrule1left,_))::rest671) => let val result=
MlyValue.fmatch(fn _ => let val fmrule as fmrule1=fmrule1 ()
val BAR_fmatch_opt as BAR_fmatch_opt1=BAR_fmatch_opt1 ()
 in (
 Fmatch(I(fmruleleft,BAR_fmatch_optright),
				 fmrule, BAR_fmatch_opt) 
) end
)
 in (LrTable.NT 43,(result,fmrule1left,BAR_fmatch_opt1right),rest671)
 end
| (135,(_,(MlyValue.fmatch fmatch1,_,fmatch1right))::(_,(_,BAR1left,_)
)::rest671) => let val result=MlyValue.BAR_fmatch_opt(fn _ => let val 
fmatch as fmatch1=fmatch1 ()
 in ( SOME fmatch ) end
)
 in (LrTable.NT 44,(result,BAR1left,fmatch1right),rest671) end
| (136,rest671) => let val result=MlyValue.BAR_fmatch_opt(fn _ => (
 NONE ))
 in (LrTable.NT 44,(result,defaultPos,defaultPos),rest671) end
| (137,(_,(MlyValue.exp exp1,_,expright as exp1right))::_::(_,(
MlyValue.fpat fpat1,fpatleft as fpat1left,_))::rest671) => let val 
result=MlyValue.fmrule(fn _ => let val fpat as fpat1=fpat1 ()
val exp as exp1=exp1 ()
 in ( Fmrule(I(fpatleft,expright), fpat, exp) ) end
)
 in (LrTable.NT 45,(result,fpat1left,exp1right),rest671) end
| (138,(_,(MlyValue.pat pat1,pat1left,pat1right))::rest671) => let 
val result=MlyValue.fpat(fn _ => let val pat as pat1=pat1 ()
 in ( pat ) end
)
 in (LrTable.NT 46,(result,pat1left,pat1right),rest671) end
| (139,(_,(MlyValue.AND_typbind_opt AND_typbind_opt1,_,
AND_typbind_optright as AND_typbind_opt1right))::(_,(MlyValue.tycon 
tycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1,tyvarseqleft as 
tyvarseq1left,_))::rest671) => let val result=MlyValue.typbind(fn _
 => let val tyvarseq as tyvarseq1=tyvarseq1 ()
val tycon as tycon1=tycon1 ()
val AND_typbind_opt as AND_typbind_opt1=AND_typbind_opt1 ()
 in (
 NEWTypBind(I(tyvarseqleft,AND_typbind_optright),
				     tyvarseq, tycon, AND_typbind_opt) 
) end
)
 in (LrTable.NT 47,(result,tyvarseq1left,AND_typbind_opt1right),
rest671) end
| (140,(_,(MlyValue.AND_typbind_opt AND_typbind_opt1,_,
AND_typbind_optright as AND_typbind_opt1right))::(_,(MlyValue.ty ty1,_
,_))::_::(_,(MlyValue.tycon tycon1,_,_))::(_,(MlyValue.tyvarseq 
tyvarseq1,tyvarseqleft as tyvarseq1left,_))::rest671) => let val 
result=MlyValue.typbind(fn _ => let val tyvarseq as tyvarseq1=
tyvarseq1 ()
val tycon as tycon1=tycon1 ()
val ty as ty1=ty1 ()
val AND_typbind_opt as AND_typbind_opt1=AND_typbind_opt1 ()
 in (
 EQUALTypBind(I(tyvarseqleft,AND_typbind_optright),
				  tyvarseq, tycon, ty, AND_typbind_opt) 
) end
)
 in (LrTable.NT 47,(result,tyvarseq1left,AND_typbind_opt1right),
rest671) end
| (141,(_,(MlyValue.typbind typbind1,_,typbind1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_typbind_opt(fn _ => let 
val typbind as typbind1=typbind1 ()
 in ( SOME typbind ) end
)
 in (LrTable.NT 48,(result,AND1left,typbind1right),rest671) end
| (142,rest671) => let val result=MlyValue.AND_typbind_opt(fn _ => (
 NONE ))
 in (LrTable.NT 48,(result,defaultPos,defaultPos),rest671) end
| (143,(_,(MlyValue.AND_datbind_opt AND_datbind_opt1,_,
AND_datbind_optright as AND_datbind_opt1right))::(_,(MlyValue.tycon 
tycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1,tyvarseqleft as 
tyvarseq1left,_))::rest671) => let val result=MlyValue.datbind(fn _
 => let val tyvarseq as tyvarseq1=tyvarseq1 ()
val tycon as tycon1=tycon1 ()
val AND_datbind_opt as AND_datbind_opt1=AND_datbind_opt1 ()
 in (
 OPENDatBind(I(tyvarseqleft,AND_datbind_optright),
				      tyvarseq, tycon, AND_datbind_opt) 
) end
)
 in (LrTable.NT 49,(result,tyvarseq1left,AND_datbind_opt1right),
rest671) end
| (144,(_,(MlyValue.AND_datbind_opt AND_datbind_opt1,_,
AND_datbind_optright as AND_datbind_opt1right))::(_,(MlyValue.conbind 
conbind1,_,_))::_::(_,(MlyValue.tycon tycon1,_,_))::(_,(
MlyValue.tyvarseq tyvarseq1,tyvarseqleft as tyvarseq1left,_))::rest671
) => let val result=MlyValue.datbind(fn _ => let val tyvarseq as 
tyvarseq1=tyvarseq1 ()
val tycon as tycon1=tycon1 ()
val conbind as conbind1=conbind1 ()
val AND_datbind_opt as AND_datbind_opt1=AND_datbind_opt1 ()
 in (
 CLOSEDDatBind(I(tyvarseqleft,AND_datbind_optright),
					tyvarseq, tycon, conbind,
					AND_datbind_opt)
) end
)
 in (LrTable.NT 49,(result,tyvarseq1left,AND_datbind_opt1right),
rest671) end
| (145,(_,(MlyValue.AND_datbind_opt AND_datbind_opt1,_,
AND_datbind_optright as AND_datbind_opt1right))::(_,(MlyValue.tycon 
tycon1,tyconleft as tycon1left,_))::rest671) => let val result=
MlyValue.datbind0(fn _ => let val tycon as tycon1=tycon1 ()
val AND_datbind_opt as AND_datbind_opt1=AND_datbind_opt1 ()
 in (
 OPENDatBind(I(tyconleft,AND_datbind_optright),
				      Seq(I(defaultPos,defaultPos), []),
				      tycon, AND_datbind_opt) 
) end
)
 in (LrTable.NT 50,(result,tycon1left,AND_datbind_opt1right),rest671)
 end
| (146,(_,(MlyValue.AND_datbind_opt AND_datbind_opt1,_,
AND_datbind_optright as AND_datbind_opt1right))::(_,(MlyValue.conbind 
conbind1,_,_))::_::(_,(MlyValue.tycon tycon1,tyconleft as tycon1left,_
))::rest671) => let val result=MlyValue.datbind0(fn _ => let val tycon
 as tycon1=tycon1 ()
val conbind as conbind1=conbind1 ()
val AND_datbind_opt as AND_datbind_opt1=AND_datbind_opt1 ()
 in (
 CLOSEDDatBind(I(tyconleft,AND_datbind_optright),
					Seq(I(defaultPos,defaultPos), []),
					tycon, conbind, AND_datbind_opt) 
) end
)
 in (LrTable.NT 50,(result,tycon1left,AND_datbind_opt1right),rest671)
 end
| (147,(_,(MlyValue.AND_datbind_opt AND_datbind_opt1,_,
AND_datbind_optright as AND_datbind_opt1right))::(_,(MlyValue.tycon 
tycon1,_,_))::(_,(MlyValue.tyvarseq1 tyvarseq11,tyvarseq1left as 
tyvarseq11left,_))::rest671) => let val result=MlyValue.datbind1(fn _
 => let val tyvarseq1 as tyvarseq11=tyvarseq11 ()
val tycon as tycon1=tycon1 ()
val AND_datbind_opt as AND_datbind_opt1=AND_datbind_opt1 ()
 in (
 OPENDatBind(I(tyvarseq1left,AND_datbind_optright),
				      tyvarseq1, tycon, AND_datbind_opt) 
) end
)
 in (LrTable.NT 51,(result,tyvarseq11left,AND_datbind_opt1right),
rest671) end
| (148,(_,(MlyValue.AND_datbind_opt AND_datbind_opt1,_,
AND_datbind_optright as AND_datbind_opt1right))::(_,(MlyValue.conbind 
conbind1,_,_))::_::(_,(MlyValue.tycon tycon1,_,_))::(_,(
MlyValue.tyvarseq1 tyvarseq11,tyvarseq1left as tyvarseq11left,_))::
rest671) => let val result=MlyValue.datbind1(fn _ => let val tyvarseq1
 as tyvarseq11=tyvarseq11 ()
val tycon as tycon1=tycon1 ()
val conbind as conbind1=conbind1 ()
val AND_datbind_opt as AND_datbind_opt1=AND_datbind_opt1 ()
 in (
 CLOSEDDatBind(I(tyvarseq1left,AND_datbind_optright),
					tyvarseq1, tycon, conbind,
					AND_datbind_opt) 
) end
)
 in (LrTable.NT 51,(result,tyvarseq11left,AND_datbind_opt1right),
rest671) end
| (149,(_,(MlyValue.datbind datbind1,_,datbind1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_datbind_opt(fn _ => let 
val datbind as datbind1=datbind1 ()
 in ( SOME datbind ) end
)
 in (LrTable.NT 52,(result,AND1left,datbind1right),rest671) end
| (150,rest671) => let val result=MlyValue.AND_datbind_opt(fn _ => (
 NONE ))
 in (LrTable.NT 52,(result,defaultPos,defaultPos),rest671) end
| (151,(_,(MlyValue.BAR_conbind_opt BAR_conbind_opt1,_,
BAR_conbind_optright as BAR_conbind_opt1right))::(_,(
MlyValue.OF_ty_opt OF_ty_opt1,_,_))::(_,(MlyValue.vid vid1,_,_))::(_,(
MlyValue.OP_opt OP_opt1,OP_optleft as OP_opt1left,_))::rest671) => 
let val result=MlyValue.conbind(fn _ => let val OP_opt as OP_opt1=
OP_opt1 ()
val vid as vid1=vid1 ()
val OF_ty_opt as OF_ty_opt1=OF_ty_opt1 ()
val BAR_conbind_opt as BAR_conbind_opt1=BAR_conbind_opt1 ()
 in (
 ConBind(I(OP_optleft,BAR_conbind_optright),
				  OP_opt, vid, OF_ty_opt, BAR_conbind_opt) 
) end
)
 in (LrTable.NT 53,(result,OP_opt1left,BAR_conbind_opt1right),rest671)
 end
| (152,(_,(MlyValue.conbind conbind1,_,conbind1right))::(_,(_,BAR1left
,_))::rest671) => let val result=MlyValue.BAR_conbind_opt(fn _ => let 
val conbind as conbind1=conbind1 ()
 in ( SOME conbind ) end
)
 in (LrTable.NT 54,(result,BAR1left,conbind1right),rest671) end
| (153,rest671) => let val result=MlyValue.BAR_conbind_opt(fn _ => (
 NONE ))
 in (LrTable.NT 54,(result,defaultPos,defaultPos),rest671) end
| (154,(_,(MlyValue.ty ty1,_,ty1right))::(_,(_,OF1left,_))::rest671)
 => let val result=MlyValue.OF_ty_opt(fn _ => let val ty as ty1=ty1 ()
 in ( SOME ty ) end
)
 in (LrTable.NT 55,(result,OF1left,ty1right),rest671) end
| (155,rest671) => let val result=MlyValue.OF_ty_opt(fn _ => ( NONE ))
 in (LrTable.NT 55,(result,defaultPos,defaultPos),rest671) end
| (156,(_,(MlyValue.AND_dconbind_opt AND_dconbind_opt1,_,
AND_dconbind_optright as AND_dconbind_opt1right))::(_,(
MlyValue.longtycon longtycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1,_
,_))::_::(_,(MlyValue.OF_ty_opt OF_ty_opt1,_,_))::(_,(MlyValue.vid 
vid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,OP_optleft as OP_opt1left,_))
::rest671) => let val result=MlyValue.dconbind(fn _ => let val OP_opt
 as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val OF_ty_opt as OF_ty_opt1=OF_ty_opt1 ()
val tyvarseq as tyvarseq1=tyvarseq1 ()
val longtycon as longtycon1=longtycon1 ()
val AND_dconbind_opt as AND_dconbind_opt1=AND_dconbind_opt1 ()
 in (
 NEWDconBind(I(OP_optleft,AND_dconbind_optright),
				      OP_opt, vid, OF_ty_opt, tyvarseq,
				      longtycon, AND_dconbind_opt) 
) end
)
 in (LrTable.NT 56,(result,OP_opt1left,AND_dconbind_opt1right),rest671
) end
| (157,(_,(MlyValue.AND_dconbind_opt AND_dconbind_opt1,_,
AND_dconbind_optright as AND_dconbind_opt1right))::(_,(
MlyValue.longvid longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_
::(_,(MlyValue.vid vid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,OP_opt1left
,_))::rest671) => let val result=MlyValue.dconbind(fn _ => let val 
OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val OP_opt2=OP_opt2 ()
val longvid as longvid1=longvid1 ()
val AND_dconbind_opt as AND_dconbind_opt1=AND_dconbind_opt1 ()
 in (
 EQUALDconBind(I(OP_opt1left,AND_dconbind_optright),
					OP_opt1, vid,
					OP_opt2, longvid, AND_dconbind_opt) 
) end
)
 in (LrTable.NT 56,(result,OP_opt1left,AND_dconbind_opt1right),rest671
) end
| (158,(_,(MlyValue.dconbind dconbind1,_,dconbind1right))::(_,(_,
AND1left,_))::rest671) => let val result=MlyValue.AND_dconbind_opt(fn 
_ => let val dconbind as dconbind1=dconbind1 ()
 in ( SOME dconbind ) end
)
 in (LrTable.NT 57,(result,AND1left,dconbind1right),rest671) end
| (159,rest671) => let val result=MlyValue.AND_dconbind_opt(fn _ => (
 NONE ))
 in (LrTable.NT 57,(result,defaultPos,defaultPos),rest671) end
| (160,(_,(MlyValue.AND_exbind_opt AND_exbind_opt1,_,
AND_exbind_optright as AND_exbind_opt1right))::(_,(MlyValue.OF_ty_opt 
OF_ty_opt1,_,_))::(_,(MlyValue.vid vid1,_,_))::(_,(MlyValue.OP_opt 
OP_opt1,OP_optleft as OP_opt1left,_))::rest671) => let val result=
MlyValue.exbind(fn _ => let val OP_opt as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val OF_ty_opt as OF_ty_opt1=OF_ty_opt1 ()
val AND_exbind_opt as AND_exbind_opt1=AND_exbind_opt1 ()
 in (
 NEWExBind(I(OP_optleft,AND_exbind_optright),
				    OP_opt, vid, OF_ty_opt, AND_exbind_opt) 
) end
)
 in (LrTable.NT 58,(result,OP_opt1left,AND_exbind_opt1right),rest671)
 end
| (161,(_,(MlyValue.AND_exbind_opt AND_exbind_opt1,_,
AND_exbind_optright as AND_exbind_opt1right))::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.vid
 vid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,OP_opt1left,_))::rest671) => 
let val result=MlyValue.exbind(fn _ => let val OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val OP_opt2=OP_opt2 ()
val longvid as longvid1=longvid1 ()
val AND_exbind_opt as AND_exbind_opt1=AND_exbind_opt1 ()
 in (
 EQUALExBind(I(OP_opt1left,AND_exbind_optright),
				      OP_opt1, vid,
				      OP_opt2, longvid, AND_exbind_opt) 
) end
)
 in (LrTable.NT 58,(result,OP_opt1left,AND_exbind_opt1right),rest671)
 end
| (162,(_,(MlyValue.exbind exbind1,_,exbind1right))::(_,(_,AND1left,_)
)::rest671) => let val result=MlyValue.AND_exbind_opt(fn _ => let val 
exbind as exbind1=exbind1 ()
 in ( SOME exbind ) end
)
 in (LrTable.NT 59,(result,AND1left,exbind1right),rest671) end
| (163,rest671) => let val result=MlyValue.AND_exbind_opt(fn _ => (
 NONE ))
 in (LrTable.NT 59,(result,defaultPos,defaultPos),rest671) end
| (164,(_,(_,UNDERBARleft as UNDERBAR1left,UNDERBARright as 
UNDERBAR1right))::rest671) => let val result=MlyValue.atpat(fn _ => (
 WILDCARDAtPat(I(UNDERBARleft,UNDERBARright)) ))
 in (LrTable.NT 60,(result,UNDERBAR1left,UNDERBAR1right),rest671) end
| (165,(_,(MlyValue.longvid' longvid'1,longvid'left as longvid'1left,
longvid'right as longvid'1right))::rest671) => let val result=
MlyValue.atpat(fn _ => let val longvid' as longvid'1=longvid'1 ()
 in (
 LONGVIDAtPat(I(longvid'left,longvid'right),
				       SANSOp, longvid') 
) end
)
 in (LrTable.NT 60,(result,longvid'1left,longvid'1right),rest671) end
| (166,(_,(MlyValue.longvid longvid1,_,longvidright as longvid1right))
::(_,(_,OPleft as OP1left,_))::rest671) => let val result=
MlyValue.atpat(fn _ => let val longvid as longvid1=longvid1 ()
 in (
 LONGVIDAtPat(I(OPleft,longvidright),
				       WITHOp, longvid) )
 end
)
 in (LrTable.NT 60,(result,OP1left,longvid1right),rest671) end
| (167,(_,(MlyValue.scon scon1,sconleft as scon1left,sconright as 
scon1right))::rest671) => let val result=MlyValue.atpat(fn _ => let 
val scon as scon1=scon1 ()
 in ( SCONAtPat(I(sconleft,sconright), scon) ) end
)
 in (LrTable.NT 60,(result,scon1left,scon1right),rest671) end
| (168,(_,(_,_,RBRACEright as RBRACE1right))::(_,(MlyValue.patrow_opt 
patrow_opt1,_,_))::(_,(_,LBRACEleft as LBRACE1left,_))::rest671) => 
let val result=MlyValue.atpat(fn _ => let val patrow_opt as 
patrow_opt1=patrow_opt1 ()
 in ( RECORDAtPat(I(LBRACEleft,RBRACEright), patrow_opt) ) end
)
 in (LrTable.NT 60,(result,LBRACE1left,RBRACE1right),rest671) end
| (169,(_,(_,_,RPARright as RPAR1right))::(_,(_,LPARleft as LPAR1left,
_))::rest671) => let val result=MlyValue.atpat(fn _ => (
 UNITAtPat(I(LPARleft,RPARright)) ))
 in (LrTable.NT 60,(result,LPAR1left,RPAR1right),rest671) end
| (170,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.pat_COMMA_list2
 pat_COMMA_list21,_,_))::(_,(_,LPARleft as LPAR1left,_))::rest671) => 
let val result=MlyValue.atpat(fn _ => let val pat_COMMA_list2 as 
pat_COMMA_list21=pat_COMMA_list21 ()
 in ( TUPLEAtPat(I(LPARleft,RPARright), pat_COMMA_list2) ) end
)
 in (LrTable.NT 60,(result,LPAR1left,RPAR1right),rest671) end
| (171,(_,(_,_,RBRACKright as RBRACK1right))::(_,(
MlyValue.pat_COMMA_list0 pat_COMMA_list01,_,_))::(_,(_,LBRACKleft as 
LBRACK1left,_))::rest671) => let val result=MlyValue.atpat(fn _ => 
let val pat_COMMA_list0 as pat_COMMA_list01=pat_COMMA_list01 ()
 in ( LISTAtPat(I(LBRACKleft,RBRACKright),
				    pat_COMMA_list0) )
 end
)
 in (LrTable.NT 60,(result,LBRACK1left,RBRACK1right),rest671) end
| (172,(_,(_,_,RBRACKright as RBRACK1right))::(_,(
MlyValue.pat_COMMA_list0 pat_COMMA_list01,_,_))::(_,(_,HASHBRACKleft
 as HASHBRACK1left,_))::rest671) => let val result=MlyValue.atpat(fn _
 => let val pat_COMMA_list0 as pat_COMMA_list01=pat_COMMA_list01 ()
 in (
 VECTORAtPat(I(HASHBRACKleft,RBRACKright),
				    pat_COMMA_list0) )
 end
)
 in (LrTable.NT 60,(result,HASHBRACK1left,RBRACK1right),rest671) end
| (173,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.pat_BAR_list2 
pat_BAR_list21,_,_))::(_,(_,LPARleft as LPAR1left,_))::rest671) => 
let val result=MlyValue.atpat(fn _ => let val pat_BAR_list2 as 
pat_BAR_list21=pat_BAR_list21 ()
 in ( ALTAtPat(I(LPARleft,RPARright),
				   pat_BAR_list2) ) end
)
 in (LrTable.NT 60,(result,LPAR1left,RPAR1right),rest671) end
| (174,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.pat pat1,_,_))
::(_,(_,LPARleft as LPAR1left,_))::rest671) => let val result=
MlyValue.atpat(fn _ => let val pat as pat1=pat1 ()
 in ( PARAtPat(I(LPARleft,RPARright), pat) ) end
)
 in (LrTable.NT 60,(result,LPAR1left,RPAR1right),rest671) end
| (175,(_,(MlyValue.pat_COMMA_list1 pat_COMMA_list11,
pat_COMMA_list11left,pat_COMMA_list11right))::rest671) => let val 
result=MlyValue.pat_COMMA_list0(fn _ => let val pat_COMMA_list1 as 
pat_COMMA_list11=pat_COMMA_list11 ()
 in ( pat_COMMA_list1 ) end
)
 in (LrTable.NT 61,(result,pat_COMMA_list11left,pat_COMMA_list11right)
,rest671) end
| (176,rest671) => let val result=MlyValue.pat_COMMA_list0(fn _ => (
 [] ))
 in (LrTable.NT 61,(result,defaultPos,defaultPos),rest671) end
| (177,(_,(MlyValue.pat_COMMA_list1 pat_COMMA_list11,_,
pat_COMMA_list11right))::_::(_,(MlyValue.pat pat1,pat1left,_))::
rest671) => let val result=MlyValue.pat_COMMA_list1(fn _ => let val 
pat as pat1=pat1 ()
val pat_COMMA_list1 as pat_COMMA_list11=pat_COMMA_list11 ()
 in ( pat::pat_COMMA_list1 ) end
)
 in (LrTable.NT 62,(result,pat1left,pat_COMMA_list11right),rest671)
 end
| (178,(_,(MlyValue.pat pat1,pat1left,pat1right))::rest671) => let 
val result=MlyValue.pat_COMMA_list1(fn _ => let val pat as pat1=pat1 
()
 in ( pat::[] ) end
)
 in (LrTable.NT 62,(result,pat1left,pat1right),rest671) end
| (179,(_,(MlyValue.pat_COMMA_list1 pat_COMMA_list11,_,
pat_COMMA_list11right))::_::(_,(MlyValue.pat pat1,pat1left,_))::
rest671) => let val result=MlyValue.pat_COMMA_list2(fn _ => let val 
pat as pat1=pat1 ()
val pat_COMMA_list1 as pat_COMMA_list11=pat_COMMA_list11 ()
 in ( pat::pat_COMMA_list1 ) end
)
 in (LrTable.NT 63,(result,pat1left,pat_COMMA_list11right),rest671)
 end
| (180,(_,(MlyValue.pat pat2,_,pat2right))::_::(_,(MlyValue.pat pat1,
pat1left,_))::rest671) => let val result=MlyValue.pat_BAR_list2(fn _
 => let val pat1=pat1 ()
val pat2=pat2 ()
 in ( [pat1,pat2] ) end
)
 in (LrTable.NT 64,(result,pat1left,pat2right),rest671) end
| (181,(_,(MlyValue.pat_BAR_list2 pat_BAR_list21,_,pat_BAR_list21right
))::_::(_,(MlyValue.pat pat1,pat1left,_))::rest671) => let val result=
MlyValue.pat_BAR_list2(fn _ => let val pat as pat1=pat1 ()
val pat_BAR_list2 as pat_BAR_list21=pat_BAR_list21 ()
 in ( pat::pat_BAR_list2 ) end
)
 in (LrTable.NT 64,(result,pat1left,pat_BAR_list21right),rest671) end
| (182,(_,(_,DOTSleft as DOTS1left,DOTSright as DOTS1right))::rest671)
 => let val result=MlyValue.patrow(fn _ => (
 WILDCARDPatRow(I(DOTSleft,DOTSright)) ))
 in (LrTable.NT 65,(result,DOTS1left,DOTS1right),rest671) end
| (183,(_,(MlyValue.COMMA_patrow_opt COMMA_patrow_opt1,_,
COMMA_patrow_optright as COMMA_patrow_opt1right))::(_,(MlyValue.pat 
pat1,_,_))::_::(_,(MlyValue.lab lab1,lableft as lab1left,_))::rest671)
 => let val result=MlyValue.patrow(fn _ => let val lab as lab1=lab1 ()
val pat as pat1=pat1 ()
val COMMA_patrow_opt as COMMA_patrow_opt1=COMMA_patrow_opt1 ()
 in (
 ROWPatRow(I(lableft,COMMA_patrow_optright),
				      lab, pat, COMMA_patrow_opt) 
) end
)
 in (LrTable.NT 65,(result,lab1left,COMMA_patrow_opt1right),rest671)
 end
| (184,(_,(MlyValue.COMMA_patrow_opt COMMA_patrow_opt1,_,
COMMA_patrow_optright as COMMA_patrow_opt1right))::(_,(
MlyValue.AS_pat_opt AS_pat_opt1,_,_))::(_,(MlyValue.COLON_ty_opt 
COLON_ty_opt1,_,_))::(_,(MlyValue.vid' vid'1,vid'left as vid'1left,_))
::rest671) => let val result=MlyValue.patrow(fn _ => let val vid' as 
vid'1=vid'1 ()
val COLON_ty_opt as COLON_ty_opt1=COLON_ty_opt1 ()
val AS_pat_opt as AS_pat_opt1=AS_pat_opt1 ()
val COMMA_patrow_opt as COMMA_patrow_opt1=COMMA_patrow_opt1 ()
 in (
 VIDPatRow(I(vid'left,COMMA_patrow_optright),
				    vid', COLON_ty_opt, AS_pat_opt,
				    COMMA_patrow_opt) 
) end
)
 in (LrTable.NT 65,(result,vid'1left,COMMA_patrow_opt1right),rest671)
 end
| (185,(_,(MlyValue.patrow patrow1,_,patrow1right))::(_,(_,COMMA1left,
_))::rest671) => let val result=MlyValue.COMMA_patrow_opt(fn _ => let 
val patrow as patrow1=patrow1 ()
 in ( SOME patrow ) end
)
 in (LrTable.NT 67,(result,COMMA1left,patrow1right),rest671) end
| (186,rest671) => let val result=MlyValue.COMMA_patrow_opt(fn _ => (
 NONE ))
 in (LrTable.NT 67,(result,defaultPos,defaultPos),rest671) end
| (187,(_,(MlyValue.ty ty1,_,ty1right))::(_,(_,COLON1left,_))::rest671
) => let val result=MlyValue.COLON_ty_opt(fn _ => let val ty as ty1=
ty1 ()
 in ( SOME ty ) end
)
 in (LrTable.NT 68,(result,COLON1left,ty1right),rest671) end
| (188,rest671) => let val result=MlyValue.COLON_ty_opt(fn _ => (
 NONE ))
 in (LrTable.NT 68,(result,defaultPos,defaultPos),rest671) end
| (189,(_,(MlyValue.pat pat1,_,pat1right))::(_,(_,AS1left,_))::rest671
) => let val result=MlyValue.AS_pat_opt(fn _ => let val pat as pat1=
pat1 ()
 in ( SOME pat ) end
)
 in (LrTable.NT 69,(result,AS1left,pat1right),rest671) end
| (190,rest671) => let val result=MlyValue.AS_pat_opt(fn _ => ( NONE )
)
 in (LrTable.NT 69,(result,defaultPos,defaultPos),rest671) end
| (191,(_,(MlyValue.patrow patrow1,patrow1left,patrow1right))::rest671
) => let val result=MlyValue.patrow_opt(fn _ => let val patrow as 
patrow1=patrow1 ()
 in ( SOME patrow ) end
)
 in (LrTable.NT 66,(result,patrow1left,patrow1right),rest671) end
| (192,rest671) => let val result=MlyValue.patrow_opt(fn _ => ( NONE )
)
 in (LrTable.NT 66,(result,defaultPos,defaultPos),rest671) end
| (193,(_,(MlyValue.atpat atpat1,atpatleft as atpat1left,atpatright
 as atpat1right))::rest671) => let val result=MlyValue.infpat(fn _ => 
let val atpat as atpat1=atpat1 ()
 in ( ATPATPat(I(atpatleft,atpatright), atpat) ) end
)
 in (LrTable.NT 70,(result,atpat1left,atpat1right),rest671) end
| (194,(_,(MlyValue.atpat atpat1,_,atpatright as atpat1right))::(_,(
MlyValue.infpat infpat1,infpatleft as infpat1left,_))::rest671) => 
let val result=MlyValue.infpat(fn _ => let val infpat as infpat1=
infpat1 ()
val atpat as atpat1=atpat1 ()
 in ( APPPat(I(infpatleft,atpatright), infpat, atpat) ) end
)
 in (LrTable.NT 70,(result,infpat1left,atpat1right),rest671) end
| (195,(_,(MlyValue.infpat infpat1,infpat1left,infpat1right))::rest671
) => let val result=MlyValue.pat(fn _ => let val infpat as infpat1=
infpat1 ()
 in ( infpat ) end
)
 in (LrTable.NT 71,(result,infpat1left,infpat1right),rest671) end
| (196,(_,(MlyValue.ty ty1,_,tyright as ty1right))::_::(_,(
MlyValue.pat pat1,patleft as pat1left,_))::rest671) => let val result=
MlyValue.pat(fn _ => let val pat as pat1=pat1 ()
val ty as ty1=ty1 ()
 in ( TYPEDPat(I(patleft,tyright), pat, ty) ) end
)
 in (LrTable.NT 71,(result,pat1left,ty1right),rest671) end
| (197,(_,(MlyValue.pat pat1,_,patright as pat1right))::(_,(_,NONleft
 as NON1left,_))::rest671) => let val result=MlyValue.pat(fn _ => let 
val pat as pat1=pat1 ()
 in ( NONPat(I(NONleft,patright), pat) ) end
)
 in (LrTable.NT 71,(result,NON1left,pat1right),rest671) end
| (198,(_,(MlyValue.pat pat2,_,pat2right))::_::(_,(MlyValue.pat pat1,
pat1left,_))::rest671) => let val result=MlyValue.pat(fn _ => let val 
pat1=pat1 ()
val pat2=pat2 ()
 in ( ASPat(I(pat1left,pat2right), pat1, pat2) ) end
)
 in (LrTable.NT 71,(result,pat1left,pat2right),rest671) end
| (199,(_,(MlyValue.atexp atexp1,_,atexpright as atexp1right))::_::(_,
(MlyValue.pat pat1,patleft as pat1left,_))::rest671) => let val result
=MlyValue.pat(fn _ => let val pat as pat1=pat1 ()
val atexp as atexp1=atexp1 ()
 in ( WHENPat(I(patleft,atexpright), pat, atexp) ) end
)
 in (LrTable.NT 71,(result,pat1left,atexp1right),rest671) end
| (200,(_,(_,_,ENDright as END1right))::(_,(MlyValue.valbind valbind1,
_,_))::_::(_,(MlyValue.pat pat1,patleft as pat1left,_))::rest671) => 
let val result=MlyValue.pat(fn _ => let val pat as pat1=pat1 ()
val valbind as valbind1=valbind1 ()
 in ( WITHVALPat(I(patleft,ENDright), pat, valbind) ) end
)
 in (LrTable.NT 71,(result,pat1left,END1right),rest671) end
| (201,(_,(_,_,ENDright as END1right))::(_,(MlyValue.fvalbind 
fvalbind1,_,_))::_::(_,(MlyValue.pat pat1,patleft as pat1left,_))::
rest671) => let val result=MlyValue.pat(fn _ => let val pat as pat1=
pat1 ()
val fvalbind as fvalbind1=fvalbind1 ()
 in ( WITHFUNPat(I(patleft,ENDright), pat, fvalbind) ) end
)
 in (LrTable.NT 71,(result,pat1left,END1right),rest671) end
| (202,(_,(MlyValue.tupty tupty1,tupty1left,tupty1right))::rest671)
 => let val result=MlyValue.ty(fn _ => let val tupty as tupty1=tupty1 
()
 in ( tupty ) end
)
 in (LrTable.NT 72,(result,tupty1left,tupty1right),rest671) end
| (203,(_,(MlyValue.ty ty1,_,tyright as ty1right))::_::(_,(
MlyValue.tupty tupty1,tuptyleft as tupty1left,_))::rest671) => let 
val result=MlyValue.ty(fn _ => let val tupty as tupty1=tupty1 ()
val ty as ty1=ty1 ()
 in ( ARROWTy(I(tuptyleft,tyright), tupty, ty) ) end
)
 in (LrTable.NT 72,(result,tupty1left,ty1right),rest671) end
| (204,(_,(MlyValue.ty_STAR_list ty_STAR_list1,ty_STAR_listleft as 
ty_STAR_list1left,ty_STAR_listright as ty_STAR_list1right))::rest671)
 => let val result=MlyValue.tupty(fn _ => let val ty_STAR_list as 
ty_STAR_list1=ty_STAR_list1 ()
 in (
 TUPLETy(I(ty_STAR_listleft,ty_STAR_listright),
				   ty_STAR_list) )
 end
)
 in (LrTable.NT 73,(result,ty_STAR_list1left,ty_STAR_list1right),
rest671) end
| (205,(_,(MlyValue.ty_STAR_list ty_STAR_list1,_,ty_STAR_list1right))
::_::(_,(MlyValue.consty consty1,consty1left,_))::rest671) => let val 
result=MlyValue.ty_STAR_list(fn _ => let val consty as consty1=consty1
 ()
val ty_STAR_list as ty_STAR_list1=ty_STAR_list1 ()
 in ( consty::ty_STAR_list ) end
)
 in (LrTable.NT 74,(result,consty1left,ty_STAR_list1right),rest671)
 end
| (206,(_,(MlyValue.consty consty1,consty1left,consty1right))::rest671
) => let val result=MlyValue.ty_STAR_list(fn _ => let val consty as 
consty1=consty1 ()
 in ( consty::[] ) end
)
 in (LrTable.NT 74,(result,consty1left,consty1right),rest671) end
| (207,(_,(MlyValue.atty atty1,atty1left,atty1right))::rest671) => 
let val result=MlyValue.consty(fn _ => let val atty as atty1=atty1 ()
 in ( atty ) end
)
 in (LrTable.NT 75,(result,atty1left,atty1right),rest671) end
| (208,(_,(MlyValue.longtycon longtycon1,_,longtyconright as 
longtycon1right))::(_,(MlyValue.tyseq tyseq1,tyseqleft as tyseq1left,_
))::rest671) => let val result=MlyValue.consty(fn _ => let val tyseq
 as tyseq1=tyseq1 ()
val longtycon as longtycon1=longtycon1 ()
 in ( TYCONTy(I(tyseqleft,longtyconright),
					  tyseq, longtycon) )
 end
)
 in (LrTable.NT 75,(result,tyseq1left,longtycon1right),rest671) end
| (209,(_,(MlyValue.tyvar tyvar1,tyvarleft as tyvar1left,tyvarright
 as tyvar1right))::rest671) => let val result=MlyValue.atty(fn _ => 
let val tyvar as tyvar1=tyvar1 ()
 in ( TYVARTy(I(tyvarleft,tyvarright), tyvar) ) end
)
 in (LrTable.NT 76,(result,tyvar1left,tyvar1right),rest671) end
| (210,(_,(_,_,RBRACEright as RBRACE1right))::(_,(MlyValue.tyrow_opt 
tyrow_opt1,_,_))::(_,(_,LBRACEleft as LBRACE1left,_))::rest671) => 
let val result=MlyValue.atty(fn _ => let val tyrow_opt as tyrow_opt1=
tyrow_opt1 ()
 in ( RECORDTy(I(LBRACEleft,RBRACEright), tyrow_opt) ) end
)
 in (LrTable.NT 76,(result,LBRACE1left,RBRACE1right),rest671) end
| (211,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.ty ty1,_,_))::(
_,(_,LPARleft as LPAR1left,_))::rest671) => let val result=
MlyValue.atty(fn _ => let val ty as ty1=ty1 ()
 in ( PARTy(I(LPARleft,RPARright), ty) ) end
)
 in (LrTable.NT 76,(result,LPAR1left,RPAR1right),rest671) end
| (212,(_,(MlyValue.longsigid longsigid1,_,longsigidright as 
longsigid1right))::(_,(_,PACKleft as PACK1left,_))::rest671) => let 
val result=MlyValue.atty(fn _ => let val longsigid as longsigid1=
longsigid1 ()
 in ( PACKTy(I(PACKleft,longsigidright), longsigid)) end
)
 in (LrTable.NT 76,(result,PACK1left,longsigid1right),rest671) end
| (213,(_,(MlyValue.COMMA_tyrow_opt COMMA_tyrow_opt1,_,
COMMA_tyrow_optright as COMMA_tyrow_opt1right))::(_,(MlyValue.ty ty1,_
,_))::_::(_,(MlyValue.lab lab1,lableft as lab1left,_))::rest671) => 
let val result=MlyValue.tyrow(fn _ => let val lab as lab1=lab1 ()
val ty as ty1=ty1 ()
val COMMA_tyrow_opt as COMMA_tyrow_opt1=COMMA_tyrow_opt1 ()
 in (
 ROWTyRow(I(lableft,COMMA_tyrow_optright),
				   lab, ty, COMMA_tyrow_opt) 
) end
)
 in (LrTable.NT 77,(result,lab1left,COMMA_tyrow_opt1right),rest671)
 end
| (214,(_,(MlyValue.tyrow tyrow1,_,tyrow1right))::(_,(_,COMMA1left,_))
::rest671) => let val result=MlyValue.COMMA_tyrow_opt(fn _ => let val 
tyrow as tyrow1=tyrow1 ()
 in ( SOME tyrow ) end
)
 in (LrTable.NT 79,(result,COMMA1left,tyrow1right),rest671) end
| (215,rest671) => let val result=MlyValue.COMMA_tyrow_opt(fn _ => (
 NONE ))
 in (LrTable.NT 79,(result,defaultPos,defaultPos),rest671) end
| (216,(_,(MlyValue.tyrow tyrow1,tyrow1left,tyrow1right))::rest671)
 => let val result=MlyValue.tyrow_opt(fn _ => let val tyrow as tyrow1=
tyrow1 ()
 in ( SOME tyrow ) end
)
 in (LrTable.NT 78,(result,tyrow1left,tyrow1right),rest671) end
| (217,rest671) => let val result=MlyValue.tyrow_opt(fn _ => ( NONE ))
 in (LrTable.NT 78,(result,defaultPos,defaultPos),rest671) end
| (218,(_,(MlyValue.consty consty1,constyleft as consty1left,
constyright as consty1right))::rest671) => let val result=
MlyValue.tyseq(fn _ => let val consty as consty1=consty1 ()
 in ( Seq(I(constyleft,constyright),
					      [consty]) ) end
)
 in (LrTable.NT 80,(result,consty1left,consty1right),rest671) end
| (219,rest671) => let val result=MlyValue.tyseq(fn _ => (
 Seq(I(defaultPos,defaultPos), []) ))
 in (LrTable.NT 80,(result,defaultPos,defaultPos),rest671) end
| (220,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.ty_COMMA_list2 
ty_COMMA_list21,_,_))::(_,(_,LPARleft as LPAR1left,_))::rest671) => 
let val result=MlyValue.tyseq(fn _ => let val ty_COMMA_list2 as 
ty_COMMA_list21=ty_COMMA_list21 ()
 in ( Seq(I(LPARleft,RPARright),
					      ty_COMMA_list2) ) end
)
 in (LrTable.NT 80,(result,LPAR1left,RPAR1right),rest671) end
| (221,(_,(MlyValue.ty_COMMA_list2 ty_COMMA_list21,_,
ty_COMMA_list21right))::_::(_,(MlyValue.ty ty1,ty1left,_))::rest671)
 => let val result=MlyValue.ty_COMMA_list2(fn _ => let val ty as ty1=
ty1 ()
val ty_COMMA_list2 as ty_COMMA_list21=ty_COMMA_list21 ()
 in ( ty::ty_COMMA_list2 ) end
)
 in (LrTable.NT 81,(result,ty1left,ty_COMMA_list21right),rest671) end
| (222,(_,(MlyValue.ty ty2,_,ty2right))::_::(_,(MlyValue.ty ty1,
ty1left,_))::rest671) => let val result=MlyValue.ty_COMMA_list2(fn _
 => let val ty1=ty1 ()
val ty2=ty2 ()
 in ( [ty1, ty2] ) end
)
 in (LrTable.NT 81,(result,ty1left,ty2right),rest671) end
| (223,(_,(MlyValue.tyvarseq1 tyvarseq11,tyvarseq11left,
tyvarseq11right))::rest671) => let val result=MlyValue.tyvarseq(fn _
 => let val tyvarseq1 as tyvarseq11=tyvarseq11 ()
 in ( tyvarseq1 ) end
)
 in (LrTable.NT 82,(result,tyvarseq11left,tyvarseq11right),rest671)
 end
| (224,rest671) => let val result=MlyValue.tyvarseq(fn _ => (
 Seq(I(defaultPos,defaultPos), []) ))
 in (LrTable.NT 82,(result,defaultPos,defaultPos),rest671) end
| (225,(_,(MlyValue.tyvar tyvar1,tyvarleft as tyvar1left,tyvarright
 as tyvar1right))::rest671) => let val result=MlyValue.tyvarseq1(fn _
 => let val tyvar as tyvar1=tyvar1 ()
 in ( Seq(I(tyvarleft,tyvarright), [tyvar])) end
)
 in (LrTable.NT 83,(result,tyvar1left,tyvar1right),rest671) end
| (226,(_,(_,_,RPARright as RPAR1right))::(_,(
MlyValue.tyvar_COMMA_list1 tyvar_COMMA_list11,_,_))::(_,(_,LPARleft
 as LPAR1left,_))::rest671) => let val result=MlyValue.tyvarseq1(fn _
 => let val tyvar_COMMA_list1 as tyvar_COMMA_list11=tyvar_COMMA_list11
 ()
 in ( Seq(I(LPARleft,RPARright),
					      tyvar_COMMA_list1) ) end
)
 in (LrTable.NT 83,(result,LPAR1left,RPAR1right),rest671) end
| (227,(_,(MlyValue.tyvar_COMMA_list1 tyvar_COMMA_list11,_,
tyvar_COMMA_list11right))::_::(_,(MlyValue.tyvar tyvar1,tyvar1left,_))
::rest671) => let val result=MlyValue.tyvar_COMMA_list1(fn _ => let 
val tyvar as tyvar1=tyvar1 ()
val tyvar_COMMA_list1 as tyvar_COMMA_list11=tyvar_COMMA_list11 ()
 in ( tyvar::tyvar_COMMA_list1 ) end
)
 in (LrTable.NT 84,(result,tyvar1left,tyvar_COMMA_list11right),rest671
) end
| (228,(_,(MlyValue.tyvar tyvar1,tyvar1left,tyvar1right))::rest671)
 => let val result=MlyValue.tyvar_COMMA_list1(fn _ => let val tyvar
 as tyvar1=tyvar1 ()
 in ( tyvar::[] ) end
)
 in (LrTable.NT 84,(result,tyvar1left,tyvar1right),rest671) end
| (229,(_,(_,_,ENDright as END1right))::(_,(MlyValue.dec dec1,_,_))::(
_,(_,STRUCTleft as STRUCT1left,_))::rest671) => let val result=
MlyValue.atstrexp(fn _ => let val dec as dec1=dec1 ()
 in ( STRUCTAtStrExp(I(STRUCTleft,ENDright), dec) ) end
)
 in (LrTable.NT 85,(result,STRUCT1left,END1right),rest671) end
| (230,(_,(MlyValue.longstrid longstrid1,longstridleft as 
longstrid1left,longstridright as longstrid1right))::rest671) => let 
val result=MlyValue.atstrexp(fn _ => let val longstrid as longstrid1=
longstrid1 ()
 in (
 LONGSTRIDAtStrExp(I(longstridleft,longstridright),
					    longstrid) 
) end
)
 in (LrTable.NT 85,(result,longstrid1left,longstrid1right),rest671)
 end
| (231,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.strexp strexp1,
_,_))::(_,(_,LPARleft as LPAR1left,_))::rest671) => let val result=
MlyValue.atstrexp(fn _ => let val strexp as strexp1=strexp1 ()
 in ( PARAtStrExp(I(LPARleft,RPARright), strexp) ) end
)
 in (LrTable.NT 85,(result,LPAR1left,RPAR1right),rest671) end
| (232,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.dec dec1,_,_))
::(_,(_,LPARleft as LPAR1left,_))::rest671) => let val result=
MlyValue.atstrexp(fn _ => let val dec as dec1=dec1 ()
 in ( DECAtStrExp(I(LPARleft,RPARright), dec) ) end
)
 in (LrTable.NT 85,(result,LPAR1left,RPAR1right),rest671) end
| (233,(_,(_,_,ENDright as END1right))::(_,(MlyValue.strexp strexp1,_,
_))::_::(_,(MlyValue.dec dec1,_,_))::(_,(_,LETleft as LET1left,_))::
rest671) => let val result=MlyValue.atstrexp(fn _ => let val dec as 
dec1=dec1 ()
val strexp as strexp1=strexp1 ()
 in ( LETAtStrExp(I(LETleft,ENDright), dec, strexp) ) end
)
 in (LrTable.NT 85,(result,LET1left,END1right),rest671) end
| (234,(_,(MlyValue.atstrexp atstrexp1,atstrexpleft as atstrexp1left,
atstrexpright as atstrexp1right))::rest671) => let val result=
MlyValue.appstrexp(fn _ => let val atstrexp as atstrexp1=atstrexp1 ()
 in ( ATSTREXPStrExp(I(atstrexpleft,atstrexpright),
					 atstrexp) )
 end
)
 in (LrTable.NT 86,(result,atstrexp1left,atstrexp1right),rest671) end
| (235,(_,(MlyValue.atstrexp atstrexp1,_,atstrexpright as 
atstrexp1right))::(_,(MlyValue.appstrexp appstrexp1,appstrexpleft as 
appstrexp1left,_))::rest671) => let val result=MlyValue.appstrexp(fn _
 => let val appstrexp as appstrexp1=appstrexp1 ()
val atstrexp as atstrexp1=atstrexp1 ()
 in (
 APPStrExp(I(appstrexpleft,atstrexpright),
				    appstrexp, atstrexp) 
) end
)
 in (LrTable.NT 86,(result,appstrexp1left,atstrexp1right),rest671) end
| (236,(_,(MlyValue.appstrexp appstrexp1,appstrexp1left,
appstrexp1right))::rest671) => let val result=MlyValue.strexp(fn _ => 
let val appstrexp as appstrexp1=appstrexp1 ()
 in ( appstrexp ) end
)
 in (LrTable.NT 87,(result,appstrexp1left,appstrexp1right),rest671)
 end
| (237,(_,(MlyValue.sigexp sigexp1,_,sigexpright as sigexp1right))::_
::(_,(MlyValue.strexp strexp1,strexpleft as strexp1left,_))::rest671)
 => let val result=MlyValue.strexp(fn _ => let val strexp as strexp1=
strexp1 ()
val sigexp as sigexp1=sigexp1 ()
 in (
 TRANSStrExp(I(strexpleft,sigexpright),
				      strexp, sigexp) )
 end
)
 in (LrTable.NT 87,(result,strexp1left,sigexp1right),rest671) end
| (238,(_,(MlyValue.sigexp sigexp1,_,sigexpright as sigexp1right))::_
::(_,(MlyValue.strexp strexp1,strexpleft as strexp1left,_))::rest671)
 => let val result=MlyValue.strexp(fn _ => let val strexp as strexp1=
strexp1 ()
val sigexp as sigexp1=sigexp1 ()
 in ( OPAQStrExp(I(strexpleft,sigexpright), strexp, sigexp)) end
)
 in (LrTable.NT 87,(result,strexp1left,sigexp1right),rest671) end
| (239,(_,(MlyValue.strexp strexp1,_,strexpright as strexp1right))::_
::(_,(MlyValue.strpat strpat1,_,_))::(_,(_,FCTleft as FCT1left,_))::
rest671) => let val result=MlyValue.strexp(fn _ => let val strpat as 
strpat1=strpat1 ()
val strexp as strexp1=strexp1 ()
 in ( FCTStrExp(I(FCTleft,strexpright), strpat, strexp) ) end
)
 in (LrTable.NT 87,(result,FCT1left,strexp1right),rest671) end
| (240,(_,(MlyValue.sigexp sigexp1,_,sigexpright as sigexp1right))::_
::(_,(MlyValue.infexp infexp1,_,_))::(_,(_,UNPACKleft as UNPACK1left,_
))::rest671) => let val result=MlyValue.strexp(fn _ => let val infexp
 as infexp1=infexp1 ()
val sigexp as sigexp1=sigexp1 ()
 in (
 UNPACKStrExp(I(UNPACKleft,sigexpright),
				       infexp, sigexp) )
 end
)
 in (LrTable.NT 87,(result,UNPACK1left,sigexp1right),rest671) end
| (241,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.sigexp sigexp1,
_,_))::_::(_,(MlyValue.strid strid1,_,_))::(_,(_,LPARleft as LPAR1left
,_))::rest671) => let val result=MlyValue.strpat(fn _ => let val strid
 as strid1=strid1 ()
val sigexp as sigexp1=sigexp1 ()
 in ( StrPat(I(LPARleft,RPARright), strid, sigexp) ) end
)
 in (LrTable.NT 88,(result,LPAR1left,RPAR1right),rest671) end
| (242,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.sigexp sigexp1,
_,_))::_::_::(_,(_,LPARleft as LPAR1left,_))::rest671) => let val 
result=MlyValue.strpat(fn _ => let val sigexp as sigexp1=sigexp1 ()
 in ( WILDCARDStrPat(I(LPARleft,RPARright), sigexp) ) end
)
 in (LrTable.NT 88,(result,LPAR1left,RPAR1right),rest671) end
| (243,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.spec spec1,_,_)
)::(_,(_,LPARleft as LPAR1left,_))::rest671) => let val result=
MlyValue.strpat(fn _ => let val spec as spec1=spec1 ()
 in ( SPECStrPat(I(LPARleft,RPARright), spec) ) end
)
 in (LrTable.NT 88,(result,LPAR1left,RPAR1right),rest671) end
| (244,(_,(MlyValue.strexp__AND_strbind_opt strexp__AND_strbind_opt1,_
,strexp__AND_strbind_optright as strexp__AND_strbind_opt1right))::_::(
_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_,_))::(_,(
MlyValue.strid strid1,stridleft as strid1left,_))::rest671) => let 
val result=MlyValue.strbind(fn _ => let val strid as strid1=strid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val strexp__AND_strbind_opt as strexp__AND_strbind_opt1=
strexp__AND_strbind_opt1 ()
 in (
 TRANSStrBind(I(stridleft,
					 strexp__AND_strbind_optright),
				       strid, COLON_sigexp_opt,
				       #1 strexp__AND_strbind_opt,
				       #2 strexp__AND_strbind_opt) 
) end
)
 in (LrTable.NT 89,(result,strid1left,strexp__AND_strbind_opt1right),
rest671) end
| (245,(_,(MlyValue.strexp__AND_strbind_opt strexp__AND_strbind_opt1,_
,strexp__AND_strbind_optright as strexp__AND_strbind_opt1right))::_::(
_,(MlyValue.sigexp sigexp1,_,_))::_::(_,(MlyValue.strid strid1,
stridleft as strid1left,_))::rest671) => let val result=
MlyValue.strbind(fn _ => let val strid as strid1=strid1 ()
val sigexp as sigexp1=sigexp1 ()
val strexp__AND_strbind_opt as strexp__AND_strbind_opt1=
strexp__AND_strbind_opt1 ()
 in (
 OPAQStrBind(I(stridleft,strexp__AND_strbind_optright),
				      strid, sigexp, #1 strexp__AND_strbind_opt,
				      #2 strexp__AND_strbind_opt) 
) end
)
 in (LrTable.NT 89,(result,strid1left,strexp__AND_strbind_opt1right),
rest671) end
| (246,(_,(MlyValue.strexp__AND_strbind_opt strexp__AND_strbind_opt1,_
,strexp__AND_strbind_optright as strexp__AND_strbind_opt1right))::_::(
_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_,_))::(_,(_,
UNDERBARleft as UNDERBAR1left,_))::rest671) => let val result=
MlyValue.strbind(fn _ => let val COLON_sigexp_opt as COLON_sigexp_opt1
=COLON_sigexp_opt1 ()
val strexp__AND_strbind_opt as strexp__AND_strbind_opt1=
strexp__AND_strbind_opt1 ()
 in (
 WILDCARDStrBind(I(UNDERBARleft,
					 strexp__AND_strbind_optright),
				       COLON_sigexp_opt,
				       #1 strexp__AND_strbind_opt,
				       #2 strexp__AND_strbind_opt) 
) end
)
 in (LrTable.NT 89,(result,UNDERBAR1left,strexp__AND_strbind_opt1right
),rest671) end
| (247,(_,(MlyValue.strbind strbind1,_,strbind1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_strbind_opt(fn _ => let 
val strbind as strbind1=strbind1 ()
 in ( SOME strbind ) end
)
 in (LrTable.NT 90,(result,AND1left,strbind1right),rest671) end
| (248,rest671) => let val result=MlyValue.AND_strbind_opt(fn _ => (
 NONE ))
 in (LrTable.NT 90,(result,defaultPos,defaultPos),rest671) end
| (249,(_,(MlyValue.AND_strbind_opt AND_strbind_opt1,_,
AND_strbind_opt1right))::(_,(MlyValue.appstrexp appstrexp1,
appstrexp1left,_))::rest671) => let val result=
MlyValue.strexp__AND_strbind_opt(fn _ => let val appstrexp as 
appstrexp1=appstrexp1 ()
val AND_strbind_opt as AND_strbind_opt1=AND_strbind_opt1 ()
 in ( ( appstrexp, AND_strbind_opt ) ) end
)
 in (LrTable.NT 91,(result,appstrexp1left,AND_strbind_opt1right),
rest671) end
| (250,(_,(MlyValue.sigexp__AND_strbind_opt sigexp__AND_strbind_opt1,_
,sigexp__AND_strbind_optright as sigexp__AND_strbind_opt1right))::_::(
_,(MlyValue.strexp strexp1,strexpleft as strexp1left,_))::rest671) => 
let val result=MlyValue.strexp__AND_strbind_opt(fn _ => let val strexp
 as strexp1=strexp1 ()
val sigexp__AND_strbind_opt as sigexp__AND_strbind_opt1=
sigexp__AND_strbind_opt1 ()
 in (
 ( TRANSStrExp(I(strexpleft,
					  sigexp__AND_strbind_optright),
					strexp, #1 sigexp__AND_strbind_opt)
			  , #2 sigexp__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 91,(result,strexp1left,sigexp__AND_strbind_opt1right),
rest671) end
| (251,(_,(MlyValue.sigexp__AND_strbind_opt sigexp__AND_strbind_opt1,_
,sigexp__AND_strbind_optright as sigexp__AND_strbind_opt1right))::_::(
_,(MlyValue.strexp strexp1,strexpleft as strexp1left,_))::rest671) => 
let val result=MlyValue.strexp__AND_strbind_opt(fn _ => let val strexp
 as strexp1=strexp1 ()
val sigexp__AND_strbind_opt as sigexp__AND_strbind_opt1=
sigexp__AND_strbind_opt1 ()
 in (
 ( OPAQStrExp(I(strexpleft,
					 sigexp__AND_strbind_optright),
				       strexp, #1 sigexp__AND_strbind_opt)
			  , #2 sigexp__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 91,(result,strexp1left,sigexp__AND_strbind_opt1right),
rest671) end
| (252,(_,(MlyValue.strexp__AND_strbind_opt strexp__AND_strbind_opt1,_
,strexp__AND_strbind_optright as strexp__AND_strbind_opt1right))::_::(
_,(MlyValue.strpat strpat1,_,_))::(_,(_,FCTleft as FCT1left,_))::
rest671) => let val result=MlyValue.strexp__AND_strbind_opt(fn _ => 
let val strpat as strpat1=strpat1 ()
val strexp__AND_strbind_opt as strexp__AND_strbind_opt1=
strexp__AND_strbind_opt1 ()
 in (
 ( FCTStrExp(I(FCTleft,strexp__AND_strbind_optright),
				      strpat, #1 strexp__AND_strbind_opt)
			  , #2 strexp__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 91,(result,FCT1left,strexp__AND_strbind_opt1right),
rest671) end
| (253,(_,(MlyValue.sigexp__AND_strbind_opt sigexp__AND_strbind_opt1,_
,sigexp__AND_strbind_optright as sigexp__AND_strbind_opt1right))::_::(
_,(MlyValue.infexp infexp1,_,_))::(_,(_,UNPACKleft as UNPACK1left,_))
::rest671) => let val result=MlyValue.strexp__AND_strbind_opt(fn _ => 
let val infexp as infexp1=infexp1 ()
val sigexp__AND_strbind_opt as sigexp__AND_strbind_opt1=
sigexp__AND_strbind_opt1 ()
 in (
 ( UNPACKStrExp(I(UNPACKleft,
					   sigexp__AND_strbind_optright),
					 infexp, #1 sigexp__AND_strbind_opt)
			  , #2 sigexp__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 91,(result,UNPACK1left,sigexp__AND_strbind_opt1right),
rest671) end
| (254,(_,(MlyValue.AND_strbind_opt AND_strbind_opt1,_,
AND_strbind_opt1right))::(_,(MlyValue.sigexp' sigexp'1,sigexp'1left,_)
)::rest671) => let val result=MlyValue.sigexp__AND_strbind_opt(fn _
 => let val sigexp' as sigexp'1=sigexp'1 ()
val AND_strbind_opt as AND_strbind_opt1=AND_strbind_opt1 ()
 in ( ( sigexp', AND_strbind_opt ) ) end
)
 in (LrTable.NT 92,(result,sigexp'1left,AND_strbind_opt1right),rest671
) end
| (255,(_,(MlyValue.sigexp__AND_strbind_opt sigexp__AND_strbind_opt1,_
,sigexp__AND_strbind_optright as sigexp__AND_strbind_opt1right))::_::(
_,(MlyValue.strpat strpat1,_,_))::(_,(_,FCTleft as FCT1left,_))::
rest671) => let val result=MlyValue.sigexp__AND_strbind_opt(fn _ => 
let val strpat as strpat1=strpat1 ()
val sigexp__AND_strbind_opt as sigexp__AND_strbind_opt1=
sigexp__AND_strbind_opt1 ()
 in (
 ( FCTSigExp(I(FCTleft,sigexp__AND_strbind_optright),
				      strpat, #1 sigexp__AND_strbind_opt)
			  , #2 sigexp__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 92,(result,FCT1left,sigexp__AND_strbind_opt1right),
rest671) end
| (256,(_,(MlyValue.rea__AND_strbind_opt rea__AND_strbind_opt1,_,
rea__AND_strbind_optright as rea__AND_strbind_opt1right))::_::(_,(
MlyValue.sigexp sigexp1,sigexpleft as sigexp1left,_))::rest671) => 
let val result=MlyValue.sigexp__AND_strbind_opt(fn _ => let val sigexp
 as sigexp1=sigexp1 ()
val rea__AND_strbind_opt as rea__AND_strbind_opt1=
rea__AND_strbind_opt1 ()
 in (
 ( WHEREREASigExp(I(sigexpleft,
					     rea__AND_strbind_optright),
					   sigexp, #1 rea__AND_strbind_opt)
			  , #2 rea__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 92,(result,sigexp1left,rea__AND_strbind_opt1right),
rest671) end
| (257,(_,(MlyValue.AND_rea_opt__AND_strbind_opt 
AND_rea_opt__AND_strbind_opt1,_,AND_rea_opt__AND_strbind_optright as 
AND_rea_opt__AND_strbind_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,VALleft as 
VAL1left,_))::rest671) => let val result=MlyValue.rea__AND_strbind_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_strbind_opt as AND_rea_opt__AND_strbind_opt1=
AND_rea_opt__AND_strbind_opt1 ()
 in (
 ( VALRea(I(VALleft,AND_rea_opt__AND_strbind_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_strbind_opt)
			  , #2 AND_rea_opt__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 93,(result,VAL1left,AND_rea_opt__AND_strbind_opt1right
),rest671) end
| (258,(_,(MlyValue.AND_rea_opt__AND_strbind_opt 
AND_rea_opt__AND_strbind_opt1,_,AND_rea_opt__AND_strbind_optright as 
AND_rea_opt__AND_strbind_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,FUNleft as 
FUN1left,_))::rest671) => let val result=MlyValue.rea__AND_strbind_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_strbind_opt as AND_rea_opt__AND_strbind_opt1=
AND_rea_opt__AND_strbind_opt1 ()
 in (
 ( FUNRea(I(FUNleft,AND_rea_opt__AND_strbind_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_strbind_opt)
			  , #2 AND_rea_opt__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 93,(result,FUN1left,AND_rea_opt__AND_strbind_opt1right
),rest671) end
| (259,(_,(MlyValue.AND_rea_opt__AND_strbind_opt 
AND_rea_opt__AND_strbind_opt1,_,AND_rea_opt__AND_strbind_optright as 
AND_rea_opt__AND_strbind_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,
CONSTRUCTORleft as CONSTRUCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_strbind_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_strbind_opt as AND_rea_opt__AND_strbind_opt1=
AND_rea_opt__AND_strbind_opt1 ()
 in (
 ( CONSTRUCTORRea(I(CONSTRUCTORleft,
					     AND_rea_opt__AND_strbind_optright),
					   OP_opt1, longvid1, OP_opt2, longvid2,
				           #1 AND_rea_opt__AND_strbind_opt)
			  , #2 AND_rea_opt__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 93,(result,CONSTRUCTOR1left,
AND_rea_opt__AND_strbind_opt1right),rest671) end
| (260,(_,(MlyValue.AND_rea_opt__AND_strbind_opt 
AND_rea_opt__AND_strbind_opt1,_,AND_rea_opt__AND_strbind_optright as 
AND_rea_opt__AND_strbind_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,EXCEPTIONleft
 as EXCEPTION1left,_))::rest671) => let val result=
MlyValue.rea__AND_strbind_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_strbind_opt as AND_rea_opt__AND_strbind_opt1=
AND_rea_opt__AND_strbind_opt1 ()
 in (
 ( EXCEPTIONRea(I(EXCEPTIONleft,
					   AND_rea_opt__AND_strbind_optright),
					 OP_opt1, longvid1, OP_opt2, longvid2,
					 #1 AND_rea_opt__AND_strbind_opt)
			  , #2 AND_rea_opt__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 93,(result,EXCEPTION1left,
AND_rea_opt__AND_strbind_opt1right),rest671) end
| (261,(_,(MlyValue.AND_rea_opt__AND_strbind_opt 
AND_rea_opt__AND_strbind_opt1,_,AND_rea_opt__AND_strbind_optright as 
AND_rea_opt__AND_strbind_opt1right))::(_,(MlyValue.ty ty1,_,_))::_::(_
,(MlyValue.longtycon longtycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1
,_,_))::(_,(_,TYPEleft as TYPE1left,_))::rest671) => let val result=
MlyValue.rea__AND_strbind_opt(fn _ => let val tyvarseq as tyvarseq1=
tyvarseq1 ()
val longtycon as longtycon1=longtycon1 ()
val ty as ty1=ty1 ()
val AND_rea_opt__AND_strbind_opt as AND_rea_opt__AND_strbind_opt1=
AND_rea_opt__AND_strbind_opt1 ()
 in (
 ( TYPERea(I(TYPEleft,
				      AND_rea_opt__AND_strbind_optright),
				    tyvarseq, longtycon, ty,
				    #1 AND_rea_opt__AND_strbind_opt)
			  , #2 AND_rea_opt__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 93,(result,TYPE1left,
AND_rea_opt__AND_strbind_opt1right),rest671) end
| (262,(_,(MlyValue.AND_rea_opt__AND_strbind_opt 
AND_rea_opt__AND_strbind_opt1,_,AND_rea_opt__AND_strbind_optright as 
AND_rea_opt__AND_strbind_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,STRUCTUREleft as 
STRUCTURE1left,_))::rest671) => let val result=
MlyValue.rea__AND_strbind_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_strbind_opt as AND_rea_opt__AND_strbind_opt1=
AND_rea_opt__AND_strbind_opt1 ()
 in (
 ( STRUCTURERea(I(STRUCTUREleft,
					   AND_rea_opt__AND_strbind_optright),
				         longstrid1, COLON_sigexp_opt,
					 longstrid2,
				         #1 AND_rea_opt__AND_strbind_opt)
			  , #2 AND_rea_opt__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 93,(result,STRUCTURE1left,
AND_rea_opt__AND_strbind_opt1right),rest671) end
| (263,(_,(MlyValue.AND_rea_opt__AND_strbind_opt 
AND_rea_opt__AND_strbind_opt1,_,AND_rea_opt__AND_strbind_optright as 
AND_rea_opt__AND_strbind_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,FUNCTORleft as 
FUNCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_strbind_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_strbind_opt as AND_rea_opt__AND_strbind_opt1=
AND_rea_opt__AND_strbind_opt1 ()
 in (
 ( FUNCTORRea(I(FUNCTORleft,
					 AND_rea_opt__AND_strbind_optright),
				       longstrid1, COLON_sigexp_opt, longstrid2,
				       #1 AND_rea_opt__AND_strbind_opt)
			  , #2 AND_rea_opt__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 93,(result,FUNCTOR1left,
AND_rea_opt__AND_strbind_opt1right),rest671) end
| (264,(_,(MlyValue.sigexp__AND_rea_opt__AND_strbind_opt 
sigexp__AND_rea_opt__AND_strbind_opt1,_,
sigexp__AND_rea_opt__AND_strbind_optright as 
sigexp__AND_rea_opt__AND_strbind_opt1right))::_::(_,(
MlyValue.strpat_list0 strpat_list01,_,_))::(_,(MlyValue.longsigid 
longsigid1,_,_))::(_,(_,SIGNATUREleft as SIGNATURE1left,_))::rest671)
 => let val result=MlyValue.rea__AND_strbind_opt(fn _ => let val 
longsigid as longsigid1=longsigid1 ()
val strpat_list0 as strpat_list01=strpat_list01 ()
val sigexp__AND_rea_opt__AND_strbind_opt as 
sigexp__AND_rea_opt__AND_strbind_opt1=
sigexp__AND_rea_opt__AND_strbind_opt1 ()
 in (
 ( SIGNATURERea
				(I(SIGNATUREleft,
				   sigexp__AND_rea_opt__AND_strbind_optright),
				 longsigid, strpat_list0,
				 #1 sigexp__AND_rea_opt__AND_strbind_opt,
				 #2 sigexp__AND_rea_opt__AND_strbind_opt)
			  , #3 sigexp__AND_rea_opt__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 93,(result,SIGNATURE1left,
sigexp__AND_rea_opt__AND_strbind_opt1right),rest671) end
| (265,(_,(MlyValue.AND_strbind_opt AND_strbind_opt1,
AND_strbind_opt1left,AND_strbind_opt1right))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_strbind_opt(fn _ => let val 
AND_strbind_opt as AND_strbind_opt1=AND_strbind_opt1 ()
 in ( ( NONE, AND_strbind_opt ) ) end
)
 in (LrTable.NT 94,(result,AND_strbind_opt1left,AND_strbind_opt1right)
,rest671) end
| (266,(_,(MlyValue.rea__AND_strbind_opt rea__AND_strbind_opt1,_,
rea__AND_strbind_opt1right))::(_,(_,AND1left,_))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_strbind_opt(fn _ => let val 
rea__AND_strbind_opt as rea__AND_strbind_opt1=rea__AND_strbind_opt1 ()
 in (
 ( SOME(#1 rea__AND_strbind_opt)
				  , #2 rea__AND_strbind_opt ) )
 end
)
 in (LrTable.NT 94,(result,AND1left,rea__AND_strbind_opt1right),
rest671) end
| (267,(_,(MlyValue.AND_rea_opt__AND_strbind_opt 
AND_rea_opt__AND_strbind_opt1,_,AND_rea_opt__AND_strbind_opt1right))::
(_,(MlyValue.appsigexp appsigexp1,appsigexp1left,_))::rest671) => let 
val result=MlyValue.sigexp__AND_rea_opt__AND_strbind_opt(fn _ => let 
val appsigexp as appsigexp1=appsigexp1 ()
val AND_rea_opt__AND_strbind_opt as AND_rea_opt__AND_strbind_opt1=
AND_rea_opt__AND_strbind_opt1 ()
 in (
 ( appsigexp
		          , #1 AND_rea_opt__AND_strbind_opt
			  , #2 AND_rea_opt__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 95,(result,appsigexp1left,
AND_rea_opt__AND_strbind_opt1right),rest671) end
| (268,(_,(MlyValue.sigexp sigexp1,_,sigexp1right))::(_,(_,COLON1left,
_))::rest671) => let val result=MlyValue.COLON_sigexp_opt(fn _ => let 
val sigexp as sigexp1=sigexp1 ()
 in ( SOME sigexp ) end
)
 in (LrTable.NT 96,(result,COLON1left,sigexp1right),rest671) end
| (269,rest671) => let val result=MlyValue.COLON_sigexp_opt(fn _ => (
 NONE ))
 in (LrTable.NT 96,(result,defaultPos,defaultPos),rest671) end
| (270,(_,(_,ANYleft as ANY1left,ANYright as ANY1right))::rest671) => 
let val result=MlyValue.atsigexp(fn _ => (
 ANYAtSigExp(I(ANYleft,ANYright)) ))
 in (LrTable.NT 97,(result,ANY1left,ANY1right),rest671) end
| (271,(_,(_,_,ENDright as END1right))::(_,(MlyValue.spec spec1,_,_))
::(_,(_,SIGleft as SIG1left,_))::rest671) => let val result=
MlyValue.atsigexp(fn _ => let val spec as spec1=spec1 ()
 in ( SIGAtSigExp(I(SIGleft,ENDright), spec) ) end
)
 in (LrTable.NT 97,(result,SIG1left,END1right),rest671) end
| (272,(_,(MlyValue.longsigid longsigid1,longsigidleft as 
longsigid1left,longsigidright as longsigid1right))::rest671) => let 
val result=MlyValue.atsigexp(fn _ => let val longsigid as longsigid1=
longsigid1 ()
 in (
 LONGSIGIDAtSigExp(I(longsigidleft,longsigidright),
					    longsigid) 
) end
)
 in (LrTable.NT 97,(result,longsigid1left,longsigid1right),rest671)
 end
| (273,(_,(_,_,ENDright as END1right))::(_,(MlyValue.sigexp sigexp1,_,
_))::_::(_,(MlyValue.dec dec1,_,_))::(_,(_,LETleft as LET1left,_))::
rest671) => let val result=MlyValue.atsigexp(fn _ => let val dec as 
dec1=dec1 ()
val sigexp as sigexp1=sigexp1 ()
 in ( LETAtSigExp(I(LETleft,ENDright), dec, sigexp) ) end
)
 in (LrTable.NT 97,(result,LET1left,END1right),rest671) end
| (274,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.sigexp sigexp1,
_,_))::(_,(_,LPARleft as LPAR1left,_))::rest671) => let val result=
MlyValue.atsigexp(fn _ => let val sigexp as sigexp1=sigexp1 ()
 in ( PARAtSigExp(I(LPARleft,RPARright), sigexp) ) end
)
 in (LrTable.NT 97,(result,LPAR1left,RPAR1right),rest671) end
| (275,(_,(MlyValue.atsigexp atsigexp1,atsigexpleft as atsigexp1left,
atsigexpright as atsigexp1right))::rest671) => let val result=
MlyValue.appsigexp(fn _ => let val atsigexp as atsigexp1=atsigexp1 ()
 in ( ATSIGEXPSigExp(I(atsigexpleft,atsigexpright),
					 atsigexp) )
 end
)
 in (LrTable.NT 98,(result,atsigexp1left,atsigexp1right),rest671) end
| (276,(_,(MlyValue.atstrexp atstrexp1,_,atstrexpright as 
atstrexp1right))::(_,(MlyValue.appsigexp appsigexp1,appsigexpleft as 
appsigexp1left,_))::rest671) => let val result=MlyValue.appsigexp(fn _
 => let val appsigexp as appsigexp1=appsigexp1 ()
val atstrexp as atstrexp1=atstrexp1 ()
 in (
 APPSigExp(I(appsigexpleft,atstrexpright),
				    appsigexp, atstrexp) 
) end
)
 in (LrTable.NT 98,(result,appsigexp1left,atstrexp1right),rest671) end
| (277,(_,(MlyValue.sigexp' sigexp'1,sigexp'1left,sigexp'1right))::
rest671) => let val result=MlyValue.sigexp(fn _ => let val sigexp' as 
sigexp'1=sigexp'1 ()
 in ( sigexp' ) end
)
 in (LrTable.NT 99,(result,sigexp'1left,sigexp'1right),rest671) end
| (278,(_,(MlyValue.sigexp sigexp1,_,sigexpright as sigexp1right))::_
::(_,(MlyValue.strpat strpat1,_,_))::(_,(_,FCTleft as FCT1left,_))::
rest671) => let val result=MlyValue.sigexp(fn _ => let val strpat as 
strpat1=strpat1 ()
val sigexp as sigexp1=sigexp1 ()
 in ( FCTSigExp(I(FCTleft,sigexpright), strpat, sigexp) ) end
)
 in (LrTable.NT 99,(result,FCT1left,sigexp1right),rest671) end
| (279,(_,(MlyValue.rea rea1,_,rearight as rea1right))::_::(_,(
MlyValue.sigexp sigexp1,sigexpleft as sigexp1left,_))::rest671) => 
let val result=MlyValue.sigexp(fn _ => let val sigexp as sigexp1=
sigexp1 ()
val rea as rea1=rea1 ()
 in ( WHEREREASigExp(I(sigexpleft,rearight),
					 sigexp, rea) ) end
)
 in (LrTable.NT 99,(result,sigexp1left,rea1right),rest671) end
| (280,(_,(MlyValue.appsigexp appsigexp1,appsigexp1left,
appsigexp1right))::rest671) => let val result=MlyValue.sigexp'(fn _
 => let val appsigexp as appsigexp1=appsigexp1 ()
 in ( appsigexp ) end
)
 in (LrTable.NT 100,(result,appsigexp1left,appsigexp1right),rest671)
 end
| (281,(_,(MlyValue.longstrid longstrid2,_,longstrid2right))::_::(_,(
MlyValue.longstrid longstrid1,_,_))::_::(_,(MlyValue.sigexp sigexp1,
sigexpleft as sigexp1left,_))::rest671) => let val result=
MlyValue.sigexp'(fn _ => let val sigexp as sigexp1=sigexp1 ()
val longstrid1=longstrid1 ()
val longstrid2=longstrid2 ()
 in (
 WHERELONGSTRIDSigExp(I(sigexpleft,longstrid2right),
					       sigexp, longstrid1, longstrid2) 
) end
)
 in (LrTable.NT 100,(result,sigexp1left,longstrid2right),rest671) end
| (282,(_,(MlyValue.sigexp__AND_sigbind_opt sigexp__AND_sigbind_opt1,_
,sigexp__AND_sigbind_optright as sigexp__AND_sigbind_opt1right))::_::(
_,(MlyValue.strpat_list0 strpat_list01,_,_))::(_,(MlyValue.sigid 
sigid1,sigidleft as sigid1left,_))::rest671) => let val result=
MlyValue.sigbind(fn _ => let val sigid as sigid1=sigid1 ()
val strpat_list0 as strpat_list01=strpat_list01 ()
val sigexp__AND_sigbind_opt as sigexp__AND_sigbind_opt1=
sigexp__AND_sigbind_opt1 ()
 in (
 SigBind(I(sigidleft,sigexp__AND_sigbind_optright),
				  sigid, strpat_list0,
				  #1 sigexp__AND_sigbind_opt,
				  #2 sigexp__AND_sigbind_opt) 
) end
)
 in (LrTable.NT 101,(result,sigid1left,sigexp__AND_sigbind_opt1right),
rest671) end
| (283,(_,(MlyValue.strpat_list1 strpat_list11,strpat_list11left,
strpat_list11right))::rest671) => let val result=MlyValue.strpat_list0
(fn _ => let val strpat_list1 as strpat_list11=strpat_list11 ()
 in ( strpat_list1 ) end
)
 in (LrTable.NT 102,(result,strpat_list11left,strpat_list11right),
rest671) end
| (284,rest671) => let val result=MlyValue.strpat_list0(fn _ => ( [] )
)
 in (LrTable.NT 102,(result,defaultPos,defaultPos),rest671) end
| (285,(_,(MlyValue.sigbind sigbind1,_,sigbind1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_sigbind_opt(fn _ => let 
val sigbind as sigbind1=sigbind1 ()
 in ( SOME sigbind ) end
)
 in (LrTable.NT 103,(result,AND1left,sigbind1right),rest671) end
| (286,rest671) => let val result=MlyValue.AND_sigbind_opt(fn _ => (
 NONE ))
 in (LrTable.NT 103,(result,defaultPos,defaultPos),rest671) end
| (287,(_,(MlyValue.AND_sigbind_opt AND_sigbind_opt1,_,
AND_sigbind_opt1right))::(_,(MlyValue.sigexp' sigexp'1,sigexp'1left,_)
)::rest671) => let val result=MlyValue.sigexp__AND_sigbind_opt(fn _
 => let val sigexp' as sigexp'1=sigexp'1 ()
val AND_sigbind_opt as AND_sigbind_opt1=AND_sigbind_opt1 ()
 in ( ( sigexp', AND_sigbind_opt ) ) end
)
 in (LrTable.NT 104,(result,sigexp'1left,AND_sigbind_opt1right),
rest671) end
| (288,(_,(MlyValue.sigexp__AND_sigbind_opt sigexp__AND_sigbind_opt1,_
,sigexp__AND_sigbind_optright as sigexp__AND_sigbind_opt1right))::_::(
_,(MlyValue.strpat strpat1,_,_))::(_,(_,FCTleft as FCT1left,_))::
rest671) => let val result=MlyValue.sigexp__AND_sigbind_opt(fn _ => 
let val strpat as strpat1=strpat1 ()
val sigexp__AND_sigbind_opt as sigexp__AND_sigbind_opt1=
sigexp__AND_sigbind_opt1 ()
 in (
 ( FCTSigExp(I(FCTleft,sigexp__AND_sigbind_optright),
				      strpat, #1 sigexp__AND_sigbind_opt)
			  , #2 sigexp__AND_sigbind_opt ) 
) end
)
 in (LrTable.NT 104,(result,FCT1left,sigexp__AND_sigbind_opt1right),
rest671) end
| (289,(_,(MlyValue.rea__AND_sigbind_opt rea__AND_sigbind_opt1,_,
rea__AND_sigbind_optright as rea__AND_sigbind_opt1right))::_::(_,(
MlyValue.sigexp sigexp1,sigexpleft as sigexp1left,_))::rest671) => 
let val result=MlyValue.sigexp__AND_sigbind_opt(fn _ => let val sigexp
 as sigexp1=sigexp1 ()
val rea__AND_sigbind_opt as rea__AND_sigbind_opt1=
rea__AND_sigbind_opt1 ()
 in (
 ( WHEREREASigExp(I(sigexpleft,
					     rea__AND_sigbind_optright),
					   sigexp, #1 rea__AND_sigbind_opt)
			  , #2 rea__AND_sigbind_opt ) 
) end
)
 in (LrTable.NT 104,(result,sigexp1left,rea__AND_sigbind_opt1right),
rest671) end
| (290,(_,(MlyValue.AND_rea_opt__AND_sigbind_opt 
AND_rea_opt__AND_sigbind_opt1,_,AND_rea_opt__AND_sigbind_optright as 
AND_rea_opt__AND_sigbind_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,VALleft as 
VAL1left,_))::rest671) => let val result=MlyValue.rea__AND_sigbind_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_sigbind_opt as AND_rea_opt__AND_sigbind_opt1=
AND_rea_opt__AND_sigbind_opt1 ()
 in (
 ( VALRea(I(VALleft,AND_rea_opt__AND_sigbind_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_sigbind_opt)
			  , #2 AND_rea_opt__AND_sigbind_opt ) 
) end
)
 in (LrTable.NT 105,(result,VAL1left,
AND_rea_opt__AND_sigbind_opt1right),rest671) end
| (291,(_,(MlyValue.AND_rea_opt__AND_sigbind_opt 
AND_rea_opt__AND_sigbind_opt1,_,AND_rea_opt__AND_sigbind_optright as 
AND_rea_opt__AND_sigbind_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,FUNleft as 
FUN1left,_))::rest671) => let val result=MlyValue.rea__AND_sigbind_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_sigbind_opt as AND_rea_opt__AND_sigbind_opt1=
AND_rea_opt__AND_sigbind_opt1 ()
 in (
 ( FUNRea(I(FUNleft,AND_rea_opt__AND_sigbind_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_sigbind_opt)
			  , #2 AND_rea_opt__AND_sigbind_opt ) 
) end
)
 in (LrTable.NT 105,(result,FUN1left,
AND_rea_opt__AND_sigbind_opt1right),rest671) end
| (292,(_,(MlyValue.AND_rea_opt__AND_sigbind_opt 
AND_rea_opt__AND_sigbind_opt1,_,AND_rea_opt__AND_sigbind_optright as 
AND_rea_opt__AND_sigbind_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,
CONSTRUCTORleft as CONSTRUCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_sigbind_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_sigbind_opt as AND_rea_opt__AND_sigbind_opt1=
AND_rea_opt__AND_sigbind_opt1 ()
 in (
 ( CONSTRUCTORRea(I(CONSTRUCTORleft,
					     AND_rea_opt__AND_sigbind_optright),
					   OP_opt1, longvid1, OP_opt2, longvid2,
				           #1 AND_rea_opt__AND_sigbind_opt)
			  , #2 AND_rea_opt__AND_sigbind_opt ) 
) end
)
 in (LrTable.NT 105,(result,CONSTRUCTOR1left,
AND_rea_opt__AND_sigbind_opt1right),rest671) end
| (293,(_,(MlyValue.AND_rea_opt__AND_sigbind_opt 
AND_rea_opt__AND_sigbind_opt1,_,AND_rea_opt__AND_sigbind_optright as 
AND_rea_opt__AND_sigbind_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,EXCEPTIONleft
 as EXCEPTION1left,_))::rest671) => let val result=
MlyValue.rea__AND_sigbind_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_sigbind_opt as AND_rea_opt__AND_sigbind_opt1=
AND_rea_opt__AND_sigbind_opt1 ()
 in (
 ( EXCEPTIONRea(I(EXCEPTIONleft,
					   AND_rea_opt__AND_sigbind_optright),
					 OP_opt1, longvid1, OP_opt2, longvid2,
					 #1 AND_rea_opt__AND_sigbind_opt)
			  , #2 AND_rea_opt__AND_sigbind_opt ) 
) end
)
 in (LrTable.NT 105,(result,EXCEPTION1left,
AND_rea_opt__AND_sigbind_opt1right),rest671) end
| (294,(_,(MlyValue.AND_rea_opt__AND_sigbind_opt 
AND_rea_opt__AND_sigbind_opt1,_,AND_rea_opt__AND_sigbind_optright as 
AND_rea_opt__AND_sigbind_opt1right))::(_,(MlyValue.ty ty1,_,_))::_::(_
,(MlyValue.longtycon longtycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1
,_,_))::(_,(_,TYPEleft as TYPE1left,_))::rest671) => let val result=
MlyValue.rea__AND_sigbind_opt(fn _ => let val tyvarseq as tyvarseq1=
tyvarseq1 ()
val longtycon as longtycon1=longtycon1 ()
val ty as ty1=ty1 ()
val AND_rea_opt__AND_sigbind_opt as AND_rea_opt__AND_sigbind_opt1=
AND_rea_opt__AND_sigbind_opt1 ()
 in (
 ( TYPERea(I(TYPEleft,
				      AND_rea_opt__AND_sigbind_optright),
				    tyvarseq, longtycon, ty,
				    #1 AND_rea_opt__AND_sigbind_opt)
			  , #2 AND_rea_opt__AND_sigbind_opt ) 
) end
)
 in (LrTable.NT 105,(result,TYPE1left,
AND_rea_opt__AND_sigbind_opt1right),rest671) end
| (295,(_,(MlyValue.AND_rea_opt__AND_sigbind_opt 
AND_rea_opt__AND_sigbind_opt1,_,AND_rea_opt__AND_sigbind_optright as 
AND_rea_opt__AND_sigbind_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,STRUCTUREleft as 
STRUCTURE1left,_))::rest671) => let val result=
MlyValue.rea__AND_sigbind_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_sigbind_opt as AND_rea_opt__AND_sigbind_opt1=
AND_rea_opt__AND_sigbind_opt1 ()
 in (
 ( STRUCTURERea(I(STRUCTUREleft,
					   AND_rea_opt__AND_sigbind_optright),
				         longstrid1, COLON_sigexp_opt,
					 longstrid2,
				         #1 AND_rea_opt__AND_sigbind_opt)
			  , #2 AND_rea_opt__AND_sigbind_opt ) 
) end
)
 in (LrTable.NT 105,(result,STRUCTURE1left,
AND_rea_opt__AND_sigbind_opt1right),rest671) end
| (296,(_,(MlyValue.AND_rea_opt__AND_sigbind_opt 
AND_rea_opt__AND_sigbind_opt1,_,AND_rea_opt__AND_sigbind_optright as 
AND_rea_opt__AND_sigbind_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,FUNCTORleft as 
FUNCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_sigbind_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_sigbind_opt as AND_rea_opt__AND_sigbind_opt1=
AND_rea_opt__AND_sigbind_opt1 ()
 in (
 ( FUNCTORRea(I(FUNCTORleft,
					 AND_rea_opt__AND_sigbind_optright),
				       longstrid1, COLON_sigexp_opt, longstrid2,
				       #1 AND_rea_opt__AND_sigbind_opt)
			  , #2 AND_rea_opt__AND_sigbind_opt ) 
) end
)
 in (LrTable.NT 105,(result,FUNCTOR1left,
AND_rea_opt__AND_sigbind_opt1right),rest671) end
| (297,(_,(MlyValue.sigexp__AND_rea_opt__AND_sigbind_opt 
sigexp__AND_rea_opt__AND_sigbind_opt1,_,
sigexp__AND_rea_opt__AND_sigbind_optright as 
sigexp__AND_rea_opt__AND_sigbind_opt1right))::_::(_,(
MlyValue.strpat_list0 strpat_list01,_,_))::(_,(MlyValue.longsigid 
longsigid1,_,_))::(_,(_,SIGNATUREleft as SIGNATURE1left,_))::rest671)
 => let val result=MlyValue.rea__AND_sigbind_opt(fn _ => let val 
longsigid as longsigid1=longsigid1 ()
val strpat_list0 as strpat_list01=strpat_list01 ()
val sigexp__AND_rea_opt__AND_sigbind_opt as 
sigexp__AND_rea_opt__AND_sigbind_opt1=
sigexp__AND_rea_opt__AND_sigbind_opt1 ()
 in (
 ( SIGNATURERea
				(I(SIGNATUREleft,
				   sigexp__AND_rea_opt__AND_sigbind_optright),
				 longsigid, strpat_list0,
				 #1 sigexp__AND_rea_opt__AND_sigbind_opt,
				 #2 sigexp__AND_rea_opt__AND_sigbind_opt)
			  , #3 sigexp__AND_rea_opt__AND_sigbind_opt ) 
) end
)
 in (LrTable.NT 105,(result,SIGNATURE1left,
sigexp__AND_rea_opt__AND_sigbind_opt1right),rest671) end
| (298,(_,(MlyValue.AND_sigbind_opt AND_sigbind_opt1,
AND_sigbind_opt1left,AND_sigbind_opt1right))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_sigbind_opt(fn _ => let val 
AND_sigbind_opt as AND_sigbind_opt1=AND_sigbind_opt1 ()
 in ( ( NONE, AND_sigbind_opt) ) end
)
 in (LrTable.NT 106,(result,AND_sigbind_opt1left,AND_sigbind_opt1right
),rest671) end
| (299,(_,(MlyValue.rea__AND_sigbind_opt rea__AND_sigbind_opt1,_,
rea__AND_sigbind_opt1right))::(_,(_,AND1left,_))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_sigbind_opt(fn _ => let val 
rea__AND_sigbind_opt as rea__AND_sigbind_opt1=rea__AND_sigbind_opt1 ()
 in (
 ( SOME(#1 rea__AND_sigbind_opt)
				  , #2 rea__AND_sigbind_opt ) )
 end
)
 in (LrTable.NT 106,(result,AND1left,rea__AND_sigbind_opt1right),
rest671) end
| (300,(_,(MlyValue.AND_rea_opt__AND_sigbind_opt 
AND_rea_opt__AND_sigbind_opt1,_,AND_rea_opt__AND_sigbind_opt1right))::
(_,(MlyValue.appsigexp appsigexp1,appsigexp1left,_))::rest671) => let 
val result=MlyValue.sigexp__AND_rea_opt__AND_sigbind_opt(fn _ => let 
val appsigexp as appsigexp1=appsigexp1 ()
val AND_rea_opt__AND_sigbind_opt as AND_rea_opt__AND_sigbind_opt1=
AND_rea_opt__AND_sigbind_opt1 ()
 in (
 ( appsigexp
		          , #1 AND_rea_opt__AND_sigbind_opt
			  , #2 AND_rea_opt__AND_sigbind_opt ) 
) end
)
 in (LrTable.NT 107,(result,appsigexp1left,
AND_rea_opt__AND_sigbind_opt1right),rest671) end
| (301,(_,(MlyValue.AND_rea_opt AND_rea_opt1,_,AND_rea_optright as 
AND_rea_opt1right))::(_,(MlyValue.longvid longvid2,_,_))::(_,(
MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid longvid1,_,_))
::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,VALleft as VAL1left,_))::
rest671) => let val result=MlyValue.rea(fn _ => let val OP_opt1=
OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt as AND_rea_opt1=AND_rea_opt1 ()
 in (
 VALRea(I(VALleft,AND_rea_optright),
				 OP_opt1, longvid1,
				 OP_opt2, longvid2, AND_rea_opt) 
) end
)
 in (LrTable.NT 108,(result,VAL1left,AND_rea_opt1right),rest671) end
| (302,(_,(MlyValue.AND_rea_opt AND_rea_opt1,_,AND_rea_optright as 
AND_rea_opt1right))::(_,(MlyValue.longvid longvid2,_,_))::(_,(
MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid longvid1,_,_))
::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,FUNleft as FUN1left,_))::
rest671) => let val result=MlyValue.rea(fn _ => let val OP_opt1=
OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt as AND_rea_opt1=AND_rea_opt1 ()
 in (
 FUNRea(I(FUNleft,AND_rea_optright),
				 OP_opt1, longvid1,
				 OP_opt2, longvid2, AND_rea_opt) 
) end
)
 in (LrTable.NT 108,(result,FUN1left,AND_rea_opt1right),rest671) end
| (303,(_,(MlyValue.AND_rea_opt AND_rea_opt1,_,AND_rea_optright as 
AND_rea_opt1right))::(_,(MlyValue.longvid longvid2,_,_))::(_,(
MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid longvid1,_,_))
::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,CONSTRUCTORleft as 
CONSTRUCTOR1left,_))::rest671) => let val result=MlyValue.rea(fn _ => 
let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt as AND_rea_opt1=AND_rea_opt1 ()
 in (
 CONSTRUCTORRea(I(CONSTRUCTORleft,AND_rea_optright),
					 OP_opt1, longvid1,
					 OP_opt2, longvid2, AND_rea_opt) 
) end
)
 in (LrTable.NT 108,(result,CONSTRUCTOR1left,AND_rea_opt1right),
rest671) end
| (304,(_,(MlyValue.AND_rea_opt AND_rea_opt1,_,AND_rea_optright as 
AND_rea_opt1right))::(_,(MlyValue.longvid longvid2,_,_))::(_,(
MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid longvid1,_,_))
::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,EXCEPTIONleft as 
EXCEPTION1left,_))::rest671) => let val result=MlyValue.rea(fn _ => 
let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt as AND_rea_opt1=AND_rea_opt1 ()
 in (
 EXCEPTIONRea(I(EXCEPTIONleft,AND_rea_optright),
					 OP_opt1, longvid1,
					 OP_opt2, longvid2, AND_rea_opt) 
) end
)
 in (LrTable.NT 108,(result,EXCEPTION1left,AND_rea_opt1right),rest671)
 end
| (305,(_,(MlyValue.AND_rea_opt AND_rea_opt1,_,AND_rea_optright as 
AND_rea_opt1right))::(_,(MlyValue.ty ty1,_,_))::_::(_,(
MlyValue.longtycon longtycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1,_
,_))::(_,(_,TYPEleft as TYPE1left,_))::rest671) => let val result=
MlyValue.rea(fn _ => let val tyvarseq as tyvarseq1=tyvarseq1 ()
val longtycon as longtycon1=longtycon1 ()
val ty as ty1=ty1 ()
val AND_rea_opt as AND_rea_opt1=AND_rea_opt1 ()
 in (
 TYPERea(I(TYPEleft,AND_rea_optright),
				  tyvarseq, longtycon, ty, AND_rea_opt) 
) end
)
 in (LrTable.NT 108,(result,TYPE1left,AND_rea_opt1right),rest671) end
| (306,(_,(MlyValue.AND_rea_opt AND_rea_opt1,_,AND_rea_optright as 
AND_rea_opt1right))::(_,(MlyValue.longstrid longstrid2,_,_))::_::(_,(
MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_,_))::(_,(
MlyValue.longstrid longstrid1,_,_))::(_,(_,STRUCTUREleft as 
STRUCTURE1left,_))::rest671) => let val result=MlyValue.rea(fn _ => 
let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt as AND_rea_opt1=AND_rea_opt1 ()
 in (
 STRUCTURERea(I(STRUCTUREleft,AND_rea_optright),
				       longstrid1, COLON_sigexp_opt, longstrid2,
				       AND_rea_opt) 
) end
)
 in (LrTable.NT 108,(result,STRUCTURE1left,AND_rea_opt1right),rest671)
 end
| (307,(_,(MlyValue.AND_rea_opt AND_rea_opt1,_,AND_rea_optright as 
AND_rea_opt1right))::(_,(MlyValue.longstrid longstrid2,_,_))::_::(_,(
MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_,_))::(_,(
MlyValue.longstrid longstrid1,_,_))::(_,(_,FUNCTORleft as FUNCTOR1left
,_))::rest671) => let val result=MlyValue.rea(fn _ => let val 
longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt as AND_rea_opt1=AND_rea_opt1 ()
 in (
 FUNCTORRea(I(FUNCTORleft,AND_rea_optright),
				     longstrid1, COLON_sigexp_opt, longstrid2,
				     AND_rea_opt) 
) end
)
 in (LrTable.NT 108,(result,FUNCTOR1left,AND_rea_opt1right),rest671)
 end
| (308,(_,(MlyValue.sigexp__AND_rea_opt sigexp__AND_rea_opt1,_,
sigexp__AND_rea_optright as sigexp__AND_rea_opt1right))::_::(_,(
MlyValue.strpat_list0 strpat_list01,_,_))::(_,(MlyValue.longsigid 
longsigid1,_,_))::(_,(_,SIGNATUREleft as SIGNATURE1left,_))::rest671)
 => let val result=MlyValue.rea(fn _ => let val longsigid as 
longsigid1=longsigid1 ()
val strpat_list0 as strpat_list01=strpat_list01 ()
val sigexp__AND_rea_opt as sigexp__AND_rea_opt1=sigexp__AND_rea_opt1 
()
 in (
 SIGNATURERea(I(SIGNATUREleft,
					 sigexp__AND_rea_optright),
				       longsigid, strpat_list0,
				       #1 sigexp__AND_rea_opt,
				       #2 sigexp__AND_rea_opt) 
) end
)
 in (LrTable.NT 108,(result,SIGNATURE1left,sigexp__AND_rea_opt1right),
rest671) end
| (309,(_,(MlyValue.rea rea1,_,rea1right))::(_,(_,AND1left,_))::
rest671) => let val result=MlyValue.AND_rea_opt(fn _ => let val rea
 as rea1=rea1 ()
 in ( SOME rea ) end
)
 in (LrTable.NT 109,(result,AND1left,rea1right),rest671) end
| (310,rest671) => let val result=MlyValue.AND_rea_opt(fn _ => ( NONE 
))
 in (LrTable.NT 109,(result,defaultPos,defaultPos),rest671) end
| (311,(_,(MlyValue.AND_rea_opt AND_rea_opt1,_,AND_rea_opt1right))::(_
,(MlyValue.appsigexp appsigexp1,appsigexp1left,_))::rest671) => let 
val result=MlyValue.sigexp__AND_rea_opt(fn _ => let val appsigexp as 
appsigexp1=appsigexp1 ()
val AND_rea_opt as AND_rea_opt1=AND_rea_opt1 ()
 in ( ( appsigexp, AND_rea_opt ) ) end
)
 in (LrTable.NT 110,(result,appsigexp1left,AND_rea_opt1right),rest671)
 end
| (312,(_,(MlyValue.strexp__AND_funbind_opt strexp__AND_funbind_opt1,_
,strexp__AND_funbind_optright as strexp__AND_funbind_opt1right))::_::(
_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_,_))::(_,(
MlyValue.strpat_list1 strpat_list11,_,_))::(_,(MlyValue.strid strid1,
stridleft as strid1left,_))::rest671) => let val result=
MlyValue.funbind(fn _ => let val strid as strid1=strid1 ()
val strpat_list1 as strpat_list11=strpat_list11 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val strexp__AND_funbind_opt as strexp__AND_funbind_opt1=
strexp__AND_funbind_opt1 ()
 in (
 TRANSFunBind(I(stridleft,
					 strexp__AND_funbind_optright),
				       strid, strpat_list1, COLON_sigexp_opt,
				       #1 strexp__AND_funbind_opt,
				       #2 strexp__AND_funbind_opt) 
) end
)
 in (LrTable.NT 111,(result,strid1left,strexp__AND_funbind_opt1right),
rest671) end
| (313,(_,(MlyValue.strexp__AND_funbind_opt strexp__AND_funbind_opt1,_
,strexp__AND_funbind_optright as strexp__AND_funbind_opt1right))::_::(
_,(MlyValue.sigexp sigexp1,_,_))::_::(_,(MlyValue.strpat_list1 
strpat_list11,_,_))::(_,(MlyValue.strid strid1,stridleft as strid1left
,_))::rest671) => let val result=MlyValue.funbind(fn _ => let val 
strid as strid1=strid1 ()
val strpat_list1 as strpat_list11=strpat_list11 ()
val sigexp as sigexp1=sigexp1 ()
val strexp__AND_funbind_opt as strexp__AND_funbind_opt1=
strexp__AND_funbind_opt1 ()
 in (
 OPAQFunBind(I(stridleft,strexp__AND_funbind_optright),
				      strid, strpat_list1, sigexp,
				      #1 strexp__AND_funbind_opt,
				      #2 strexp__AND_funbind_opt) 
) end
)
 in (LrTable.NT 111,(result,strid1left,strexp__AND_funbind_opt1right),
rest671) end
| (314,(_,(MlyValue.strpat strpat1,strpat1left,strpat1right))::rest671
) => let val result=MlyValue.strpat_list1(fn _ => let val strpat as 
strpat1=strpat1 ()
 in ( strpat::[] ) end
)
 in (LrTable.NT 112,(result,strpat1left,strpat1right),rest671) end
| (315,(_,(MlyValue.strpat_list1 strpat_list11,_,strpat_list11right))
::(_,(MlyValue.strpat strpat1,strpat1left,_))::rest671) => let val 
result=MlyValue.strpat_list1(fn _ => let val strpat as strpat1=strpat1
 ()
val strpat_list1 as strpat_list11=strpat_list11 ()
 in ( strpat::strpat_list1 ) end
)
 in (LrTable.NT 112,(result,strpat1left,strpat_list11right),rest671)
 end
| (316,(_,(MlyValue.funbind funbind1,_,funbind1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_funbind_opt(fn _ => let 
val funbind as funbind1=funbind1 ()
 in ( SOME funbind ) end
)
 in (LrTable.NT 113,(result,AND1left,funbind1right),rest671) end
| (317,rest671) => let val result=MlyValue.AND_funbind_opt(fn _ => (
 NONE ))
 in (LrTable.NT 113,(result,defaultPos,defaultPos),rest671) end
| (318,(_,(MlyValue.AND_funbind_opt AND_funbind_opt1,_,
AND_funbind_opt1right))::(_,(MlyValue.appstrexp appstrexp1,
appstrexp1left,_))::rest671) => let val result=
MlyValue.strexp__AND_funbind_opt(fn _ => let val appstrexp as 
appstrexp1=appstrexp1 ()
val AND_funbind_opt as AND_funbind_opt1=AND_funbind_opt1 ()
 in ( ( appstrexp, AND_funbind_opt ) ) end
)
 in (LrTable.NT 114,(result,appstrexp1left,AND_funbind_opt1right),
rest671) end
| (319,(_,(MlyValue.sigexp__AND_funbind_opt sigexp__AND_funbind_opt1,_
,sigexp__AND_funbind_optright as sigexp__AND_funbind_opt1right))::_::(
_,(MlyValue.strexp strexp1,strexpleft as strexp1left,_))::rest671) => 
let val result=MlyValue.strexp__AND_funbind_opt(fn _ => let val strexp
 as strexp1=strexp1 ()
val sigexp__AND_funbind_opt as sigexp__AND_funbind_opt1=
sigexp__AND_funbind_opt1 ()
 in (
 ( TRANSStrExp(I(strexpleft,
					  sigexp__AND_funbind_optright),
					strexp, #1 sigexp__AND_funbind_opt)
			  , #2 sigexp__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 114,(result,strexp1left,sigexp__AND_funbind_opt1right)
,rest671) end
| (320,(_,(MlyValue.sigexp__AND_funbind_opt sigexp__AND_funbind_opt1,_
,sigexp__AND_funbind_optright as sigexp__AND_funbind_opt1right))::_::(
_,(MlyValue.strexp strexp1,strexpleft as strexp1left,_))::rest671) => 
let val result=MlyValue.strexp__AND_funbind_opt(fn _ => let val strexp
 as strexp1=strexp1 ()
val sigexp__AND_funbind_opt as sigexp__AND_funbind_opt1=
sigexp__AND_funbind_opt1 ()
 in (
 ( OPAQStrExp(I(strexpleft,
					 sigexp__AND_funbind_optright),
				       strexp, #1 sigexp__AND_funbind_opt)
			  , #2 sigexp__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 114,(result,strexp1left,sigexp__AND_funbind_opt1right)
,rest671) end
| (321,(_,(MlyValue.strexp__AND_funbind_opt strexp__AND_funbind_opt1,_
,strexp__AND_funbind_optright as strexp__AND_funbind_opt1right))::_::(
_,(MlyValue.strpat strpat1,_,_))::(_,(_,FCTleft as FCT1left,_))::
rest671) => let val result=MlyValue.strexp__AND_funbind_opt(fn _ => 
let val strpat as strpat1=strpat1 ()
val strexp__AND_funbind_opt as strexp__AND_funbind_opt1=
strexp__AND_funbind_opt1 ()
 in (
 ( FCTStrExp(I(FCTleft,strexp__AND_funbind_optright),
				      strpat, #1 strexp__AND_funbind_opt)
			  , #2 strexp__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 114,(result,FCT1left,strexp__AND_funbind_opt1right),
rest671) end
| (322,(_,(MlyValue.sigexp__AND_funbind_opt sigexp__AND_funbind_opt1,_
,sigexp__AND_funbind_optright as sigexp__AND_funbind_opt1right))::_::(
_,(MlyValue.infexp infexp1,_,_))::(_,(_,UNPACKleft as UNPACK1left,_))
::rest671) => let val result=MlyValue.strexp__AND_funbind_opt(fn _ => 
let val infexp as infexp1=infexp1 ()
val sigexp__AND_funbind_opt as sigexp__AND_funbind_opt1=
sigexp__AND_funbind_opt1 ()
 in (
 ( UNPACKStrExp(I(UNPACKleft,
					   sigexp__AND_funbind_optright),
					 infexp, #1 sigexp__AND_funbind_opt)
			  , #2 sigexp__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 114,(result,UNPACK1left,sigexp__AND_funbind_opt1right)
,rest671) end
| (323,(_,(MlyValue.AND_funbind_opt AND_funbind_opt1,_,
AND_funbind_opt1right))::(_,(MlyValue.sigexp' sigexp'1,sigexp'1left,_)
)::rest671) => let val result=MlyValue.sigexp__AND_funbind_opt(fn _
 => let val sigexp' as sigexp'1=sigexp'1 ()
val AND_funbind_opt as AND_funbind_opt1=AND_funbind_opt1 ()
 in ( ( sigexp', AND_funbind_opt ) ) end
)
 in (LrTable.NT 115,(result,sigexp'1left,AND_funbind_opt1right),
rest671) end
| (324,(_,(MlyValue.sigexp__AND_funbind_opt sigexp__AND_funbind_opt1,_
,sigexp__AND_funbind_optright as sigexp__AND_funbind_opt1right))::_::(
_,(MlyValue.strpat strpat1,_,_))::(_,(_,FCTleft as FCT1left,_))::
rest671) => let val result=MlyValue.sigexp__AND_funbind_opt(fn _ => 
let val strpat as strpat1=strpat1 ()
val sigexp__AND_funbind_opt as sigexp__AND_funbind_opt1=
sigexp__AND_funbind_opt1 ()
 in (
 ( FCTSigExp(I(FCTleft,sigexp__AND_funbind_optright),
				      strpat, #1 sigexp__AND_funbind_opt)
			  , #2 sigexp__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 115,(result,FCT1left,sigexp__AND_funbind_opt1right),
rest671) end
| (325,(_,(MlyValue.rea__AND_funbind_opt rea__AND_funbind_opt1,_,
rea__AND_funbind_optright as rea__AND_funbind_opt1right))::_::(_,(
MlyValue.sigexp sigexp1,sigexpleft as sigexp1left,_))::rest671) => 
let val result=MlyValue.sigexp__AND_funbind_opt(fn _ => let val sigexp
 as sigexp1=sigexp1 ()
val rea__AND_funbind_opt as rea__AND_funbind_opt1=
rea__AND_funbind_opt1 ()
 in (
 ( WHEREREASigExp(I(sigexpleft,
					     rea__AND_funbind_optright),
					   sigexp, #1 rea__AND_funbind_opt)
			  , #2 rea__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 115,(result,sigexp1left,rea__AND_funbind_opt1right),
rest671) end
| (326,(_,(MlyValue.AND_rea_opt__AND_funbind_opt 
AND_rea_opt__AND_funbind_opt1,_,AND_rea_opt__AND_funbind_optright as 
AND_rea_opt__AND_funbind_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,VALleft as 
VAL1left,_))::rest671) => let val result=MlyValue.rea__AND_funbind_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_funbind_opt as AND_rea_opt__AND_funbind_opt1=
AND_rea_opt__AND_funbind_opt1 ()
 in (
 ( VALRea(I(VALleft,AND_rea_opt__AND_funbind_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_funbind_opt)
			  , #2 AND_rea_opt__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 116,(result,VAL1left,
AND_rea_opt__AND_funbind_opt1right),rest671) end
| (327,(_,(MlyValue.AND_rea_opt__AND_funbind_opt 
AND_rea_opt__AND_funbind_opt1,_,AND_rea_opt__AND_funbind_optright as 
AND_rea_opt__AND_funbind_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,FUNleft as 
FUN1left,_))::rest671) => let val result=MlyValue.rea__AND_funbind_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_funbind_opt as AND_rea_opt__AND_funbind_opt1=
AND_rea_opt__AND_funbind_opt1 ()
 in (
 ( FUNRea(I(FUNleft,AND_rea_opt__AND_funbind_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_funbind_opt)
			  , #2 AND_rea_opt__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 116,(result,FUN1left,
AND_rea_opt__AND_funbind_opt1right),rest671) end
| (328,(_,(MlyValue.AND_rea_opt__AND_funbind_opt 
AND_rea_opt__AND_funbind_opt1,_,AND_rea_opt__AND_funbind_optright as 
AND_rea_opt__AND_funbind_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,
CONSTRUCTORleft as CONSTRUCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_funbind_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_funbind_opt as AND_rea_opt__AND_funbind_opt1=
AND_rea_opt__AND_funbind_opt1 ()
 in (
 ( CONSTRUCTORRea(I(CONSTRUCTORleft,
					     AND_rea_opt__AND_funbind_optright),
					   OP_opt1, longvid1, OP_opt2, longvid2,
				           #1 AND_rea_opt__AND_funbind_opt)
			  , #2 AND_rea_opt__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 116,(result,CONSTRUCTOR1left,
AND_rea_opt__AND_funbind_opt1right),rest671) end
| (329,(_,(MlyValue.AND_rea_opt__AND_funbind_opt 
AND_rea_opt__AND_funbind_opt1,_,AND_rea_opt__AND_funbind_optright as 
AND_rea_opt__AND_funbind_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,EXCEPTIONleft
 as EXCEPTION1left,_))::rest671) => let val result=
MlyValue.rea__AND_funbind_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_funbind_opt as AND_rea_opt__AND_funbind_opt1=
AND_rea_opt__AND_funbind_opt1 ()
 in (
 ( EXCEPTIONRea(I(EXCEPTIONleft,
					   AND_rea_opt__AND_funbind_optright),
					 OP_opt1, longvid1, OP_opt2, longvid2,
					 #1 AND_rea_opt__AND_funbind_opt)
			  , #2 AND_rea_opt__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 116,(result,EXCEPTION1left,
AND_rea_opt__AND_funbind_opt1right),rest671) end
| (330,(_,(MlyValue.AND_rea_opt__AND_funbind_opt 
AND_rea_opt__AND_funbind_opt1,_,AND_rea_opt__AND_funbind_optright as 
AND_rea_opt__AND_funbind_opt1right))::(_,(MlyValue.ty ty1,_,_))::_::(_
,(MlyValue.longtycon longtycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1
,_,_))::(_,(_,TYPEleft as TYPE1left,_))::rest671) => let val result=
MlyValue.rea__AND_funbind_opt(fn _ => let val tyvarseq as tyvarseq1=
tyvarseq1 ()
val longtycon as longtycon1=longtycon1 ()
val ty as ty1=ty1 ()
val AND_rea_opt__AND_funbind_opt as AND_rea_opt__AND_funbind_opt1=
AND_rea_opt__AND_funbind_opt1 ()
 in (
 ( TYPERea(I(TYPEleft,
				      AND_rea_opt__AND_funbind_optright),
				    tyvarseq, longtycon, ty,
				    #1 AND_rea_opt__AND_funbind_opt)
			  , #2 AND_rea_opt__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 116,(result,TYPE1left,
AND_rea_opt__AND_funbind_opt1right),rest671) end
| (331,(_,(MlyValue.AND_rea_opt__AND_funbind_opt 
AND_rea_opt__AND_funbind_opt1,_,AND_rea_opt__AND_funbind_optright as 
AND_rea_opt__AND_funbind_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,STRUCTUREleft as 
STRUCTURE1left,_))::rest671) => let val result=
MlyValue.rea__AND_funbind_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_funbind_opt as AND_rea_opt__AND_funbind_opt1=
AND_rea_opt__AND_funbind_opt1 ()
 in (
 ( STRUCTURERea(I(STRUCTUREleft,
					   AND_rea_opt__AND_funbind_optright),
				         longstrid1, COLON_sigexp_opt,
					 longstrid2,
				         #1 AND_rea_opt__AND_funbind_opt)
			  , #2 AND_rea_opt__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 116,(result,STRUCTURE1left,
AND_rea_opt__AND_funbind_opt1right),rest671) end
| (332,(_,(MlyValue.AND_rea_opt__AND_funbind_opt 
AND_rea_opt__AND_funbind_opt1,_,AND_rea_opt__AND_funbind_optright as 
AND_rea_opt__AND_funbind_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,FUNCTORleft as 
FUNCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_funbind_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_funbind_opt as AND_rea_opt__AND_funbind_opt1=
AND_rea_opt__AND_funbind_opt1 ()
 in (
 ( FUNCTORRea(I(FUNCTORleft,
					 AND_rea_opt__AND_funbind_optright),
				       longstrid1, COLON_sigexp_opt, longstrid2,
				       #1 AND_rea_opt__AND_funbind_opt)
			  , #2 AND_rea_opt__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 116,(result,FUNCTOR1left,
AND_rea_opt__AND_funbind_opt1right),rest671) end
| (333,(_,(MlyValue.sigexp__AND_rea_opt__AND_funbind_opt 
sigexp__AND_rea_opt__AND_funbind_opt1,_,
sigexp__AND_rea_opt__AND_funbind_optright as 
sigexp__AND_rea_opt__AND_funbind_opt1right))::_::(_,(
MlyValue.strpat_list0 strpat_list01,_,_))::(_,(MlyValue.longsigid 
longsigid1,_,_))::(_,(_,SIGNATUREleft as SIGNATURE1left,_))::rest671)
 => let val result=MlyValue.rea__AND_funbind_opt(fn _ => let val 
longsigid as longsigid1=longsigid1 ()
val strpat_list0 as strpat_list01=strpat_list01 ()
val sigexp__AND_rea_opt__AND_funbind_opt as 
sigexp__AND_rea_opt__AND_funbind_opt1=
sigexp__AND_rea_opt__AND_funbind_opt1 ()
 in (
 ( SIGNATURERea
				(I(SIGNATUREleft,
				   sigexp__AND_rea_opt__AND_funbind_optright),
				 longsigid, strpat_list0,
				 #1 sigexp__AND_rea_opt__AND_funbind_opt,
				 #2 sigexp__AND_rea_opt__AND_funbind_opt)
			  , #3 sigexp__AND_rea_opt__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 116,(result,SIGNATURE1left,
sigexp__AND_rea_opt__AND_funbind_opt1right),rest671) end
| (334,(_,(MlyValue.AND_funbind_opt AND_funbind_opt1,
AND_funbind_opt1left,AND_funbind_opt1right))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_funbind_opt(fn _ => let val 
AND_funbind_opt as AND_funbind_opt1=AND_funbind_opt1 ()
 in ( ( NONE, AND_funbind_opt ) ) end
)
 in (LrTable.NT 117,(result,AND_funbind_opt1left,AND_funbind_opt1right
),rest671) end
| (335,(_,(MlyValue.rea__AND_funbind_opt rea__AND_funbind_opt1,_,
rea__AND_funbind_opt1right))::(_,(_,AND1left,_))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_funbind_opt(fn _ => let val 
rea__AND_funbind_opt as rea__AND_funbind_opt1=rea__AND_funbind_opt1 ()
 in (
 ( SOME(#1 rea__AND_funbind_opt)
			  , #2 rea__AND_funbind_opt ) )
 end
)
 in (LrTable.NT 117,(result,AND1left,rea__AND_funbind_opt1right),
rest671) end
| (336,(_,(MlyValue.AND_rea_opt__AND_funbind_opt 
AND_rea_opt__AND_funbind_opt1,_,AND_rea_opt__AND_funbind_opt1right))::
(_,(MlyValue.appsigexp appsigexp1,appsigexp1left,_))::rest671) => let 
val result=MlyValue.sigexp__AND_rea_opt__AND_funbind_opt(fn _ => let 
val appsigexp as appsigexp1=appsigexp1 ()
val AND_rea_opt__AND_funbind_opt as AND_rea_opt__AND_funbind_opt1=
AND_rea_opt__AND_funbind_opt1 ()
 in (
 ( appsigexp
		          , #1 AND_rea_opt__AND_funbind_opt
			  , #2 AND_rea_opt__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 118,(result,appsigexp1left,
AND_rea_opt__AND_funbind_opt1right),rest671) end
| (337,(_,(MlyValue.spec1 spec11,spec11left,spec11right))::rest671)
 => let val result=MlyValue.spec(fn _ => let val spec1 as spec11=
spec11 ()
 in ( spec1 ) end
)
 in (LrTable.NT 119,(result,spec11left,spec11right),rest671) end
| (338,rest671) => let val result=MlyValue.spec(fn _ => (
 EMPTYSpec(I(defaultPos,defaultPos)) ))
 in (LrTable.NT 119,(result,defaultPos,defaultPos),rest671) end
| (339,(_,(MlyValue.spec1' spec1'1,spec1'1left,spec1'1right))::rest671
) => let val result=MlyValue.spec1(fn _ => let val spec1' as spec1'1=
spec1'1 ()
 in ( spec1' ) end
)
 in (LrTable.NT 120,(result,spec1'1left,spec1'1right),rest671) end
| (340,(_,(MlyValue.spec1' spec1'1,_,spec1'right as spec1'1right))::(_
,(MlyValue.spec1 spec11,spec1left as spec11left,_))::rest671) => let 
val result=MlyValue.spec1(fn _ => let val spec1 as spec11=spec11 ()
val spec1' as spec1'1=spec1'1 ()
 in ( SEQSpec(I(spec1left,spec1'right), spec1, spec1') ) end
)
 in (LrTable.NT 120,(result,spec11left,spec1'1right),rest671) end
| (341,(_,(_,SEMICOLONleft as SEMICOLON1left,SEMICOLON1right))::
rest671) => let val result=MlyValue.spec1(fn _ => (
 EMPTYSpec(I(SEMICOLONleft,SEMICOLONleft)) ))
 in (LrTable.NT 120,(result,SEMICOLON1left,SEMICOLON1right),rest671)
 end
| (342,(_,(MlyValue.longtycon_EQUALS_list2 longtycon_EQUALS_list21,_,
longtycon_EQUALS_list2right as longtycon_EQUALS_list21right))::_::(_,(
_,SHARINGleft as SHARING1left,_))::rest671) => let val result=
MlyValue.spec1(fn _ => let val longtycon_EQUALS_list2 as 
longtycon_EQUALS_list21=longtycon_EQUALS_list21 ()
 in (
 SHARINGTYPESpec(I(SHARINGleft,
					    longtycon_EQUALS_list2right),
					  EMPTYSpec(I(SHARINGleft,SHARINGleft)),
					  longtycon_EQUALS_list2) 
) end
)
 in (LrTable.NT 120,(result,SHARING1left,longtycon_EQUALS_list21right)
,rest671) end
| (343,(_,(MlyValue.longtycon_EQUALS_list2 longtycon_EQUALS_list21,_,
longtycon_EQUALS_list2right as longtycon_EQUALS_list21right))::_::_::(
_,(MlyValue.spec1 spec11,spec1left as spec11left,_))::rest671) => let 
val result=MlyValue.spec1(fn _ => let val spec1 as spec11=spec11 ()
val longtycon_EQUALS_list2 as longtycon_EQUALS_list21=
longtycon_EQUALS_list21 ()
 in (
 SHARINGTYPESpec(I(spec1left,
					    longtycon_EQUALS_list2right),
					  spec1, longtycon_EQUALS_list2) 
) end
)
 in (LrTable.NT 120,(result,spec11left,longtycon_EQUALS_list21right),
rest671) end
| (344,(_,(MlyValue.longsigid_EQUALS_list2 longsigid_EQUALS_list21,_,
longsigid_EQUALS_list2right as longsigid_EQUALS_list21right))::_::(_,(
_,SHARINGleft as SHARING1left,_))::rest671) => let val result=
MlyValue.spec1(fn _ => let val longsigid_EQUALS_list2 as 
longsigid_EQUALS_list21=longsigid_EQUALS_list21 ()
 in (
 SHARINGSIGNATURESpec(I(SHARINGleft,
						 longsigid_EQUALS_list2right),
					       EMPTYSpec(I(SHARINGleft,
							   SHARINGleft)),
					       longsigid_EQUALS_list2) 
) end
)
 in (LrTable.NT 120,(result,SHARING1left,longsigid_EQUALS_list21right)
,rest671) end
| (345,(_,(MlyValue.longsigid_EQUALS_list2 longsigid_EQUALS_list21,_,
longsigid_EQUALS_list2right as longsigid_EQUALS_list21right))::_::_::(
_,(MlyValue.spec1 spec11,spec1left as spec11left,_))::rest671) => let 
val result=MlyValue.spec1(fn _ => let val spec1 as spec11=spec11 ()
val longsigid_EQUALS_list2 as longsigid_EQUALS_list21=
longsigid_EQUALS_list21 ()
 in (
 SHARINGSIGNATURESpec(I(spec1left,
						 longsigid_EQUALS_list2right),
					       spec1, longsigid_EQUALS_list2) 
) end
)
 in (LrTable.NT 120,(result,spec11left,longsigid_EQUALS_list21right),
rest671) end
| (346,(_,(MlyValue.longstrid_EQUALS_list2 longstrid_EQUALS_list21,_,
longstrid_EQUALS_list2right as longstrid_EQUALS_list21right))::(_,(_,
SHARINGleft as SHARING1left,_))::rest671) => let val result=
MlyValue.spec1(fn _ => let val longstrid_EQUALS_list2 as 
longstrid_EQUALS_list21=longstrid_EQUALS_list21 ()
 in (
 SHARINGSpec(I(SHARINGleft,
					longstrid_EQUALS_list2right),
				      EMPTYSpec(I(SHARINGleft,SHARINGleft)),
				      longstrid_EQUALS_list2) 
) end
)
 in (LrTable.NT 120,(result,SHARING1left,longstrid_EQUALS_list21right)
,rest671) end
| (347,(_,(MlyValue.longstrid_EQUALS_list2 longstrid_EQUALS_list21,_,
longstrid_EQUALS_list2right as longstrid_EQUALS_list21right))::_::(_,(
MlyValue.spec1 spec11,spec1left as spec11left,_))::rest671) => let 
val result=MlyValue.spec1(fn _ => let val spec1 as spec11=spec11 ()
val longstrid_EQUALS_list2 as longstrid_EQUALS_list21=
longstrid_EQUALS_list21 ()
 in (
 SHARINGSpec(I(spec1left,longstrid_EQUALS_list2right),
				      spec1, longstrid_EQUALS_list2) 
) end
)
 in (LrTable.NT 120,(result,spec11left,longstrid_EQUALS_list21right),
rest671) end
| (348,(_,(MlyValue.valdesc valdesc1,_,valdescright as valdesc1right))
::(_,(_,VALleft as VAL1left,_))::rest671) => let val result=
MlyValue.spec1'(fn _ => let val valdesc as valdesc1=valdesc1 ()
 in ( VALSpec(I(VALleft,valdescright), valdesc) ) end
)
 in (LrTable.NT 121,(result,VAL1left,valdesc1right),rest671) end
| (349,(_,(MlyValue.valdesc valdesc1,_,valdescright as valdesc1right))
::(_,(_,FUNleft as FUN1left,_))::rest671) => let val result=
MlyValue.spec1'(fn _ => let val valdesc as valdesc1=valdesc1 ()
 in ( FUNSpec(I(FUNleft,valdescright), valdesc) ) end
)
 in (LrTable.NT 121,(result,FUN1left,valdesc1right),rest671) end
| (350,(_,(MlyValue.typdesc typdesc1,_,typdescright as typdesc1right))
::(_,(_,TYPEleft as TYPE1left,_))::rest671) => let val result=
MlyValue.spec1'(fn _ => let val typdesc as typdesc1=typdesc1 ()
 in ( TYPESpec(I(TYPEleft,typdescright), typdesc) ) end
)
 in (LrTable.NT 121,(result,TYPE1left,typdesc1right),rest671) end
| (351,(_,(MlyValue.typdesc typdesc1,_,typdescright as typdesc1right))
::(_,(_,EQTYPEleft as EQTYPE1left,_))::rest671) => let val result=
MlyValue.spec1'(fn _ => let val typdesc as typdesc1=typdesc1 ()
 in ( EQTYPESpec(I(EQTYPEleft,typdescright), typdesc) ) end
)
 in (LrTable.NT 121,(result,EQTYPE1left,typdesc1right),rest671) end
| (352,(_,(MlyValue.typdesc typdesc1,_,typdescright as typdesc1right))
::(_,(_,EQEQTYPEleft as EQEQTYPE1left,_))::rest671) => let val result=
MlyValue.spec1'(fn _ => let val typdesc as typdesc1=typdesc1 ()
 in ( EQEQTYPESpec(I(EQEQTYPEleft,typdescright), typdesc) ) end
)
 in (LrTable.NT 121,(result,EQEQTYPE1left,typdesc1right),rest671) end
| (353,(_,(MlyValue.WITHTYPE_typdesc_opt WITHTYPE_typdesc_opt1,_,
WITHTYPE_typdesc_optright as WITHTYPE_typdesc_opt1right))::(_,(
MlyValue.datdesc0 datdesc01,_,_))::(_,(_,DATATYPEleft as DATATYPE1left
,_))::rest671) => let val result=MlyValue.spec1'(fn _ => let val 
datdesc0 as datdesc01=datdesc01 ()
val WITHTYPE_typdesc_opt as WITHTYPE_typdesc_opt1=
WITHTYPE_typdesc_opt1 ()
 in (
 DATATYPESpec(I(DATATYPEleft,
					 WITHTYPE_typdesc_optright),
				       datdesc0, WITHTYPE_typdesc_opt) 
) end
)
 in (LrTable.NT 121,(result,DATATYPE1left,WITHTYPE_typdesc_opt1right),
rest671) end
| (354,(_,(MlyValue.WITHTYPE_typdesc_opt WITHTYPE_typdesc_opt1,_,
WITHTYPE_typdesc_optright as WITHTYPE_typdesc_opt1right))::(_,(
MlyValue.datdesc1 datdesc11,_,_))::(_,(_,DATATYPEleft as DATATYPE1left
,_))::rest671) => let val result=MlyValue.spec1'(fn _ => let val 
datdesc1 as datdesc11=datdesc11 ()
val WITHTYPE_typdesc_opt as WITHTYPE_typdesc_opt1=
WITHTYPE_typdesc_opt1 ()
 in (
 DATATYPESpec(I(DATATYPEleft,
					 WITHTYPE_typdesc_optright),
				       datdesc1, WITHTYPE_typdesc_opt) 
) end
)
 in (LrTable.NT 121,(result,DATATYPE1left,WITHTYPE_typdesc_opt1right),
rest671) end
| (355,(_,(MlyValue.longtycon longtycon1,_,longtyconright as 
longtycon1right))::_::_::(_,(MlyValue.tycon tycon1,_,_))::(_,(_,
DATATYPEleft as DATATYPE1left,_))::rest671) => let val result=
MlyValue.spec1'(fn _ => let val tycon as tycon1=tycon1 ()
val longtycon as longtycon1=longtycon1 ()
 in (
 REPLICATIONSpec(I(DATATYPEleft,longtyconright),
					  tycon, longtycon) 
) end
)
 in (LrTable.NT 121,(result,DATATYPE1left,longtycon1right),rest671)
 end
| (356,(_,(MlyValue.dcondesc dcondesc1,_,dcondescright as 
dcondesc1right))::(_,(_,CONSTRUCTORleft as CONSTRUCTOR1left,_))::
rest671) => let val result=MlyValue.spec1'(fn _ => let val dcondesc
 as dcondesc1=dcondesc1 ()
 in (
 CONSTRUCTORSpec(I(CONSTRUCTORleft,dcondescright),
					  dcondesc) )
 end
)
 in (LrTable.NT 121,(result,CONSTRUCTOR1left,dcondesc1right),rest671)
 end
| (357,(_,(MlyValue.exdesc exdesc1,_,exdescright as exdesc1right))::(_
,(_,EXCEPTIONleft as EXCEPTION1left,_))::rest671) => let val result=
MlyValue.spec1'(fn _ => let val exdesc as exdesc1=exdesc1 ()
 in ( EXCEPTIONSpec(I(EXCEPTIONleft,exdescright), exdesc) ) end
)
 in (LrTable.NT 121,(result,EXCEPTION1left,exdesc1right),rest671) end
| (358,(_,(MlyValue.strdesc strdesc1,_,strdescright as strdesc1right))
::(_,(_,STRUCTUREleft as STRUCTURE1left,_))::rest671) => let val 
result=MlyValue.spec1'(fn _ => let val strdesc as strdesc1=strdesc1 ()
 in ( STRUCTURESpec(I(STRUCTUREleft,strdescright), strdesc)) end
)
 in (LrTable.NT 121,(result,STRUCTURE1left,strdesc1right),rest671) end
| (359,(_,(MlyValue.sigdesc sigdesc1,_,sigdescright as sigdesc1right))
::(_,(_,SIGNATUREleft as SIGNATURE1left,_))::rest671) => let val 
result=MlyValue.spec1'(fn _ => let val sigdesc as sigdesc1=sigdesc1 ()
 in ( SIGNATURESpec(I(SIGNATUREleft,sigdescright), sigdesc)) end
)
 in (LrTable.NT 121,(result,SIGNATURE1left,sigdesc1right),rest671) end
| (360,(_,(MlyValue.fundesc fundesc1,_,fundescright as fundesc1right))
::(_,(_,FUNCTORleft as FUNCTOR1left,_))::rest671) => let val result=
MlyValue.spec1'(fn _ => let val fundesc as fundesc1=fundesc1 ()
 in ( FUNCTORSpec(I(FUNCTORleft,fundescright), fundesc)) end
)
 in (LrTable.NT 121,(result,FUNCTOR1left,fundesc1right),rest671) end
| (361,(_,(MlyValue.sigexp sigexp1,_,sigexpright as sigexp1right))::(_
,(_,INCLUDEleft as INCLUDE1left,_))::rest671) => let val result=
MlyValue.spec1'(fn _ => let val sigexp as sigexp1=sigexp1 ()
 in ( INCLUDESpec(I(INCLUDEleft,sigexpright), sigexp) ) end
)
 in (LrTable.NT 121,(result,INCLUDE1left,sigexp1right),rest671) end
| (362,(_,(MlyValue.strid strid1,_,stridright as strid1right))::(_,(_,
PREBOUNDleft as PREBOUND1left,_))::rest671) => let val result=
MlyValue.spec1'(fn _ => let val strid as strid1=strid1 ()
 in ( PREBOUNDSpec(I(PREBOUNDleft,stridright), strid) ) end
)
 in (LrTable.NT 121,(result,PREBOUND1left,strid1right),rest671) end
| (363,(_,(MlyValue.ty ty1,_,tyright as ty1right))::_::(_,(
MlyValue.tyvar tyvar1,_,_))::_::(_,(MlyValue.vid vid1,_,_))::(_,(
MlyValue.OP_opt OP_opt1,_,_))::(_,(_,OVERLOADleft as OVERLOAD1left,_))
::rest671) => let val result=MlyValue.spec1'(fn _ => let val OP_opt
 as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val tyvar as tyvar1=tyvar1 ()
val ty as ty1=ty1 ()
 in (
 OVERLOADSpec(I(OVERLOADleft,tyright),
				       OP_opt, vid, tyvar, ty)
) end
)
 in (LrTable.NT 121,(result,OVERLOAD1left,ty1right),rest671) end
| (364,(_,(MlyValue.longvid longvid1,_,longvidright as longvid1right))
::_::(_,(MlyValue.longtycon longtycon1,_,_))::_::(_,(MlyValue.vid vid1
,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,INSTANCEleft as 
INSTANCE1left,_))::rest671) => let val result=MlyValue.spec1'(fn _ => 
let val OP_opt as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val longtycon as longtycon1=longtycon1 ()
val longvid as longvid1=longvid1 ()
 in (
 INSTANCESpec(I(INSTANCEleft,longvidright),
				       OP_opt, vid, longtycon, longvid) 
) end
)
 in (LrTable.NT 121,(result,INSTANCE1left,longvid1right),rest671) end
| (365,(_,(MlyValue.longtycon longtycon1,_,longtyconright as 
longtycon1right))::_::(_,(MlyValue.scon scon1,_,_))::(_,(_,
INSTANCEleft as INSTANCE1left,_))::rest671) => let val result=
MlyValue.spec1'(fn _ => let val scon as scon1=scon1 ()
val longtycon as longtycon1=longtycon1 ()
 in (
 INSTANCESCONSpec(I(INSTANCEleft,longtyconright),
					   scon, longtycon) 
) end
)
 in (LrTable.NT 121,(result,INSTANCE1left,longtycon1right),rest671)
 end
| (366,(_,(MlyValue.vid_list1 vid_list11,_,vid_list1right as 
vid_list11right))::(_,(MlyValue.d_opt d_opt1,_,_))::(_,(_,INFIXleft
 as INFIX1left,_))::rest671) => let val result=MlyValue.spec1'(fn _
 => let val d_opt as d_opt1=d_opt1 ()
val vid_list1 as vid_list11=vid_list11 ()
 in (
 INFIXMULTISpec(I(INFIXleft,vid_list1right), d_opt,
					 vid_list1) )
 end
)
 in (LrTable.NT 121,(result,INFIX1left,vid_list11right),rest671) end
| (367,(_,(MlyValue.vid_list1 vid_list11,_,vid_list1right as 
vid_list11right))::(_,(MlyValue.d_opt d_opt1,_,_))::(_,(_,INFIXRleft
 as INFIXR1left,_))::rest671) => let val result=MlyValue.spec1'(fn _
 => let val d_opt as d_opt1=d_opt1 ()
val vid_list1 as vid_list11=vid_list11 ()
 in (
 INFIXRMULTISpec(I(INFIXRleft,vid_list1right), d_opt,
					  vid_list1) 
) end
)
 in (LrTable.NT 121,(result,INFIXR1left,vid_list11right),rest671) end
| (368,(_,(MlyValue.vid_list1 vid_list11,_,vid_list1right as 
vid_list11right))::(_,(_,NONFIXleft as NONFIX1left,_))::rest671) => 
let val result=MlyValue.spec1'(fn _ => let val vid_list1 as vid_list11
=vid_list11 ()
 in ( NONFIXMULTISpec(I(NONFIXleft,vid_list1right),
					  vid_list1) 
) end
)
 in (LrTable.NT 121,(result,NONFIX1left,vid_list11right),rest671) end
| (369,(_,(MlyValue.typdesc typdesc1,_,typdesc1right))::(_,(_,
WITHTYPE1left,_))::rest671) => let val result=
MlyValue.WITHTYPE_typdesc_opt(fn _ => let val typdesc as typdesc1=
typdesc1 ()
 in ( SOME typdesc ) end
)
 in (LrTable.NT 122,(result,WITHTYPE1left,typdesc1right),rest671) end
| (370,rest671) => let val result=MlyValue.WITHTYPE_typdesc_opt(fn _
 => ( NONE ))
 in (LrTable.NT 122,(result,defaultPos,defaultPos),rest671) end
| (371,(_,(MlyValue.longtycon_EQUALS_list1 longtycon_EQUALS_list11,_,
longtycon_EQUALS_list11right))::_::(_,(MlyValue.longtycon longtycon1,
longtycon1left,_))::rest671) => let val result=
MlyValue.longtycon_EQUALS_list1(fn _ => let val longtycon as 
longtycon1=longtycon1 ()
val longtycon_EQUALS_list1 as longtycon_EQUALS_list11=
longtycon_EQUALS_list11 ()
 in ( longtycon::longtycon_EQUALS_list1 ) end
)
 in (LrTable.NT 123,(result,longtycon1left,
longtycon_EQUALS_list11right),rest671) end
| (372,(_,(MlyValue.longtycon longtycon1,longtycon1left,
longtycon1right))::rest671) => let val result=
MlyValue.longtycon_EQUALS_list1(fn _ => let val longtycon as 
longtycon1=longtycon1 ()
 in ( longtycon::[] ) end
)
 in (LrTable.NT 123,(result,longtycon1left,longtycon1right),rest671)
 end
| (373,(_,(MlyValue.longtycon_EQUALS_list1 longtycon_EQUALS_list11,_,
longtycon_EQUALS_list11right))::_::(_,(MlyValue.longtycon longtycon1,
longtycon1left,_))::rest671) => let val result=
MlyValue.longtycon_EQUALS_list2(fn _ => let val longtycon as 
longtycon1=longtycon1 ()
val longtycon_EQUALS_list1 as longtycon_EQUALS_list11=
longtycon_EQUALS_list11 ()
 in ( longtycon::longtycon_EQUALS_list1 ) end
)
 in (LrTable.NT 124,(result,longtycon1left,
longtycon_EQUALS_list11right),rest671) end
| (374,(_,(MlyValue.longsigid_EQUALS_list1 longsigid_EQUALS_list11,_,
longsigid_EQUALS_list11right))::_::(_,(MlyValue.longsigid longsigid1,
longsigid1left,_))::rest671) => let val result=
MlyValue.longsigid_EQUALS_list1(fn _ => let val longsigid as 
longsigid1=longsigid1 ()
val longsigid_EQUALS_list1 as longsigid_EQUALS_list11=
longsigid_EQUALS_list11 ()
 in ( longsigid::longsigid_EQUALS_list1 ) end
)
 in (LrTable.NT 125,(result,longsigid1left,
longsigid_EQUALS_list11right),rest671) end
| (375,(_,(MlyValue.longsigid longsigid1,longsigid1left,
longsigid1right))::rest671) => let val result=
MlyValue.longsigid_EQUALS_list1(fn _ => let val longsigid as 
longsigid1=longsigid1 ()
 in ( longsigid::[] ) end
)
 in (LrTable.NT 125,(result,longsigid1left,longsigid1right),rest671)
 end
| (376,(_,(MlyValue.longsigid_EQUALS_list1 longsigid_EQUALS_list11,_,
longsigid_EQUALS_list11right))::_::(_,(MlyValue.longsigid longsigid1,
longsigid1left,_))::rest671) => let val result=
MlyValue.longsigid_EQUALS_list2(fn _ => let val longsigid as 
longsigid1=longsigid1 ()
val longsigid_EQUALS_list1 as longsigid_EQUALS_list11=
longsigid_EQUALS_list11 ()
 in ( longsigid::longsigid_EQUALS_list1 ) end
)
 in (LrTable.NT 126,(result,longsigid1left,
longsigid_EQUALS_list11right),rest671) end
| (377,(_,(MlyValue.longstrid_EQUALS_list1 longstrid_EQUALS_list11,_,
longstrid_EQUALS_list11right))::_::(_,(MlyValue.longstrid longstrid1,
longstrid1left,_))::rest671) => let val result=
MlyValue.longstrid_EQUALS_list1(fn _ => let val longstrid as 
longstrid1=longstrid1 ()
val longstrid_EQUALS_list1 as longstrid_EQUALS_list11=
longstrid_EQUALS_list11 ()
 in ( longstrid::longstrid_EQUALS_list1 ) end
)
 in (LrTable.NT 127,(result,longstrid1left,
longstrid_EQUALS_list11right),rest671) end
| (378,(_,(MlyValue.longstrid longstrid1,longstrid1left,
longstrid1right))::rest671) => let val result=
MlyValue.longstrid_EQUALS_list1(fn _ => let val longstrid as 
longstrid1=longstrid1 ()
 in ( longstrid::[] ) end
)
 in (LrTable.NT 127,(result,longstrid1left,longstrid1right),rest671)
 end
| (379,(_,(MlyValue.longstrid_EQUALS_list1 longstrid_EQUALS_list11,_,
longstrid_EQUALS_list11right))::_::(_,(MlyValue.longstrid longstrid1,
longstrid1left,_))::rest671) => let val result=
MlyValue.longstrid_EQUALS_list2(fn _ => let val longstrid as 
longstrid1=longstrid1 ()
val longstrid_EQUALS_list1 as longstrid_EQUALS_list11=
longstrid_EQUALS_list11 ()
 in ( longstrid::longstrid_EQUALS_list1 ) end
)
 in (LrTable.NT 128,(result,longstrid1left,
longstrid_EQUALS_list11right),rest671) end
| (380,(_,(MlyValue.AND_valdesc_opt AND_valdesc_opt1,_,
AND_valdesc_optright as AND_valdesc_opt1right))::(_,(MlyValue.ty ty1,_
,_))::_::(_,(MlyValue.vid vid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,
OP_optleft as OP_opt1left,_))::rest671) => let val result=
MlyValue.valdesc(fn _ => let val OP_opt as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val ty as ty1=ty1 ()
val AND_valdesc_opt as AND_valdesc_opt1=AND_valdesc_opt1 ()
 in (
 NEWValDesc(I(OP_optleft,AND_valdesc_optright),
				  OP_opt, vid, ty, AND_valdesc_opt) 
) end
)
 in (LrTable.NT 129,(result,OP_opt1left,AND_valdesc_opt1right),rest671
) end
| (381,(_,(MlyValue.AND_valdesc_opt AND_valdesc_opt1,_,
AND_valdesc_optright as AND_valdesc_opt1right))::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.vid
 vid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,OP_opt1left,_))::rest671) => 
let val result=MlyValue.valdesc(fn _ => let val OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val OP_opt2=OP_opt2 ()
val longvid as longvid1=longvid1 ()
val AND_valdesc_opt as AND_valdesc_opt1=AND_valdesc_opt1 ()
 in (
 EQUALValDesc(I(OP_opt1left,AND_valdesc_optright),
				       OP_opt1, vid,
				       OP_opt2, longvid, AND_valdesc_opt) 
) end
)
 in (LrTable.NT 129,(result,OP_opt1left,AND_valdesc_opt1right),rest671
) end
| (382,(_,(MlyValue.valdesc valdesc1,_,valdesc1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_valdesc_opt(fn _ => let 
val valdesc as valdesc1=valdesc1 ()
 in ( SOME valdesc ) end
)
 in (LrTable.NT 130,(result,AND1left,valdesc1right),rest671) end
| (383,rest671) => let val result=MlyValue.AND_valdesc_opt(fn _ => (
 NONE ))
 in (LrTable.NT 130,(result,defaultPos,defaultPos),rest671) end
| (384,(_,(MlyValue.AND_typdesc_opt AND_typdesc_opt1,_,
AND_typdesc_optright as AND_typdesc_opt1right))::(_,(MlyValue.tycon 
tycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1,tyvarseqleft as 
tyvarseq1left,_))::rest671) => let val result=MlyValue.typdesc(fn _
 => let val tyvarseq as tyvarseq1=tyvarseq1 ()
val tycon as tycon1=tycon1 ()
val AND_typdesc_opt as AND_typdesc_opt1=AND_typdesc_opt1 ()
 in (
 NEWTypDesc(I(tyvarseqleft,AND_typdesc_optright),
				     tyvarseq, tycon, AND_typdesc_opt) 
) end
)
 in (LrTable.NT 131,(result,tyvarseq1left,AND_typdesc_opt1right),
rest671) end
| (385,(_,(MlyValue.AND_typdesc_opt AND_typdesc_opt1,_,
AND_typdesc_optright as AND_typdesc_opt1right))::(_,(MlyValue.ty ty1,_
,_))::_::(_,(MlyValue.tycon tycon1,_,_))::(_,(MlyValue.tyvarseq 
tyvarseq1,tyvarseqleft as tyvarseq1left,_))::rest671) => let val 
result=MlyValue.typdesc(fn _ => let val tyvarseq as tyvarseq1=
tyvarseq1 ()
val tycon as tycon1=tycon1 ()
val ty as ty1=ty1 ()
val AND_typdesc_opt as AND_typdesc_opt1=AND_typdesc_opt1 ()
 in (
 EQUALTypDesc(I(tyvarseqleft,AND_typdesc_optright),
				       tyvarseq, tycon, ty, AND_typdesc_opt) 
) end
)
 in (LrTable.NT 131,(result,tyvarseq1left,AND_typdesc_opt1right),
rest671) end
| (386,(_,(MlyValue.typdesc typdesc1,_,typdesc1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_typdesc_opt(fn _ => let 
val typdesc as typdesc1=typdesc1 ()
 in ( SOME typdesc ) end
)
 in (LrTable.NT 132,(result,AND1left,typdesc1right),rest671) end
| (387,rest671) => let val result=MlyValue.AND_typdesc_opt(fn _ => (
 NONE ))
 in (LrTable.NT 132,(result,defaultPos,defaultPos),rest671) end
| (388,(_,(MlyValue.AND_datdesc_opt AND_datdesc_opt1,_,
AND_datdesc_optright as AND_datdesc_opt1right))::(_,(MlyValue.tycon 
tycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1,tyvarseqleft as 
tyvarseq1left,_))::rest671) => let val result=MlyValue.datdesc(fn _
 => let val tyvarseq as tyvarseq1=tyvarseq1 ()
val tycon as tycon1=tycon1 ()
val AND_datdesc_opt as AND_datdesc_opt1=AND_datdesc_opt1 ()
 in (
 OPENDatDesc(I(tyvarseqleft,AND_datdesc_optright),
				      tyvarseq, tycon, AND_datdesc_opt) 
) end
)
 in (LrTable.NT 133,(result,tyvarseq1left,AND_datdesc_opt1right),
rest671) end
| (389,(_,(MlyValue.AND_datdesc_opt AND_datdesc_opt1,_,
AND_datdesc_optright as AND_datdesc_opt1right))::(_,(MlyValue.condesc 
condesc1,_,_))::_::(_,(MlyValue.tycon tycon1,_,_))::(_,(
MlyValue.tyvarseq tyvarseq1,tyvarseqleft as tyvarseq1left,_))::rest671
) => let val result=MlyValue.datdesc(fn _ => let val tyvarseq as 
tyvarseq1=tyvarseq1 ()
val tycon as tycon1=tycon1 ()
val condesc as condesc1=condesc1 ()
val AND_datdesc_opt as AND_datdesc_opt1=AND_datdesc_opt1 ()
 in (
 CLOSEDDatDesc(I(tyvarseqleft,AND_datdesc_optright),
				     tyvarseq, tycon, condesc, AND_datdesc_opt)
) end
)
 in (LrTable.NT 133,(result,tyvarseq1left,AND_datdesc_opt1right),
rest671) end
| (390,(_,(MlyValue.AND_datdesc_opt AND_datdesc_opt1,_,
AND_datdesc_optright as AND_datdesc_opt1right))::(_,(MlyValue.tycon 
tycon1,tyconleft as tycon1left,_))::rest671) => let val result=
MlyValue.datdesc0(fn _ => let val tycon as tycon1=tycon1 ()
val AND_datdesc_opt as AND_datdesc_opt1=AND_datdesc_opt1 ()
 in (
 OPENDatDesc(I(tyconleft,AND_datdesc_optright),
				      Seq(I(defaultPos,defaultPos), []),
				      tycon, AND_datdesc_opt) 
) end
)
 in (LrTable.NT 134,(result,tycon1left,AND_datdesc_opt1right),rest671)
 end
| (391,(_,(MlyValue.AND_datdesc_opt AND_datdesc_opt1,_,
AND_datdesc_optright as AND_datdesc_opt1right))::(_,(MlyValue.condesc 
condesc1,_,_))::_::(_,(MlyValue.tycon tycon1,tyconleft as tycon1left,_
))::rest671) => let val result=MlyValue.datdesc0(fn _ => let val tycon
 as tycon1=tycon1 ()
val condesc as condesc1=condesc1 ()
val AND_datdesc_opt as AND_datdesc_opt1=AND_datdesc_opt1 ()
 in (
 CLOSEDDatDesc(I(tyconleft,AND_datdesc_optright),
	  				Seq(I(defaultPos,defaultPos), []),
					tycon, condesc, AND_datdesc_opt) 
) end
)
 in (LrTable.NT 134,(result,tycon1left,AND_datdesc_opt1right),rest671)
 end
| (392,(_,(MlyValue.AND_datdesc_opt AND_datdesc_opt1,_,
AND_datdesc_optright as AND_datdesc_opt1right))::(_,(MlyValue.tycon 
tycon1,_,_))::(_,(MlyValue.tyvarseq1 tyvarseq11,tyvarseq1left as 
tyvarseq11left,_))::rest671) => let val result=MlyValue.datdesc1(fn _
 => let val tyvarseq1 as tyvarseq11=tyvarseq11 ()
val tycon as tycon1=tycon1 ()
val AND_datdesc_opt as AND_datdesc_opt1=AND_datdesc_opt1 ()
 in (
 OPENDatDesc(I(tyvarseq1left,AND_datdesc_optright),
				      tyvarseq1, tycon, AND_datdesc_opt) 
) end
)
 in (LrTable.NT 135,(result,tyvarseq11left,AND_datdesc_opt1right),
rest671) end
| (393,(_,(MlyValue.AND_datdesc_opt AND_datdesc_opt1,_,
AND_datdesc_optright as AND_datdesc_opt1right))::(_,(MlyValue.condesc 
condesc1,_,_))::_::(_,(MlyValue.tycon tycon1,_,_))::(_,(
MlyValue.tyvarseq1 tyvarseq11,tyvarseq1left as tyvarseq11left,_))::
rest671) => let val result=MlyValue.datdesc1(fn _ => let val tyvarseq1
 as tyvarseq11=tyvarseq11 ()
val tycon as tycon1=tycon1 ()
val condesc as condesc1=condesc1 ()
val AND_datdesc_opt as AND_datdesc_opt1=AND_datdesc_opt1 ()
 in (
 CLOSEDDatDesc(I(tyvarseq1left,AND_datdesc_optright),
	  				tyvarseq1, tycon, condesc,
					AND_datdesc_opt) 
) end
)
 in (LrTable.NT 135,(result,tyvarseq11left,AND_datdesc_opt1right),
rest671) end
| (394,(_,(MlyValue.datdesc datdesc1,_,datdesc1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_datdesc_opt(fn _ => let 
val datdesc as datdesc1=datdesc1 ()
 in ( SOME datdesc ) end
)
 in (LrTable.NT 136,(result,AND1left,datdesc1right),rest671) end
| (395,rest671) => let val result=MlyValue.AND_datdesc_opt(fn _ => (
 NONE ))
 in (LrTable.NT 136,(result,defaultPos,defaultPos),rest671) end
| (396,(_,(MlyValue.BAR_condesc_opt BAR_condesc_opt1,_,
BAR_condesc_optright as BAR_condesc_opt1right))::(_,(
MlyValue.OF_ty_opt OF_ty_opt1,_,_))::(_,(MlyValue.vid vid1,_,_))::(_,(
MlyValue.OP_opt OP_opt1,OP_optleft as OP_opt1left,_))::rest671) => 
let val result=MlyValue.condesc(fn _ => let val OP_opt as OP_opt1=
OP_opt1 ()
val vid as vid1=vid1 ()
val OF_ty_opt as OF_ty_opt1=OF_ty_opt1 ()
val BAR_condesc_opt as BAR_condesc_opt1=BAR_condesc_opt1 ()
 in (
 ConDesc(I(OP_optleft,BAR_condesc_optright),
				  OP_opt, vid, OF_ty_opt, BAR_condesc_opt) 
) end
)
 in (LrTable.NT 137,(result,OP_opt1left,BAR_condesc_opt1right),rest671
) end
| (397,(_,(MlyValue.condesc condesc1,_,condesc1right))::(_,(_,BAR1left
,_))::rest671) => let val result=MlyValue.BAR_condesc_opt(fn _ => let 
val condesc as condesc1=condesc1 ()
 in ( SOME condesc ) end
)
 in (LrTable.NT 138,(result,BAR1left,condesc1right),rest671) end
| (398,rest671) => let val result=MlyValue.BAR_condesc_opt(fn _ => (
 NONE ))
 in (LrTable.NT 138,(result,defaultPos,defaultPos),rest671) end
| (399,(_,(MlyValue.AND_dcondesc_opt AND_dcondesc_opt1,_,
AND_dcondesc_optright as AND_dcondesc_opt1right))::(_,(
MlyValue.longtycon longtycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1,_
,_))::_::(_,(MlyValue.OF_ty_opt OF_ty_opt1,_,_))::(_,(MlyValue.vid 
vid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,OP_optleft as OP_opt1left,_))
::rest671) => let val result=MlyValue.dcondesc(fn _ => let val OP_opt
 as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val OF_ty_opt as OF_ty_opt1=OF_ty_opt1 ()
val tyvarseq as tyvarseq1=tyvarseq1 ()
val longtycon as longtycon1=longtycon1 ()
val AND_dcondesc_opt as AND_dcondesc_opt1=AND_dcondesc_opt1 ()
 in (
 NEWDconDesc(I(OP_optleft,AND_dcondesc_optright),
				      OP_opt, vid, OF_ty_opt,
				      tyvarseq, longtycon, AND_dcondesc_opt) 
) end
)
 in (LrTable.NT 139,(result,OP_opt1left,AND_dcondesc_opt1right),
rest671) end
| (400,(_,(MlyValue.AND_dcondesc_opt AND_dcondesc_opt1,_,
AND_dcondesc_optright as AND_dcondesc_opt1right))::(_,(
MlyValue.longvid longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_
::(_,(MlyValue.vid vid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,OP_opt1left
,_))::rest671) => let val result=MlyValue.dcondesc(fn _ => let val 
OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val OP_opt2=OP_opt2 ()
val longvid as longvid1=longvid1 ()
val AND_dcondesc_opt as AND_dcondesc_opt1=AND_dcondesc_opt1 ()
 in (
 EQUALDconDesc(I(OP_opt1left,AND_dcondesc_optright),
					OP_opt1, vid,
					OP_opt2, longvid, AND_dcondesc_opt) 
) end
)
 in (LrTable.NT 139,(result,OP_opt1left,AND_dcondesc_opt1right),
rest671) end
| (401,(_,(MlyValue.dcondesc dcondesc1,_,dcondesc1right))::(_,(_,
AND1left,_))::rest671) => let val result=MlyValue.AND_dcondesc_opt(fn 
_ => let val dcondesc as dcondesc1=dcondesc1 ()
 in ( SOME dcondesc ) end
)
 in (LrTable.NT 140,(result,AND1left,dcondesc1right),rest671) end
| (402,rest671) => let val result=MlyValue.AND_dcondesc_opt(fn _ => (
 NONE ))
 in (LrTable.NT 140,(result,defaultPos,defaultPos),rest671) end
| (403,(_,(MlyValue.AND_exdesc_opt AND_exdesc_opt1,_,
AND_exdesc_optright as AND_exdesc_opt1right))::(_,(MlyValue.OF_ty_opt 
OF_ty_opt1,_,_))::(_,(MlyValue.vid vid1,_,_))::(_,(MlyValue.OP_opt 
OP_opt1,OP_optleft as OP_opt1left,_))::rest671) => let val result=
MlyValue.exdesc(fn _ => let val OP_opt as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val OF_ty_opt as OF_ty_opt1=OF_ty_opt1 ()
val AND_exdesc_opt as AND_exdesc_opt1=AND_exdesc_opt1 ()
 in (
 NEWExDesc(I(OP_optleft,AND_exdesc_optright),
	  			    OP_opt, vid, OF_ty_opt, AND_exdesc_opt) 
) end
)
 in (LrTable.NT 141,(result,OP_opt1left,AND_exdesc_opt1right),rest671)
 end
| (404,(_,(MlyValue.AND_exdesc_opt AND_exdesc_opt1,_,
AND_exdesc_optright as AND_exdesc_opt1right))::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.vid
 vid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,OP_opt1left,_))::rest671) => 
let val result=MlyValue.exdesc(fn _ => let val OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val OP_opt2=OP_opt2 ()
val longvid as longvid1=longvid1 ()
val AND_exdesc_opt as AND_exdesc_opt1=AND_exdesc_opt1 ()
 in (
 EQUALExDesc(I(OP_opt1left,AND_exdesc_optright),
				      OP_opt1, vid,
				      OP_opt2, longvid, AND_exdesc_opt) 
) end
)
 in (LrTable.NT 141,(result,OP_opt1left,AND_exdesc_opt1right),rest671)
 end
| (405,(_,(MlyValue.exdesc exdesc1,_,exdesc1right))::(_,(_,AND1left,_)
)::rest671) => let val result=MlyValue.AND_exdesc_opt(fn _ => let val 
exdesc as exdesc1=exdesc1 ()
 in ( SOME exdesc ) end
)
 in (LrTable.NT 142,(result,AND1left,exdesc1right),rest671) end
| (406,rest671) => let val result=MlyValue.AND_exdesc_opt(fn _ => (
 NONE ))
 in (LrTable.NT 142,(result,defaultPos,defaultPos),rest671) end
| (407,(_,(MlyValue.sigexp__AND_strdesc_opt sigexp__AND_strdesc_opt1,_
,sigexp__AND_strdesc_optright as sigexp__AND_strdesc_opt1right))::_::(
_,(MlyValue.strid strid1,stridleft as strid1left,_))::rest671) => let 
val result=MlyValue.strdesc(fn _ => let val strid as strid1=strid1 ()
val sigexp__AND_strdesc_opt as sigexp__AND_strdesc_opt1=
sigexp__AND_strdesc_opt1 ()
 in (
 NEWStrDesc(I(stridleft,sigexp__AND_strdesc_optright),
				     strid, #1 sigexp__AND_strdesc_opt,
				     #2 sigexp__AND_strdesc_opt) 
) end
)
 in (LrTable.NT 143,(result,strid1left,sigexp__AND_strdesc_opt1right),
rest671) end
| (408,(_,(MlyValue.AND_strdesc_opt AND_strdesc_opt1,_,
AND_strdesc_optright as AND_strdesc_opt1right))::(_,(
MlyValue.longstrid longstrid1,_,_))::_::(_,(MlyValue.COLON_sigexp_opt 
COLON_sigexp_opt1,_,_))::(_,(MlyValue.strid strid1,stridleft as 
strid1left,_))::rest671) => let val result=MlyValue.strdesc(fn _ => 
let val strid as strid1=strid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid as longstrid1=longstrid1 ()
val AND_strdesc_opt as AND_strdesc_opt1=AND_strdesc_opt1 ()
 in (
 EQUALStrDesc(I(stridleft,AND_strdesc_optright),
				       strid, COLON_sigexp_opt, longstrid,
				       AND_strdesc_opt) 
) end
)
 in (LrTable.NT 143,(result,strid1left,AND_strdesc_opt1right),rest671)
 end
| (409,(_,(MlyValue.strdesc strdesc1,_,strdesc1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_strdesc_opt(fn _ => let 
val strdesc as strdesc1=strdesc1 ()
 in ( SOME strdesc ) end
)
 in (LrTable.NT 144,(result,AND1left,strdesc1right),rest671) end
| (410,rest671) => let val result=MlyValue.AND_strdesc_opt(fn _ => (
 NONE ))
 in (LrTable.NT 144,(result,defaultPos,defaultPos),rest671) end
| (411,(_,(MlyValue.AND_strdesc_opt AND_strdesc_opt1,_,
AND_strdesc_opt1right))::(_,(MlyValue.sigexp' sigexp'1,sigexp'1left,_)
)::rest671) => let val result=MlyValue.sigexp__AND_strdesc_opt(fn _
 => let val sigexp' as sigexp'1=sigexp'1 ()
val AND_strdesc_opt as AND_strdesc_opt1=AND_strdesc_opt1 ()
 in ( ( sigexp', AND_strdesc_opt ) ) end
)
 in (LrTable.NT 145,(result,sigexp'1left,AND_strdesc_opt1right),
rest671) end
| (412,(_,(MlyValue.sigexp__AND_strdesc_opt sigexp__AND_strdesc_opt1,_
,sigexp__AND_strdesc_optright as sigexp__AND_strdesc_opt1right))::_::(
_,(MlyValue.strpat strpat1,_,_))::(_,(_,FCTleft as FCT1left,_))::
rest671) => let val result=MlyValue.sigexp__AND_strdesc_opt(fn _ => 
let val strpat as strpat1=strpat1 ()
val sigexp__AND_strdesc_opt as sigexp__AND_strdesc_opt1=
sigexp__AND_strdesc_opt1 ()
 in (
 ( FCTSigExp(I(FCTleft,sigexp__AND_strdesc_optright),
				      strpat, #1 sigexp__AND_strdesc_opt)
			  , #2 sigexp__AND_strdesc_opt ) 
) end
)
 in (LrTable.NT 145,(result,FCT1left,sigexp__AND_strdesc_opt1right),
rest671) end
| (413,(_,(MlyValue.rea__AND_strdesc_opt rea__AND_strdesc_opt1,_,
rea__AND_strdesc_optright as rea__AND_strdesc_opt1right))::_::(_,(
MlyValue.sigexp sigexp1,sigexpleft as sigexp1left,_))::rest671) => 
let val result=MlyValue.sigexp__AND_strdesc_opt(fn _ => let val sigexp
 as sigexp1=sigexp1 ()
val rea__AND_strdesc_opt as rea__AND_strdesc_opt1=
rea__AND_strdesc_opt1 ()
 in (
 ( WHEREREASigExp(I(sigexpleft,
					     rea__AND_strdesc_optright),
					   sigexp, #1 rea__AND_strdesc_opt)
			  , #2 rea__AND_strdesc_opt ) 
) end
)
 in (LrTable.NT 145,(result,sigexp1left,rea__AND_strdesc_opt1right),
rest671) end
| (414,(_,(MlyValue.AND_rea_opt__AND_strdesc_opt 
AND_rea_opt__AND_strdesc_opt1,_,AND_rea_opt__AND_strdesc_optright as 
AND_rea_opt__AND_strdesc_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,VALleft as 
VAL1left,_))::rest671) => let val result=MlyValue.rea__AND_strdesc_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_strdesc_opt as AND_rea_opt__AND_strdesc_opt1=
AND_rea_opt__AND_strdesc_opt1 ()
 in (
 ( VALRea(I(VALleft,AND_rea_opt__AND_strdesc_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_strdesc_opt)
			  , #2 AND_rea_opt__AND_strdesc_opt ) 
) end
)
 in (LrTable.NT 146,(result,VAL1left,
AND_rea_opt__AND_strdesc_opt1right),rest671) end
| (415,(_,(MlyValue.AND_rea_opt__AND_strdesc_opt 
AND_rea_opt__AND_strdesc_opt1,_,AND_rea_opt__AND_strdesc_optright as 
AND_rea_opt__AND_strdesc_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,FUNleft as 
FUN1left,_))::rest671) => let val result=MlyValue.rea__AND_strdesc_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_strdesc_opt as AND_rea_opt__AND_strdesc_opt1=
AND_rea_opt__AND_strdesc_opt1 ()
 in (
 ( FUNRea(I(FUNleft,AND_rea_opt__AND_strdesc_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_strdesc_opt)
			  , #2 AND_rea_opt__AND_strdesc_opt ) 
) end
)
 in (LrTable.NT 146,(result,FUN1left,
AND_rea_opt__AND_strdesc_opt1right),rest671) end
| (416,(_,(MlyValue.AND_rea_opt__AND_strdesc_opt 
AND_rea_opt__AND_strdesc_opt1,_,AND_rea_opt__AND_strdesc_optright as 
AND_rea_opt__AND_strdesc_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,
CONSTRUCTORleft as CONSTRUCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_strdesc_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_strdesc_opt as AND_rea_opt__AND_strdesc_opt1=
AND_rea_opt__AND_strdesc_opt1 ()
 in (
 ( CONSTRUCTORRea(I(CONSTRUCTORleft,
					     AND_rea_opt__AND_strdesc_optright),
					   OP_opt1, longvid1, OP_opt2, longvid2,
				           #1 AND_rea_opt__AND_strdesc_opt)
			  , #2 AND_rea_opt__AND_strdesc_opt ) 
) end
)
 in (LrTable.NT 146,(result,CONSTRUCTOR1left,
AND_rea_opt__AND_strdesc_opt1right),rest671) end
| (417,(_,(MlyValue.AND_rea_opt__AND_strdesc_opt 
AND_rea_opt__AND_strdesc_opt1,_,AND_rea_opt__AND_strdesc_optright as 
AND_rea_opt__AND_strdesc_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,EXCEPTIONleft
 as EXCEPTION1left,_))::rest671) => let val result=
MlyValue.rea__AND_strdesc_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_strdesc_opt as AND_rea_opt__AND_strdesc_opt1=
AND_rea_opt__AND_strdesc_opt1 ()
 in (
 ( EXCEPTIONRea(I(EXCEPTIONleft,
					   AND_rea_opt__AND_strdesc_optright),
					 OP_opt1, longvid1, OP_opt2, longvid2,
					 #1 AND_rea_opt__AND_strdesc_opt)
			  , #2 AND_rea_opt__AND_strdesc_opt ) 
) end
)
 in (LrTable.NT 146,(result,EXCEPTION1left,
AND_rea_opt__AND_strdesc_opt1right),rest671) end
| (418,(_,(MlyValue.AND_rea_opt__AND_strdesc_opt 
AND_rea_opt__AND_strdesc_opt1,_,AND_rea_opt__AND_strdesc_optright as 
AND_rea_opt__AND_strdesc_opt1right))::(_,(MlyValue.ty ty1,_,_))::_::(_
,(MlyValue.longtycon longtycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1
,_,_))::(_,(_,TYPEleft as TYPE1left,_))::rest671) => let val result=
MlyValue.rea__AND_strdesc_opt(fn _ => let val tyvarseq as tyvarseq1=
tyvarseq1 ()
val longtycon as longtycon1=longtycon1 ()
val ty as ty1=ty1 ()
val AND_rea_opt__AND_strdesc_opt as AND_rea_opt__AND_strdesc_opt1=
AND_rea_opt__AND_strdesc_opt1 ()
 in (
 ( TYPERea(I(TYPEleft,
				      AND_rea_opt__AND_strdesc_optright),
				    tyvarseq, longtycon, ty,
				    #1 AND_rea_opt__AND_strdesc_opt)
			  , #2 AND_rea_opt__AND_strdesc_opt ) 
) end
)
 in (LrTable.NT 146,(result,TYPE1left,
AND_rea_opt__AND_strdesc_opt1right),rest671) end
| (419,(_,(MlyValue.AND_rea_opt__AND_strdesc_opt 
AND_rea_opt__AND_strdesc_opt1,_,AND_rea_opt__AND_strdesc_optright as 
AND_rea_opt__AND_strdesc_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,STRUCTUREleft as 
STRUCTURE1left,_))::rest671) => let val result=
MlyValue.rea__AND_strdesc_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_strdesc_opt as AND_rea_opt__AND_strdesc_opt1=
AND_rea_opt__AND_strdesc_opt1 ()
 in (
 ( STRUCTURERea(I(STRUCTUREleft,
					   AND_rea_opt__AND_strdesc_optright),
				         longstrid1, COLON_sigexp_opt,
					 longstrid2,
				         #1 AND_rea_opt__AND_strdesc_opt)
			  , #2 AND_rea_opt__AND_strdesc_opt ) 
) end
)
 in (LrTable.NT 146,(result,STRUCTURE1left,
AND_rea_opt__AND_strdesc_opt1right),rest671) end
| (420,(_,(MlyValue.AND_rea_opt__AND_strdesc_opt 
AND_rea_opt__AND_strdesc_opt1,_,AND_rea_opt__AND_strdesc_optright as 
AND_rea_opt__AND_strdesc_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,FUNCTORleft as 
FUNCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_strdesc_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_strdesc_opt as AND_rea_opt__AND_strdesc_opt1=
AND_rea_opt__AND_strdesc_opt1 ()
 in (
 ( FUNCTORRea(I(FUNCTORleft,
					 AND_rea_opt__AND_strdesc_optright),
				       longstrid1, COLON_sigexp_opt, longstrid2,
				       #1 AND_rea_opt__AND_strdesc_opt)
			  , #2 AND_rea_opt__AND_strdesc_opt ) 
) end
)
 in (LrTable.NT 146,(result,FUNCTOR1left,
AND_rea_opt__AND_strdesc_opt1right),rest671) end
| (421,(_,(MlyValue.sigexp__AND_rea_opt__AND_strdesc_opt 
sigexp__AND_rea_opt__AND_strdesc_opt1,_,
sigexp__AND_rea_opt__AND_strdesc_optright as 
sigexp__AND_rea_opt__AND_strdesc_opt1right))::_::(_,(
MlyValue.strpat_list0 strpat_list01,_,_))::(_,(MlyValue.longsigid 
longsigid1,_,_))::(_,(_,SIGNATUREleft as SIGNATURE1left,_))::rest671)
 => let val result=MlyValue.rea__AND_strdesc_opt(fn _ => let val 
longsigid as longsigid1=longsigid1 ()
val strpat_list0 as strpat_list01=strpat_list01 ()
val sigexp__AND_rea_opt__AND_strdesc_opt as 
sigexp__AND_rea_opt__AND_strdesc_opt1=
sigexp__AND_rea_opt__AND_strdesc_opt1 ()
 in (
 ( SIGNATURERea
				(I(SIGNATUREleft,
				   sigexp__AND_rea_opt__AND_strdesc_optright),
				 longsigid, strpat_list0,
				 #1 sigexp__AND_rea_opt__AND_strdesc_opt,
				 #2 sigexp__AND_rea_opt__AND_strdesc_opt)
			  , #3 sigexp__AND_rea_opt__AND_strdesc_opt ) 
) end
)
 in (LrTable.NT 146,(result,SIGNATURE1left,
sigexp__AND_rea_opt__AND_strdesc_opt1right),rest671) end
| (422,(_,(MlyValue.AND_strdesc_opt AND_strdesc_opt1,
AND_strdesc_opt1left,AND_strdesc_opt1right))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_strdesc_opt(fn _ => let val 
AND_strdesc_opt as AND_strdesc_opt1=AND_strdesc_opt1 ()
 in ( ( NONE, AND_strdesc_opt ) ) end
)
 in (LrTable.NT 147,(result,AND_strdesc_opt1left,AND_strdesc_opt1right
),rest671) end
| (423,(_,(MlyValue.rea__AND_strdesc_opt rea__AND_strdesc_opt1,_,
rea__AND_strdesc_opt1right))::(_,(_,AND1left,_))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_strdesc_opt(fn _ => let val 
rea__AND_strdesc_opt as rea__AND_strdesc_opt1=rea__AND_strdesc_opt1 ()
 in (
 ( SOME(#1 rea__AND_strdesc_opt)
				  , #2 rea__AND_strdesc_opt ) )
 end
)
 in (LrTable.NT 147,(result,AND1left,rea__AND_strdesc_opt1right),
rest671) end
| (424,(_,(MlyValue.AND_rea_opt__AND_strdesc_opt 
AND_rea_opt__AND_strdesc_opt1,_,AND_rea_opt__AND_strdesc_opt1right))::
(_,(MlyValue.appsigexp appsigexp1,appsigexp1left,_))::rest671) => let 
val result=MlyValue.sigexp__AND_rea_opt__AND_strdesc_opt(fn _ => let 
val appsigexp as appsigexp1=appsigexp1 ()
val AND_rea_opt__AND_strdesc_opt as AND_rea_opt__AND_strdesc_opt1=
AND_rea_opt__AND_strdesc_opt1 ()
 in (
 ( appsigexp
		          , #1 AND_rea_opt__AND_strdesc_opt
			  , #2 AND_rea_opt__AND_strdesc_opt ) 
) end
)
 in (LrTable.NT 148,(result,appsigexp1left,
AND_rea_opt__AND_strdesc_opt1right),rest671) end
| (425,(_,(MlyValue.AND_sigdesc_opt AND_sigdesc_opt1,_,
AND_sigdesc_optright as AND_sigdesc_opt1right))::(_,(
MlyValue.strpat_list0 strpat_list01,_,_))::(_,(MlyValue.sigid sigid1,
sigidleft as sigid1left,_))::rest671) => let val result=
MlyValue.sigdesc(fn _ => let val sigid as sigid1=sigid1 ()
val strpat_list0 as strpat_list01=strpat_list01 ()
val AND_sigdesc_opt as AND_sigdesc_opt1=AND_sigdesc_opt1 ()
 in (
 NEWSigDesc(I(sigidleft,AND_sigdesc_optright),
				     sigid, strpat_list0, AND_sigdesc_opt) 
) end
)
 in (LrTable.NT 149,(result,sigid1left,AND_sigdesc_opt1right),rest671)
 end
| (426,(_,(MlyValue.sigexp__AND_sigdesc_opt sigexp__AND_sigdesc_opt1,_
,sigexp__AND_sigdesc_optright as sigexp__AND_sigdesc_opt1right))::_::(
_,(MlyValue.strpat_list0 strpat_list01,_,_))::(_,(MlyValue.sigid 
sigid1,sigidleft as sigid1left,_))::rest671) => let val result=
MlyValue.sigdesc(fn _ => let val sigid as sigid1=sigid1 ()
val strpat_list0 as strpat_list01=strpat_list01 ()
val sigexp__AND_sigdesc_opt as sigexp__AND_sigdesc_opt1=
sigexp__AND_sigdesc_opt1 ()
 in (
 EQUALSigDesc(I(sigidleft,
					 sigexp__AND_sigdesc_optright),
				       sigid, strpat_list0,
				       #1 sigexp__AND_sigdesc_opt,
				       #2 sigexp__AND_sigdesc_opt) 
) end
)
 in (LrTable.NT 149,(result,sigid1left,sigexp__AND_sigdesc_opt1right),
rest671) end
| (427,(_,(MlyValue.sigdesc sigdesc1,_,sigdesc1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_sigdesc_opt(fn _ => let 
val sigdesc as sigdesc1=sigdesc1 ()
 in ( SOME sigdesc ) end
)
 in (LrTable.NT 150,(result,AND1left,sigdesc1right),rest671) end
| (428,rest671) => let val result=MlyValue.AND_sigdesc_opt(fn _ => (
 NONE ))
 in (LrTable.NT 150,(result,defaultPos,defaultPos),rest671) end
| (429,(_,(MlyValue.AND_sigdesc_opt AND_sigdesc_opt1,_,
AND_sigdesc_opt1right))::(_,(MlyValue.sigexp' sigexp'1,sigexp'1left,_)
)::rest671) => let val result=MlyValue.sigexp__AND_sigdesc_opt(fn _
 => let val sigexp' as sigexp'1=sigexp'1 ()
val AND_sigdesc_opt as AND_sigdesc_opt1=AND_sigdesc_opt1 ()
 in ( ( sigexp', AND_sigdesc_opt ) ) end
)
 in (LrTable.NT 151,(result,sigexp'1left,AND_sigdesc_opt1right),
rest671) end
| (430,(_,(MlyValue.sigexp__AND_sigdesc_opt sigexp__AND_sigdesc_opt1,_
,sigexp__AND_sigdesc_optright as sigexp__AND_sigdesc_opt1right))::_::(
_,(MlyValue.strpat strpat1,_,_))::(_,(_,FCTleft as FCT1left,_))::
rest671) => let val result=MlyValue.sigexp__AND_sigdesc_opt(fn _ => 
let val strpat as strpat1=strpat1 ()
val sigexp__AND_sigdesc_opt as sigexp__AND_sigdesc_opt1=
sigexp__AND_sigdesc_opt1 ()
 in (
 ( FCTSigExp(I(FCTleft,sigexp__AND_sigdesc_optright),
				      strpat, #1 sigexp__AND_sigdesc_opt)
			  , #2 sigexp__AND_sigdesc_opt ) 
) end
)
 in (LrTable.NT 151,(result,FCT1left,sigexp__AND_sigdesc_opt1right),
rest671) end
| (431,(_,(MlyValue.rea__AND_sigdesc_opt rea__AND_sigdesc_opt1,_,
rea__AND_sigdesc_optright as rea__AND_sigdesc_opt1right))::_::(_,(
MlyValue.sigexp sigexp1,sigexpleft as sigexp1left,_))::rest671) => 
let val result=MlyValue.sigexp__AND_sigdesc_opt(fn _ => let val sigexp
 as sigexp1=sigexp1 ()
val rea__AND_sigdesc_opt as rea__AND_sigdesc_opt1=
rea__AND_sigdesc_opt1 ()
 in (
 ( WHEREREASigExp(I(sigexpleft,
					     rea__AND_sigdesc_optright),
					   sigexp, #1 rea__AND_sigdesc_opt)
			  , #2 rea__AND_sigdesc_opt ) 
) end
)
 in (LrTable.NT 151,(result,sigexp1left,rea__AND_sigdesc_opt1right),
rest671) end
| (432,(_,(MlyValue.AND_rea_opt__AND_sigdesc_opt 
AND_rea_opt__AND_sigdesc_opt1,_,AND_rea_opt__AND_sigdesc_optright as 
AND_rea_opt__AND_sigdesc_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,VALleft as 
VAL1left,_))::rest671) => let val result=MlyValue.rea__AND_sigdesc_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_sigdesc_opt as AND_rea_opt__AND_sigdesc_opt1=
AND_rea_opt__AND_sigdesc_opt1 ()
 in (
 ( VALRea(I(VALleft,AND_rea_opt__AND_sigdesc_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_sigdesc_opt)
			  , #2 AND_rea_opt__AND_sigdesc_opt ) 
) end
)
 in (LrTable.NT 152,(result,VAL1left,
AND_rea_opt__AND_sigdesc_opt1right),rest671) end
| (433,(_,(MlyValue.AND_rea_opt__AND_sigdesc_opt 
AND_rea_opt__AND_sigdesc_opt1,_,AND_rea_opt__AND_sigdesc_optright as 
AND_rea_opt__AND_sigdesc_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,FUNleft as 
FUN1left,_))::rest671) => let val result=MlyValue.rea__AND_sigdesc_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_sigdesc_opt as AND_rea_opt__AND_sigdesc_opt1=
AND_rea_opt__AND_sigdesc_opt1 ()
 in (
 ( FUNRea(I(FUNleft,AND_rea_opt__AND_sigdesc_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_sigdesc_opt)
			  , #2 AND_rea_opt__AND_sigdesc_opt ) 
) end
)
 in (LrTable.NT 152,(result,FUN1left,
AND_rea_opt__AND_sigdesc_opt1right),rest671) end
| (434,(_,(MlyValue.AND_rea_opt__AND_sigdesc_opt 
AND_rea_opt__AND_sigdesc_opt1,_,AND_rea_opt__AND_sigdesc_optright as 
AND_rea_opt__AND_sigdesc_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,
CONSTRUCTORleft as CONSTRUCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_sigdesc_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_sigdesc_opt as AND_rea_opt__AND_sigdesc_opt1=
AND_rea_opt__AND_sigdesc_opt1 ()
 in (
 ( CONSTRUCTORRea(I(CONSTRUCTORleft,
					     AND_rea_opt__AND_sigdesc_optright),
					   OP_opt1, longvid1, OP_opt2, longvid2,
				           #1 AND_rea_opt__AND_sigdesc_opt)
			  , #2 AND_rea_opt__AND_sigdesc_opt ) 
) end
)
 in (LrTable.NT 152,(result,CONSTRUCTOR1left,
AND_rea_opt__AND_sigdesc_opt1right),rest671) end
| (435,(_,(MlyValue.AND_rea_opt__AND_sigdesc_opt 
AND_rea_opt__AND_sigdesc_opt1,_,AND_rea_opt__AND_sigdesc_optright as 
AND_rea_opt__AND_sigdesc_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,EXCEPTIONleft
 as EXCEPTION1left,_))::rest671) => let val result=
MlyValue.rea__AND_sigdesc_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_sigdesc_opt as AND_rea_opt__AND_sigdesc_opt1=
AND_rea_opt__AND_sigdesc_opt1 ()
 in (
 ( EXCEPTIONRea(I(EXCEPTIONleft,
					   AND_rea_opt__AND_sigdesc_optright),
					 OP_opt1, longvid1, OP_opt2, longvid2,
					 #1 AND_rea_opt__AND_sigdesc_opt)
			  , #2 AND_rea_opt__AND_sigdesc_opt ) 
) end
)
 in (LrTable.NT 152,(result,EXCEPTION1left,
AND_rea_opt__AND_sigdesc_opt1right),rest671) end
| (436,(_,(MlyValue.AND_rea_opt__AND_sigdesc_opt 
AND_rea_opt__AND_sigdesc_opt1,_,AND_rea_opt__AND_sigdesc_optright as 
AND_rea_opt__AND_sigdesc_opt1right))::(_,(MlyValue.ty ty1,_,_))::_::(_
,(MlyValue.longtycon longtycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1
,_,_))::(_,(_,TYPEleft as TYPE1left,_))::rest671) => let val result=
MlyValue.rea__AND_sigdesc_opt(fn _ => let val tyvarseq as tyvarseq1=
tyvarseq1 ()
val longtycon as longtycon1=longtycon1 ()
val ty as ty1=ty1 ()
val AND_rea_opt__AND_sigdesc_opt as AND_rea_opt__AND_sigdesc_opt1=
AND_rea_opt__AND_sigdesc_opt1 ()
 in (
 ( TYPERea(I(TYPEleft,
				      AND_rea_opt__AND_sigdesc_optright),
				    tyvarseq, longtycon, ty,
				    #1 AND_rea_opt__AND_sigdesc_opt)
			  , #2 AND_rea_opt__AND_sigdesc_opt ) 
) end
)
 in (LrTable.NT 152,(result,TYPE1left,
AND_rea_opt__AND_sigdesc_opt1right),rest671) end
| (437,(_,(MlyValue.AND_rea_opt__AND_sigdesc_opt 
AND_rea_opt__AND_sigdesc_opt1,_,AND_rea_opt__AND_sigdesc_optright as 
AND_rea_opt__AND_sigdesc_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,STRUCTUREleft as 
STRUCTURE1left,_))::rest671) => let val result=
MlyValue.rea__AND_sigdesc_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_sigdesc_opt as AND_rea_opt__AND_sigdesc_opt1=
AND_rea_opt__AND_sigdesc_opt1 ()
 in (
 ( STRUCTURERea(I(STRUCTUREleft,
					   AND_rea_opt__AND_sigdesc_optright),
				         longstrid1, COLON_sigexp_opt,
					 longstrid2,
				         #1 AND_rea_opt__AND_sigdesc_opt)
			  , #2 AND_rea_opt__AND_sigdesc_opt ) 
) end
)
 in (LrTable.NT 152,(result,STRUCTURE1left,
AND_rea_opt__AND_sigdesc_opt1right),rest671) end
| (438,(_,(MlyValue.AND_rea_opt__AND_sigdesc_opt 
AND_rea_opt__AND_sigdesc_opt1,_,AND_rea_opt__AND_sigdesc_optright as 
AND_rea_opt__AND_sigdesc_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,FUNCTORleft as 
FUNCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_sigdesc_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_sigdesc_opt as AND_rea_opt__AND_sigdesc_opt1=
AND_rea_opt__AND_sigdesc_opt1 ()
 in (
 ( FUNCTORRea(I(FUNCTORleft,
					 AND_rea_opt__AND_sigdesc_optright),
				       longstrid1, COLON_sigexp_opt, longstrid2,
				       #1 AND_rea_opt__AND_sigdesc_opt)
			  , #2 AND_rea_opt__AND_sigdesc_opt ) 
) end
)
 in (LrTable.NT 152,(result,FUNCTOR1left,
AND_rea_opt__AND_sigdesc_opt1right),rest671) end
| (439,(_,(MlyValue.sigexp__AND_rea_opt__AND_sigdesc_opt 
sigexp__AND_rea_opt__AND_sigdesc_opt1,_,
sigexp__AND_rea_opt__AND_sigdesc_optright as 
sigexp__AND_rea_opt__AND_sigdesc_opt1right))::_::(_,(
MlyValue.strpat_list0 strpat_list01,_,_))::(_,(MlyValue.longsigid 
longsigid1,_,_))::(_,(_,SIGNATUREleft as SIGNATURE1left,_))::rest671)
 => let val result=MlyValue.rea__AND_sigdesc_opt(fn _ => let val 
longsigid as longsigid1=longsigid1 ()
val strpat_list0 as strpat_list01=strpat_list01 ()
val sigexp__AND_rea_opt__AND_sigdesc_opt as 
sigexp__AND_rea_opt__AND_sigdesc_opt1=
sigexp__AND_rea_opt__AND_sigdesc_opt1 ()
 in (
 ( SIGNATURERea
				(I(SIGNATUREleft,
				   sigexp__AND_rea_opt__AND_sigdesc_optright),
				 longsigid, strpat_list0,
				 #1 sigexp__AND_rea_opt__AND_sigdesc_opt,
				 #2 sigexp__AND_rea_opt__AND_sigdesc_opt)
			  , #3 sigexp__AND_rea_opt__AND_sigdesc_opt ) 
) end
)
 in (LrTable.NT 152,(result,SIGNATURE1left,
sigexp__AND_rea_opt__AND_sigdesc_opt1right),rest671) end
| (440,(_,(MlyValue.AND_sigdesc_opt AND_sigdesc_opt1,
AND_sigdesc_opt1left,AND_sigdesc_opt1right))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_sigdesc_opt(fn _ => let val 
AND_sigdesc_opt as AND_sigdesc_opt1=AND_sigdesc_opt1 ()
 in ( ( NONE, AND_sigdesc_opt) ) end
)
 in (LrTable.NT 153,(result,AND_sigdesc_opt1left,AND_sigdesc_opt1right
),rest671) end
| (441,(_,(MlyValue.rea__AND_sigdesc_opt rea__AND_sigdesc_opt1,_,
rea__AND_sigdesc_opt1right))::(_,(_,AND1left,_))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_sigdesc_opt(fn _ => let val 
rea__AND_sigdesc_opt as rea__AND_sigdesc_opt1=rea__AND_sigdesc_opt1 ()
 in (
 ( SOME(#1 rea__AND_sigdesc_opt)
				  , #2 rea__AND_sigdesc_opt ) )
 end
)
 in (LrTable.NT 153,(result,AND1left,rea__AND_sigdesc_opt1right),
rest671) end
| (442,(_,(MlyValue.AND_rea_opt__AND_sigdesc_opt 
AND_rea_opt__AND_sigdesc_opt1,_,AND_rea_opt__AND_sigdesc_opt1right))::
(_,(MlyValue.appsigexp appsigexp1,appsigexp1left,_))::rest671) => let 
val result=MlyValue.sigexp__AND_rea_opt__AND_sigdesc_opt(fn _ => let 
val appsigexp as appsigexp1=appsigexp1 ()
val AND_rea_opt__AND_sigdesc_opt as AND_rea_opt__AND_sigdesc_opt1=
AND_rea_opt__AND_sigdesc_opt1 ()
 in (
 ( appsigexp
		          , #1 AND_rea_opt__AND_sigdesc_opt
			  , #2 AND_rea_opt__AND_sigdesc_opt ) 
) end
)
 in (LrTable.NT 154,(result,appsigexp1left,
AND_rea_opt__AND_sigdesc_opt1right),rest671) end
| (443,(_,(MlyValue.sigexp__AND_fundesc_opt sigexp__AND_fundesc_opt1,_
,sigexp__AND_fundesc_optright as sigexp__AND_fundesc_opt1right))::_::(
_,(MlyValue.strpat_list0 strpat_list01,_,_))::(_,(MlyValue.strid 
strid1,stridleft as strid1left,_))::rest671) => let val result=
MlyValue.fundesc(fn _ => let val strid as strid1=strid1 ()
val strpat_list0 as strpat_list01=strpat_list01 ()
val sigexp__AND_fundesc_opt as sigexp__AND_fundesc_opt1=
sigexp__AND_fundesc_opt1 ()
 in (
 FunDesc(I(stridleft,sigexp__AND_fundesc_optright),
				  strid, strpat_list0,
				  #1 sigexp__AND_fundesc_opt,
				  #2 sigexp__AND_fundesc_opt) 
) end
)
 in (LrTable.NT 155,(result,strid1left,sigexp__AND_fundesc_opt1right),
rest671) end
| (444,(_,(MlyValue.fundesc fundesc1,_,fundesc1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_fundesc_opt(fn _ => let 
val fundesc as fundesc1=fundesc1 ()
 in ( SOME fundesc ) end
)
 in (LrTable.NT 156,(result,AND1left,fundesc1right),rest671) end
| (445,rest671) => let val result=MlyValue.AND_fundesc_opt(fn _ => (
 NONE ))
 in (LrTable.NT 156,(result,defaultPos,defaultPos),rest671) end
| (446,(_,(MlyValue.AND_fundesc_opt AND_fundesc_opt1,_,
AND_fundesc_opt1right))::(_,(MlyValue.sigexp' sigexp'1,sigexp'1left,_)
)::rest671) => let val result=MlyValue.sigexp__AND_fundesc_opt(fn _
 => let val sigexp' as sigexp'1=sigexp'1 ()
val AND_fundesc_opt as AND_fundesc_opt1=AND_fundesc_opt1 ()
 in ( ( sigexp', AND_fundesc_opt ) ) end
)
 in (LrTable.NT 157,(result,sigexp'1left,AND_fundesc_opt1right),
rest671) end
| (447,(_,(MlyValue.sigexp__AND_fundesc_opt sigexp__AND_fundesc_opt1,_
,sigexp__AND_fundesc_optright as sigexp__AND_fundesc_opt1right))::_::(
_,(MlyValue.strpat strpat1,_,_))::(_,(_,FCTleft as FCT1left,_))::
rest671) => let val result=MlyValue.sigexp__AND_fundesc_opt(fn _ => 
let val strpat as strpat1=strpat1 ()
val sigexp__AND_fundesc_opt as sigexp__AND_fundesc_opt1=
sigexp__AND_fundesc_opt1 ()
 in (
 ( FCTSigExp(I(FCTleft,sigexp__AND_fundesc_optright),
				      strpat, #1 sigexp__AND_fundesc_opt)
			  , #2 sigexp__AND_fundesc_opt ) 
) end
)
 in (LrTable.NT 157,(result,FCT1left,sigexp__AND_fundesc_opt1right),
rest671) end
| (448,(_,(MlyValue.rea__AND_fundesc_opt rea__AND_fundesc_opt1,_,
rea__AND_fundesc_optright as rea__AND_fundesc_opt1right))::_::(_,(
MlyValue.sigexp sigexp1,sigexpleft as sigexp1left,_))::rest671) => 
let val result=MlyValue.sigexp__AND_fundesc_opt(fn _ => let val sigexp
 as sigexp1=sigexp1 ()
val rea__AND_fundesc_opt as rea__AND_fundesc_opt1=
rea__AND_fundesc_opt1 ()
 in (
 ( WHEREREASigExp(I(sigexpleft,
					     rea__AND_fundesc_optright),
					   sigexp, #1 rea__AND_fundesc_opt)
			  , #2 rea__AND_fundesc_opt ) 
) end
)
 in (LrTable.NT 157,(result,sigexp1left,rea__AND_fundesc_opt1right),
rest671) end
| (449,(_,(MlyValue.AND_rea_opt__AND_fundesc_opt 
AND_rea_opt__AND_fundesc_opt1,_,AND_rea_opt__AND_fundesc_optright as 
AND_rea_opt__AND_fundesc_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,VALleft as 
VAL1left,_))::rest671) => let val result=MlyValue.rea__AND_fundesc_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_fundesc_opt as AND_rea_opt__AND_fundesc_opt1=
AND_rea_opt__AND_fundesc_opt1 ()
 in (
 ( VALRea(I(VALleft,AND_rea_opt__AND_fundesc_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_fundesc_opt)
			  , #2 AND_rea_opt__AND_fundesc_opt ) 
) end
)
 in (LrTable.NT 158,(result,VAL1left,
AND_rea_opt__AND_fundesc_opt1right),rest671) end
| (450,(_,(MlyValue.AND_rea_opt__AND_fundesc_opt 
AND_rea_opt__AND_fundesc_opt1,_,AND_rea_opt__AND_fundesc_optright as 
AND_rea_opt__AND_fundesc_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,FUNleft as 
FUN1left,_))::rest671) => let val result=MlyValue.rea__AND_fundesc_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_fundesc_opt as AND_rea_opt__AND_fundesc_opt1=
AND_rea_opt__AND_fundesc_opt1 ()
 in (
 ( FUNRea(I(FUNleft,AND_rea_opt__AND_fundesc_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_fundesc_opt)
			  , #2 AND_rea_opt__AND_fundesc_opt ) 
) end
)
 in (LrTable.NT 158,(result,FUN1left,
AND_rea_opt__AND_fundesc_opt1right),rest671) end
| (451,(_,(MlyValue.AND_rea_opt__AND_fundesc_opt 
AND_rea_opt__AND_fundesc_opt1,_,AND_rea_opt__AND_fundesc_optright as 
AND_rea_opt__AND_fundesc_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,
CONSTRUCTORleft as CONSTRUCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_fundesc_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_fundesc_opt as AND_rea_opt__AND_fundesc_opt1=
AND_rea_opt__AND_fundesc_opt1 ()
 in (
 ( CONSTRUCTORRea(I(CONSTRUCTORleft,
					     AND_rea_opt__AND_fundesc_optright),
					   OP_opt1, longvid1, OP_opt2, longvid2,
				           #1 AND_rea_opt__AND_fundesc_opt)
			  , #2 AND_rea_opt__AND_fundesc_opt ) 
) end
)
 in (LrTable.NT 158,(result,CONSTRUCTOR1left,
AND_rea_opt__AND_fundesc_opt1right),rest671) end
| (452,(_,(MlyValue.AND_rea_opt__AND_fundesc_opt 
AND_rea_opt__AND_fundesc_opt1,_,AND_rea_opt__AND_fundesc_optright as 
AND_rea_opt__AND_fundesc_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,EXCEPTIONleft
 as EXCEPTION1left,_))::rest671) => let val result=
MlyValue.rea__AND_fundesc_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_fundesc_opt as AND_rea_opt__AND_fundesc_opt1=
AND_rea_opt__AND_fundesc_opt1 ()
 in (
 ( EXCEPTIONRea(I(EXCEPTIONleft,
					   AND_rea_opt__AND_fundesc_optright),
					 OP_opt1, longvid1, OP_opt2, longvid2,
					 #1 AND_rea_opt__AND_fundesc_opt)
			  , #2 AND_rea_opt__AND_fundesc_opt ) 
) end
)
 in (LrTable.NT 158,(result,EXCEPTION1left,
AND_rea_opt__AND_fundesc_opt1right),rest671) end
| (453,(_,(MlyValue.AND_rea_opt__AND_fundesc_opt 
AND_rea_opt__AND_fundesc_opt1,_,AND_rea_opt__AND_fundesc_optright as 
AND_rea_opt__AND_fundesc_opt1right))::(_,(MlyValue.ty ty1,_,_))::_::(_
,(MlyValue.longtycon longtycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1
,_,_))::(_,(_,TYPEleft as TYPE1left,_))::rest671) => let val result=
MlyValue.rea__AND_fundesc_opt(fn _ => let val tyvarseq as tyvarseq1=
tyvarseq1 ()
val longtycon as longtycon1=longtycon1 ()
val ty as ty1=ty1 ()
val AND_rea_opt__AND_fundesc_opt as AND_rea_opt__AND_fundesc_opt1=
AND_rea_opt__AND_fundesc_opt1 ()
 in (
 ( TYPERea(I(TYPEleft,
				      AND_rea_opt__AND_fundesc_optright),
				    tyvarseq, longtycon, ty,
				    #1 AND_rea_opt__AND_fundesc_opt)
			  , #2 AND_rea_opt__AND_fundesc_opt ) 
) end
)
 in (LrTable.NT 158,(result,TYPE1left,
AND_rea_opt__AND_fundesc_opt1right),rest671) end
| (454,(_,(MlyValue.AND_rea_opt__AND_fundesc_opt 
AND_rea_opt__AND_fundesc_opt1,_,AND_rea_opt__AND_fundesc_optright as 
AND_rea_opt__AND_fundesc_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,STRUCTUREleft as 
STRUCTURE1left,_))::rest671) => let val result=
MlyValue.rea__AND_fundesc_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_fundesc_opt as AND_rea_opt__AND_fundesc_opt1=
AND_rea_opt__AND_fundesc_opt1 ()
 in (
 ( STRUCTURERea(I(STRUCTUREleft,
					   AND_rea_opt__AND_fundesc_optright),
				         longstrid1, COLON_sigexp_opt,
					 longstrid2,
				         #1 AND_rea_opt__AND_fundesc_opt)
			  , #2 AND_rea_opt__AND_fundesc_opt ) 
) end
)
 in (LrTable.NT 158,(result,STRUCTURE1left,
AND_rea_opt__AND_fundesc_opt1right),rest671) end
| (455,(_,(MlyValue.AND_rea_opt__AND_fundesc_opt 
AND_rea_opt__AND_fundesc_opt1,_,AND_rea_opt__AND_fundesc_optright as 
AND_rea_opt__AND_fundesc_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,FUNCTORleft as 
FUNCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_fundesc_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_fundesc_opt as AND_rea_opt__AND_fundesc_opt1=
AND_rea_opt__AND_fundesc_opt1 ()
 in (
 ( FUNCTORRea(I(FUNCTORleft,
					 AND_rea_opt__AND_fundesc_optright),
				       longstrid1, COLON_sigexp_opt, longstrid2,
				       #1 AND_rea_opt__AND_fundesc_opt)
			  , #2 AND_rea_opt__AND_fundesc_opt ) 
) end
)
 in (LrTable.NT 158,(result,FUNCTOR1left,
AND_rea_opt__AND_fundesc_opt1right),rest671) end
| (456,(_,(MlyValue.sigexp__AND_rea_opt__AND_fundesc_opt 
sigexp__AND_rea_opt__AND_fundesc_opt1,_,
sigexp__AND_rea_opt__AND_fundesc_optright as 
sigexp__AND_rea_opt__AND_fundesc_opt1right))::_::(_,(
MlyValue.strpat_list0 strpat_list01,_,_))::(_,(MlyValue.longsigid 
longsigid1,_,_))::(_,(_,SIGNATUREleft as SIGNATURE1left,_))::rest671)
 => let val result=MlyValue.rea__AND_fundesc_opt(fn _ => let val 
longsigid as longsigid1=longsigid1 ()
val strpat_list0 as strpat_list01=strpat_list01 ()
val sigexp__AND_rea_opt__AND_fundesc_opt as 
sigexp__AND_rea_opt__AND_fundesc_opt1=
sigexp__AND_rea_opt__AND_fundesc_opt1 ()
 in (
 ( SIGNATURERea
				(I(SIGNATUREleft,
				   sigexp__AND_rea_opt__AND_fundesc_optright),
				 longsigid, strpat_list0,
				 #1 sigexp__AND_rea_opt__AND_fundesc_opt,
				 #2 sigexp__AND_rea_opt__AND_fundesc_opt)
			  , #3 sigexp__AND_rea_opt__AND_fundesc_opt ) 
) end
)
 in (LrTable.NT 158,(result,SIGNATURE1left,
sigexp__AND_rea_opt__AND_fundesc_opt1right),rest671) end
| (457,(_,(MlyValue.AND_fundesc_opt AND_fundesc_opt1,
AND_fundesc_opt1left,AND_fundesc_opt1right))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_fundesc_opt(fn _ => let val 
AND_fundesc_opt as AND_fundesc_opt1=AND_fundesc_opt1 ()
 in ( ( NONE, AND_fundesc_opt ) ) end
)
 in (LrTable.NT 159,(result,AND_fundesc_opt1left,AND_fundesc_opt1right
),rest671) end
| (458,(_,(MlyValue.rea__AND_fundesc_opt rea__AND_fundesc_opt1,_,
rea__AND_fundesc_opt1right))::(_,(_,AND1left,_))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_fundesc_opt(fn _ => let val 
rea__AND_fundesc_opt as rea__AND_fundesc_opt1=rea__AND_fundesc_opt1 ()
 in (
 ( SOME(#1 rea__AND_fundesc_opt),
			    #2 rea__AND_fundesc_opt ) )
 end
)
 in (LrTable.NT 159,(result,AND1left,rea__AND_fundesc_opt1right),
rest671) end
| (459,(_,(MlyValue.AND_rea_opt__AND_fundesc_opt 
AND_rea_opt__AND_fundesc_opt1,_,AND_rea_opt__AND_fundesc_opt1right))::
(_,(MlyValue.appsigexp appsigexp1,appsigexp1left,_))::rest671) => let 
val result=MlyValue.sigexp__AND_rea_opt__AND_fundesc_opt(fn _ => let 
val appsigexp as appsigexp1=appsigexp1 ()
val AND_rea_opt__AND_fundesc_opt as AND_rea_opt__AND_fundesc_opt1=
AND_rea_opt__AND_fundesc_opt1 ()
 in (
 ( appsigexp
		          , #1 AND_rea_opt__AND_fundesc_opt
			  , #2 AND_rea_opt__AND_fundesc_opt ) 
) end
)
 in (LrTable.NT 160,(result,appsigexp1left,
AND_rea_opt__AND_fundesc_opt1right),rest671) end
| (460,(_,(MlyValue.dec' dec'1,dec'left as dec'1left,dec'right as 
dec'1right))::rest671) => let val result=MlyValue.program(fn _ => let 
val dec' as dec'1=dec'1 ()
 in ( DECProgram(I(dec'left,dec'right),
				     dec', NONE) ) end
)
 in (LrTable.NT 161,(result,dec'1left,dec'1right),rest671) end
| (461,(_,(MlyValue.program_opt' program_opt'1,_,program_opt'right as 
program_opt'1right))::_::(_,(MlyValue.dec' dec'1,dec'left as dec'1left
,_))::rest671) => let val result=MlyValue.program(fn _ => let val dec'
 as dec'1=dec'1 ()
val program_opt' as program_opt'1=program_opt'1 ()
 in (
 DECProgram(I(dec'left,program_opt'right),
				     dec', program_opt') 
) end
)
 in (LrTable.NT 161,(result,dec'1left,program_opt'1right),rest671) end
| (462,(_,(MlyValue.program_opt' program_opt'1,_,program_opt'right as 
program_opt'1right))::_::(_,(MlyValue.exp exp1,expleft as exp1left,_))
::rest671) => let val result=MlyValue.program(fn _ => let val exp as 
exp1=exp1 ()
val program_opt' as program_opt'1=program_opt'1 ()
 in (
 EXPProgram(I(expleft,program_opt'right),
				     exp, program_opt') 
) end
)
 in (LrTable.NT 161,(result,exp1left,program_opt'1right),rest671) end
| (463,(_,(MlyValue.program program1,program1left,program1right))::
rest671) => let val result=MlyValue.program_opt(fn _ => let val 
program as program1=program1 ()
 in ( SOME program ) end
)
 in (LrTable.NT 162,(result,program1left,program1right),rest671) end
| (464,rest671) => let val result=MlyValue.program_opt(fn _ => ( NONE 
))
 in (LrTable.NT 162,(result,defaultPos,defaultPos),rest671) end
| (465,(_,(MlyValue.program_opt program_opt1,program_opt1left,
program_opt1right))::rest671) => let val result=MlyValue.program_opt'(
fn _ => let val program_opt as program_opt1=program_opt1 ()
 in ( program_opt ) end
)
 in (LrTable.NT 163,(result,program_opt1left,program_opt1right),
rest671) end
| (466,(_,(MlyValue.program_opt' program_opt'1,_,program_opt'1right))
::(_,(_,SEMICOLON1left,_))::rest671) => let val result=
MlyValue.program_opt'(fn _ => let val program_opt' as program_opt'1=
program_opt'1 ()
 in ( program_opt' ) end
)
 in (LrTable.NT 163,(result,SEMICOLON1left,program_opt'1right),rest671
) end
| (467,(_,(MlyValue.program_opt program_opt1,_,program_optright as 
program_opt1right))::(_,(MlyValue.import0 import01,import0left as 
import01left,_))::rest671) => let val result=MlyValue.component(fn _
 => let val import0 as import01=import01 ()
val program_opt as program_opt1=program_opt1 ()
 in (
 Component(I(import0left,program_optright),
					    import0, program_opt) 
) end
)
 in (LrTable.NT 164,(result,import01left,program_opt1right),rest671)
 end
| (468,(_,(MlyValue.import1 import11,import11left,import11right))::
rest671) => let val result=MlyValue.import0(fn _ => let val import1
 as import11=import11 ()
 in ( import1 ) end
)
 in (LrTable.NT 165,(result,import11left,import11right),rest671) end
| (469,rest671) => let val result=MlyValue.import0(fn _ => (
 EMPTYImport(I(defaultPos,defaultPos)) ))
 in (LrTable.NT 165,(result,defaultPos,defaultPos),rest671) end
| (470,(_,(MlyValue.STRING STRING1,_,STRINGright as STRING1right))::_
::(_,(MlyValue.spec spec1,_,_))::(_,(_,IMPORTleft as IMPORT1left,_))::
rest671) => let val result=MlyValue.import1(fn _ => let val spec as 
spec1=spec1 ()
val STRING as STRING1=STRING1 ()
 in (
 IMPORTImport(I(IMPORTleft,STRINGright),
					       spec, STRING) )
 end
)
 in (LrTable.NT 166,(result,IMPORT1left,STRING1right),rest671) end
| (471,(_,(MlyValue.import1 import12,_,import12right))::(_,(
MlyValue.import1 import11,import11left,_))::rest671) => let val result
=MlyValue.import1(fn _ => let val import11=import11 ()
val import12=import12 ()
 in (
 SEQImport(I(import11left,import12right),
					    import11, import12) 
) end
)
 in (LrTable.NT 166,(result,import11left,import12right),rest671) end
| (472,(_,(_,SEMICOLONleft as SEMICOLON1left,SEMICOLON1right))::
rest671) => let val result=MlyValue.import1(fn _ => (
 EMPTYImport(I(SEMICOLONleft,SEMICOLONleft)) ))
 in (LrTable.NT 166,(result,SEMICOLON1left,SEMICOLON1right),rest671)
 end
| _ => raise (mlyAction i392)
end
val void = MlyValue.VOID
val extract = fn a => (fn MlyValue.component x => x
| _ => let exception ParseInternal
	in raise ParseInternal end) a ()
end
end
structure Tokens : Parser_TOKENS =
struct
type svalue = ParserData.svalue
type ('a,'b) token = ('a,'b) Token.token
fun EOF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 0,(
ParserData.MlyValue.VOID,p1,p2))
fun ABSTYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 1,(
ParserData.MlyValue.VOID,p1,p2))
fun AND (p1,p2) = Token.TOKEN (ParserData.LrTable.T 2,(
ParserData.MlyValue.VOID,p1,p2))
fun ANDALSO (p1,p2) = Token.TOKEN (ParserData.LrTable.T 3,(
ParserData.MlyValue.VOID,p1,p2))
fun AS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 4,(
ParserData.MlyValue.VOID,p1,p2))
fun CASE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 5,(
ParserData.MlyValue.VOID,p1,p2))
fun DO (p1,p2) = Token.TOKEN (ParserData.LrTable.T 6,(
ParserData.MlyValue.VOID,p1,p2))
fun DATATYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 7,(
ParserData.MlyValue.VOID,p1,p2))
fun ELSE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 8,(
ParserData.MlyValue.VOID,p1,p2))
fun END (p1,p2) = Token.TOKEN (ParserData.LrTable.T 9,(
ParserData.MlyValue.VOID,p1,p2))
fun EXCEPTION (p1,p2) = Token.TOKEN (ParserData.LrTable.T 10,(
ParserData.MlyValue.VOID,p1,p2))
fun FN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 11,(
ParserData.MlyValue.VOID,p1,p2))
fun FUN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 12,(
ParserData.MlyValue.VOID,p1,p2))
fun HANDLE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 13,(
ParserData.MlyValue.VOID,p1,p2))
fun IF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 14,(
ParserData.MlyValue.VOID,p1,p2))
fun IN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 15,(
ParserData.MlyValue.VOID,p1,p2))
fun INFIX (p1,p2) = Token.TOKEN (ParserData.LrTable.T 16,(
ParserData.MlyValue.VOID,p1,p2))
fun INFIXR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 17,(
ParserData.MlyValue.VOID,p1,p2))
fun LET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 18,(
ParserData.MlyValue.VOID,p1,p2))
fun LOCAL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 19,(
ParserData.MlyValue.VOID,p1,p2))
fun NONFIX (p1,p2) = Token.TOKEN (ParserData.LrTable.T 20,(
ParserData.MlyValue.VOID,p1,p2))
fun OF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 21,(
ParserData.MlyValue.VOID,p1,p2))
fun OP (p1,p2) = Token.TOKEN (ParserData.LrTable.T 22,(
ParserData.MlyValue.VOID,p1,p2))
fun OPEN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 23,(
ParserData.MlyValue.VOID,p1,p2))
fun ORELSE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 24,(
ParserData.MlyValue.VOID,p1,p2))
fun RAISE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 25,(
ParserData.MlyValue.VOID,p1,p2))
fun REC (p1,p2) = Token.TOKEN (ParserData.LrTable.T 26,(
ParserData.MlyValue.VOID,p1,p2))
fun THEN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 27,(
ParserData.MlyValue.VOID,p1,p2))
fun TYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 28,(
ParserData.MlyValue.VOID,p1,p2))
fun VAL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 29,(
ParserData.MlyValue.VOID,p1,p2))
fun WITH (p1,p2) = Token.TOKEN (ParserData.LrTable.T 30,(
ParserData.MlyValue.VOID,p1,p2))
fun WITHTYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 31,(
ParserData.MlyValue.VOID,p1,p2))
fun WHILE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 32,(
ParserData.MlyValue.VOID,p1,p2))
fun LPAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 33,(
ParserData.MlyValue.VOID,p1,p2))
fun RPAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 34,(
ParserData.MlyValue.VOID,p1,p2))
fun LBRACK (p1,p2) = Token.TOKEN (ParserData.LrTable.T 35,(
ParserData.MlyValue.VOID,p1,p2))
fun RBRACK (p1,p2) = Token.TOKEN (ParserData.LrTable.T 36,(
ParserData.MlyValue.VOID,p1,p2))
fun LBRACE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 37,(
ParserData.MlyValue.VOID,p1,p2))
fun RBRACE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 38,(
ParserData.MlyValue.VOID,p1,p2))
fun COMMA (p1,p2) = Token.TOKEN (ParserData.LrTable.T 39,(
ParserData.MlyValue.VOID,p1,p2))
fun COLON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 40,(
ParserData.MlyValue.VOID,p1,p2))
fun SEMICOLON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 41,(
ParserData.MlyValue.VOID,p1,p2))
fun DOTS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 42,(
ParserData.MlyValue.VOID,p1,p2))
fun UNDERBAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 43,(
ParserData.MlyValue.VOID,p1,p2))
fun BAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 44,(
ParserData.MlyValue.VOID,p1,p2))
fun EQUALS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 45,(
ParserData.MlyValue.VOID,p1,p2))
fun DARROW (p1,p2) = Token.TOKEN (ParserData.LrTable.T 46,(
ParserData.MlyValue.VOID,p1,p2))
fun ARROW (p1,p2) = Token.TOKEN (ParserData.LrTable.T 47,(
ParserData.MlyValue.VOID,p1,p2))
fun HASH (p1,p2) = Token.TOKEN (ParserData.LrTable.T 48,(
ParserData.MlyValue.VOID,p1,p2))
fun CONSTRUCTOR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 49,(
ParserData.MlyValue.VOID,p1,p2))
fun NON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 50,(
ParserData.MlyValue.VOID,p1,p2))
fun WITHFUN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 51,(
ParserData.MlyValue.VOID,p1,p2))
fun WITHVAL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 52,(
ParserData.MlyValue.VOID,p1,p2))
fun DOT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 53,(
ParserData.MlyValue.VOID,p1,p2))
fun HASHBRACK (p1,p2) = Token.TOKEN (ParserData.LrTable.T 54,(
ParserData.MlyValue.VOID,p1,p2))
fun ANY (p1,p2) = Token.TOKEN (ParserData.LrTable.T 55,(
ParserData.MlyValue.VOID,p1,p2))
fun FCT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 56,(
ParserData.MlyValue.VOID,p1,p2))
fun PACK (p1,p2) = Token.TOKEN (ParserData.LrTable.T 57,(
ParserData.MlyValue.VOID,p1,p2))
fun UNPACK (p1,p2) = Token.TOKEN (ParserData.LrTable.T 58,(
ParserData.MlyValue.VOID,p1,p2))
fun IMPORT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 59,(
ParserData.MlyValue.VOID,p1,p2))
fun FROM (p1,p2) = Token.TOKEN (ParserData.LrTable.T 60,(
ParserData.MlyValue.VOID,p1,p2))
fun PRIMITIVE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 61,(
ParserData.MlyValue.VOID,p1,p2))
fun OVERLOAD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 62,(
ParserData.MlyValue.VOID,p1,p2))
fun INSTANCE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 63,(
ParserData.MlyValue.VOID,p1,p2))
fun PREBOUND (p1,p2) = Token.TOKEN (ParserData.LrTable.T 64,(
ParserData.MlyValue.VOID,p1,p2))
fun EQEQTYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 65,(
ParserData.MlyValue.VOID,p1,p2))
fun EQTYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 66,(
ParserData.MlyValue.VOID,p1,p2))
fun FUNCTOR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 67,(
ParserData.MlyValue.VOID,p1,p2))
fun INCLUDE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 68,(
ParserData.MlyValue.VOID,p1,p2))
fun SHARING (p1,p2) = Token.TOKEN (ParserData.LrTable.T 69,(
ParserData.MlyValue.VOID,p1,p2))
fun SIG (p1,p2) = Token.TOKEN (ParserData.LrTable.T 70,(
ParserData.MlyValue.VOID,p1,p2))
fun SIGNATURE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 71,(
ParserData.MlyValue.VOID,p1,p2))
fun STRUCT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 72,(
ParserData.MlyValue.VOID,p1,p2))
fun STRUCTURE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 73,(
ParserData.MlyValue.VOID,p1,p2))
fun WHERE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 74,(
ParserData.MlyValue.VOID,p1,p2))
fun COLONGREATER (p1,p2) = Token.TOKEN (ParserData.LrTable.T 75,(
ParserData.MlyValue.VOID,p1,p2))
fun ZERO (p1,p2) = Token.TOKEN (ParserData.LrTable.T 76,(
ParserData.MlyValue.VOID,p1,p2))
fun DIGIT (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 77,(
ParserData.MlyValue.DIGIT (fn () => i),p1,p2))
fun NUMERIC (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 78,(
ParserData.MlyValue.NUMERIC (fn () => i),p1,p2))
fun INT (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 79,(
ParserData.MlyValue.INT (fn () => i),p1,p2))
fun WORD (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 80,(
ParserData.MlyValue.WORD (fn () => i),p1,p2))
fun REAL (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 81,(
ParserData.MlyValue.REAL (fn () => i),p1,p2))
fun STRING (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 82,(
ParserData.MlyValue.STRING (fn () => i),p1,p2))
fun CHAR (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 83,(
ParserData.MlyValue.CHAR (fn () => i),p1,p2))
fun ALPHA (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 84,(
ParserData.MlyValue.ALPHA (fn () => i),p1,p2))
fun SYMBOL (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 85,(
ParserData.MlyValue.SYMBOL (fn () => i),p1,p2))
fun STAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 86,(
ParserData.MlyValue.VOID,p1,p2))
fun TYVAR (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 87,(
ParserData.MlyValue.TYVAR (fn () => i),p1,p2))
fun ETYVAR (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 88,(
ParserData.MlyValue.ETYVAR (fn () => i),p1,p2))
end
end
(* src # 100 *)
(*
 * Standard ML derived forms
 *
 * Definition, Appendix A
 *
 * Extensions and modifications:
 *   - predefined ids are taken out of a pseudo structure with empty name
 *   - recursive expressions:
 *	rec pat => exp     ==>     let val rec x as pat = exp in x end
 *     where x is a fresh identifier.
 *   - exception declarations have been made a derived form:
 *	exception exbind          ==>  constructor exbind'
 *	vid <of ty> <and exbind>  ==>  vid <of ty> : exn <and exbind'>
 *   - abstype has been made a derived form:
 *	abstype datbind <withtype tybind> with dec end
 *	  ==>
 *	<type typbind> local datatype datbind in type typbind' dec end
 *     where typbind' contains a binding t = t for each tycon t bound in
 *     datbind. Note that this results in a different treatment of equality.
 *   - include takes longsigids:
 *	include longsigid_1 ... longsigid_n
 *	==>
 *	include longsigid_1 ; ... ; include longsigid_n
 *   - derived forms for primitive declarations similar to specifications:
 *   - where constraints have been made a derived form of intersection:
 *	sigexp where type tyvarseq strid_1....strid_n.tycon = ty
 *	==>
 *      sigexp where sig structure strid_1 :
 *			...
 *			   sig structure strid_n :
 *			      sig type tyvarseq tycon = ty end
 *			   end
 *			...
 *		     end
 *
 *	sigexp where strid_1....strid_n.strid = longstrid
 *	==>
 *      sigexp where sig structure strid_1 :
 *			...
 *			   sig structure strid_n :
 *			      sig structure strid = longstrid end
 *			   end
 *			...
 *		     end
 *
 * We did NOT introduce a sharing signature ... and signature ... derived form
 * similar to types, because we consider that one completely broken.
 *
 * Notes:
 * - Two phrases named Fmatch and Fmrule have been added to factorize FvalBind.
 * - A phrase named TyReaDesc has been added to factorize type
 *   realisation signature expressions.
 * - In Fvalbinds we do not enforce that all optional type annotations are
 *   syntactically identical (as the Definition enforces, although this seems
 *   to be a mistake).
 * - The Definition is somewhat inaccurate about the derived forms of Exp
 *   [Definition, Appendix A, Figure 15] in that most forms are actually AtExp
 *   derived forms, as can be seen from the full grammar [Definition,
 *   Appendix B, Figure 20]. To achieve consistency, the equivalent forms must
 *   be put in parentheses in some case.
 * - The same goes for pattern derived forms [Definition, Appendix A, Figure 16;
 *   Appendix B, Figure 22].
 *)


structure DerivedForms :> DERIVED_FORMS =
  struct

    (* Import *)

    structure Grammar = InputGrammar
    structure G       = Grammar
    structure E       = ParsingError

    type Info      = Grammar.Info

    type Lab       = Grammar.Lab
    type VId       = Grammar.VId
    type StrId     = Grammar.StrId
    type LongVId   = Grammar.LongVId
    type LongTyCon = Grammar.LongTyCon
    type LongStrId = Grammar.LongStrId
    type LongSigId = Grammar.LongSigId

    type Op        = Grammar.Op
    type AtExp     = Grammar.AtExp
    type AppExp    = Grammar.Exp
    type InfExp    = Grammar.Exp
    type Exp       = Grammar.Exp
    type ExpRow    = Grammar.ExpRow
    type Match     = Grammar.Match
    type Mrule     = Grammar.Mrule
    type Dec       = Grammar.Dec
    type ValBind   = Grammar.ValBind
    type FvalBind  = Grammar.FvalBind
    type ExBind    = Grammar.DconBind
    type Fmatch    = Grammar.Match
    type Fmrule    = Grammar.Mrule
    type Fpat      = Grammar.Pat
    type TypBind   = Grammar.TypBind
    type DatBind   = Grammar.DatBind
    type AtPat     = Grammar.AtPat
    type PatRow    = Grammar.PatRow
    type Pat       = Grammar.Pat
    type Ty        = Grammar.Ty
    type TyVarSeq  = Grammar.TyVarSeq
    type AtStrExp  = Grammar.AtStrExp
    type AppStrExp = Grammar.StrExp
    type StrExp    = Grammar.StrExp
    type StrPat    = Grammar.StrPat
    type StrBind   = Grammar.StrBind
    type FunBind   = Grammar.StrBind
    type AppSigExp = Grammar.SigExp
    type SigExp    = Grammar.SigExp
    type Spec      = Grammar.Spec
    type ValDesc   = Grammar.ValDesc
    type TypDesc   = Grammar.TypDesc
    type DatDesc   = Grammar.DatDesc
    type ExDesc    = Grammar.DconDesc
    type FunDesc   = Grammar.StrDesc
    type Program   = Grammar.Program


    (* Additional types *)

    type AppExp = Exp
    type InfExp = Exp

    type Fmatch = Match
    type Fmrule = Mrule
    type Fpat   = Pat

    type TyReaDesc = (G.Info * G.TyVarSeq * G.LongTyCon * G.Ty) list

    (* Some helpers *)

    fun strid_PREBOUND(I)	= G.StrId(I, StrId.fromString "")
    fun longstrid_PREBOUND(I)	= G.SHORTLong(I, strid_PREBOUND(I))
    fun longvid(I, vid)		= G.DOTLong(I, longstrid_PREBOUND(I), vid)
    fun longtycon(I, tycon)	= G.DOTLong(I, longstrid_PREBOUND(I), tycon)

    fun vid_NIL(I)		= G.VId(I, VId.fromString "nil")
    fun vid_CONS(I)		= G.VId(I, VId.fromString "::")
    fun longvid_NIL(I)		= longvid(I, vid_NIL(I))
    fun longvid_CONS(I)		= longvid(I, vid_CONS(I))

    fun LONGVIDExp(I, longvid)	= G.ATEXPExp(I, G.LONGVIDAtExp(I, G.WITHOp,
								  longvid))
    fun LONGVIDPat(I, longvid)	= G.ATPATPat(I, G.LONGVIDAtPat(I, G.WITHOp,
								  longvid))
    fun VIDExp(I, vid)		= LONGVIDExp(I, G.SHORTLong(I, vid))
    fun VIDPat(I, vid)		= LONGVIDPat(I, G.SHORTLong(I, vid))

    fun NILExp(I)		= LONGVIDExp(I, longvid_NIL(I))
    fun CONSExp(I)		= LONGVIDExp(I, longvid_CONS(I))
    fun NILPat(I)		= LONGVIDPat(I, longvid_NIL(I))
    fun CONSPat(I)		= LONGVIDPat(I, longvid_CONS(I))

    fun tycon_EXN(I)		= G.TyCon(I, TyCon.fromString "exn")
    fun longtycon_EXN(I)	= longtycon(I, tycon_EXN(I))


    (* Functions to handle rewriting of withtype declarations *)

    fun equalTyCon(G.TyCon(_,tycon1), G.TyCon(_,tycon2)) = tycon1 = tycon2
    fun equalTyVar(G.TyVar(_,tyvar1), G.TyVar(_,tyvar2)) = tyvar1 = tyvar2

    fun lookupTyCon(tycon, G.NEWTypBind(i, tyvarseq, tycon', typbind_opt)) =
	    E.error(i, E.WithtypeInvalid)

      | lookupTyCon(tycon, G.EQUALTypBind(_,tyvarseq,tycon', ty, typbind_opt)) =
	    if equalTyCon(tycon, tycon') then
		(tyvarseq, ty)
	    else
	  	lookupTyCon(tycon, Option.valOf typbind_opt)
		(* may raise Option *)


    fun replaceTy (G.Seq(_,tyvars), G.Seq(_,tys)) (ty as G.TYVARTy(i, tyvar)) =
	let
	    fun loop(tyvar'::tyvars', ty'::tys') =
		    if equalTyVar(tyvar, tyvar') then
			ty'
		    else
			loop(tyvars', tys')
	      | loop([], _) =
		    ty
	      | loop(_, []) =
		    E.error(i, E.WithtypeArityMismatch)
	in
	    loop(tyvars, tys)
	end

      | replaceTy tyvarseq_tyseq (G.RECORDTy(I, tyrow_opt)) =
	    G.RECORDTy(I, Option.map (replaceTyRow tyvarseq_tyseq) tyrow_opt)

      | replaceTy tyvarseq_tyseq (G.TUPLETy(I, tys)) =
	    G.TUPLETy(I, List.map (replaceTy tyvarseq_tyseq) tys)

      | replaceTy tyvarseq_tyseq (G.TYCONTy(I, tyseq', tycon)) =
	    G.TYCONTy(I, replaceTySeq tyvarseq_tyseq tyseq', tycon)

      | replaceTy tyvarseq_tyseq (G.ARROWTy(I, ty1, ty2)) =
	    G.ARROWTy(I, replaceTy tyvarseq_tyseq ty1,
			 replaceTy tyvarseq_tyseq ty2)

      | replaceTy tyvarseq_tyseq (ty as G.PACKTy _) =
	    ty

      | replaceTy tyvarseq_tyseq (G.PARTy(I, ty)) =
	    G.PARTy(I, replaceTy tyvarseq_tyseq ty)

    and replaceTyRow tyvarseq_tyseq (G.ROWTyRow(I, lab, ty, tyrow_opt)) =
	    G.ROWTyRow(I, lab, replaceTy tyvarseq_tyseq ty, 
			  Option.map (replaceTyRow tyvarseq_tyseq) tyrow_opt)

    and replaceTySeq tyvarseq_tyseq (G.Seq(I, tys)) =	  
	    G.Seq(I, List.map (replaceTy tyvarseq_tyseq) tys)


    fun rewriteTy typbind (ty as G.TYVARTy _) = ty

      | rewriteTy typbind (G.RECORDTy(I, tyrow_opt)) =
	    G.RECORDTy(I, Option.map (rewriteTyRow typbind) tyrow_opt)

      | rewriteTy typbind (G.TUPLETy(I, tys)) =
	    G.TUPLETy(I, List.map (rewriteTy typbind) tys)

      | rewriteTy typbind (ty as G.TYCONTy(I, tyseq, longtycon as G.DOTLong _))=
	    G.TYCONTy(I, rewriteTySeq typbind tyseq, longtycon)

      | rewriteTy typbind (ty as G.TYCONTy(I, tyseq,
					  longtycon as G.SHORTLong(_, tycon))) =
	let 
	    val tyseq' = rewriteTySeq typbind tyseq
	in
	    let
		val (tyvarseq', ty') = lookupTyCon(tycon, typbind)
	    in
		replaceTy (tyvarseq',tyseq') ty'
	    end
	    handle Option => G.TYCONTy(I, tyseq', longtycon)
	end

      | rewriteTy typbind (G.ARROWTy(I, ty1, ty2)) =
	    G.ARROWTy(I, rewriteTy typbind ty1, rewriteTy typbind ty2)

      | rewriteTy typbind (ty as G.PACKTy _) =
	    ty

      | rewriteTy typbind (G.PARTy(I, ty)) =
	    G.PARTy(I, rewriteTy typbind ty)

    and rewriteTyRow typbind (G.ROWTyRow(I, lab, ty, tyrow_opt)) =
	    G.ROWTyRow(I, lab, rewriteTy typbind ty,
			  Option.map (rewriteTyRow typbind) tyrow_opt)

    and rewriteTySeq typbind (G.Seq(I, tys)) =
	    G.Seq(I, List.map (rewriteTy typbind) tys)

    fun rewriteConBind typbind (G.ConBind(I, op_opt, vid, ty_opt, conbind_opt))=
	    G.ConBind(I, op_opt, vid,
			 Option.map (rewriteTy typbind) ty_opt,
			 Option.map (rewriteConBind typbind) conbind_opt)

    fun rewriteDatBind typbind (G.CLOSEDDatBind(I, tyvarseq, tycon, conbind,
							      datbind_opt)) =
	    G.CLOSEDDatBind(I, tyvarseq, tycon, rewriteConBind typbind conbind,
			       Option.map (rewriteDatBind typbind) datbind_opt)
      | rewriteDatBind typbind (G.OPENDatBind(I, tyvarseq, tycon,
							      datbind_opt)) =
	    G.OPENDatBind(I, tyvarseq, tycon,
			     Option.map (rewriteDatBind typbind) datbind_opt)


    fun toTy tyvar = G.TYVARTy(G.infoTyVar tyvar, tyvar)

    fun toTypBind(G.NEWTypDesc(I, tyvarseq, tycon, typdesc_opt)) =
	    G.NEWTypBind(I, tyvarseq, tycon, Option.map toTypBind typdesc_opt)

      | toTypBind(G.EQUALTypDesc(I, tyvarseq, tycon, ty, typdesc_opt)) =
	    G.EQUALTypBind(I, tyvarseq, tycon, ty,
			      Option.map toTypBind typdesc_opt)

    (* Functions to handle rewriting of withtype specifications *)

    fun rewriteConDesc typbind (G.ConDesc(I, op_opt, vid, ty_opt, condesc_opt))=
	    G.ConDesc(I, op_opt, vid,
			 Option.map (rewriteTy typbind) ty_opt,
			 Option.map (rewriteConDesc typbind) condesc_opt)

    fun rewriteDatDesc typbind (G.CLOSEDDatDesc(I, tyvarseq, tycon, condesc,
							      datdesc_opt)) =
	    G.CLOSEDDatDesc(I, tyvarseq, tycon, rewriteConDesc typbind condesc,
			       Option.map (rewriteDatDesc typbind) datdesc_opt)
      | rewriteDatDesc typbind (G.OPENDatDesc(I, tyvarseq, tycon,
							      datdesc_opt)) =
	    G.OPENDatDesc(I, tyvarseq, tycon,
			     Option.map (rewriteDatDesc typbind) datdesc_opt)


    (* Rewriting of abstype *)

    fun toTy tyvar = G.TYVARTy(G.infoTyVar tyvar, tyvar)

    fun redeclare ( G.CLOSEDDatBind(I, tyvarseq, tycon, _, datbind_opt)
		  | G.OPENDatBind(I, tyvarseq, tycon, datbind_opt)) =
	let
	    val G.Seq(I',tyvarseq') = tyvarseq
	    val tyseq     = G.Seq(I', List.map toTy tyvarseq')
	    val I_tycon   = G.infoTyCon tycon
	    val longtycon = G.SHORTLong(I_tycon, tycon)
	    val ty        = G.TYCONTy(I_tycon, tyseq,longtycon)
	in
	    G.EQUALTypBind(I, tyvarseq, tycon, ty,
			      Option.map redeclare datbind_opt)
	end



    (* Patterns *)

    fun UNITAtPat(I) = G.TUPLEAtPat(I, [])

    val TUPLEAtPat   = G.TUPLEAtPat
    val WITHFUNPat   = G.WITHFUNPat

    fun LISTAtPat(I, pats) =
	let
	    fun toPatList []          = NILPat(I)
	      | toPatList(pat::pats') =
		G.APPPat(I, CONSPat(I), TUPLEAtPat(I, [pat,toPatList pats']))
	in
	    G.PARAtPat(I, toPatList pats)
	end


    fun VIDPatRow(I, vid as G.VId(I',vid'), ty_opt, pat_opt, patrow_opt) =
	let
	    val lab    = G.Lab(I', Lab.fromString(VId.toString vid'))
	    val vidPat = VIDPat(I', vid)
	    val pat1   = case ty_opt
			   of NONE    => vidPat
			    | SOME ty => G.TYPEDPat(I, vidPat, ty)
	    val pat    = case pat_opt
			   of NONE      => pat1
			    | SOME pat' => G.ASPat(I, pat1, pat')
	in
	    G.ROWPatRow(I, lab, pat, patrow_opt)
	end



    (* Expressions *)

    fun UNITAtExp(I) = G.TUPLEAtExp(I, [])

    val TUPLEAtExp   = G.TUPLEAtExp
    val HASHAtExp    = G.HASHAtExp
    val CASEExp      = G.CASEExp
    val IFExp        = G.IFExp
    val ORELSEExp    = G.ORELSEExp
    val ANDALSOExp   = G.ANDALSOExp
    val WHILEExp     = G.WHILEExp
    val SEQAtExp     = G.SEQAtExp

    fun LETAtExp(I, dec, [exp]) = G.LETAtExp(I, dec, exp)
      | LETAtExp(I, dec,  exps) =
	    G.LETAtExp(I, dec, G.ATEXPExp(I, SEQAtExp(I, exps)))

    fun LISTAtExp(I, exps) =
	let
	    fun toExpList []          = NILExp(I)
	      | toExpList(exp::exps') =
		  G.APPExp(I, CONSExp(I), TUPLEAtExp(I, [exp, toExpList exps']))
	in
	    G.PARAtExp(I, toExpList exps)
	end

    fun RECExp(I, pat, exp) =
	let
	    val I'      = G.infoPat pat
	    val vid     = G.VId(I', VId.invent())
	    val asPat   = G.ASPat(I', VIDPat(I', vid), pat)
	    val valbind = G.RECValBind(I, G.PLAINValBind(I, asPat, exp, NONE))
	    val dec     = G.VALDec(I, G.Seq(I',[]), valbind)
	in
	    G.ATEXPExp(I, G.LETAtExp(I, dec, VIDExp(I', vid)))
	end


    fun VIDExpRow(I, vid as G.VId(I',vid'), ty_opt, exprow_opt) =
	let
	    val lab    = G.Lab(I', Lab.fromString(VId.toString vid'))
	    val vidExp = VIDExp(I', vid)
	    val exp    = case ty_opt
			   of NONE    => vidExp
			    | SOME ty => G.TYPEDExp(I, vidExp, ty)
	in
	    G.ROWExpRow(I, lab, exp, exprow_opt)
	end


    (* Types *)

    fun TUPLETy(I, [ty]) = ty
      | TUPLETy(I,  tys) = G.TUPLETy(I, tys)


    (* Declarations *)

    val FUNDec       = G.FUNDec
    val EXCEPTIONDec = G.CONSTRUCTORDec
    val FUNCTORDec   = G.STRUCTUREDec
    val FvalBind     = G.FvalBind
    val EQUALExBind  = G.EQUALDconBind
    val Fmatch       = G.Match
    val Fmrule       = G.Mrule

    fun Fpat p       = p


    fun DATATYPEDec(I, datbind, NONE)         = G.DATATYPEDec(I, datbind)
      | DATATYPEDec(I, datbind, SOME typbind) =
	let
	    val datbind' = rewriteDatBind typbind datbind
	in
	    G.SEQDec(I, G.DATATYPEDec(G.infoDatBind datbind, datbind'),
			G.TYPEDec(G.infoTypBind typbind, typbind))
	end

    fun ABSTYPEDec(I, datbind, NONE, dec) =
	let
	    val datatypeDec = G.DATATYPEDec(I, datbind)
	    val typeDec     = G.TYPEDec(I, redeclare datbind)
	in
	    G.LOCALDec(I, datatypeDec, G.SEQDec(I, typeDec, dec))
	end

      | ABSTYPEDec(I, datbind, SOME typbind, dec) =
	let
	    val I'          = G.infoTypBind typbind
	    val datbind'    = rewriteDatBind typbind datbind
	    val datatypeDec = G.DATATYPEDec(I, datbind')
	    val typeDec     = G.TYPEDec(I, redeclare datbind')
	in
	    G.SEQDec(I, G.TYPEDec(I', typbind),
			G.LOCALDec(I, datatypeDec, G.SEQDec(I, typeDec, dec)))
	end


    fun OPENMULTIDec(I, [])                    = G.EMPTYDec(I)
      | OPENMULTIDec(I, longstrid::longstrids) =
	    G.SEQDec(I, G.OPENDec(I,longstrid), OPENMULTIDec(I,longstrids))

    fun INFIXMULTIDec(I, _, [])          = G.EMPTYDec(I)
      | INFIXMULTIDec(I, NONE, longvids) = INFIXMULTIDec(I, SOME 0, longvids)
      | INFIXMULTIDec(I, SOME d, longvid::longvids) =
	    G.SEQDec(I, G.INFIXDec(I, d, longvid),
			INFIXMULTIDec(I, SOME d, longvids))

    fun INFIXRMULTIDec(I, _, [])          = G.EMPTYDec(I)
      | INFIXRMULTIDec(I, NONE, longvids) = INFIXRMULTIDec(I, SOME 0, longvids)
      | INFIXRMULTIDec(I, SOME d, longvid::longvids) =
	    G.SEQDec(I, G.INFIXRDec(I, d, longvid),
			INFIXRMULTIDec(I, SOME d, longvids))

    fun NONFIXMULTIDec(I, [])                = G.EMPTYDec(I)
      | NONFIXMULTIDec(I, longvid::longvids) =
	    G.SEQDec(I, G.NONFIXDec(I,longvid), NONFIXMULTIDec(I,longvids))


    fun NEWExBind(I, op_opt, vid, ty_opt, dconbind_opt) =
	    G.NEWDconBind(I, op_opt, vid, ty_opt,
			     G.Seq(I,[]), longtycon_EXN(I), dconbind_opt)
 

    (* Structure bindings *)

    fun TRANSStrBind(I, strid, NONE, strexp, strbind_opt) =
	    G.StrBind(I, strid, strexp, strbind_opt)

      | TRANSStrBind(I, strid, SOME sigexp, strexp, strbind_opt) =
	    G.StrBind(I, strid, G.TRANSStrExp(I, strexp, sigexp), strbind_opt)

    fun OPAQStrBind(I, strid, sigexp, strexp, strbind_opt) =
	    G.StrBind(I, strid, G.OPAQStrExp(I, strexp, sigexp), strbind_opt)

    fun WILDCARDStrBind(I, sigexp_opt, strexp, strbind_opt) =
	    TRANSStrBind(I, G.StrId(I, StrId.invent()),
			 sigexp_opt, strexp, strbind_opt)


    (* Structure expressions *)

    val DECAtStrExp = G.STRUCTAtStrExp
    val STRIDStrPat = G.StrPat

    fun FCTStrExp(I, strpat as G.StrPat(I1, G.StrId(I2, strid'), sigexp),
		     strexp) =
	if StrId.toString strid' <> "" then
	    G.FCTStrExp(I, strpat, strexp)
	else
	let
	    val I3     = G.infoStrExp strexp
	    val strid  = G.StrId(I2, StrId.invent())

	    val dec    = G.OPENDec(I3, G.SHORTLong(I3, strid))
	    val letexp = G.ATSTREXPStrExp(I3, G.LETAtStrExp(I3, dec, strexp))
	in
	    G.FCTStrExp(I, G.StrPat(I1, strid, sigexp), letexp)
	end

    fun WILDCARDStrPat(I, sigexp) =
	    G.StrPat(I, G.StrId(I, StrId.invent()), sigexp)

    fun SPECStrPat(I, spec) =
	let
	    val I' = G.infoSpec spec
	in
	    G.StrPat(I, G.StrId(I, StrId.fromString ""),
		     G.ATSIGEXPSigExp(I', G.SIGAtSigExp(I', spec)))
	end


    (* Functor bindings *)

    fun FunBind(I, strid, strpats, strexp, funbind_opt) =
	let
	    val I' = G.infoStrExp strexp

	    fun buildStrExp       []         = strexp
	      | buildStrExp(strpat::strpats) =
		    FCTStrExp(Source.over(G.infoStrPat strpat, I'),
			      strpat, buildStrExp strpats)
	in
	    G.StrBind(I, strid, buildStrExp strpats, funbind_opt)
	end

    fun TRANSFunBind(I, strid, strpats, NONE, strexp, funbind_opt) =
	    FunBind(I, strid, strpats, strexp, funbind_opt)

      | TRANSFunBind(I, strid, strpats, SOME sigexp, strexp, funbind_opt) =
	    FunBind(I, strid, strpats, G.TRANSStrExp(I, strexp, sigexp),
		       funbind_opt)

    fun OPAQFunBind(I, strid, strpats, sigexp, strexp, funbind_opt) =
	    FunBind(I, strid, strpats, G.OPAQStrExp(I, strexp, sigexp),
		       funbind_opt)


    (* Specifications *)

    val FUNSpec       = G.VALSpec
    val SHARINGSpec   = G.SHARINGSpec
    val EXCEPTIONSpec = G.CONSTRUCTORSpec
    val FUNCTORSpec   = G.STRUCTURESpec
    val EQUALExDesc   = G.EQUALDconDesc

    fun DATATYPESpec(I, datdesc, NONE)         = G.DATATYPESpec(I, datdesc)
      | DATATYPESpec(I, datdesc, SOME typdesc) =
	let
	    val datdesc' = rewriteDatDesc (toTypBind typdesc) datdesc
	in
	    G.SEQSpec(I, G.DATATYPESpec(G.infoDatDesc datdesc, datdesc'),
			 G.TYPESpec(G.infoTypDesc typdesc, typdesc))
	end

    fun INCLUDEMULTISpec(I, [])             = G.EMPTYSpec(I)
      | INCLUDEMULTISpec(I, longsigid::longsigids') =
	let
	    val sigexp = G.ATSIGEXPSigExp(I, G.LONGSIGIDAtSigExp(I, longsigid))
	    val spec1  = G.INCLUDESpec(I, sigexp)
	in
	    G.SEQSpec(I, spec1, INCLUDEMULTISpec(I, longsigids'))
	end

    fun INFIXMULTISpec(I, _, [])          = G.EMPTYSpec(I)
      | INFIXMULTISpec(I, NONE, longvids) = INFIXMULTISpec(I, SOME 0, longvids)
      | INFIXMULTISpec(I, SOME d, longvid::longvids) =
	    G.SEQSpec(I, G.INFIXSpec(I, d, longvid),
			 INFIXMULTISpec(I, SOME d, longvids))

    fun INFIXRMULTISpec(I, _, [])          = G.EMPTYSpec(I)
      | INFIXRMULTISpec(I, NONE, longvids) = INFIXRMULTISpec(I, SOME 0,longvids)
      | INFIXRMULTISpec(I, SOME d, longvid::longvids) =
	    G.SEQSpec(I, G.INFIXRSpec(I, d, longvid),
			 INFIXRMULTISpec(I, SOME d, longvids))

    fun NONFIXMULTISpec(I, [])                = G.EMPTYSpec(I)
      | NONFIXMULTISpec(I, longvid::longvids) =
	    G.SEQSpec(I, G.NONFIXSpec(I,longvid), NONFIXMULTISpec(I,longvids))


    fun NEWExDesc(I, op_opt, vid, ty_opt, dcondesc_opt) =
	    G.NEWDconDesc(I, op_opt, vid, ty_opt, G.Seq(I,[]),
			  longtycon_EXN(I), dcondesc_opt)

    fun FunDesc(I, strid, strpats, sigexp, fundesc_opt) =
	let
	    val I' = G.infoSigExp sigexp

	    fun buildSigExp       []         = sigexp
	      | buildSigExp(strpat::strpats) =
		    FCTSigExp(Source.over(G.infoStrPat strpat, I'),
			      strpat, buildSigExp strpats)
	in
	    G.NEWStrDesc(I, strid, buildSigExp strpats, fundesc_opt)
	end


    (* Signature expressions *)

    and FCTSigExp(I, strpat as G.StrPat(I1, G.StrId(I2, strid'), sigexp1),
		     sigexp) =
	if StrId.toString strid' <> "" then
	    G.FCTSigExp(I, strpat, sigexp)
	else
	let
	    val I3     = G.infoSigExp sigexp
	    val strid  = G.StrId(I2, StrId.invent())

	    val dec    = G.OPENDec(I3, G.SHORTLong(I3, strid))
	    val letexp = G.ATSIGEXPSigExp(I3, G.LETAtSigExp(I3, dec, sigexp))
	in
	    G.FCTSigExp(I, G.StrPat(I1, strid, sigexp1), letexp)
	end


    datatype Rea =
	  VALRea         of Info * Op * LongVId * Op * LongVId * Rea option
	| CONSTRUCTORRea of Info * Op * LongVId * Op * LongVId * Rea option
	| TYPERea        of Info * TyVarSeq * LongTyCon * Ty * Rea option
	| STRUCTURERea   of Info * LongStrId * SigExp option * LongStrId
							     * Rea option
	| SIGNATURERea   of Info * LongSigId * StrPat list * AppSigExp
							   * Rea option

    val FUNRea       = VALRea
    val EXCEPTIONRea = CONSTRUCTORRea
    val FUNCTORRea   = STRUCTURERea


    fun buildValSpec (op_opt1, op_opt2, longvid) (I, vid) =
	    G.VALSpec(I, G.EQUALValDesc(I, op_opt1, vid,
					   op_opt2, longvid, NONE))
    fun buildDconSpec (op_opt1, op_opt2, longvid) (I, vid) =
	    G.CONSTRUCTORSpec(I, G.EQUALDconDesc(I, op_opt1, vid,
						    op_opt2, longvid, NONE))
    fun buildTypSpec (tyvarseq, ty) (I, tycon) =
	    G.TYPESpec(I, G.EQUALTypDesc(I, tyvarseq, tycon, ty, NONE))
    fun buildStrSpec (sigexp_opt, longstrid) (I, strid) =
	    G.STRUCTURESpec(I, G.EQUALStrDesc(I, strid, sigexp_opt,
						 longstrid, NONE))
    fun buildSigSpec (strpats, sigexp) (I, sigid) =
	    G.SIGNATURESpec(I, G.EQUALSigDesc(I, sigid, strpats, sigexp, NONE))


    fun buildSigExp(buildInnerSpec, I, longid, rea_opt) =
	let
	    val (strids,id) = G.explodeLong longid

	    fun buildSpec      []        = buildInnerSpec(I, id)
	      | buildSpec(strid::strids) =
		  G.STRUCTURESpec(I,
			G.NEWStrDesc(I, strid, buildSigExp strids, NONE))

	    and buildSigExp strids =
		  G.ATSIGEXPSigExp(I,
			G.SIGAtSigExp(I, buildSpec strids))
	in
	    ( buildSigExp strids, rea_opt )
	end


    fun Rea(VALRea(I, op_opt1, longvid1, op_opt2, longvid2, rea_opt)) =
	    buildSigExp(buildValSpec(op_opt1, op_opt2, longvid2),
			I, longvid1, rea_opt)
      | Rea(CONSTRUCTORRea(I, op_opt1, longvid1, op_opt2, longvid2, rea_opt)) =
	    buildSigExp(buildDconSpec(op_opt1, op_opt2, longvid2),
			I, longvid1, rea_opt)
      | Rea(TYPERea(I, tyvarseq, longtycon, ty, rea_opt)) =
	    buildSigExp(buildTypSpec(tyvarseq, ty), I, longtycon, rea_opt)
      | Rea(STRUCTURERea(I, longstrid1, sigexp_opt, longstrid2, rea_opt)) =
	    buildSigExp(buildStrSpec(sigexp_opt, longstrid2),
			I, longstrid1, rea_opt)
      | Rea(SIGNATURERea(I, longsigid, strpats, sigexp, rea_opt)) =
	    buildSigExp(buildSigSpec(strpats, sigexp), I, longsigid, rea_opt)

    fun WHEREREASigExp'(I, sigexp, NONE)     = sigexp
      | WHEREREASigExp'(I, sigexp, SOME rea) =
	let
	    val (sigexp2,rea_opt) = Rea rea
	    val  I'               = Source.over(I, G.infoSigExp sigexp2)
	    val  sigexp'          = G.WHERESigExp(I', sigexp, sigexp2)
	in
	    WHEREREASigExp'(I, sigexp', rea_opt)
	end

    fun WHEREREASigExp(I, sigexp, rea) = WHEREREASigExp'(I, sigexp, SOME rea)


    fun WHERELONGSTRIDSigExp(I, sigexp, longstrid1, longstrid2) =
	let
	    val I' = Source.over(G.infoLong longstrid1, G.infoLong longstrid2)
	in
	    WHEREREASigExp(I, sigexp,
			   STRUCTURERea(I', longstrid1, NONE, longstrid2, NONE))
	end



    (* Programs *)

    fun DECProgram(I, dec, program_opt) =
	    G.Program(I, dec, program_opt)

    fun EXPProgram(I, exp, program_opt) =
	let
	    val longvid = G.SHORTLong(I, G.VId(I, VId.fromString "it"))
	    val pat     = G.ATPATPat(I, G.LONGVIDAtPat(I, G.SANSOp, longvid))
	    val valbind = G.PLAINValBind(I, pat, exp, NONE)
	    val dec     = G.VALDec(I, G.Seq(I, []), valbind)
	in
	    G.Program(I, dec, program_opt)
	end

  end
(* src # 101 *)
signature LEXER_ERROR =
  sig

    type token
    type error

    exception Error of (int * int) * error
    exception EOF   of (int * int) -> token

    val error :	(int * int) * error -> 'a

  end
(* src # 102 *)
functor LexerError(structure Tokens: Parser_TOKENS
		   type error) : LEXER_ERROR =
  struct

    type token = (Tokens.svalue, int) Tokens.token
    type error = error

    exception Error of (int * int) * error
    exception EOF   of (int * int) -> token

    fun error pos_e = raise Error pos_e

  end
(* src # 103 *)
 functor Lexer(structure Tokens:     Parser_TOKENS
			structure LexerError: LEXER_ERROR
			  where type token = (Tokens.svalue,int) Tokens.token
			  where type error = ParsingError.error)=
   struct
    structure UserDeclarations =
      struct
(*
 * Standard ML lexical analysis
 *
 * Definition, sections 2.1-2.5, 3.1
 *
 * Extensions and modifications:
 *   - more liberal constant prefixes (allow 0xw)
 *   - binary int and word constants (0b010, 0wb010)
 *   - longids have been moved to the context-free grammar,
 *     so the LONGID token is substituted by a DOT token
 *   - #[ keyword for vector expressions
 *   - CONSTRUCTOR keyword for constructor declarations
 *   - NON keyword added for negated patterns
 *   - WITHVAL and WITHFUN keywords for bindings inside pattern
 *   - FCT keyword for functor expressions and signatures
 *   - ANY keyword for top signature
 *   - PACK and UNPACK keyword for first class structures
 *   - IMPORT and FROM keywords added
 *   - PRIMITIVE, OVERLOAD, INSTANCE, PREBOUND, and EQEQTYPE keywords added
 *
 * Notes:
 *   Since all lexical classes must be disjoint:
 *   - There is no single class ID, use ALPHA|SYMBOL|STAR|EQUALS.
 *   - There is no class LAB, use ALPHA|SYMBOL|NUMERIC|DIGIT|STAR.
 *   - ID does not contain `=' and `*', those are EQUALS and STAR.
 *   - INT does not contain positive decimal integers without leading 0,
 *     and single DIGIT integers, those are in NUMERIC, DIGIT, and ZERO.
 *   - NUMERIC does not contain single digit numbers, those are in DIGIT.
 *   - DIGIT does not contain 0, that is ZERO.
 *
 *   The parser uses a global variable to recognise nested comments, so it is
 *   not reentrant.
 *)


    open Misc
    open Tokens

    structure E = ParsingError

    val error = LexerError.error


  (* Types to match structure LEXER.UserDeclaration *)

    type ('a,'b) token = ('a,'b) Tokens.token
    type pos           = int
    type svalue        = Tokens.svalue
    type lexresult     = (svalue, pos) token


  (* Handling nested comments *)

    val nesting = ref 0		(* non-reentrant side-effect way :-P *)


    fun eof() =
	if !nesting = 0 then
	    raise LexerError.EOF(fn i => Tokens.EOF i)
	else
	    raise LexerError.EOF(fn i => error(i, E.UnclosedComment))



  (* Some helpers to create tokens *)

    open Tokens


    fun toLRPos(yypos, yytext) =
	let
	    val yypos = yypos - 2	(* bug in ML-Lex... *)
	in
	    (yypos, yypos + String.size yytext)
	end

    fun token(TOKEN, yypos, yytext) =
        TOKEN(toLRPos(yypos, yytext))

    fun tokenOf(TOKEN, toVal, yypos, yytext) =
	let
	    val i as (l,r) = toLRPos(yypos, yytext)
	in
	    TOKEN(toVal(yytext,i), l, r)
	end


    fun error'(yypos, yytext, e) = error(toLRPos(yypos, yytext), e)



  (* Convert identifiers and constants *)

    datatype radix = datatype StringCvt.radix

    fun toId(s,i) = s

    fun toDigit(s,i) = Char.ord(String.sub(s,0)) - Char.ord #"0"

    fun toInt(s,i) =
	case String.sub(s,0)
	  of #"~" => ~(toInt(String.extract(s,1,NONE), i))
	   | #"0" => (if String.size s = 1 then 0 else
		      case String.sub(s,1)
			of #"b" => toInt'(String.extract(s,2,NONE), BIN, i)
			 | #"x" => toInt'(String.extract(s,2,NONE), HEX, i)
			 |   _  => toInt'(s, DEC, i)
		     )
	   |   _  => toInt'(s, DEC, i)

    and toInt'(s,b,i) = Option.valOf(StringCvt.scanString (LargeInt.scan b) s)
			handle Overflow => error(i, E.IntTooLarge)

    fun toWord(s,i) =
	case (String.sub(s,1), String.sub(s,2))
	  of ( (#"b",_) | (_,#"b") ) => toWord'(String.extract(s,3,NONE), BIN,i)
	   | ( (#"x",_) | (_,#"x") ) => toWord'(String.extract(s,3,NONE), HEX,i)
	   |            _            => toWord'(String.extract(s,2,NONE), DEC,i)

    and toWord'(s,b,i) = Option.valOf(StringCvt.scanString (LargeWord.scan b) s)
			 handle Overflow => error(i, E.WordTooLarge)

    fun toReal(s,i)    = Option.valOf(StringCvt.scanString LargeReal.scan s)
			 handle Overflow => error(i, E.RealTooLarge)


    fun toString(s,i) =
	let
            fun base(s,b,m) =
		WideChar.chr(Option.valOf(StringCvt.scanString (Int.scan b) s))
		handle (Chr | Overflow) =>
			 error(i, E.EscapeCharTooLarge m)

	    fun dec s     = base(s, DEC, false)
	    fun unicode s = base(s, HEX, true)

	    fun convert(k,cs) =
		case String.sub(s,k)
		  of #"\"" => WideString.implode(List.rev cs)
		   | #"\\" => escape(k+1,cs)
		   |   c   => convert(k+1, Char_toWide(c)::cs)

	    and escape(k,cs) =
		case String.sub(s,k)
		  of #"a"  => convert(k+1, #"\a"::cs)
		   | #"b"  => convert(k+1, #"\b"::cs)
		   | #"t"  => convert(k+1, #"\t"::cs)
		   | #"n"  => convert(k+1, #"\n"::cs)
		   | #"v"  => convert(k+1, #"\v"::cs)
		   | #"f"  => convert(k+1, #"\f"::cs)
		   | #"r"  => convert(k+1, #"\r"::cs)
		   | #"\"" => convert(k+1, #"\""::cs)
		   | #"\\" => convert(k+1, #"\\"::cs)
		   | #"^"  => let val c = String.sub(s,k+1) in
				  convert(k+2, WideChar.chr(Char.ord c -
							    Char.ord #"0")::cs)
			      end

		   | #"u"  => let val s' = String.extract(s, k+1, SOME 4) in
				  convert(k+5, unicode s' :: cs)
			      end

		   |   c   => if Char.isDigit c then
				  let val s' = String.extract(s, k, SOME 3) in
				      convert(k+3, dec s' :: cs)
				  end
			      else if Char.isSpace c then
				   gap(k+1, cs)
			      else raise Crash.Crash "Lexer.toString: \
						     \invalid escape sequence"

	    and gap(k, cs) =
		    if String.sub(s,k) = #"\\" then
			convert(k+1, cs)
		    else
			gap(k+1, cs)

	in
	    convert(1,[])
	end


    fun toChar(s, i) =
	let
	    val s'  = String.substring(s, 1, String.size s - 1)
	    val ss' = toString(s', i)
	in
	    if WideString.size ss' = 1 then
		WideString.sub(ss', 0)
	    else
		error(i, E.CharLengthInvalid ss')
	end

end (* end of user routines *)
exception LexError (* raised if illegal leaf action tried *)
structure Internal =
	struct

datatype yyfinstate = N of int
type statedata = {fin : yyfinstate list, trans: int Vector.vector}
(* transition & final state table *)
val tab = let
fun decode s k =
  let val k' = k + k
      val hi = Char.ord(String.sub(s, k'))
      val lo = Char.ord(String.sub(s, k' + 1))
  in hi * 256 + lo end
val s = [ 
 (0,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (1,256, 
"\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\001\058\001\059\001\058\001\058\001\058\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\001\058\000\216\001\046\001\033\000\216\000\216\000\216\001\031\
\\001\029\001\028\001\027\000\216\001\026\001\024\001\021\000\216\
\\001\009\001\007\001\007\001\007\001\007\001\007\001\007\001\007\
\\001\007\001\007\001\005\001\004\000\216\001\002\000\216\000\216\
\\000\216\000\027\000\027\000\027\000\027\000\027\000\027\000\027\
\\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\
\\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\
\\000\027\000\027\000\027\001\001\000\216\001\000\000\216\000\217\
\\000\216\000\201\000\027\000\187\000\178\000\159\000\146\000\027\
\\000\140\000\123\000\027\000\027\000\116\000\027\000\110\000\100\
\\000\096\000\027\000\089\000\066\000\059\000\053\000\050\000\029\
\\000\027\000\027\000\027\000\026\000\025\000\024\000\006\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005"
),
 (3,256, 
"\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\065\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\063\001\060\001\061\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060"
),
 (6,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\007\000\000\000\007\000\007\000\007\000\007\000\000\
\\000\000\000\000\000\007\000\007\000\000\000\007\000\000\000\007\
\\000\019\000\008\000\008\000\008\000\008\000\008\000\008\000\008\
\\000\008\000\008\000\007\000\000\000\007\000\007\000\007\000\007\
\\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\007\000\000\000\007\000\000\
\\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\007\000\000\000\007\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (7,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\007\000\000\000\007\000\007\000\007\000\007\000\000\
\\000\000\000\000\000\007\000\007\000\000\000\007\000\000\000\007\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\007\000\000\000\007\000\007\000\007\000\007\
\\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\007\000\000\000\007\000\000\
\\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\007\000\000\000\007\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (8,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\013\000\000\
\\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\
\\000\008\000\008\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\009\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\009\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (9,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\
\\000\012\000\012\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\010\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (10,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\
\\000\011\000\011\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (12,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\
\\000\012\000\012\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (13,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\014\
\\000\014\000\014\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (14,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\014\
\\000\014\000\014\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\015\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\015\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (15,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\
\\000\018\000\018\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (16,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\
\\000\017\000\017\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (18,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\
\\000\018\000\018\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (19,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\013\000\000\
\\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\
\\000\008\000\008\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\009\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\022\000\000\000\000\000\009\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\020\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (20,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\
\\000\021\000\021\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\021\000\021\000\021\000\021\000\021\000\021\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\021\000\021\000\021\000\021\000\021\000\021\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (22,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\023\000\023\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (27,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (29,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\043\000\030\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (30,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\031\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (31,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\032\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (32,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\040\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\036\000\028\000\033\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (33,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\034\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (34,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\035\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (36,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\037\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (37,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\038\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (38,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\039\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (40,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\041\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (41,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\042\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (43,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\047\000\028\000\028\
\\000\028\000\044\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (44,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\045\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (45,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\046\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (47,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\048\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (48,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\049\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (50,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\051\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (51,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\052\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (53,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\054\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (54,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\055\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (55,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\056\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (56,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\057\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (57,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\058\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (59,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\063\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\060\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (60,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\061\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (61,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\062\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (63,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\064\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (64,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\065\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (66,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\083\000\075\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\067\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (67,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\068\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (68,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\069\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (69,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\070\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (70,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\071\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (71,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\072\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (72,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\073\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (73,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\074\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (75,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\076\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (76,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\077\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (77,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\078\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (78,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\079\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (79,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\080\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (80,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\081\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (81,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\082\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (83,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\084\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (84,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\085\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (85,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\086\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (86,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\087\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (87,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\088\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (89,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\092\000\028\000\028\000\028\000\090\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (90,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\091\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (92,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\093\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (93,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\094\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (94,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\095\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (96,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\097\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (97,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\098\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (98,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\099\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (100,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\109\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\106\000\028\000\101\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (101,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\102\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (102,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\103\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (103,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\104\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (104,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\105\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (106,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\107\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (107,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\108\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (110,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\111\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (111,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\112\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (112,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\113\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (113,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\114\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (114,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\115\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (116,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\121\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\117\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (117,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\118\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (118,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\119\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (119,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\120\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (121,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\122\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (123,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\139\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\134\000\124\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (124,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\129\000\028\000\028\000\125\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (125,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\126\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (126,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\127\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (127,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\128\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (129,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\130\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (130,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\131\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (131,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\132\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (132,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\133\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (134,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\135\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (135,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\136\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (136,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\137\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (137,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\138\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (140,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\141\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (141,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\142\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (142,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\143\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (143,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\144\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (144,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\145\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (146,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\157\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\156\000\028\
\\000\028\000\028\000\153\000\028\000\028\000\147\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (147,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\148\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (148,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\149\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (149,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\150\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (150,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\151\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (151,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\152\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (153,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\154\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (154,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\155\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (157,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\158\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (159,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\175\000\028\000\173\000\028\
\\000\028\000\168\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\160\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (160,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\161\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (161,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\162\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (162,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\163\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (163,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\164\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (164,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\165\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (165,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\166\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (166,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\167\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (168,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\169\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (169,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\170\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (170,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\171\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (171,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\172\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (173,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\174\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (175,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\176\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (176,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\177\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (178,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\180\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\179\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (180,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\181\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (181,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\182\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (182,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\183\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (183,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\184\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (184,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\185\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (185,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\186\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (187,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\198\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\188\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (188,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\189\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (189,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\190\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (190,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\191\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (191,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\192\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (192,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\193\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (193,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\194\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (194,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\195\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (195,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\196\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (196,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\197\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (198,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\199\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (199,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\200\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (201,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\210\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\203\000\028\
\\000\028\000\028\000\028\000\202\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (203,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\205\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\204\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (205,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\206\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (206,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\207\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (207,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\208\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (208,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\209\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (210,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\211\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (211,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\212\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (212,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\213\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (213,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\214\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (214,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\215\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (217,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\218\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (218,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\250\000\000\000\000\
\\000\000\000\242\000\000\000\000\000\000\000\000\000\000\000\234\
\\000\219\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (219,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\220\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (220,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\228\000\000\000\000\
\\000\000\000\221\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (221,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\222\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (222,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\223\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (223,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\224\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (224,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\225\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (225,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\226\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (226,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\227\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (228,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\229\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (229,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\230\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (230,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\231\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (231,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\232\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (232,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\233\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (234,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\235\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (235,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\236\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (236,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\237\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (237,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\238\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (238,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\239\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (239,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\240\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (240,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\241\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (242,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\243\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (243,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\244\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (244,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\245\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (245,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\246\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (246,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\247\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (247,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\248\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (248,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\249\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (250,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\251\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (251,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\252\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (252,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\253\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (253,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\254\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (254,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\255\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (258,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\007\000\000\000\007\000\007\000\007\000\007\000\000\
\\000\000\000\000\000\007\000\007\000\000\000\007\000\000\000\007\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\007\000\000\000\007\000\007\001\003\000\007\
\\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\007\000\000\000\007\000\000\
\\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\007\000\000\000\007\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (261,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\007\000\000\000\007\000\007\000\007\000\007\000\000\
\\000\000\000\000\000\007\000\007\000\000\000\007\000\000\000\007\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\007\000\000\000\007\000\007\001\006\000\007\
\\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\007\000\000\000\007\000\000\
\\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\007\000\000\000\007\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (263,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\013\000\000\
\\001\008\001\008\001\008\001\008\001\008\001\008\001\008\001\008\
\\001\008\001\008\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\009\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\009\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (265,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\013\000\000\
\\001\020\001\020\001\020\001\020\001\020\001\020\001\020\001\020\
\\001\020\001\020\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\009\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\001\018\000\000\000\000\000\009\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\014\
\\001\010\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (266,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\013\001\013\001\013\001\013\001\013\001\013\001\013\001\013\
\\001\013\001\013\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\013\001\013\001\013\001\013\001\013\001\013\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\013\001\013\001\013\001\013\001\013\001\013\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\011\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (267,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\012\001\012\001\012\001\012\001\012\001\012\001\012\001\012\
\\001\012\001\012\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\012\001\012\001\012\001\012\001\012\001\012\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\012\001\012\001\012\001\012\001\012\001\012\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (269,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\013\001\013\001\013\001\013\001\013\001\013\001\013\001\013\
\\001\013\001\013\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\013\001\013\001\013\001\013\001\013\001\013\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\013\001\013\001\013\001\013\001\013\001\013\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (270,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\017\001\017\001\017\001\017\001\017\001\017\001\017\001\017\
\\001\017\001\017\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\001\015\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\011\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (271,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\016\001\016\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (273,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\017\001\017\001\017\001\017\001\017\001\017\001\017\001\017\
\\001\017\001\017\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (274,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\019\001\019\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\015\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (275,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\019\001\019\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (276,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\013\000\000\
\\001\020\001\020\001\020\001\020\001\020\001\020\001\020\001\020\
\\001\020\001\020\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\009\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\009\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (277,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\001\022\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (278,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\001\023\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (280,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\007\000\000\000\007\000\007\000\007\000\007\000\000\
\\000\000\000\000\000\007\000\007\000\000\000\007\000\000\000\007\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\007\000\000\000\007\000\007\001\025\000\007\
\\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\007\000\000\000\007\000\000\
\\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\007\000\000\000\007\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (285,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\001\030\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (287,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\032\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\032\001\032\001\032\001\032\001\032\001\032\001\032\001\032\
\\001\032\001\032\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\032\001\032\001\032\001\032\001\032\001\032\001\032\
\\001\032\001\032\001\032\001\032\001\032\001\032\001\032\001\032\
\\001\032\001\032\001\032\001\032\001\032\001\032\001\032\001\032\
\\001\032\001\032\001\032\000\000\000\000\000\000\000\000\001\032\
\\000\000\001\032\001\032\001\032\001\032\001\032\001\032\001\032\
\\001\032\001\032\001\032\001\032\001\032\001\032\001\032\001\032\
\\001\032\001\032\001\032\001\032\001\032\001\032\001\032\001\032\
\\001\032\001\032\001\032\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (289,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\007\001\035\000\007\000\007\000\007\000\007\000\000\
\\000\000\000\000\000\007\000\007\000\000\000\007\000\000\000\007\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\007\000\000\000\007\000\007\000\007\000\007\
\\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\001\034\000\007\000\000\000\007\000\000\
\\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\007\000\000\000\007\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (291,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\035\001\035\001\045\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\036\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\000\000\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035"
),
 (292,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\044\001\044\001\044\001\044\001\044\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\044\000\000\001\035\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\042\001\042\001\042\001\042\001\042\001\042\001\042\001\042\
\\001\042\001\042\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\001\035\000\000\001\041\000\000\
\\000\000\001\035\001\035\000\000\000\000\000\000\001\035\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\001\035\000\000\
\\000\000\000\000\001\035\000\000\001\035\001\037\001\035\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (293,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\038\001\038\001\038\001\038\001\038\001\038\001\038\001\038\
\\001\038\001\038\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\038\001\038\001\038\001\038\001\038\001\038\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\038\001\038\001\038\001\038\001\038\001\038\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (294,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\039\001\039\001\039\001\039\001\039\001\039\001\039\001\039\
\\001\039\001\039\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\039\001\039\001\039\001\039\001\039\001\039\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\039\001\039\001\039\001\039\001\039\001\039\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (295,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\040\001\040\001\040\001\040\001\040\001\040\001\040\001\040\
\\001\040\001\040\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\040\001\040\001\040\001\040\001\040\001\040\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\040\001\040\001\040\001\040\001\040\001\040\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (296,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\035\001\035\001\035\001\035\001\035\001\035\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\035\001\035\001\035\001\035\001\035\001\035\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (297,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (298,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\043\001\043\001\043\001\043\001\043\001\043\001\043\001\043\
\\001\043\001\043\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (299,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (300,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\044\001\044\001\044\001\044\001\044\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\044\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\001\035\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (302,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\047\001\047\001\057\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\048\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\000\000\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047"
),
 (304,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\056\001\056\001\056\001\056\001\056\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\056\000\000\001\047\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\054\001\054\001\054\001\054\001\054\001\054\001\054\001\054\
\\001\054\001\054\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\001\047\000\000\001\053\000\000\
\\000\000\001\047\001\047\000\000\000\000\000\000\001\047\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\001\047\000\000\
\\000\000\000\000\001\047\000\000\001\047\001\049\001\047\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (305,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\050\001\050\001\050\001\050\001\050\001\050\001\050\001\050\
\\001\050\001\050\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\050\001\050\001\050\001\050\001\050\001\050\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\050\001\050\001\050\001\050\001\050\001\050\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (306,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\051\001\051\001\051\001\051\001\051\001\051\001\051\001\051\
\\001\051\001\051\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\051\001\051\001\051\001\051\001\051\001\051\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\051\001\051\001\051\001\051\001\051\001\051\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (307,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\052\001\052\001\052\001\052\001\052\001\052\001\052\001\052\
\\001\052\001\052\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\052\001\052\001\052\001\052\001\052\001\052\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\052\001\052\001\052\001\052\001\052\001\052\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (308,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\047\001\047\001\047\001\047\001\047\001\047\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\047\001\047\001\047\001\047\001\047\001\047\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (309,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (310,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\055\001\055\001\055\001\055\001\055\001\055\001\055\001\055\
\\001\055\001\055\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (311,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (312,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\056\001\056\001\056\001\056\001\056\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\056\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\001\047\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (314,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\059\001\059\001\059\001\059\001\059\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\059\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (317,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\062\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (319,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\001\064\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
(0, 0, "")]
fun f(n, i, x) = (n, Vector.tabulate(i, decode x)) 
val s = map f (rev (tl (rev s))) 
exception LexHackingError 
fun look ((j,x)::r, i) = if i = j then x else look(r, i) 
  | look ([], i) = raise LexHackingError
fun g {fin=x, trans=i} = {fin=x, trans=look(s,i)} 
in Vector.fromList(map g 
[{fin = [], trans = 0},
{fin = [], trans = 1},
{fin = [], trans = 1},
{fin = [], trans = 3},
{fin = [], trans = 3},
{fin = [(N 594)], trans = 0},
{fin = [(N 577),(N 594)], trans = 6},
{fin = [(N 577)], trans = 7},
{fin = [(N 436)], trans = 8},
{fin = [], trans = 9},
{fin = [], trans = 10},
{fin = [(N 483)], trans = 10},
{fin = [(N 483)], trans = 12},
{fin = [], trans = 13},
{fin = [(N 483)], trans = 14},
{fin = [], trans = 15},
{fin = [], trans = 16},
{fin = [(N 483)], trans = 16},
{fin = [(N 483)], trans = 18},
{fin = [(N 436)], trans = 19},
{fin = [], trans = 20},
{fin = [(N 436)], trans = 20},
{fin = [], trans = 22},
{fin = [(N 436)], trans = 22},
{fin = [(N 48),(N 594)], trans = 0},
{fin = [(N 46),(N 577),(N 594)], trans = 7},
{fin = [(N 44),(N 594)], trans = 0},
{fin = [(N 574),(N 594)], trans = 27},
{fin = [(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 29},
{fin = [(N 574)], trans = 30},
{fin = [(N 574)], trans = 31},
{fin = [(N 380),(N 574)], trans = 32},
{fin = [(N 574)], trans = 33},
{fin = [(N 574)], trans = 34},
{fin = [(N 405),(N 574)], trans = 27},
{fin = [(N 574)], trans = 36},
{fin = [(N 574)], trans = 37},
{fin = [(N 574)], trans = 38},
{fin = [(N 397),(N 574)], trans = 27},
{fin = [(N 574)], trans = 40},
{fin = [(N 574)], trans = 41},
{fin = [(N 388),(N 574)], trans = 27},
{fin = [(N 574)], trans = 43},
{fin = [(N 574)], trans = 44},
{fin = [(N 574)], trans = 45},
{fin = [(N 375),(N 574)], trans = 27},
{fin = [(N 574)], trans = 47},
{fin = [(N 574)], trans = 48},
{fin = [(N 369),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 50},
{fin = [(N 574)], trans = 51},
{fin = [(N 363),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 53},
{fin = [(N 574)], trans = 54},
{fin = [(N 574)], trans = 55},
{fin = [(N 574)], trans = 56},
{fin = [(N 574)], trans = 57},
{fin = [(N 359),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 59},
{fin = [(N 574)], trans = 60},
{fin = [(N 574)], trans = 61},
{fin = [(N 352),(N 574)], trans = 27},
{fin = [(N 574)], trans = 63},
{fin = [(N 574)], trans = 64},
{fin = [(N 347),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 66},
{fin = [(N 574)], trans = 67},
{fin = [(N 574)], trans = 68},
{fin = [(N 574)], trans = 69},
{fin = [(N 574)], trans = 70},
{fin = [(N 332),(N 574)], trans = 71},
{fin = [(N 574)], trans = 72},
{fin = [(N 574)], trans = 73},
{fin = [(N 342),(N 574)], trans = 27},
{fin = [(N 574)], trans = 75},
{fin = [(N 315),(N 574)], trans = 76},
{fin = [(N 574)], trans = 77},
{fin = [(N 574)], trans = 78},
{fin = [(N 574)], trans = 79},
{fin = [(N 574)], trans = 80},
{fin = [(N 574)], trans = 81},
{fin = [(N 325),(N 574)], trans = 27},
{fin = [(N 574)], trans = 83},
{fin = [(N 574)], trans = 84},
{fin = [(N 574)], trans = 85},
{fin = [(N 574)], trans = 86},
{fin = [(N 574)], trans = 87},
{fin = [(N 311),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 89},
{fin = [(N 574)], trans = 90},
{fin = [(N 303),(N 574)], trans = 27},
{fin = [(N 574)], trans = 92},
{fin = [(N 574)], trans = 93},
{fin = [(N 574)], trans = 94},
{fin = [(N 299),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 96},
{fin = [(N 574)], trans = 97},
{fin = [(N 574)], trans = 98},
{fin = [(N 293),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 100},
{fin = [(N 574)], trans = 101},
{fin = [(N 574)], trans = 102},
{fin = [(N 574)], trans = 103},
{fin = [(N 574)], trans = 104},
{fin = [(N 288),(N 574)], trans = 27},
{fin = [(N 276),(N 574)], trans = 106},
{fin = [(N 574)], trans = 107},
{fin = [(N 281),(N 574)], trans = 27},
{fin = [(N 273),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 110},
{fin = [(N 574)], trans = 111},
{fin = [(N 263),(N 574)], trans = 112},
{fin = [(N 574)], trans = 113},
{fin = [(N 574)], trans = 114},
{fin = [(N 270),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 116},
{fin = [(N 574)], trans = 117},
{fin = [(N 574)], trans = 118},
{fin = [(N 574)], trans = 119},
{fin = [(N 259),(N 574)], trans = 27},
{fin = [(N 574)], trans = 121},
{fin = [(N 253),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 123},
{fin = [(N 228),(N 574)], trans = 124},
{fin = [(N 574)], trans = 125},
{fin = [(N 574)], trans = 126},
{fin = [(N 242),(N 574)], trans = 127},
{fin = [(N 249),(N 574)], trans = 27},
{fin = [(N 574)], trans = 129},
{fin = [(N 574)], trans = 130},
{fin = [(N 574)], trans = 131},
{fin = [(N 574)], trans = 132},
{fin = [(N 236),(N 574)], trans = 27},
{fin = [(N 574)], trans = 134},
{fin = [(N 574)], trans = 135},
{fin = [(N 574)], trans = 136},
{fin = [(N 574)], trans = 137},
{fin = [(N 225),(N 574)], trans = 27},
{fin = [(N 218),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 140},
{fin = [(N 574)], trans = 141},
{fin = [(N 574)], trans = 142},
{fin = [(N 574)], trans = 143},
{fin = [(N 574)], trans = 144},
{fin = [(N 215),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 146},
{fin = [(N 574)], trans = 147},
{fin = [(N 200),(N 574)], trans = 148},
{fin = [(N 574)], trans = 149},
{fin = [(N 574)], trans = 150},
{fin = [(N 574)], trans = 151},
{fin = [(N 208),(N 574)], trans = 27},
{fin = [(N 574)], trans = 153},
{fin = [(N 574)], trans = 154},
{fin = [(N 196),(N 574)], trans = 27},
{fin = [(N 191),(N 574)], trans = 27},
{fin = [(N 574)], trans = 157},
{fin = [(N 188),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 159},
{fin = [(N 574)], trans = 160},
{fin = [(N 574)], trans = 161},
{fin = [(N 574)], trans = 162},
{fin = [(N 574)], trans = 163},
{fin = [(N 574)], trans = 164},
{fin = [(N 574)], trans = 165},
{fin = [(N 574)], trans = 166},
{fin = [(N 184),(N 574)], trans = 27},
{fin = [(N 574)], trans = 168},
{fin = [(N 574)], trans = 169},
{fin = [(N 574)], trans = 170},
{fin = [(N 574)], trans = 171},
{fin = [(N 174),(N 574)], trans = 27},
{fin = [(N 574)], trans = 173},
{fin = [(N 167),(N 574)], trans = 27},
{fin = [(N 574)], trans = 175},
{fin = [(N 574)], trans = 176},
{fin = [(N 163),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 178},
{fin = [(N 158),(N 574)], trans = 27},
{fin = [(N 574)], trans = 180},
{fin = [(N 574)], trans = 181},
{fin = [(N 574)], trans = 182},
{fin = [(N 574)], trans = 183},
{fin = [(N 574)], trans = 184},
{fin = [(N 574)], trans = 185},
{fin = [(N 155),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 187},
{fin = [(N 574)], trans = 188},
{fin = [(N 574)], trans = 189},
{fin = [(N 574)], trans = 190},
{fin = [(N 574)], trans = 191},
{fin = [(N 574)], trans = 192},
{fin = [(N 574)], trans = 193},
{fin = [(N 574)], trans = 194},
{fin = [(N 574)], trans = 195},
{fin = [(N 574)], trans = 196},
{fin = [(N 146),(N 574)], trans = 27},
{fin = [(N 574)], trans = 198},
{fin = [(N 574)], trans = 199},
{fin = [(N 134),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 201},
{fin = [(N 129),(N 574)], trans = 27},
{fin = [(N 574)], trans = 203},
{fin = [(N 126),(N 574)], trans = 27},
{fin = [(N 114),(N 574)], trans = 205},
{fin = [(N 574)], trans = 206},
{fin = [(N 574)], trans = 207},
{fin = [(N 574)], trans = 208},
{fin = [(N 122),(N 574)], trans = 27},
{fin = [(N 574)], trans = 210},
{fin = [(N 574)], trans = 211},
{fin = [(N 574)], trans = 212},
{fin = [(N 574)], trans = 213},
{fin = [(N 574)], trans = 214},
{fin = [(N 110),(N 574)], trans = 27},
{fin = [(N 577),(N 594)], trans = 7},
{fin = [(N 42),(N 594)], trans = 217},
{fin = [], trans = 218},
{fin = [], trans = 219},
{fin = [], trans = 220},
{fin = [], trans = 221},
{fin = [], trans = 222},
{fin = [], trans = 223},
{fin = [], trans = 224},
{fin = [], trans = 225},
{fin = [], trans = 226},
{fin = [(N 102)], trans = 0},
{fin = [], trans = 228},
{fin = [], trans = 229},
{fin = [], trans = 230},
{fin = [], trans = 231},
{fin = [], trans = 232},
{fin = [(N 90)], trans = 0},
{fin = [], trans = 234},
{fin = [], trans = 235},
{fin = [], trans = 236},
{fin = [], trans = 237},
{fin = [], trans = 238},
{fin = [], trans = 239},
{fin = [], trans = 240},
{fin = [(N 79)], trans = 0},
{fin = [], trans = 242},
{fin = [], trans = 243},
{fin = [], trans = 244},
{fin = [], trans = 245},
{fin = [], trans = 246},
{fin = [], trans = 247},
{fin = [], trans = 248},
{fin = [(N 68)], trans = 0},
{fin = [], trans = 250},
{fin = [], trans = 251},
{fin = [], trans = 252},
{fin = [], trans = 253},
{fin = [], trans = 254},
{fin = [(N 57)], trans = 0},
{fin = [(N 40),(N 594)], trans = 0},
{fin = [(N 38),(N 594)], trans = 0},
{fin = [(N 33),(N 577),(N 594)], trans = 258},
{fin = [(N 36),(N 577)], trans = 7},
{fin = [(N 31),(N 594)], trans = 0},
{fin = [(N 26),(N 577),(N 594)], trans = 261},
{fin = [(N 29),(N 577)], trans = 7},
{fin = [(N 409),(N 412),(N 436),(N 594)], trans = 263},
{fin = [(N 412),(N 436)], trans = 263},
{fin = [(N 407),(N 436),(N 594)], trans = 265},
{fin = [], trans = 266},
{fin = [], trans = 267},
{fin = [(N 455)], trans = 267},
{fin = [(N 436)], trans = 269},
{fin = [], trans = 270},
{fin = [], trans = 271},
{fin = [(N 455)], trans = 271},
{fin = [(N 455)], trans = 273},
{fin = [], trans = 274},
{fin = [(N 436)], trans = 275},
{fin = [(N 436)], trans = 276},
{fin = [(N 20),(N 594)], trans = 277},
{fin = [], trans = 278},
{fin = [(N 24)], trans = 0},
{fin = [(N 577),(N 594)], trans = 280},
{fin = [(N 18),(N 577)], trans = 7},
{fin = [(N 15),(N 594)], trans = 0},
{fin = [(N 13),(N 577),(N 594)], trans = 7},
{fin = [(N 11),(N 594)], trans = 0},
{fin = [(N 9),(N 594)], trans = 285},
{fin = [(N 580)], trans = 0},
{fin = [(N 569),(N 594)], trans = 287},
{fin = [(N 569)], trans = 287},
{fin = [(N 4),(N 577),(N 594)], trans = 289},
{fin = [(N 7)], trans = 0},
{fin = [], trans = 291},
{fin = [], trans = 292},
{fin = [], trans = 293},
{fin = [], trans = 294},
{fin = [], trans = 295},
{fin = [], trans = 296},
{fin = [], trans = 297},
{fin = [], trans = 298},
{fin = [], trans = 299},
{fin = [], trans = 300},
{fin = [(N 564)], trans = 0},
{fin = [(N 592),(N 594)], trans = 302},
{fin = [], trans = 302},
{fin = [], trans = 304},
{fin = [], trans = 305},
{fin = [], trans = 306},
{fin = [], trans = 307},
{fin = [], trans = 308},
{fin = [], trans = 309},
{fin = [], trans = 310},
{fin = [], trans = 311},
{fin = [], trans = 312},
{fin = [(N 523)], trans = 0},
{fin = [(N 2),(N 594)], trans = 314},
{fin = [(N 2)], trans = 314},
{fin = [(N 588)], trans = 0},
{fin = [(N 588)], trans = 317},
{fin = [(N 586)], trans = 0},
{fin = [(N 588)], trans = 319},
{fin = [(N 583)], trans = 0},
{fin = [(N 590)], trans = 0}])
end
structure StartStates =
	struct
	datatype yystartstate = STARTSTATE of int

(* start state definitions *)

val COMMENT = STARTSTATE 3;
val INITIAL = STARTSTATE 1;

end
type result = UserDeclarations.lexresult
	exception LexerError (* raised if illegal leaf action tried *)
end

fun makeLexer yyinput =
let	val yygone0=1
	val yyb = ref "\n" 		(* buffer *)
	val yybl = ref 1		(*buffer length *)
	val yybufpos = ref 1		(* location of next character to use *)
	val yygone = ref yygone0	(* position in file of beginning of buffer *)
	val yydone = ref false		(* eof found yet? *)
	val yybegin = ref 1		(*Current 'start state' for lexer *)

	val YYBEGIN = fn (Internal.StartStates.STARTSTATE x) =>
		 yybegin := x

fun lex () : Internal.result =
let fun continue() = lex() in
  let fun scan (s,AcceptingLeaves : Internal.yyfinstate list list,l,i0) =
	let fun action (i,nil) = raise LexError
	| action (i,nil::l) = action (i-1,l)
	| action (i,(node::acts)::l) =
		case node of
		    Internal.N yyk => 
			(let val yytext = substring(!yyb,i0,i-i0)
			     val yypos = i0+ !yygone
			open UserDeclarations Internal.StartStates
 in (yybufpos := i; case yyk of 

			(* Application actions *)

  102 => ( token(PRIMITIVE, yypos, yytext) )
| 11 => ( token(RPAR,      yypos, yytext) )
| 110 => ( token(ABSTYPE,   yypos, yytext) )
| 114 => ( token(AND,       yypos, yytext) )
| 122 => ( token(ANDALSO,   yypos, yytext) )
| 126 => ( token(ANY,       yypos, yytext) )
| 129 => ( token(AS,        yypos, yytext) )
| 13 => ( token(STAR,      yypos, yytext) )
| 134 => ( token(CASE,      yypos, yytext) )
| 146 => ( token(CONSTRUCTOR,yypos, yytext) )
| 15 => ( token(COMMA,     yypos, yytext) )
| 155 => ( token(DATATYPE,  yypos, yytext) )
| 158 => ( token(DO,        yypos, yytext) )
| 163 => ( token(ELSE,      yypos, yytext) )
| 167 => ( token(END,       yypos, yytext) )
| 174 => ( token(EQTYPE,    yypos, yytext) )
| 18 => ( token(ARROW,     yypos, yytext) )
| 184 => ( token(EXCEPTION, yypos, yytext) )
| 188 => ( token(FCT,       yypos, yytext) )
| 191 => ( token(FN,        yypos, yytext) )
| 196 => ( token(FROM,      yypos, yytext) )
| 2 => ( continue() )
| 20 => ( token(DOT,       yypos, yytext) )
| 200 => ( token(FUN,       yypos, yytext) )
| 208 => ( token(FUNCTOR,   yypos, yytext) )
| 215 => ( token(HANDLE,    yypos, yytext) )
| 218 => ( token(IF,        yypos, yytext) )
| 225 => ( token(IMPORT,    yypos, yytext) )
| 228 => ( token(IN,        yypos, yytext) )
| 236 => ( token(INCLUDE,   yypos, yytext) )
| 24 => ( token(DOTS,      yypos, yytext) )
| 242 => ( token(INFIX,     yypos, yytext) )
| 249 => ( token(INFIXR,    yypos, yytext) )
| 253 => ( token(LET,       yypos, yytext) )
| 259 => ( token(LOCAL,     yypos, yytext) )
| 26 => ( token(COLON,     yypos, yytext) )
| 263 => ( token(NON,       yypos, yytext) )
| 270 => ( token(NONFIX,    yypos, yytext) )
| 273 => ( token(OF,        yypos, yytext) )
| 276 => ( token(OP,        yypos, yytext) )
| 281 => ( token(OPEN,      yypos, yytext) )
| 288 => ( token(ORELSE,    yypos, yytext) )
| 29 => ( token(COLONGREATER, yypos, yytext) )
| 293 => ( token(PACK,      yypos, yytext) )
| 299 => ( token(RAISE,     yypos, yytext) )
| 303 => ( token(REC,       yypos, yytext) )
| 31 => ( token(SEMICOLON, yypos, yytext) )
| 311 => ( token(SHARING,   yypos, yytext) )
| 315 => ( token(SIG,       yypos, yytext) )
| 325 => ( token(SIGNATURE, yypos, yytext) )
| 33 => ( token(EQUALS,    yypos, yytext) )
| 332 => ( token(STRUCT,    yypos, yytext) )
| 342 => ( token(STRUCTURE, yypos, yytext) )
| 347 => ( token(THEN,      yypos, yytext) )
| 352 => ( token(TYPE,      yypos, yytext) )
| 359 => ( token(UNPACK,    yypos, yytext) )
| 36 => ( token(DARROW,    yypos, yytext) )
| 363 => ( token(VAL,       yypos, yytext) )
| 369 => ( token(WHERE,     yypos, yytext) )
| 375 => ( token(WHILE,     yypos, yytext) )
| 38 => ( token(LBRACK,    yypos, yytext) )
| 380 => ( token(WITH,      yypos, yytext) )
| 388 => ( token(WITHFUN,   yypos, yytext) )
| 397 => ( token(WITHTYPE,  yypos, yytext) )
| 4 => ( token(HASH,      yypos, yytext) )
| 40 => ( token(RBRACK,    yypos, yytext) )
| 405 => ( token(WITHVAL,   yypos, yytext) )
| 407 => ( token  (ZERO,              yypos, yytext) )
| 409 => ( tokenOf(DIGIT,   toDigit,  yypos, yytext) )
| 412 => ( tokenOf(NUMERIC, toInt,    yypos, yytext) )
| 42 => ( token(UNDERBAR,  yypos, yytext) )
| 436 => ( tokenOf(INT,     toInt,    yypos, yytext) )
| 44 => ( token(LBRACE,    yypos, yytext) )
| 455 => ( tokenOf(WORD,    toWord,   yypos, yytext) )
| 46 => ( token(BAR,       yypos, yytext) )
| 48 => ( token(RBRACE,    yypos, yytext) )
| 483 => ( tokenOf(REAL,    toReal,   yypos, yytext) )
| 523 => ( tokenOf(STRING,  toString, yypos, yytext) )
| 564 => ( tokenOf(CHAR,    toChar,   yypos, yytext) )
| 569 => ( tokenOf(TYVAR,   toId,     yypos, yytext) )
| 57 => ( token(EQEQTYPE,  yypos, yytext) )
| 574 => ( tokenOf(ALPHA,   toId,     yypos, yytext) )
| 577 => ( tokenOf(SYMBOL,  toId,     yypos, yytext) )
| 580 => ( nesting := 1 ; YYBEGIN COMMENT ; continue() )
| 583 => ( nesting := !nesting+1 ; continue() )
| 586 => ( nesting := !nesting-1 ;
			     if !nesting = 0 then YYBEGIN INITIAL else () ;
			     continue() )
| 588 => ( continue() )
| 590 => ( continue() )
| 592 => ( error'(yypos, yytext, E.InvalidString) )
| 594 => ( error'(yypos, yytext,
				    E.InvalidChar(String.sub(yytext,0))) )
| 68 => ( token(INSTANCE,  yypos, yytext) )
| 7 => ( token(HASHBRACK, yypos, yytext) )
| 79 => ( token(OVERLOAD,  yypos, yytext) )
| 9 => ( token(LPAR,      yypos, yytext) )
| 90 => ( token(PREBOUND,  yypos, yytext) )
| _ => raise Internal.LexerError

		) end )

	val {fin,trans} = Vector.sub(Internal.tab, s)
	val NewAcceptingLeaves = fin::AcceptingLeaves
	in if l = !yybl then
	     if trans = #trans(Vector.sub(Internal.tab,0))
	       then action(l,NewAcceptingLeaves
) else	    let val newchars= if !yydone then "" else yyinput 1024
	    in if (size newchars)=0
		  then (yydone := true;
		        if (l=i0) then UserDeclarations.eof ()
		                  else action(l,NewAcceptingLeaves))
		  else (if i0=l then yyb := newchars
		     else yyb := substring(!yyb,i0,l-i0)^newchars;
		     yygone := !yygone+i0;
		     yybl := size (!yyb);
		     scan (s,AcceptingLeaves,l-i0,0))
	    end
	  else let val NewChar = Char.ord(String.sub(!yyb,l))
		val NewState = Vector.sub(trans, NewChar)
		in if NewState=0 then action(l,NewAcceptingLeaves)
		else scan(NewState,NewAcceptingLeaves,l+1,i0)
	end
	end
(*
	val start= if substring(!yyb,!yybufpos-1,1)="\n"
then !yybegin+1 else !yybegin
*)
	in scan(!yybegin (* start *),nil,!yybufpos,!yybufpos)
    end
end
  in lex
  end
end
(* src # 104 *)
functor CountPosLexer(
	structure Lexer: LEXER
	where type UserDeclarations.pos = int
	where type ('a,'b) UserDeclarations.token = ('a,'b) LrParser.Token.token
	structure LexerError: LEXER_ERROR
	where type token =
		(Lexer.UserDeclarations.svalue, int) LrParser.Token.token
	val error : Source.region * LexerError.error -> 'a
) : LEXER =
  struct

    structure UserDeclarations =
      struct
	open Lexer.UserDeclarations
	type pos = Source.pos
      end

    fun makeLexer yyinput =
	let
	    val lin  = ref 1
	    val col  = ref 0
	    val pos  = ref 0
	    val buf  = ref ""	(* current buffer *)
	    val buf' = ref ""	(* next buffer *)
	    val off  = ref 0	(* offset to start of current buffer *)
	    val off' = ref 0	(* offset for next buffer *)

	    fun count(i, i', lin, col) =
		if i = i' then
		    (lin,col)
		else (case String.sub(!buf, i)
		    of #"\n" => count(i+1, i', lin+1, 0)
		     | #"\t" => count(i+1, i', lin, col+8-(col mod 8))
		     |  _    => count(i+1, i', lin, col+1)
		) handle Subscript =>
		let
		    val n = String.size(!buf)
		in
		    buf  := !buf' ;
		    buf' := ""    ;
		    off  := !off' ;
		    count(0, i'-n, lin, col)
		end

	    fun transform(pos1, pos2) =
		let
		    val n0 = !off
		    val pos1' as (l1,c1) = count(!pos-n0, pos1-n0, !lin, !col)
		    val n0 = !off
		    val pos2' as (l2,c2) = count(pos1-n0, pos2-n0, l1, c1)
		in
		    lin := l2 ;
		    col := c2 ;
		    pos := pos2 ;
		    (pos1',pos2')
		end

	    fun yyinput' n =
		let
		    val s = yyinput n
		in
		    buf' := s ;
		    off' := !off + String.size(!buf) ;
		    s
		end

	    val lexer = Lexer.makeLexer yyinput'
	in
	    fn () =>
		let
		    val LrParser.Token.TOKEN(term, (svalue,pos1,pos2)) =
			lexer() handle LexerError.EOF f =>
			let val pos = !off'+String.size(!buf') in f(pos,pos) end
		    val (pos1', pos2') = transform(pos1, pos2)
		in
		    LrParser.Token.TOKEN(term, (svalue, pos1', pos2'))
		end
		handle LexerError.Error(position, e) =>
		    error(transform position, e)
	end

  end
(* src # 105 *)
signature PARSING_PHASE =
  sig

    val parse: Source.source -> InputGrammar.Component

  end
(* src # 106 *)
structure ParsingPhase :> PARSING_PHASE =
  struct

    (* Import *)

    structure Grammar = InputGrammar
    structure E       = ParsingError


    (* Build Yacc parser *)

    structure LrVals = LrVals(structure Token        = LrParser.Token
			      structure DerivedForms = DerivedForms)

    structure LexerError = LexerError(structure Tokens = LrVals.Tokens
				      type error       = ParsingError.error)

    structure Lexer  = Lexer (structure Tokens     = LrVals.Tokens
			      structure LexerError = LexerError)

    structure Lexer' = CountPosLexer(structure Lexer      = Lexer
				     structure LexerError = LexerError
				     val error            = ParsingError.error)

    structure Parser = Join  (structure LrParser   = LrParser
			      structure ParserData = LrVals.ParserData
			      structure Lex        = Lexer')


    (* The actual parsing function *)

    fun parse source =
	let
	    val yyread = ref false
	    fun yyinput _ =
		if !yyread then
		    ""
		else
		    ( yyread := true; source )

	    val lexer = Parser.makeLexer yyinput

	    fun onError(s, pos1, pos2) = E.error((pos1,pos2), E.SyntaxError s)
	in
	    #1 (Parser.parse(0, lexer, onError, ()))
	end

  end
(* src # 107 *)
signature BIND_ENV0 =
  sig

    val E0 :	BindEnv.Env

  end
(* src # 108 *)
structure BindEnv0 :> BIND_ENV0 =
  struct

    open BindEnv

    structure P = Prebound

    val i = Source.nowhere

    (* Prebound *)

    val E = new()

    (* Type environment *)

    val E_empty = new()
    val E_bool  = new()
    val E_list  = new()
    val E_ref   = new()

    val _ = insertVal(E_bool, VId.fromString "false", (i,P.stamp_false,C 0))
    val _ = insertVal(E_bool, VId.fromString "true",  (i,P.stamp_true, C 0))
    val _ = insertVal(E_list, VId.fromString "nil",   (i,P.stamp_nil,  C 0))
    val _ = insertVal(E_list, VId.fromString "::",    (i,P.stamp_cons, C 1))
    val _ = insertVal(E_ref,  VId.fromString "ref",   (i,P.stamp_ref,  R))

    val _ = insertTy(E, TyCon.fromString "bool",   (i, P.stamp_bool,   E_bool))
    val _ = insertTy(E, TyCon.fromString "int",    (i, P.stamp_int,    E_empty))
    val _ = insertTy(E, TyCon.fromString "word",   (i, P.stamp_word,   E_empty))
    val _ = insertTy(E, TyCon.fromString "real",   (i, P.stamp_real,   E_empty))
    val _ = insertTy(E, TyCon.fromString "char",   (i, P.stamp_char,   E_empty))
    val _ = insertTy(E, TyCon.fromString "string", (i, P.stamp_string, E_empty))
    val _ = insertTy(E, TyCon.fromString "list",   (i, P.stamp_list,   E_list))
    val _ = insertTy(E, TyCon.fromString "ref",    (i, P.stamp_tref,   E_ref))
    val _ = insertTy(E, TyCon.fromString "exn",    (i, P.stamp_exn,    E_empty))

    (* Value environment *)

    val _ = union(E, E_bool)
    val _ = union(E, E_list)
    val _ = union(E, E_ref)

    val _ = insertVal(E, VId.fromString "Match", (i, P.stamp_Match, C 0))
    val _ = insertVal(E, VId.fromString "Bind",  (i, P.stamp_Bind,  C 0))

    (* Global *)

    val E0 = new()

    val _  = insertStr(E0, StrId.fromString "", (i, Stamp.new(), E))

  end
(* src # 109 *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature DEBUG =
    sig
	structure Intermediate: INTERMEDIATE_GRAMMAR = IntermediateGrammar

	val seqToString: string -> ('a -> string) -> 'a list -> string
	val listToString: ('a -> string) -> 'a list -> string
	val setToString: ('a -> string) -> 'a list -> string
	val posToString: string list -> string
	val idToString: Intermediate.id -> string
	val longidToString: Intermediate.longid -> string
	val mappingToString: (string list * Intermediate.id) list -> string
	val substToString: (Intermediate.id * Intermediate.id) list -> string
	val litToString: Intermediate.lit -> string
	val labToString: Intermediate.lab -> string
	val patToString: Intermediate.pat -> string
    end
(* src # 110 *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure Debug :> DEBUG =
    struct
	structure Intermediate = IntermediateGrammar
	open Intermediate

	fun seqToString sep toString (x::xs) =
	    List.foldl (fn (x, s) => toString x ^ sep ^ s) (toString x) xs
	  | seqToString _ _ nil = ""

	fun listToString toString xs = seqToString ", " toString xs

	fun setToString toString xs = "{" ^ listToString toString xs ^ "}"

	fun posToString pos =
	    seqToString "." (fn x => x) (List.rev ("e"::pos))

	fun labToString (Lab (_, s)) = s

	fun idToString (Id (_, stamp, InId)) =
	    "$" ^ Stamp.toString stamp
	  | idToString (Id (_, stamp, ExId s)) =
	    s ^ "$" ^ Stamp.toString stamp

	fun longidToString (LongId (_, longid, lab)) =
	    longidToString longid ^ "." ^ labToString lab
	  | longidToString (ShortId (_, id)) = idToString id

	fun mappingToString mapping =
	    "{" ^
	    listToString (fn (pos, id) =>
			  posToString pos ^ " = " ^ idToString id) mapping ^
	    "}"

	fun substToString subst =
	    "{" ^
	    listToString (fn (id, id') =>
			  idToString id ^ " -> " ^ idToString id') subst ^ "}"

	fun litToString (IntLit i) = LargeInt.toString i
	  | litToString _ = "<lit>"

	fun patToString (WildPat _) = "_"
	  | patToString (LitPat (_, lit)) = litToString lit
	  | patToString (VarPat (_, id)) = idToString id
	  | patToString (ConPat (_, longid, NONE)) = longidToString longid
	  | patToString (ConPat (_, longid, SOME pat)) =
	    "(" ^ longidToString longid ^ " " ^ patToString pat ^ ")"
	  | patToString (RefPat (_, pat)) = "(ref " ^ patToString pat ^ ")"
	  | patToString (TupPat (_, pats)) =
	    "(" ^ listToString patToString pats ^ ")"
	  | patToString (RowPat (_, patFields, hasDots)) =
	    "{" ^
	    listToString (fn Field (_, lab, pat) =>
			  labToString lab ^ ": " ^ patToString pat) patFields ^
	    (if hasDots then ", ..." else "") ^ "}"
	  | patToString (VecPat (_, pats)) =
	    "#[" ^ listToString patToString pats ^ "]"
	  | patToString (AsPat (_, pat1, pat2)) =
	    "(" ^ patToString pat1 ^ " as " ^ patToString pat2 ^ ")"
	  | patToString (AltPat (_, pats)) =
	    "(" ^ seqToString " | " patToString pats ^ ")"
	  | patToString (NegPat (_, pat)) = "(non " ^ patToString pat ^ ")"
	  | patToString (GuardPat (_, pat, _)) =
	    "(" ^ patToString pat ^ " when <exp>)"
	  | patToString (WithPat (_, pat, _)) =
	    "(" ^ patToString pat ^ " with <decs>)"
    end
(* src # 111 *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature IMPERATIVE_GRAMMAR =
    sig
	type coord = Source.region

	(* Literals *)

	datatype lit = datatype IntermediateGrammar.lit

	(* Identifiers *)

	type stamp = IntermediateGrammar.stamp

	datatype name = datatype IntermediateGrammar.name
	datatype id = datatype IntermediateGrammar.id

	type lab = string

	(* Expressions and Declarations *)

	type shared = int ref

	type isToplevel = bool
	type hasArgs = bool

	datatype test =
	    LitTest of lit
	  | ConTest of id * id option
	  | RefTest of id
	  | TupTest of id list
	  | RecTest of (lab * id) list
	    (* sorted, all labels distinct, no tuple *)
	  | LabTest of lab * id
	  | VecTest of id list

	datatype funFlag =
	    PrintName of string
	  | AuxiliaryOf of stamp

	datatype 'a args =
	    OneArg of 'a
	  | TupArgs of 'a list
	  | RecArgs of (lab * 'a) list
	    (* sorted, all labels distinct, no tuple *)

	structure StampSet: IMP_SET

	datatype livenessInfo =
	    Unknown
	  | LoopStart   (* internal *)
	  | LoopEnd   (* internal *)
	  | Use of StampSet.t   (* internal *)
	  | Kill of StampSet.t

	type info = coord * livenessInfo ref

	datatype stm =
	    ValDec of info * id * exp * isToplevel
	  | RecDec of info * (id * exp) list * isToplevel
	    (* all ids distinct *)
	  | EvalStm of info * exp
	  | RaiseStm of info * id
	  (* the following must always be last *)
	  | HandleStm of info * body * id * body * body * shared
	  | EndHandleStm of info * shared
	  | TestStm of info * id * test * body * body
	  | SharedStm of info * body * shared   (* used at least twice *)
	  | ReturnStm of info * exp
	  | IndirectStm of info * body option ref
	  | ExportStm of info * exp
	and exp =
	    LitExp of coord * lit
	  | PrimExp of coord * string
	  | NewExp of coord * string option * hasArgs
	  | VarExp of coord * id
	  | ConExp of coord * id * hasArgs
	  | RefExp of coord
	  | TupExp of coord * id list
	  | RecExp of coord * (lab * id) list
	    (* sorted, all labels distinct, no tuple *)
	  | SelExp of coord * lab
	  | VecExp of coord * id list
	  | FunExp of coord * stamp * funFlag list * (id args * body) list
	    (* all arities distinct; always contains a single OneArg *)
	  | AppExp of coord * id * id args
	  | SelAppExp of coord * lab * id
	  | ConAppExp of coord * id * id args
	  | RefAppExp of coord * id args
	  | PrimAppExp of coord * string * id list
	  | AdjExp of coord * id * id
	withtype body = stm list

	type component = (id * string) list * id list * body

	val infoStm: stm -> info
    end
(* src # 112 *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure ImperativeGrammar: IMPERATIVE_GRAMMAR =
    (*--** the above signature constraint should be opaque *)
    struct
	type coord = Source.region

	(* Literals *)

	datatype lit = datatype IntermediateGrammar.lit

	(* Identifiers *)

	type stamp = IntermediateGrammar.stamp

	datatype name = datatype IntermediateGrammar.name
	datatype id = datatype IntermediateGrammar.id

	type lab = string

	(* Expressions and Declarations *)

	type shared = int ref

	type isToplevel = bool
	type hasArgs = bool

	datatype test =
	    LitTest of lit
	  | ConTest of id * id option
	  | RefTest of id
	  | TupTest of id list
	  | RecTest of (lab * id) list
	    (* sorted, all labels distinct, no tuple *)
	  | LabTest of lab * id
	  | VecTest of id list

	datatype funFlag =
	    PrintName of string
	  | AuxiliaryOf of stamp

	datatype 'a args =
	    OneArg of 'a
	  | TupArgs of 'a list
	  | RecArgs of (lab * 'a) list
	    (* sorted, all labels distinct, no tuple *)

	structure StampSet =
	    MakeHashImpSet(type t = stamp
			   val hash = Stamp.hash)

	datatype livenessInfo =
	    Unknown
	  | LoopStart   (* internal *)
	  | LoopEnd   (* internal *)
	  | Use of StampSet.t   (* internal *)
	  | Kill of StampSet.t

	type info = coord * livenessInfo ref

	datatype stm =
	    ValDec of info * id * exp * isToplevel
	  | RecDec of info * (id * exp) list * isToplevel
	    (* all ids distinct *)
	  | EvalStm of info * exp
	  | RaiseStm of info * id
	  (* the following must always be last *)
	  | HandleStm of info * body * id * body * body * shared
	  | EndHandleStm of info * shared
	  | TestStm of info * id * test * body * body
	  | SharedStm of info * body * shared   (* used at least twice *)
	  | ReturnStm of info * exp
	  | IndirectStm of info * body option ref
	  | ExportStm of info * exp
	and exp =
	    LitExp of coord * lit
	  | PrimExp of coord * string
	  | NewExp of coord * string option * hasArgs
	  | VarExp of coord * id
	  | ConExp of coord * id * hasArgs
	  | RefExp of coord
	  | TupExp of coord * id list
	  | RecExp of coord * (lab * id) list
	    (* sorted, all labels distinct, no tuple *)
	  | SelExp of coord * lab
	  | VecExp of coord * id list
	  | FunExp of coord * stamp * funFlag list * (id args * body) list
	    (* all arities distinct; always contains a single OneArg *)
	  | AppExp of coord * id * id args
	  | SelAppExp of coord * lab * id
	  | ConAppExp of coord * id * id args
	  | RefAppExp of coord * id args
	  | PrimAppExp of coord * string * id list
	  | AdjExp of coord * id * id
	withtype body = stm list

	type component = (id * string) list * id list * body

	fun infoStm (ValDec (info, _, _, _)) = info
	  | infoStm (RecDec (info, _, _)) = info
	  | infoStm (EvalStm (info, _)) = info
	  | infoStm (RaiseStm (info, _)) = info
	  | infoStm (HandleStm (info, _, _, _, _, _)) = info
	  | infoStm (EndHandleStm (info, _)) = info
	  | infoStm (TestStm (info, _, _, _, _)) = info
	  | infoStm (SharedStm (info, _, _)) = info
	  | infoStm (ReturnStm (info, _)) = info
	  | infoStm (IndirectStm (info, _)) = info
	  | infoStm (ExportStm (info, _)) = info
    end
(* src # 113 *)
(*
 * Authors:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature OUTPUT_IMPERATIVE_GRAMMAR =
    sig
	structure I: IMPERATIVE_GRAMMAR = ImperativeGrammar

	val outputComponent: I.component -> string
    end
(* src # 114 *)
(*
 * Authors:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure OutputImperativeGrammar :> OUTPUT_IMPERATIVE_GRAMMAR =
    struct
	structure I = ImperativeGrammar

	open I

	datatype format =
	    SEQ of format list
	  | S of string
	  | IN
	  | EX
	  | NL
	  | ID of id
	  | CO of string
	  | NULL
	  | SEP of format * format list

	fun format f =
	    let
		val indent = ref 0
		fun format' (SEQ fs) = String.concat (List.map format' fs)
		  | format' (S s) = s
		  | format' IN = (indent := !indent + 1; "")
		  | format' EX = (indent := !indent - 1; "")
		  | format' NL =
		    "\n" ^ String.concat (List.tabulate
					  (!indent, fn _ => "  "))
		  | format' (ID (Id (_, stamp, InId))) =
		    "$" ^ Stamp.toString stamp
		  | format' (ID (Id (_, stamp, ExId s))) =
		    s ^ "$" ^ Stamp.toString stamp
		  | format' (CO s) = "   (* " ^ s ^ " *)"
		  | format' NULL = ""
		  | format' (SEP (f, f1::fr)) =
		    List.foldl (fn (fi, rest) => rest ^ format' f ^ format' fi)
		    (format' f1) fr
		  | format' (SEP (_, nil)) = ""
	    in
		format' f
	    end

	local
	    val count = ref 0
	in
	    fun gen () =
		let
		    val n = !count + 1
		in
		    count := n; n
		end
	end

	fun insert (x, ys as (y::yr)): int list =
	    if x < y then x::ys else y::insert (x, yr)
	  | insert (x, nil) = [x]

	val sort = StampSet.fold insert nil

	fun outputInfo (_, ref (Unknown | LoopStart | LoopEnd)) = NULL
	  | outputInfo (_, ref (Use set)) =
	    if StampSet.isEmpty set then SEQ [S "(* use *)", NL]
	    else
		SEQ [S (List.foldl (fn (stamp, s) =>
				    s ^ " " ^ Stamp.toString stamp)
			"(* use" (sort set)), S " *)", NL]
	  | outputInfo (_, ref (Kill set)) =
	    if StampSet.isEmpty set then SEQ [S "(* kill *)", NL]
	    else
		SEQ [S (List.foldl (fn (stamp, s) =>
				    s ^ " " ^ Stamp.toString stamp)
			"(* kill" (sort set)), S "*)", NL]

	fun outputLit (WordLit w) = "word " ^ LargeWord.toString w
	  | outputLit (IntLit i) = "int " ^ LargeInt.toString i
	  | outputLit (CharLit c) = "char " ^ Char.toCString c
	  | outputLit (StringLit s) = "string \"" ^ String.toCString s ^ "\""
	  | outputLit (RealLit r) = "real " ^ (*LargeReal.toString*) r

	fun outputArgs (OneArg id) = ID id
	  | outputArgs (TupArgs ids) =
	    SEQ [S "(", SEP (S ", ", List.map ID ids), S ")"]
	  | outputArgs (RecArgs labIdList) =
	    SEQ [S "{", SEP (S ", ",
			     List.map (fn (lab, id) =>
				       SEQ [S (lab ^ "="), ID id]) labIdList),
		 S "}"]

	fun outputTest (LitTest lit) = S (outputLit lit)
	  | outputTest (ConTest (id, NONE)) = SEQ [S "nam ", ID id]
	  | outputTest (ConTest (id1, SOME id2)) =
	    SEQ [S "(con ", ID id1, S ") ", ID id2]
	  | outputTest (RefTest id) = SEQ [S "(con ref) ", ID id]
	  | outputTest (TupTest ids) =
	    SEQ [S "(", SEP (S ", ", List.map ID ids), S ")"]
	  | outputTest (RecTest labIdList) =
	    SEQ [S "{", SEP (S ", ",
			     List.map (fn (lab, id) =>
				       SEQ [S (lab ^ "="), ID id]) labIdList),
		 S "}"]
	  | outputTest (LabTest (lab, id)) =
	    SEQ [S ("{" ^ lab ^ "="), ID id, S "...}"]
	  | outputTest (VecTest ids) =
	    SEQ [S "#[", SEP (S ", ", List.map ID ids), S "]"]

	fun outputStm (ValDec (_, id, exp, isToplevel)) =
	    SEQ [S "val ", ID id, S " = ", IN, outputExp exp, EX,
		 if isToplevel then CO "toplevel" else NULL]
	  | outputStm (RecDec (_, idExpList, isToplevel)) =
	    SEQ [S "rec", IN, if isToplevel then CO "toplevel" else NULL,
		 SEQ (List.map (fn (id, exp) =>
				SEQ [NL, S "val ", ID id, S " = ",
				     IN, outputExp exp, EX]) idExpList), EX]
	  | outputStm (EvalStm (_, exp)) =
	    SEQ [S "eval ", IN, outputExp exp, EX]
	  | outputStm (HandleStm (_, body1, id, body2, body3, shared)) =
	    (shared := gen ();
	     SEQ [S "try", CO (Int.toString (!shared)), IN, NL,
		  outputBody body1, EX, NL,
		  S "catch ", ID id, IN, NL, outputBody body2, EX, NL,
		  S "cont", IN, NL, outputBody body3, EX])
	  | outputStm (EndHandleStm (_, ref i)) =
	    S ("(* leave " ^ Int.toString i ^ " *)")
	  | outputStm (TestStm (_, id, test, body1, body2)) =
	    SEQ [S "case ", ID id, S " of ", IN, outputTest test, NL,
		 outputBody body1, EX, NL, S "else", IN, NL, outputBody body2,
		 EX]
	  | outputStm (RaiseStm (_, id)) =
	    SEQ [S "raise ", ID id]
	  | outputStm (SharedStm (_, body, shared as ref 0)) =
	    (shared := gen ();
	     SEQ [S ("label " ^ (Int.toString (!shared)) ^ ":"), NL,
		  outputBody body])
	  | outputStm (SharedStm (_, _, ref i)) =
	    SEQ [S ("goto " ^ (Int.toString i))]
	  | outputStm (ReturnStm (_, exp)) =
	    SEQ [S "return ", IN, outputExp exp, EX]
	  | outputStm (IndirectStm (_, ref bodyOpt)) =
	    SEQ [S "indirect", NL, outputBody (valOf bodyOpt)]
	  | outputStm (ExportStm (_, exp)) =
	    SEQ [S "export ", IN, outputExp exp, EX]
	and outputExp (LitExp (_, lit)) = S (outputLit lit)
	  | outputExp (PrimExp (_, s)) = S ("prim \"" ^ s ^ "\"")
	  | outputExp (NewExp (_, NONE, true)) = S "nam"
	  | outputExp (NewExp (_, SOME string, true)) =
	    S ("nam \"" ^ string ^ "\"")
	  | outputExp (NewExp (_, NONE, false)) = S "con"
	  | outputExp (NewExp (_, SOME string, false)) =
	    S ("con \"" ^ string ^ "\"")
	  | outputExp (VarExp (_, id)) = ID id
	  | outputExp (ConExp (_, id, false)) = SEQ [S "nam ", ID id]
	  | outputExp (ConExp (_, id, true)) = SEQ [S "con ", ID id]
	  | outputExp (RefExp _) = SEQ [S "con ref"]
	  | outputExp (TupExp (_, ids)) =
	    SEQ [S "(", SEP (S ", ", List.map ID ids), S ")"]
	  | outputExp (RecExp (_, labIdList)) =
	    SEQ [S "{", SEP (S ", ",
			     List.map (fn (lab, id) =>
				       SEQ [S (lab ^ "="), ID id]) labIdList),
		 S "}"]
	  | outputExp (SelExp (_, lab)) = SEQ [S ("#" ^ lab)]
	  | outputExp (VecExp (_, ids)) =
	    SEQ [S "#[", SEP (S ", ", List.map ID ids), S "]"]
	  | outputExp (FunExp (_, _, s, argsBodyList)) =
	    SEQ [NL, S "fn ",
		 SEP (SEQ [NL, S "| "],
		      List.map (fn (args, body) =>
				SEQ [outputArgs args, S " =>", IN, NL,
				     outputBody body, EX]) argsBodyList)]
	  | outputExp (AppExp (_, id, args)) =
	    SEQ [ID id, S " ", outputArgs args]
	  | outputExp (SelAppExp (_, lab, id)) =
	    SEQ [S ("#" ^ lab ^ " "), ID id]
	  | outputExp (ConAppExp (_, id, args)) =
	    SEQ [S "(con ", ID id, S ") ", outputArgs args]
	  | outputExp (RefAppExp (_, args)) =
	    SEQ [S "(con ref) ", outputArgs args]
	  | outputExp (PrimAppExp (_, s, ids)) =
	    SEQ [S (s ^ " "), SEP (S ", ", List.map ID ids)]
	  | outputExp (AdjExp (_, id1, id2)) =
	    SEQ [S "adj ", ID id1, S ", ", ID id2]
	and outputBody stms =
	    SEP (NL,
		 List.map (fn stm =>
			   SEQ [outputInfo (infoStm stm), outputStm stm]) stms)

	fun outputComponent (idStringList, _, body) =
	    format (SEQ [SEQ (List.map
			      (fn (id, string) =>
			       SEQ [S "import ", ID id,
				    S (" from " ^ string ^ "\n")])
			      idStringList), outputBody body, NL])
    end
(* src # 115 *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature INTERMEDIATE_AUX =
    sig
	structure Intermediate: INTERMEDIATE_GRAMMAR = IntermediateGrammar

	val foldli: (int * 'a * 'b -> 'b) -> 'b -> 'a list -> 'b

	val freshId: Intermediate.info -> Intermediate.id

	val idEq: Intermediate.id * Intermediate.id -> bool

	val occursInMatches: Intermediate.match list * Intermediate.id -> bool

	val patternVariablesOf: Intermediate.pat -> Intermediate.id list

	type subst = (Intermediate.id * Intermediate.id) list

	val substDec: Intermediate.dec * subst -> Intermediate.dec
	val substExp: Intermediate.exp * subst -> Intermediate.exp
	val substPat: Intermediate.pat * subst -> Intermediate.pat

	val separateAlt: Intermediate.pat -> Intermediate.pat
    end
(* src # 116 *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure IntermediateAux :> INTERMEDIATE_AUX =
    struct
	structure Intermediate = IntermediateGrammar
	open Intermediate

	local
	    fun foldli' (x::xr, f, z, i) =
		foldli' (xr, f, f (i, x, z), i + 1)
	      | foldli' (nil, _, z, _) = z
	in
	    fun foldli f z xs = foldli' (xs, f, z, 1)
	end

	fun freshId coord = Id (coord, Stamp.new (), InId)

	fun idEq (Id (_, stamp1, _), Id (_, stamp2, _)) = stamp1 = stamp2

	fun occursInDec (ValDec (_, pat, exp), id) =
	    occursInPat (pat, id) orelse occursInExp (exp, id)
	  | occursInDec (RecDec (_, decs), id) =
	    List.exists (fn dec => occursInDec (dec, id)) decs
	and occursInExp (LitExp (_, _), _) = false
	  | occursInExp (PrimExp (_, _), _) = false
	  | occursInExp (NewExp (_, _, _), _) = false
	  | occursInExp (VarExp (_, ShortId (_, id)), id') = idEq (id, id')
	  | occursInExp (VarExp (_, LongId (_, _, _)), _) = false
	  | occursInExp (ConExp (_, _, _), _) = false
	  | occursInExp (RefExp _, _) = false
	  | occursInExp (TupExp (_, exps), id) =
	    List.exists (fn exp => occursInExp (exp, id)) exps
	  | occursInExp (RowExp (_, expFields), id) =
	    List.exists (fn Field (_, _, exp) => occursInExp (exp, id))
	    expFields
	  | occursInExp (SelExp (_, _), _) = false
	  | occursInExp (VecExp (_, exps), id) =
	    List.exists (fn exp => occursInExp (exp, id)) exps
	  | occursInExp (FunExp (_, _, exp), id) = occursInExp (exp, id)
	  | occursInExp (AppExp (_, exp1, exp2), id) =
	    occursInExp (exp1, id) orelse occursInExp (exp2, id)
	  | occursInExp (AdjExp (_, exp1, exp2), id) =
	    occursInExp (exp1, id) orelse occursInExp (exp2, id)
	  | occursInExp (AndExp (_, exp1, exp2), id) =
	    occursInExp (exp1, id) orelse occursInExp (exp2, id)
	  | occursInExp (OrExp (_, exp1, exp2), id) =
	    occursInExp (exp1, id) orelse occursInExp (exp2, id)
	  | occursInExp (IfExp (_, exp1, exp2, exp3), id) =
	    occursInExp (exp1, id) orelse occursInExp (exp2, id) orelse
	    occursInExp (exp3, id)
	  | occursInExp (WhileExp (_, exp1, exp2), id) =
	    occursInExp (exp1, id) orelse occursInExp (exp2, id)
	  | occursInExp (SeqExp (_, exps), id) =
	    List.exists (fn exp => occursInExp (exp, id)) exps
	  | occursInExp (CaseExp (_, exp, matches), id) =
	    occursInExp (exp, id) orelse occursInMatches (matches, id)
	  | occursInExp (RaiseExp (_, exp), id) = occursInExp (exp, id)
	  | occursInExp (HandleExp (_, exp, matches), id) =
	    occursInExp (exp, id) orelse occursInMatches (matches, id)
	  | occursInExp (LetExp (_, decs, exp), id) =
	    List.exists (fn dec => occursInDec (dec, id)) decs orelse
	    occursInExp (exp, id)
	and occursInMatches (matches, id) =
	    List.exists (fn Match (_, pat, exp) =>
		       occursInPat (pat, id) orelse occursInExp (exp, id))
	    matches
	and occursInPat (WildPat _, _) = false
	  | occursInPat (LitPat (_, _), _) = false
	  | occursInPat (VarPat (_, _), _) = false
	  | occursInPat (ConPat (_, _, NONE), _) = false
	  | occursInPat (ConPat (_, _, SOME pat), id) = occursInPat (pat, id)
	  | occursInPat (RefPat (_, pat), id) = occursInPat (pat, id)
	  | occursInPat (TupPat (_, pats), id) =
	    List.exists (fn pat => occursInPat (pat, id)) pats
	  | occursInPat (RowPat (_, patFields, _), id) =
	    List.exists (fn Field (_, _, pat) => occursInPat (pat, id))
	    patFields
	  | occursInPat (VecPat (_, pats), id) =
	    List.exists (fn pat => occursInPat (pat, id)) pats
	  | occursInPat (AsPat (_, pat1, pat2), id) =
	    occursInPat (pat1, id) orelse occursInPat (pat2, id)
	  | occursInPat (AltPat (_, pats), id) =
	    List.exists (fn pat => occursInPat (pat, id)) pats
	  | occursInPat (NegPat (_, pat), id) = occursInPat (pat, id)
	  | occursInPat (GuardPat (_, pat, exp), id) =
	    occursInPat (pat, id) orelse occursInExp (exp, id)
	  | occursInPat (WithPat (_, pat, decs), id) =
	    occursInPat (pat, id) orelse
	    List.exists (fn dec => occursInDec (dec, id)) decs

	local
	    fun patternVariablesOf' (WildPat _, ids) = ids
	      | patternVariablesOf' (LitPat (_, _), ids) = ids
	      | patternVariablesOf' (VarPat (_, id), ids) = id::ids
	      | patternVariablesOf' (ConPat (_, _, NONE), ids) = ids
	      | patternVariablesOf' (ConPat (_, _, SOME pat), ids) =
		patternVariablesOf' (pat, ids)
	      | patternVariablesOf' (RefPat (_, pat), ids) =
		patternVariablesOf' (pat, ids)
	      | patternVariablesOf' (TupPat (_, pats), ids) =
		foldr patternVariablesOf' ids pats
	      | patternVariablesOf' (RowPat (_, fieldPats, _), ids) =
		foldr (fn (Field (_, _, pat), ids) =>
		       patternVariablesOf' (pat, ids)) ids fieldPats
	      | patternVariablesOf' (VecPat (_, pats), ids) =
		foldr patternVariablesOf' ids pats
	      | patternVariablesOf' (AsPat (_, pat1, pat2), ids) =
		patternVariablesOf' (pat1, patternVariablesOf' (pat2, ids))
	      | patternVariablesOf' (AltPat (_, pat::_), ids) =
		patternVariablesOf' (pat, ids)
	      | patternVariablesOf' (AltPat (_, nil), ids) = ids
	      | patternVariablesOf' (NegPat (_, _), ids) = ids
	      | patternVariablesOf' (GuardPat (_, pat, _), ids) =
		patternVariablesOf' (pat, ids)
	      | patternVariablesOf' (WithPat (_, pat, decs), ids) =
		patternVariablesOf' (pat, foldr declaredVariables ids decs)
	    and declaredVariables (ValDec (_, pat, _), ids) =
		patternVariablesOf' (pat, ids)
	      | declaredVariables (RecDec (_, decs), ids) =
		foldr declaredVariables ids decs
	in
	    fun patternVariablesOf pat = patternVariablesOf' (pat, nil)
	end

	type subst = (id * id) list

	fun lookup ((Id (_, stamp, _), id')::subst, id0 as Id (_, stamp0, _)) =
	    if stamp = stamp0 then id'
	    else lookup (subst, id0)
	  | lookup (nil, id0) = id0

	fun substLongId (ShortId (coord, id), subst) =
	    ShortId (coord, lookup (subst, id))
	  | substLongId (longid as LongId (_, _, _), _) = longid

	fun substDecs (dec::decr, subst) =
	    substDec (dec, subst)::substDecs (decr, subst)
	  | substDecs (nil, _) = nil
	and substDec (ValDec (coord, pat, exp), subst) =
	    ValDec (coord, substPat (pat, subst), substExp (exp, subst))
	  | substDec (RecDec (coord, decs), subst) =
	    RecDec (coord, List.map (fn dec => substDec (dec, subst)) decs)
	and substExp (exp as LitExp (_, _), _) = exp
	  | substExp (exp as PrimExp (_, _), _) = exp
	  | substExp (exp as NewExp (_, _, _), _) = exp
	  | substExp (VarExp (coord, longid), subst) =
	    VarExp (coord, substLongId (longid, subst))
	  | substExp (exp as ConExp (_, _, _), _) = exp
	  | substExp (exp as RefExp _, _) = exp
	  | substExp (TupExp (coord, exps), subst) =
	    TupExp (coord, List.map (fn exp => substExp (exp, subst)) exps)
	  | substExp (RowExp (coord, expFields), subst) =
	    RowExp (coord,
		    List.map (fn Field (coord, lab, exp) =>
			      Field (coord, lab, substExp (exp, subst)))
		    expFields)
	  | substExp (exp as SelExp (_, _), _) = exp
	  | substExp (VecExp (coord, exps), subst) =
	    VecExp (coord, List.map (fn exp => substExp (exp, subst)) exps)
	  | substExp (FunExp (coord, id, exp), subst) =
	    FunExp (coord, id, substExp (exp, subst))
	  | substExp (AppExp (coord, exp1, exp2), subst) =
	    AppExp (coord, substExp (exp1, subst), substExp (exp2, subst))
	  | substExp (AdjExp (coord, exp1, exp2), subst) =
	    AdjExp (coord, substExp (exp1, subst), substExp (exp2, subst))
	  | substExp (AndExp (coord, exp1, exp2), subst) =
	    AndExp (coord, substExp (exp1, subst), substExp (exp2, subst))
	  | substExp (OrExp (coord, exp1, exp2), subst) =
	    OrExp (coord, substExp (exp1, subst), substExp (exp2, subst))
	  | substExp (IfExp (coord, exp1, exp2, exp3), subst) =
	    IfExp (coord, substExp (exp1, subst),
		   substExp (exp2, subst), substExp (exp3, subst))
	  | substExp (WhileExp (coord, exp1, exp2), subst) =
	    WhileExp (coord, substExp (exp1, subst), substExp (exp2, subst))
	  | substExp (SeqExp (coord, exps), subst) =
	    SeqExp (coord, List.map (fn exp => substExp (exp, subst)) exps)
	  | substExp (CaseExp (coord, exp, matches), subst) =
	    CaseExp (coord, substExp (exp, subst),
		     substMatches (matches, subst))
	  | substExp (RaiseExp (coord, exp), subst) =
	    RaiseExp (coord, substExp (exp, subst))
	  | substExp (HandleExp (coord, exp, matches), subst) =
	    HandleExp (coord, substExp (exp, subst),
		       substMatches (matches, subst))
	  | substExp (LetExp (coord, decs, exp), subst) =
	    LetExp (coord, substDecs (decs, subst), substExp (exp, subst))
	and substMatches (matches, subst) =
	    List.map (fn Match (coord, pat, exp) =>
		      Match (coord, substPat (pat, subst),
			     substExp (exp, subst))) matches
	and substPat (pat as WildPat _, _) = pat
	  | substPat (pat as LitPat (_, _), _) = pat
	  | substPat (pat as VarPat (_, _), _) = pat
	  | substPat (ConPat (coord, longid, NONE), subst) =
	    ConPat (coord, substLongId (longid, subst), NONE)
	  | substPat (ConPat (coord, longid, SOME pat), subst) =
	    ConPat (coord, substLongId (longid, subst),
		    SOME (substPat (pat, subst)))
	  | substPat (RefPat (coord, pat), subst) =
	    RefPat (coord, substPat (pat, subst))
	  | substPat (TupPat (coord, pats), subst) =
	    TupPat (coord, List.map (fn pat => substPat (pat, subst)) pats)
	  | substPat (RowPat (coord, patFields, hasDots), subst) =
	    RowPat (coord,
		    List.map (fn Field (coord, lab, pat) =>
			      Field (coord, lab, substPat (pat, subst)))
		    patFields, hasDots)
	  | substPat (VecPat (coord, pats), subst) =
	    VecPat (coord, List.map (fn pat => substPat (pat, subst)) pats)
	  | substPat (AsPat (coord, pat1, pat2), subst) =
	    AsPat (coord, substPat (pat1, subst), substPat (pat2, subst))
	  | substPat (AltPat (coord, pats), subst) =
	    AltPat (coord, List.map (fn pat => substPat (pat, subst)) pats)
	  | substPat (NegPat (coord, pat), subst) =
	    NegPat (coord, substPat (pat, subst))
	  | substPat (GuardPat (coord, pat, exp), subst) =
	    GuardPat (coord, substPat (pat, subst), substExp (exp, subst))
	  | substPat (WithPat (coord, pat, decs), subst) =
	    WithPat (coord, substPat (pat, subst), substDecs (decs, subst))

	(* If the same test occurs in two patterns at the same position,
	 * then these may be merged by the pattern matching compiler.
	 * In this process, a global substitution is built such that the
	 * identifiers bound at each pattern position are all mapped to
	 * common identifiers.
	 * In the presence of disjunctive patterns, such a substitution can
	 * in general only be made consistent with all pattern bindings by
	 * first uniquely renaming, then binding all the original identifiers
	 * by `with' declarations.  `with' declarations are not affected by
	 * the substitution because they are never merged.
	 *
	 * `separateAlt' moves all bindings to `with' declarations.  These
	 * are placed right at the end of each alternative pattern to allow
	 * for a maximum of merging possibilities.
	 * In principle, it is sufficient to do so only within disjunctive
	 * patterns.  If we apply this on the toplevel as well however,
	 * we need not substitute into the right hand side of a match.
	 *)

	fun separateAlt pat =
	    let
		val (pat', subst) = relax (pat, nil)
		val decs =
		    List.map
		    (fn (id, id') =>
		     let
			 val coord = infoId id
			 val exp = VarExp (coord, ShortId (coord, id'))
		     in
			 ValDec (coord, VarPat (coord, id), exp)
		     end) subst
	    in
		case decs of
		    nil => pat'
		  | _::_ => WithPat (infoPat pat', pat', decs)
	    end
	and relax (pat as WildPat _, subst) = (pat, subst)
	  | relax (pat as LitPat (_, _), subst) = (pat, subst)
	  | relax (VarPat (coord, id), subst) =
	    let
		val id' = freshId coord
	    in
		(VarPat (coord, id'), (id, id')::subst)
	    end
	  | relax (pat as ConPat (_, _, NONE), subst) = (pat, subst)
	  | relax (ConPat (coord, longid, SOME pat), subst) =
	    let
		val (pat', subst') = relax (pat, subst)
	    in
		(ConPat (coord, longid, SOME pat'), subst')
	    end
	  | relax (RefPat (coord, pat), subst) =
	    let
		val (pat', subst') = relax (pat, subst)
	    in
		(RefPat (coord, pat'), subst')
	    end
	  | relax (TupPat (coord, pats), subst) =
	    let
		val (pats', subst') =
		    List.foldr (fn (pat, (pats, subst)) =>
				let
				    val (pat', subst') = relax (pat, subst)
				in
				    (pat'::pats, subst')
				end) (nil, subst) pats
	    in
		(TupPat (coord, pats'), subst')
	    end
	  | relax (RowPat (coord, patFields, hasDots), subst) =
	    let
		val (patFields', subst') =
		    List.foldr
		    (fn (Field (coord, lab, pat), (patFields, subst)) =>
		     let
			 val (pat', subst') = relax (pat, subst)
		     in
			 (Field (coord, lab, pat')::patFields, subst')
		     end) (nil, subst) patFields
	    in
		(RowPat (coord, patFields', hasDots), subst')
	    end
	  | relax (VecPat (coord, pats), subst) =
	    let
		val (pats', subst') =
		    List.foldr (fn (pat, (pats, subst)) =>
				let
				    val (pat', subst') = relax (pat, subst)
				in
				    (pat'::pats, subst')
				end) (nil, subst) pats
	    in
		(VecPat (coord, pats'), subst')
	    end
	  | relax (AsPat (coord, pat1, pat2), subst) =
	    let
		val (pat1', subst') = relax (pat1, subst)
		val (pat2', subst'') = relax (pat2, subst')
	    in
		(AsPat (coord, pat1', pat2'), subst'')
	    end
	  | relax (AltPat (coord, pats), subst) =
	    (AltPat (coord, List.map separateAlt pats), subst)
	  | relax (NegPat (coord, pat), subst) =
	    (NegPat (coord, separateAlt pat), subst)
	  | relax (GuardPat (coord, pat, exp), subst) =
	    let
		val (pat', subst') = relax (pat, subst)
	    in
		(GuardPat (coord, pat', substExp (exp, subst')), subst')
	    end
	  | relax (WithPat (coord, pat, decs), subst) =
	    let
		val (pat', subst') = relax (pat, subst)
	    in
		(WithPat (coord, pat', substDecs (decs, subst')), subst')
	    end
    end
(* src # 117 *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature LABEL_SORT =
    sig
	type 'a t

	datatype arity =
	    Rec
	  | Tup of int

	val sort: 'a t list -> 'a t list * arity
    end
(* src # 118 *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

functor MakeLabelSort(type 'a t val get: 'a t -> string) :> LABEL_SORT
    where type 'a t = 'a t =
    struct
	type 'a t = 'a t

	datatype arity =
	    Rec
	  | Tup of int

	fun split nil = (nil, nil)
	  | split (xs as [_]) = (xs, nil)
	  | split (x1::x2::xr) =
	    let
		val (xr1, xr2) = split xr
	    in
		(x1::xr1, x2::xr2)
	    end

	fun labelLess (x1, x2) =
	    let
		val s1 = get x1
		val s2 = get x2
	    in
		case Int.fromString s1 of
		    SOME i1 =>
			(case Int.fromString s2 of
			     SOME i2 => i1 < i2
			   | NONE => true)
		  | NONE => String.< (s1, s2)
	    end

	fun merge (xs as x::xr, ys as y::yr) =
	    if labelLess (x, y) then x::merge (xr, ys)
	    else y::merge (xs, yr)
	  | merge (nil, ys) = ys
	  | merge (xs, nil) = xs

	fun sort' nil = nil
	  | sort' (xs as [_]) = xs
	  | sort' xs =
	    let
		val (ys, zs) = split xs
	    in
		merge (sort' ys, sort' zs)
	    end

	fun isTuple (x::xr, i) =
	    if get x = Int.toString i then isTuple (xr, i + 1)
	    else NONE
	  | isTuple (nil, i) = SOME (i - 1)

	fun sort xs =
	    let
		val xs' = sort' xs
	    in
		case isTuple (xs', 1) of
		    SOME i => (xs', Tup i)
		  | NONE => (xs', Rec)
	    end
    end
(* src # 119 *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature SIMPLIFY_MATCH =
    sig
	structure I: INTERMEDIATE_GRAMMAR = IntermediateGrammar
	structure O: IMPERATIVE_GRAMMAR = ImperativeGrammar

	datatype test =
	    LitTest of I.lit
	  | ConTest of I.longid * bool   (* has args *)
	  | RefTest
	  | TupTest of int
	  | RecTest of string list
	    (* sorted, all labels distinct, no tuple *)
	  | LabTest of string
	  | VecTest of int
	  | GuardTest of mapping * I.exp
	  | DecTest of mapping * I.info * I.dec list
	withtype mapping = (string list * I.id) list

	type pos = string list

	datatype testGraph =
	    Node of pos * test * testGraph ref * testGraph ref * nodeStatus ref
	  | Leaf of O.body * O.body option ref
	  | Default
	and nodeStatus =
	    Initial
	  | Raw of testGraph list * testGraph list
	  | Cooked of (pos * test) list * (pos * test) list
	  | Optimized of (pos * test) list * (pos * test) list
	  | Translated of O.body

	type consequent = (O.coord * O.body option ref)

	val buildGraph: (I.info * I.pat * O.body) list * O.body ->
	    testGraph * consequent list

	type bodyFun = unit -> O.body

	val buildFunArgs: I.id * (I.info * I.pat * O.body) list * bodyFun ->
	    (O.id O.args * testGraph * mapping * consequent list) list
    end
(* src # 120 *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure SimplifyMatch :> SIMPLIFY_MATCH =
    struct
	structure I = IntermediateGrammar
	structure O = ImperativeGrammar

	open I
	open IntermediateAux

	(* Tests *)

	datatype test =
	    LitTest of lit
	  | ConTest of longid * bool   (* has args *)
	  | RefTest
	  | TupTest of int
	  | RecTest of string list
	    (* sorted, all labels distinct, no tuple *)
	  | LabTest of string
	  | VecTest of int
	  | GuardTest of mapping * exp
	  | DecTest of mapping * O.coord * dec list
	withtype mapping = (string list * id) list

	(* Test Sequences *)

	type pos = string list

	datatype testSeqElem =
	    Test of pos * test
	  | Neg of testSeq
	  | Alt of testSeq list
	withtype testSeq = testSeqElem list

	(* Test Sequence Construction *)

	structure StringLabelSort =
	    MakeLabelSort(type 'a t = string fun get x = x)

	fun makeTestSeq (WildPat _, _, rest, mapping) = (rest, mapping)
	  | makeTestSeq (LitPat (_, lit), pos, rest, mapping) =
	    (Test (pos, LitTest lit)::rest, mapping)
	  | makeTestSeq (VarPat (_, id), pos, rest, mapping) =
	    (rest, (pos, id)::mapping)
	  | makeTestSeq (ConPat (_, longid, patOpt), pos, rest, mapping) =
	    (case patOpt of
		 SOME pat =>
		     makeTestSeq (pat, ""::pos,
				  Test (pos, ConTest (longid, true))::rest,
				  mapping)
	       | NONE => (Test (pos, ConTest (longid, false))::rest, mapping))
	  | makeTestSeq (RefPat (_, pat), pos, rest, mapping) =
	    makeTestSeq (pat, ""::pos, Test (pos, RefTest)::rest, mapping)
	  | makeTestSeq (TupPat (_, pats), pos, rest, mapping) =
	    foldli (fn (i, pat, (rest, mapping)) =>
		    makeTestSeq (pat, Int.toString i::pos, rest, mapping))
	    (Test (pos, TupTest (List.length pats))::rest, mapping)
	    pats
	  | makeTestSeq (RowPat (_, patFields, true), pos, rest, mapping) =
	    List.foldl (fn (Field (_, Lab (_, s), pat), (rest, mapping)) =>
			makeTestSeq (pat, s::pos, rest, mapping))
	    (List.foldl (fn (Field (_, Lab (_, s), _), rest) =>
			 Test (pos, LabTest s)::rest) rest patFields,
	     mapping) patFields
	  | makeTestSeq (RowPat (_, patFields, false), pos, rest, mapping) =
	    let
		val labs =
		    List.map (fn Field (_, Lab (_, s), _) => s) patFields
		val test =
		    case StringLabelSort.sort labs of
			(_, StringLabelSort.Tup i) => TupTest i
		      | (labs', StringLabelSort.Rec) => RecTest labs'
	    in
		List.foldl (fn (Field (_, Lab (_, s), pat), (rest, mapping)) =>
			    makeTestSeq (pat, s::pos, rest, mapping))
		(Test (pos, test)::rest, mapping) patFields
	    end
	  | makeTestSeq (VecPat (_, pats), pos, rest, mapping) =
	    foldli (fn (i, pat, (rest, mapping)) =>
		    makeTestSeq (pat, Int.toString i::pos, rest, mapping))
	    (Test (pos, VecTest (List.length pats))::rest, mapping)
	    pats
	  | makeTestSeq (AsPat (_, pat1, pat2), pos, rest, mapping) =
	    let
		val (rest', mapping') = makeTestSeq (pat1, pos, rest, mapping)
	    in
		makeTestSeq (pat2, pos, rest', mapping')
	    end
	  | makeTestSeq (AltPat (_, pats), pos, rest, mapping) =
	    (Alt (List.map (fn pat =>
			    let
				val (rest', _) =
				    makeTestSeq (pat, pos, nil, mapping)
			    in
				List.rev rest'
			    end) pats)::rest, mapping)
	  | makeTestSeq (NegPat (_, pat), pos, rest, mapping) =
	    let
		val (rest', _) = makeTestSeq (pat, pos, nil, mapping)
	    in
		(Neg (List.rev rest')::rest, mapping)
	    end
	  | makeTestSeq (GuardPat (_, pat, exp), pos, rest, mapping) =
	    let
		val (rest', mapping') = makeTestSeq (pat, pos, rest, mapping)
	    in
		(Test (pos, GuardTest (mapping', exp))::rest', mapping')
	    end
	  | makeTestSeq (WithPat (coord, pat, decs), pos, rest, mapping) =
	    let
		val (rest', mapping') = makeTestSeq (pat, pos, rest, mapping)
	    in
		(Test (pos, DecTest (mapping', coord, decs))::rest', mapping')
	    end

	(* Test Graphs *)

	datatype testGraph =
	    Node of pos * test * testGraph ref * testGraph ref * nodeStatus ref
	  | Leaf of O.body * O.body option ref
	  | Default
	and nodeStatus =
	    Initial
	  | Raw of testGraph list * testGraph list
	  | Cooked of (pos * test) list * (pos * test) list
	  | Optimized of (pos * test) list * (pos * test) list
	  | Translated of O.body

	(* Construction of Test Trees Needing Backtracking *)

	fun labEq (Lab (_, s1), Lab (_, s2)) = s1 = s2

	fun longidEq (ShortId (_, id1), ShortId (_, id2)) = idEq (id1, id2)
	  | longidEq (LongId (_, longid1, lab1), LongId (_, longid2, lab2)) =
	    longidEq (longid1, longid2) andalso labEq (lab1, lab2)
	  | longidEq (_, _) = false

	fun testEq (LitTest lit1, LitTest lit2) = lit1 = lit2
	  | testEq (ConTest (longid1, hasArgs1), ConTest (longid2, hasArgs2)) =
	    (* approximation: consider constructors equal if same long id *)
	    longidEq (longid1, longid2) andalso hasArgs1 = hasArgs2
	  | testEq (TupTest n1, TupTest n2) = n1 = n2
	  | testEq (RecTest labs1, RecTest labs2) = labs1 = labs2
	  | testEq (VecTest n1, VecTest n2) = n1 = n2
	  | testEq (_, _) = false

	fun areParallelTests (LitTest lit1, LitTest lit2) = lit1 <> lit2
	  | areParallelTests (LitTest _, TupTest _) = true
	  | areParallelTests (TupTest _, LitTest _) = true
	  | areParallelTests (LitTest _, RecTest _) = true
	  | areParallelTests (RecTest _, LitTest _) = true
	  | areParallelTests (LitTest _, VecTest _) = true
	  | areParallelTests (VecTest _, LitTest _) = true
	  | areParallelTests (TupTest n1, TupTest n2) = n1 <> n2
	  | areParallelTests (TupTest _, RecTest _) = true
	  | areParallelTests (RecTest _, TupTest _) = true
	  | areParallelTests (VecTest _, TupTest _) = true
	  | areParallelTests (TupTest _, VecTest _) = true
	  | areParallelTests (VecTest _, RecTest _) = true
	  | areParallelTests (RecTest _, VecTest _) = true
	  | areParallelTests (RecTest labs1, RecTest labs2) = labs1 <> labs2
	  | areParallelTests (VecTest n1, VecTest n2) = n1 <> n2
	  | areParallelTests (_, _) = false

	local
	    fun findTest (Node (pos', test', thenTreeRef, elseTreeRef, _),
			  pos, test) =
		if pos = pos' then
		    if testEq (test, test') then SOME thenTreeRef
		    else if areParallelTests (test, test') then
			findTest (!elseTreeRef, pos, test)
		    else NONE
		else NONE
	      | findTest (_, _, _) = NONE
	in
	    fun mergeIntoTree (nil, thenTree, _) = thenTree
	      | mergeIntoTree (Test (pos, test)::testSeqRest,
			       thenTree, elseTree) =
		(case findTest (elseTree, pos, test) of
		     SOME treeRef =>
			 let
			     val newTree = mergeIntoTree (testSeqRest,
							  thenTree, !treeRef)
			 in
			     treeRef := newTree; elseTree
			 end
		   | NONE =>
			 let
			     val newThenTree =
				 mergeIntoTree (testSeqRest, thenTree, Default)
			 in
			     Node (pos, test, ref newThenTree, ref elseTree,
				   ref Initial)
			 end)
	      | mergeIntoTree (Neg testSeq::testSeqRest, thenTree, elseTree) =
		mergeIntoTree (testSeq, elseTree,
			       mergeIntoTree (testSeqRest, thenTree, elseTree))
	      | mergeIntoTree (Alt testSeqs::testSeqRest, thenTree, elseTree) =
		let
		    val newThenTree =
			mergeIntoTree (testSeqRest, thenTree, Default)
		in
		    List.foldr (fn (testSeq, elseTree) =>
				mergeIntoTree (testSeq, newThenTree, elseTree))
		    elseTree testSeqs
		end
	end

	(* Elimination of Backtracking, Producing a Test Graph *)

	fun propagateElses (Node (_, _, thenTreeRef, elseTreeRef, _),
			    defaultTree) =
	    (case !elseTreeRef of
		 Default => elseTreeRef := defaultTree
	       | elseTree => propagateElses (elseTree, defaultTree);
	     case !thenTreeRef of
		 Default => thenTreeRef := defaultTree
	       | thenTree => propagateElses (thenTree, !elseTreeRef))
	  | propagateElses (Leaf (_, _), _) = ()
	  | propagateElses (Default, _) =
	    raise Crash.Crash "SimplifyMatch.propagateElses"

	(* Optimization of the Test Graph *)

	local
	    fun union (NONE, gs) = gs
	      | union (SOME g, gr) = g::gr

	    fun computeRaw (graph as Node (_, _, ref thenGraph, ref elseGraph,
					   status as ref Initial),
			    prevTrueOpt, prevFalseOpt) =
		(status := Raw (union (prevTrueOpt, nil),
				union (prevFalseOpt, nil));
		 computeRaw (thenGraph, SOME graph, NONE);
		 computeRaw (elseGraph, NONE, SOME graph))
	      | computeRaw (Node (_, _, _, _, status as
				  ref (Raw (trueGraphs, falseGraphs))),
			    prevTrueOpt, prevFalseOpt) =
		status := Raw (union (prevTrueOpt, trueGraphs),
			       union (prevFalseOpt, falseGraphs))
	      | computeRaw (_, _, _) = ()

	    fun testSetMember (pos, test, (pos', test')::testSetRest) =
		pos = pos' andalso testEq (test, test')
		orelse testSetMember (pos, test, testSetRest)
	      | testSetMember (_, _, nil) = false

	    fun testSetIntersect ((pos, test)::testSetRest, testSet') =
		if testSetMember (pos, test, testSet') then
		    (pos, test)::(testSetIntersect (testSetRest, testSet'))
		else testSetIntersect (testSetRest, testSet')
	      | testSetIntersect (nil, _) = nil

	    fun getSets (status as ref (Raw (trueGraphs, falseGraphs))) =
		let
		    val sets = (makePosTestList (trueGraphs, true),
				makePosTestList (falseGraphs, false))
		in
		    status := Cooked sets; sets
		end
	      | getSets (ref (Cooked sets)) = sets
	      | getSets (ref (Optimized sets)) = sets
	      | getSets (ref _) = raise Crash.Crash "SimplifyMatch.getSets"
	    and makePosTestList (graphs, isTrue) =
		List.foldr
		(fn (graph, posTestList) =>
		 case graph of
		     Node (pos, test, _, _, status) =>
			 let
			     val (trueSet, falseSet) = getSets status
			 in
			     if isTrue then
				 testSetIntersect
				 ((pos, test)::trueSet, falseSet)
			     else
				 testSetIntersect
				 (trueSet, (pos, test)::falseSet)
			 end
		   | _ => raise Crash.Crash "SimplifyMatch.cook")
		nil graphs

	    fun disentailed (pos, test, (pos', test')::rest) =
		pos = pos' andalso areParallelTests (test, test')
		orelse disentailed (pos, test, rest)
	      | disentailed (_, _, nil) = false

	    fun optimize (ref (Node (_, _, _, _, ref (Optimized (_, _))))) = ()
	      | optimize (graphRef as
			  ref (Node (pos, test, thenGraphRef, elseGraphRef,
				     status))) =
		let
		    val sets as (trueSet, falseSet) = getSets status
		in
		    if testSetMember (pos, test, trueSet) then
			(graphRef := !thenGraphRef; optimize graphRef)
		    else if testSetMember (pos, test, falseSet)
			orelse disentailed (pos, test, trueSet) then
			(graphRef := !elseGraphRef; optimize graphRef)
		    else
			(status := Optimized sets;
			 optimize thenGraphRef;
			 optimize elseGraphRef)
		end
	      | optimize (ref (Leaf (_, _))) = ()
	      | optimize (ref _) = raise Crash.Crash "SimplifyMatch.optimize"
	in
	    fun optimizeGraph graph =
		let
		    val _ = computeRaw (graph, NONE, NONE)
		    val graphRef = ref graph
		in
		    optimize graphRef; !graphRef
		end
	end

	type consequent = (O.coord * O.body option ref)

	fun buildGraph (matches, elseExp) =
	    let
		val (graph, consequents) =
		    List.foldr (fn ((coord, pat, thenExp),
				    (elseTree, consequents)) =>
				let
				    val pat' = separateAlt pat
				    val (testSeq, _) =
					makeTestSeq (pat', nil, nil, nil)
				    val r = ref NONE
				    val leaf = Leaf (thenExp, r)
				in
				    (mergeIntoTree (List.rev testSeq,
						    leaf, elseTree),
				     (coord, r)::consequents)
				end) (Default, nil) matches
		val elseGraph = Leaf (elseExp, ref NONE)
	    in
		case graph of
		    Default =>
			(elseGraph, consequents)
		  | _ =>
			(propagateElses (graph, elseGraph);
			 (optimizeGraph graph, consequents))
	    end

	type bodyFun = unit -> O.body

	local
	    datatype args =
		ONE
	      | TUP of int
	      | REC of string list

	    exception NonArgable

	    fun normalize (_, LitPat (_, _), _) = ONE
	      | normalize (_, ConPat (_, _, _), _) = ONE
	      | normalize (_, RefPat (_, _), _) = ONE
	      | normalize (_, TupPat (_, pats), _) = TUP (List.length pats)
	      | normalize (_, RowPat (_, patFields, false), _) =
		let
		    val labs =
			List.map (fn Field (_, Lab (_, s), _) => s) patFields
		in
		    case StringLabelSort.sort labs of
			(_, StringLabelSort.Tup i) => TUP i
		      | (labs', StringLabelSort.Rec) => REC labs'
		end
	      | normalize (_, VecPat (_, _), _) = ONE
	      | normalize (_, _, _) = raise NonArgable

	    fun insertMatch ((ONE, matches)::rest, ONE, match) =
		(ONE, match::matches)::rest
	      | insertMatch (argsMatchesList, ONE, match) =
		(ONE, [match])::argsMatchesList
	      | insertMatch ((args, matches)::rest, args', match) =
		if args = args' then (args, match::matches)::rest
		else (args, matches)::insertMatch (rest, args', match)
	      | insertMatch (nil, args', match) = [(args', [match])]

	    fun makeArg (match, argsMatchesList) =
		insertMatch (argsMatchesList, normalize match, match)

	    fun freshId coord = Id (coord, Stamp.new (), InId)

	    fun process (ONE, graph, consequents, id) =
		(O.OneArg id, graph, [(nil, id)], consequents)
	      | process (TUP i, Node (nil, TupTest i', ref graph, _, _),
			 consequents, _) =
		let
		    val intIdList =
			List.tabulate
			(i, fn i => (i + 1, freshId Source.nowhere))
		    val ids = List.map #2 intIdList
		    val mapping =
			List.foldr (fn ((i, id), mapping) =>
				    ([Int.toString i], id)::mapping)
			nil intIdList
		in
		    if i = i' then ()
		    else raise Crash.Crash "SimplifyMatch.process 1";
		    (O.TupArgs ids, graph, mapping, consequents)
		end
	      | process (REC labs, Node (nil, RecTest labs', ref graph, _, _),
			 consequents, _) =
		let
		    val labIdList =
			List.map (fn lab => (lab, freshId Source.nowhere)) labs
		    val mapping =
			List.foldr (fn ((lab, id), mapping) =>
				    ([lab], id)::mapping) nil labIdList
		in
		    if labs = labs' then ()
		    else raise Crash.Crash "SimplifyMatch.process 2";
		    (O.RecArgs labIdList, graph, mapping, consequents)
		end
	      | process (_, _, _, _) =
		raise Crash.Crash "SimplifyMatch.process 3"
	in
	    fun buildFunArgs (id, matches, errStmsFun) =
		let
		    val argsMatchesList =
			(List.map (fn (args, matches) =>
				   (args, List.rev matches))
			 (List.foldl makeArg nil matches))
			handle NonArgable => [(ONE, matches)]
		in
		    List.map (fn (args, matches) =>
			      let
				  val (graph, consequents) =
				      buildGraph (matches, errStmsFun ())
			      in
				  process (args, graph, consequents, id)
			      end) argsMatchesList
		end
	end
    end
(* src # 121 *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature SIMPLIFY_REC =
    sig
	structure I: INTERMEDIATE_GRAMMAR = IntermediateGrammar

	type constraint = I.longid * I.longid * bool   (* has args *)
	type binding = I.id * I.exp
	type alias = I.id * I.id

	val derec: I.dec list -> constraint list * binding list * alias list
    end
(* src # 122 *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure SimplifyRec :> SIMPLIFY_REC =
    struct
	structure I = IntermediateGrammar

	open I

	type constraint = longid * longid * bool   (* has args *)
	type binding = id * exp
	type alias = id * id

	datatype pat =
	    WildPat of info
	  | LitPat of info * lit
	  | VarPat of info * id
	  | ConPat of info * longid * pat option
	  | RefPat of info * pat
	  | TupPat of info * pat list
	  | RowPat of info * pat field list * bool
	  | VecPat of info * pat list
	  | AsPat of info * id * pat

	fun infoPat (WildPat coord) = coord
	  | infoPat (LitPat (coord, _)) = coord
	  | infoPat (VarPat (coord, _)) = coord
	  | infoPat (ConPat (coord, _, _)) = coord
	  | infoPat (RefPat (coord, _)) = coord
	  | infoPat (TupPat (coord, _)) = coord
	  | infoPat (RowPat (coord, _, _)) = coord
	  | infoPat (VecPat (coord, _)) = coord
	  | infoPat (AsPat (coord, _, _)) = coord

	structure FieldSort =
	    MakeLabelSort(type 'a t = 'a field
			  fun get (Field (_, Lab (_, s), _)) = s)

	fun select (Field (_, Lab (_, s), x)::fieldr, s') =
	    if s = s' then SOME x else select (fieldr, s')
	  | select (nil, _) = NONE

	fun isSubarity (xs as Field (_, Lab (_, s), _)::xr,
			Field (_, Lab (_, s'), _)::yr) =
	    if s = s' then isSubarity (xr, yr)
	    else isSubarity (xs, yr)
	  | isSubarity (nil, _) = true
	  | isSubarity (_, nil) = false

	fun unalias (WildPat _) = (nil, NONE)
	  | unalias (VarPat (_, id)) = ([id], NONE)
	  | unalias (AsPat (_, id, pat)) =
	    let
		val (ids, patOpt) = unalias pat
	    in
		(id::ids, patOpt)
	    end
	  | unalias pat = (nil, SOME pat)

	fun patToExp (WildPat coord) =
	    let
		val id = IntermediateAux.freshId coord
	    in
		(VarPat (coord, id), VarExp (coord, ShortId (coord, id)))
	    end
	  | patToExp (pat as LitPat (coord, lit)) = (pat, LitExp (coord, lit))
	  | patToExp (pat as VarPat (coord, id)) =
	    (pat, VarExp (coord, ShortId (coord, id)))
	  | patToExp (pat as ConPat (coord, longid, NONE)) =
	    (pat, ConExp (coord, longid, false))
	  | patToExp (ConPat (coord, longid, SOME pat)) =
	    let
		val (pat', exp') = patToExp pat
	    in
		(ConPat (coord, longid, SOME pat'),
		 AppExp (coord, ConExp (coord, longid, true), exp'))
	    end
	  | patToExp (RefPat (coord, pat)) =
	    let
		val (pat', exp') = patToExp pat
	    in
		(RefPat (coord, pat'), AppExp (coord, RefExp coord, exp'))
	    end
	  | patToExp (TupPat (coord, pats)) =
	    let
		val (pats', exps') = ListPair.unzip (List.map patToExp pats)
	    in
		(TupPat (coord, pats'), TupExp (coord, exps'))
	    end
	  | patToExp (RowPat (coord, patFields, hasDots)) =
	    (*--** record patterns with dots must be resolved using the rhs *)
	    raise Crash.Crash "SimplifyRec.patToExp"
	  | patToExp (VecPat (coord, pats)) =
	    let
		val (pats', exps') = ListPair.unzip (List.map patToExp pats)
	    in
		(VecPat (coord, pats'), VecExp (coord, exps'))
	    end
	  | patToExp (pat as AsPat (coord, id, _)) =
	    (pat, VarExp (coord, ShortId (coord, id)))

	fun derec' (WildPat _, exp) = (nil, [(nil, exp)])
	  | derec' (LitPat (coord, lit1), LitExp (_, lit2)) =
	    if lit1 = lit2 then (nil, nil)
	    else Error.error (coord, "pattern never matches")
	  | derec' (VarPat (_, id), exp) = (nil, [([id], exp)])
	  | derec' (ConPat (coord, longid1, NONE),
		    ConExp (_, longid2, false)) =
	    ([(longid1, longid2, false)], nil)
	  | derec' (ConPat (coord, longid1, SOME pat),
		   AppExp (_, ConExp (_, longid2, true), exp)) =
	    let
		val (constraints, idsExpList) = derec' (pat, exp)
	    in
		((longid1, longid2, true)::constraints, idsExpList)
	    end
	  | derec' (RefPat (_, pat), AppExp (_, RefExp _, exp)) =
	    derec' (pat, exp)
	  | derec' (TupPat (coord, pats), TupExp (_, exps)) =
	    if length pats = length exps then
		ListPair.foldr (fn (pat, exp, (cr, idsExpr)) =>
				let
				    val (cs, idsExps) = derec' (pat, exp)
				in
				    (cs @ cr, idsExps @ idsExpr)
				end) (nil, nil) (pats, exps)
	    else Error.error (coord, "pattern never matches")
	  | derec' (TupPat (coord, pats), RowExp (_, expFields)) =
	    (case FieldSort.sort expFields of
		 (expFields', FieldSort.Tup n) =>
		     if length pats = n then
			 ListPair.foldr
			 (fn (pat, Field (_, _, exp), (cr, idsExpr)) =>
			  let
			      val (cs, idsExps) = derec' (pat, exp)
			  in
			      (cs @ cr, idsExps @ idsExpr)
			  end) (nil, nil) (pats, expFields')
		     else Error.error (coord, "pattern never matches")
	       | (_, FieldSort.Rec) =>
		     Error.error (coord, "pattern never matches"))
	  | derec' (RowPat (coord, _, false), TupExp (_, _)) =
	    Error.error (coord, "pattern never matches")
	  | derec' (RowPat (coord, patFields, true), TupExp (_, exps)) =
	    let
		val n = length exps
	    in
		if List.all (fn Field (_, Lab (_, s), _) =>
			     case Int.fromString s of
				 SOME i => i >= 1 andalso i <= n
			       | NONE => false) patFields
		then
		    raise Crash.Crash   (*--** *)
		    "SimplifyRec.derec': not implemented 1"
		else Error.error (coord, "pattern never matches")
	    end
	  | derec' (RowPat (coord, patFields, false), RowExp (_, expFields)) =
	    let
		val (expFields', _) = FieldSort.sort expFields
	    in
		if length patFields = length expFields' then
		    ListPair.foldr
		    (fn (Field (_, Lab (_, s), pat),
			 Field (_, Lab (_, s'), exp), (cr, idsExpr)) =>
		     if s = s' then
			 let
			     val (cs, idsExps) = derec' (pat, exp)
			 in
			     (cs @ cr, idsExpr @ idsExpr)
			 end
		     else Error.error (coord, "pattern never matches"))
		    (nil, nil) (patFields, expFields')
		else Error.error (coord, "pattern never matches")
	    end
	  | derec' (RowPat (coord, patFields, true), RowExp (_, expFields)) =
	    let
		val (expFields', _) = FieldSort.sort expFields
	    in
		if isSubarity (patFields, expFields') then
		    raise Crash.Crash   (*--** *)
		    "SimplifyRec.derec': not implemented 2"
		else Error.error (coord, "pattern never matches")
	    end
	  | derec' (VecPat (coord, pats), VecExp (_, exps)) =
	    if length pats = length exps then
		ListPair.foldr (fn (pat, exp, (cr, idsExpr)) =>
				let
				    val (cs, idsExps) = derec' (pat, exp)
				in
				    (cs @ cr, idsExps @ idsExpr)
				end) (nil, nil) (pats, exps)
	    else Error.error (coord, "pattern never matches")
	  | derec' (pat as AsPat (_, _, _), exp) =
	    let
		val (ids, patOpt) = unalias pat
	    in
		case patOpt of
		    NONE =>
			(nil, [(ids, exp)])
		  | SOME pat' =>
			let
			    val (pat'', exp') = patToExp pat'
			    val (constraints, idsExpList) = derec' (pat'', exp)
			in
			    (constraints, (ids, exp')::idsExpList)
			end
	    end
	  | derec' (pat, _) =
	    Error.error (infoPat pat, "pattern never matches")

	fun unify (WildPat _, pat2) = (nil, pat2)
	  | unify (pat1, WildPat _) = (nil, pat1)
	  | unify (pat1 as LitPat (coord, lit1), LitPat (_, lit2)) =
	    if lit1 = lit2 then (nil, pat1)   (*--** what about widths? *)
	    else Error.error (coord, "pattern never matches")
	  | unify (VarPat (coord, id), pat2) = (nil, AsPat (coord, id, pat2))
	  | unify (pat1, VarPat (coord, id)) = (nil, AsPat (coord, id, pat1))
	  | unify (pat1 as ConPat (coord, longid, NONE),
		   ConPat (_, longid', NONE)) =
	    ([(longid, longid', false)], pat1)
	  | unify (ConPat (coord, longid, SOME pat1),
		   ConPat (_, longid', SOME pat2)) =
	    let
		val (constraints, pat) = unify (pat1, pat2)
	    in
		((longid, longid', true)::constraints,
		 ConPat (coord, longid, SOME pat))
	    end
	  | unify (RefPat (coord, pat1), RefPat (_, pat2)) =
	    let
		val (constraints, pat) = unify (pat1, pat2)
	    in
		(constraints, RefPat (coord, pat))
	    end
	  | unify (TupPat (coord, pats1), TupPat (_, pats2)) =
	    if length pats1 = length pats2 then
		let
		    val (constraints, pats) =
			ListPair.foldr (fn (pat1, pat2, (cr, patr)) =>
					let
					    val (cs, pat) = unify (pat1, pat2)
					in
					    (cs @ cr, pat::patr)
					end) (nil, nil) (pats1, pats2)
		in
		    (constraints, TupPat (coord, pats))
		end
	    else Error.error (coord, "pattern never matches")
	  | unify (TupPat (_, _), RowPat (_, _, true)) =
	    raise Crash.Crash "SimplifyRec.unify: not implemented 1"   (*--** *)
	  | unify (pat1 as RowPat (_, _, _), pat2 as TupPat (_, _)) =
	    unify (pat2, pat1)
	  | unify (RowPat (_, _, _), RowPat (_, _, _)) =
	    raise Crash.Crash "SimplifyRec.unify: not implemented 2"   (*--** *)
	  | unify (VecPat (coord, pats1), VecPat (_, pats2)) =
	    if length pats1 = length pats2 then
		let
		    val (constraints, pats) =
			ListPair.foldr (fn (pat1, pat2, (cr, patr)) =>
					let
					    val (cs, pat) = unify (pat1, pat2)
					in
					    (cs @ cr, pat::patr)
					end) (nil, nil) (pats1, pats2)
		in
		    (constraints, VecPat (coord, pats))
		end
	    else Error.error (coord, "pattern never matches")
	  | unify (AsPat (coord, id, pat1), pat2) =
	    let
		val (constraints, pat) = unify (pat1, pat2)
	    in
		(constraints, AsPat (coord, id, pat))
	    end
	  | unify (pat1, pat2 as AsPat (_, _, _)) = unify (pat2, pat1)
	  | unify (pat, _) =
	    Error.error (infoPat pat, "pattern never matches")

	fun preprocess (I.WildPat coord) = (nil, WildPat coord)
	  | preprocess (I.LitPat (coord, lit)) = (nil, LitPat (coord, lit))
	  | preprocess (I.VarPat (coord, id)) = (nil, VarPat (coord, id))
	  | preprocess (I.ConPat (coord, longid, NONE)) =
	    (nil, ConPat (coord, longid, NONE))
	  | preprocess (I.ConPat (coord, longid, SOME pat)) =
	    let
		val (constraints, pat') = preprocess pat
	    in
		(constraints, ConPat (coord, longid, SOME pat'))
	    end
	  | preprocess (I.RefPat (coord, pat)) =
	    let
		val (constraints, pat') = preprocess pat
	    in
		(constraints, RefPat (coord, pat'))
	    end
	  | preprocess (I.TupPat (coord, pats)) =
	    let
		val (constraints, pats) =
		    List.foldr (fn (pat, (cr, patr)) =>
				let
				    val (cs, pat) = preprocess pat
				in
				    (cs @ cr, pat::patr)
				end) (nil, nil) pats
	    in
		(constraints, TupPat (coord, pats))
	    end
	  | preprocess (I.RowPat (coord, patFields, hasDots)) =
	    let
		val (patFields', arity) = FieldSort.sort patFields
		val (constraints, patFields'') =
		    List.foldr (fn (Field (coord, lab, pat), (cr, fieldr)) =>
				let
				    val (cs, pat') = preprocess pat
				in
				    (cs @ cr, Field (coord, lab, pat')::fieldr)
				end) (nil, nil) patFields'
		val pat' =
		    case arity of
			FieldSort.Tup i =>
			    if hasDots then
				RowPat (coord, patFields'', true)
			    else
				TupPat (coord,
					List.map (fn Field (_, _, pat) => pat)
					patFields'')
		      | FieldSort.Rec =>
			    RowPat (coord, patFields'', hasDots)
	    in
		(constraints, pat')
	    end
	  | preprocess (I.VecPat (coord, pats)) =
	    let
		val (constraints, pats) =
		    List.foldr (fn (pat, (cr, patr)) =>
				let
				    val (cs, pat) = preprocess pat
				in
				    (cs @ cr, pat::patr)
				end) (nil, nil) pats
	    in
		(constraints, VecPat (coord, pats))
	    end
	  | preprocess (I.AsPat (coord, pat1, pat2)) =
	    let
		val (constraints1, pat1') = preprocess pat1
		val (constraints2, pat2') = preprocess pat2
		val (constraints3, pat') = unify (pat1', pat2')
	    in
		(constraints1 @ constraints2 @ constraints3, pat')
	    end
	  | preprocess (I.AltPat (coord, _)) =
	    Error.error (coord, "alternative pattern not allowed in val rec")
	  | preprocess (I.NegPat (coord, _)) =
	    Error.error (coord, "negated pattern not allowed in val rec")
	  | preprocess (I.GuardPat (coord, _, _)) =
	    Error.error (coord, "guard pattern not allowed in val rec")
	  | preprocess (I.WithPat (coord, _, _)) =
	    Error.error (coord, "with pattern not allowed in val rec")

	fun derec (ValDec (_, pat, exp)::decr) =
	    let
		val (constraints, pat') = preprocess pat
		val (constraints', idsExpList) = derec' (pat', exp)
		val (idExpList, aliases) =
		    List.foldr (fn ((ids, exp), (rest, subst)) =>
				let
				    val toId = List.hd ids
				in
				    ((toId, exp)::rest,
				     List.foldr
				     (fn (fromId, subst) =>
				      (fromId, toId)::subst)
				     subst (List.tl ids))
				end) (nil, nil) idsExpList
		val (constraints'', idExpList', aliases') = derec decr
	    in
		(constraints @ constraints' @ constraints'',
		 idExpList @ idExpList', aliases @ aliases')
	    end
	  | derec (RecDec (_, decs)::decr) =
	    let
		val (constraints, idExpList, aliases) = derec decs
		val (constraints', idExpList', aliases') = derec decr
	    in
		(constraints @ constraints',
		 idExpList @ idExpList', aliases @ aliases')
	    end
	  | derec nil = (nil, nil, nil)
    end
(* src # 123 *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature MATCH_COMPILATION_PHASE =
    sig
	structure I: INTERMEDIATE_GRAMMAR = IntermediateGrammar
	structure O: IMPERATIVE_GRAMMAR = ImperativeGrammar

	val translate: I.component -> O.component
    end
(* src # 124 *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure MatchCompilationPhase :> MATCH_COMPILATION_PHASE =
    struct
	structure I = IntermediateGrammar
	structure O = ImperativeGrammar

	open I
	open IntermediateAux
	open SimplifyMatch

	val id_false = Id (Source.nowhere, Prebound.stamp_false, ExId "false")
	val id_true = Id (Source.nowhere, Prebound.stamp_true, ExId "true")
	val id_Match = Id (Source.nowhere, Prebound.stamp_Match, ExId "Match")
	val id_Bind = Id (Source.nowhere, Prebound.stamp_Bind, ExId "Bind")

	val longid_true = ShortId (Source.nowhere, id_true)
	val longid_false = ShortId (Source.nowhere, id_false)

	structure FieldLabelSort =
	    MakeLabelSort(type 'a t = string * id
			  fun get (s, _) = s)

	type mapping = (pos * id) list

	fun lookup (pos, (pos', id)::mappingRest) =
	    if pos = pos' then id
	    else lookup (pos, mappingRest)
	  | lookup (pos, nil) = raise Crash.Crash "MatchCompilationPhase.lookup"

	fun mappingsToSubst (mapping0, mapping) =
	    List.map (fn (pos, id) => (id, lookup (pos, mapping))) mapping0

	(* Translation *)

	fun info coord = (coord, ref O.Unknown)

	fun share nil = nil
	  | share (stms as [O.SharedStm (_, _, _)]) = stms
	  | share stms = [O.SharedStm (info Source.nowhere, stms, ref 0)]

	datatype continuation =
	    Decs of dec list * continuation
	  | Goto of O.body
	  | Share of O.body option ref * continuation
	  | Export of O.exp

	fun translateLongid (ShortId (_, id)) = (nil, id)
	  | translateLongid (LongId (coord, longid, Lab (_, s))) =
	    let
		val (stms, id) = translateLongid longid
		val id' = freshId coord
		val stm =
		    O.ValDec (info coord, id',
			      O.SelAppExp (coord, s, id), false)
	    in
		(stms @ [stm], id')
	    end

	fun decsToIdExpList (O.ValDec (_, id, exp', _)::rest, coord) =
	    (id, exp')::decsToIdExpList (rest, coord)
	  | decsToIdExpList (O.IndirectStm (_, ref (SOME body))::rest, coord) =
	    decsToIdExpList (body, coord) @ decsToIdExpList (rest, coord)
	  | decsToIdExpList (_::_, coord) =
	    Error.error (coord, "not admissible")
	  | decsToIdExpList (nil, _) = nil

	fun translateCont (Decs (dec::decr, cont)) =
	    translateDec (dec, Decs (decr, cont))
	  | translateCont (Decs (nil, cont)) = translateCont cont
	  | translateCont (Goto stms) = stms
	  | translateCont (Share (r as ref NONE, cont)) =
	    let
		val stms = share (translateCont cont)
	    in
		r := SOME stms; stms
	    end
	  | translateCont (Share (ref (SOME stms), _)) = stms
	  | translateCont (Export exp) =
	    [O.ExportStm (info Source.nowhere, exp)]
	and translateDec (ValDec (coord, VarPat (_, id), exp), cont) =
	    let
		fun declare exp' = O.ValDec (info coord, id, exp', false)
	    in
		translateExp (exp, declare, cont)
	    end
	  | translateDec (ValDec (coord, pat, exp), cont) =
	    let
		val matches = [(coord, pat, translateCont cont)]
	    in
		simplifyCase (coord, exp, matches, id_Bind)
	    end
	  | translateDec (RecDec (coord, decs), cont) =
	    let
		val (constraints, idExpList, subst) = SimplifyRec.derec decs
		val aliasDecs =
		    List.map (fn (fromId, toId) =>
			      let
				  val coord = infoId toId
				  val toExp = O.VarExp (coord, toId)
			      in
				  O.ValDec (info (infoId fromId),
					    fromId, toExp, false)
			      end) subst
		val decs' =
		    List.foldr (fn ((id, exp), decs) =>
				translateExp (substExp (exp, subst),
					      fn exp' =>
					      O.ValDec (info (infoExp exp),
							id, exp', false),
					      Goto decs)) nil idExpList
		val idExpList' = decsToIdExpList (decs', coord)
		val rest =
		    O.RecDec (info coord, idExpList', false)::aliasDecs @
		    translateCont cont
		val errStms = share [O.RaiseStm (info coord, id_Bind)]
	    in
		List.foldr
		(fn ((longid1, longid2, hasArgs), rest) =>
		 let
		     val (stms1, id1) = translateLongid longid1
		     val (stms2, id2) = translateLongid longid2
		 in
		     stms1 @ stms2 @
		     (if hasArgs then
			  let
			      val id1' = freshId coord
			      val id2' = freshId coord
			  in
			      [O.ValDec (info coord, id1',
					 O.ConAppExp (coord, id1,
						      O.OneArg id1), false),
			       O.TestStm (info coord, id1,
					  O.ConTest (id2, SOME id2'),
					  rest, errStms)]
			  end
		      else
			  [O.TestStm (info coord, id1, O.ConTest (id2, NONE),
				      rest, errStms)])
		 end) rest constraints
	    end
	and unfoldTerm (VarExp (_, longid), cont) =
	    let
		val (stms, id) = translateLongid longid
	    in
		(stms @ translateCont cont, id)
	    end
	  | unfoldTerm (exp, cont) =
	    let
		val coord = infoExp exp
		val id' = freshId coord
		fun declare exp' = O.ValDec (info coord, id', exp', false)
		val stms = translateExp (exp, declare, cont)
	    in
		(stms, id')
	    end
	and unfoldArgs (TupExp (_, exps), rest) =
	    let
		val (stms, ids) =
		    List.foldr (fn (exp, (stms, ids)) =>
				let
				    val (stms', id) =
					unfoldTerm (exp, Goto stms)
				in
				    (stms', id::ids)
				end) (rest, nil) exps
	    in
		(stms, O.TupArgs ids)
	    end
	  (*--** RecArgs *)
	  | unfoldArgs (exp, rest) =
	    let
		val (stms, id) = unfoldTerm (exp, Goto rest)
	    in
		(stms, O.OneArg id)
	    end
	and translateExp (LitExp (coord, lit), f, cont) =
	    f (O.LitExp (coord, lit))::translateCont cont
	  | translateExp (PrimExp (coord, s), f, cont) =
	    f (O.PrimExp (coord, s))::translateCont cont
	  | translateExp (NewExp (coord, stringOpt, hasArgs), f, cont) =
	    f (O.NewExp (coord, stringOpt, hasArgs))::translateCont cont
	  | translateExp (VarExp (coord, longid), f, cont) =
	    let
		val (stms, id) = translateLongid longid
	    in
		stms @ f (O.VarExp (coord, id))::translateCont cont
	    end
	  | translateExp (ConExp (coord, longid, hasArgs), f, cont) =
	    let
		val (stms, id) = translateLongid longid
	    in
		stms @ f (O.ConExp (coord, id, hasArgs))::translateCont cont
	    end
	  | translateExp (RefExp coord, f, cont) =
	    f (O.RefExp coord)::translateCont cont
	  | translateExp (TupExp (coord, exps), f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (info coord, r)]
		val (stms, ids) =
		    List.foldr (fn (exp, (stms, ids)) =>
				let
				    val (stms', id) =
					unfoldTerm (exp, Goto stms)
				in
				    (stms', id::ids)
				end) (rest, nil) exps
	    in
		r := SOME (f (O.TupExp (coord, ids))::translateCont cont);
		stms
	    end
	  | translateExp (RowExp (coord, expFields), f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (info coord, r)]
		val (stms, fields) =
		    List.foldr (fn (Field (_, Lab (_, s), exp),
				    (stms, fields)) =>
				let
				    val (stms', id) =
					unfoldTerm (exp, Goto stms)
				in
				    (stms', (s, id)::fields)
				end) (rest, nil) expFields
		val exp' =
		    case FieldLabelSort.sort fields of
			(fields', FieldLabelSort.Tup _) =>
			    O.TupExp (coord, List.map #2 fields')
		      | (fields', FieldLabelSort.Rec) =>
			    O.RecExp (coord, fields')
	    in
		r := SOME (f exp'::translateCont cont);
		stms
	    end
	  | translateExp (SelExp (coord, Lab (_, s)), f, cont) =
	    f (O.SelExp (coord, s))::translateCont cont
	  | translateExp (VecExp (coord, exps), f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (info coord, r)]
		val (stms, ids) =
		    List.foldr (fn (exp, (stms, ids)) =>
				let
				    val (stms', id) =
					unfoldTerm (exp, Goto stms)
				in
				    (stms', id::ids)
				end) (rest, nil) exps
	    in
		r := SOME (f (O.VecExp (coord, ids))::translateCont cont);
		stms
	    end
	  | translateExp (FunExp (coord, id, exp), f, cont) =
	    let
		fun return exp' = O.ReturnStm (info (infoExp exp), exp')
		val argsBodyList =
		    case exp of
			CaseExp (_, VarExp (_, ShortId (_, id')), matches) =>
			    if idEq (id, id')
				andalso not (occursInMatches (matches, id))
			    then translateFunBody (coord, id, matches, return)
			    else
				[(O.OneArg id,
				  translateExp (exp, return, Goto nil))]
		      | _ =>
			    [(O.OneArg id,
			      translateExp (exp, return, Goto nil))]
	    in
		f (O.FunExp (coord, Stamp.new (), nil, argsBodyList))::
		translateCont cont
	    end
	  | translateExp (AppExp (coord, ConExp (_, longid, true), exp2),
			  f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (info coord, r)]
		val (stms2, args) = unfoldArgs (exp2, rest)
		val (stms1, id1) = translateLongid longid
	    in
		r := SOME (f (O.ConAppExp (coord, id1, args))::
			   translateCont cont);
		stms1 @ stms2
	    end
	  | translateExp (AppExp (coord, RefExp _, exp2), f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (info coord, r)]
		val (stms2, args) = unfoldArgs (exp2, rest)
	    in
		(r := SOME (f (O.RefAppExp (coord, args))::translateCont cont);
		 stms2)
	    end
	  | translateExp (AppExp (coord, SelExp (_, Lab (_, s)), exp2),
			  f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (info coord, r)]
		val (stms2, id2) = unfoldTerm (exp2, Goto rest)
	    in
		(r := SOME (f (O.SelAppExp (coord, s, id2))::
			    translateCont cont);
		 stms2)
	    end
	  | translateExp (AppExp (coord, exp1, exp2), f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (info coord, r)]
		val (stms2, args) = unfoldArgs (exp2, rest)
		val (stms1, id1) = unfoldTerm (exp1, Goto stms2)
	    in
		r := SOME (f (O.AppExp (coord, id1, args))::
			   translateCont cont);
		stms1
	    end
	  | translateExp (AdjExp (coord, exp1, exp2), f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (info coord, r)]
		val (stms2, id2) = unfoldTerm (exp2, Goto rest)
		val (stms1, id1) = unfoldTerm (exp1, Goto stms2)
	    in
		r := SOME (f (O.AdjExp (coord, id1, id2))::translateCont cont);
		stms1
	    end
	  | translateExp (AndExp (coord, exp1, exp2), f, cont) =
	    translateExp (IfExp (coord, exp1,
				 exp2, VarExp (coord, longid_false)), f, cont)
	  | translateExp (OrExp (coord, exp1, exp2), f, cont) =
	    translateExp (IfExp (coord, exp1,
				 VarExp (coord, longid_true), exp2), f, cont)
	  | translateExp (IfExp (_, exp1, exp2, exp3), f, cont) =
	    let
		val cont' = Share (ref NONE, cont)
		val stms2 = translateExp (exp2, f, cont')
		val stms3 = translateExp (exp3, f, cont')
	    in
		simplifyIf (exp1, stms2, stms3)
	    end
	  | translateExp (WhileExp (coord, exp1, exp2), f, cont) =
	    let
		val r = ref NONE
		val cont' = Goto [O.IndirectStm (info coord, r)]
		fun eval exp' = O.EvalStm (info (infoExp exp2), exp')
		val coord' = infoExp exp1
		val id = freshId coord'
		val trueBody = translateExp (exp2, eval, cont')
		val falseBody = translateExp (TupExp (coord, nil), f, cont)
		val errorBody = [O.RaiseStm (info coord', id_Match)]
		val stms1 =
		    [O.TestStm (info coord', id,
				O.ConTest (id_true, NONE), trueBody,
				[O.TestStm (info coord', id,
					    O.ConTest (id_false, NONE),
					    falseBody, errorBody)])]
		val stms2 =
		    translateDec (ValDec (coord', VarPat (coord', id), exp1),
				  Goto stms1)
		val stms = share stms2
	    in
		r := SOME stms; stms
	    end
	  | translateExp (SeqExp (_, exps), f, cont) =
	    let
		val isLast = ref true
		fun translate (exp, stms) =
		    if !isLast then
			(case stms of
			     nil => ()
			   | _ =>
			     raise Crash.Crash "ImperativePhase.translateExp";
			 isLast := false; translateExp (exp, f, cont))
		    else
			translateExp
			(exp, (fn exp' => O.EvalStm (info (infoExp exp), exp')),
			 Goto stms)
	    in
		List.foldr (fn (exp, stms) => translate (exp, stms)) nil exps
	    end
	  | translateExp (CaseExp (coord, exp, matches), f, cont) =
	    let
		val cont' = Share (ref NONE, cont)
		val matches' =
		    List.map (fn Match (_, pat, exp) =>
			      (infoExp exp, pat, translateExp (exp, f, cont')))
		    matches
	    in
		simplifyCase (coord, exp, matches', id_Match)
	    end
	  | translateExp (RaiseExp (coord, exp), _, _) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (info coord, r)]
		val (stms, id) = unfoldTerm (exp, Goto rest)
	    in
		r := SOME [O.RaiseStm (info coord, id)];
		stms
	    end
	  | translateExp (HandleExp (coord, exp, matches), f, cont) =
	    let
		val coord' = infoExp exp
		val id' = freshId coord'
		val shared = ref 0
		val cont' = Goto [O.EndHandleStm (info coord, shared)]
		fun f' exp' = O.ValDec (info coord', id', exp', false)
		val tryBody = translateExp (exp, f', cont')
		val catchId = freshId coord
		val catchVarExp = VarExp (coord, ShortId (coord, catchId))
		val matches' =
		    List.map (fn Match (_, pat, exp) =>
			      (infoExp exp, pat, translateExp (exp, f', cont')))
		    matches
		val catchBody =
		    simplifyCase (coord, catchVarExp, matches', catchId)
		val contBody =
		    translateExp  (VarExp (coord', ShortId (coord', id')),
				   f, cont)
	    in
		[O.HandleStm (info coord, tryBody, catchId, catchBody,
			      contBody, shared)]
	    end
	  | translateExp (LetExp (coord, decs, exp), f, cont) =
	    let
		val stms = translateExp (exp, f, cont)
	    in
		translateCont (Decs (decs, Goto stms))
	    end
	and simplifyIf (AndExp (_, exp1, exp2), thenStms, elseStms) =
	    let
		val elseStms' = share elseStms
		val thenStms' = simplifyIf (exp2, thenStms, elseStms')
	    in
		simplifyIf (exp1, thenStms', elseStms')
	    end
	  | simplifyIf (OrExp (_, exp1, exp2), thenStms, elseStms) =
	    let
		val thenStms' = share thenStms
		val elseStms' = simplifyIf (exp2, thenStms', elseStms)
	    in
		simplifyIf (exp1, thenStms', elseStms')
	    end
	  | simplifyIf (exp, thenStms, elseStms) =
	    let
		val coord = infoExp exp
		val r = ref NONE
		val rest = [O.IndirectStm (info coord, r)]
		val (stms, id) = unfoldTerm (exp, Goto rest)
		val errStms = [O.RaiseStm (info coord, id_Match)]
	    in
		r := SOME [O.TestStm (info coord, id,
				      O.ConTest (id_true, NONE), thenStms,
				      [O.TestStm (info coord, id,
						  O.ConTest (id_false, NONE),
						  elseStms, errStms)])];
		stms
	    end
	and checkReachability consequents =
	    List.app (fn (coord, ref bodyOpt) =>
		      if isSome bodyOpt then ()
		      else Error.warn (coord, "unreachable expression"))
	    consequents
	and simplifyCase (coord, exp, matches, raiseId) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (info coord, r)]
		val (stms, id) = unfoldTerm (exp, Goto rest)
		val errStms = [O.RaiseStm (info coord, raiseId)]
		val (graph, consequents) = buildGraph (matches, errStms)
	    in
		r := SOME (translateGraph (graph, [(nil, id)]));
		checkReachability consequents;
		stms
	    end
	and translateFunBody (coord, id, matches, return) =
	    let
		val matches' =
		    List.map (fn Match (_, pat, exp) =>
			      (infoExp exp, pat,
			       translateExp (exp, return, Goto nil))) matches
		fun errStmsFun () = [O.RaiseStm (info coord, id_Match)]
		val argsBodyList =
		    List.map (fn (args, graph, mapping, consequents) =>
			      let
				  val stms = translateGraph (graph, mapping)
			      in
				  checkReachability consequents;
				  (args, stms)
			      end) (buildFunArgs (id, matches', errStmsFun))
	    in
		case argsBodyList of
		    (O.OneArg _, _)::_ => argsBodyList
		  | _ => (O.OneArg id, errStmsFun ())::argsBodyList
	    end
	and translateGraph (Node (pos, test, ref thenGraph, ref elseGraph,
				  status as ref (Optimized (_, _))), mapping) =
	    let
		val stms =
		    share (translateNode (pos, test, thenGraph, elseGraph,
					  mapping))
	    in
		status := Translated stms; stms
	    end
	  | translateGraph (Node (_, _, _, _, ref (Translated stms)), _) = stms
	  | translateGraph (Leaf (stms, stmsOptRef as ref NONE), _) =
	    let
		val stms' = share stms
	    in
		stmsOptRef := SOME stms'; stms'
	    end
	  | translateGraph (Leaf (_, ref (SOME stms)), _) = stms
	  | translateGraph (_, _) =
	    raise Crash.Crash "MatchCompilationPhase.translateGraph"
	and translateNode (pos, GuardTest (mapping0, exp),
			   thenGraph, elseGraph, mapping) =
	    let
		val coord = infoExp exp
		val r = ref NONE
		val rest = [O.IndirectStm (info coord, r)]
		val subst = mappingsToSubst (mapping0, mapping)
		val (stms, id) = unfoldTerm (substExp (exp, subst), Goto rest)
		val thenStms = translateGraph (thenGraph, mapping)
		val elseStms = translateGraph (elseGraph, mapping)
		val errStms = [O.RaiseStm (info coord, id_Match)]
	    in
		r := SOME [O.TestStm (info coord, id,
				      O.ConTest (id_true, NONE), thenStms,
				      [O.TestStm (info coord, id,
						  O.ConTest (id_false, NONE),
						  elseStms, errStms)])];
		stms
	    end
	  | translateNode (pos, DecTest (mapping0, coord, decs),
			   thenGraph, _, mapping) =
	    let
		val thenStms = translateGraph (thenGraph, mapping)
		val subst = mappingsToSubst (mapping0, mapping)
		val cont = Decs (List.map (fn dec => substDec (dec, subst))
				 decs, Goto thenStms)
	    in
		translateCont cont
	    end
	  | translateNode (pos, test, thenGraph, elseGraph, mapping) =
	    let
		val id = lookup (pos, mapping)
		val (stms, test', mapping') =
		    translateTest (test, pos, mapping)
	    in
		stms @ [O.TestStm (info Source.nowhere, id, test',
				   translateGraph (thenGraph, mapping'),
				   translateGraph (elseGraph, mapping'))]
	    end
	and translateTest (LitTest lit, _, mapping) =
	    (nil, O.LitTest lit, mapping)
	  | translateTest (ConTest (longid, false), _, mapping) =
	    let
		val (stms, id) = translateLongid longid
	    in
		(stms, O.ConTest (id, NONE), mapping)
	    end
	  | translateTest (ConTest (longid, true), pos, mapping) =
	    let
		val (stms, id) = translateLongid longid
		val id' = freshId Source.nowhere
		val mapping' = ((""::pos), id')::mapping
	    in
		(stms, O.ConTest (id, SOME id'), mapping')
	    end
	  | translateTest (RefTest, pos, mapping) =
	    let
		val id = freshId Source.nowhere
		val mapping' = ((""::pos), id)::mapping
	    in
		(nil, O.RefTest id, mapping')
	    end
	  | translateTest (TupTest n, pos, mapping) =
	    let
		val ids = List.tabulate (n, fn _ => freshId Source.nowhere)
		val labs = List.tabulate (n, fn i => Int.toString (i + 1))
		val mapping' =
		    foldli (fn (i, id, mapping) =>
			    (Int.toString i::pos, id)::mapping) mapping ids
	    in
		(nil, O.TupTest ids, mapping')
	    end
	  | translateTest (RecTest labs, pos, mapping) =
	    let
		val stringIdList =
		    List.map (fn s => (s, freshId Source.nowhere)) labs
		val mapping' =
		    ListPair.foldr (fn (s, (_, i), mapping) =>
				    (s::pos, i)::mapping)
		    mapping (labs, stringIdList)
	    in
		(nil, O.RecTest stringIdList, mapping')
	    end
	  | translateTest (LabTest string, pos, mapping) =
	    let
		val id = freshId Source.nowhere
		val mapping' = ((string::pos), id)::mapping
	    in
		(nil, O.LabTest (string, id), mapping')
	    end
	  | translateTest (VecTest n, pos, mapping) =
	    let
		val ids = List.tabulate (n, fn _ => freshId Source.nowhere)
		val labs = List.tabulate (n, fn i => Int.toString (i + 1))
		val mapping' =
		    foldli (fn (i, id, mapping) =>
			    (Int.toString i::pos, id)::mapping) mapping ids
	    in
		(nil, O.VecTest ids, mapping')
	    end
	  | translateTest ((GuardTest (_, _) | DecTest (_, _, _)), _, _) =
	    raise Crash.Crash "MatchCompilationPhase.translateTest"

	fun getPrintName (Id (_, _, ExId s)) = s
	  | getPrintName (Id (_, _, InId)) =
	    raise Crash.Crash "MatchCompilationPhase.getPrintName"

	structure IdSort =
	    MakeLabelSort(type 'a t = id
			  val get = getPrintName)

	fun translate (imports, exports, decs) =
	    let
		val exportExp =
		    case IdSort.sort exports of
			(exports', IdSort.Tup _) =>
			    O.TupExp (Source.nowhere, exports')
		      | (exports', IdSort.Rec) =>
			    O.RecExp (Source.nowhere,
				      List.map (fn id => (getPrintName id, id))
				      exports')
	    in
		(imports, exports,
		 translateCont (Decs (decs, Export exportExp)))
	    end
    end
(* src # 125 *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature LIVENESS_ANALYSIS_PHASE =
    sig
	structure I: IMPERATIVE_GRAMMAR = ImperativeGrammar

	val annotate: I.component -> unit
    end

(* src # 126 *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(*
 * The `Use' set of a statement is the set of stamps that
 * have already been initialized when the statement is reached
 * and that are still going to be referenced within or after it.
 *
 * Dead code elimination for defining occurrences without using occurrences:
 *    stm = ValDec (... stamp ...): stamp \in Kill(Cont(stm))
 *    stm = RecDec (... stamp ...): stamp \in Kill(Cont(stm))   (*--** check *)
 *    stm = HandleStm (... stamp ... catchBody ...): stamp \in Kill(catchBody)
 *    stm = TestStm (... stamp ... thenBody ...): stamp \in Kill(thenBody)
 *)

structure LivenessAnalysisPhase :> LIVENESS_ANALYSIS_PHASE =
    struct
	structure I = ImperativeGrammar
	open I

	datatype 'a lazyCopy =
	    Orig of 'a
	  | Copy of 'a

	fun lazyValOf (Orig x) = x
	  | lazyValOf (Copy x) = x

	fun processArgs (OneArg id, lset, x) = x (lset, id)
	  | processArgs (TupArgs ids, lset, x) =
	    List.foldl (fn (id, lset) => x (lset, id)) lset ids
	  | processArgs (RecArgs labIdList, lset, x) =
	    List.foldl (fn ((_, id), lset) => x (lset, id)) lset labIdList

	(* Compute `Use' Sets *)

	fun del (lset as (Orig set), Id (_, stamp, _)) =
	    if StampSet.member (set, stamp) then
		let
		    val set' = StampSet.copy set
		in
		    StampSet.delete (set', stamp);
		    Copy set'
		end
	    else lset
	  | del (lset as (Copy set), Id (_, stamp, _)) =
	    (StampSet.delete (set, stamp); lset)

	fun delList (lset, ids) =
	    List.foldl (fn (id, lset) => del (lset, id)) lset ids

	fun ins (lset as (Orig set), Id (_, stamp, _)) =
	    if StampSet.member (set, stamp) then lset
	    else
		let
		    val set' = StampSet.copy set
		in
		    StampSet.insert (set', stamp);
		    Copy set'
		end
	  | ins (lset as (Copy set), Id (_, stamp, _)) =
	    (StampSet.insert (set, stamp); lset)

	fun insList (lset, ids) =
	    List.foldl (fn (id, lset) => ins (lset, id)) lset ids

	fun union (Orig set, set') =
	    let
		val set'' = StampSet.copy set
	    in
		StampSet.union (set'', set');
		Copy set''
	    end
	  | union (lset as (Copy set), set') =
	    (StampSet.union (set, set'); lset)

	fun scanTest (LitTest _, lset) = lset
	  | scanTest (ConTest (id, NONE), lset) = ins (lset, id)
	  | scanTest (ConTest (id1, SOME id2), lset) =
	    del (ins (lset, id1), id2)
	  | scanTest (RefTest id, lset) = del (lset, id)
	  | scanTest (TupTest ids, lset) = delList (lset, ids)
	  | scanTest (RecTest labIdList, lset) =
	    List.foldl (fn ((_, id), lset) => del (lset, id)) lset labIdList
	  | scanTest (LabTest (_, id), lset) = del (lset, id)
	  | scanTest (VecTest ids, lset) = delList (lset, ids)

	fun setInfo ((_, r as ref (Unknown | LoopStart | LoopEnd)), set) =
	    r := Use set
	  | setInfo ((_, ref (Use _)), _) = ()
	  | setInfo ((_, ref (Kill _)), _) =
	    raise Crash.Crash "LivenessAnalysisPhase.setInfo"

	(* Annotate the `Use' set at each statement *)

	fun scanBody (ValDec (i, id, exp, _)::stms, initial) =
	    let
		val lset = scanBody (stms, initial)
		val set = lazyValOf (scanExp (exp, del (lset, id)))
	    in
		setInfo (i, set);
		Orig set
	    end
	  | scanBody (RecDec (i, idExpList, _)::stms, initial) =
	    let
		val lset = scanBody (stms, initial)
		val lset' =
		    List.foldl (fn ((_, exp), lset) => scanExp (exp, lset))
		    lset idExpList
		val set = lazyValOf lset'
		val _ = setInfo (i, set)
		val set' = StampSet.copy set
	    in
		List.app (fn (Id (_, stamp, _), _) =>
			  StampSet.delete (set', stamp)) idExpList;
		Copy set'
	    end
	  | scanBody (EvalStm (i, exp)::stms, initial) =
	    let
		val lset = scanBody (stms, initial)
		val set = lazyValOf (scanExp (exp, lset))
	    in
		setInfo (i, set);
		Orig set
	    end
	  | scanBody ([RaiseStm (i, Id (_, stamp, _))], _) =
	    let
		val set = StampSet.new ()
		val _ = StampSet.insert (set, stamp)
	    in
		setInfo (i, set);
		Orig set
	    end
	  | scanBody ([HandleStm (i, body1, id, body2, body3, _)], initial) =
	    let
		val lset3 = scanBody (body3, initial)
		val lset2 = scanBody (body2, lset3)
		val lset1 = scanBody (body1, lset2)
		val set = lazyValOf (del (lset1, id))
	    in
		setInfo (i, set);
		Orig set
	    end
	  | scanBody ([EndHandleStm (i, _)], initial) =
	    let
		val set = lazyValOf initial
	    in
		setInfo (i, set);
		Orig set
	    end
	  | scanBody ([TestStm (i, id, test, body1, body2)], initial) =
	    let
		val initial' = Orig (lazyValOf initial)
		val lset1 = scanTest (test, scanBody (body1, initial'))
		val lset2 = scanTest (test, scanBody (body2, initial'))
		val lset1' = union (lset1, lazyValOf (ins (lset2, id)))
		val set = lazyValOf lset1'
	    in
		setInfo (i, set);
		Orig set
	    end
	  | scanBody ([SharedStm (i as (_, r as ref Unknown), body, _)],
		      initial) =
	    let
		val _ = r := LoopStart
		val set = lazyValOf (scanBody (body, initial))
	    in
		setInfo (i, set);
		Orig set
	    end
	  | scanBody ([SharedStm (i as (_, r as ref LoopStart), body, _)],
		      initial) =
	    (r := LoopEnd; scanBody (body, initial))
	  | scanBody ([SharedStm ((_, r as ref LoopEnd), _, _)],
		      initial) = Copy (StampSet.new ())   (*--** or initial? *)
	  | scanBody ([SharedStm ((_, ref (Use set')), _, _)], _) = Orig set'
	  | scanBody ([SharedStm ((_, ref (Kill _)), _, _)], _) =
	    raise Crash.Crash "LivenessAnalysisPhase.scanStm 1"
	  | scanBody ([ReturnStm (i, exp)], _) =
	    let
		val set = lazyValOf (scanExp (exp, Copy (StampSet.new ())))
	    in
		setInfo (i, set);
		Orig set
	    end
	  | scanBody ([IndirectStm (i, ref bodyOpt)], initial) =
	    let
		val set = lazyValOf (scanBody (valOf bodyOpt, initial))
	    in
		setInfo (i, set);
		Orig set
	    end
	  | scanBody ([ExportStm (i, exp)], _) =
	    let
		val set = lazyValOf (scanExp (exp, Copy (StampSet.new ())))
	    in
		setInfo (i, set);
		Orig set
	    end
	  | scanBody (nil, initial) = initial
	  | scanBody (_, _) =
	    raise Crash.Crash "LivenessAnalysisPhase.scanStm 2"
	and scanExp (LitExp (_, _), lset) = lset
	  | scanExp (PrimExp (_, _), lset) = lset
	  | scanExp (NewExp (_, _, _), lset) = lset
	  | scanExp (VarExp (_, id), lset) = ins (lset, id)
	  | scanExp (ConExp (_, id, _), lset) = ins (lset, id)
	  | scanExp (RefExp _, lset) = lset
	  | scanExp (TupExp (_, ids), lset) = insList (lset, ids)
	  | scanExp (RecExp (_, labIdList), lset) =
	    List.foldl (fn ((_, id), lset) => ins (lset, id)) lset labIdList
	  | scanExp (SelExp (_, _), lset) = lset
	  | scanExp (VecExp (_, ids), lset) = insList (lset, ids)
	  | scanExp (FunExp (_, _, _, argsBodyList), lset) =
	    List.foldl (fn ((args, body), lset) =>
			let
			    val set =
				lazyValOf (scanBody (body,
						     Copy (StampSet.new ())))
			    val lset' = union (lset, set)
			in
			    processArgs (args, lset', del)
			end) lset argsBodyList
	  | scanExp (AppExp (_, id, args), lset) =
	    processArgs (args, ins (lset, id), ins)
	  | scanExp (SelAppExp (_, _, id), lset) = ins (lset, id)
	  | scanExp (ConAppExp (_, id, args), lset) =
	    processArgs (args, ins (lset, id), ins)
	  | scanExp (RefAppExp (_, args), lset) = processArgs (args, lset, ins)
	  | scanExp (PrimAppExp (_, _, ids), lset) = insList (lset, ids)
	  | scanExp (AdjExp (_, id1, id2), lset) = ins (ins (lset, id1), id2)

	(* Compute `Def' and `Kill' sets *)

	fun processArgs (OneArg id, set, x) = x (set, id)
	  | processArgs (TupArgs ids, set, x) =
	    List.app (fn id => x (set, id)) ids
	  | processArgs (RecArgs labIdList, set, x) =
	    List.app (fn (_, id) => x (set, id)) labIdList

	fun ins (set, Id (_, stamp, _)) = StampSet.insert (set, stamp)

	fun insList (set, ids) = List.app (fn id => ins (set, id)) ids

	fun initTest (LitTest _, _) = ()
	  | initTest (ConTest (_, NONE), _) = ()
	  | initTest (ConTest (_, SOME id), set) = ins (set, id)
	  | initTest (RefTest id, set) = ins (set, id)
	  | initTest (TupTest ids, set) = insList (set, ids)
	  | initTest (RecTest labIdList, set) =
	    List.app (fn (_, id) => ins (set, id)) labIdList
	  | initTest (LabTest (_, id), set) = ins (set, id)
	  | initTest (VecTest ids, set) = insList (set, ids)

	fun initStm (ValDec (_, id, exp, _), set) =
	    (ins (set, id); initExp exp)
	  | initStm (RecDec (_, idExpList, _), set) =
	    List.app (fn (id, exp) => (ins (set, id); initExp exp)) idExpList
	  | initStm (EvalStm (_, exp), _) = initExp exp
	  | initStm (RaiseStm (_, _), _) = ()
	  | initStm (HandleStm (_, body1, id, body2, body3, _), set) =
	    let
		val set' = StampSet.copy set
	    in
		ins (set', id);
		initBody (body1, StampSet.copy set);
		initBody (body2, set');
		initBody (body3, set)
	    end
	  | initStm (EndHandleStm (_, _), _) = ()
	  | initStm (TestStm (_, _, test, body1, body2), set) =
	    let
		val set' = StampSet.copy set
	    in
		initTest (test, set'); initBody (body1, set');
		initBody (body2, set)
	    end
	  | initStm (SharedStm ((_, ref (Kill _)), _, _), _) = ()
	  | initStm (SharedStm (_, body, _), set) = initBody (body, set)
	  | initStm (ReturnStm (_, exp), _) = initExp exp
	  | initStm (IndirectStm (_, ref bodyOpt), set) =
	    initBody (valOf bodyOpt, set)
	  | initStm (ExportStm (_, _), _) = ()
	and initExp (FunExp (_, _, _, argsBodyList)) =
	    List.app (fn (args, body) =>
		      let
			  val set = StampSet.new ()
		      in
			  processArgs (args, set, ins); initBody (body, set)
		      end) argsBodyList
	  | initExp _ = ()
	and initBody (stm::stms, defSet) =
	    (case infoStm stm of
		 (_, ref (Unknown | LoopStart | LoopEnd)) =>
		     raise Crash.Crash "LivenessAnalysisPhase.initBody"
	       | (_, r as ref (Use useSet)) =>
		     let
			 val killSet = StampSet.new ()
		     in
			 StampSet.app
			 (fn stamp =>
			  if StampSet.member (useSet, stamp) then ()
			  else StampSet.insert (killSet, stamp)) defSet;
			 StampSet.app
			 (fn stamp => StampSet.delete (defSet, stamp)) killSet;
			 initStm (stm, defSet);
			 r := Kill killSet;
			 initBody (stms, defSet)
		     end
	       | (_, ref (Kill _)) => ())
	  | initBody (nil, _) = ()

	fun annotate (_, _, body) =
	    (scanBody (body, Copy (StampSet.new ()));
	     initBody (body, StampSet.new ()))
    end
(* src # 127 *)
(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 1999
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature OZIFY_IMPERATIVE_GRAMMAR =
    sig
	structure I: IMPERATIVE_GRAMMAR = ImperativeGrammar

	val outputComponent: TextIO.outstream * I.component -> unit
    end
(* src # 128 *)
(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 1999
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure OzifyImperativeGrammar :> OZIFY_IMPERATIVE_GRAMMAR =
    struct
	structure I = ImperativeGrammar
	open I

	local
	    val count = ref 0
	in
	    fun gen () =
		let
		    val n = !count + 1
		in
		    count := n; n
		end
	end

	val output = TextIO.output
	val output1 = TextIO.output1

	fun f (q, s) = (output (q, s); output1 (q, #"("))
	fun m q = output1 (q, #" ")
	fun r q = output1 (q, #")")

	fun outputBool (q, b) = output (q, Bool.toString b)
	fun outputInt (q, n) = output (q, Int.toString n)
	fun outputLargeInt (q, n) = output (q, LargeInt.toString n)
	fun outputLargeWord (q, w) = outputLargeInt (q, LargeWord.toLargeInt w)
	fun outputLargeReal (q, x) = output (q, (*LargeReal.toString*) x)
	fun outputAtom (q, s) =
	    (output1 (q, #"'");
	     output (q, String.toCString s);
	     output1(q, #"'"))

	fun outputStamp (q, stamp) =
	    if stamp = Prebound.stamp_false then outputAtom (q, "false")
	    else if stamp = Prebound.stamp_true then outputAtom (q, "true")
	    else if stamp = Prebound.stamp_nil then outputAtom (q, "nil")
	    else if stamp = Prebound.stamp_cons then outputAtom (q, "cons")
	    else if stamp = Prebound.stamp_ref then outputAtom (q, "ref")
	    else if stamp = Prebound.stamp_Match then outputAtom (q, "Match")
	    else if stamp = Prebound.stamp_Bind then outputAtom (q, "Bind")
	    else output (q, Stamp.toString stamp)

	fun outputOption _ (q, NONE) =
	    (f (q, "none"); r q)
	  | outputOption outputX (q, SOME x) =
	    (f (q, "some"); outputX (q, x); r q)

	fun appTail f (x::xr) = (f (x, xr); appTail f xr)
	  | appTail _ nil = ()

	fun outputList _ (q, nil) = output(q, "nil")
	  | outputList outputX (q, xs) =
	    (output1 (q, #"[");
	     appTail (fn (x, xr) =>
		      (outputX (q, x); case xr of nil => () | _ =>  m q)) xs;
	     output1 (q, #"]"))

	fun outputChar (q, c) = output (q, Int.toString (Char.ord c))

	fun outputString (q, s) =
	    outputList outputChar (q, String.explode s)

	fun outputPair (outputA, outputB) (q, (a, b)) =
	    (output1 (q, #"("); outputA (q, a);
	     output1 (q, #"#"); outputB (q, b); output1 (q, #")"))

	fun outputCoord (q, ((ll, lc), (rl, rc))) =
	    (output (q, Int.toString ll); output1 (q, #"#");
	     output (q, Int.toString lc); output1 (q, #"#");
	     output (q, Int.toString rl); output1 (q, #"#");
	     output (q, Int.toString rc))

	fun outputInfo (q, (coord, _)) = outputCoord (q, coord)   (*--** *)

	fun outputLit (q, WordLit w) =
	    (f (q, "wordLit"); outputLargeWord (q, w); r q)
	  | outputLit (q, IntLit n) =
	    (f (q, "intLit"); outputLargeInt (q, n); r q)
	  | outputLit (q, CharLit c) =
	    (f (q, "charLit"); outputChar (q, c); r q)
	  | outputLit (q, StringLit s) =
	    (f (q, "stringLit"); outputString (q, s); r q)
	  | outputLit (q, RealLit x) =
	    (f (q, "realLit"); outputLargeReal (q, x); r q)

	fun outputLab (q, s) =
	    case Int.fromString s of
		NONE => outputAtom (q, s)
	      | SOME n => outputInt (q, n)

	fun outputId (q, Id (coord, stamp, name)) =
	    (f (q, "id"); outputCoord (q, coord); m q;
	     outputStamp (q, stamp); m q;
	     case name of
		 ExId s => (f (q, "exId"); outputAtom (q, s); r q)
	       | InId => output (q, "inId");
	     r q)

	fun outputTest (q, LitTest lit) =
	    (f (q, "litTest"); outputLit (q, lit); r q)
	  | outputTest (q, ConTest (id, idOpt)) =
	    (f (q, "conTest"); outputId (q, id); m q;
	     outputOption outputId (q, idOpt); r q)
	  | outputTest (q, RefTest id) =
	    (f (q, "refTest"); outputId (q, id); r q)
	  | outputTest (q, TupTest ids) =
	    (f (q, "tupTest"); outputList outputId (q, ids); r q)
	  | outputTest (q, RecTest labIdList) =
	    (f (q, "recTest");
	     outputList (outputPair (outputLab, outputId)) (q, labIdList); r q)
	  | outputTest (q, LabTest (lab, id)) =
	    (f (q, "labTest"); outputLab (q, lab); m q; outputId (q, id); r q)
	  | outputTest (q, VecTest ids) =
	    (f (q, "vecTest"); outputList outputId (q, ids); r q)

	fun outputFunFlag (q, PrintName s) =
	    (f (q, "printName"); outputAtom (q, s); r q)
	  | outputFunFlag (q, AuxiliaryOf stamp) =
	    (f (q, "auxiliaryOf"); outputStamp (q, stamp); r q)

	fun outputArgs outputX (q, OneArg id) =
	    (f (q, "oneArg"); outputX (q, id); r q)
	  | outputArgs outputX (q, TupArgs ids) =
	    (f (q, "tupArgs"); outputList outputX (q, ids); r q)
	  | outputArgs outputX (q, RecArgs labIdList) =
	    (f (q, "recArgs");
	     outputList (outputPair (outputLab, outputX)) (q, labIdList); r q)

	fun outputStm (q, ValDec (info, id, exp, isToplevel)) =
	    (f (q, "valDec"); outputInfo (q, info); m q;
	     outputId (q, id); m q; outputExp (q, exp); m q;
	     outputBool (q, isToplevel); r q)
	  | outputStm (q, RecDec (info, idExpList, isToplevel)) =
	    (f (q, "recDec"); outputInfo (q, info); m q;
	     outputList (outputPair (outputId, outputExp)) (q, idExpList); m q;
	     outputBool (q, isToplevel); r q)
	  | outputStm (q, EvalStm (info, exp)) =
	    (f (q, "evalStm"); outputInfo (q, info); m q;
	     outputExp (q, exp); r q)
	  | outputStm (q, HandleStm (info, body1, id, body2, body3, shared)) =
	    (shared := gen ();
	     f (q, "handleStm"); outputInfo (q, info); m q;
	     outputBody (q, body1); m q; outputId (q, id); m q;
	     outputBody (q, body2); m q; outputBody (q, body3); m q;
	     outputInt (q, !shared); r q)
	  | outputStm (q, EndHandleStm (info, ref i)) =
	    (f (q, "endHandleStm"); outputInfo (q, info); m q;
	     outputInt (q, i); r q)
	  | outputStm (q, TestStm (info, id, test, body1, body2)) =
	    (f (q, "testStm"); outputInfo (q, info); m q;
	     outputId (q, id); m q; outputTest (q, test); m q;
	     outputBody (q, body1); m q; outputBody (q, body2); r q)
	  | outputStm (q, RaiseStm (info, id)) =
	    (f (q, "raiseStm"); outputInfo (q, info); m q;
	     outputId (q, id); r q)
	  | outputStm (q, SharedStm (info, body, shared)) =
	    (if !shared = 0 then
		 (shared := gen ();
		  f (q, "sharedStm"); outputInfo (q, info); m q;
		  outputBody (q, body); m q)
	     else
		 f (q, "refStm");
	     outputInt (q, !shared); r q)
	  | outputStm (q, ReturnStm (info, exp)) =
	    (f (q, "returnStm"); outputInfo (q, info); m q;
	     outputExp (q, exp); r q)
	  | outputStm (q, IndirectStm (_, ref bodyOpt)) =
	    (output (q, "/* indirect */");
	     List.app (fn stm => (m q; outputStm (q, stm))) (valOf bodyOpt))
	  | outputStm (q, ExportStm (info, exp)) =
	    (f (q, "exportStm"); outputInfo (q, info); m q;
	     outputExp (q, exp); r q)
	and outputExp (q, LitExp (coord, lit)) =
	    (f (q, "litExp"); outputCoord (q, coord); m q;
	     outputLit (q, lit); r q)
	  | outputExp (q, PrimExp (coord, string)) =
	    (f (q, "primExp"); outputCoord (q, coord); m q;
	     outputAtom (q, string); r q)
	  | outputExp (q, NewExp (coord, stringOpt, hasArgs)) =
	    (f (q, "newExp"); outputCoord (q, coord); m q;
	     outputOption outputAtom (q, stringOpt); m q;
	     outputBool (q, hasArgs); r q)
	  | outputExp (q, VarExp (coord, id)) =
	    (f (q, "varExp"); outputCoord (q, coord); m q;
	     outputId (q, id); r q)
	  | outputExp (q, ConExp (coord, id, hasArgs)) =
	    (f (q, "conExp"); outputCoord (q, coord); m q;
	     outputId (q, id); m q; outputBool (q, hasArgs); r q)
	  | outputExp (q, RefExp coord) =
	    (f (q, "refExp"); outputCoord (q, coord); r q)
	  | outputExp (q, TupExp (coord, ids)) =
	    (f (q, "tupExp"); outputCoord (q, coord); m q;
	     outputList outputId (q, ids); r q)
	  | outputExp (q, RecExp (coord, labIdList)) =
	    (f (q, "recExp"); outputCoord (q, coord); m q;
	     outputList (outputPair (outputLab, outputId)) (q, labIdList); r q)
	  | outputExp (q, VecExp (coord, ids)) =
	    (f (q, "vecExp"); outputCoord (q, coord); m q;
	     outputList outputId (q, ids); r q)
	  | outputExp (q, SelExp (coord, lab)) =
	    (f (q, "selExp"); outputCoord (q, coord); m q;
	     outputLab (q, lab); r q)
	  | outputExp (q, FunExp (coord, stamp, flags, argsBodyList)) =
	    (f (q, "funExp"); outputCoord (q, coord); m q;
	     outputStamp (q, stamp); m q;
	     outputList outputFunFlag (q, flags); m q;
	     outputList (outputPair (outputArgs outputId, outputBody))
	     (q, argsBodyList); r q)
	  | outputExp (q, AppExp (coord, id, args)) =
	    (f (q, "appExp"); outputCoord (q, coord); m q;
	     outputId (q, id); m q; outputArgs outputId (q, args); r q)
	  | outputExp (q, SelAppExp (coord, lab, id)) =
	    (f (q, "selAppExp"); outputCoord (q, coord); m q;
	     outputLab (q, lab); m q; outputId (q, id); r q)
	  | outputExp (q, ConAppExp (coord, id, args)) =
	    (f (q, "conAppExp"); outputCoord (q, coord); m q;
	     outputId (q, id); m q; outputArgs outputId (q, args); r q)
	  | outputExp (q, RefAppExp (coord, args)) =
	    (f (q, "refAppExp"); outputCoord (q, coord); m q;
	     outputArgs outputId (q, args); r q)
	  | outputExp (q, PrimAppExp (coord, string, ids)) =
	    (f (q, "primAppExp"); outputCoord (q, coord); m q;
	     outputAtom (q, string); m q; outputList outputId (q, ids); r q)
	  | outputExp (q, AdjExp (coord, id1, id2)) =
	    (f (q, "adjExp"); outputCoord (q, coord); m q;
	     outputId (q, id1); m q; outputId (q, id2); r q)
	and outputBody (q, stms) = outputList outputStm (q, stms)

	fun outputComponent (q, (idStringList, ids, stms)) =
	    (output1 (q, #"(");
	     outputList (outputPair (outputId, outputString))
	     (q, idStringList); output1 (q, #"#");
	     outputList outputId (q, ids); output1 (q, #"#");
	     outputList outputStm (q, stms); output1 (q, #")"))
    end
(* src # 129 *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature IL =
    sig
	type id = string

	type dottedname = id list

	(* Class Attributes *)

	type isPublic = bool

	type classVisibility = isPublic

	datatype classInheritance =
	    AbstractClass
	  | InterfaceClass
	  | SealedClass
	  | ValueClass
	  | RegularClass

	type classAttr = classVisibility * classInheritance

	(* Method Attributes *)

	datatype memberVisibility =
	    Private
	  | Assembly
	  | Public
	  | FamilyAndAssembly
	  | Family
	  | FamilyOrAssembly
	datatype methKind =
	    Static
	  | Instance
	  | Abstract
	  | Virtual
	  | Final

	type methAttr = memberVisibility * methKind

	(* Field Attributes *)

	type static = bool
	type initonly = bool

	type fieldAttr = memberVisibility * static * initonly

	(* Types *)

	datatype ty =
	    ClassTy of dottedname
	  | ValueClassTy of dottedname
	  | ArrayTy of ty
	  | CharTy
	  | VoidTy
	  | BoolTy
	  | Int32Ty
	  | Float32Ty
	  | UnsignedInt32Ty

	(* Instructions *)

	type label = int

	type isInstance = bool

	datatype cond =
	    EQ
	  | GE
	  | GE_UN
	  | GT
	  | GT_UN
	  | LE
	  | LE_UN
	  | LT
	  | LT_UN
	  | NE_UN
	  | TRUE
	  | FALSE

	datatype instr =
	    Add
	  | AddOvf
	  | And
	  | B of cond * label
	  | Br of label
	  | Call of isInstance * dottedname * id * ty list * ty
	  | Callvirt of dottedname * id * ty list * ty
	  | Castclass of dottedname
	  | Ceq
	  | Cgt
	  | CgtUn
	  | Clt
	  | CltUn
	  | Comment of string
	  | Div
	  | DivUn
	  | Dup
	  | Isinst of dottedname
	  | Label of label
	  | Ldarg of int
	  | LdcI4 of int
	  | LdcR4 of string
	  | LdelemRef
	  | Ldfld of dottedname * id * ty
	  | Ldlen
	  | Ldloc of int
	  | Ldnull
	  | Ldsfld of dottedname * id * ty
	  | Ldstr of string
	  | Leave of label
	  | Newarr of ty
	  | Newobj of dottedname * ty list
	  | Mul
	  | Neg
	  | Not
	  | Or
	  | Pop
	  | Rem
	  | RemUn
	  | Ret
	  | Rethrow
	  | Shl
	  | Shr
	  | ShrUn
	  | Starg of int
	  | StelemRef
	  | Stfld of dottedname * id * ty
	  | Stloc of int
	  | Stsfld of dottedname * id * ty
	  | Sub
	  | SubOvf
	  | Switch of label list
	  | Tail
	  | Throw
	  | Try of label * label * dottedname * label * label
	  | Xor

	(* Top-Level Declarations *)

	type extends = dottedname
	type implements = dottedname list

	type locals = ty list * bool   (* initialize *)

	datatype classDecl =
	    Field of id * fieldAttr * ty
	  | Method of id * methAttr * ty list * ty * locals * instr list

	type isEntrypoint = bool

	datatype decl =
	    Class of
	    dottedname * classAttr * extends * implements * classDecl list
	  | GlobalMethod of
	    id * isPublic * ty list * ty * isEntrypoint * locals * instr list

	type program = decl list

	val outputProgram: TextIO.outstream * program -> unit
    end
(* src # 130 *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure IL :> IL =
    struct
	type id = string

	type dottedname = id list

	(* Class Attributes *)

	type isPublic = bool

	type classVisibility = isPublic

	datatype classInheritance =
	    AbstractClass
	  | InterfaceClass
	  | SealedClass
	  | ValueClass
	  | RegularClass

	type classAttr = classVisibility * classInheritance

	(* Method Attributes *)

	datatype memberVisibility =
	    Private
	  | Assembly
	  | Public
	  | FamilyAndAssembly
	  | Family
	  | FamilyOrAssembly
	datatype methKind =
	    Static
	  | Instance
	  | Abstract
	  | Virtual
	  | Final

	type methAttr = memberVisibility * methKind

	(* Field Attributes *)

	type static = bool
	type initonly = bool

	type fieldAttr = memberVisibility * static * initonly

	(* Types *)

	datatype ty =
	    ClassTy of dottedname
	  | ValueClassTy of dottedname
	  | ArrayTy of ty
	  | CharTy
	  | VoidTy
	  | BoolTy
	  | Int32Ty
	  | Float32Ty
	  | UnsignedInt32Ty

	(* Instructions *)

	type label = int

	type isInstance = bool

	datatype cond =
	    EQ
	  | GE
	  | GE_UN
	  | GT
	  | GT_UN
	  | LE
	  | LE_UN
	  | LT
	  | LT_UN
	  | NE_UN
	  | TRUE
	  | FALSE

	datatype instr =
	    Add
	  | AddOvf
	  | And
	  | B of cond * label
	  | Br of label
	  | Call of isInstance * dottedname * id * ty list * ty
	  | Callvirt of dottedname * id * ty list * ty
	  | Castclass of dottedname
	  | Ceq
	  | Cgt
	  | CgtUn
	  | Clt
	  | CltUn
	  | Comment of string
	  | Div
	  | DivUn
	  | Dup
	  | Isinst of dottedname
	  | Label of label
	  | Ldarg of int
	  | LdcI4 of int
	  | LdcR4 of string
	  | LdelemRef
	  | Ldfld of dottedname * id * ty
	  | Ldlen
	  | Ldloc of int
	  | Ldnull
	  | Ldsfld of dottedname * id * ty
	  | Ldstr of string
	  | Leave of label
	  | Newarr of ty
	  | Newobj of dottedname * ty list
	  | Mul
	  | Neg
	  | Not
	  | Or
	  | Pop
	  | Rem
	  | RemUn
	  | Ret
	  | Rethrow
	  | Shl
	  | Shr
	  | ShrUn
	  | Starg of int
	  | StelemRef
	  | Stfld of dottedname * id * ty
	  | Stloc of int
	  | Stsfld of dottedname * id * ty
	  | Sub
	  | SubOvf
	  | Switch of label list
	  | Tail
	  | Throw
	  | Try of label * label * dottedname * label * label
	  | Xor

	(* Top-Level Declarations *)

	type extends = dottedname
	type implements = dottedname list

	type locals = ty list * bool   (* initialize *)

	datatype classDecl =
	    Field of id * fieldAttr * ty
	  | Method of id * methAttr * ty list * ty * locals * instr list

	type isEntrypoint = bool

	datatype decl =
	    Class of
	    dottedname * classAttr * extends * implements * classDecl list
	  | GlobalMethod of
	    id * isPublic * ty list * ty * isEntrypoint * locals * instr list

	type program = decl list

	(* Output to File *)

	val output = TextIO.output
	val output1 = TextIO.output1

	val outputId = output

	(* Compute Stack Size *)

	structure Map =
	    MakeHashImpMap(type t = label
			   fun hash label = label)

	val size = ref 0
	val maxSize = ref 0
	val map: int Map.t ref = ref (Map.new ())
	val returnSize = ref 0

	fun pop n =
	    if !size = ~1 then ()
	    else
		let
		    val i = !size - n
		in
		    if i < 0 then
			raise Crash.Crash ("stack underflow by " ^
					   Int.toString (~i))
		    else size := i
		end

	fun push n =
	    if !size = ~1 then ()
	    else
		let
		    val i = !size + n
		in
		    size := i;
		    if i > !maxSize then maxSize := i else ()
		end

	fun branch label =
	    if !size = ~1 then
		case Map.lookup (!map, label) of
		    SOME n => size := n
		  | NONE => ()
	    else
		case Map.lookup (!map, label) of
		    SOME n =>
			if !size = n then ()
			else
			    raise Crash.Crash ("inconsistent stack size " ^
					       "for label " ^
					       Int.toString label ^ ": " ^
					       Int.toString (!size) ^ " <> " ^
					       Int.toString n)
		  | NONE => Map.insertDisjoint (!map, label, !size)

	fun catch label = Map.insertDisjoint (!map, label, 1)

	fun invalidate () = size := ~1

	fun return () =
	    if !size = ~1 orelse !size = !returnSize then ()
	    else
		raise Crash.Crash ("non-empty stack on return: " ^
				   Int.toString (!size) ^ " <> " ^
				   Int.toString (!returnSize))

	fun eval (Add | AddOvf) = (pop 2; push 1)
	  | eval And = (pop 2; push 1)
	  | eval (B ((TRUE | FALSE), label)) = (pop 1; branch label)
	  | eval (B (_, label)) = (pop 2; branch label)
	  | eval (Br label) = (branch label; invalidate ())
	  | eval (Call (isInstance, _, _, tys, ty)) =
	    (pop ((if isInstance then 1 else 0) + List.length tys);
	     case ty of VoidTy => () | _ => push 1)
	  | eval (Callvirt (_, _, tys, ty)) =
	    (pop (List.length tys + 1);
	     case ty of VoidTy => () | _ => push 1)
	  | eval (Castclass _) = (pop 1; push 1)
	  | eval (Ceq | Cgt | CgtUn | Clt | CltUn) = (pop 2; push 1)
	  | eval (Comment _) = ()
	  | eval (Div | DivUn) = (pop 2; push 1)
	  | eval Dup = (pop 1; push 2)
	  | eval (Isinst _) = (pop 1; push 1)
	  | eval (Label label) = branch label
	  | eval (Ldarg _) = push 1
	  | eval (LdcI4 _) = push 1
	  | eval (LdcR4 _) = push 1
	  | eval LdelemRef = (pop 2; push 1)
	  | eval (Ldfld (_, _, _)) = (pop 1; push 1)
	  | eval Ldlen = (pop 1; push 1)
	  | eval (Ldloc _) = push 1
	  | eval Ldnull = push 1
	  | eval (Ldsfld (_, _, _)) = push 1
	  | eval (Ldstr _) = push 1
	  | eval (Leave label) = (branch label; invalidate ())
	  | eval (Newarr _) = (pop 1; push 1)
	  | eval (Newobj (_, tys)) = (pop (List.length tys); push 1)
	  | eval Mul = (pop 2; push 1)
	  | eval Neg = (pop 2; push 1)
	  | eval Not = (pop 2; push 1)
	  | eval Or = (pop 2; push 1)
	  | eval Pop = pop 1
	  | eval (Rem | RemUn) = (pop 2; push 1)
	  | eval Ret = (return (); invalidate ())
	  | eval Rethrow = invalidate ()
	  | eval (Shl | Shr | ShrUn) = (pop 2; push 1)
	  | eval (Starg _) = pop 2
	  | eval StelemRef = pop 3
	  | eval (Stfld (_, _, _)) = pop 2
	  | eval (Stloc _) = pop 1
	  | eval (Stsfld (_, _, _)) = pop 1
	  | eval (Sub | SubOvf) = (pop 2; push 1)
	  | eval (Switch labels) = (pop 1; List.app branch labels)
	  | eval Tail = ()
	  | eval Throw = (pop 1; invalidate ())
	  | eval (Try (tryLabel, _, _, catchLabel, _)) =
	    (branch tryLabel; catch catchLabel)
	  | eval Xor = (pop 2; push 1)

	fun outputMaxStack (q, instrs, ty) =
	    (size := 0; maxSize := 0; map := Map.new ();
	     returnSize := (case ty of VoidTy => 0 | _ => 1);
	     List.app eval instrs;
	     output (q, ".maxstack "); output (q, Int.toString (!maxSize));
	     output (q, "\n"))
	    handle Crash.Crash s => output (q, "//--** " ^ s ^ "\n.maxstack 1024\n")

	(* Output IL Syntax *)

	fun outputDottedname (q, [id]) = outputId (q, id)
	  | outputDottedname (q, id::idr) =
	    (outputId (q, id); output1 (q, #"."); outputDottedname (q, idr))
	  | outputDottedname (_, nil) = raise Crash.Crash "IL.outputDottedname"

	fun outputClassAttr (q, (isPublic, inheritance)) =
	    (if isPublic then output (q, "public ")
	     else output (q, "private ");
	     case inheritance of
		 AbstractClass => output (q, "abstract ")
	       | InterfaceClass => output (q, "interface ")
	       | SealedClass => output (q, "sealed ")
	       | ValueClass => output (q, "value ")
	       | RegularClass => ())

	fun outputMemberVisibility (q, Private) = output (q, "private ")
	  | outputMemberVisibility (q, Assembly) = output (q, "assembly ")
	  | outputMemberVisibility (q, Public) = output (q, "public ")
	  | outputMemberVisibility (q, FamilyAndAssembly) =
	    output (q, "famandassem ")
	  | outputMemberVisibility (q, Family) = output (q, "family ")
	  | outputMemberVisibility (q, FamilyOrAssembly) =
	    output (q, "famorassem ")

	fun outputMethKind (q, Static) = output (q, "static ")
	  | outputMethKind (q, Instance) = ()
	  | outputMethKind (q, Abstract) = output (q, "abstract virtual ")
	  | outputMethKind (q, Virtual) = output (q, "virtual ")
	  | outputMethKind (q, Final) = output (q, "final virtual ")

	fun outputMethAttr (q, (vis, kind)) =
	    (outputMemberVisibility (q, vis);
	     outputMethKind (q, kind))

	fun outputFieldAttr (q, (vis, static, initonly)) =
	    (outputMemberVisibility (q, vis);
	     if static then output (q, "static ") else ();
	     if initonly then output (q, "initonly ") else ())

	fun outputTy (q, ClassTy dottedname) =
	    (output (q, "class "); outputDottedname (q, dottedname))
	  | outputTy (q, ValueClassTy dottedname) =
	    (output (q, "value class "); outputDottedname (q, dottedname))
	  | outputTy (q, ArrayTy ty) = (outputTy (q, ty); output (q, "[]"))
	  | outputTy (q, CharTy) = output (q, "wchar")
	  | outputTy (q, VoidTy) = output (q, "void")
	  | outputTy (q, BoolTy) = output (q, "bool")
	  | outputTy (q, Int32Ty) = output (q, "int32")
	  | outputTy (q, Float32Ty) = output (q, "float32")
	  | outputTy (q, UnsignedInt32Ty) = output (q, "unsigned int32")

	fun outputTys (q, [ty]) = outputTy (q, ty)
	  | outputTys (q, ty::tyr) =
	    (outputTy (q, ty); output (q, ", "); outputTys (q, tyr))
	  | outputTys (q, nil) = ()

	fun outputLabel (q, i) = output (q, "L" ^ Int.toString i)

	fun outputLabels (q, [label]) = outputLabel (q, label)
	  | outputLabels (q, label::labelr) =
	    (outputLabel (q, label); output (q, ", ");
	     outputLabels (q, labelr))
	  | outputLabels (q, nil) = ()

	fun intToString i =
	    if i < 0 then "-" ^ Int.toString (~i)
	    else Int.toString i

	fun outputInstr (q, Add) = output (q, "add")
	  | outputInstr (q, AddOvf) = output (q, "add.ovf")
	  | outputInstr (q, And) = output (q, "and")
	  | outputInstr (q, B (EQ, label)) =   (*--** short form? *)
	    (output (q, "beq "); outputLabel (q, label))
	  | outputInstr (q, B (GE, label)) =   (*--** short form? *)
	    (output (q, "bge "); outputLabel (q, label))
	  | outputInstr (q, B (GE_UN, label)) =   (*--** short form? *)
	    (output (q, "bge.un "); outputLabel (q, label))
	  | outputInstr (q, B (GT, label)) =   (*--** short form? *)
	    (output (q, "bgt "); outputLabel (q, label))
	  | outputInstr (q, B (GT_UN, label)) =   (*--** short form? *)
	    (output (q, "bgt.un "); outputLabel (q, label))
	  | outputInstr (q, B (LE, label)) =   (*--** short form? *)
	    (output (q, "ble "); outputLabel (q, label))
	  | outputInstr (q, B (LE_UN, label)) =   (*--** short form? *)
	    (output (q, "ble.un "); outputLabel (q, label))
	  | outputInstr (q, B (LT, label)) =   (*--** short form? *)
	    (output (q, "blt "); outputLabel (q, label))
	  | outputInstr (q, B (LT_UN, label)) =   (*--** short form? *)
	    (output (q, "blt.un "); outputLabel (q, label))
	  | outputInstr (q, B (NE_UN, label)) =   (*--** short form? *)
	    (output (q, "bne.un "); outputLabel (q, label))
	  | outputInstr (q, B (TRUE, label)) =   (*--** short form? *)
	    (output (q, "brtrue "); outputLabel (q, label))
	  | outputInstr (q, B (FALSE, label)) =   (*--** short form? *)
	    (output (q, "brfalse "); outputLabel (q, label))
	  | outputInstr (q, Br label) =   (*--** short form? *)
	    (output (q, "br "); outputLabel (q, label))
	  | outputInstr (q, Call (isInstance, dottedname, id, tys, ty)) =
	    (output (q, "call ");
	     if isInstance then output (q, "instance ") else ();
	     outputTy (q, ty); output1 (q, #" ");
	     outputDottedname (q, dottedname); output (q, "::");
	     outputId (q, id); output1 (q, #"(");
	     outputTys (q, tys); output1 (q, #")"))
	  | outputInstr (q, Callvirt (dottedname, id, tys, ty)) =
	    (output (q, "callvirt instance ");
	     outputTy (q, ty); output1 (q, #" ");
	     outputDottedname (q, dottedname); output (q, "::");
	     outputId (q, id); output1 (q, #"(");
	     outputTys (q, tys); output1 (q, #")"))
	  | outputInstr (q, Castclass dottedname) =
	    (output (q, "castclass "); outputDottedname (q, dottedname))
	  | outputInstr (q, Ceq) = output (q, "ceq")
	  | outputInstr (q, Cgt) = output (q, "cgt")
	  | outputInstr (q, CgtUn) = output (q, "cgt.un")
	  | outputInstr (q, Clt) = output (q, "clt")
	  | outputInstr (q, CltUn) = output (q, "clt.un")
	  | outputInstr (q, Comment s) = output (q, "// " ^ s)
	  | outputInstr (q, Div) = output (q, "div")
	  | outputInstr (q, DivUn) = output (q, "div.un")
	  | outputInstr (q, Dup) = output (q, "dup")
	  | outputInstr (q, Isinst dottedname) =
	    (output (q, "isinst "); outputDottedname (q, dottedname))
	  | outputInstr (q, Label label) =
	    (outputLabel (q, label); output1 (q, #":"))
	  | outputInstr (q, Ldarg i) =
	    (output (q, "ldarg");
	     if i < 4 then (output1 (q, #"."); output (q, Int.toString i))
	     else if i < 256 then
		 (output (q, ".s "); output (q, Int.toString i))
	     else (output1 (q, #" "); output (q, Int.toString i)))
	  | outputInstr (q, LdcI4 i) =
	    (output (q, "ldc.i4");
	     if i >= 0 andalso i <= 8 then
		 (output1 (q, #"."); output (q, Int.toString i))
	     else if i = ~1 then output (q, ".M1")
	     else if i >= ~128 andalso i <= 127 then
		 (output (q, ".s "); output (q, intToString i))
	     else (output1 (q, #" "); output (q, intToString i)))
	  | outputInstr (q, LdcR4 r) =
	    (output (q, "ldc.r4 "); output (q, r))
	  | outputInstr (q, LdelemRef) = output (q, "ldelem.ref")
	  | outputInstr (q, Ldfld (dottedname, id, ty)) =
	    (output (q, "ldfld "); outputTy (q, ty); output1 (q, #" ");
	     outputDottedname (q, dottedname); output (q, "::");
	     outputId (q, id))
	  | outputInstr (q, Ldlen) = output (q, "ldlen")
	  | outputInstr (q, Ldloc i) =
	    (output (q, "ldloc");
	     if i < 4 then (output1 (q, #"."); output (q, Int.toString i))
	     else if i < 256 then
		 (output (q, ".s "); output (q, Int.toString i))
	     else (output1 (q, #" "); output (q, Int.toString i)))
	  | outputInstr (q, Ldnull) = output (q, "ldnull")
	  | outputInstr (q, Ldsfld (dottedname, id, ty)) =
	    (output (q, "ldsfld "); outputTy (q, ty); output1 (q, #" ");
	     outputDottedname (q, dottedname); output (q, "::");
	     outputId (q, id))
	  | outputInstr (q, Ldstr s) =
	    (output (q, "ldstr \""); output (q, String.toCString s);
	     output1 (q, #"\""))
	  | outputInstr (q, Leave label) =   (*--** short form? *)
	    (output (q, "leave "); outputLabel (q, label))
	  | outputInstr (q, Newarr ty) =
	    (output (q, "newarr "); outputTy (q, ty))
	  | outputInstr (q, Newobj (dottedname, tys)) =
	    (output (q, "newobj instance void ");
	     outputDottedname (q, dottedname);
	     output (q, "::.ctor("); outputTys (q, tys); output1 (q, #")"))
	  | outputInstr (q, Mul) = output (q, "mul")
	  | outputInstr (q, Neg) = output (q, "neg")
	  | outputInstr (q, Not) = output (q, "not")
	  | outputInstr (q, Or) = output (q, "or")
	  | outputInstr (q, Pop) = output (q, "pop")
	  | outputInstr (q, Rem) = output (q, "rem")
	  | outputInstr (q, RemUn) = output (q, "rem.un")
	  | outputInstr (q, Ret) = output (q, "ret")
	  | outputInstr (q, Rethrow) = output (q, "rethrow")
	  | outputInstr (q, Shl) = output (q, "shl")
	  | outputInstr (q, Shr) = output (q, "shr")
	  | outputInstr (q, ShrUn) = output (q, "shr.un")
	  | outputInstr (q, Starg i) =
	    (output (q, "starg");
	     if i < 4 then (output1 (q, #"."); output (q, Int.toString i))
	     else if i < 256 then
		 (output (q, ".s "); output (q, Int.toString i))
	     else (output1 (q, #" "); output (q, Int.toString i)))
	  | outputInstr (q, StelemRef) = output (q, "stelem.ref")
	  | outputInstr (q, Stfld (dottedname, id, ty)) =
	    (output (q, "stfld "); outputTy (q, ty); output1 (q, #" ");
	     outputDottedname (q, dottedname); output (q, "::");
	     outputId (q, id))
	  | outputInstr (q, Stloc i) =
	    (output (q, "stloc");
	     if i < 4 then (output1 (q, #"."); output (q, Int.toString i))
	     else if i < 256 then
		 (output (q, ".s "); output (q, Int.toString i))
	     else (output1 (q, #" "); output (q, Int.toString i)))
	  | outputInstr (q, Stsfld (dottedname, id, ty)) =
	    (output (q, "stsfld "); outputTy (q, ty); output1 (q, #" ");
	     outputDottedname (q, dottedname); output (q, "::");
	     outputId (q, id))
	  | outputInstr (q, Sub) = output (q, "sub")
	  | outputInstr (q, SubOvf) = output (q, "sub.ovf")
	  | outputInstr (q, Switch labels) =
	    (output (q, "switch("); outputLabels (q, labels);
	     output1 (q, #")"))
	  | outputInstr (q, Tail) = output (q, "tail.")
	  | outputInstr (q, Throw) = output (q, "throw")
	  | outputInstr (q, Try (label1, label2, dottedname, label3, label4)) =
	    (output (q, ".try "); outputLabel (q, label1);
	     output (q, " to "); outputLabel (q, label2);
	     output (q, " catch "); outputDottedname (q, dottedname);
	     output (q, " handler "); outputLabel (q, label3);
	     output (q, " to "); outputLabel (q, label4))
	  | outputInstr (q, Xor) = output (q, "xor")

	fun outputInstrs (q, (instr as Try (_, _, _, _, _))::instrr, trys) =
	    outputInstrs (q, instrr, trys @ [instr])
	  | outputInstrs (q, instr::instrr, trys) =
	    (output (q, "  "); outputInstr (q, instr); output1 (q, #"\n");
	     outputInstrs (q, instrr, trys))
	  | outputInstrs (q, nil, instr::instrr) =
	    (output (q, "  "); outputInstr (q, instr); output1 (q, #"\n");
	     outputInstrs (q, nil, instrr))
	  | outputInstrs (_, nil, nil) = ()

	local
	    fun outputLocals' (q, ty::tyr) =
		(output (q, ", "); outputTy (q, ty); outputLocals' (q, tyr))
	      | outputLocals' (q, nil) = ()
	in
	    fun outputLocals (q, (ty1::tyr, zeroinit)) =
		(output (q, ".locals("); outputTy (q, ty1);
		 outputLocals' (q, tyr); output (q, ")\n");
		 if zeroinit then output (q, ".zeroinit\n") else ())
	      | outputLocals (_, (nil, _)) = ()
	end

	fun outputClassDecl (q, Field (id, attr, ty)) =
	    (output (q, ".field "); outputFieldAttr (q, attr);
	     outputTy (q, ty); output1 (q, #" "); outputId (q, id);
	     output1 (q, #"\n"))
	  | outputClassDecl (q, Method (id, attr, tys, ty, locals, instrs)) =
	    (output (q, ".method "); outputMethAttr (q, attr);
	     outputTy (q, ty); output1 (q, #" "); outputId (q, id);
	     output1 (q, #"("); outputTys (q, tys); output (q, ") {\n");
	     outputMaxStack (q, instrs, ty);
	     outputLocals (q, locals); outputInstrs (q, instrs, nil);
	     output (q, "}\n"))

	fun outputClassDecls (q, decl::declr) =
	    (outputClassDecl (q, decl); outputClassDecls (q, declr))
	  | outputClassDecls (_, nil) = ()

	fun splitNamespace [id] = (nil, id)
	  | splitNamespace (id::idr) =
	    let
		val (namespace, id') = splitNamespace idr
	    in
		(id::namespace, id')
	    end
	  | splitNamespace nil = raise Crash.Crash "IL.splitNamespace"

	local
	    fun outputDottednames (q, dottedname::dottednames) =
		(output (q, ", "); outputDottedname (q, dottedname);
		 outputDottednames (q, dottednames))
	      | outputDottednames (_, nil) = ()
	in
	    fun outputImplements (q, dottedname::dottednames) =
		(output (q, "implements "); outputDottedname (q, dottedname);
		 outputDottednames (q, dottednames))
	      | outputImplements (_, nil) = ()
	end

	fun outputDecl (q, Class (name, attr, super, interfaces, members)) =
	    let
		val (namespace, id) = splitNamespace name
	    in
		case namespace of
		    nil => ()
		  | _::_ =>
			(output (q, ".namespace ");
			 outputDottedname (q, namespace);
			 output (q, " {\n"));
		output (q, ".class "); outputClassAttr (q, attr);
		outputId (q, id); output (q, " extends ");
		outputDottedname (q, super);
		outputImplements (q, interfaces);
		output (q, " {\n"); outputClassDecls (q, members);
		output (q, "}\n");
		case namespace of
		    nil => ()
		  | _::_ => output (q, "}\n")
	    end
	  | outputDecl (q, GlobalMethod (id, isPublic, tys, ty, isEntrypoint,
					 locals, instrs)) =
	    (output (q, ".method ");
	     output (q, if isPublic then "public " else "private ");
	     outputTy (q, ty); output1 (q, #" "); outputId (q, id);
	     output1 (q, #"("); outputTys (q, tys); output (q, ") {\n");
	     if isEntrypoint then output (q, ".entrypoint\n") else ();
	     outputMaxStack (q, instrs, ty);
	     outputLocals (q, locals); outputInstrs (q, instrs, nil);
	     output (q, "}\n"))

	fun outputProgram (q, [decl]) = outputDecl (q, decl)
	  | outputProgram (q, decl::declr) =
	    (outputDecl (q, decl); output1 (q, #"\n");
	     outputProgram (q, declr))
	  | outputProgram (_, nil) = ()
    end
(* src # 131 *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure StockWerk =
    struct
	val Prebound              = ["StockWerk", "Prebound"]
	val Komponist             = ["StockWerk", "Komponist"]
	val ExceptionWrapper      = ["StockWerk", "ExceptionWrapper"]
	val RecordArity           = ["StockWerk", "RecordArity"]
	val StockWert             = ["StockWerk", "StockWert"]
	val Word                  = ["StockWerk", "Word"]
	val Int                   = ["StockWerk", "Int"]
	val Char                  = ["StockWerk", "Char"]
	val String                = ["StockWerk", "String"]
	val Real                  = ["StockWerk", "Real"]
	val NongenericConstructor = ["StockWerk", "NongenericConstructor"]
	val GenericConstructor    = ["StockWerk", "GenericConstructor"]
	val ConVal                = ["StockWerk", "ConVal"]
	val RefConstructor        = ["StockWerk", "RefConstructor"]
	val Ref                   = ["StockWerk", "Ref"]
	val Tuple2                = ["StockWerk", "Tuple2"]
	val Tuple3                = ["StockWerk", "Tuple3"]
	val Tuple4                = ["StockWerk", "Tuple4"]
	val Tuple                 = ["StockWerk", "Tuple"]
	val Record                = ["StockWerk", "Record"]
	val Vector                = ["StockWerk", "Vector"]
	val Transient             = ["StockWerk", "Transient"]
	val Promise               = ["StockWerk", "Promise"]
	val Future                = ["StockWerk", "Future"]
	val ByNeed                = ["StockWerk", "ByNeed"]
	val Selector              = ["StockWerk", "Selector"]
	val Procedure             = ["StockWerk", "Procedure"]
	val Procedure0            = ["StockWerk", "Procedure0"]
	val Procedure2            = ["StockWerk", "Procedure2"]
	val Procedure3            = ["StockWerk", "Procedure3"]
	val Procedure4            = ["StockWerk", "Procedure4"]

	val PreboundTy              = IL.ClassTy Prebound
	val KomponistTy             = IL.ClassTy Komponist
	val ExceptionWrapperTy      = IL.ClassTy ExceptionWrapper
	val RecordArityTy           = IL.ClassTy RecordArity
	val StockWertTy             = IL.ClassTy StockWert
	val WordTy                  = IL.ClassTy Word
	val IntTy                   = IL.ClassTy Int
	val CharTy                  = IL.ClassTy Char
	val StringTy                = IL.ClassTy String
	val RealTy                  = IL.ClassTy Real
	val NongenericConstructorTy = IL.ClassTy NongenericConstructor
	val GenericConstructorTy    = IL.ClassTy GenericConstructor
	val ConValTy                = IL.ClassTy ConVal
	val RefConstructorTy        = IL.ClassTy RefConstructor
	val RefTy                   = IL.ClassTy Ref
	val Tuple2Ty                = IL.ClassTy Tuple2
	val Tuple3Ty                = IL.ClassTy Tuple3
	val Tuple4Ty                = IL.ClassTy Tuple4
	val TupleTy                 = IL.ClassTy Tuple
	val RecordTy                = IL.ClassTy Record
	val VectorTy                = IL.ClassTy Vector
	val TransientTy             = IL.ClassTy Transient
	val PromiseTy               = IL.ClassTy Promise
	val FutureTy                = IL.ClassTy Future
	val ByNeedTy                = IL.ClassTy ByNeed
	val SelectorTy              = IL.ClassTy Selector
	val ProcedureTy             = IL.ClassTy Procedure
	val Procedure0Ty            = IL.ClassTy Procedure0
	val Procedure2Ty            = IL.ClassTy Procedure2
	val Procedure3Ty            = IL.ClassTy Procedure3
	val Procedure4Ty            = IL.ClassTy Procedure4
    end
(* src # 132 *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature BUILTINS =
    sig
	val lookup: string -> IL.id * IL.ty
    end
(* src # 133 *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure Builtins :> BUILTINS =
    struct
	structure Map = MakeHashImpMap(StringHashKey)

	val builtinTable =
	    let
		val map: (string * IL.ty) Map.t = Map.new ()
		val ty = StockWerk.StockWertTy
	    in
		Map.insert (map, "=", ("eq", ty));
		Map.insert (map, "<>", ("ne", ty));
		Map.insert (map, "~", ("Int$uminus", ty));
		Map.insert (map, "+", ("Int$plus", ty));
		Map.insert (map, "-", ("Int$minus", ty));
		Map.insert (map, "*", ("Int$times", ty));
		Map.insert (map, "div", ("Int$div", ty));
		Map.insert (map, "mod", ("Int$mod", ty));
		Map.insert (map, "<", ("Int$lt", ty));
		Map.insert (map, ">", ("Int$gt", ty));
		Map.insert (map, "<=", ("Int$le", ty));
		Map.insert (map, ">=", ("Int$ge", ty));
		Map.insert (map, ":=", ("General$assign", ty));
		Map.insert (map, "Char.<=", ("Char$le", ty));
		Map.insert (map, "String.^", ("String$conc", ty));
		Map.insert (map, "Word.+", ("Word$plus", ty));
		Map.insert (map, "Word.-", ("Word$minus", ty));
		Map.insert (map, "Word.*", ("Word$times", ty));
		Map.insert (map, "Word.<<", ("Word$shl", ty));
		Map.insert (map, "Word.>>", ("Word$lsr", ty));
		Map.insert (map, "Word.~>>", ("Word$asr", ty));
		Map.insert (map, "Word.fromInt'", ("Word$fromInt2", ty));
		map
	    end

	fun lookup name =
	    case Map.lookup (builtinTable, name) of
		SOME (id, ty) => (id, ty)
	      | NONE =>
		    (String.map (fn c => if c = #"." then #"$" else c) name,
		     StockWerk.StockWertTy)
    end
(* src # 134 *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(*
 * The procedures in this structure may be called according to
 * the following grammar:
 *
 *    <file> ::= init { <method> } close
 *
 *    <method> ::= defineClass
 *              |  defineMethod { <method> } closeMethod
 *              |  emit
 *              |  emitId
 *              |  declareLocal
 *              |  kill
 *              |  saveRegState { <method> } restoreRegState
 *
 * Methods may be defined in classes before the corresponding
 * invocation of defineClass.  All classes must have been defined
 * when calling close.
 *)

signature CODE_STORE =
    sig
	type class = ImperativeGrammar.stamp

	val className: class -> IL.dottedname

	type savedRegState

	val init: IL.dottedname -> unit
	val defineClass: class * IL.extends * IL.implements -> unit
	val defineMethod: class * IL.id * ImperativeGrammar.id list -> unit
	val emit: IL.instr -> unit
	val emitId: ImperativeGrammar.id -> unit
	val declareLocal: ImperativeGrammar.id -> unit
	val kill: ImperativeGrammar.StampSet.t -> unit
	val saveRegState: unit -> savedRegState
	val restoreRegState: savedRegState -> unit
	val closeMethod: unit -> unit
	val close: unit -> IL.program
    end
(* src # 135 *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure CodeStore :> CODE_STORE =
    struct
	open IL

	type stamp = ImperativeGrammar.stamp
	structure StampSet = ImperativeGrammar.StampSet

	datatype id = datatype ImperativeGrammar.id

	datatype reg =
	    SFld of index
	  | Fld of index
	  | Arg of index
	  | Loc of index
	  | Prebound of IL.id * IL.ty
	withtype index = int

	type class = stamp

	structure Map =
	    MakeHashImpMap(type t = class
			   val hash = Stamp.hash)
	structure ScopedMap =
	    MakeHashScopedImpMap(type t = stamp
				 val hash = Stamp.hash)

	type classAttrState = (extends * implements) option ref
	type scope = reg ScopedMap.t
	type classDeclsState = classDecl list ref
	type regState = scope * index ref * index ref * index list ref
	type savedRegState = index list
	type instrsState = IL.instr list ref

	val namespace: dottedname ref = ref nil
	val classes: (classAttrState * scope * classDeclsState) Map.t ref =
	    ref (Map.new ())
	val env: (class * IL.id * int * regState * instrsState) list ref =
	    ref nil

	val global = Stamp.new ()
	val preboundScope =
	    let
		open Prebound
		val scope = ScopedMap.new ()
		val ty = StockWerk.StockWertTy
	    in
		ScopedMap.insert (scope, stamp_false, Prebound ("false", ty));
		ScopedMap.insert (scope, stamp_true, Prebound ("true", ty));
		ScopedMap.insert (scope, stamp_nil, Prebound ("nil", ty));
		ScopedMap.insert (scope, stamp_cons, Prebound ("cons", ty));
		ScopedMap.insert (scope, stamp_ref, Prebound ("ref", ty));
		ScopedMap.insert (scope, stamp_Match, Prebound ("General$Match", ty));
		ScopedMap.insert (scope, stamp_Bind, Prebound ("General$Bind", ty));
		scope
	    end

	fun className class = !namespace @ ["P" ^ Stamp.toString class]
	fun sfldName i = "V" ^ Int.toString i
	fun fldName i = "G" ^ Int.toString i

	fun init dottedname =
	    (namespace := dottedname;
	     classes := Map.new ();
	     env := [(global, "main", 0,
		      (ScopedMap.copy preboundScope, ref 0, ref 0, ref nil),
		      ref nil)])

	fun defineClass (stamp, extends, implements) =
	    let
		val classAttr = SOME (extends, implements)
		val ctor =
		    Method (".ctor", (Public, Instance),
			    nil, VoidTy, (nil, false),
			    [Ldarg 0,
			     Tail, Call (true, extends, ".ctor", nil, VoidTy),
			     Ret])
	    in
		case Map.lookup (!classes, stamp) of
		    SOME (classAttrRef, _, classDeclsRef) =>
			if Option.isSome (!classAttrRef) then
			    raise Crash.Crash "CodeStore.defineClass"
			else
			    (classAttrRef := classAttr;
			     classDeclsRef := ctor::(!classDeclsRef))
		  | NONE =>
			Map.insertDisjoint (!classes, stamp,
					    (ref classAttr,
					     ScopedMap.copy preboundScope,
					     ref [ctor]))
	    end

	fun defineMethod (stamp, id, args) =
	    let
		val (scope, classDeclsRef) =
		    case Map.lookup (!classes, stamp) of
			SOME (_, scope, classDeclsRef) =>
			    (scope, classDeclsRef)
		      | NONE =>
			    let
				val scope = ScopedMap.copy preboundScope
				val classDeclsRef = ref nil
			    in
				Map.insertDisjoint
				(!classes, stamp,
				 (ref NONE, scope, classDeclsRef));
				(scope, classDeclsRef)
			    end
	    in
		ScopedMap.insertScope scope;
		List.foldl (fn (Id (_, stamp, _), i) =>
			    (ScopedMap.insertDisjoint (scope, stamp, Arg i);
			     i + 1)) 1 args;
		env := (stamp, id, List.length args,
			(scope, ref 0, ref 0, ref nil), ref nil)::(!env)
	    end

	fun emit instr =
	    let
		val (_, _, _, _, instrsRef) = List.hd (!env)
	    in
		instrsRef := instr::(!instrsRef)
	    end

	local
	    fun currentClosure () =
		let
		    val (stamp, _, _, _, _) = List.hd (!env)
		in
		    className stamp
		end

	    fun lookup ((_, _, _, (scope, ri, _, _), _)::envr, stamp) =
		(case ScopedMap.lookup (scope, stamp) of
		     SOME reg => reg
		   | NONE =>
			 let
			     val i = !ri
			     val reg = Fld i
			 in   (*--** generate SFld? *)
			     lookup (envr, stamp);
			     ScopedMap.insertDisjoint (scope, stamp, reg);
			     ri := i + 1;
			     reg
			 end)
	      | lookup (nil, stamp) =
		raise Crash.Crash ("CodeStore.lookup: " ^ Stamp.toString stamp)
	in
	    fun emitStamp stamp =
		case lookup (!env, stamp) of
		    SFld i =>
			emit (Ldsfld (currentClosure (), sfldName i,
				      StockWerk.StockWertTy))
		  | Fld i =>
			(emit (Ldarg 0);
			 emit (Ldfld (currentClosure (), fldName i,
				      StockWerk.StockWertTy)))
		  | Loc i => emit (Ldloc i)
		  | Arg i => emit (Ldarg i)
		  | Prebound (id, ty) =>
			emit (Ldsfld (StockWerk.Prebound, id, ty))
	end

	fun emitId (Id (_, stamp, _)) =
	    (emit (Comment ("load " ^ Stamp.toString stamp));
	     emitStamp stamp)

	fun declareLocal (Id (_, stamp, _)) =
	    let
		val (_, _, _, (scope, _, ri, indicesRef), _) = List.hd (!env)
	    in
		emit (Comment ("store " ^ Stamp.toString stamp));
		case ScopedMap.lookup (scope, stamp) of
		    SOME (Loc i) => emit (Stloc i)
		  | SOME _ => raise Crash.Crash "CodeStore.declareLocal"
		  | NONE =>
			let
			    val i =
				case indicesRef of
				    ref nil => !ri before ri := !ri + 1
				  | ref (index::rest) =>
					index before indicesRef := rest
			in
			    ScopedMap.insertDisjoint (scope, stamp, Loc i);
			    emit (Stloc i)
			end
	    end

	fun kill set =
	    let
		val (_, _, _, (scope, _, _, indicesRef), _) = List.hd (!env)
	    in
		StampSet.app
		(fn stamp =>
		 case ScopedMap.lookup (scope, stamp) of
		     SOME (Loc i) =>
			 (emit (Comment ("kill " ^ Stamp.toString stamp));
			  indicesRef := i::(!indicesRef))
		    | _ => emit (Comment ("nonlocal " ^ Stamp.toString stamp)))
		set
	    end

	fun saveRegState () =
	    let
		val (_, _, _, (_, _, _, ref indices), _) = hd (!env)
	    in
		indices
	    end

	fun restoreRegState indices =
	    let
		val (_, _, _, (_, _, _, indicesRef), _) = hd (!env)
	    in
		indicesRef := indices
	    end

	fun args n = List.tabulate (n, fn _ => StockWerk.StockWertTy)

	fun closeMethod () =
	    case !env of
		(stamp, id, narg, (scope, _, ref nloc, _), ref instrs)::envr =>
		    let
			val (_, _, classDeclsRef) =
			    Map.lookupExistent (!classes, stamp)
			val delta = ScopedMap.splitScope scope
			val className' = className stamp
			val _ = env := envr
			val method =
			    Method (id, (Public, Virtual),
				    args narg, StockWerk.StockWertTy,
				    (args nloc, false), List.rev instrs)
			val newClassDecls =
			    ScopedMap.foldi
			    (fn (stamp, reg, classDecls) =>
			     case reg of
				 SFld i =>
				     (emit Dup;
				      emitStamp stamp;
				      emit (Stsfld (className', sfldName i,
						    StockWerk.StockWertTy));
				      ScopedMap.insertDisjoint (scope, stamp,
								reg);
				      Field (sfldName i, (Public, true, false),
					     StockWerk.StockWertTy)::classDecls)
			       | Fld i =>
				     (emit Dup;
				      emitStamp stamp;
				      emit (Stfld (className', fldName i,
						   StockWerk.StockWertTy));
				      ScopedMap.insertDisjoint (scope, stamp,
								reg);
				      Field (fldName i, (Public, false, false),
					     StockWerk.StockWertTy)::classDecls)
			   | _ => classDecls) (!classDeclsRef) delta
		    in
			classDeclsRef := method::newClassDecls
		    end
	      | nil => raise Crash.Crash "CodeStore.closeMethod"

	fun close () =
	    let
		val mainMethod =
		    case !env of
			[(_, id, 0, (_, _, ref n, _), ref instrs)] =>
			    Class (["Main"], (true, SealedClass),
				   ["System", "Object"], nil,
				   [Method (id, (Public, Static),
					    [StockWerk.KomponistTy],
					    StockWerk.StockWertTy,
					    (args n, false),
					    List.rev instrs)])
		      | _ => raise Crash.Crash "CodeStore.close"
	    in
		Map.foldi
		(fn (stamp, (ref classAttr, scope, ref classDecls), program) =>
		 let
		     val (extends, implements) = Option.valOf classAttr
		 in
		     Class (className stamp, (true, SealedClass),
			    extends, implements, classDecls)::program
		 end) [mainMethod] (!classes)
	    end
    end
(* src # 136 *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature CODE_GEN_PHASE =
    sig
	structure I: IMPERATIVE_GRAMMAR = ImperativeGrammar
	structure O: IL = IL

	val genComponent: I.component -> O.program
    end
(* src # 137 *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(*
 * Optimierungsideen:
 *
 * Voraussetzung: Fuer Pickling/Marshaling muss erkannt werden, welche
 * Referenzen Code auf andere Closures macht.  Idee: Code wird nicht
 * in assemblierter Form in ein PEFile geschrieben (denn Code kann nicht
 * reflektiert werden), sondern in Zwischendarstellung als StockWert
 * gespeichert (bei jeder Closure in einem statischen Feld):
 * -- Verzeichnis aller TypeToken
 * -- Verzeichnis aller FieldToken
 * -- Verzeichnis aller MethodToken
 * -- IL-Code (wobei Tokens als Indizes in obige Verzeichnisse
 *    repraesentiert werden)
 * Bei Serialisierung wird der transitive Abschluss aller Closures
 * gebildet.  Closures werden ausserdem mit ihrer Definition
 * rausgeschrieben (also mit den Werten ihrer statischen Felder).
 * Bei Deserialisierung eines Token wird (bei Bedarf) der zugehoerige
 * Code in Zwischendarstellung assembliert (eine Form von JITting).
 *
 * Dann kann folgende Optimierung durchgefuehrt werden:
 *
 * Die freien Variablen werden klassifiziert nach statischen und
 * dynamischen freien Variablen (statisch = auf toplevel definiert,
 * also die V-Register in Mozart; dynamisch = nicht auf toplevel
 * definiert, also die G-Register in Mozart) und entsprechend in
 * statischen oder Instanzenfeldern gespeichert.
 *
 * Literale und RecordArities sollen auch in V-Registern gespeichert
 * werden, zaehlen also auch als `statische freie Variablen'.  V-Register
 * werden als zum Code gehoerig betrachtet.
 *
 * Vorteile:
 * -- Da sich alle Instanzen von Prozeduren die statischen freien
 *    Variablen teilen, wird die (wiederholte) Ausfuehrung einer
 *    Prozedurdefinition effizienter.
 * -- Der Heapverbrauch sinkt, da Literale nur einmal geboxt werden
 *    muessen.
 * Nachteile:
 * -- Es muss der Overhead in Kauf genommen werden, dass der Code
 *    jeder Prozedur in zwei Darstellungen gespeichert wird.
 *)

(*
 * Anzahl der generierten Klassen reduzieren:
 *
 * Eine Toplevel-Prozedur, die ausschliesslich an Designatorposition von
 * Applikationen verwendet wird, heisst Hilfsprozedur (Auxiliary).  Berechne
 * den Dominanzgraphen des Aufrufgraphen der Toplevel-Prozeduren.  Jede
 * dominierende nicht-Hilfsprozedur, die ausschliesslich Hilfsprozeduren
 * unter sich hat, kann die Definitionen ihrer Hilfsprozeduren in ihrer
 * eigenen Klasse aufnehmen.
 *
 * Entsprechend dominierte Hilfsprozeduren sollen mit dem Flag AuxiliaryOf
 * annotiert werden.
 *)

structure CodeGenPhase :> CODE_GEN_PHASE =
    struct
	structure I = ImperativeGrammar
	structure O = IL

	open I
	open O
	open CodeStore

	structure System =
	    struct
		val String = ["System", "String"]
		val StringTy = ClassTy String
	    end

	local
	    fun appi' (x::xr, f, i) = (f (i, x); appi' (xr, f, i + 1))
	      | appi' (nil, _, _) = ()
	in
	    fun appi f xs = appi' (xs, f, 0)
	end

	local
	    val count = ref 0
	in
	    fun newLabel () =
		let
		    val n = !count + 1
		in
		    count := n; n
		end
	end

	fun emitCoord (s, ((a, b), _)) =
	    emit (Comment (s ^ " at " ^ Int.toString a ^ "." ^ Int.toString b))

	fun emitRecordArity labs =
	    (emit (LdcI4 (List.length labs)); emit (Newarr System.StringTy);
	     appi (fn (i, lab) =>
		   (emit Dup; emit (LdcI4 i); emit (Ldstr lab);
		    emit (StelemRef))) labs;
	     emit (Call (false, StockWerk.RecordArity, "MakeRecordArity",
			 [ArrayTy System.StringTy], StockWerk.RecordArityTy)))

	datatype expMode =
	    PREPARE
	  | FILL
	  | BOTH

	fun idEq (Id (_, stamp1, _), Id (_, stamp2, _)) = stamp1 = stamp2

	fun genTestInt (dottedname, ty, i, elseLabel) =
	    (emit Dup; emit (Isinst dottedname); emit (B (FALSE, elseLabel));
	     emit Dup; emit (Castclass dottedname);
	     emit (Ldfld (dottedname, "Value", ty)); emit (LdcI4 i);
	     emit (B (NE_UN, elseLabel)); emit Pop)

	fun genTest (LitTest (WordLit w), elseLabel) =
	    genTestInt (StockWerk.Word, Int32Ty, LargeWord.toInt w, elseLabel)
	  | genTest (LitTest (IntLit i), elseLabel) =
	    genTestInt (StockWerk.Int, Int32Ty, Int.fromLarge i, elseLabel)
	  | genTest (LitTest (CharLit c), elseLabel) =
	    genTestInt (StockWerk.Char, CharTy, Char.ord c, elseLabel)
	  | genTest (LitTest (StringLit s), elseLabel) =
	    (emit Dup; emit (Isinst StockWerk.String);
	     emit (B (FALSE, elseLabel));
	     emit Dup; emit (Castclass StockWerk.String);
	     emit (Ldfld (StockWerk.String, "Value", System.StringTy));
	     emit (Ldstr s);
	     emit (Call (false, System.String, "Equals",
			 [System.StringTy, System.StringTy], BoolTy));
	     emit (B (FALSE, elseLabel)); emit Pop)
	  | genTest (LitTest (RealLit s), elseLabel) =
	    (emit Dup; emit (Isinst StockWerk.Real);
	     emit (B (FALSE, elseLabel));
	     emit Dup; emit (Castclass StockWerk.Real);
	     emit (Ldfld (StockWerk.Real, "Value", Float32Ty));
	     emit (LdcR4 s); emit (B (NE_UN, elseLabel)); emit Pop)
	  | genTest (ConTest (id, NONE), elseLabel) =
	    (emit Dup; emitId id; emit (B (NE_UN, elseLabel)); emit Pop)
	  | genTest (ConTest (id1, SOME id2), elseLabel) =
	    (emit Dup; emit (Isinst StockWerk.ConVal);
	     emit (B (FALSE, elseLabel));
	     emit (Castclass StockWerk.ConVal); emit Dup;
	     emit (Ldfld (StockWerk.ConVal, "Con", StockWerk.StockWertTy));
	     emitId id1; emit (B (NE_UN, elseLabel));
	     emit (Ldfld (StockWerk.ConVal, "Val", StockWerk.StockWertTy));
	     declareLocal id2)
	  | genTest (RefTest id, elseLabel) =
	    (emit Dup; emit (Isinst StockWerk.Ref);
	     emit (B (FALSE, elseLabel));
	     emit (Castclass StockWerk.Ref);
	     emit (Call (true, StockWerk.Ref, "Access", nil,
			 StockWerk.StockWertTy));
	     declareLocal id)
	  | genTest (TupTest nil, elseLabel) =
	    (emit Dup;
	     emit (Ldsfld (StockWerk.Prebound, "unit", StockWerk.StockWertTy));
	     emit (B (NE_UN, elseLabel)); emit Pop)
	  | genTest (TupTest [id1, id2], elseLabel) =
	    (emit Dup; emit (Isinst StockWerk.Tuple2);
	     emit (B (FALSE, elseLabel));
	     emit (Castclass StockWerk.Tuple2); emit Dup;
	     emit (Ldfld (StockWerk.Tuple2, "Value1", StockWerk.StockWertTy));
	     declareLocal id1;
	     emit (Ldfld (StockWerk.Tuple2, "Value2", StockWerk.StockWertTy));
	     declareLocal id2)
	  | genTest (TupTest [id1, id2, id3], elseLabel) =
	    (emit Dup; emit (Isinst StockWerk.Tuple3);
	     emit (B (FALSE, elseLabel));
	     emit (Castclass StockWerk.Tuple3); emit Dup;
	     emit (Ldfld (StockWerk.Tuple3, "Value1", StockWerk.StockWertTy));
	     declareLocal id1; emit Dup;
	     emit (Ldfld (StockWerk.Tuple3, "Value2", StockWerk.StockWertTy));
	     declareLocal id2;
	     emit (Ldfld (StockWerk.Tuple3, "Value3", StockWerk.StockWertTy));
	     declareLocal id3)
	  | genTest (TupTest [id1, id2, id3, id4], elseLabel) =
	    (emit Dup; emit (Isinst StockWerk.Tuple4);
	     emit (B (FALSE, elseLabel));
	     emit (Castclass StockWerk.Tuple4); emit Dup;
	     emit (Ldfld (StockWerk.Tuple4, "Value1", StockWerk.StockWertTy));
	     declareLocal id1; emit Dup;
	     emit (Ldfld (StockWerk.Tuple4, "Value2", StockWerk.StockWertTy));
	     declareLocal id2; emit Dup;
	     emit (Ldfld (StockWerk.Tuple4, "Value3", StockWerk.StockWertTy));
	     declareLocal id3;
	     emit (Ldfld (StockWerk.Tuple4, "Value4", StockWerk.StockWertTy));
	     declareLocal id4)
	  | genTest (TupTest ids, elseLabel) =
	    let
		val thenLabel = newLabel ()
	    in
		emit Dup; emit (Isinst StockWerk.Tuple);
		emit (B (FALSE, elseLabel));
		emit (Castclass StockWerk.Tuple); emit Dup;
		emit (Ldfld (StockWerk.Tuple, "Values",
			     ArrayTy StockWerk.StockWertTy));
		emit Dup; emit Ldlen; emit (LdcI4 (List.length ids));
		emit (B (EQ, thenLabel)); emit Pop; emit (Br elseLabel);
		emit (Label thenLabel);
		appi (fn (i, id) =>
		      (emit Dup; emit (LdcI4 i); emit LdelemRef;
		       declareLocal id)) ids; emit Pop; emit Pop
	    end
	  | genTest (RecTest labIdList, elseLabel) =
	    (emit Dup; emit (Isinst StockWerk.Record);
	     emit (B (FALSE, elseLabel));
	     emit (Castclass StockWerk.Record); emit Dup;
	     emit (Ldfld (StockWerk.Record, "Arity",
			  StockWerk.RecordArityTy));
	     emitRecordArity (List.map #1 labIdList);
	     emit (B (NE_UN, elseLabel));
	     emit (Ldfld (StockWerk.Record, "Values",
			  ArrayTy StockWerk.StockWertTy));
	     appi (fn (i, (_, id)) =>
		   (emit Dup; emit (LdcI4 i); emit LdelemRef;
		    declareLocal id)) labIdList; emit Pop)
	  | genTest (LabTest (lab, id), elseLabel) =
	    let
		val thenLabel = newLabel ()
	    in
		emit Dup; emit (Isinst StockWerk.Record);
		emit (B (FALSE, elseLabel));
		emit (Castclass StockWerk.Record); emit Dup;
		emit (Ldstr lab);
		emit (Call (true, StockWerk.Record, "CondSelect",
			    [System.StringTy], StockWerk.StockWertTy));
		emit Dup; emit (B (TRUE, thenLabel));
		emit Pop; emit (Br elseLabel);
		emit (Label thenLabel); declareLocal id; emit Pop
	    end
	  | genTest (VecTest ids, elseLabel) =
	    let
		val thenLabel = newLabel ()
	    in
		emit Dup; emit (Isinst StockWerk.Vector);
		emit (B (FALSE, elseLabel));
		emit (Castclass StockWerk.Vector); emit Dup;
		emit (Ldfld (StockWerk.Vector, "Values",
			     ArrayTy StockWerk.StockWertTy));
		emit Dup; emit Ldlen; emit (LdcI4 (List.length ids));
		emit (B (EQ, thenLabel)); emit Pop; emit (Br elseLabel);
		emit (Label thenLabel);
		appi (fn (i, id) =>
		      (emit Dup; emit (LdcI4 i); emit LdelemRef;
		       declareLocal id)) ids; emit Pop
	    end

	fun genLit (WordLit w) =
	    (emit (LdcI4 (LargeWord.toInt w));
	     emit (Newobj (StockWerk.Word, [Int32Ty])))
	  | genLit (IntLit i) =
	    (emit (LdcI4 (Int.fromLarge i));
	     emit (Newobj (StockWerk.Int, [Int32Ty])))
	  | genLit (CharLit c) =
	    (emit (LdcI4 (Char.ord c));
	     emit (Newobj (StockWerk.Char, [CharTy])))
	  | genLit (StringLit s) =
	    (emit (Ldstr s);
	     emit (Newobj (StockWerk.String, [System.StringTy])))
	  | genLit (RealLit s) =
	    (emit (LdcR4 s);
	     emit (Newobj (StockWerk.Real, [Float32Ty])))

	fun checkSingleMethod [(OneArg _, [RaiseStm (_, Id (_, stamp, _))]),
			       argsBody] =
	    if stamp = Prebound.stamp_Match then SOME argsBody
	    else NONE
	  | checkSingleMethod _ = NONE

	(*--** in EvalStm and declarations of unused variables,
	 * remove all of exp but side-effects *)

	fun genStm (ValDec (_, id, exp, _)) =
	    (genExp (exp, BOTH); declareLocal id)
	  | genStm (RecDec (_, idExpList, _)) =
	    (List.app (fn (id, exp) =>
		       (genExp (exp, PREPARE); declareLocal id)) idExpList;
	     List.app (fn (id, exp) =>
		       (emitId id; genExp (exp, FILL))) idExpList)
	  | genStm (EvalStm (_, exp)) = (genExp (exp, BOTH); emit Pop)
	  | genStm (HandleStm (_, tryBody, id, catchBody, contBody, shared)) =
	    let
		val label1 = newLabel ()
		val label2 = newLabel ()
		val label3 = newLabel ()
	    in
		shared := label3;
		emit (Try (label1, label2, StockWerk.ExceptionWrapper,
			   label2, label3));
		emit (Label label1); genBody tryBody;
		emit (Label label2);
		emit (Ldfld (StockWerk.ExceptionWrapper, "Value",
			     StockWerk.StockWertTy));
		declareLocal id; genBody catchBody;
		emit (Label label3); genBody contBody
	    end
	  | genStm (EndHandleStm (_, shared)) = emit (Leave (!shared))
	  | genStm (stm as TestStm (_, id, _, _, _)) =
	    let
		val (testBodyFunList, elseBody) = gatherTests ([stm], id)
	    in
		genTestStm (id, testBodyFunList, elseBody)
	    end
	  | genStm (RaiseStm ((((i, _), (_, _)), _), id)) =
	    (emitId id; emit (LdcI4 i);
	     emit (Newobj (StockWerk.ExceptionWrapper,
			   [StockWerk.StockWertTy, Int32Ty])); emit Throw)
	  | genStm (SharedStm (_, body, shared as ref 0)) =
	    let
		val label = newLabel ()
	    in
		emit (Label label); shared := label; genBody body
	    end
	  | genStm (SharedStm (_, _, ref i)) = emit (Br i)
	  | genStm (ReturnStm (_, exp)) = (genExp (exp, BOTH); emit Ret)
	  | genStm (IndirectStm (_, ref bodyOpt)) = genBody (valOf bodyOpt)
	  | genStm (ExportStm (_, exp)) = (genExp (exp, BOTH); emit Ret)
	and gatherTests ([TestStm (_, id, test, thenBody, elseBody)], id') =
	    if idEq (id, id') then
		let
		    val (testBodyFunList, elseBody') =
			gatherTests (elseBody, id')
		    fun thenBodyFun () = genBody thenBody
		in
		    ((test, thenBodyFun)::testBodyFunList, elseBody')
		end
	    else (nil, elseBody)
	  | gatherTests (body, _) = (nil, body)
	and genTestStm (_, nil, elseBody) = genBody elseBody
	  | genTestStm (id, testBodyFunList, elseBody) =
	    let
		val retryLabel = newLabel ()
		val falseLabel = newLabel ()
	    in
		emitId id; emit (Label retryLabel);
		List.app (fn (test, bodyFun) =>
			  let
			      val elseLabel = newLabel ()
			      val regState = saveRegState ()
			  in
			      genTest (test, elseLabel); bodyFun ();
			      emit (Label elseLabel); restoreRegState regState
			  end) testBodyFunList;
		emit Dup; emit (Isinst StockWerk.Transient);
		emit (B (FALSE, falseLabel));
		emit (Callvirt (StockWerk.StockWert, "Await", nil,
				StockWerk.StockWertTy));
		emit (Br retryLabel); emit (Label falseLabel);
		emit Pop; genBody elseBody
	    end
	and genExp (LitExp (_, lit), PREPARE) = genLit lit
	  | genExp (PrimExp (_, name), PREPARE) =
	    let
		val (id, ty) = Builtins.lookup name
	    in
		emit (Ldsfld (StockWerk.Prebound, id, ty))
	    end
	  | genExp (NewExp (_, NONE, _), PREPARE) =
	    emit (Newobj (StockWerk.GenericConstructor, nil))
	  | genExp (NewExp (_, SOME s, _), PREPARE) =
	    (emit (Ldstr s);
	     emit (Call (false, StockWerk.NongenericConstructor, "Make",
			 [System.StringTy],
			 StockWerk.NongenericConstructorTy)))
	  | genExp (VarExp (_, id), PREPARE) = emitId id
	  | genExp (ConExp (_, id as Id (_, stamp, _), _), PREPARE) = emitId id
	  | genExp (RefExp _, PREPARE) =
	    emit (Ldsfld (StockWerk.Prebound, "ref", StockWerk.StockWertTy))
	  | genExp (TupExp (_, nil), PREPARE) =
	    emit (Ldsfld (StockWerk.Prebound, "unit", StockWerk.StockWertTy))
	  | genExp (TupExp (_, nil), FILL) = ()
	  | genExp (TupExp (_, nil), BOTH) =
	    emit (Ldsfld (StockWerk.Prebound, "unit", StockWerk.StockWertTy))
	  | genExp (TupExp (_, [id1, id2]), PREPARE) =
	    emit (Newobj (StockWerk.Tuple2, nil))
	  | genExp (TupExp (_, [id1, id2]), FILL) =
	    (emit Dup; emitId id1;
	     emit (Stfld (StockWerk.Tuple2, "Value1", StockWerk.StockWertTy));
	     emitId id2;
	     emit (Stfld (StockWerk.Tuple2, "Value2", StockWerk.StockWertTy)))
	  | genExp (TupExp (_, [id1, id2]), BOTH) =
	    (emit (Newobj (StockWerk.Tuple2, nil));
	     emit Dup; emitId id1;
	     emit (Stfld (StockWerk.Tuple2, "Value1", StockWerk.StockWertTy));
	     emit Dup; emitId id2;
	     emit (Stfld (StockWerk.Tuple2, "Value2", StockWerk.StockWertTy)))
	  | genExp (TupExp (_, [id1, id2, id3]), PREPARE) =
	    emit (Newobj (StockWerk.Tuple3, nil))
	  | genExp (TupExp (_, [id1, id2, id3]), FILL) =
	    (emit Dup; emitId id1;
	     emit (Stfld (StockWerk.Tuple3, "Value1", StockWerk.StockWertTy));
	     emit Dup; emitId id2;
	     emit (Stfld (StockWerk.Tuple3, "Value2", StockWerk.StockWertTy));
	     emitId id3;
	     emit (Stfld (StockWerk.Tuple3, "Value3", StockWerk.StockWertTy)))
	  | genExp (TupExp (_, [id1, id2, id3]), BOTH) =
	    (emit (Newobj (StockWerk.Tuple3, nil));
	     emit Dup; emitId id1;
	     emit (Stfld (StockWerk.Tuple3, "Value1", StockWerk.StockWertTy));
	     emit Dup; emitId id2;
	     emit (Stfld (StockWerk.Tuple3, "Value2", StockWerk.StockWertTy));
	     emit Dup; emitId id3;
	     emit (Stfld (StockWerk.Tuple3, "Value3", StockWerk.StockWertTy)))
	  | genExp (TupExp (_, [id1, id2, id3, id4]), PREPARE) =
	    emit (Newobj (StockWerk.Tuple4, nil))
	  | genExp (TupExp (_, [id1, id2, id3, id4]), FILL) =
	    (emit Dup; emitId id1;
	     emit (Stfld (StockWerk.Tuple4, "Value1", StockWerk.StockWertTy));
	     emit Dup; emitId id2;
	     emit (Stfld (StockWerk.Tuple4, "Value2", StockWerk.StockWertTy));
	     emit Dup; emitId id3;
	     emit (Stfld (StockWerk.Tuple4, "Value3", StockWerk.StockWertTy));
	     emitId id4;
	     emit (Stfld (StockWerk.Tuple4, "Value4", StockWerk.StockWertTy)))
	  | genExp (TupExp (_, [id1, id2, id3, id4]), BOTH) =
	    (emit (Newobj (StockWerk.Tuple4, nil));
	     emit Dup; emitId id1;
	     emit (Stfld (StockWerk.Tuple4, "Value1", StockWerk.StockWertTy));
	     emit Dup; emitId id2;
	     emit (Stfld (StockWerk.Tuple4, "Value2", StockWerk.StockWertTy));
	     emit Dup; emitId id3;
	     emit (Stfld (StockWerk.Tuple4, "Value3", StockWerk.StockWertTy));
	     emit Dup; emitId id4;
	     emit (Stfld (StockWerk.Tuple4, "Value4", StockWerk.StockWertTy)))
	  | genExp (TupExp (_, ids), PREPARE) =
	    (emit (LdcI4 (List.length ids));
	     emit (Newarr StockWerk.StockWertTy);
	     emit (Newobj (StockWerk.Tuple, [ArrayTy StockWerk.StockWertTy])))
	  | genExp (TupExp (_, ids), FILL) =
	    (emit (Ldfld (StockWerk.Tuple, "Values",
			  ArrayTy StockWerk.StockWertTy));
	     appi (fn (i, id) =>
		   (emit Dup; emit (LdcI4 i); emitId id; emit StelemRef)) ids;
	     emit Pop)
	  | genExp (TupExp (_, ids), BOTH) =
	    (emit (LdcI4 (List.length ids));
	     emit (Newarr StockWerk.StockWertTy);
	     appi (fn (i, id) =>
		   (emit Dup; emit (LdcI4 i); emitId id; emit StelemRef)) ids;
	     emit (Newobj (StockWerk.Tuple, [ArrayTy StockWerk.StockWertTy])))
	  | genExp (RecExp (_, labIdList), PREPARE) =
	    (emitRecordArity (List.map #1 labIdList);
	     emit (LdcI4 (List.length labIdList));
	     emit (Newarr StockWerk.StockWertTy);
	     emit (Newobj (StockWerk.Record, [StockWerk.RecordArityTy,
					      ArrayTy StockWerk.StockWertTy])))
	  | genExp (RecExp (_, labIdList), FILL) =
	    (emit (Ldfld (StockWerk.Record, "Values",
			  ArrayTy StockWerk.StockWertTy));
	     appi (fn (i, (_, id)) =>
		   (emit Dup; emit (LdcI4 i); emitId id; emit StelemRef))
	     labIdList;
	     emit Pop)
	  | genExp (RecExp (_, labIdList), BOTH) =
	    (emitRecordArity (List.map #1 labIdList);
	     emit (LdcI4 (List.length labIdList));
	     emit (Newarr StockWerk.StockWertTy);
	     appi (fn (i, (_, id)) =>
		   (emit Dup; emit (LdcI4 i); emitId id; emit StelemRef))
	     labIdList;
	     emit (Newobj (StockWerk.Record, [StockWerk.RecordArityTy,
					      ArrayTy StockWerk.StockWertTy])))
	  | genExp (SelExp (_, s), BOTH) =
	    (emit (Ldstr s);
	     emit (Newobj (StockWerk.Selector, [System.StringTy])))
	  | genExp (VecExp (_, ids), PREPARE) =
	    (emit (LdcI4 (List.length ids));
	     emit (Newarr StockWerk.StockWertTy);
	     emit (Newobj (StockWerk.Vector, [ArrayTy StockWerk.StockWertTy])))
	  | genExp (VecExp (_, ids), FILL) =
	    (emit (Ldfld (StockWerk.Vector, "Values",
			  ArrayTy StockWerk.StockWertTy));
	     appi (fn (i, id) =>
		   (emit Dup; emit (LdcI4 i); emitId id; emit StelemRef)) ids;
	     emit Pop)
	  | genExp (FunExp (coord, stamp, _, argsBodyList), PREPARE) =
	    (emitCoord ("FunExp", coord); emit (Newobj (className stamp, nil));
	     case checkSingleMethod argsBodyList of
		 SOME (TupArgs nil, _) =>
		     defineClass (stamp, StockWerk.Procedure0, nil)
	       | SOME (TupArgs [_, _], _) =>
		     defineClass (stamp, StockWerk.Procedure2, nil)
	       | SOME (TupArgs [_, _, _], _) =>
		     defineClass (stamp, StockWerk.Procedure3, nil)
	       | SOME (TupArgs [_, _, _, _], _) =>
		     defineClass (stamp, StockWerk.Procedure4, nil)
	       | _ =>
		     defineClass (stamp, StockWerk.Procedure, nil))
	  | genExp (FunExp (_, stamp, _, argsBodyList), FILL) =
	    (case checkSingleMethod argsBodyList of
		 SOME (TupArgs nil, body) =>
		     (defineMethod (stamp, "Apply0", nil);
		      genBody body; closeMethod ())
	       | SOME (TupArgs (ids as [_, _]), body) =>
		     (defineMethod (stamp, "Apply2", ids);
		      genBody body; closeMethod ())
	       | SOME (TupArgs (ids as [_, _, _]), body) =>
		     (defineMethod (stamp, "Apply3", ids);
		      genBody body; closeMethod ())
	       | SOME (TupArgs (ids as [_, _, _, _]), body) =>
		     (defineMethod (stamp, "Apply4", ids);
		      genBody body; closeMethod ())
	       | _ =>
		     (case argsBodyList of
			  (OneArg id, body)::rest =>
			      genFunBody (stamp, id, body, rest)
			| _ => raise Crash.Crash "CodeGenPhase.genExp");
	     emit Pop)
	  | genExp (AppExp (_, id1, OneArg id2), BOTH) =
	    (emitId id1; emitId id2;
	     emit (Callvirt (StockWerk.StockWert, "Apply",
			     [StockWerk.StockWertTy], StockWerk.StockWertTy)))
	  | genExp (AppExp (_, id, TupArgs nil), BOTH) =
	    (emitId id;
	     emit (Callvirt (StockWerk.StockWert, "Apply0",
			     nil, StockWerk.StockWertTy)))
	  | genExp (AppExp (_, id, TupArgs [id1, id2]), BOTH) =
	    (emitId id; emitId id1; emitId id2;
	     emit (Callvirt (StockWerk.StockWert, "Apply2",
			     [StockWerk.StockWertTy, StockWerk.StockWertTy],
			     StockWerk.StockWertTy)))
	  | genExp (AppExp (_, id, TupArgs [id1, id2, id3]), BOTH) =
	    (emitId id; emitId id1; emitId id2; emitId id3;
	     emit (Callvirt (StockWerk.StockWert, "Apply3",
			     [StockWerk.StockWertTy, StockWerk.StockWertTy,
			      StockWerk.StockWertTy], StockWerk.StockWertTy)))
	  | genExp (AppExp (_, id, TupArgs [id1, id2, id3, id4]), BOTH) =
	    (emitId id; emitId id1; emitId id2; emitId id3; emitId id4;
	     emit (Callvirt (StockWerk.StockWert, "Apply4",
			     [StockWerk.StockWertTy, StockWerk.StockWertTy,
			      StockWerk.StockWertTy, StockWerk.StockWertTy],
			     StockWerk.StockWertTy)))
	  | genExp (AppExp (coord, id, TupArgs ids), BOTH) =
	    (emitId id; genExp (TupExp (coord, ids), BOTH);
	     emit (Callvirt (StockWerk.StockWert, "Apply",
			     [StockWerk.StockWertTy], StockWerk.StockWertTy)))
	  | genExp (AppExp (coord, id, RecArgs labIdList), BOTH) =
	    (emitId id; genExp (RecExp (coord, labIdList), BOTH);
	     emit (Callvirt (StockWerk.StockWert, "Apply",
			     [StockWerk.StockWertTy], StockWerk.StockWertTy)))
	  | genExp (SelAppExp (_, s, id), BOTH) =
	    (emitId id; emit (Ldstr s);
	     emit (Callvirt (StockWerk.StockWert, "Select", [System.StringTy],
			     StockWerk.StockWertTy)))
	  | genExp (ConAppExp (_, id, _), PREPARE) =
	    (emitId id;
	     emit (Newobj (StockWerk.ConVal, [StockWerk.StockWertTy])))
	  | genExp (ConAppExp (_, _, args), FILL) =
	    (genArgs args;
	     emit (Stfld (StockWerk.ConVal, "Val", StockWerk.StockWertTy)))
	  | genExp (RefAppExp (_, _), PREPARE) =
	    emit (Newobj (StockWerk.Ref, nil))
	  | genExp (RefAppExp (_, args), FILL) =
	    (genArgs args;
	     emit (Call (true, StockWerk.Ref, "Assign",
			 [StockWerk.StockWertTy], VoidTy)))
	  | genExp (PrimAppExp (_, name, ids), BOTH) =
	    (*--** *)
	    raise Crash.Crash "CodeGenPhase.genExp: PrimAppExp"
	  | genExp (AdjExp (_, id1, id2), BOTH) =
	    (*--** *)
	    raise Crash.Crash "CodeGenPhase.genExp: AdjExp"
	  | genExp (exp, PREPARE) =
	    raise Crash.Crash "CodeGenPhase.genExp: not admissible"
	  | genExp (_, FILL) = emit Pop
	  | genExp (exp, BOTH) =
	    (genExp (exp, PREPARE); emit Dup; genExp (exp, FILL))
	and genFunBody (stamp, id, body, argsBodyList) =
	    let
		val testBodyFunList =
		    List.map
		    (fn (args, body) =>
		     case args of
			 OneArg _ => raise Crash.Crash "CodeGen.genFunBody"
		       | TupArgs (ids as (nil | [_, _] | [_, _, _] |
					  [_, _, _, _])) =>
			     let
				 val name =
				     "Apply" ^ Int.toString (List.length ids)
			     in
				 defineMethod (stamp, name, ids);
				 genBody body; closeMethod ();
				 (TupTest ids,
				  fn () =>
				  (emit (Ldarg 0); List.map emitId ids;
				   emit Tail;
				   emit (Call (true, className stamp, name,
					       List.map
					       (fn _ => StockWerk.StockWertTy)
					       ids, StockWerk.StockWertTy));
				   emit Ret))
			     end
		       | TupArgs ids =>
			     (TupTest ids, fn () => genBody body)
		       | RecArgs labIdList =>
			     (RecTest labIdList, fn () => genBody body))
		    argsBodyList
	    in
		defineMethod (stamp, "Apply", [id]);
		genTestStm (id, testBodyFunList, body);
		closeMethod ()
	    end
	and genArgs (OneArg id) = emitId id
	  | genArgs (TupArgs ids) = genExp (TupExp (Source.nowhere, ids), BOTH)
	  | genArgs (RecArgs idExpList) =
	    genExp (RecExp (Source.nowhere, idExpList), BOTH)
	and genBody (stm::stms) =
	    (case infoStm stm of
		 (_, ref (Kill set)) => kill set
	       | (_, ref _) => ();
	     genStm stm; genBody stms)
	  | genBody nil = ()

	fun genComponent (component as (imports, _, body)) =
	    (LivenessAnalysisPhase.annotate component;
	     init ["Test"];
	     List.app (fn (id, string) =>
		       (emit (Ldarg 0);
			emit (Ldstr string);
			emit (Call (true, StockWerk.Komponist, "Import",
				    [System.StringTy], StockWerk.StockWertTy));
			declareLocal id)) imports;
	     genBody body; close())
    end
(* src # 138 *)
signature MAIN =
  sig

    val parseString :		string -> InputGrammar.Component
    val parseFile :		string -> InputGrammar.Component

    val abstractString :	string -> AbstractGrammar.component
    val abstractFile :		string -> AbstractGrammar.component

    val elabString :		string -> TypedGrammar.component
    val elabFile :		string -> TypedGrammar.component

    val translateString :	string -> IntermediateGrammar.component
    val translateFile :		string -> IntermediateGrammar.component
    val translateString' :	string -> IntermediateGrammar.component
    val translateFile' :	string -> IntermediateGrammar.component

    val imperatifyString :	string -> ImperativeGrammar.component
    val imperatifyFile :	string -> ImperativeGrammar.component
    val imperatifyString' :	string -> ImperativeGrammar.component
    val imperatifyFile' :	string -> ImperativeGrammar.component

    val ozifyStringToStdOut :	string -> unit
    val ozifyFileToStdOut :	string -> unit
    val ozifyStringToStdOut' :	string -> unit
    val ozifyFileToStdOut' :	string -> unit

    val ozifyStringToFile :	string * string -> unit
    val ozifyFileToFile :	string * string -> unit
    val ozifyStringToFile' :	string * string -> unit
    val ozifyFileToFile' :	string * string -> unit

    val debugStringToStdOut :	string -> unit
    val debugFileToStdOut :	string -> unit
    val debugStringToStdOut' :	string -> unit
    val debugFileToStdOut' :	string -> unit

    val debugStringToFile :	string * string -> unit
    val debugFileToFile :	string * string -> unit
    val debugStringToFile' :	string * string -> unit
    val debugFileToFile' :	string * string -> unit

    val comifyStringToStdOut :	string -> unit
    val comifyFileToStdOut :	string -> unit
    val comifyStringToStdOut' :	string -> unit
    val comifyFileToStdOut' :	string -> unit

    val comifyStringToFile :	string * string -> unit
    val comifyFileToFile :	string * string -> unit
    val comifyStringToFile' :	string * string -> unit
    val comifyFileToFile' :	string * string -> unit

  end
(* src # 139 *)
structure Main :> MAIN =
  struct

    fun processString process source =
	process source
	handle exn as Crash.Crash message =>
	    ( TextIO.output(TextIO.stdErr, "CRASH: " ^ message ^ "\n")
	    ; raise exn
	    )

    fun processFile process name =
	let
	    val file   = TextIO.openIn name
	    val source = TextIO.inputAll file
	    val _      = TextIO.closeIn file
	in
	    processString process source
	end

    fun toFile process name s =
	let
	    val file = TextIO.openOut name
	in
	    process file s handle x => ( TextIO.closeOut file ; raise x ) ;
	    TextIO.closeOut file
	end

    val parse      = ParsingPhase.parse
    fun abstract x = (AbstractionPhase.translate (BindEnv.copy BindEnv0.E0) o parse) x
    fun elab x     = (ElaborationPhase.elab (Env.copy Env0.E0) o abstract) x
    fun elab' x    = let val y = abstract x in
			ElaborationPhase.elab (Env.copy Env0.E0) y ; y
		     end
    val translate   = TranslationPhase.translate o elab'
    val translate'  = TranslationPhase.translate o abstract
    val imperatify  = MatchCompilationPhase.translate o translate
    val imperatify' = MatchCompilationPhase.translate o translate'
    val ilify       = CodeGenPhase.genComponent o imperatify
    val ilify'      = CodeGenPhase.genComponent o imperatify'

    fun ozify outstream s =
	let
	    val component = imperatify s
	in
	    OzifyImperativeGrammar.outputComponent (outstream, component);
	    TextIO.output1 (outstream, #"\n")
	end

    fun ozify' outstream s =
	let
	    val component = imperatify' s
	in
	    OzifyImperativeGrammar.outputComponent (outstream, component);
	    TextIO.output1 (outstream, #"\n")
	end

    fun debug outstream s =
	let
	    val x = imperatify s
	    val _ = LivenessAnalysisPhase.annotate x
	    val s' = OutputImperativeGrammar.outputComponent x
	in
	    TextIO.output (outstream, s')
	end

    fun debug' outstream s =
	let
	    val x = imperatify' s
	    val _ = LivenessAnalysisPhase.annotate x
	    val s' = OutputImperativeGrammar.outputComponent x
	in
	    TextIO.output (outstream, s')
	end

    fun comify outstream s =
	let
	    val component = ilify s
	in
	    IL.outputProgram (outstream, component);
	    TextIO.output1 (outstream, #"\n")
	end

    fun comify' outstream s =
	let
	    val component = ilify' s
	in
	    IL.outputProgram (outstream, component);
	    TextIO.output1 (outstream, #"\n")
	end

    val parseString		= processString parse
    val parseFile		= processFile parse

    val abstractString		= processString abstract
    val abstractFile		= processFile abstract

    val elabString		= processString elab
    val elabFile		= processFile elab

    val translateString		= processString translate
    val translateFile		= processFile translate
    val translateString'	= processString translate'
    val translateFile'		= processFile translate'

    val imperatifyString	= processString imperatify
    val imperatifyFile		= processFile imperatify
    val imperatifyString'	= processString imperatify'
    val imperatifyFile'		= processFile imperatify'

    val ozifyStringToStdOut	= processString (ozify TextIO.stdOut)
    val ozifyFileToStdOut	= processFile (ozify TextIO.stdOut)
    val ozifyStringToStdOut'	= processString (ozify' TextIO.stdOut)
    val ozifyFileToStdOut'	= processFile (ozify' TextIO.stdOut)

    fun ozifyStringToFile(s,n)	= processString (toFile ozify n) s
    fun ozifyFileToFile(n1,n2)	= processFile (toFile ozify' n2) n1
    fun ozifyStringToFile'(s,n)	= processString (toFile ozify n) s
    fun ozifyFileToFile'(n1,n2)	= processFile (toFile ozify' n2) n1

    val debugStringToStdOut	= processString (debug TextIO.stdOut)
    val debugFileToStdOut	= processFile (debug TextIO.stdOut)
    val debugStringToStdOut'	= processString (debug' TextIO.stdOut)
    val debugFileToStdOut'	= processFile (debug' TextIO.stdOut)

    fun debugStringToFile(s,n)	= processString (toFile debug n) s
    fun debugFileToFile(n1,n2)	= processFile (toFile debug n2) n1
    fun debugStringToFile'(s,n)	= processString (toFile debug' n) s
    fun debugFileToFile'(n1,n2)	= processFile (toFile debug' n2) n1

    val comifyStringToStdOut	= processString (comify TextIO.stdOut)
    val comifyFileToStdOut	= processFile (comify TextIO.stdOut)
    val comifyStringToStdOut'	= processString (comify' TextIO.stdOut)
    val comifyFileToStdOut'	= processFile (comify' TextIO.stdOut)

    fun comifyStringToFile(s,n)	= processString (toFile comify n) s
    fun comifyFileToFile(n1,n2)	= processFile (toFile comify n2) n1
    fun comifyStringToFile'(s,n) = processString (toFile comify' n) s
    fun comifyFileToFile'(n1,n2) = processFile (toFile comify' n2) n1

  end
