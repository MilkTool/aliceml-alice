(*
 * Authors:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt and Andreas Rossberg, 1999-2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure InputGrammar        from "../frontend-sml/InputGrammar"
import structure AbstractGrammar     from "../frontend-common/AbstractGrammar"
import structure TypedGrammar        from "../frontend-common/TypedGrammar"
import structure IntermediateGrammar from "../common/IntermediateGrammar"
import structure FlatGrammar         from "../backend-common/FlatGrammar"

import structure Source             from "../infrastructure/Source"
import structure Crash              from "../infrastructure/Crash"
import structure Composer           from "Composer"
import structure Signature          from "Signature"

import functor MkSwitches           from "../infrastructure/MkSwitches"
import functor MkMozartTarget       from "../backend-mozart/MkMozartTarget"
import functor MkFrontendSML        from "../frontend-sml/MkFrontendSML"
import functor MkFrontendCommon     from "../frontend-common/MkFrontendCommon"
import functor MkBackendCommon      from "../backend-common/MkBackendCommon"
import functor MkBackendMozart      from "../backend-mozart/MkBackendMozart"
import functor MkCompiler           from "MkCompiler"
import functor MkRecursiveCompiler  from "MkRecursiveCompiler"

import functor MkParsingPhase       from "../frontend-sml/MkParsingPhase"
import functor MkAbstractionPhase   from "../frontend-sml/MkAbstractionPhase"
import functor MkElaborationPhase   from "../frontend-common/MkElaborationPhase"
import functor MkTranslationPhase   from "../frontend-common/MkTranslationPhase"
import functor MkTracingPhase       from "../infrastructure/MkTracingPhase"
import functor MkResultDumpingPhase from
					"../infrastructure/MkResultDumpingPhase"

signature DEBUG =
    sig
	val parseString:	string -> InputGrammar.t
	val parseFile:		string -> InputGrammar.t

	val abstractString:	string -> AbstractGrammar.t
	val abstractFile:	string -> AbstractGrammar.t

	val elabString:		string -> TypedGrammar.t
	val elabFile:		string -> TypedGrammar.t

	val translateString:	string -> IntermediateGrammar.t
	val translateFile:	string -> IntermediateGrammar.t

	val flattenString:	string -> FlatGrammar.t
	val flattenFile:	string -> FlatGrammar.t
    end

structure Debug : DEBUG =
    struct
	(* Build a recursive compiler - to obtain acquireSign *)

	structure Switches = MkSwitches(val logOut = TextIO.stdOut)

	val f: (Source.desc * Url.t -> Composer.Sig.t) ref =
	    ref (fn _ => raise Crash.Crash "SMLToMozartMain.f")

	structure MozartTarget =
	    MkMozartTarget(structure Switches = Switches
			   structure Sig = Signature)

	structure FrontendSML =
	    MkFrontendSML(fun loadSign (desc, url) = !f (desc, url)
			  structure Switches = Switches)

	structure FrontendCommon =
	    MkFrontendCommon(fun loadSign (desc, url) = !f (desc, url)
			     structure Switches = Switches)

	structure BackendCommon = MkBackendCommon(Switches)

	structure BackendMozart =
	    MkBackendMozart(structure Switches = Switches
			    structure MozartTarget = MozartTarget)

	structure Compiler =
	    MkCompiler(structure Switches         = Switches
		       structure Target           = MozartTarget
		       structure FrontendSpecific = FrontendSML
		       structure FrontendCommon   = FrontendCommon
		       structure BackendCommon    = BackendCommon
		       structure BackendSpecific  = BackendMozart)

	structure RecursiveCompiler =
	    MkRecursiveCompiler(structure Composer = Composer
				structure Compiler = Compiler
				val extension = "ozf")

	(* Debugging functions *)

(*	val _ = Switches.Bootstrap.rttLevel := Switches.Bootstrap.FULL_RTT
*)

	structure ParsingPhase =
	    MkTracingPhase(
		  structure Phase    = MkParsingPhase(Switches)
		  structure Switches = Switches
		  val name = "Parsing"
	    )
	structure AbstractionPhase =
	    MkTracingPhase(
		  structure Phase    =
		      MkAbstractionPhase(val loadSign =
					     RecursiveCompiler.acquireSign
					 structure Switches = Switches)
		  structure Switches = Switches
		  val name = "Abstraction"
	    )
	structure AbstractionPhase =
	    MkResultDumpingPhase(
		  structure Phase    = AbstractionPhase
		  structure Switches = Switches
		  val header = "Abstract Syntax"
		  val pp     = PPAbstractGrammar.ppComp
		  val switch = Switches.Debug.dumpAbstractionResult
	    )
	structure ElaborationPhase =
	    MkTracingPhase(
		  structure Phase    =
		      MkElaborationPhase(val loadSign =
					     RecursiveCompiler.acquireSign)
		  structure Switches = Switches
		  val name = "Elaboration"
	    )
	structure ElaborationPhase =
	    MkResultDumpingPhase(
		  structure Phase    = ElaborationPhase
		  structure Switches = Switches
		  val header = "Component Signature"
		  val pp     = PPInf.ppSig o #sign o TypedGrammar.infoComp
		  val switch = Switches.Debug.dumpElaborationSig
	    )
	structure TranslationPhase =
	    MkTracingPhase(
		  structure Phase    = MkTranslationPhase(Switches)
		  structure Switches = Switches
		  val name = "Translation"
	    )
	structure TranslationPhase =
	    MkResultDumpingPhase(
		  structure Phase    = TranslationPhase
		  structure Switches = Switches
		  val header = "Intermediate Syntax"
		  val pp     = PPIntermediateGrammar.ppComp
		  val switch = Switches.Debug.dumpIntermediate
	    )
	structure BackendCommon = MkBackendCommon(Switches)

	fun processString process source =
	    RecursiveCompiler.processString process source
	    handle e as Crash.Crash message =>
		(TextIO.output (TextIO.stdErr, "CRASH: " ^ message ^ "\n");
		 raise e)

	fun processFile process source =
	    RecursiveCompiler.processFile process source
	    handle e as Crash.Crash message =>
		(TextIO.output (TextIO.stdErr, "CRASH: " ^ message ^ "\n");
		 raise e)

	fun parse' x     = ParsingPhase.translate () x
	fun abstract' x  = AbstractionPhase.translate (BindEnv.new()) x
	fun elab' x      = let val comp = ElaborationPhase.translate
					    (Env.new()) x
			       val i = TypedGrammar.infoComp comp
			   in  BindEnvFromSig.envFromSig(#region i,#sign i);
			       comp
			   end
	fun translate' x = TranslationPhase.translate () x
	fun flatten' x   = BackendCommon.translate (BackendCommon.C.new ()) x

	infix 3 oo
	fun (f oo g) (desc, x) = f (desc, g (desc, x))

	fun source (_, s) = Source.fromString s
	val parse         = parse' oo source
	val abstract      = abstract' oo parse
	val elab          = elab' oo abstract
	val translate     = translate' oo elab
	val flatten       = flatten' oo translate

	val parseString		= processString parse
	val parseFile		= processFile parse

	val abstractString	= processString abstract
	val abstractFile	= processFile abstract

	val elabString		= processString elab
	val elabFile		= processFile elab

	val translateString	= processString translate
	val translateFile	= processFile translate

	val flattenString	= processString flatten
	val flattenFile		= processFile flatten
    end
