(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2000-2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(*
 * This file implements value propagation (a variant on constant propagation
 * and constant folding).  For each program point, an approximation of the
 * environment that it will see at run-time is computed, and if possible,
 * the computations are simplified to take advantage of these minimal
 * assumptions.
 *
 * This analysis is - for now - not interprocedural.
 *)

(*
 * We need to implement our own maps because the ones provided by
 * the library are not fit for our purposes:  The iterators yield
 * all elements of the map, regardless of their scope and whether
 * they are shadowed; this would introduce a severe performance bug.
 *)

import   (*--**DEBUG*)
    structure TextIO
from "../../lib/system/TextIO"

import
    structure PrettyPrint
from "../../lib/utility/PrettyPrint"

import
    structure Assert
from "../../lib/utility/Assert"

import
    signature HASH_KEY
    structure FromEqHashKey
from "../../lib/utility/HASH_KEY-sig"

import
    signature IMP_MAP
from "../../lib/utility/IMP_MAP-sig"

import
    structure MkHashImpMap
from "../../lib/utility/MkHashImpMap"

import
    structure FromEqHashKey
from "../../lib/utility/HASH_KEY-sig"

import
    structure MkDepthFirstSearch
from "../../lib/utility/MkDepthFirstSearch"

import
    structure Label
from "../../lib/rtt/Label"

import
    structure Crash
from "../infrastructure/Crash"

import
    structure Source
from "../infrastructure/Source"

import
    structure Error
from "../infrastructure/Error"

import
    signature CONTEXT
from "../infrastructure/CONTEXT-sig"

import
    structure Stamp
from "../common/Stamp"

import
    structure StampSet
from "../common/StampSet"

import
    structure StampMap
from "../common/StampMap"

import
    structure Arity
from "Arity"

import
    structure FlatGrammar
from "FlatGrammar"

import
    structure OutputFlatGrammar
from "OutputFlatGrammar"

import
    structure PrimOps
from "PrimOps"

import
    signature VALUE_PROPAGATION_PHASE
from "VALUE_PROPAGATION_PHASE-sig"

signature SCOPED_IMP_MAP =
    sig
	type key
	type 'a map
	type 'a t = 'a map

	exception Lookup of key

	val new: unit -> 'a map
	val clone: 'a map -> 'a map
	val cloneTop: 'a map -> 'a map
	val insertScope: 'a map -> unit
	val deleteScope: 'a map -> unit
	val insert: 'a map * key * 'a -> unit
	val insertDeep: 'a map * key * key * 'a -> unit   (* Lookup *)
	val lookup: 'a map * key -> 'a option
	val lookupExistent: 'a map * key -> 'a            (* Lookup *)
	val appiScope: (key * 'a -> unit) -> 'a map -> unit
	val foldi: (key * 'a * 'b -> 'b) -> 'b -> 'a map -> 'b
    end

functor MkScopedImpMap(ImpMap: IMP_MAP) :>
    SCOPED_IMP_MAP where type key = ImpMap.key =
    struct
	type key = ImpMap.key
	type 'a map = 'a ImpMap.t list ref
	type 'a t = 'a map

	exception Lookup = ImpMap.Lookup

	fun new () = ref [ImpMap.new ()]

	fun clone (ref maps) = ref (List.map ImpMap.clone maps)

	fun cloneTop (ref maps) =
	    ref (ImpMap.clone (List.hd maps)::List.tl maps)

	fun insertScope r = r := ImpMap.new ()::(!r)
	fun deleteScope r = r := List.tl (!r)

	fun insert (ref maps, key, entry) =
	    ImpMap.insert (List.hd maps, key, entry)

	fun insertDeep (ref maps, key, newKey, entry) =
	    insertDeep' (maps, key, newKey, entry)
	and insertDeep' (map::rest, key, newKey, entry) =
	    if ImpMap.member (map, key) then ImpMap.insert (map, newKey, entry)
	    else insertDeep' (rest, key, newKey, entry)
	  | insertDeep' (nil, key, _, _) = raise Lookup key

	fun lookup (ref maps, key) = lookup' (maps, key)
	and lookup' (nil, _) = NONE
	  | lookup' ([map], key) = ImpMap.lookup (map, key)
	  | lookup' (map::rest, key) =
	    case ImpMap.lookup (map, key) of
		NONE => lookup' (rest, key)
	      | res as SOME _ => res

	fun lookupExistent (mapsRef, key) =
	    case lookup (mapsRef, key) of
		SOME entry => entry
	      | NONE => raise Lookup key

	fun appiScope f (ref maps) = ImpMap.appi f (List.hd maps)

	fun foldi f z (ref maps) = foldi' (maps, f, z)
	and foldi' (map::maps, f, z) =
	    foldi' (maps, f, ImpMap.foldi f z map)
	  | foldi' (nil, _, z) = z
    end

functor MkHashScopedImpMap(Key: HASH_KEY) =
    MkScopedImpMap(MkHashImpMap(Key))

structure ValuePropagationPhase :> VALUE_PROPAGATION_PHASE =
    struct
	structure I = FlatGrammar
	structure O = FlatGrammar

	open I

	fun idEq (Id (_, stamp1, _), Id (_, stamp2, _)) = stamp1 = stamp2

	fun isId (IdDef _) = true
	  | isId (Wildcard) = false

	fun idOf (IdDef id) = id
	  | idOf (Wildcard) = raise Crash.Crash "ValuePropagationPhase.idOf"

	fun conEq (Con (Id (_, stamp, _)), Con (Id (_, stamp', _))) =
	    stamp = stamp'
	  | conEq (StaticCon stamp, StaticCon stamp') = stamp = stamp'
	  | conEq (_, _) = false

	structure IdMap =
	    MkHashScopedImpMap(type t = id
			       val equals = idEq
			       fun hash (Id (_, stamp, _)) =
				   Stamp.hash stamp)

	(*
	 * The `value' data type represents the approximation of the value
	 * a given identifier will have at a given program point.  Only the
	 * values which can actually be used to simplify computations are
	 * stored.
	 *)

	datatype value =
	    LitVal of lit
	  | PrimVal of string
	  | VarVal of id
	  | TagVal of label * int
	  | ConVal of con
	  | ProdVal of idDef vector
	  | VecVal of idDef vector
	  | FunVal of stamp * idDef args * body
	  | TagAppVal of label * int * idDef args
	  | ConAppVal of con * idDef args
	  | RefAppVal of idDef
	  | CaughtExnVal of id
	  | UnknownVal
	  | FailedVal

	fun mapArgs f (OneArg x) = OneArg (f x)
	  | mapArgs f (TupArgs xs) = TupArgs (Vector.map f xs)
	  | mapArgs f (ProdArgs labelXVec) =
	    ProdArgs (Vector.map (fn (label, x) => (label, f x)) labelXVec)

	fun allArgs f (OneArg x) = f x
	  | allArgs f (TupArgs xs) = Vector.all f xs
	  | allArgs f (ProdArgs labelXVec) =
	    Vector.all (fn (_, x) => f x) labelXVec

	fun expToValue (LitExp (_, lit)) = LitVal lit
	  | expToValue (PrimExp (_, name)) = PrimVal name
	  | expToValue (NewExp _) = UnknownVal   (*--** ConVal? *)
	  | expToValue (VarExp (_, id)) = VarVal id
	  | expToValue (TagExp (_, label, n)) = TagVal (label, n)
	  | expToValue (ConExp (_, con)) = ConVal con
	  | expToValue (TupExp (_, ids)) = ProdVal (Vector.map IdDef ids)
	  | expToValue (ProdExp (_, labelIdVec)) =
	    ProdVal (Vector.map (fn (_, id) => IdDef id) labelIdVec)
	  | expToValue (VecExp (_, ids)) = VecVal (Vector.map IdDef ids)
	  | expToValue (FunExp (_, stamp, _, args, body)) =
	    FunVal (stamp, args, body)
	  | expToValue (PrimAppExp (_, _, _)) = UnknownVal
	  | expToValue (VarAppExp (_, _, _)) = UnknownVal
	  | expToValue (TagAppExp (_, label, n, args)) =
	    TagAppVal (label, n, mapArgs IdDef args)
	  | expToValue (ConAppExp (_, con, args)) =
	    ConAppVal (con, mapArgs IdDef args)
	  | expToValue (RefAppExp (_, id)) = RefAppVal (IdDef id)
	  | expToValue (SelAppExp (_, _, _, _, _)) = UnknownVal
	  | expToValue (LazySelAppExp (_, _, _, _, _)) = UnknownVal
	  | expToValue (FunAppExp (_, _, _, _)) = UnknownVal
	  | expToValue (FailExp _) = FailedVal

	(*
	 * For each identifier, we store in the environment whether it
	 * has been declared on the top level (i.e., outside any function)
	 * and what approximation we can give about its value.
	 *)

	type isToplevel = bool
	type env = (value * isToplevel) IdMap.t

	structure C: CONTEXT =
	    struct
		type t = env

		val new = IdMap.new
		val clone = IdMap.clone
	    end

	(*
	 * Value propagation performed on a given sequence of statements
	 * is only correct if we give it a value environment that we can
	 * minimally assume to hold at run-time at this program point.
	 * For control-flow junctions, this means we have to merge all
	 * incoming environments in order to build an environment of
	 * correct assumptions for the remainder of the control path.
	 *
	 * The control-flow junctions in our language are the SharedStm
	 * nodes.  In order to have the correct environment when performing
	 * value propagation on a SharedStm, therefore, we need to have
	 * analyzed all paths leading to this SharedStm.  In general this
	 * means that we have to build an abstract control-flow graph
	 * containing only the SharedStms as nodes and having edges from
	 * a node n to a node m iff there is a control-flow branch leading
	 * from n to m.  If then we analyze SharedStms in an order conforming
	 * to the topological ordering of the graph's nodes, the minimal
	 * environments (as defined above) are correctly computed.
	 *
	 * sortShared computes an appropriate ordering on the SharedStms.
	 *)

	datatype 'a sharedEntry =
	    UNIQUE
	  | SHARED
	  | VISITED of 'a

	local
	    fun node (edgeMap, stamp) =
		StampMap.insertDisjoint (edgeMap, stamp, nil)

	    fun edge (edgeMap, pred, succ) =
		let
		    val stamps = StampMap.lookupExistent (edgeMap, pred)
		in
		    StampMap.insert (edgeMap, pred, succ::stamps)
		end

	    fun sortStm (ValDec (_, _, _), _, _, _, _) = ()
	      | sortStm (RefAppDec (_, _, _), _, _, _, _) = ()
	      | sortStm (TupDec (_, _, _), _, _, _, _) = ()
	      | sortStm (ProdDec (_, _, _), _, _, _, _) = ()
	      | sortStm (RaiseStm (_, _), _, _, _, _) = ()
	      | sortStm (ReraiseStm (_, _), _, _, _, _) = ()
	      | sortStm (TryStm (_, tryBody, _, _, handleBody),
			 pred, edgeMap, shared, path) =
		(sortBody (tryBody, pred, edgeMap, shared, path);
		 sortBody (handleBody, pred, edgeMap, shared, path))
	      | sortStm (EndTryStm (_, body), pred, edgeMap, shared, path) =
		sortBody (body, pred, edgeMap, shared, path)
	      | sortStm (EndHandleStm (_, body), pred, edgeMap, shared, path) =
		sortBody (body, pred, edgeMap, shared, path)
	      | sortStm (TestStm (_, _, tests, body),
			 pred, edgeMap, shared, path) =
		(sortTests (tests, pred, edgeMap, shared, path);
		 sortBody (body, pred, edgeMap, shared, path))
	      | sortStm (SharedStm (_, body, stamp),
			 pred, edgeMap, shared, path) =
		(StampMap.insert (shared, stamp,
				  if StampMap.member (shared, stamp)
				  then SHARED else UNIQUE);
		 edge (edgeMap, pred, stamp);
		 sortSharedBody (body, stamp, edgeMap, shared, path))
	      | sortStm (ReturnStm (_, _), _, _, _, _) = ()
	      | sortStm (IndirectStm (_, ref bodyOpt),
			 pred, edgeMap, shared, path) =
		sortBody (valOf bodyOpt, pred, edgeMap, shared, path)
	      | sortStm (ExportStm (_, _), _, _, _, _) = ()
	    and sortTests (LitTests litBodyVec, pred, edgeMap, shared, path) =
		Vector.app (fn (_, body) =>
			    sortBody (body, pred, edgeMap, shared, path))
		litBodyVec
	      | sortTests (TagTests tagBodyVec, pred, edgeMap, shared, path) =
		Vector.app (fn (_, _, _, body) =>
			    sortBody (body, pred, edgeMap, shared, path))
		tagBodyVec
	      | sortTests (ConTests conBodyVec, pred, edgeMap, shared, path) =
		Vector.app (fn (_, _, body) =>
			    sortBody (body, pred, edgeMap, shared, path))
		conBodyVec
	      | sortTests (VecTests vecBodyVec, pred, edgeMap, shared, path) =
		Vector.app (fn (_, body) =>
			    sortBody (body, pred, edgeMap, shared, path))
		vecBodyVec
	    and sortBody (stm::stms, pred, edgeMap, shared, path) =
		(sortStm (stm, pred, edgeMap, shared, path);
		 sortBody (stms, pred, edgeMap, shared, path))
	      | sortBody (nil, _, _, _, _) = ()
	    and sortSharedBody (body, stamp, edgeMap, shared, path) =
		if StampMap.member (edgeMap, stamp) then ()
		else
		    (node (edgeMap, stamp);
		     StampSet.insertDisjoint (path, stamp);
		     sortBody (body, stamp, edgeMap, shared, path);
		     StampSet.deleteExistent (path, stamp))

	    structure DepthFirstSearch =
		MkDepthFirstSearch(structure Key = FromEqHashKey(Stamp)
				   structure Map = StampMap)
	in
	    fun sortShared (body, stamp) =
		let
		    val edgeMap = StampMap.new ()
		    val shared = StampMap.new ()
		    val path = StampSet.new ()
		in
		    sortSharedBody (body, stamp, edgeMap, shared, path);
		    (DepthFirstSearch.search edgeMap, shared)
		end
	end

	(*
	 * All lazy selections are hoisted to just after the declaration
	 * of the variable being selected.  This is performed by a
	 * post-processing patching step.
	 *)

	fun prodToLabels (Tuple n) =
	    Vector.tabulate (n, fn i => Label.fromInt (i + 1))
	  | prodToLabels (Product labels) = labels

	fun stm_info region = {region = region, liveness = ref Unknown}

	fun patchIdDef (Wildcard, _) = nil
	  | patchIdDef (IdDef id, lazySels) =
	    case IdMap.lookup (lazySels, id) of
		SOME (prod, idDefs) =>
		     Vector.foldri
		     (fn (n, label, rest) =>
		      case Array.sub (idDefs, n) of
			  idDef as IdDef _ =>
			      ValDec (stm_info Source.nowhere, idDef,
				      LazySelAppExp ({region = Source.nowhere},
						     prod, label, n, id))::
			      patchIdDef (idDef, lazySels) @ rest
			| Wildcard => rest)
		     nil (prodToLabels prod, 0, NONE)
	      | NONE => nil

	fun patchIdDefs (idDefs, lazySels) =
	    Vector.foldr (fn (idDef, rest) =>
			  patchIdDef (idDef, lazySels) @ rest) nil idDefs

	fun patchArgs (OneArg idDef, lazySels) =
	    patchIdDef (idDef, lazySels)
	  | patchArgs (TupArgs idDefs, lazySels) =
	    patchIdDefs (idDefs, lazySels)
	  | patchArgs (ProdArgs labelIdDefVec, lazySels) =
	    Vector.foldr (fn ((_, idDef), rest) =>
			  patchIdDef (idDef, lazySels) @ rest) nil
	    labelIdDefVec

	fun patchConArgs (NONE, _) = nil
	  | patchConArgs (SOME args, lazySels) = patchArgs (args, lazySels)

	fun patchBody ((stm as ValDec (_, idDef, _))::stms,
		       lazySels, shared) =
	    stm::patchIdDef (idDef, lazySels) @
	    patchBody (stms, lazySels, shared)
	  | patchBody ((stm as RefAppDec (_, idDef, _))::stms,
		       lazySels, shared) =
	    stm::patchIdDef (idDef, lazySels) @
	    patchBody (stms, lazySels, shared)
	  | patchBody ((stm as TupDec (_, idDefs, _))::stms,
		       lazySels, shared) =
	    stm::patchIdDefs (idDefs, lazySels) @
	    patchBody (stms, lazySels, shared)
	  | patchBody ((stm as ProdDec (_, labelIdDefVec, _))::stms,
		       lazySels, shared) =
	    stm::patchIdDefs (Vector.map #2 labelIdDefVec, lazySels) @
	    patchBody (stms, lazySels, shared)
	  | patchBody ([TryStm (info, tryBody, idDef1, idDef2, handleBody)],
		       lazySels, shared) =
	    [TryStm (info, patchBody (tryBody, lazySels, shared),
		     idDef1, idDef2,
		     patchIdDef (idDef1, lazySels) @
		     patchIdDef (idDef2, lazySels) @
		     patchBody (handleBody, lazySels, shared))]
	  | patchBody ([EndTryStm (info, body)], lazySels, shared) =
	    [EndTryStm (info, patchBody (body, lazySels, shared))]
	  | patchBody ([EndHandleStm (info, body)], lazySels, shared) =
	    [EndHandleStm (info, patchBody (body, lazySels, shared))]
	  | patchBody ([TestStm (info, id, tests, body)], lazySels, shared) =
	    [TestStm (info, id, patchTests (tests, lazySels, shared),
		      patchBody (body, lazySels, shared))]
	  | patchBody ([SharedStm (info, body, stamp)], lazySels, shared) =
	    (case StampMap.lookup (shared, stamp) of
		 SOME body => body
	       | NONE =>
		     let
			 val body = patchBody (body, lazySels, shared)
			 val body' = [SharedStm (info, body, stamp)]
		     in
			 StampMap.insert (shared, stamp, body');
			 body'
		     end)
	  | patchBody ([IndirectStm (_, ref (SOME body))], lazySels, shared) =
	    patchBody (body, lazySels, shared)
	  | patchBody (body as [(RaiseStm (_, _) | ReraiseStm (_, _) |
				 ReturnStm (_, _) | ExportStm (_, _))], _, _) =
	    body
	  | patchBody (_, _, _) =
	    raise Crash.Crash "ValuePropagationPhase.patchBody"
	and patchTests (LitTests tests, lazySels, shared) =
	    LitTests (Vector.map (fn (lit, body) =>
				  (lit, patchBody (body, lazySels, shared)))
		      tests)
	  | patchTests (TagTests tests, lazySels, shared) =
	    TagTests (Vector.map (fn (label, n, conArgs, body) =>
				  (label, n, conArgs,
				   patchConArgs (conArgs, lazySels) @
				   patchBody (body, lazySels, shared))) tests)
	  | patchTests (ConTests tests, lazySels, shared) =
	    ConTests (Vector.map (fn (con, conArgs, body) =>
				  (con, conArgs,
				   patchConArgs (conArgs, lazySels) @
				   patchBody (body, lazySels, shared))) tests)
	  | patchTests (VecTests tests, lazySels, shared) =
	    VecTests (Vector.map (fn (idDefs, body) =>
				  (idDefs,
				   patchIdDefs (idDefs, lazySels) @
				   patchBody (body, lazySels, shared))) tests)

	(*
	 * As outlined above, we need to compute the value environments we
	 * can minimally assume to hold at every given program point.  For
	 * control-flow junctions, this means that we have to combine the
	 * environments from all branches.
	 *
	 * `unionEnv' takes two environments and returns the combined minimal
	 * environment.  It is reflexive and associative, so an arbitrary
	 * number of environments can be combined using `unionEnv.'
	 *)

	fun idDefEq (IdDef (Id (_, stamp, _)), IdDef (Id (_, stamp', _))) =
	    stamp = stamp'
	  | idDefEq (Wildcard, Wildcard) = true
	  | idDefEq (_, _) = false

	fun argsMin (args as OneArg idDef, OneArg idDef') =
	    if idDefEq (idDef, idDef') then args else OneArg Wildcard
	  | argsMin (TupArgs idDefs, TupArgs idDefs') =
	    TupArgs (VectorPair.map (fn (idDef, idDef') =>
				     if idDefEq (idDef, idDef') then idDef
				     else Wildcard) (idDefs, idDefs'))
	  | argsMin (ProdArgs labelIdDefVec, ProdArgs labelIdDefVec') =
	    ProdArgs (VectorPair.map (fn ((label, idDef), (_, idDef')) =>
				      (label,
				       if idDefEq (idDef, idDef') then idDef
				       else Wildcard))
		      (labelIdDefVec, labelIdDefVec'))
	  | argsMin (_, _) = raise Crash.Crash "ValuePropagationPhase.argsMin"

	fun valueMin (value as LitVal lit, LitVal lit') =
	    if litEq (lit, lit') then value else UnknownVal
	  | valueMin (value as PrimVal name, PrimVal name') =
	    if name = name' then value else UnknownVal
	  | valueMin (value as VarVal (Id (_, stamp, _)),
		      VarVal (Id (_, stamp', _))) =
	    if stamp = stamp' then value else UnknownVal
	  | valueMin (value as TagVal (_, n), TagVal (_, n')) =
	    if n = n' then value else UnknownVal
	  | valueMin (value as ConVal con, ConVal con') =
	    if conEq (con, con') then value else UnknownVal
	  | valueMin (ProdVal idDefs, ProdVal idDefs') =
	    ProdVal (VectorPair.map (fn (idDef, idDef') =>
				     if idDefEq (idDef, idDef')
				     then idDef else Wildcard)
		     (idDefs, idDefs'))
	  | valueMin (VecVal idDefs, VecVal idDefs') =
	    if Vector.length idDefs = Vector.length idDefs' then
		VecVal (VectorPair.map (fn (idDef, idDef') =>
					if idDefEq (idDef, idDef') then idDef
					else Wildcard) (idDefs, idDefs'))
	    else UnknownVal
	  | valueMin (value as FunVal (stamp, _, _), FunVal (stamp', _, _)) =
	    if stamp = stamp' then value else UnknownVal
	  | valueMin (TagAppVal (label, n, args),
		      TagAppVal (label', _, args')) =
	    if label = label' then TagAppVal (label, n, argsMin (args, args'))
	    else UnknownVal
	  | valueMin (value as RefAppVal idDef, RefAppVal idDef') =
	    if idDefEq (idDef, idDef') then value else UnknownVal
	  | valueMin (value as CaughtExnVal id, CaughtExnVal id') =
	    if idEq (id, id') then value else UnknownVal
	  | valueMin (_, _) = UnknownVal

	fun unionEnv (env', env) =
	    IdMap.appiScope
	    (fn (id, entry as (value, isToplevel)) =>
	     case IdMap.lookup (env', id) of
		 SOME (value', isToplevel') =>
		     let
			 val entry' = (valueMin (value, value'), isToplevel)
		     in
			 Assert.assert (isToplevel = isToplevel');
			 IdMap.insert (env', id, entry')
		     end
	       | NONE => IdMap.insert (env', id, entry)) env

	(* Various Helper Functions *)

	fun getTerm (info, id, env) =
	    case IdMap.lookupExistent (env, id) of
		(LitVal lit, _) => LitExp (info, lit)
	      | (PrimVal name, _) => PrimExp (info, name)
	      | (VarVal id', _) => getTerm (info, id', env)
	      | (TagVal (label, n), _) => TagExp (info, label, n)
	      | (ConVal con, _) => ConExp (info, con)
	      | (_, _) => VarExp (info, id)

	fun deref (id, env) =
	    case IdMap.lookupExistent (env, id) of
		(VarVal id', _) => id'
	      | (_, _) => id

	fun derefArgs (OneArg id, env) = OneArg (deref (id, env))
	  | derefArgs (TupArgs ids, env) =
	    TupArgs (Vector.map (fn id => deref (id, env)) ids)
	  | derefArgs (ProdArgs labelIdVec, env) =
	    ProdArgs (Vector.map (fn (label, id) => (label, deref (id, env)))
		      labelIdVec)

	fun argsToIds (OneArg id) = #[id]
	  | argsToIds (TupArgs ids) = ids
	  | argsToIds (ProdArgs labelIdVec) = Vector.map #2 labelIdVec

	fun doSel (n, id, env) =
	    case IdMap.lookupExistent (env, id) of
		(ProdVal idDefs, _) =>
		    (case Vector.sub (idDefs, n) of
			 IdDef id => SOME id
		       | Wildcard => NONE)
	      | (_, _) => NONE

	fun doLazySel (id, idDefs, n, env, isToplevel) =
	    case Array.sub (idDefs, n) of
		Wildcard =>
		    let
			val newId = freshId {region = Source.nowhere}
		    in
			IdMap.insertDeep (env, id, newId,
					  (UnknownVal, isToplevel));
			Array.update (idDefs, n, IdDef newId); newId
		    end
	      | IdDef id => id

	(* Calling Convention Conversion *)

	fun getIds (id, env) =
	    case IdMap.lookupExistent (env, id) of
		(ProdVal idDefs, _) =>
		    if Vector.all isId idDefs then
			SOME (Vector.map idOf idDefs)
		    else NONE
	      | (_, _) => NONE

	fun argsToArity (OneArg _) = Arity.Unary
	  | argsToArity (TupArgs ids) = Arity.Tuple (Vector.length ids)
	  | argsToArity (ProdArgs labelIdVec) =
	    Arity.Product (Vector.map #1 labelIdVec)

	fun adaptArity (_, Arity.Unary, args as OneArg _, _, f) = (nil, f args)
	  | adaptArity (info, Arity.Unary, TupArgs ids, _, f) =
	    (* construct tuple *)
	    let
		val id = freshId info
	    in
		([ValDec (stm_info (#region info), IdDef id,
			  TupExp (info, ids))], f (OneArg id))
	    end
	  | adaptArity (info, Arity.Unary, ProdArgs labelIdVec, _, f) =
	    (* construct product *)
	    let
		val id = freshId info
	    in
		([ValDec (stm_info (#region info), IdDef id,
			  ProdExp (info, labelIdVec))], f (OneArg id))
	    end
	  | adaptArity (info, Arity.Tuple n, OneArg id, env, f) =
	    (* deconstruct tuple (try statically) *)
	    (case getIds (id, env) of
		 SOME ids => (nil, f (TupArgs ids))
	       | NONE =>
		     let
			 val ids = Vector.tabulate (n, fn _ => freshId info)
			 val idDefs = Vector.map IdDef ids
		     in
			 ([TupDec (stm_info (#region info), idDefs, id)],
			  f (TupArgs ids))
		     end)
	  | adaptArity (_, Arity.Tuple _, args as TupArgs _, _, f) =
	    (nil, f args)
	  | adaptArity (info, Arity.Product labels, OneArg id, env, f) =
	    (* deconstruct product (try statically) *)
	    (case getIds (id, env) of
		 SOME ids => (nil, f (ProdArgs (VectorPair.zip (labels, ids))))
	       | NONE =>
		     let
			 val labelIdVec =
			     Vector.map (fn label => (label, freshId info))
			     labels
			 val labelIdDefVec =
			     Vector.map (fn (label, id) => (label, IdDef id))
			     labelIdVec
		     in
			 ([ProdDec (stm_info (#region info),
				    labelIdDefVec, id)],
			  f (ProdArgs labelIdVec))
		     end)
	  | adaptArity (_, Arity.Product _, args as ProdArgs _, _, f) =
	    (nil, f args)
	  | adaptArity (_, _, _, _, _) =
	    raise Crash.Crash "ValuePropagationPhase.adaptArity"

	(* Applications of Primitives *)

	fun isSimple (LitExp (_, _), _) = true
	  | isSimple (PrimExp (_, _), _) = true
	  | isSimple (NewExp _, _) = true
	  | isSimple (VarExp (_, id), env) = isSome (IdMap.lookup (env, id))
	  | isSimple (TagExp (_, _, _), _) = true
	  | isSimple (ConExp (_, _), _) = true
	  | isSimple (TupExp (_, ids), env) =
	    Vector.all (fn id => isSome (IdMap.lookup (env, id))) ids
	  | isSimple (ProdExp (_, labelIdVec), env) =
	    Vector.all (fn (_, id) => isSome (IdMap.lookup (env, id)))
	    labelIdVec
	  | isSimple (VecExp (_, ids), env) =
	    Vector.all (fn id => isSome (IdMap.lookup (env, id))) ids
	  | isSimple (TagAppExp (_, _, _, args), env) =
	    allArgs (fn id => isSome (IdMap.lookup (env, id))) args
	  | isSimple (RefAppExp (_, id), env) = isSome (IdMap.lookup (env, id))
	  | isSimple (_, _) = false

	fun vpPrimApp (info, "Future.byneed", ids as #[id], env) =
	    (case IdMap.lookupExistent (env, id) of
		 (FunVal (_, _, [ReturnStm (_, exp)]), _) =>
		     if isSimple (exp, env) then exp
		     else PrimAppExp (info, "Future.byneed", ids)
	       | (_, _) => PrimAppExp (info, "Future.byneed", ids))
	  | vpPrimApp (info, name, ids, _) =
	    (*--** assertion about arity; evaluate application partially? *)
	    PrimAppExp (info, name, ids)

	(* Environment Handling *)

	fun alias (IdDef id, IdDef id', env, isToplevel) =
	    IdMap.insert (env, id, (VarVal id', isToplevel))
	  | alias (_, _, _, _) = ()

	fun aliasArgs (OneArg idDef, OneArg idDef', env, isToplevel) =
	    alias (idDef, idDef', env, isToplevel)
	  | aliasArgs (TupArgs idDefs, TupArgs idDefs', env, isToplevel) =
	    VectorPair.app (fn (idDef, idDef') =>
			    alias (idDef, idDef', env, isToplevel))
	    (idDefs, idDefs')
	  | aliasArgs (ProdArgs labelIdDefVec, ProdArgs labelIdDefVec',
		       env, isToplevel) =
	    VectorPair.app (fn ((_, idDef), (_, idDef')) =>
			    alias (idDef, idDef', env, isToplevel))
	    (labelIdDefVec, labelIdDefVec')
	  | aliasArgs (_, _, _, _) =
	    raise Crash.Crash "ValuePropagationPhase.aliasArgs"

	fun declare (env, IdDef id, entry) = IdMap.insert (env, id, entry)
	  | declare (_, Wildcard, _) = ()

	fun declareUnknown (env, idDef, isToplevel) =
	    declare (env, idDef, (UnknownVal, isToplevel))

	fun declareArgs (env, OneArg idDef, isToplevel) =
	    declareUnknown (env, idDef, isToplevel)
	  | declareArgs (env, TupArgs idDefs, isToplevel) =
	    Vector.app (fn idDef =>
			declareUnknown (env, idDef, isToplevel)) idDefs
	  | declareArgs (env, ProdArgs labelIdDefVec, isToplevel) =
	    Vector.app (fn (_, idDef) =>
			declareUnknown (env, idDef, isToplevel)) labelIdDefVec

	fun declareConArgs (_, NONE, _) = ()
	  | declareConArgs (env, SOME args, isToplevel) =
	    declareArgs (env, args, isToplevel)

	(* The Main Recursion over the Syntax Tree *)

	fun testsAppend (NONE, testsOpt) = testsOpt
	  | testsAppend (testsOpt, NONE) = testsOpt
	  | testsAppend (SOME (LitTests xs), SOME (LitTests ys)) =
	    SOME (LitTests (Vector.append (xs, ys)))
	  | testsAppend (SOME (TagTests xs), SOME (TagTests ys)) =
	    SOME (TagTests (Vector.append (xs, ys)))
	  | testsAppend (SOME (ConTests xs), SOME (ConTests ys)) =
	    SOME (ConTests (Vector.append (xs, ys)))
	  | testsAppend (SOME (VecTests xs), SOME (VecTests ys)) =
	    SOME (VecTests (Vector.append (xs, ys)))
	  | testsAppend (SOME _, SOME _) =
	    raise Crash.Crash "ValuePropagationPhase.testsAppend"

	fun testsNull (SOME (LitTests xs)) = Vector.length xs = 0
	  | testsNull (SOME (TagTests xs)) = Vector.length xs = 0
	  | testsNull (SOME (ConTests xs)) = Vector.length xs = 0
	  | testsNull (SOME (VecTests xs)) = Vector.length xs = 0
	  | testsNull NONE = true

	fun vpBody (ValDec (info, idDef, exp)::stms,
		    state as {env, isToplevel, lazySels, ...}) =
	    let
		val (stms', exp) = vpExp (exp, env, isToplevel, lazySels)
	    in
		declare (env, idDef, (expToValue exp, isToplevel));
		stms' @ ValDec (info, idDef, exp)::vpBody (stms, state)
	    end
	  | vpBody (RefAppDec (info, idDef, id)::stms,
		    state as {env, isToplevel, ...}) =
	    let
		val id = deref (id, env)
	    in
		IdMap.insert (env, id, (RefAppVal idDef, isToplevel));
		declareUnknown (env, idDef, isToplevel);
		RefAppDec (info, idDef, id)::vpBody (stms, state)
	    end
	  | vpBody (TupDec (info, idDefs, id)::stms,
		    state as {env, isToplevel, ...}) =
	    let
		val id = deref (id, env)
		val idDefs =
		    case IdMap.lookupExistent (env, id) of
			(ProdVal idDefs', isToplevel') =>
			    VectorPair.map
			    (fn (idDef, idDef') =>
			     case (idDef, idDef') of
				 (IdDef id, IdDef id') =>
				     (IdMap.insert (env, id,
						    (VarVal id', isToplevel'));
				      Wildcard)
			       | (_, _) => idDef) (idDefs, idDefs')
		      | (_, _) => idDefs
	    in
		Vector.app (fn idDef =>
			    declareUnknown (env, idDef, isToplevel)) idDefs;
		IdMap.insert (env, id, (ProdVal idDefs, isToplevel));
		TupDec (info, idDefs, id)::vpBody (stms, state)
	    end
	  | vpBody (ProdDec (info, labelIdDefVec, id)::stms,
		    state as {env, isToplevel, ...}) =
	    let
		val id = deref (id, env)
		val labelIdDefVec =
		    case IdMap.lookupExistent (env, id) of
			(ProdVal idDefs, isToplevel') =>
			    VectorPair.map
			    (fn ((label, idDef), idDef') =>
			     case (idDef, idDef') of
				 (IdDef id, IdDef id') =>
				     (IdMap.insert (env, id,
						    (VarVal id', isToplevel'));
				      (label, Wildcard))
			       | (_, _) => (label, idDef'))
			    (labelIdDefVec, idDefs)
		      | (_, _) => labelIdDefVec
		val idDefs = Vector.map #2 labelIdDefVec
	    in
		Vector.app (fn idDef =>
			    declareUnknown (env, idDef, isToplevel)) idDefs;
		IdMap.insert (env, id, (ProdVal idDefs, isToplevel));
		ProdDec (info, labelIdDefVec, id)::vpBody (stms, state)
	    end
	  | vpBody ([stm as RaiseStm (info, id)], {env, ...}) =
	    let
		val id = deref (id, env)
	    in
		[case IdMap.lookupExistent (env, id) of
		     (CaughtExnVal id', _) => ReraiseStm (info, id')
		   | _ => RaiseStm (info, id)]
	    end
	  | vpBody ([stm as ReraiseStm (info, id)], {env, ...}) =
	    [ReraiseStm (info, deref (id, env))]
	  | vpBody ([TryStm (info, tryBody, idDef1, idDef2, handleBody)],
		    state as {env, isToplevel, ...}) =
	    let
		val tryBody = vpBodyScope (tryBody, state)
		val _ =
		    declare (env, idDef2,
			     (case idDef1 of
				  IdDef id => CaughtExnVal id
				| _ => UnknownVal, isToplevel))
		val handleBody = vpBodyScope (handleBody, state)
	    in
		[TryStm (info, tryBody, idDef1, idDef2, handleBody)]
	    end
	  | vpBody ([EndTryStm (info, body)], state) =
	    [EndTryStm (info, vpBodyScope (body, state))]
	  | vpBody ([EndHandleStm (info, body)], state) =
	    [EndHandleStm (info, vpBodyScope (body, state))]
	  | vpBody ([stm as TestStm (info, id, _, _)], state as {env, ...}) =
	    let
		val id = deref (id, env)
		val (testsOpt, elseBody) = vpTestStm ([stm], id, state)
	    in
		if testsNull testsOpt then elseBody
		else [TestStm (info, id, valOf testsOpt, elseBody)]
	    end
	  | vpBody ([SharedStm (info, body, stamp)],
		    state as {env, shared, ...}) =
	    (* We need to return a SharedStm with an IndirectStm in it;
	     * the IndirectStm's reference will be updated destructively
	     * later when analyses proceeds (topological ordering). *)
	    (case StampMap.lookupExistent (shared, stamp) of
		 UNIQUE => vpBody (body, state)
	       | SHARED =>
		     let
			 val bodyOptRef = ref (SOME body)
			 val entry =
			     VISITED (bodyOptRef, IdMap.cloneTop env)
			 val info' = {region = #region info,
				      liveness = ref Unknown}
		     in
			 StampMap.insert (shared, stamp, entry);
			 [SharedStm (info, [IndirectStm (info', bodyOptRef)],
				     stamp)]
		     end
	       | VISITED (bodyOptRef, env') =>
		     let
			 val _ = unionEnv (env', env)
			 val info' = {region = #region info,
				      liveness = ref Unknown}
		     in
			 [SharedStm (info, [IndirectStm (info', bodyOptRef)],
				     stamp)]
		     end)
	  | vpBody ([ReturnStm (info, exp)],
		    {env, isToplevel, lazySels, ...}) =
	    let
		val (stms, exp) = vpExp (exp, env, isToplevel, lazySels)
	    in
		stms @ [ReturnStm (info, exp)]
	    end
	  | vpBody ([IndirectStm (info, ref bodyOpt)], state) =
	    vpBody (valOf bodyOpt, state)
	  | vpBody ([ExportStm (info, exp)],
		    {env, isToplevel = true,
		     export = SOME (env', exportDesc), lazySels, ...}) =
	    (*--** do multiple occurrences of ExportStm work by accident? *)
	    let
		val _ =
		    Vector.app (fn (_, id) =>
				declareUnknown (env', IdDef id, true))
		    exportDesc
		val (stms, exp) = vpExp (exp, env, true, lazySels)
	    in
		stms @ [ExportStm (info, exp)]
	    end
	  | vpBody (_, _) =
	    raise Crash.Crash "ValuePropagationPhase.vpBody"
	and vpTestStm (topBody as [TestStm (_, id, tests, elseBody)],
		       id', state as {env, ...}) =
	    let
		val id = deref (id, env)
	    in
		if idEq (id, id') then
		    let
			val (testsOpt, elseBody) =
			    vpTestStm (elseBody, id', state)
			val (testsOpt', elseBody) =
			    vpTests (id, tests, elseBody, state)
		    in
			(testsAppend (testsOpt', testsOpt), elseBody)
		    end
		else (NONE, vpBodyScope (topBody, state))
	    end
	  | vpTestStm (body as [SharedStm (_, body', stamp)],
		       id, state as {shared, ...}) =
	    (case StampMap.lookupExistent (shared, stamp) of
		 UNIQUE => vpTestStm (body', id, state)
	       | _ => (NONE, vpBodyScope (body, state)))
	  | vpTestStm ([IndirectStm (_, ref bodyOpt)], id, state) =
	    vpTestStm (valOf bodyOpt, id, state)
	  | vpTestStm (body, _, state) = (NONE, vpBodyScope (body, state))
	and vpTests (id, LitTests litBodyVec, elseBody,
		     {env, isToplevel, shared, export, lazySels}) =
	    let
		val (litBodyList, elseBody) =
		    Vector.foldr
		    (fn ((lit, body), (litBodyList, elseBody)) =>
		     let
			 val env = IdMap.cloneTop env
			 val state = {env = env, isToplevel = isToplevel,
				      shared = shared, export = export,
				      lazySels = lazySels}
			 val entry = IdMap.lookupExistent (env, id)
			 val entry' = (LitVal lit, isToplevel)
			 val _ = IdMap.insert (env, id, entry')
			 val body = vpBody (body, state)
		     in
			 case entry of
			     (LitVal lit', _) =>
				 if litEq (lit, lit') then (nil, body)
				 else (nil, elseBody)
			   | _ => ((lit, body)::litBodyList, elseBody)
		     end) (nil, elseBody) litBodyVec
	    in
		(case litBodyList of
		     nil => NONE
		   | _::_ => SOME (LitTests (Vector.fromList litBodyList)),
		 elseBody)
	    end
	  | vpTests (id, TagTests tagBodyVec, elseBody,
		     {env, isToplevel, shared, export, lazySels}) =
	    let
		val (tagBodyList, elseBody) =
		    Vector.foldr
		    (fn ((label, n, conArgs, body), (tagBodyList, elseBody)) =>
		     let
			 val env = IdMap.cloneTop env
			 val state = {env = env, isToplevel = isToplevel,
				      shared = shared, export = export,
				      lazySels = lazySels}
			 val entry = IdMap.lookupExistent (env, id)
			 val entry' =
			     (case conArgs of
				  NONE => TagVal (label, n)
				| SOME args => TagAppVal (label, n, args),
			      isToplevel)
			 val _ = IdMap.insert (env, id, entry')
			 val _ = declareConArgs (env, conArgs, isToplevel)
		     in
			 case (conArgs, entry) of
			     (NONE, (TagVal (_, n'), _)) =>
				 if n = n' then
				     (nil, vpBody (body, state))
				 else (nil, elseBody)
			   | (SOME args, (TagAppVal (_, n', args'), _)) =>
				 if n = n' then
				     (aliasArgs (args, args', env, isToplevel);
				      (nil, vpBody (body, state)))
				 else (nil, elseBody)
			   | (_, _) =>
				 ((label, n, conArgs, vpBody (body, state))::
				  tagBodyList, elseBody)
		     end) (nil, elseBody) tagBodyVec
	    in
		(case tagBodyList of
		     nil => NONE
		   | _::_ => SOME (TagTests (Vector.fromList tagBodyList)),
		 elseBody)
	    end
	  | vpTests (id, ConTests conBodyVec, elseBody,
		     {env, isToplevel, shared, export, lazySels}) =
	    let
		val (conBodyList, elseBody) =
		    Vector.foldr
		    (fn ((con, conArgs, body), (conBodyList, elseBody)) =>
		     let
			 val con =
			     case con of
				 Con id =>
				     (case IdMap.lookupExistent (env, id) of
					  (ConVal (con as StaticCon _), _) =>
					      con
					| (_, _) => Con (deref (id, env)))
			       | StaticCon _ => con
			 val env = IdMap.cloneTop env
			 val state = {env = env, isToplevel = isToplevel,
				      shared = shared, export = export,
				      lazySels = lazySels}
			 val entry = IdMap.lookupExistent (env, id)
			 val entry' =
			     (case conArgs of
				  NONE => ConVal con
				| SOME args => ConAppVal (con, args),
			      isToplevel)
			 val _ = IdMap.insert (env, id, entry')
			 val _ = declareConArgs (env, conArgs, isToplevel)
		     in
			 case (conArgs, entry) of
			     (NONE, (ConVal con', _)) =>
				 if conEq (con, con') then
				     (nil, vpBody (body, state))
				 else (nil, elseBody)
			   | (SOME args, (ConAppVal (con', args'), _)) =>
				 if conEq (con, con') then
				     (aliasArgs (args, args', env, isToplevel);
				      (nil, vpBody (body, state)))
				 else (nil, elseBody)
			   | (_, _) =>
				 ((con, conArgs, vpBody (body, state))::
				  conBodyList, elseBody)
		     end) (nil, elseBody) conBodyVec
	    in
		(case conBodyList of
		     nil => NONE
		   | _::_ => SOME (ConTests (Vector.fromList conBodyList)),
		 elseBody)
	    end
	  | vpTests (id, VecTests vecBodyVec, elseBody,
		     {env, isToplevel, shared, export, lazySels}) =
	    let
		val (vecBodyList, elseBody) =
		    Vector.foldr
		    (fn ((idDefs, body), (vecBodyList, elseBody)) =>
		     let
			 val env = IdMap.cloneTop env
			 val state = {env = env, isToplevel = isToplevel,
				      shared = shared, export = export,
				      lazySels = lazySels}
			 val entry = IdMap.lookupExistent (env, id)
			 val entry' = (VecVal idDefs, isToplevel)
			 val _ = IdMap.insert (env, id, entry')
			 val _ = declareArgs (env, TupArgs idDefs, isToplevel)
		     in
			 case entry of
			     (VecVal idDefs', _) =>
				 if Vector.length idDefs =
				    Vector.length idDefs'
				 then (nil, vpBody (body, state))
				 else (nil, elseBody)
			   | (_, _) =>
				 ((idDefs, vpBody (body, state))::vecBodyList,
				  elseBody)
		     end) (nil, elseBody) vecBodyVec
	    in
		(case vecBodyList of
		     nil => NONE
		   | _::_ => SOME (VecTests (Vector.fromList vecBodyList)),
		 elseBody)
	    end
	and vpExp (exp as LitExp (_, _), _, _, _) = (nil, exp)
	  | vpExp (exp as PrimExp (info, name), _, _, _) =
	    (PrimOps.getArity name
	     handle PrimOps.UnknownPrim =>
		 Error.error (#region info, "unknown primitive " ^ name);
	     (nil, exp))
	  | vpExp (exp as NewExp _, _, _, _) = (nil, exp)
	    (*--** generate StaticCon if on toplevel *)
	  | vpExp (VarExp (info, id), env, _, _) =
	    (nil, getTerm (info, id, env))
	  | vpExp (exp as TagExp (_, _, _), _, _, _) = (nil, exp)
	  | vpExp (ConExp (info, con as Con id), env, _, _) =
	    let
		val id = deref (id, env)
	    in
		case IdMap.lookupExistent (env, id) of
		    (ConVal (con as StaticCon _), _) =>
			(nil, ConExp (info, con))
		  | (_, _) => (nil, ConExp (info, Con id))
	    end
	  | vpExp (exp as ConExp (_, StaticCon _), _, _, _) = (nil, exp)
	  | vpExp (TupExp (info, ids), env, _, _) =
	    (nil, TupExp (info, Vector.map (fn id => deref (id, env)) ids))
	  | vpExp (ProdExp (info, labelIdVec), env, _, _) =
	    (nil, ProdExp (info,
			   Vector.map (fn (label, id) =>
				       (label, deref (id, env))) labelIdVec))
	  | vpExp (VecExp (info, ids), env, _, _) =
	    (nil, VecExp (info, Vector.map (fn id => deref (id, env)) ids))
	  | vpExp (FunExp (info, stamp, flags, args, body), env, _, lazySels) =
	    let
		val _ = IdMap.insertScope env
		val _ = declareArgs (env, args, false)
		val body =
		    vpBodyShared (body, stamp,
				  {env = env, isToplevel = false,
				   export = NONE, lazySels = lazySels})
	    in
		IdMap.deleteScope env;
		(nil, FunExp (info, stamp, flags, args,
			      patchArgs (args, lazySels) @
			      patchBody (body, lazySels, StampMap.new ())))
	    end
	  | vpExp (PrimAppExp (info, name, ids), env, _, _) =
	    (nil, vpPrimApp (info, name,
			     Vector.map (fn id => deref (id, env)) ids, env))
	  | vpExp (VarAppExp (info, id, args), env, _, _) =
	    let
		val id = deref (id, env)
		val args = derefArgs (args, env)
	    in
		case IdMap.lookupExistent (env, id) of
		    (PrimVal name, _) =>
			adaptArity (info, valOf (PrimOps.getArity name),
				    args, env,
				    fn args => vpPrimApp (info, name,
							  argsToIds args, env))
		  | (FunVal (stamp, args', _), true) =>
			(*--** inlining *)
			adaptArity (info, argsToArity args', args, env,
				    fn args => FunAppExp (info, id,
							  stamp, args))
		  | (_, _) => (nil, VarAppExp (info, id, args))
	    end
	  | vpExp (TagAppExp (info, label, n, args), env, _, _) =
	    (nil, TagAppExp (info, label, n, derefArgs (args, env)))
	  | vpExp (ConAppExp (info, Con id, args), env, _, _) =
	    let
		val id = deref (id, env)
		val args = derefArgs (args, env)
	    in
		case IdMap.lookupExistent (env, id) of
		    (ConVal (con as StaticCon _), _) =>
			(nil, ConAppExp (info, con, args))
		  | (_, _) => (nil, ConAppExp (info, Con id, args))
	    end
	  | vpExp (ConAppExp (info, StaticCon stamp, args), env, _, _) =
	    (nil, ConAppExp (info, StaticCon stamp, derefArgs (args, env)))
	  | vpExp (RefAppExp (info, id), env, _, _) =
	    (nil, RefAppExp (info, deref (id, env)))
	  | vpExp (SelAppExp (info, prod, label, n, id), env, _, _) =
	    let
		val id = deref (id, env)
	    in
		case doSel (n, id, env) of
		    SOME id => (nil, VarExp (info, id))
		  | NONE => (nil, SelAppExp (info, prod, label, n, id))
	    end
	  | vpExp (LazySelAppExp (info, prod, label, n, id),
		   env, isToplevel, lazySels) =
	    let
		val id = deref (id, env)
	    in
		case IdMap.lookupExistent (env, id) of
		    (ProdVal idDefs, _) =>
			(case Vector.sub (idDefs, n) of
			     IdDef id => (nil, VarExp (info, id))
			   | Wildcard =>
				 (nil, LazySelAppExp (info, prod,
						      label, n, id)))
		  | (_, _) =>
			(case IdMap.lookup (lazySels, id) of
			     SOME (prod, idDefs) =>
				 (nil, VarExp (info,
					       doLazySel (id, idDefs, n, env,
							  isToplevel)))
			   | NONE =>
				 let
				     val m =
					 case prod of
					     Tuple i => i
					   | Product labels =>
						 Vector.length labels
				     val idDefs =
					 Array.tabulate (m, fn _ => Wildcard)
				 in
				     IdMap.insert (lazySels, id,
						   (prod, idDefs));
				     (nil,
				      VarExp (info,
					      doLazySel (id, idDefs, n, env,
							 isToplevel)))
				 end)
	    end
	  | vpExp (FunAppExp (info, id, stamp, args), env, _, _) =
	    (nil, FunAppExp (info, id, stamp, derefArgs (args, env)))
	  | vpExp (FailExp info, _, _, _) = (nil, FailExp info)
	and vpBodyScope (body, {env, isToplevel, shared, export, lazySels}) =
	    vpBody (body, {env = IdMap.cloneTop env, isToplevel = isToplevel,
			   shared = shared, export = export,
			   lazySels = lazySels})
	and vpBodyShared (body, stamp, {env, isToplevel, export, lazySels}) =
	    (case sortShared (body, stamp) of
		 ([stamp']::sorted, shared) =>
		     (Assert.assert (stamp = stamp');
		      vpBody (body, {env = env, isToplevel = isToplevel,
				     shared = shared, export = export,
				     lazySels = lazySels}) before
		      List.app
		      (fn stamps =>
		       let
			   val _ = Assert.assert (List.null (List.tl stamps))
			   val stamp = List.hd stamps
		       in
			   case StampMap.lookupExistent (shared, stamp) of
			       UNIQUE => ()
			     | SHARED =>
				   raise Crash.Crash
				       "ValuePropagationPhase.vpBodyShared 1"
			     | VISITED (bodyOptRef, env) =>
				   let
				       val body = valOf (!bodyOptRef)
				   in
				       bodyOptRef :=
				       SOME (vpBody (body,
						     {env = env,
						      isToplevel = isToplevel,
						      shared = shared,
						      export = export,
						      lazySels = lazySels}))
				   end;
			   StampMap.deleteExistent (shared, stamp)
		       end) sorted)
	       | (_, _) =>
		     raise Crash.Crash "ValuePropagationPhase.vpBodyShared 2")

	fun debug component =
	    let
		val q = TextIO.openOut "vpdebug.txt"
	    in
		TextIO.output (q,
			       "\n" ^
			       OutputFlatGrammar.componentToString component ^
			       "\n");
		TextIO.closeOut q
	    end

	fun translate env (_, component as (imports, body, exportDesc, sign)) =
	    let
		val env' = IdMap.clone env
		val _ =
		    Vector.app (fn (idDef, _, _) =>
				declareUnknown (env', idDef, true)) imports
		val lazySels = IdMap.new ()
		val body =
		    vpBodyShared (body, Stamp.new (),
				  {env = env', isToplevel = true,
				   export = SOME (env, exportDesc),
				   lazySels = lazySels})
	    in
		(imports,
		 IdMap.foldi (fn (id, _, rest) =>
			      patchIdDef (IdDef id, lazySels) @ rest) nil env @
		 patchIdDefs (Vector.map #1 imports, lazySels) @
		 patchBody (body, lazySels, StampMap.new ()),
		 exportDesc, sign)
	    end
	    (*--**DEBUG*)
	    handle exn as Error.Error (_, _) => raise exn
		 | exn =>
		       (TextIO.print
			"\nValuePropagationPhase crashed: \
			 \dumping debug information to vpdebug.txt\n";
			debug component;
			case exn of
			    IdMap.Lookup id =>
				TextIO.print ("Lookup " ^
					      OutputFlatGrammar.idToString id ^
					      "\n")
			  | _ => ();
			raise exn)

	open PrettyPrint
	infix ^/^

	fun dumpContext env =
	    hbox (text "{" ^/^
		  fbox (below (IdMap.foldi
			       (fn (id, _, rest) =>
				text (OutputFlatGrammar.idToString id) ^/^
				rest) (text "}") env)))
    end
