(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2000-2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(*
 * Communication protocol between compiler and engine:
 *
 * link_command ::=
 *     "Command:link\n"
 *     "Code:" <string> "\n"
 *     ( "Id:" <stamp> "\n"
 *       "Valref:" <int> "\n" )*
 *     "\n"
 * link_result ::=
 *     ( "Debug:" <string> "\n" )*
 *     ( "Error:" <string> "\n"
 *     | "Valref:" <int> "\n" )
 *     "\n"
 *
 * save_command ::=
 *     "Command:save\n"
 *     "Valref:" <int> "\n"
 *     "String:" <string> "\n"
 *     "\n"
 * save_result ::=
 *     ( "Debug:" <string> "\n" )*
 *     ( "Error:" <string> "\n" )?
 *     "\n"
 *
 * apply_command ::=
 *     "Command:apply\n"
 *     "Valref:" <int> "\n"
 *     ( "Label:" <string> "\n" )*
 *     "\n"
 * apply_result ::=
 *     ( "Debug:" <string> "\n" )*
 *     ( "Error:" <string> "\n"
 *     | ( "Valref:" <int> "\n" )* )
 *     "\n"
 *)

import
    structure Stamp
from "../common/Stamp"

import
    structure Label
from "../common/Label"

import
    functor MkHashImpMap
from "../misc/MkHashImpMap"

import
    structure FlatGrammar
from "FlatGrammar"

import
    signature CODE
from "CODE-sig"

import
    signature ENGINE
from "ENGINE-sig"

import
    signature CONTEXT
from "../infrastructure/CONTEXT-sig"

structure IdMap =
    MkHashImpMap(type t = FlatGrammar.id
		 fun equals (FlatGrammar.Id (_, stamp1, _),
			     FlatGrammar.Id (_, stamp2, _)) = stamp1 = stamp2
		 fun hash (FlatGrammar.Id (_, stamp, _)) = Stamp.hash stamp)

functor MkEngine(val cmd: unit -> string * string list
		 structure Code: CODE) :> ENGINE where type code = Code.t =
    struct
	type valref = int

	structure C: CONTEXT =
	    struct
		type t = Unix.proc * valref IdMap.t

		val engine: Unix.proc option ref = ref NONE

		fun new () =
		    (case !engine of
			 NONE => engine := SOME (Unix.execute (cmd ()))
		       | SOME _ => ();
		     (valOf (!engine), IdMap.new ()))

		fun clone (proc, map) = (proc, IdMap.clone map)
	    end

	type code = Code.t
	type component = valref

	type exportDesc = (Label.t * FlatGrammar.id) vector

	exception Format of string

	fun instream proc = #1 (Unix.streamsOf proc)
	fun outstream proc = #2 (Unix.streamsOf proc)

	datatype arg =
	    COMMAND of string
	  | CODE of code
	  | ID of FlatGrammar.id
	  | VALREF of valref
	  | STRING of string
	  | LABEL of Label.t

	local
	    fun split (#":"::cs) = SOME (nil, cs)
	      | split (c::cs) =
		(case split cs of
		     SOME (name, value) => SOME (c::name, value)
		   | NONE => NONE)
	      | split nil = NONE
	in
	    fun parseResult proc =
		case TextIO.inputLine (instream proc) of
		    "\n" => nil
		  | s =>
			case String.sub (s, 0) of
			    #"%" => (TextIO.print s; parseResult proc)
			  | _ =>
			case split (String.explode s) of
			    SOME ([#"D", #"e", #"b", #"u", #"g"], s) =>
				(TextIO.print (String.implode s);
				 parseResult proc)
			  | SOME (name, value) =>
				(String.implode name, String.implode value)::
				parseResult proc
			  | NONE =>
				(TextIO.print s; parseResult proc)
	end

	fun sendCommand (proc, args) =
	    let
		val q = outstream proc
	    in
		List.app (fn arg =>
			  case arg of
			      COMMAND command =>
				  (TextIO.output (q, "Command:");
				   TextIO.output (q, command);
				   TextIO.output1 (q, #"\n"))
			    | CODE code =>
				  (TextIO.output (q, "Code:");
				   TextIO.output (q, Code.toString code);
				   TextIO.output1 (q, #"\n"))
			    | ID (FlatGrammar.Id (_, stamp, _)) =>
				  (TextIO.output (q, "Id:");
				   TextIO.output (q, Stamp.toString stamp);
				   TextIO.output1 (q, #"\n"))
			    | VALREF valref =>
				  (TextIO.output (q, "Valref:");
				   TextIO.output (q, Int.toString valref);
				   TextIO.output1 (q, #"\n"))
			    | STRING string =>
				  (TextIO.output (q, "String:");
				   TextIO.output (q, string);
				   TextIO.output1 (q, #"\n"))
			    | LABEL label =>
				  (TextIO.output (q, "Label:");
				   TextIO.output (q, Label.toString label);
				   TextIO.output1 (q, #"\n"))) args;
		TextIO.output1 (q, #"\n");
		TextIO.flushOut q;
		parseResult proc
		before
		List.app (fn arg =>
			  case arg of
			      CODE code => Code.cleanup code
			    | _ => ()) args
	    end

	fun link (proc, map) code =
	    let
		val result =
		    sendCommand (proc,
				 COMMAND "link"::
				 CODE code::
				 IdMap.foldi (fn (id, valref, rest) =>
					      ID id::VALREF valref::rest)
				 nil map)
	    in
		case result of
		    [("Valref", s)] => valOf (Int.fromString s)
		  | [("Error", s)] => raise Format ("link (engine): " ^ s)
		  | _ => raise Format "link: could not parse result"
	    end

	fun save (proc, _) (valref, filename) =
	    let
		val result =
		    sendCommand (proc,
				 [COMMAND "save",
				  VALREF valref,
				  STRING filename])
	    in
		case result of
		    nil => ()
		  | [("Error", s)] => raise Format ("save (engine): " ^ s)
		  | _ => raise Format "save: could not parse result"
	    end

	fun extendEnv (("Valref", valref)::args, (_, id)::exportDesc, map) =
	    (IdMap.insert (map, id, valOf (Int.fromString valref));
	     extendEnv (args, exportDesc, map))
	  | extendEnv (("Error", s)::_, _, _) =
	    raise Format ("apply (engine): " ^ s)
	  | extendEnv ((_, _)::_, _, _) =
	    raise Format "apply: could not parse result"
	  | extendEnv (nil, nil, _) = ()
	  | extendEnv (_, _, _) =
	    raise Format "apply: wrong number of results"

	fun apply (proc, map) (valref, exportDesc) =
	    let
		val result =
		    sendCommand (proc,
				 COMMAND "apply"::
				 VALREF valref::
				 Vector.foldr (fn ((label, _), rest) =>
					       LABEL label::rest)
				 nil exportDesc)
	    in
		extendEnv (result, Vector.toList exportDesc, map)
	    end
    end
