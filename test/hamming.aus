(*
import
val show: 'a -> {}
from "../../vm-mozart/Debug.ozf"
*)

infix  7  * / div mod
infix  6  + - ^
infixr 5  :: @
infix  4  = <> > >= < <=
infix  3  := o
infix  0  before

__prebound Prebound

type     int    = Prebound.int
type     bool   = Prebound.bool
datatype list   = datatype Prebound.list
datatype ref    = datatype Prebound.ref
type     exn    = Prebound.exn

type unit = {}

exception Promise
exception Future
exception Fulfill
exception ByNeed of exn

__primitive val op=  : ''a * ''a -> bool = "="

__primitive val op+ : int * int -> int = "+"
__primitive val op- : int * int -> int = "-"
__primitive val op* : int * int -> int = "*"
__primitive val op< : int * int -> bool = "<"

__primitive val exchange: 'a ref * 'a -> 'a = "General.exchange"

__primitive val spawn: (unit -> 'a) -> unit = "Thread.spawn"
__primitive val sleep: int -> unit = "Thread.sleep"

__primitive val promise: unit -> 'a = "Transient.promise"
__primitive val future: 'a -> 'a = "Transient.future"
__primitive val fulfill: 'a * 'a -> unit = "Transient.fulfill"
__primitive val await: 'a -> 'a = "Transient.await"
__primitive val byNeed: (unit -> 'a) -> 'a = "Transient.byNeed"

__primitive val show: 'a -> unit = "show"

fun take (_, 0) = nil
  | take (x::xr, i) = x::take (xr, i - 1)

fun app f nil = ()
  | app f (x::xr) = (f x; app f xr)

fun nth (xs, i) =
    let
	fun nth' (y::_, 0) = y
	  | nth' (y::yr, j) = nth' (yr, j - 1)
    in
	nth' (xs, i)
    end

fun multiples n =
    let
	fun gen i =
	    byNeed (fn () => (n * i)::gen (i + 1))
    in
	gen 1
    end

fun merge (xs, ys) =
    byNeed (fn () =>
	    case (xs, ys) of
		(x::xr, y::yr) =>
		    if x = y then x::merge (xr, yr)
		    else if x < y then x::merge (xr, ys)
		    else y::merge (xs, yr))

val twos = multiples 2
val threes = multiples 3
val fours = multiples 4

val merged = merge (merge (twos, threes), fours)

val _ = take (merged, 20000)

val _ = show "done"
