(*
 * Authors:
 *   Sebastian Germesin <germi@ps.uni-sb.de>
 *
 * Copyright:
 *   Sebastian Germesin, 2004
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import signature TESTSUITE from "../../src/TESTSUITE-sig"

import structure Random    from "x-alice:/lib/utility/Random"
import structure Gen       from "x-alice:/lib/test/Gen"
import structure Test      from "../../src/Test"

structure TestArray2 :> TESTSUITE =
struct

    val randomize = Gen.randomize

    fun testArray () =
	let
	    fun t' (r, c, x, b) = (Array2.array (r, c, x); b) 
			          handle Size => not b


	    fun t (r, c, x) = let 
				  val a = SOME (Array2.array (r, c, x)) 
					   handle Size => NONE
			      in
		                  if Option.isNone a then
				      r < 0 orelse c < 0
				  else (r >= 0 andalso c >= 0 andalso
					Array2.nRows (valOf a) = r andalso
					Array2.nCols (valOf a) = c andalso
					Array2.sub (valOf a, 
						    Int.abs (Gen.int r),
						    Int.abs (Gen.int c)) = x)
				       handle Subscript => r = 0 orelse c = 0
			      end
	in
	    Test.test t' (~2, ~1, 0, false); 
	    Test.test t' (~2,  1, 0, false); 
	    Test.test t' ( 2, ~1, 0, false);
	    Test.test t' ( 2,  1, 0, true);
	    Gen.try 1000 (Gen.triple (Gen.int, Gen.int, Gen.int)) (Test.test t)
	end

    fun testNRows () =
	let
	    fun t' (a, i) =  (Array2.sub (a, i, 0); t' (a, i + 1))
			       handle Subscript => i

	    fun t a = t' (a, 0) = Array2.nRows a orelse Array2.nCols a = 0
	in
	    Gen.try 100 (Gen.array2 Gen.int) (Test.test t)
	end

    fun testNCols () =
	let
	    fun t' (a, i) =  (Array2.sub (a, 0, i); t' (a, i + 1))
			       handle Subscript => i

	    fun t a = t' (a, 0) = Array2.nCols a orelse Array2.nRows a = 0

	in
	    Gen.try 100 (Gen.array2 Gen.int) (Test.test t)
	end

    fun testDimensions () =
	let
	    fun t a = Array2.dimensions a = 
		      (Array2.nRows a, Array2.nCols a)
	in
	    Gen.try 100 (Gen.array2 Gen.int) (Test.test t)
	end

    fun testRow () = 
	let
	    fun t' (a, r, c) l = if c < Array2.nCols a
				  then t' (a, r, c + 1) 
				          (Array2.sub (a, r, c)::l)
				  else Vector.fromList (rev l)
				      
	    fun t (a, i) = 
		    Vector.equal Int.equal (t' (a, i, 0) [], Array2.row (a, i))
		    handle Subscript => Array2.nRows a <= i orelse i < 0
	in
	    Gen.try 100 (Gen.pair (Gen.array2 Gen.int, Gen.int)) (Test.test t)
	end

    fun testColumn () = 
	let
	    fun t' (a, r, c) l = if r < Array2.nRows a
				  then t' (a, r + 1, c) 
				          (Array2.sub (a, r, c)::l)
				  else Vector.fromList (rev l)
				      
	    fun t (a, i) = 
		    Vector.equal Int.equal (t' (a, 0, i) [], 
					    Array2.column (a, i))
		    handle Subscript => Array2.nCols a <= i orelse i < 0
	in
	    Gen.try 100 (Gen.pair (Gen.array2 Gen.int, Gen.int)) (Test.test t)
	end

    fun testSub () =
	let
	    fun t (xss, a, r, c) = if List.null xss orelse 
		                   c < 0 orelse Array2.nCols a <= c orelse
		                   r < 0 orelse Array2.nRows a <= r
				       then NONE
				   else SOME (List.nth (List.nth (xss, r), c))
	in
	   Gen.try 100 (Gen.triple (Gen.list (Gen.list Gen.int), 
				     Gen.int, Gen.int))
	      (Test.test (fn (xss, r, c) => 
			        let
				    val a = Array2.fromList xss
				    val res = t (xss, a, r, c)
				in
				    Array2.sub (a, r, c) = valOf res
				      handle Subscript => Option.isNone res
	                              handle Option => false
				end))
	end

    fun testUpdate () =
	let
	    fun t (a, r, c) = 
		let
		    val x = Gen.int (r + c)
		in
		   (Array2.update (a, r, c, x);
		    Array2.sub (a, r, c) = x)
		      handle Subscript => r < 0 orelse c < 0 orelse 
					  Array2.nCols a <= c orelse
					  Array2.nRows a <= r
		end
	in
	    Gen.try 100 (Gen.triple (Gen.array2 Gen.int, Gen.int, Gen.int))
	      (Test.test t)
	end

    fun testEqual () = 
	let
	    val xs = ref []

	    fun swap a = 
		let
		    val a2 = Array2.array (Array2.nCols a, Array2.nRows a, 0)

		    fun s' (r, c) = if c < Array2.nCols a2
				    then if r < Array2.nRows a2
					 then (Array2.update (a2, r, c, 
							 Array2.sub (a, c, r));
					       s' (r + 1, c))
					 else s' (0, c + 1)
				    else ()
		in
		    s' (0, 0);
		    a2
		end
		    

	    fun t (xss1, xss2) = List.equal (List.equal Int.equal) (xss1, xss2)
	in
	    Gen.try 100 (Gen.pair (Gen.array2 Gen.int,
				   Gen.array2 Gen.int))
	      (Test.test (fn (a1, a2) => 
			      let
				  fun eqT (a, b) = (xs := a :: !xs; a = b)

				  val eq1 = Array2.equal Array2.RowMajor 
				                         eqT (a1, a2)
				  val eq1' = !xs before xs := []
				  val eq2 = Array2.equal Array2.ColMajor
				                         eqT (a1, a2)
				  val eq3 = Array2.equal Array2.ColMajor
							 eqT (swap a1, swap a2)
				  val eq3' = !xs before xs := []
			      in
				  eq1 = eq2 andalso 
				  eq1 = t (Array2.toList a1, 
					   Array2.toList a2) andalso
				  eq1' = eq3'
			      end))
	end

    fun testFromList () =
	let
	    fun t' nil         (_, _, a) = a
	      | t' (nil :: xs) (r, c, a) = t' xs (r + 1, 0, a)
	      | t' (x   :: xs) (r, c, a) = 
		                 (Array2.update (a, r, c, List.hd x);
				  t' ((List.tl x) :: xs) (r, c + 1, a))

	    fun t nil = SOME (Array2.array (0, 0, 0))
	      | t  xs =
		  if List.all (fn x => (List.length (List.hd xs)) = 
			                List.length x) xs
		  then SOME (t' xs (0, 0, (Array2.array (List.length xs, 
					   List.length (List.hd xs), 0))))
		  else NONE
	in
	    Gen.try 100 (Gen.list (Gen.list Gen.int))
	      (Test.test (fn xs => 
			       let
				   val r = t xs
			       in 
				   if Option.isSome r
				       then Array2.equal Array2.RowMajor 
					        Int.equal 
					        (Array2.fromList xs,
						 valOf r)
				   else false
				       handle Size => Option.isNone r
			       end))
	end

    fun testToList () = 
	let
	    fun t xs = Array2.toList (Array2.fromList xs) = xs
	in
	    Gen.try 100 (Gen.list (Gen.list Gen.int)) (Test.test t)
	end

    fun testTabulate () = 
	Test.test (fn _ => raise Test.NotYetImplemented) ()
    fun testCopy () = 
	Test.test (fn _ => raise Test.NotYetImplemented) ()
    fun testApp () = 
	Test.test (fn _ => raise Test.NotYetImplemented) ()
    fun testAppi () = 
	Test.test (fn _ => raise Test.NotYetImplemented) ()
    fun testModify () = 
	Test.test (fn _ => raise Test.NotYetImplemented) ()
    fun testModifyi () = 
	Test.test (fn _ => raise Test.NotYetImplemented) ()
    fun testFold () = 
	Test.test (fn _ => raise Test.NotYetImplemented) ()
    fun testFoldi () = 
	Test.test (fn _ => raise Test.NotYetImplemented) ()
    fun testAll () = 
	Test.test (fn _ => raise Test.NotYetImplemented) ()
    fun testAlli () = 
	Test.test (fn _ => raise Test.NotYetImplemented) ()
    fun testExists () = 
	Test.test (fn _ => raise Test.NotYetImplemented) ()
    fun testExistsi () = 
	Test.test (fn _ => raise Test.NotYetImplemented) ()
    fun testContains () = 
	Test.test (fn _ => raise Test.NotYetImplemented) ()
    fun testNotContains () = 
	Test.test (fn _ => raise Test.NotYetImplemented) ()


    val suite = ("Array2", [("array", testArray),
			    ("toList", testToList),
			    ("fromList", testFromList),
			    ("tabulate", testTabulate),
			    ("sub", testSub),
			    ("dimensions", testDimensions),
			    ("nRows", testNRows),
			    ("nCols", testNCols),
			    ("row", testRow),
			    ("column", testColumn),
			    ("copy", testCopy),
			    ("app", testApp),
			    ("modify", testModify),
			    ("fold", testFold),
			    ("all", testAll),
			    ("exists", testExists),
			    ("appi", testAppi),
			    ("modifyi", testModifyi),
			    ("foldi", testFoldi),
			    ("alli", testAlli),
			    ("existsi", testExistsi),
			    ("contains", testContains),
			    ("notContains", testNotContains),
			    ("update", testUpdate),
			    ("equal", testEqual)])
end
