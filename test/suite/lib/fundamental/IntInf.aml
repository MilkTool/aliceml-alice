(*
 * Authors:
 *   Sebastian Germesin <germi@ps.uni-sb.de>
 *
 * Copyright:
 *   Sebastian Germesin, 2004
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import signature TESTSUITE from "../../src/TESTSUITE-sig"

import structure Gen       from "x-alice:/lib/test/Gen"
import structure Test      from "../../src/Test"

structure TestIntInf :> TESTSUITE = (* the intInf test suite *)
struct

    val randomize = Gen.randomize

    val fromI = IntInf.fromInt

    (* generates IntInf numbers *)
    fun largeInt i = let
			 val m = valOf Int.maxInt
		     in
			 (fromI (Gen.int m)) * (fromI (Gen.int m))
		     end


    fun testMinInt () =
	Test.test (fn m => IntInf.minInt = m) NONE

    fun testMaxInt () =
	Test.test (fn m => IntInf.maxInt = m) NONE

    fun testPrecision () =
	Test.test (fn m => IntInf.precision = m) NONE

    fun testToFromInt () = 
	(Test.test (fn x => IntInf.toInt (fromI x) = x) 
	                                                (valOf Int.maxInt);
	 Test.test (fn x => IntInf.toInt (fromI x) = x) 
	                                                (valOf Int.minInt);
	 Gen.try 1000 Gen.int 
	    (Test.test (fn x => IntInf.toInt (fromI x) = x)))

    fun testToInt () = 
	let
	    val x1 = fromI (valOf Int.maxInt)
	    val x2 = IntInf.* (x1, x1)
	    val x1 = IntInf.- (x1, x2)
	in
	    Test.test (fn s => (IntInf.toInt s; false) handle _ => true) x1;
	    Test.test (fn s => (IntInf.toInt s; false) handle _ => true) x2
	end

    fun testFromInt () =
	Test.test (fn _ => raise Test.NotYetImplemented) ()

    fun testToLarge () =
	Test.test (fn _ => raise Test.NotYetImplemented) ()

    fun testFromLarge () =
	Test.test (fn _ => raise Test.NotYetImplemented) ()

    fun testToFromLarge () =
	Test.test (fn _ => raise Test.NotYetImplemented) ()

    fun testDiv () =
	let
	    fun t (a, b) = IntInf.equal (a, b * IntInf.div(a, b) + IntInf. mod(a, b)) 
				     handle Div => IntInf.equal (b, fromI 0)
	in
	    Gen.try 10 (Gen.pair (largeInt, largeInt)) (Test.test t)
	end

    fun testMod () =
	let
	    (* very ugly... TODO: some more faster way *)
	    fun t (x, y, r, i) = if y * i > IntInf.abs(x) then false
				 else if IntInf.equal (x, y * i + r) andalso 
					 IntInf.sameSign (y, r) then true 
				     else t (x, y, r, i + (fromI 1))
	    fun getLarge i = IntInf.div (largeInt i, fromI 1000)
	    fun h i = let val a = largeInt i
			  val b = largeInt i
		      in
			  t (a, b, IntInf.mod(a, b), ~ (IntInf.abs a)) 
			    handle Div => IntInf.equal (b, fromI 0)
		      end
	in
	    Test.test (fn _ => true) () (*Gen.try 5 getLarge (Test.test h) *)
	end

    fun testQuot () =
	let
	    fun t (a, b) = IntInf.equal (a, b * IntInf.quot(a, b) + IntInf. rem(a, b)) 
				     handle Div => IntInf.equal (b, fromI 0)
	in
	    Gen.try 10 (Gen.pair (largeInt, largeInt)) (Test.test t)
	end

    fun testRem () =
	let
	    (* very ugly... TODO: some more faster way *)
	    fun t (x, y, r, i) = if y * i > IntInf.abs(x) then false
				 else if IntInf.equal (x, y * i + r) andalso 
					 IntInf.sameSign (x, r) then true 
				     else t (x, y, r, i + (fromI 1))
	    fun getLarge i = IntInf.div (largeInt i, fromI 1000)
	    fun h i = let val a = largeInt i
			  val b = largeInt i
		      in
			  t (a, b, IntInf.rem(a, b), ~ (IntInf.abs a)) 
			    handle Div => IntInf.equal (b, fromI 0)
		      end
	in
	    Test.test (fn _ => true) () (*Gen.try 5 getLarge (Test.test h) *)
	end

    fun testEqual () =
	let
	    fun t (x1, x2) = if x1 = x2 then Int.equal (x1, x2) 
			     else Bool.not (Int.equal (x1, x2))
	in
	    Gen.try 10000 Gen.int 
	     (Test.test (fn x => Int.equal(x, x) andalso 
			         t (Gen.int x, Gen.int x)))
	end

    fun testCompare () =
	let
	    fun t' (x1, x2) = if IntInf.< (x1, x2) then LESS
			      else if x1 > x2 then GREATER
				   else EQUAL
	    fun t'' (x1, x2) = IntInf.compare (x1, x2) = t' (x1, x2)
	in 
	    Gen.try 1000 (Gen.pair (largeInt, largeInt)) (Test.test t'');
	    Test.test t'' (fromI 0, fromI 0)
	end

    fun testHash () =
	let
	    fun t i = case Int.maxInt of 
		               NONE   => IntInf.toInt (IntInf.abs i)
			     | SOME m => IntInf.toInt (IntInf.mod (IntInf.abs i, 
								   IntInf.fromInt m))
	in
	    Gen.try 1000 largeInt (Test.test (fn x => IntInf.hash x = t x))
	end

    fun testDivMod () =
	let
	    fun t (a, b) = IntInf.divMod (a, b) = (IntInf.div (a, b), IntInf.mod (a, b)) 
		              handle Div => b = (fromI 0)
	in
	    Gen.try 1000 (Gen.pair (largeInt, largeInt)) (Test.test t)
	end

    fun testQuotRem () =
	let
	    fun t (a, b) = IntInf.quotRem (a, b) = (IntInf.quot (a, b), IntInf.rem (a, b)) 
		              handle Div => b = (fromI 0)
	in
	    Gen.try 1000 (Gen.pair (largeInt, largeInt)) (Test.test t)
	end

    fun testPow () =
	Test.test (fn _ => raise Test.NotYetImplemented) ()

    fun testLog2 () =
	Test.test (fn _ => raise Test.NotYetImplemented) ()

    fun testOrB () =
	Test.test (fn _ => raise Test.NotYetImplemented) ()

    fun testAndB () =
	Test.test (fn _ => raise Test.NotYetImplemented) ()

    fun testXorB () =
	Test.test (fn _ => raise Test.NotYetImplemented) ()

    fun testNotB () =
	let
	    fun t x = IntInf.notb x = IntInf.~ (x + (fromI 1))
	in
	    Gen.try 1000 largeInt (Test.test t)
	end

    fun testLeftShift () =
	Test.test (fn _ => raise Test.NotYetImplemented) ()

    fun testRightShift () =
	Test.test (fn _ => raise Test.NotYetImplemented) ()

    fun testAbs () =
	let
	    fun t x = if x < (fromI 0) then IntInf.abs x = IntInf.~ x else IntInf.abs x = x
	in
	    Gen.try 10000 largeInt (Test.test t)
	end 

    fun testMin () =
	let
	    fun t' (x1, x2) = if IntInf.equal (x1, x2) then x1
			      else if x1 < x2 then x1
				   else x2
	    fun t x = IntInf.min x = t' x
	in
	    Gen.try 10000 (Gen.pair (largeInt, largeInt)) (Test.test t)
	end

    fun testMax () =
	let
	    fun t' (x1, x2) = if IntInf.equal (x1, x2) then x1
			      else if x1 > x2 then x1
				   else x2
	    fun t x = IntInf.max x = t' x
	    fun t'' (x1, x2) = if IntInf.max (x1, x2) = x1
				   then IntInf.min (x1, x2) = x2
			       else IntInf.min (x2, x1) = x1
	in
	    Gen.try 10000 (Gen.pair (largeInt, largeInt)) (Test.test t);
	    Gen.try 10000 (Gen.pair (largeInt, largeInt)) (Test.test t'')
	end

    fun testSign () =
	let
	    fun t' x = if x < (fromI 0) then ~1
		       else 
			   if x > (fromI 0) then  1 else 0
	    fun t x = IntInf.sign x = t' x
	in 
	    Gen.try 1000 largeInt (Test.test t)
	end

    fun testSameSign () =
	let
	    fun t' (x1, x2) = if x1 = (fromI 0) andalso x2 = (fromI 0) then true
			     else if x1 > (fromI 0) andalso x2 > (fromI 0) then true
				  else if x1 < (fromI 0) andalso x2 < (fromI 0) then true
				      else false
	    fun t x = IntInf.sameSign x = t' x
	in
	    Gen.try 10000 (Gen.pair (largeInt, largeInt)) (Test.test t)
	end

    fun testArithmetic () = 
	Test.test (fn _ => raise Test.NotYetImplemented) ()

    fun testToString () =
	Test.test (fn _ => raise Test.NotYetImplemented) ()

    fun testFromString () =
	Test.test (fn _ => raise Test.NotYetImplemented) ()

    fun testToFromString () =
	let
	    val x1 = fromI (valOf Int.maxInt)
	    val x2 = fromI (valOf Int.minInt)
	    fun toFrom x = valOf (IntInf.fromString (IntInf.toString x))
	in
            (Test.test (fn x => toFrom x = x handle _ => false) x1;
	     Test.test (fn x => toFrom x = x handle _ => false) x2;
	     Gen.try 1000 Gen.int 
		     (Test.test (fn x => let
					   val t = fromI x
				         in
					   toFrom t = t handle _ => false
				         end)))
	end

    fun testFmt () = Test.test (fn _ => raise Test.NotYetImplemented) ()    

    fun testScan () = Test.test (fn _ => raise Test.NotYetImplemented) ()

    val suite = ("IntInf", [("minInt", testMinInt),
			    ("maxInt", testMaxInt),
			    ("precision", testPrecision),
			    ("toInt", testToInt),
			    ("fromInt", testFromInt),
			    ("toLarge", testToLarge),
			    ("fromLarge", testFromLarge),
			    ("toFromLarge", testToFromLarge),
			    ("arithmetic", testArithmetic),
			    ("div", testDiv),
			    ("mod", testMod),
			    ("quot", testQuot),
			    ("rem", testRem),
			    ("equal", testEqual),
			    ("compare", testCompare),
			    ("hash", testHash),
			    ("divMod", testDivMod),
			    ("quotRem", testQuotRem),
			    ("pow", testPow),
			    ("log2", testLog2),
			    ("orb", testOrB),
			    ("xorb", testXorB),
			    ("andb", testAndB),
			    ("notb", testNotB),
			    ("<<", testLeftShift),
			    ("~>>", testRightShift),
			    ("abs", testAbs),
			    ("min", testMin),
			    ("max", testMax),
			    ("sign", testSign),
			    ("sameSign", testSameSign),
			    ("toString", testToString),
			    ("fromString", testFromString),
			    ("toFromString", testToFromString),
			    ("fmt", testFmt),
			    ("scan", testScan)])
end
