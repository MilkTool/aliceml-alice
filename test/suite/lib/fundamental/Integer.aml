(*
 * Authors:
 *   Sebastian Germesin <germi@ps.uni-sb.de>
 *
 * Copyright:
 *   Sebastian Germesin, 2004
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import signature TESTSUITE from "../../src/TESTSUITE-sig"

import structure Random    from "x-alice:/lib/utility/Random"
import structure Gen       from "x-alice:/lib/test/Gen"
import structure Test      from "../../src/Test"


structure TestInteger :> TESTSUITE = (* the integer test suite *)
struct

    val randomize = Gen.randomize
    
    fun testPrecision () =
	Test.test (fn _ => valOf Int.precision = 31) ()

    fun testMinInt () = 
	let
	    (* TODO: FIXME *)
	    val n = valOf Int.precision
	    val min = Real.round (Math.pow (2.0, Real.fromInt (n - 1)))
	in
	    Test.test (fn _ => valOf Int.minInt = min) ()
	end

    fun testMaxInt () = 
	Test.test (fn _ => valOf Int.maxInt = 1073741823) ()

    fun testPrecision () = 
	Test.test (fn _ => valOf Int.precision = 31) ()

    fun testFromLarge () =
	let
	    val test1  = (Int.toLarge (valOf Int.maxInt)) + Int.toLarge 1000000
	    val test2  = Int.toLarge 1000000
	in
	 (Test.test (fn x => (Int.fromLarge x; true) 
			           handle Overflow => false) test1;
	  Test.test (fn x => (Int.fromLarge x; true)) test2)
	end

    fun testHash () = 
       let
	   fun t x = Int.hash x = (Int.abs x handle Overflow => 0)
       in
	   Gen.try 1000 Gen.int (Test.test t)
       end
 
    fun testAbs () =
	Gen.try 10000 Gen.int 
		(Test.test 
		     (fn x => if x < 0 then abs x = ~ x else abs x = x))

    fun testArithmetic () = 
	let
	    fun tS (x1, x2) = if x2 = 0 then x1 < 0
			      else x1 div x2 = 0
	    fun tE (x1, 0) = x1 = 0
	      | tE (x1, x2) = (x1 div x2 = 1 orelse x1 div x2 = ~1)
		               andalso (x1 mod x2 = 0)
	    fun tG x = (Bool.not (tS x)) andalso (Bool.not (tE x))
	    fun getInt () = Gen.int (Random.int (valOf Int.maxInt) + 1)
	    fun t' (x1, x2) = 
		((tS (x1, x2)) = (x1 < x2)) andalso
		((tG (x1, x2)) = (x1 > x2)) andalso
		((tE (x1, x2)) = (x1 = x2))
	in
	    Gen.try 1000 (Gen.pair (Gen.int, Gen.int)) (Test.test t')
	end

    fun testCompare () = 
	let
	    fun t' (x1, x2) = if x1 < x2 then LESS
			      else if x1 > x2 then GREATER
				   else EQUAL
	    fun t'' (x1, x2) = Int.compare (x1, x2) = t' (x1, x2)
	in 
	    Gen.try 1000 (Gen.pair (Gen.int, Gen.int)) (Test.test t'');
	    Test.test t'' (valOf Int.maxInt, valOf Int.minInt);
	    Test.test t'' (valOf Int.maxInt, valOf Int.maxInt);
	    Test.test t'' (0, 0)
	end

    fun testMod () = 
	let
	    (* very ugly... TODO: some more faster way *)
	    fun t (x, y, r, i) = if i > Int.abs(x) then false
				 else if x = y * i + r then true 
				     else t (x, y, r, i + 1)
	    fun getInt i = (Gen.int i) div 1000
	    fun h i = let val a = Gen.int i
			  val b = Gen.int i
			  val b = if b <> 0 then b else 1
		      in
			  t (a, b, a mod b, ~ (Int.abs a))
		      end
	in
	    Gen.try 5 getInt (Test.test h)
	end

    fun testSign () = 
	let
	    fun t' x = if x < 0 then ~1
		      else if x > 0 then 1 else x
	    fun t x = Int.sign x = t' x
	in 
	    Test.test t (valOf Int.maxInt);
	    Test.test t (valOf Int.minInt);
	    Gen.try 1000 Gen.int (Test.test t)
	end

    fun testToFromLarge () = 
	let
	    fun t x = x = Int.fromLarge (Int.toLarge x)
	in 
	    Test.test t (valOf Int.maxInt);
	    Test.test t (valOf Int.minInt);
	    Gen.try 10000 Gen.int (Test.test t)
	end

    fun testSameSign () = 
	let
	    fun t' (x1, x2) = if x1 = 0 andalso x2 = 0 then true
			     else if x1 > 0 andalso x2 > 0 then true
				  else if x1 < 0 andalso x2 < 0 then true
				      else false
	    fun t x = Int.sameSign x = t' x
	in
	    Test.test t (valOf Int.maxInt, valOf Int.maxInt);
	    Test.test t (valOf Int.minInt, valOf Int.minInt);
	    Test.test t (valOf Int.minInt, 0);
	    Test.test t (0, valOf Int.maxInt);
	    Test.test t (valOf Int.minInt, valOf Int.maxInt);
	    Test.test t (valOf Int.maxInt, valOf Int.minInt);
	    Gen.try 10000 (Gen.pair (Gen.int, Gen.int)) (Test.test t)
	end

    fun testMin () = 
	let
	    fun t' (x1, x2) = if x1 = x2 then x1
			      else if x1 < x2 then x1
				   else x2
	    fun t x = Int.min x = t' x
	in
	    Test.test t (valOf Int.maxInt, valOf Int.maxInt);
	    Test.test t (valOf Int.minInt, valOf Int.minInt);
	    Test.test t (valOf Int.minInt, 0);
	    Test.test t (0, valOf Int.maxInt);
	    Test.test t (valOf Int.minInt, valOf Int.maxInt);
	    Test.test t (valOf Int.maxInt, valOf Int.minInt);
	    Gen.try 10000 (Gen.pair (Gen.int, Gen.int)) (Test.test t)
	end

    fun testToFromString () = 
	Test.test (fn _ => raise Test.NotYetImplemented) ()

    fun testQuot () = 
	let
	    fun t (a, b) = if b <> 0 then a = b * (Int.quot (a, b)) + (a mod b)
			   else true
	in
	    Gen.try 10 (Gen.pair (Gen.int, Gen.int)) (Test.test t)
	end

    fun testScan () = 
	Test.test (fn _ => raise Test.NotYetImplemented) ()

    fun testEqual () = 
	let
	    fun t (x1, x2) = if x1 = x2 then Int.equal (x1, x2) 
			     else Bool.not (Int.equal (x1, x2))
	in
	    Gen.try 10000 Gen.int 
	     (Test.test (fn x => Int.equal(x, x) andalso 
			         t (Gen.int x, Gen.int x)))
	end

    fun testRem () =
	let
	    (* very ugly... TODO: some more faster way *)
	    fun t (x, y, r, i) = if y * i > Int.abs(x) then false
				 else if x = y * i + r then true 
				     else t (x, y, r, i + 1)
	    fun getInt i = (Gen.int i) div 1000
	    fun h i = let val a = Gen.int i
			  val b = Gen.int i
			  val b = if b <> 0 then b else 1
		      in
			  t (a, b, Int.rem(a, b), ~ (Int.abs a))
		      end
	in
	    Gen.try 5 getInt (Test.test h)
	end

    fun testSign () = 
	let
	    fun t' x = if x < 0 then ~1
		      else if x > 0 then 1 else x
	    fun t x = Int.sign x = t' x
	in 
	    Test.test t (valOf Int.maxInt);
	    Test.test t (valOf Int.minInt);
	    Gen.try 1000 Gen.int (Test.test t)
	end

    fun testToFromLarge () = 
	let
	    fun t x = x = Int.fromLarge (Int.toLarge x)
	in 
	    Test.test t (valOf Int.maxInt);
	    Test.test t (valOf Int.minInt);
	    Gen.try 10000 Gen.int (Test.test t)
	end

    fun testToFromInt () = 
	let
	    fun t x = x = Int.toInt (Int.fromInt x)
	in
	    Gen.try 100000 Gen.int (Test.test t)
	end

    fun testDiv () =
	let
	    fun t (a, b) = if b <> 0 then a = b * (a div b) + (a mod b)
			   else true
	in
	    Gen.try 10 (Gen.pair (Gen.int, Gen.int)) (Test.test t)
	end

    fun testFmt () = 
	Test.test (fn _ => raise Test.NotYetImplemented) ()

    fun testMax () = 
	let
	    fun t' (x1, x2) = if x1 = x2 then x1
			      else if x1 > x2 then x1
				   else x2
	    fun t x = Int.max x = t' x
	    fun t'' (x1, x2) = if Int.max (x1, x2) = x1
				   then Int.min (x1, x2) = x2
			       else Int.min (x2, x1) = x1
	in
	    Test.test t (valOf Int.maxInt, valOf Int.maxInt);
	    Test.test t (valOf Int.minInt, valOf Int.minInt);
	    Test.test t (valOf Int.minInt, 0);
	    Test.test t (0, valOf Int.maxInt);
	    Test.test t (valOf Int.minInt, valOf Int.maxInt);
	    Test.test t (valOf Int.maxInt, valOf Int.minInt);
	    Gen.try 10000 (Gen.pair (Gen.int, Gen.int)) (Test.test t);
	    Gen.try 10000 (Gen.pair (Gen.int, Gen.int)) (Test.test t'')
	end


    val suite = ("Integer", [("hash", testHash),
			     ("minInt", testMinInt),
			     ("maxInt", testMaxInt),
			     ("precision", testPrecision),
			     ("abs", testAbs),
			     ("arithmetic", testArithmetic),
			     ("compare", testCompare),
			     ("mod", testMod),
			     ("sign", testSign),
			     ("toFromLarge", testToFromLarge),
			     ("sameSign", testSameSign),
			     ("min", testMin),
			     ("toFromString", testToFromString),
			     ("quot", testQuot),
			     ("scan", testScan),
			     ("equal", testEqual),
			     ("rem", testRem),
			     ("toFromInt", testToFromInt),
			     ("div", testDiv),
			     ("fmt", testFmt),
			     ("max", testMax)])
end