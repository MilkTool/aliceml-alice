import signature REGRESSION from "REGRESSION-sig"

(*
 * Tests a bunch of corner cases that resulted in bugs during
 * development of the bytecode system.
 *)
structure ByteCodeBugs : REGRESSION =
struct

    val name = "ByteCodeBugs"
    val ok = NONE
    val result = ""


    val units = #[(), (), ()]
    val a  = Vector.sub (units, 2)
    val () = Vector.sub (units, 1)
    do assert a = ()
    do assert Vector.length units = 3

    val ints  = #[1, 2, 3, 4]
    val a = Vector.sub (ints, 3)
    do assert a = 4

    val pairs = #[(1, 2), (3, 4)]
    val (a, b) = Vector.sub (pairs, 0)
    do assert (a, b) = (1, 2)

    do assert (let val   ()   = Hole.hole() in () end) raise Hole.Hole
    do assert (let val (a, b) = Hole.hole() in () end) raise Hole.Hole

    val (one, two) = Vector.sub (pairs, 0)
    do assert one + two = 3
    do assert two + 1 = 3
    do assert 1 + two = 3
    do assert 1 - two = ~1
    do assert two - 1 = 1
    val tt = lazy (Fn.id (3, 4))
    do assert (op+ tt) = 7

    val r = ref 1
    val _ = r := 2
    do assert !r = 2
    val () = r := 3
    do assert !r = 3

    val () = await ()
    val a = await (lazy 2*2)
    do assert a = 4
    val (a, b) = await (lazy (1, 2))
    do assert (a, b) = (1, 2)

    exception TooLazy
    val lx = lazy raise TooLazy
    do ignore lx (*) this should not request lx, since ignore does not request its argument ...
    fun reqUnit () = true
    do assert reqUnit lx             raise TooLazy (*) ... but these should ...
    do assert await lx               raise TooLazy
    do assert Hole.hole lx           raise TooLazy
    do assert OS.FileSys.tmpName lx  raise TooLazy
    
end

