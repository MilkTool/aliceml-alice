import signature REGRESSION from "REGRESSION-sig"

structure Word : REGRESSION =
struct

val name = "word"

val ok = SOME "word.ok"

val result = ref ""

fun concatResult s = result := (!result) ^ s


(* Auxiliary functions for test cases *)

infix 1 seq
fun e1 seq e2 = e2;
fun check b = if b then "OK" else "WRONG";
fun check' f = (if f () then "OK" else "WRONG") handle _ => "EXN";

fun range (f, to) p = 
    let open Int 
    in
	(f > to) orelse (p f) andalso (range (f+1, to) p)
    end;

fun checkrange bounds = check o range bounds;

fun tst0 s s' = concatResult (s ^ "    \t" ^ s' ^ "\n");
fun tst  s b = tst0 s (check  b);
fun tst' s f = tst0 s (check' f);

fun tstrange s bounds = (tst s) o range bounds  

(* test/word.sml -- some test cases for Word, appropriate for a two's
   complement machine whose Int.precision = SOME 31 
   PS 1995-03-19, 1995-07-12, 1995-11-06, 1996-04-01, 1996-10-01 

   modified to work for Int.precision = SOME 32  -- ME 1998-10-07
*)

(*KILL 05/11/1997 11:04. tho.:
use "auxil.sml";
*)

local 
    (* Isn't this disgusting: *)
    val [gt,  lt,  ge,   le] = 
	[op>, op<, op>=, op<=] : (int * int -> bool) list
    val [add, sub, mul, idiv,   imod] = 
	[op+, op-, op*, op div, op mod] : (int * int -> int) list
    open Word;
    val op > = gt and op < = lt and op >= = ge and op <= = le;
    val op + = add and op - = sub and op * = mul 
    and op div = idiv and op mod = imod;
    val i2w = fromInt
    and w2i = toIntX;
    fun pr_ln s s' = concatResult (s ^ ": " ^ s' ^ "\n")
in

val test1 = checkrange (0, 1025)
    (fn i => i = w2i (i2w i));
val _ = pr_ln "test1" test1

val test3 = checkrange (~1000, 1000) 
    (fn i => i = toIntX (i2w i));
val _ = pr_ln "test3" test3

val test5a = checkrange (0,15) 
    (fn i => (i+960) div 2 * 2 + 1
             = w2i (orb (i2w i, i2w 961)));
val _ = pr_ln "test5a" test5a
val test5b = checkrange (0,513)
    (fn i => i = w2i (orb (i2w i, i2w i)));
val _ = pr_ln "test5b" test5b
val test6a = checkrange (0,15) 
    (fn i => i div 2 * 2 = w2i (andb (i2w i, i2w ~2)));
val _ = pr_ln "test6a" test6a
val test6b = checkrange (0,513)
    (fn i => i = w2i (andb (i2w i, i2w i)));
val _ = pr_ln "test6b" test6b
val test7a = checkrange (0,15) 
    (fn i => i+960 = w2i (xorb (i2w i, i2w 960)));
val _ = pr_ln "test7a" test7a
val test7b = checkrange (0, 513)
    (fn i => 0 = w2i (xorb (i2w i, i2w i)));
val _ = pr_ln "test7b" test7b
val test8a = check(~1 = w2i (notb (i2w 0)));
val _ = pr_ln "test8a" test8a
val test8b = check (0 = w2i (notb (i2w ~1)));
val _ = pr_ln "test8b" test8b
val maxposint = valOf Int.maxInt;
val maxnegint = (Int.~ maxposint)-1;
fun pwr2 0 = 1 
  | pwr2 n = 2 * pwr2 (n-1);
fun rwp i 0 = i
  | rwp i n = rwp i (n-1) div 2;

val test9a = checkrange (0,29)
    (fn k => pwr2 k = w2i (<< (i2w 1, i2w k)));
val _ = pr_ln "test9a" test9a
val test9b = checkrange (32,65)
    (fn k => 0 = w2i (<< (i2w 1, i2w k)));
val _ = pr_ln "test9b" test9b
val test9c = check (maxnegint = w2i (<< (i2w 1, i2w 30)));
val _ = pr_ln "test9c" test9c
val test9d = checkrange (0, 1025)
    (fn i => 2 * i = w2i (<< (i2w i, i2w 1)));

end;

val result = !result

end