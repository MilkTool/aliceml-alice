import structure Tag     from "Tag"
import structure Meaning from "Meaning"
import structure Lex     from "Lex"

signature PARSE =
sig
    exception Invalid

    val parse : string -> Meaning.meaning * int		(* Invalid *)
end

structure Parse : PARSE =
struct
    exception Invalid = Lex.Invalid

    type context = Meaning.property

    val initial =
	{ b	= false
	, em	= false
	, i	= false
	, s	= false
	, tt	= false
	, u	= 0
	, size	= ~1		(* skolem *)
	, color	= Tag.UNKNOWN	(* skolem *)
	}

    fun modify(context, Tag.B)  = {context where b = true}
      | modify(context, Tag.EM) = if #s context then context : context else
				  {context where em = not(#em context)}
      | modify(context, Tag.I)  = {context where i = true}
      | modify(context, Tag.PL) = {initial where size  = #size context,
						 color = #color context}
      | modify(context, Tag.S)  = {context where s = true, em = false}
      | modify(context, Tag.TT) = {context where tt = true}
      | modify(context, Tag.U)  = {context where u = Int.max(3, #u context + 1)}
      | modify(context, Tag.SIZE n)  = {context where size = n}
      | modify(context, Tag.COLOR c) = {context where color = c}

    fun spacify(context : context) =
	{initial where tt = #tt context, u = #u context, size = #size context,
		       color = if #u context = 0 then Tag.W else #color context}

    fun text(x, contextUntouched, context, (xs, false, property) :: doc')
	where (contextUntouched orelse context = property) =
	    (x::xs, false, property) :: doc'
      | text(x, contextUntouched, context, doc) =
	    ([x], false, context) :: doc

    fun space(x, contextUntouched, space_context,
	      doc as (xs, spacy, property) :: doc')
	where (contextUntouched orelse space_context = spacify property) =
	    if not(#tt space_context) andalso (spacy orelse List.hd xs = " ")
	    then doc
	    else (x::xs, spacy, property) :: doc'
      | space(x, contextUntouched, space_context, doc) =
	    ([x], true, space_context) :: doc

    fun parse'( [],   contextUntouched, context, stack, doc, cost) = (doc, cost)
      | parse'(t::ts, contextUntouched, context, stack, doc, cost) =
	case t of
	     Lex.TEXT x =>
		parse'(ts, true, context, stack,
		       text(x, contextUntouched, context, doc), cost)
	   | Lex.SPACE x =>
		parse'(ts, true, context, stack,
		       space(if #tt context then x else " ", contextUntouched,
			     spacify context, doc), cost)
	   | Lex.OPEN t =>
		parse'(ts, false, modify(context,t),
		       (context,t)::stack, doc, cost + Tag.cost t)
	   | Lex.CLOSE t =>
		case stack of [] => raise Invalid | (context',t')::stack' =>
		if t <> t' then raise Invalid else
		parse'(ts, false, context', stack', doc, cost)

    fun parse s = parse'(Lex.lex s, true, initial, [], [], 0)
		  handle Future.Future(Invalid) => raise Invalid
end
