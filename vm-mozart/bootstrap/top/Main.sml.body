import
    structure TextIO
from "x-alice:/lib/TextIO.ozf"

import
    structure IO
from "x-alice:/lib/IO.ozf"

import
    structure OS
from "x-alice:/lib/OS.ozf"

import
    structure CommandLine
from "x-alice:/lib/CommandLine.ozf"

import
    structure Crash
from "x-alice:/error/Crash.ozf"

import
    structure Source
from "x-alice:/error/Source.ozf"

import
    structure FromEqHashKey
from "x-alice:/misc/HASH_KEY.ozf"

import
    structure MakeHashImpMap
from "x-alice:/misc/MakeHashImpMap.ozf"

import
    structure Url
from "x-alice:/misc/Url.ozf"

import
    structure Inf
from "x-alice:/common/Inf.ozf"

import
    structure ParsingPhase
from "x-alice:/frontend-sml/ParsingPhase.ozf"

import
    structure BindEnv
from "x-alice:/frontend-sml/BindEnv.ozf"

import
    structure BindEnv0
from "x-alice:/frontend-sml/BindEnv0.ozf"

import
    structure MakeAbstractionPhase
from "x-alice:/frontend-sml/MakeAbstractionPhase.ozf"

import
    structure Env
from "x-alice:/frontend-common/Env.ozf"

import
    structure Env0
from "x-alice:/frontend-common/Env0.ozf"

import
    structure MakeElaborationPhase
from "x-alice:/frontend-common/MakeElaborationPhase.ozf"

import
    structure TranslationPhase
from "x-alice:/frontend-common/TranslationPhase.ozf"

import
    structure FlatteningPhase
from "x-alice:/backend-common/FlatteningPhase.ozf"

import
    structure CodeGenPhase
from "x-alice:/backend-mozart/CodeGenPhase.ozf"

import
    signature SIGNATURE
from "x-alice:/top/SIGNATURE.ozf"

import
    structure Signature
from "x-alice:/top/Signature.ozf"

signature COMPOSER' =
    sig
	structure Sig: SIGNATURE

	exception Corrupt

	val sign:	Url.t -> Sig.t		(* [Corrupt, IO.Io] *)
	val start:	Url.t -> unit		(* [Corrupt, IO.Io] *)

	val setAcquisitionMethod: (Url.t -> Sig.t) -> unit
    end

structure Composer :> COMPOSER' where type Sig.t = Inf.sign =
    struct
	structure Sig = Signature

	exception Corrupt

	val acquire: (Url.t -> Sig.t) ref =
	    ref (fn _ => raise Crash.Crash "Composer.acquire")

	fun setAcquisitionMethod f = acquire := f

	structure UrlMap = MakeHashImpMap(FromEqHashKey(Url))

	val signTable: Sig.t UrlMap.t = UrlMap.new ()

	fun sign url =
	    case UrlMap.lookup (signTable, url) of
		SOME sign => sign
	      | NONE =>
		    let
			val sign = !acquire url
		    in
			UrlMap.insertDisjoint (signTable, url, sign);
			sign
		    end

	fun start url = ()
    end

structure AbstractionPhase = MakeAbstractionPhase(Composer)
structure ElaborationPhase = MakeElaborationPhase(Composer)

fun processString process source =
    process source
    handle exn as Crash.Crash message =>
	(TextIO.output(TextIO.stdErr, "CRASH: " ^ message ^ "\n"); raise exn)

fun processFile process name =
    let
	val file   = TextIO.openIn name
	val source = TextIO.inputAll file
	val _      = TextIO.closeIn file
    in
	processString process source
    end

fun parse' x     = ParsingPhase.translate () x
fun abstract' x  = AbstractionPhase.translate (BindEnv.clone BindEnv0.E0) x
fun elab' x      = ElaborationPhase.translate (Env.clone Env0.E0) x
fun translate' x = TranslationPhase.translate () x
fun flatten' x   = FlatteningPhase.translate () x

val parse        = parse' o Source.fromString
val abstract     = abstract' o parse
val elab         = elab' o abstract
val translate    = translate' o elab
val flatten      = flatten' o translate

fun mozartify inFilename outFilename s =
    let
	val component as (_, (_, exportSign)) = flatten s
    in
	CodeGenPhase.translate (inFilename, component, outFilename);
	exportSign
    end

(* Tell the composer how to compile Alice source files *)

fun parseUrl url =
    case (Url.getScheme url, Url.getAuthority url) of
	(NONE, NONE) =>
	    Url.toString (Url.setScheme (url, NONE))
      | (SOME "file", NONE) =>
	    Url.toString (Url.setScheme (url, NONE))
      | (SOME "x-alice", NONE) =>
	    Url.toString (Url.setScheme (Url.makeRelativePath url, NONE))
      | _ => raise Crash.Crash "Main.parseUrl"

fun existsFile filename =
    (TextIO.closeIn (TextIO.openIn filename); true) handle IO.Io _ => false

fun changeExtension (filename, fro, to) =
    let
	val n = String.size filename
	val m = String.size fro
    in
	if n > m andalso String.substring (filename, n - m, m) = fro then
	    let
		val newname = String.substring (filename, 0, n - m) ^ to
	    in
		if existsFile newname then SOME newname
		else NONE
	    end
	else NONE
    end

fun compileSign filename =
    let
	val _ = TextIO.print ("### reading signature file " ^ filename ^ "\n")
	val (_, (_, sign)) = processFile translate filename
	val _ = TextIO.print "### done\n"
    in
	case Inf.items sign of
	    [item] => Inf.asSig (valOf (#3 (Inf.asInfItem item)))
	  | _ => raise Crash.Crash "Composer.compileSign"
    end

val fileStack: string list ref = ref nil

fun compileForMozart (sourceFilename, targetFilename) =
    (TextIO.print ("### compiling file " ^ sourceFilename ^ "\n");
     fileStack := sourceFilename::(!fileStack);
     processFile (mozartify sourceFilename targetFilename) sourceFilename
     before (TextIO.print ("### wrote file " ^ targetFilename ^ "\n");
	     case fileStack of
		 ref (_::(rest as resumeFilename::_)) =>
		     (fileStack := rest;
		      TextIO.print ("### resuming compilation of " ^
				    resumeFilename ^ "\n"))
	       | ref _ => ()))

fun acquireSign url =
    let
	val targetFilename = parseUrl url
	val sigFilename = targetFilename ^ ".sig"
    in
	if existsFile sigFilename then compileSign sigFilename
	else
	    case changeExtension (targetFilename, ".ozf", ".sml") of
		SOME sourceFilename =>
		    compileForMozart (sourceFilename, targetFilename)
	      | NONE =>
		    case changeExtension (targetFilename, ".ozf", ".sig") of
			SOME sourceFilename =>
			    compileForMozart (sourceFilename, targetFilename)
		      | NONE =>
			    (TextIO.print
			     ("### warning: could not locate source for " ^
			      targetFilename ^ "\n");
			     Inf.empty ())
    end

val _ = Composer.setAcquisitionMethod acquireSign

local
    fun stoc [infile, outfile] =
	(compileForMozart (infile, outfile); OS.Process.success)
      | stoc _ = OS.Process.failure
in
    val _ = OS.Process.exit (stoc (CommandLine.arguments ()))
end
