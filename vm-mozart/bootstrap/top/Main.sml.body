(* -*- sml -*- *)

import
    structure TextIO
from "x-alice:/lib/TextIO.ozf"

import
    structure IO
from "x-alice:/lib/IO.ozf"

import
    structure OS
from "x-alice:/lib/OS.ozf"

import
    structure CommandLine
from "x-alice:/lib/CommandLine.ozf"

import
    structure Pickle
from "x-alice:/lib/Pickle.ozf"

import
    structure Crash
from "x-alice:/error/Crash.ozf"

import
    structure Source
from "x-alice:/error/Source.ozf"

import
    structure Error
from "x-alice:/error/Error.ozf"

import
    structure FromEqHashKey
from "x-alice:/misc/HASH_KEY.ozf"

import
    structure MakeHashImpMap
from "x-alice:/misc/MakeHashImpMap.ozf"

import
    structure Url
from "x-alice:/misc/Url.ozf"

import
    structure Inf
from "x-alice:/common/Inf.ozf"

import
    structure ParsingPhase
from "x-alice:/frontend-sml/ParsingPhase.ozf"

import
    structure BindEnv
from "x-alice:/frontend-sml/BindEnv.ozf"

import
    structure BindEnv0
from "x-alice:/frontend-sml/BindEnv0.ozf"

import
    structure MakeAbstractionPhase
from "x-alice:/frontend-sml/MakeAbstractionPhase.ozf"

import
    structure Env
from "x-alice:/frontend-common/Env.ozf"

import
    structure Env0
from "x-alice:/frontend-common/Env0.ozf"

import
    structure MakeElaborationPhase
from "x-alice:/frontend-common/MakeElaborationPhase.ozf"

import
    structure TranslationPhase
from "x-alice:/frontend-common/TranslationPhase.ozf"

import
    structure FlatteningPhase
from "x-alice:/backend-common/FlatteningPhase.ozf"

import
    structure CodeGenPhase
from "x-alice:/backend-mozart/CodeGenPhase.ozf"

import
    structure Switches
from "x-alice:/top/Switches.ozf"

import
    signature SIGNATURE
from "x-alice:/top/SIGNATURE.ozf"

import
    structure Signature
from "x-alice:/top/Signature.ozf"

import
    structure Composer
from "x-alice:/top/Composer.ozf"

structure AbstractionPhase = MakeAbstractionPhase(Composer)
structure ElaborationPhase = MakeElaborationPhase(Composer)

fun readFile filename =
    let
	val file   = TextIO.openIn filename
	val source = TextIO.inputAll file
	val _      = TextIO.closeIn file
    in
	source
    end

fun readDefaultImport () =
    case OS.Process.getEnv "STOCKHOME" of
	SOME homedir =>
	    String.map (fn #"\n" => #" " | c => c)
	    (readFile (homedir ^ "/Default.import")) ^ "\n"
      | NONE =>
	    (TextIO.print "### warning: could not load Default.import\n"; "")

val defaultImport = ref ""
val outputAssembly = ref false

fun processString process source =
    process (!defaultImport ^ source)
    handle exn as Crash.Crash message =>
	(TextIO.output(TextIO.stdErr, "CRASH: " ^ message ^ "\n"); raise exn)

fun processFile process filename = processString process (readFile filename)

fun parse' x     = ParsingPhase.translate () x
fun abstract' x  = AbstractionPhase.translate (BindEnv.clone BindEnv0.E0) x
fun elab' x      = ElaborationPhase.translate (Env.clone Env0.E0) x
fun translate' x = TranslationPhase.translate () x
fun flatten' x   = FlatteningPhase.translate () x

val parse        = parse' o Source.fromString
val abstract     = abstract' o parse
val elab         = elab' o abstract
val translate    = translate' o elab
val flatten      = flatten' o translate

fun mozartify (inFilename, outFilename, header) s =
    let
	val component as (_, (_, exportSign)) = flatten s
    in
	CodeGenPhase.translate (inFilename, component, outFilename,
				if !outputAssembly then
				    SOME (outFilename ^ ".ozm")
				else NONE, header);
	exportSign
    end

(* Tell the composer how to compile Alice source files *)

fun parseUrl url =
    case (Url.getScheme url, Url.getAuthority url) of
	(NONE, NONE) =>
	    Url.toString (Url.setScheme (url, NONE))
      | (SOME "file", NONE) =>
	    Url.toString (Url.setScheme (url, NONE))
      | (SOME "x-alice", NONE) =>
	    Url.toString (Url.setScheme (Url.makeRelativePath url, NONE))
      | _ => raise Crash.Crash "Main.parseUrl"

fun existsFile filename =
    (TextIO.closeIn (TextIO.openIn filename); true) handle IO.Io _ => false

fun changeExtension (filename, fro, to) =
    let
	val n = String.size filename
	val m = String.size fro
    in
	if n > m andalso String.substring (filename, n - m, m) = fro then
	    let
		val newname = String.substring (filename, 0, n - m) ^ to
	    in
		if existsFile newname then SOME newname
		else NONE
	    end
	else NONE
    end

fun compileSign filename =
    let
	val _ = TextIO.print ("### reading signature file " ^ filename ^ "\n")
	val (_, (_, sign)) = processFile translate filename
	val _ = TextIO.print "### done\n"
    in
	case Inf.items sign of
	    [item] => Inf.asSig (valOf (#3 (Inf.asInfItem item)))
	  | _ => raise Crash.Crash "Composer.compileSign"
    end

val fileStack: string list ref = ref nil

fun compileForMozart (sourceFilename, targetFilename, header) =
    (TextIO.print ("### compiling file " ^ sourceFilename ^ "\n");
     fileStack := sourceFilename::(!fileStack);
     processFile (mozartify (sourceFilename, targetFilename, header))
     sourceFilename
     before (TextIO.print ("### wrote file " ^ targetFilename ^ "\n");
	     case fileStack of
		 ref (_::(rest as resumeFilename::_)) =>
		     (fileStack := rest;
		      TextIO.print ("### resuming compilation of " ^
				    resumeFilename ^ "\n"))
	       | ref _ => ()))

local
    exception RETURN of Composer.Sig.t
in
    fun acquireSign url =
	(case Pickle.loadSign url of
	     SOME sign =>
		 (TextIO.print ("### loaded signature from " ^
				Url.toString url ^ "\n");
		  raise RETURN sign)
	   | NONE => ();
	 let
	     val targetFilename = parseUrl url
	     val sigFilename = targetFilename ^ ".sig"
	 in
	     if existsFile sigFilename then
		 raise RETURN (compileSign sigFilename)
	     else ();
	     case changeExtension (targetFilename, ".ozf", ".aml") of
		 SOME sourceFilename =>
		     raise RETURN (compileForMozart
				  (sourceFilename, targetFilename, ""))
	       | NONE => ();
	     case changeExtension (targetFilename, ".ozf", ".sml") of
		 SOME sourceFilename =>
		     raise RETURN (compileForMozart
				  (sourceFilename, targetFilename, ""))
	       | NONE => ();
	     case changeExtension (targetFilename, ".ozf", ".sig") of
		 SOME sourceFilename =>
		     raise RETURN (compileForMozart
				  (sourceFilename, targetFilename, ""))
	       | NONE => ();
	     TextIO.print ("### warning: could not locate source for " ^
			   targetFilename ^ "\n");
	     Inf.empty ()
	 end) handle RETURN sign => sign
end

val _ = Composer.setAcquisitionMethod acquireSign

local
    fun basename filename =
	let
	    fun cutPath ((#"/" | #"\\")::rest) = nil
	      | cutPath (c::rest) = c::cutPath rest
	      | cutPath nil = nil
	    val cs = cutPath (List.rev (String.explode filename))
	    fun cutExtension (#"."::rest) =
		(case rest of
		     (#"/" | #"\\")::_ => cs
		   | _::_ => rest
		   | nil => cs)
	      | cutExtension ((#"/" | #"\\")::_) = cs
	      | cutExtension (_::rest) = cutExtension rest
	      | cutExtension nil = cs
	in
	    String.implode (List.rev (case cs of
					  #"."::_ => cs
					| _ => cutExtension cs))
	end

    val executableHeader = "#!/bin/sh\nexec stow $0 \"$@\"\n"

    fun stoc_c (infile, outfile) =
	(compileForMozart (infile, outfile, "");
	 OS.Process.success)

    fun stoc_x (infile, outfile) =
	(compileForMozart (infile, outfile, executableHeader);
	 OS.Process.system ("chmod +x " ^ outfile))

    fun usage () =
	TextIO.output (TextIO.stdErr,
		       "Usage:\n\
		       \\tstoc [<option> ...] [-c|-x] <input file> \
		       \[-o <output file>]\n\
		       \\tstoc --replacesign <input url> <signature file> \
		       \<output file>\n\
		       \Options:\n\
		       \\t--nodefaultimport\n\
		       \\t\tDo not make the SML Standard Basis available.\n\
		       \\t--outputassembly\n\
		       \\t\tWrite an .ozm file with the assembly code.\n")

    fun stoc' ([infile] | ["-c", infile]) =
	stoc_c (infile, basename infile ^ ".ozf")
      | stoc' ["-x", infile] =
	stoc_x (infile, basename infile)
      | stoc' ([infile, "-o", outfile] | ["-c", infile, "-o", outfile]) =
	stoc_c (infile, outfile)
      | stoc' ["-x", infile, "-o", outfile] =
	stoc_x (infile, outfile)
      | stoc' _ = (usage (); OS.Process.failure)

    fun defaults () =
	(defaultImport := readDefaultImport ();
	 outputAssembly := false;
	 Switches.printComponentSig := true)

    fun options ("--nodefaultimport"::rest) =
	(defaultImport := ""; options rest)
      | options ("--outputassembly"::rest) =
	(outputAssembly := true; options rest)
      | options ("--noprintcomponentsig"::rest) =
	(Switches.printComponentSig := false; options rest)
      | options rest = rest

    fun stoc ["--replacesign", infile, signfile, outfile] =
	(defaultImport := readDefaultImport ();
	 Pickle.replaceSign (Url.fromString infile,
			     compileSign signfile, outfile);
	 OS.Process.success)
      | stoc args =
	(defaults (); stoc' (options args))
	handle Error.Error (_, _) => OS.Process.failure
in
    val _ = OS.Process.exit (stoc (CommandLine.arguments ()))
end
