(* grammar for jacke's own parser *)

structure A = AbsSyn
datatype ('a,'b) sum = In1 of 'a | In2 of 'b

fun lookup "bogus" = 10000
  | lookup s = 0

%%

%eop EOF

(* %pos declares the type of positions for terminals.
   Each symbol has an associated left and right position. *)

%term     EOF 
  | ID of string
  | INT of int | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK
  | LBRACE | RBRACE | UMINUS
  | EQ | IF | THEN | ELSE | LET | IN | END | AND | OF | AS 
  | MAPSTO | BAR | LOCAL | ABSTYPE | WITH
(* jacke extensions *)
  | TOKEN | ASSOCL | ASSOCR | NONASSOC | RULE | PARSER | PREC | SKIP
(* others *)
  | DECINTRO of string | MLOP of string | MLKEY of string 

%nonterm  start of A.parsetreeWithPos list 
	| jackedec of A.parsetreeWithPos 
	| tokbinds of (string * string option) list 
	| tokbind of string * string option 
	| idlist of string list
	| rulebinds of A.Prule list | rulebind of A.Prule 
	| parsbinds of (string*string option * string) list 
	| parsbind of string * string option * string 
	| bnfexp of A.bnfexpWithPos 
	| exp of string list | explist of string list
	| program of A.parsetreeWithPos list
   

%pos int
%verbose
%start start
%eop EOF
%noshift EOF

%name jacke

%keyword LET LOCAL IN END IF THEN ELSE AND TOKEN OF AS 
         ASSOCL ASSOCR NONASSOC RULE PARSER PREC SKIP


%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

(* precedence annotations *)
%nonassoc EQ
%left AND
%left SKIP
%left BAR
%left MAPSTO
%left PREC
%left COMMA
%left AS


%%

(* the (somewhat incomplete and simplified) grammar *)

start : program (rev program)
	| ([])

program : jackedec ([jackedec])
	| exp ([A.PMLCode (exp,expleft,expright)])
	| program jackedec (jackedec::program)
	| program exp ((A.PMLCode (exp,expleft,expright))::program)

jackedec : TOKEN tokbinds (A.PTokenDec(tokbinds,TOKENleft,tokbindsright))
        | ASSOCL idlist (A.PAssoclDec(idlist,ASSOCLleft,idlistright))
	| ASSOCR idlist (A.PAssocrDec(idlist,ASSOCRleft,idlistright))
	| NONASSOC idlist (A.PNonassocDec(idlist,NONASSOCleft,idlistright))
	| RULE rulebinds (A.PRuleDec(rev rulebinds,RULEleft,rulebindsright))
	| PARSER parsbinds (A.PParserDec(parsbinds,PARSERleft,parsbindsright))
 
tokbinds : tokbind ([tokbind])
	| tokbind BAR tokbinds (tokbind::tokbinds)

tokbind : ID ((ID,NONE))
	| ID OF ID ((ID1,SOME ID2))

idlist  : ID ([ID])
	| ID idlist (ID::idlist)

rulebinds : rulebind ([rulebind])
	| rulebinds AND rulebind (rulebind::rulebinds)

rulebind : ID EQ bnfexp ((ID,NONE,bnfexp))
	| ID COLON ID EQ bnfexp ((ID1,SOME ID2,bnfexp))

parsbinds : parsbind ([parsbind])
	| parsbinds AND parsbind (parsbind::parsbinds)

parsbind : ID EQ ID ((ID1,NONE,ID2))
	| ID COLON ID EQ ID ((ID1,SOME ID2,ID3))

bnfexp : SKIP (A.PSkip)
	| ID (A.PSymbol(ID,IDleft,IDright))
	| LPAREN bnfexp RPAREN (bnfexp)
	| ID AS bnfexp (A.PAs(ID,bnfexp,IDleft,bnfexpright))
	| bnfexp COMMA bnfexp (A.PSeq([bnfexp1,bnfexp2],bnfexp1left,bnfexp2right))
	| bnfexp PREC ID (A.PPrec(bnfexp,ID,bnfexpleft,IDright))
	| bnfexp MAPSTO LPAREN explist RPAREN (A.PTransform(bnfexp,explist,bnfexpleft,RPARENright))
	| bnfexp BAR bnfexp (A.PAlt([bnfexp1,bnfexp2],bnfexp1left,bnfexp2right)) 

explist : ([])
	| explist exp (explist@exp)

exp  :  LPAREN explist RPAREN ("("::(explist@[")"]))
	| LBRACE explist RBRACE ("{"::(explist@["}"]))
	| STRING (["\""^STRING^"\""]) 
        | INT ([Int.toString INT])
	| LBRACK explist RBRACK ("["::(explist@["]"]))
	| ID ([ID])
	| EQ (["="])
	| COMMA ([","])
        | COLON ([":"])
        | SEMICOLON ([";"])
        | AND (["and"])
        | OF (["of"])
        | BAR (["|"])
	| MLKEY ([MLKEY])
	| MLOP  ([MLOP])
        | UMINUS (["~"])
	| MAPSTO (["=>"])
        | DECINTRO ([DECINTRO])
