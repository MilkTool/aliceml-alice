(* grammar for jacke's own parser *)

structure A = AbsSyn
datatype ('a,'b) sum = In1 of 'a | In2 of 'b

fun lookup "bogus" = 10000
  | lookup s = 0

%%

%eop EOF

(* %pos declares the type of positions for terminals.
   Each symbol has an associated left and right position. *)

%term     EOF 
  | ID of string
  | INT of int | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK
  | LBRACE | RBRACE | UMINUS
  | EQ | IF | THEN | ELSE | LET | IN | END | AND | OF | AS 
  | MAPSTO | BAR | LOCAL | ABSTYPE | WITH
(* jacke extensions *)
  | TOKEN | ASSOCL | ASSOCR | NONASSOC | RULE | PARSER | PREC | SKIP
(* others *)
  | DECINTRO of string | MLOP of string | MLKEY of string 

%nonterm  start of A.parsetree list 
	| jackedec of A.parsetree 
	| tokbinds of (string * string option) list 
	| tokbind of string * string option 
	| idlist of string list
	| rulebinds of A.rule list | rulebind of A.rule 
	| parsbinds of (string*string option * string) list 
	| parsbind of string * string option * string 
	| bnfexp of A.bnfexp 
	| exp of string list | explist of string list
	| program of A.parsetree list
   

%pos int
%verbose
%start start
%eop EOF
%noshift EOF

%name jacke

%keyword LET LOCAL IN END IF THEN ELSE AND TOKEN OF AS 
         ASSOCL ASSOCR NONASSOC RULE PARSER PREC SKIP


%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

(* precedence annotations *)
%nonassoc EQ
%left AND
%left SKIP
%left BAR
%left MAPSTO
%left PREC
%left COMMA
%left AS


%%

(* the (somewhat incomplete and simplified) grammar *)

start : program (rev program)
	| ([])

program : jackedec ([jackedec])
	| exp ([A.MLCode (exp)])
	| program jackedec (jackedec::program)
	| program exp ((A.MLCode (exp))::program)

jackedec : TOKEN tokbinds (A.TokenDec(tokbinds))
        | ASSOCL idlist (A.AssoclDec(idlist))
	| ASSOCR idlist (A.AssocrDec(idlist))
	| NONASSOC idlist (A.NonassocDec(idlist))
	| RULE rulebinds (A.RuleDec(rev rulebinds))
	| PARSER parsbinds (A.ParserDec(parsbinds))
 
tokbinds : tokbind ([tokbind])
	| tokbind BAR tokbinds (tokbind::tokbinds)

tokbind : ID ((ID,NONE))
	| ID OF ID ((ID1,SOME ID2))

idlist  : ID ([ID])
	| ID idlist (ID::idlist)

rulebinds : rulebind ([rulebind])
	| rulebinds AND rulebind (rulebind::rulebinds)

rulebind : ID EQ bnfexp ((ID,NONE,bnfexp))
	| ID COLON ID EQ bnfexp ((ID1,SOME ID2,bnfexp))

parsbinds : parsbind ([parsbind])
	| parsbinds AND parsbind (parsbind::parsbinds)

parsbind : ID EQ ID ((ID1,NONE,ID2))
	| ID COLON ID EQ ID ((ID1,SOME ID2,ID3))

bnfexp : SKIP (A.Skip)
	| ID (A.Symbol(ID))
	| LPAREN bnfexp RPAREN (bnfexp)
	| ID AS bnfexp (A.As(ID,bnfexp))
	| bnfexp COMMA bnfexp (A.Seq([bnfexp1,bnfexp2]))
	| bnfexp PREC ID (A.Prec(bnfexp,ID))
	| bnfexp MAPSTO LPAREN explist RPAREN (A.Transform(bnfexp,explist))
	| bnfexp BAR bnfexp (A.Alt([bnfexp1,bnfexp2])) 

explist : ([])
	| explist exp (explist@exp)

exp  :  LPAREN explist RPAREN ("("::(explist@[")"]))
	| LBRACE explist RBRACE ("{"::(explist@["}"]))
	| STRING (["\""^STRING^"\""]) 
        | INT ([Int.toString INT])
	| LBRACK explist RBRACK ("["::(explist@["]"]))
	| ID ([ID])
	| EQ (["="])
	| COMMA ([","])
        | COLON ([":"])
        | SEMICOLON ([";"])
        | AND (["and"])
        | OF (["of"])
        | BAR (["|"])
	| MLKEY ([MLKEY])
	| MLOP  ([MLOP])
        | UMINUS (["~"])
	| MAPSTO (["=>"])
        | DECINTRO ([DECINTRO])
