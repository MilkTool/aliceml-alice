(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 1999
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(* Hardwired *)

__prebound Prebound

datatype bool   = datatype Prebound.bool
type     int    = Prebound.int
type     word   = Prebound.word
type     real   = Prebound.real
type     string = Prebound.string
type     char   = Prebound.char
type  'a vector = 'a Prebound.vector
datatype list   = datatype Prebound.list
datatype ref    = datatype Prebound.ref
datatype exn    = datatype Prebound.exn

exception Match = Prebound.Match
exception Bind  = Prebound.Bind


(* Toplevel *)

infix  7  * / div mod
infix  6  + - ^
infixr 5  :: @
infix  4  = <> > >= < <=
infix  3  := o
infix  0  before

(*--** __primitive val use : string -> unit = "use" *)

__primitive val op=  : ''a * ''a -> bool = "="
__primitive val op<> : ''a * ''a -> bool = "<>"


(* Overloaded Identifiers *)

__primitive val op~ :	int -> int = "Int.~"

__primitive val op+ :	int * int -> int = "Int.+"
__primitive val op- :	int * int -> int = "Int.-"
__primitive val op* :	int * int -> int = "Int.*"
__primitive val op/ : real * real -> real = "Real./"

__primitive val op div:	int * int -> int = "Int.div"
__primitive val op mod:	int * int -> int = "Int.mod"
__primitive val abs:	int -> int = "Int.abs"

__primitive val op< :	int * int -> bool = "Int.<"
__primitive val op> :	int * int -> bool = "Int.>"
__primitive val op<= :	int * int -> bool = "Int.<="
__primitive val op>= :	int * int -> bool = "Int.>="


(* General *)

signature GENERAL =
  sig
    eqtype unit
    type exn

    exception Bind
    exception Chr
    exception Div
    exception Domain
    exception Fail of string
    exception Match
    exception Overflow
    exception Size
    exception Span
    exception Subscript

(*MISSING
    val exnName : exn -> string
    val exnMessage : exn -> string
*)

    datatype order = LESS | EQUAL | GREATER
    val ! : 'a ref -> 'a
    val := : 'a ref * 'a -> unit
    val o: ('b -> 'c) * ('a -> 'b) -> 'a -> 'c
    val before: 'a * unit -> 'a
    val ignore: 'a -> unit
  end


structure General: GENERAL =
  struct

    type unit = {}
    type exn  = exn

    exception Bind = Bind
    __primitive constructor Chr: exn = "General.Chr"
    __primitive constructor Div: exn = "General.Div"
    __primitive constructor Domain: exn = "General.Domain"
    __primitive constructor Fail of string: exn = "General.Fail"
    exception Match = Match
    __primitive constructor Overflow: exn = "General.Overflow"
    __primitive constructor Size: exn = "General.Size"
    __primitive constructor Span: exn = "General.Span"
    __primitive constructor Subscript: exn = "General.Subscript"

    datatype order = LESS | EQUAL | GREATER

    fun !(ref v) = v

    __primitive val op:= : 'a ref * 'a -> unit = "General.:="

    fun (f o g) a  = f(g a)
    fun a before b = a
    fun ignore a   = ()

  end

open General


(* Option *)

signature OPTION =
  sig
    datatype 'a option = NONE | SOME of 'a

    exception Option

    val getOpt : 'a option * 'a -> 'a
    val isSome : 'a option -> bool
    val valOf : 'a option -> 'a
    val filter : ('a -> bool) -> 'a -> 'a option
    val join : 'a option option -> 'a option
    val map : ('a -> 'b) -> 'a option -> 'b option
    val mapPartial : ('a -> 'b option) -> 'a option -> 'b option
    val compose : ('a -> 'c) * ('b -> 'a option) -> 'b -> 'c option
    val composePartial : ('a -> 'c option) * ('b -> 'a option)
                         -> 'b -> 'c option
  end

structure Option: OPTION =
  struct

    datatype 'a option = NONE | SOME of 'a

    __primitive constructor Option: exn = "Option.Option"

    fun getOpt(SOME v, _) = v
      | getOpt(NONE,   a) = a

    fun isSome(SOME v) = true
      | isSome NONE    = false

    fun valOf(SOME v) = v
      | valOf NONE    = raise Option

    fun filter f a = if f a then SOME a else NONE

    fun join NONE    = NONE
      | join(SOME v) = v

    fun map f  NONE    = NONE
      | map f (SOME v) = SOME(f v)

    fun mapPartial f  NONE    = NONE
      | mapPartial f (SOME v) = f v

    fun compose (f,g) a =
	case g a
	  of NONE   => NONE
	   | SOME v => SOME(f v)

    fun composePartial (f,g) a =
	case g a
	  of NONE   => NONE
	   | SOME v => f v

  end

datatype option = datatype Option.option


(* Bool *)

signature BOOL =
  sig
    datatype bool = false | true
    val not : bool -> bool
    val toString : bool -> string
(*MISSING
    val fromString : string -> bool option
    val scan : (char,'a) StringCvt.reader -> (bool,'a) StringCvt.reader
*)
  end

structure Bool: BOOL =
  struct

    datatype bool = datatype bool

    fun not true  = false
      | not false = true

    fun toString true  = "true"  : string
      | toString false = "false" : string

  end

val not = Bool.not


(* List *)

signature LIST =
  sig
    datatype 'a list = :: of 'a * 'a list | nil

    exception Empty

    val null : 'a list -> bool
    val hd : 'a list -> 'a
    val tl : 'a list -> 'a list
    val last : 'a list -> 'a
    val getItem : 'a list -> ('a * 'a list) option
    val nth : 'a list * int -> 'a
    val take : 'a list * int -> 'a list
    val drop : 'a list * int -> 'a list
    val length : 'a list -> int
    val rev : 'a list -> 'a list
    val @ : 'a list * 'a list -> 'a list
    val concat : 'a list list -> 'a list
    val revAppend : 'a list * 'a list -> 'a list
    val app : ('a -> unit) -> 'a list -> unit
    val map : ('a -> 'b) -> 'a list -> 'b list
    val mapPartial : ('a -> 'b option) -> 'a list -> 'b list
    val find : ('a -> bool) -> 'a list -> 'a option
    val filter : ('a -> bool) -> 'a list -> 'a list
    val partition : ('a -> bool) -> 'a list -> 'a list * 'a list
    val foldr : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
    val foldl : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
    val exists : ('a -> bool) -> 'a list -> bool
    val all : ('a -> bool) -> 'a list -> bool
    val tabulate : int * (int -> 'a) -> 'a list
  end

structure List: LIST =
  struct

    datatype list = datatype list

    __primitive constructor Empty: exn = "List.Empty"

    fun null [] = true
      | null _  = false

    fun length xs =
	let fun length'(nil,   n) = n
	      | length'(y::ys, n) = length'(ys,n+1)
	in length'(xs,0) end

    fun   nil   @ ys = ys
      | (x::xs) @ ys = x :: xs @ ys

    fun hd(x::xs) = x
      | hd  _     = raise Empty

    fun tl(x::xs) = xs
      | tl  _     = raise Empty

    fun last(x::nil) = x
      | last(x::xs)  = last xs
      | last  nil    = raise Empty

    fun getItem(x::xs) = SOME(x,xs)
      | getItem  nil   = NONE

    fun nth(l,i) =
	let fun nth'(x::xs, 0) = x
	      | nth'(x::xs, j) = nth'(xs, j-1)
	      | nth'(nil,   j) = raise Subscript
	in if i >= 0 then nth'(l,i) else raise Subscript end

    fun rev l =
	let fun rev'( nil,  ys) = ys
	      | rev'(x::xs, ys) = rev'(xs, x::ys)
	in rev'(l,nil) end

    fun take(l,i) =
	let fun take'(x::xs, 0, ys) = rev ys
	      | take'(x::xs, j, ys) = take'(xs, j-1, x::ys)
	      | take'(nil,   j, ys) = raise Subscript
	in if i >= 0 then take'(l,i,nil) else raise Subscript end

    fun drop(l,i) =
	let fun drop'(xs,    0) = xs
	      | drop'(x::xs, j) = drop'(xs, j-1)
	      | drop'(nil,   j) = raise Subscript
	in if i >= 0 then drop'(l,i) else raise Subscript end

    fun concat  nil   = nil
      | concat(l::ls) = l @ concat ls

    fun revAppend( nil,  ys) = ys
      | revAppend(x::xs, ys) = revAppend(xs, x::ys)

    fun app f   nil   = ()
      | app f (x::xs) = (f x ; app f xs)

    fun map f   nil   = nil
      | map f (x::xs) = f x :: map f xs

    fun mapPartial f   nil   = nil
      | mapPartial f (x::xs) =
	let val yo = f x
	    val ys = mapPartial f xs
	in case yo of NONE => ys | SOME y => y::ys end

    fun find f   nil   = NONE
      | find f (x::xs) = if f x then SOME x else find f xs

    fun filter f   nil   = nil
      | filter f (x::xs) =
	let val b  = f x
	    val ys = filter f xs
	in if b then x::ys else ys end

    fun partition f l =
	let fun partition'( nil,  pos, neg) = (rev pos, rev neg)
	      | partition'(x::xs, pos, neg) =
		if f x then partition'(xs, x::pos, neg)
		       else partition'(xs, pos, x::neg)
	in partition'(l,nil,nil) end

    fun foldl f b   nil   = b
      | foldl f b (x::xs) = foldl f (f(x,b)) xs

    fun foldr f b   nil   = b
      | foldr f b (x::xs) = f(x, foldr f b xs)

    fun exists f   nil   = false
      | exists f (x::xs) = f x orelse exists f xs

    fun all f   nil   = true
      | all f (x::xs) = f x andalso all f xs

    fun tabulate(n, f) =
	let fun tabulate'(i,l) = if i = n then rev l
					  else tabulate'(i+1, f i :: l)
	in if n >= 0 then tabulate'(0, nil) else raise Size end

  end


(* ListPair *)

signature LIST_PAIR =
  sig
    val zip : 'a list * 'b list -> ('a * 'b) list
    val unzip : ('a * 'b) list -> 'a list * 'b list
    val map : ('a * 'b -> 'c) -> 'a list * 'b list -> 'c list
    val app : ('a * 'b -> unit) -> 'a list * 'b list -> unit
    val foldl : ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c
    val foldr : ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c
    val all : ('a * 'b -> bool) -> 'a list * 'b list -> bool
    val exists : ('a * 'b -> bool) -> 'a list * 'b list -> bool
  end

structure ListPair: LIST_PAIR =
  struct

    fun zip(l1, l2) =
	let fun zip'( nil,    _,   l) = List.rev l
	      | zip'(  _,    nil,  l) = List.rev l
	      | zip'(x::xs, y::ys, l) = zip'(xs, ys, (x,y)::l)
	in zip'(l1, l2, nil) end

    fun unzip l =
	let fun unzip'(    nil,   l1, l2) = (List.rev l1, List.rev l2)
	      | unzip'((x,y)::l', l1, l2) = unzip'(l', x::l1, y::l2)
	in unzip'(l, nil, nil) end

    fun map f ( nil,    _  ) = nil
      | map f (  _,    nil ) = nil
      | map f (x::xs, y::ys) = f(x,y) :: map f (xs,ys)

    fun app f ( nil,    _  ) = ()
      | app f (  _,    nil ) = ()
      | app f (x::xs, y::ys) = (f(x,y) ; app f (xs,ys))

    fun foldl f c ( nil,    _  ) = c
      | foldl f c (  _,    nil ) = c
      | foldl f c (x::xs, y::ys) = f(x, y, foldl f c (xs,ys))

    fun foldr f c ( nil,    _  ) = c
      | foldr f c (  _,    nil ) = c
      | foldr f c (x::xs, y::ys) = foldr f (f(x,y,c)) (xs,ys)

    fun exists f ( nil,    _  ) = false
      | exists f (  _,    nil ) = false
      | exists f (x::xs, y::ys) = f(x,y) orelse exists f (xs,ys)

    fun all f ( nil,    _  ) = true
      | all f (  _,    nil ) = true
      | all f (x::xs, y::ys) = f(x,y) andalso all f (xs,ys)

  end


(* Char *)

signature CHAR =
  sig
    type char

    val chr : int -> char
    val ord : char -> int

(*MISSING
    val minChar : char
    val maxChar : char
    val maxOrd : int
    val pred : char -> char
    val succ : char -> char
    val < : char * char -> bool
*)
    val <= : char * char -> bool
(*MISSING
    val > : char * char -> bool
    val >= : char * char -> bool
    val compare : char * char -> order
    val scan : (char,'a) StringCvt.reader -> (char,'a) StringCvt.reader
    val fromString : string -> char option
    val toString : char -> string
    val fromCString : string -> char option
*)
    val toCString : char -> string
(*MISSING
    val contains : string -> char -> bool
    val notContains : string -> char -> bool
    val isLower : char -> bool
    val isUpper : char -> bool
*)
    val isDigit : char -> bool
(*MISSING
    val isAlpha : char -> bool
*)
    val isHexDigit : char -> bool
    val isAlphaNum : char -> bool
(*MISSING
    val isPrint : char -> bool
*)
    val isSpace : char -> bool
(*MISSING
    val isPunct : char -> bool
    val isGraph : char -> bool
    val isCntrl : char -> bool
    val isAscii : char -> bool
    val toUpper : char -> char
*)
    val toLower : char -> char
  end

structure Char: CHAR =
    struct
	type char = char

	__primitive val <= : char * char -> bool = "Char.<="

	__primitive val ord : char -> int = "Char.ord"
	__primitive val chr : int -> char = "Char.chr"

	__primitive val isAlphaNum : char -> bool = "Char.isAlphaNum"
	__primitive val isDigit :    char -> bool = "Char.isDigit"
	__primitive val isHexDigit : char -> bool = "Char.isHexDigit"
	__primitive val isSpace :    char -> bool = "Char.isSpace"
	__primitive val toLower :    char -> char = "Char.toLower"

	__primitive val toCString :  char -> string = "Char.toCString"
    end


(* String *)

signature STRING =
  sig
    type string

(*MISSING
    val maxSize : int
*)
    val size : string -> int
    val sub : string * int -> char
    val substring : string * int * int -> string
    val extract : string * int * int option -> string
    val concat : string list -> string
    val ^ : string * string -> string
    val str : char -> string
    val implode : char list -> string
    val explode : string -> char list
(*MISSING
    val fromString : string -> string option
    val toString : string -> string
    val fromCString : string -> string option
*)
    val toCString : string -> string
    val map : (char -> char) -> string -> string
(*MISSING
    val translate : (char -> string) -> string -> string
*)
    val tokens : (char -> bool) -> string -> string list
(*MISSING
    val fields : (char -> bool) -> string -> string list
    val isPrefix : string -> string -> bool
*)
    val compare : string * string -> order
(*MISSING
    val collate : (char * char -> order) -> string * string -> order
*)
    val <= : string * string -> bool
    val < : string * string -> bool
    val >= : string * string -> bool
    val > : string * string -> bool
  end

structure String: STRING =
    struct
	type string = string

	__primitive val op^ : string * string -> string = "String.^"
	__primitive val str : char -> string = "String.str"
	__primitive val size : string -> int = "String.size"
	__primitive val substring : string * int * int -> string =
							"String.substring"
	__primitive val sub : string * int -> char = "String.sub"
	__primitive val explode : string -> char list = "String.explode"

	fun extract (s, i, NONE) = substring (s, i, size s - i)
	  | extract (s, i, SOME j) = substring (s, i, j)

	fun concat l = List.foldr (fn (s, rest) => s ^ rest) "" l

	fun toCString s =
	    List.foldr (fn (c, rest) => Char.toCString c ^ rest) "" (explode s)

	fun implode l = concat (List.map str l)

	fun map f s = implode (List.map f (explode s))

	__primitive val compare : string * string -> order = "String.compare"

	fun s < t = compare (s, t) = LESS

	local
	    fun token (c::cr, f) =
		if f c then
		    let
			val (cs, rest) = token (cr, f)
		    in
			(c::cs, rest)
		    end
		else (nil, cr)
	      | token (nil, _) = (nil, nil)

	    fun tokens' (c::cr, f) =
		if f c then tokens' (cr, f)
		else
		    let
			val (cs, rest) = token (cr, f)
		    in
			implode (c::cs)::tokens' (rest, f)
		    end
	      | tokens' (nil, _) = nil
	in
	    fun tokens f s = tokens' (explode s, f)
	end

	__primitive val op< :	string * string -> bool = "String.<"
	__primitive val op> :	string * string -> bool = "String.>"
	__primitive val op<= :	string * string -> bool = "String.<="
	__primitive val op>= :	string * string -> bool = "String.>="

    end


(* StringCvt *)

signature STRING_CVT =
    sig
	datatype radix = BIN | OCT | DEC | HEX

	type ('a, 'b) reader = 'b -> ('a * 'b) option

	type cs

	val dropl: (char -> bool) -> (char, 'a) reader -> 'a -> 'a

	val skipWS: (char, 'a) reader -> 'a -> 'a

	val scanString:
	    ((char, cs) reader -> ('a, cs) reader) -> string -> 'a option
    end

structure StringCvt :> STRING_CVT =
    struct
	datatype radix = BIN | OCT | DEC | HEX

	type ('a, 'b) reader = 'b -> ('a * 'b) option

	type cs = int

	fun dropl p getc =
	    let
		fun h src =
		    case getc src of
			NONE => src
		      | SOME (c, rest) => if p c then h rest else src
	    in
		h
	    end

	fun skipWS getc = dropl Char.isSpace getc

	fun scanString scan s =
	    let
		val len = String.size s
		fun getc i =
		    if i < len then SOME (String.sub (s, i), i + 1)
		    else NONE
	    in
		case scan getc 0 of
		    NONE => NONE
		  | SOME (res, _) => SOME res
	    end
    end


(* Int *)

local

structure Int =
    struct
	type int = int

	open StringCvt

	val maxInt = NONE

	val ~ = ~
	val op+ = op+
	val op- = op-
	val op* = op*

	val op div = op div
	val op mod = op mod
	val abs = abs

	val op< = op<
	val op> = op>
	val op<= = op<=
	val op>= = op>=

	fun decval c = Char.ord c - Char.ord #"0"
	fun hexval c =
	    if Char.ord #"0" <= Char.ord c andalso Char.ord c <= Char.ord #"9"
	    then Char.ord c - Char.ord #"0"
	    else (Char.ord c - Char.ord #"A" + 10) mod 32
	fun skipWSget getc source = getc (dropl Char.isSpace getc source)

	fun isBinDigit #"0" = true
	  | isBinDigit #"1" = true
	  | isBinDigit _ = false

	fun isOctDigit c = Char.ord c >= Char.ord #"0" andalso
			   Char.ord c <= Char.ord #"7"

	fun scan radix getc source =
	    let
		val (isDigit, factor) =
		    case radix of
			BIN => (isBinDigit,       2)
		      | OCT => (isOctDigit,       8)
		      | DEC => (Char.isDigit,    10)
		      | HEX => (Char.isHexDigit, 16)
		fun dig1 sgn NONE = NONE
		  | dig1 sgn (SOME (c, rest)) =
		    let
			fun digr res src =
			    case getc src of
				NONE => SOME (sgn * res, src)
			      | SOME (c', rest') =>
				    if isDigit c' then
					digr (factor * res + hexval c') rest'
				    else
					SOME (sgn * res, src)
		    in
			if isDigit c then digr (hexval c) rest else NONE
		    end
		fun getdigs sgn after0 inp =
		    case dig1 sgn inp of
			NONE => SOME (0, after0)
		      | res => res
		fun hexopt sgn NONE = NONE
		  | hexopt sgn (SOME (#"0", after0)) =
		    if radix <> HEX then getdigs sgn after0 (getc after0)
		    else
			(case getc after0 of
			     NONE => SOME(0, after0)
			   | SOME ((#"x" | #"X"), rest) =>
				 getdigs sgn after0 (getc rest)
			   | inp => getdigs sgn after0 inp)
		  | hexopt sgn inp = dig1 sgn inp
		fun sign NONE = NONE
		  | sign (SOME (#"~", rest)) = hexopt ~1 (getc rest)
		  | sign (SOME (#"-", rest)) = hexopt ~1 (getc rest)
		  | sign (SOME (#"+", rest)) = hexopt 1 (getc rest)
		  | sign inp = hexopt  1 inp
	    in
		sign (skipWSget getc source)
	    end

	__primitive val compare: int * int -> order = "Int.compare"

	__primitive val toString : int -> string = "Int.toString"

	val fromString = scanString (scan DEC)   (*--** crashes *)

	fun min (i, j) = if i > j then j else i
	fun max (i, j) = if i < j then j else i

	fun fromInt i   = i
	fun fromLarge i = i
	fun toInt i     = i
	fun toLarge i   = i
    end

structure LargeInt = Int

in

signature INTEGER =
    sig
	type int

	val maxInt : int option

	val ~ : int -> int
	val + : int * int -> int
	val - : int * int -> int
	val * : int * int -> int
	val div : int * int -> int
	val mod : int * int -> int
	val abs : int -> int
	val < : int * int -> bool
	val > : int * int -> bool
	val <= : int * int -> bool
	val >= : int * int -> bool

	val scan:
	    StringCvt.radix -> (char, 'a) StringCvt.reader -> 'a ->
	    (int * 'a) option

	val compare: int * int -> order

	val toString: int -> string

	val fromString: string -> int option

	val min: int * int -> int
	val max: int * int -> int

	val fromInt: Int.int -> int
	val fromLarge: LargeInt.int -> int
	val toInt : int -> Int.int
	val toLarge: int -> LargeInt.int
    end

structure Int :> INTEGER where type int = int = Int
structure LargeInt :> INTEGER where type int = LargeInt.int = LargeInt

end (* local *)


(* Word *)

signature WORD =
  sig
    eqtype word

    val wordSize : int
    val toLargeWord : word -> word
(*MISSING
    val toLargeWordX : word -> word
*)
    val fromLargeWord : word -> word
    val toLargeInt : word -> int
    val toLargeIntX : word -> int
    val fromLargeInt : int -> word
    val toInt : word -> int
    val toIntX : word -> int
    val fromInt : int -> word
    val orb : word * word -> word
    val xorb : word * word -> word
    val andb : word * word -> word
    val notb : word -> word
    val << : word * word -> word
    val >> : word * word -> word
    val ~>> : word * word -> word
    val + : word * word -> word
    val - : word * word -> word
    val * : word * word -> word
(*MISSING
    val div : word * word -> word
*)
    val mod : word * word -> word
(*MISSING
    val compare : word * word -> order
    val > : word * word -> bool
    val >= : word * word -> bool
    val < : word * word -> bool
    val <= : word * word -> bool
    val min : word * word -> word
    val max : word * word -> word
*)
    val scan : StringCvt.radix
               -> (char,'a) StringCvt.reader -> (word,'a) StringCvt.reader
(*MISSING
    val fromString : string -> word option
    val fmt : StringCvt.radix -> word -> string
*)
    val toString : word -> string
  end

structure Word: WORD =
    struct
	type word = word

	val wordSize = 31

	local
	    __primitive val fromInt' : int * int -> word = "Word.fromInt'"
	in
	    fun fromInt x = fromInt' (wordSize, x)
	    fun fromLargeInt x = fromInt' (wordSize, x)
	end

	__primitive val toInt : word -> int = "Word.toInt"
	__primitive val toLargeInt : word -> LargeInt.int = "Word.toInt"
	__primitive val toIntX : word -> int = "Word.toIntX"
	__primitive val toLargeIntX : word -> LargeInt.int = "Word.toIntX"
	__primitive val op+ : word * word -> word = "Word.+"
	__primitive val op- : word * word -> word = "Word.-"
	__primitive val op* : word * word -> word = "Word.*"
	__primitive val op mod : word * word -> word = "Word.mod"
	__primitive val orb : word * word -> word = "Word.orb"
	__primitive val xorb : word * word -> word = "Word.xorb"
	__primitive val andb : word * word -> word = "Word.andb"
	__primitive val notb : word -> word = "Word.notb"
	__primitive val op<< : word * word -> word = "Word.<<"
	__primitive val op>> : word * word -> word = "Word.>>"
	__primitive val op~>> : word * word -> word = "Word.~>>"
	__primitive val toString : word -> string = "Word.toString"

	fun fromLargeWord w = w
	fun toLargeWord w = w

	local
	    open StringCvt
	    fun skipWSget getc source = getc (dropl Char.isSpace getc source)

	    (* Below, 48 = Char.ord #"0" and 55 = Char.ord #"A" - 10. *)
	    fun decval c = fromInt (Char.ord c) - fromInt 48;
	    fun hexval c =
		if Char.ord #"0" <= Char.ord c
		andalso Char.ord c <= Char.ord #"9" then
		    fromInt (Char.ord c) - fromInt 48
		else
		    (fromInt (Char.ord c) - fromInt 55) mod (fromInt 32);
	in
	    fun scan radix getc source =
		let open StringCvt
		    val source = skipWS getc source
		    val (isDigit, factor) =
			case radix of
			    BIN => (fn c => (Char.ord #"0" <= Char.ord c
				    andalso Char.ord c <= Char.ord #"1"),  2)
			  | OCT => (fn c => (Char.ord #"0" <= Char.ord c
				    andalso Char.ord c <= Char.ord #"7"),  8)
			  | DEC => (Char.isDigit,                          10)
			  | HEX => (Char.isHexDigit,                       16)
		    fun dig1 NONE              = NONE
		      | dig1 (SOME (c1, src1)) =
			let fun digr res src =
			    case getc src of
				NONE           => SOME (res, src)
			      | SOME (c, rest) =>
				    if isDigit c then
					digr (fromInt factor * res + hexval c)
					rest
				    else SOME (res, src)
			in
			    if isDigit c1 then digr (hexval c1) src1
			    else NONE
			end
		    fun getdigs after0 src =
			case dig1 (getc src) of
			    NONE => SOME(fromInt 0, after0)
			  | res  => res
		    fun hexprefix after0 src =
			if radix <> HEX then getdigs after0 src
			else
			    case getc src of
				SOME(#"x", rest) => getdigs after0 rest
			      | SOME(#"X", rest) => getdigs after0 rest
			      | SOME _           => getdigs after0 src
			      | NONE => SOME(fromInt 0, after0)
		in
		    case getc source of
			SOME(#"0", after0) =>
			    (case getc after0 of
				 SOME(#"w", src2) => hexprefix after0 src2
			       | SOME _           => hexprefix after0 after0
			       | NONE             => SOME(fromInt 0, after0))
		      | SOME _ => dig1 (getc source)
		      | NONE   => NONE
		end
	end
    end

structure LargeWord: WORD = Word


(* Real *)

signature REAL =
  sig
    type real
(*MISSING
    structure Math :
      sig
        type real
        val pi : real
        val e : real
        val sqrt : real -> real
        val sin : real -> real
        val cos : real -> real
        val tan : real -> real
        val asin : real -> real
        val acos : real -> real
        val atan : real -> real
        val atan2 : real * real -> real
        val exp : real -> real
        val pow : real * real -> real
        val ln : real -> real
        val log10 : real -> real
        val sinh : real -> real
        val cosh : real -> real
        val tanh : real -> real
      end
    val radix : int
    val precision : int
    val maxFinite : real
    val minPos : real
    val minNormalPos : real
    val posInf : real
    val negInf : real
*)
    val + : real * real -> real
    val - : real * real -> real
    val * : real * real -> real
(*MISSING
    val / : real * real -> real
    val *+ : real * real * real -> real
    val *- : real * real * real -> real
*)
    val ~ : real -> real
(*MISSING
    val abs : real -> real
    val min : real * real -> real
    val max : real * real -> real
    val sign : real -> int
    val signBit : real -> bool
    val sameSign : real * real -> bool
    val copySign : real * real -> real
*)
    val compare : real * real -> order
(*MISSING
    val compareReal : real * real -> IEEEReal.real_order
*)
    val < : real * real -> bool
    val <= : real * real -> bool
    val > : real * real -> bool
    val >= : real * real -> bool
(*MISSING
    val == : real * real -> bool
    val != : real * real -> bool
    val ?= : real * real -> bool
    val unordered : real * real -> bool
    val isFinite : real -> bool
    val isNan : real -> bool
    val isNormal : real -> bool
    val class : real -> IEEEReal.float_class
    val fmt : StringCvt.realfmt -> real -> string
*)
    val toString : real -> string
    val fromString : string -> real option
    val scan : (char,'a) StringCvt.reader -> (real,'a) StringCvt.reader
(*MISSING
    val toManExp : real -> {exp:int, man:real}
    val fromManExp : {exp:int, man:real} -> real
    val split : real -> {frac:real, whole:real}
    val realMod : real -> real
    val rem : real * real -> real
    val nextAfter : real * real -> real
    val checkFloat : real -> real
    val floor : real -> int
    val ceil : real -> int
*)
    val trunc : real -> int
(*MISSING
    val round : real -> int
    val realFloor : real -> real
    val realCeil : real -> real
    val realTrunc : real -> real
    val toInt : IEEEReal.rounding_mode -> real -> int
    val toLargeInt : IEEEReal.rounding_mode -> real -> Int32.int
*)
    val fromInt : int -> real
(*MISSING
    val fromLargeInt : Int32.int -> real
    val toLarge : real -> Real64.real
    val fromLarge : IEEEReal.rounding_mode -> Real64.real -> real
    val toDecimal : real -> IEEEReal.decimal_approx
    val fromDecimal : IEEEReal.decimal_approx -> real
    sharing type Math.real = real
*)
  end

structure Real: REAL =
    struct
	type real = real

	__primitive val fromInt: int -> real = "Real.fromInt"

	__primitive val ~ : real -> real = "Real.~"
	__primitive val op+ : real * real -> real = "Real.+"
	__primitive val op- : real * real -> real = "Real.-"
	__primitive val op* : real * real -> real = "Real.*"
	val op/ = op/
	__primitive val op< : real * real -> bool = "Real.<"
	__primitive val op> : real * real -> bool = "Real.>"
	__primitive val op<= : real * real -> bool = "Real.<="
	__primitive val op>= : real * real -> bool = "Real.>="

	__primitive val compare: real * real -> order = "Real.compare"
	__primitive val trunc: real -> int = "Real.trunc"

	fun scan(r: (char,'a) StringCvt.reader) = scan r   (*--** *)

	fun scan getc source =
	    let
		fun decval c = Int.- (Char.ord c, 48)
		fun pow10 0 = 1.0
		  | pow10 n =
		    if n mod 2 = 0 then
			let val x = pow10 (n div 2) in x * x end
		    else 10.0 * pow10 (Int.- (n, 1))
		fun pointsym src =
		    case getc src of
			NONE           => (false, src)
		      | SOME (c, rest) => if c = #"." then (true, rest)
					  else (false, src)
		fun esym src =
		    case getc src of
			NONE           => (false, src)
		      | SOME (c, rest) =>
			    if c = #"e" orelse c = #"E"  then
				(true, rest)
			    else (false, src)
		fun scandigs first next final source =
		    let fun digs state src =
			case getc src of
			    NONE          => (SOME (final state), src)
			  | SOME(c, rest) =>
				if Char.isDigit c then
				    digs (next(state, decval c)) rest
				else
				    (SOME (final state), src)
		    in
			case getc source of
			    NONE          => (NONE, source)
			  | SOME(c, rest) =>
				if Char.isDigit c then
				    digs (first (decval c)) rest
				else (NONE, source)
		    end

		fun ident x = x
		val getint  =
		    scandigs fromInt
		    (fn (res, cval) => 10.0 * res + fromInt cval) ident
		val getfrac =
		    scandigs
		    (fn cval => (1, fromInt cval))
		    (fn ((decs, frac), cval) =>
		     (Int.+(decs,1), 10.0*frac+fromInt cval))
		    (fn (decs, frac) => frac / pow10 decs)
		val getexp =
		    scandigs ident (fn (res, cval) =>
				    Int.+(Int.*(10,res),cval)) ident

		fun sign src =
		    case getc src of
			SOME(#"+", rest) => (true,  rest)
		      | SOME(#"-", rest) => (false, rest)
		      | SOME(#"~", rest) => (false, rest)
		      | _                => (true,  src )

		val src = StringCvt.dropl Char.isSpace getc source
		val (manpos, src1) = sign src
		val (intg,   src2) = getint src1
		val (decpt,  src3) = pointsym src2
		val (frac,   src4) = getfrac src3

		fun mkres v rest =
		    SOME(if manpos then v else ~v, rest)

		fun expopt manval src =
		    let val (esym,   src1) = esym src
			val (exppos, src2) = sign src1
			val (expv,   rest) = getexp src2
		    in
			case (esym, expv) of
			    (_,     NONE)     => mkres manval src
			  | (true,  SOME exp) =>
				if exppos then mkres (manval * pow10 exp) rest
				else mkres (manval / pow10 exp) rest
			  | _                 => NONE
		    end
	    in
		case (intg,     decpt, frac) of
		    (NONE,      true,  SOME fval) => expopt fval src4
		  | (SOME ival, false, SOME _   ) => NONE
		  | (SOME ival, true,  NONE     ) => mkres ival src2
		  | (SOME ival, false, NONE     ) => expopt ival src2
		  | (SOME ival, _    , SOME fval) => expopt (ival+fval) src4
		  | _                             => NONE
	    end

	val fromString = StringCvt.scanString scan

	__primitive val toString: real -> string = "Real.toString"
    end

structure LargeReal = Real


(* Array *)

signature ARRAY =
  sig
    type 'a array
(*MISSING
    type 'a vector
    val maxLen : int
*)
    val array : int * 'a -> 'a array
(*MISSING
    val tabulate : int * (int -> 'a) -> 'a array
*)
    val fromList : 'a list -> 'a array
(*MISSING
    val array0 : 'a array
*)
    val length : 'a array -> int
    val sub : 'a array * int -> 'a
    val update : 'a array * int * 'a -> unit
(*MISSING
    val extract : 'a array * int * int option -> 'a vector
*)
    val copy : {di:int, dst:'a array, len:int option, si:int, src:'a array}
               -> unit
(*MISSING
    val copyVec : {di:int, dst:'a array, len:int option, si:int, src:'a vector}
                  -> unit
*)
    val app : ('a -> unit) -> 'a array -> unit
    val foldl : ('a * 'b -> 'b) -> 'b -> 'a array -> 'b
(*MISSING
    val foldr : ('a * 'b -> 'b) -> 'b -> 'a array -> 'b
    val modify : ('a -> 'a) -> 'a array -> unit
    val appi : (int * 'a -> unit) -> 'a array * int * int option -> unit
    val foldli : (int * 'a * 'b -> 'b)
                 -> 'b -> 'a array * int * int option -> 'b
    val foldri : (int * 'a * 'b -> 'b)
                 -> 'b -> 'a array * int * int option -> 'b
    val modifyi : (int * 'a -> 'a) -> 'a array * int * int option -> unit
*)
  end

structure Array: ARRAY =
    struct
	__eqtype 'a array

	__primitive val array : int * 'a -> 'a array = "Array.array"
	__primitive val fromList : 'a list -> 'a array = "Array.fromList"
	__primitive val length : 'a array -> int = "Array.length"
	__primitive val sub : 'a array * int -> 'a = "Array.sub"
	__primitive val update : 'a array * int * 'a -> unit = "Array.update"

	fun copy {src, si, len, dst, di} =
	    let
		val bound =
		    case len of
			NONE => length src
		      | SOME n => si + n
		val offset = di - si
		fun copy' i =
		    if i < bound then
			(update (dst, i + offset, sub (src, i));
			 copy' (i + 1))
		    else ()
	    in
		copy' si
	    end

	fun foldl f z a =
	    let
		val n = length a
		fun foldl' (i, z') =
		    if i < n then foldl' (i + 1, f (sub (a, i), z'))
		    else z'
	    in
		foldl' (0, z)
	    end

	fun app f a =
	    let
		val n = length a
		fun app' i =
		    if i < n then (f (sub (a, i)); app' (i + 1))
		    else ()
	    in
		app' 0
	    end
    end

type array = Array.array


(* Vector *)

signature VECTOR =
  sig
    eqtype 'a vector

(*MISSING
    val maxLen : int
*)
    val fromList : 'a list -> 'a vector
    val tabulate : int * (int -> 'a) -> 'a vector
(*MISSING
    val length : 'a vector -> int
*)
    val sub : 'a vector * int -> 'a
(*MISSING
    val extract : 'a vector * int * int option -> 'a vector
    val concat : 'a vector list -> 'a vector
    val app : ('a -> unit) -> 'a vector -> unit
    val map : ('a -> 'b) -> 'a vector -> 'b vector
    val foldl : ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b
    val foldr : ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b
    val appi : (int * 'a -> unit) -> 'a vector * int * int option -> unit
    val mapi : (int * 'a -> 'b) -> 'a vector * int * int option -> 'b vector
    val foldli : (int * 'a * 'b -> 'b)
                 -> 'b -> 'a vector * int * int option -> 'b
    val foldri : (int * 'a * 'b -> 'b)
                 -> 'b -> 'a vector * int * int option -> 'b
*)
  end

structure Vector: VECTOR =
    struct
	type 'a vector = 'a vector

	__primitive val fromList : 'a list -> 'a vector = "Vector.fromList"
	__primitive val sub : 'a vector * int -> 'a = "Vector.sub"

	fun tabulate (n, f) = fromList (List.tabulate (n, f))
    end

val vector = Vector.fromList


(* Transient *)

signature TRANSIENT =
    sig
	exception Promise
	exception Future
	exception Fulfill
	exception ByNeed of exn

	val promise: unit -> 'a
	val fulfill: 'a * 'a -> unit

	val future: 'a -> 'a
	val byNeed: (unit -> 'a) -> 'a

	val await: 'a -> 'a

	val isPromise: 'a -> bool
	val isFuture: 'a -> bool
    end

structure Transient: TRANSIENT =
    struct
	__primitive constructor Promise: exn = "Transient.Promise"
	__primitive constructor Future: exn = "Transient.Future"
	__primitive constructor Fulfill: exn = "Transient.Fulfill"
	__primitive constructor ByNeed of exn: exn = "Transient.ByNeed"

	__primitive val promise: unit -> 'a = "Transient.promise"
	__primitive val fulfill: 'a * 'a -> unit = "Transient.fulfill"

	__primitive val future: 'a -> 'a = "Transient.future"
	__primitive val byNeed: (unit -> 'a) -> 'a = "Transient.byNeed"

	__primitive val await: 'a -> 'a = "Transient.await"

	__primitive val isPromise: 'a -> bool = "Transient.isPromise"
	__primitive val isFuture: 'a -> bool = "Transient.isFuture"
    end

open Transient

structure Transient' =
    struct
	type 'a promise

	__primitive constructor Promise: exn = "Transient.Promise"
	__primitive constructor Future: exn = "Transient.Future"
	__primitive constructor Fulfill: exn = "Transient.Fulfill"
	__primitive constructor ByNeed of exn: exn = "Transient.ByNeed"

	__primitive val promise: unit -> 'a promise = "Transient.promise"
	__primitive val fulfill: 'a promise * 'a -> unit = "Transient.fulfill"

	__primitive val future: 'a promise -> 'a = "Transient.future"
	__primitive val byNeed: (unit -> 'a) -> 'a = "Transient.byNeed"

	__primitive val await: 'a -> 'a = "Transient.await"

	__primitive val isPromise: 'a promise -> bool = "Transient.isPromise"
	__primitive val isFuture: 'a -> bool = "Transient.isFuture"
    end


(* Thread *)

signature THREAD =
    sig
	type thread

	datatype state =
	    RUNNABLE
	  | BLOCKED
	  | TERMINATED

	exception Terminate

	val spawn: (unit -> 'a) -> 'a
	val current: unit -> thread
	val state: thread -> state

	val yield: thread -> unit
	val sleep: int -> unit

	val raiseIn: thread * exn -> unit
	val terminate: thread -> unit

	val suspend: thread -> unit
	val resume: thread -> unit
	val isSuspended: thread -> bool
    end

structure Thread: THREAD =
    struct
	type thread

	datatype state =
	    RUNNABLE
	  | BLOCKED
	  | TERMINATED

	__primitive constructor Terminate: exn = "Thread.Terminate"

	__primitive val spawn: (unit -> 'a) -> 'a = "Thread.spawn"
	__primitive val current: unit -> thread = "Thread.current"
	__primitive val state: thread -> state = "Thread.state"

	__primitive val yield: thread -> unit = "Thread.yield"
	__primitive val sleep: int -> unit = "Thread.sleep"

	__primitive val raiseIn: thread * exn -> unit = "Thread.raiseIn"
	fun terminate t = raiseIn (t, Terminate)

	__primitive val suspend: thread -> unit = "Thread.suspend"
	__primitive val resume: thread -> unit = "Thread.resume"
	__primitive val isSuspended: thread -> bool = "Thread.isSuspended"
    end


(* More members exported to toplevel *)

val getOpt = Option.getOpt
val isSome = Option.isSome
val valOf = Option.valOf

val null = List.null
val hd = List.hd
val tl = List.tl
val length = List.length
val rev = List.rev
val op@ = List.@
val app = List.app
val map = List.map
val foldr = List.foldr
val foldl = List.foldl

val ord = Char.ord
val chr = Char.chr

val str = String.str
val size = String.size
val concat = String.concat
val explode = String.explode
val implode = String.implode
val substring = String.substring
val op^ = String.^

val real = Real.fromInt

val spawn = Thread.spawn
