(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg and Leif Kornstaedt, 1999-2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(*
 *  Items marked with (**) are extensions to the Standard Basis.
 *)

import structure __pervasive                          from "Pervasive"
import type int and word and string
       datatype bool and order and option and list    from "ToplevelTypes"
import infix 4 = <> < > <= infixr 5 :: infix 6 + - infix 7 * div mod
       val op = and op <> and op < and op <=
       and op + and op -                              from "ToplevelValues"
import structure General                              from "General"
import structure Option                               from "Option"
import structure LargeInt                             from "LargeInt"
import structure Char                                 from "Char"
import structure String                               from "String"
import structure StringCvt                            from "StringCvt"
import signature WORD                                 from "WORD-sig"

local
type large_word    = __pervasive.LargeWord.word
type toplevel_word = word
in

functor MkWord(type word val wordSize: int) : WORD =
struct
    type word = word
    type t    = word							(**)

    val wordSize = wordSize

    __primitive val largeWordSize: int = "LargeWord.wordSize"

    __primitive val fromInt': int * int -> word = "Word.fromInt'"
    __primitive val fromWord': int * toplevel_word -> word = "Word.fromWord'"
    __primitive val fromWordX': int * toplevel_word -> word = "Word.fromWordX'"
    __primitive val fromWord'': int * word -> large_word = "Word.fromWord'"
    __primitive val fromWordX'': int * word -> large_word = "Word.fromWordX'"

    __primitive val toInt :       word -> int              = "Word.toInt"
    __primitive val toIntX :      word -> int              = "Word.toIntX"
    __primitive val toLargeInt :  word -> LargeInt.int     = "Word.toInt"
    __primitive val toLargeIntX : word -> LargeInt.int     = "Word.toIntX"

    fun toLargeWord x	= fromWord''(largeWordSize,x)
    fun toLargeWordX x	= fromWordX''(largeWordSize,x)
    fun fromWord x	= fromWord'(wordSize,x)
    fun fromLargeWord x	= fromWord'(wordSize,x)
    fun fromInt x	= fromInt'(wordSize,x)
    fun fromLargeInt x	= fromInt'(wordSize,x)

    __primitive val op + :   word * word -> word = "Word.+"
    __primitive val op - :   word * word -> word = "Word.-"
    __primitive val op * :   word * word -> word = "Word.*"
    __primitive val op div : word * word -> word = "Word.div"
    __primitive val op mod : word * word -> word = "Word.mod"

    __primitive val notb :   word -> word        = "Word.notb"
    __primitive val orb :    word * word -> word = "Word.orb"
    __primitive val xorb :   word * word -> word = "Word.xorb"
    __primitive val andb :   word * word -> word = "Word.andb"
    __primitive val op << :  word * toplevel_word -> word = "Word.<<"
    __primitive val op >> :  word * toplevel_word -> word = "Word.>>"
    __primitive val op ~>> : word * toplevel_word -> word = "Word.~>>"

    __primitive val op < :   word * word -> bool = "Word.<"
    __primitive val op > :   word * word -> bool = "Word.>"
    __primitive val op <= :  word * word -> bool = "Word.<="
    __primitive val op >= :  word * word -> bool = "Word.>="

    fun compare(w1,w2) =
	if w1 < w2 then LESS
	else if w1 < w2 then GREATER
	else EQUAL

    fun min(w1,w2) = if w1 < w2 then w1 else w2
    fun max(w1,w2) = if w1 > w2 then w1 else w2


    (* Formatting *)

    open StringCvt

    (* fmt and scan both use inverted signs to cope with minInt! *)

    val w0 = fromWord 0w0
    val w2 = fromWord 0w2
    val w8 = fromWord 0w8
    val w10 = fromWord 0w10
    val w16 = fromWord 0w16

    fun base BIN	= fromWord 0w2
      | base OCT	= fromWord 0w8
      | base DEC	= fromWord 0w10
      | base HEX	= fromWord 0w16

    fun toIsDigit BIN	= Char.isBinDigit
      | toIsDigit OCT	= Char.isOctDigit
      | toIsDigit DEC	= Char.isDigit
      | toIsDigit HEX	= Char.isHexDigit

    val zero		= fromInt(Char.ord #"0")
    val ten		= fromInt(Char.ord #"A") - w10
    fun digit i		= Char.chr(toInt(i + (if i < w10 then zero else ten)))
    fun value c		= fromInt(Char.ord(Char.toUpper c)) -
			  (if fromInt(Char.ord c) < ten+w10 then zero else ten)

    fun fmt radix i	= if i = w0 then "0"
			  else fmt'(base radix, i, [])
    and fmt'(b, i, cs)	= if i = w0 then String.implode cs
			  else fmt'(b, i div b, digit(i mod b) :: cs)


    (* Scanning *)

    fun scanPrefix getc src =
	case getc src
	  of SOME(#"0", src') =>
	     (case getc src'
		of SOME(#"w", src'') => (true, src'')
		 | _                 => (false, src)
	     )
	   | _ => (false, src)

    fun scanHexPrefix getc src =
	case getc src
	  of SOME(#"0", src') =>
	     (case getc src'
		of SOME(#"x", src'') => (true, src'')
		 | SOME(#"X", src'') => (true, src'')
		 | SOME(#"w", src'') =>
		   (case getc src''
		      of SOME(#"x", src''') => (true, src''')
		       | SOME(#"X", src''') => (true, src''')
		       | _                  => (true, src'')
		   )
		 | _                 => (false, src)
	     )
	   | _ => (false, src)

    fun scanNum (isDigit, b) getc src =
	case getc src
	  of SOME(c, _) =>
	     if isDigit c
	     then SOME(scanNum' (isDigit, b) getc src w0)
	     else NONE
	   | NONE => NONE
    and scanNum' (isDigit, b) getc src i =
	case getc src
	  of SOME(c, src') =>
	     if isDigit c
	     then if i > fromInt ~1 div b then raise General.Overflow
		  else scanNum' (isDigit, b) getc src' (b*i + value c)
	     else (i, src)
	   | NONE => (i, src)

    fun scan radix getc src =
	let
	    val       src1  = skipWS getc src
	    val (pref,src2) = if radix = HEX then scanHexPrefix getc src1
					     else scanPrefix getc src1
	in
	    case scanNum (toIsDigit radix, base radix) getc src2
	      of NONE => if pref then SOME(w0, #2(Option.valOf(getc src1)))
				 else NONE
	       | some => some
	end

    val toString	= fmt HEX
    val fromString	= scanString(scan HEX)
end

end
