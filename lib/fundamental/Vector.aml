(*
 * Authors:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999-2000
 *   Andreas Rossberg, 2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)


(*
 *  Items marked with (**) are extensions to the Standard Basis.
 *)

import structure __pervasive                        from "Pervasive"
import type int and vector
       datatype bool and option and list            from "ToplevelTypes"
import infix 4 = < > infixr 5 :: infix 6 + -
       val op = and op < and op > and op + and op - from "ToplevelValues"
import structure General                            from "General"
import structure List                               from "List"
import signature VECTOR                             from "VECTOR-sig"


structure Vector : VECTOR =
struct
    type 'a vector = 'a vector
    type 'a t      = 'a vector						(**)

    __primitive val maxLen :	int			= "Vector.maxLen"

    __primitive val fromList :	'a list -> 'a vector	= "Vector.fromList"
    __primitive val length :	'a vector -> int	= "Vector.length"
    __primitive val sub :	'a vector * int -> 'a	= "Vector.sub"
    __primitive val sub' :	'a vector * int -> 'a	= "Unsafe.Vector.sub"

    fun toList v		= toList'(v, length v - 1, [])
    and toList'(v, ~1, xs)	= xs
      | toList'(v, i, xs)	= toList'(v, i-1, sub'(v,i)::xs)

    fun sliceLength(v,i,NONE) where (i > length v)
				= raise General.Subscript
      | sliceLength(v,i,NONE)	= length v - i
      | sliceLength(v,i,SOME n) where (i+n > length v orelse n < 0)
				= raise General.Subscript
      | sliceLength(v,i,SOME n)	= n

    __primitive val tabulate :	int * (int -> 'a) -> 'a vector
							= "Vector.tabulate"

    fun extract(v,i,no)		= tabulate(sliceLength(v,i,no),
					   fn k => sub'(v,i+k))
    fun concat vs		= fromList(List.concat(List.map toList vs))
    fun append(v1,v2)		= concat[v1,v2]				(**)

    fun rev v			= let val len = length v		(**)
				      fun f i = sub'(v, len-i-1)
				  in tabulate(len, f) end

    fun replace(v,i,x)		= let fun f j where (i = j) = x		(**)
					| f j               = sub(v,j)
				  in tabulate(length v, f) end

    fun map f v			= tabulate(length v, fn i => f(sub'(v,i)))
    fun mapi f (v,i,no)		= tabulate(sliceLength(v,i,no),
					   fn k => f(i+k, sub'(v,i+k)))

    fun app  f v		= app'(f,v,0)
    and app'(f,v,i) where (i = length v)
				= ()
      | app'(f,v,i)		= (f(sub'(v,i)) ; app'(f,v,i+1))

    fun appr  f v		= appr'(f, v, length v - 1)		(**)
    and appr'(f,v,~1)		= ()
      | appr'(f,v,i)		= (f(sub'(v,i)) ; appr'(f,v,i-1))

    fun foldl  f x v		= foldl'(f,x,v,0)
    and foldl'(f,x,v,i) where (i = length v)
				= x
      | foldl'(f,x,v,i)		= foldl'(f, f(sub'(v,i),x), v, i+1)

    fun foldr  f x v		= foldr'(f, x, v, length v - 1)
    and foldr'(f,x,v,~1)	= x
      | foldr'(f,x,v,i)		= foldr'(f, f(sub'(v,i),x), v, i-1)

    fun appi f (v,i,no)		= appi'(f, v, i, sliceLength(v,i,no))
    and appi'(f,v,i,0)		= ()
      | appi'(f,v,i,n)		= (f(i, sub'(v,i)) ; appi'(f,v,i+1,n-1))

    fun appri f (v,i,no)	= appri'(f, v, i, i-1+sliceLength(v,i,no)) (**)
    and appri'(f,v,i,j)	where (i < j)
				= ()
      | appri'(f,v,i,j)		= (f(i, sub'(v,i)) ; appri'(f,v,i-1,j))

    fun foldli f x (v,i,no)	= foldli'(f, x, v, i, sliceLength(v,i,no))
    and foldli'(f,x,v,i,0)	= x
      | foldli'(f,x,v,i,n)	= foldli'(f, f(i, sub'(v,i), x), v, i+1, n-1)

    fun foldri f x (v,i,no)	= foldri'(f, x, v, i-1+sliceLength(v,i,no), i)
    and foldri'(f,x,v,i,j) where (i < j)
				= x
      | foldri'(f,x,v,i,j)	= foldri'(f, f(i, sub'(v,i),x), v, i-1, j)

    fun all  f v		= all'(f,v,0)				(**)
    and all'(f,v,i) 		= i = length v orelse
				  f(sub'(v,i)) andalso all'(f,v,i+1)

    fun exists  f v		= exists'(f,v,0)			(**)
    and exists'(f,v,i) 		= i = length v orelse
				  f(sub'(v,i)) orelse exists'(f,v,i+1)

    fun find  f v					= find'(f,v,0)	(**)
    and find'(f,v,i) where (i = length v)		= NONE
      | find'(f,v,i) withval x = sub'(v,i) where (f x)	= SOME x
      | find'(f,v,i)					= find'(f,v,i+1)
end
