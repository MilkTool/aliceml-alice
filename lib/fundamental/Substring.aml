(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(*
 *  Items marked with (**) are extensions to the Standard Basis.
 *)

import structure __pervasive                           from "Pervasive"
import type int and bool and order and option and list from "ToplevelTypes"
import signature SUBSTRING                             from "SUBSTRING-sig"

structure Substring :> SUBSTRING =
struct
    structure String		= String
    type substring		= string * int * int

    fun base ss			= ss : substring
    val string			= String.substring o base
    val size			= #3 o base
    fun sub(ss, i)		= String.sub(string ss, i)

    fun substring(s, i, j)	= (if i < 0 orelse j < 0 orelse
				     String.size s < i + j
				   then raise Subscript
				   else (s, i, j)
				  ) handle Overflow => raise Subscript
    fun extract(s, i, NONE)	= substring(s, i, String.size s - i)
      | extract(s, i, SOME j)	= substring(s, i, j)
    fun all s			= substring(s, 0, String.size s)

    fun isEmpty (s,i,n)		= n = 0

    fun getc (s,i,0)		= NONE
      | getc (s,i,n)		= SOME (String.sub(s, i), (s, i+1, n-1))
    val first			= Option.map #1 o getc

    fun Int_max(i, j)		= if i > j then i else j
    fun triml k (s,i,n)		= if k < 0 then raise Subscript else
				  (s, i+k, Int_max(n-k, 0))
    fun trimr k (s,i,n)		= if k < 0 then raise Subscript else
				  (s, i, Int_max(n-k, 0))

    fun slice(ss, i, SOME m)	= slice'(ss, i, m)
      | slice(ss, i, NONE)	= slice'(ss, i, size ss - i)
    and slice'((s,i,n), j, m)	= if j + m > n then raise Subscript else
				  substring(s, i+j, m)

    val concat			= String.concat o (List.map string)
    fun explode	ss		= String.explode(string ss)
    fun translate f ss		= String.concat(List.map f (explode ss))
    fun isPrefix s ss		= String.isPrefix s (string ss)
    fun compare(ss, st)		= String.compare(string ss, string st)
    fun collate f (ss, st)	= String.collate f (string ss, string st)

    fun splitAt((s,i,n), j)	= if j < 0 orelse j> n then raise Subscript else
				  ((s,i,j), (s, i+j, n-j))

    fun splitl f (s,i,n)	= splitl'(f, s, i, n, i)
    and splitl'(f, s, i, n, j)	= if j = i+n then
				      ((s,i,n), (s,j,0))
				  else if f(String.sub(s, j)) then
				      splitl'(f, s, i, n, j+1)
				  else
				      ((s, i, j-i), (s, j, n-(j-i)))

    fun splitr f (s,i,n)	= splitr'(f, s, i, n, i+n-1)
    and splitr'(f, s, i, n, j)	= if j < i then
				      ((s,i,0), (s,i,n))
				  else if f(String.sub(s, j)) then
				      splitr'(f, s, i, n, j-1)
				  else
				      ((s, i, j-i+1), (s, j, n-(j-i+1)))

    fun takel p ss		= #1(splitl p ss)
    fun dropl p ss		= #2(splitl p ss)
    fun taker p ss		= #2(splitr p ss)
    fun dropr p ss		= #1(splitr p ss)
(*
    fun position 
    fun span

    fun tokens
    fun fields
*)
    fun foldl f a ss		= List.foldl f a (explode ss)
    fun foldr f a ss		= List.foldr f a (explode ss)
    fun app f ss		= List.app f (explode ss)
end
