(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(*
 *  Items marked with (**) are extensions to the Standard Basis.
 *)

import structure __pervasive                       from "Pervasive"
import type int and char and string
       datatype bool and order and option and list from "ToplevelTypes"
import infix 6 + - infix 4 = <> < >
       val op = and op <> and op < and op >
       val op + and op -                           from "ToplevelValues"
import structure General                           from "General"
import structure Option                            from "Option"
import structure List                              from "List"
import structure String                            from "String"
import signature SUBSTRING                         from "SUBSTRING-sig"

structure Substring :> SUBSTRING where type string = string
				 where type char   = char =
struct
    type char			= char
    type string			= string
    type substring		= string * int * int
    type t			= substring

    fun base ss			= ss : substring
    fun string ss		= String.substring(base ss)
    fun size ss			= #3(base ss)
    fun sub(ss, i)		= String.sub(string ss, i)

    fun substring(s, i, j)	= (if i < 0 orelse j < 0 orelse
				     String.size s < i + j
				   then raise General.Subscript
				   else (s, i, j)
				  ) handle General.Overflow =>
					   raise General.Subscript
    fun extract(s, i, NONE)	= substring(s, i, String.size s - i)
      | extract(s, i, SOME j)	= substring(s, i, j)
    fun full s			= substring(s, 0, String.size s)
    val all			= full

    fun isEmpty (s,i,n)		= n = 0

    fun getc (s,i,0)		= NONE
      | getc (s,i,n)		= SOME (String.sub(s, i), (s, i+1, n-1))
    fun first ss		= Option.map #1 (getc ss)

    fun Int_max(i, j)		= if i > j then i else j
    fun triml k (s,i,n)		= if k < 0 then raise General.Subscript else
				  (s, i+k, Int_max(n-k, 0))
    fun trimr k (s,i,n)		= if k < 0 then raise General.Subscript else
				  (s, i, Int_max(n-k, 0))

    fun slice(ss, i, SOME m)	= slice'(ss, i, m)
      | slice(ss, i, NONE)	= slice'(ss, i, size ss - i)
    and slice'((s,i,n), j, m)	= if j + m > n then raise General.Subscript else
				  substring(s, i+j, m)

    (*INEFFICIENT*)
    fun concat sss		= String.concat(List.map string sss)
    fun concatWith s sss	= String.concatWith s (List.map string sss)
    fun explode	ss		= String.explode(string ss)
    fun translate f ss		= String.concat(List.map f (explode ss))
    fun isPrefix s ss		= String.isPrefix s (string ss)
    fun isSuffix s ss		= String.isSuffix s (string ss)
    fun isSubstring s ss	= String.isSubstring s (string ss)
    fun hash ss			= String.hash(string ss)
    fun equal(ss, st)		= string ss = string st
    fun compare(ss, st)		= String.compare(string ss, string st)
    fun collate f (ss, st)	= String.collate f (string ss, string st)

    fun splitAt((s,i,n), j)	= if j < 0 orelse j> n
				  then raise General.Subscript
				  else ((s,i,j), (s, i+j, n-j))

    fun splitl f (s,i,n)	= splitl'(f, s, i, n, i)
    and splitl'(f, s, i, n, j)	= if j = i+n then
				      ((s,i,n), (s,j,0))
				  else if f(String.sub(s, j)) then
				      splitl'(f, s, i, n, j+1)
				  else
				      ((s, i, j-i), (s, j, n-(j-i)))

    fun splitr f (s,i,n)	= splitr'(f, s, i, n, i+n-1)
    and splitr'(f, s, i, n, j)	= if j < i then
				      ((s,i,0), (s,i,n))
				  else if f(String.sub(s, j)) then
				      splitr'(f, s, i, n, j-1)
				  else
				      ((s, i, j-i+1), (s, j, n-(j-i+1)))

    fun takel p ss		= #1(splitl p ss)
    fun dropl p ss		= #2(splitl p ss)
    fun taker p ss		= #2(splitr p ss)
    fun dropr p ss		= #1(splitr p ss)
(*
    fun position 
*)
    fun span((s,i,n), (s',i',n'))
				= if s <> s' orelse i'+n' < i
				  then raise General.Span
				  else (s, i, (i'+n')-i)
(*
    fun tokens
    fun fields
*)
    fun foldl f a ss		= List.foldl f a (explode ss)	(*INEFFICIENT*)
    fun foldr f a ss		= List.foldr f a (explode ss)
    fun app f ss		= List.app f (explode ss)
    fun appr f ss		= List.appr f (explode ss)
end
