(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg and Leif Kornstaedt, 1999-2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(*
 *  Items marked with (**) are extensions to the Standard Basis.
 *)

import structure __pervasive                          from "Pervasive"
import type int and word and string
       datatype bool and order and option and list    from "ToplevelTypes"
import infix 4 = <> < > <= infixr 5 :: infix 6 + - infix 7 * div mod
       val op = and op <> and op < and op <=
       and op + and op -                              from "ToplevelValues"
import structure General                              from "General"
import structure Option                               from "Option"
import structure LargeInt                             from "LargeInt"
import structure Char                                 from "Char"
import structure String                               from "String"
import structure StringCvt                            from "StringCvt"
import signature WORD                                 from "WORD-sig"


structure Word : WORD =
struct
    type word = word
    type t    = word							(**)

    __primitive val wordSize :		int                  = "Word.wordSize"

    __primitive val toInt :		word -> int          = "Word.toInt"
    __primitive val toIntX :		word -> int          = "Word.toIntX"
    __primitive val toLargeInt :	word -> LargeInt.int = "Word.toInt"
    __primitive val toLargeIntX :	word -> LargeInt.int = "Word.toIntX"
    __primitive val fromInt' :		int * int -> word    = "Word.fromInt'"

    fun toLargeWord w	= w
    fun toLargeWordX w	= w
    fun fromLargeWord w	= w
    fun fromInt x	= fromInt'(wordSize,x)
    fun fromLargeInt x	= fromInt'(wordSize,x)

    __primitive val op + :   word * word -> word = "Word.+"
    __primitive val op - :   word * word -> word = "Word.-"
    __primitive val op * :   word * word -> word = "Word.*"
    __primitive val op div : word * word -> word = "Word.div"
    __primitive val op mod : word * word -> word = "Word.mod"

    __primitive val notb :   word -> word        = "Word.notb"
    __primitive val orb :    word * word -> word = "Word.orb"
    __primitive val xorb :   word * word -> word = "Word.xorb"
    __primitive val andb :   word * word -> word = "Word.andb"
    __primitive val op << :  word * word -> word = "Word.<<"
    __primitive val op >> :  word * word -> word = "Word.>>"
    __primitive val op ~>> : word * word -> word = "Word.~>>"

    __primitive val op < :   word * word -> bool = "Word.<"
    __primitive val op > :   word * word -> bool = "Word.>"
    __primitive val op <= :  word * word -> bool = "Word.<="
    __primitive val op >= :  word * word -> bool = "Word.>="

    fun compare(w1,w2) =
	if w1 < w2 then LESS
	else if w1 < w2 then GREATER
	else EQUAL

    fun min(w1,w2) = if w1 < w2 then w1 else w2
    fun max(w1,w2) = if w1 > w2 then w1 else w2


    (* Formatting *)

    open StringCvt

    (* fmt and scan both use inverted signs to cope with minInt! *)

    fun base BIN	= 0w2
      | base OCT	= 0w8
      | base DEC	= 0w10
      | base HEX	= 0w16

    fun toIsDigit BIN	= Char.isBinDigit
      | toIsDigit OCT	= Char.isOctDigit
      | toIsDigit DEC	= Char.isDigit
      | toIsDigit HEX	= Char.isHexDigit

    val zero		= fromInt(Char.ord #"0")
    val ten		= fromInt(Char.ord #"A") - 0w10
    fun digit i		= Char.chr(toInt(i + (if i < 0w10 then zero else ten)))
    fun value c		= fromInt(Char.ord(Char.toUpper c)) -
			  (if fromInt(Char.ord c) < ten+0w10 then zero else ten)

    fun fmt radix 0w0	= "0"
      | fmt radix i	= fmt'(base radix, i, [])
    and fmt'(b, 0w0,cs)	= String.implode cs
      | fmt'(b, i, cs)	= fmt'(b, i div b, digit(i mod b) :: cs)


    (* Scanning *)

    fun scanPrefix getc src =
	case getc src
	  of SOME(#"0", src') =>
	     (case getc src'
		of SOME(#"w", src'') => (true, src'')
		 | _                 => (false, src)
	     )
	   | _ => (false, src)

    fun scanHexPrefix getc src =
	case getc src
	  of SOME(#"0", src') =>
	     (case getc src'
		of SOME(#"x", src'') => (true, src'')
		 | SOME(#"X", src'') => (true, src'')
		 | SOME(#"w", src'') =>
		   (case getc src''
		      of SOME(#"x", src''') => (true, src''')
		       | SOME(#"X", src''') => (true, src''')
		       | _                  => (true, src'')
		   )
		 | _                 => (false, src)
	     )
	   | _ => (false, src)

    fun scanNum (isDigit, b) getc src =
	case getc src
	  of SOME(c, _) =>
	     if isDigit c
	     then SOME(scanNum' (isDigit, b) getc src 0w0)
	     else NONE
	   | NONE => NONE
    and scanNum' (isDigit, b) getc src i =
	case getc src
	  of SOME(c, src') =>
	     if isDigit c
	     then if i > fromInt ~1 div b then raise General.Overflow
		  else scanNum' (isDigit, b) getc src' (b*i + value c)
	     else (i, src)
	   | NONE => (i, src)

    fun scan radix getc src =
	let
	    val       src1  = skipWS getc src
	    val (pref,src2) = if radix = HEX then scanHexPrefix getc src1
					     else scanPrefix getc src1
	in
	    case scanNum (toIsDigit radix, base radix) getc src2
	      of NONE => if pref then SOME(0w0, #2(Option.valOf(getc src1)))
				 else NONE
	       | some => some
	end

    val toString	= fmt HEX
    val fromString	= scanString(scan HEX)
end
