(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2001-2005
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(*
 *  Items marked with (**) are extensions to the Standard Basis.
 *)

import structure __pervasive         from "Pervasive"
import __primitive datatype bool     from "ToplevelTypes"
import __primitive structure Ref     from "Ref"
import __primitive structure Hole    from "Hole"
import __primitive signature PROMISE from "PROMISE-sig"

local
structure Promise : PROMISE =						(**)
struct
    open Ref

    type 'a promise	= (bool * 'a) ref
    type 'a t		= 'a promise

    exception Promise

    fun promise()	= ref (false, Hole.hole())
    fun future(ref(_,h)) = Hole.future h handle Hole.Hole => h

    fun fulfill(p, x) =
	let
	    val  p'   = Hole.hole()
	    val (b,h) = exchange(p, Hole.future p')
	in
	    if b
	    then (Hole.fill(p',(true,h)); raise Promise)
	    else (Hole.fill(h,x) handle e => (Hole.fill(p',(false,h)); raise e);
		  Hole.fill(p',(true,h)))
	end

    fun fail(p, e) =
	let
	    val  p'   = Hole.hole()
	    val (b,h) = exchange(p, Hole.future p')
	in
	    if b
	    then (Hole.fill(p',(true,h)); raise Promise)
	    else (Hole.fail(h,e) handle e' => (Hole.fill(p',(false,h)); raise e');
		  Hole.fill(p',(true,h)))
	end

    fun isFulfilled(ref(b,h)) = b
end

    __primitive __eqeqtype promise = "'a promise"
    __primitive functor Cast (structure X : PROMISE signature S) : S = "Cast"
in
    structure Promise = Cast (signature S = PROMISE where type promise = promise
			      structure X = Promise)
end
