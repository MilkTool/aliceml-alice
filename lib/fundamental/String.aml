(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg and Leif Kornstaedt, 1999-2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(*
 *  Items marked with (**) are extensions to the Standard Basis.
 *)

import structure __pervasive                       from "Pervasive"
import type char and string and int
       datatype bool and order and option and list from "ToplevelTypes"
import infix 4 = <> infixr 5 :: infix 6 + - ^
       val op = and op <> and op + and op -        from "ToplevelValues"
import structure Char                              from "Char"
import structure Bool                              from "Bool"
import structure List                              from "List"
import structure StringCvt                         from "StringCvt"
import signature STRING                            from "STRING-sig"


structure String : STRING =
struct
    type string	= string
    type t	= string						(**)

    structure Char = Char

    __primitive val maxSize : int = "String.maxSize"

    __primitive val size : string -> int        = "String.size"
    __primitive val str :  char -> string       = "String.str"
    __primitive val sub :  string * int -> char = "String.sub"
    __primitive val sub' : string * int -> char = "Unsafe.String.sub"
    __primitive val substring : string * int * int -> string
						= "String.substring"
    fun extract(s, i, NONE)   = substring(s, i, size s - i)
      | extract(s, i, SOME j) = substring(s, i, j)

    __primitive val op ^ :    string * string -> string = "String.^"
    __primitive val implode : char list -> string       = "String.implode"
    __primitive val explode : string -> char list       = "String.explode"

    val maxLen		= maxSize					(**)
    val length		= size						(**)
    val append		= op ^						(**)
    val fromList	= implode					(**)
    val toList		= explode					(**)
    fun tabulate(n,f)	= implode(List.tabulate(n,f)) (*INEFFICIENT*)	(**)

    fun concat ss	= List.foldr op^ "" ss			(*INEFFICIENT*)

    fun map f s		= implode(List.map f (explode s))	(*INEFFICIENT*)
    fun translate f s	= concat(List.map f (explode s))	(*INEFFICIENT*)

    __primitive val op < :	string * string -> bool  = "String.<"
    __primitive val op > :	string * string -> bool  = "String.>"
    __primitive val op <= :	string * string -> bool  = "String.<="
    __primitive val op >= :	string * string -> bool  = "String.>="
    __primitive val compare :	string * string -> order = "String.compare"
    __primitive val hash :	string -> int            = "String.hash"

(*
    local
	infix << >> andb xorb
	val plus = op +
 	__primitive val op + :	word * word -> word  = "Word.+"
 	__primitive val op << :	word * word -> word  = "Word.<<"
 	__primitive val op >> :	word * word -> word  = "Word.>>"
 	__primitive val op andb : word * word -> word  = "Word.andb"
 	__primitive val op xorb : word * word -> word  = "Word.xorb"
	__primitive val fromInt': int * int -> word = "Word.fromInt'"
	__primitive val toInt : word -> int = "Word.toInt"
	__primitive val wordSize : int = "Word.wordSize"
    in
	fun hash s =	(* hashpjw [Aho/Sethi/Ullman "Compilers"] *)
	    let
		val n = size s

		fun iter(i,h) =
		    if i = n then h else
		    let
			val c  = fromInt'(wordSize, Char.ord(sub'(s,i)))
			val h' = (h << 0w4) + c
			val g  = h' andb 0wxf00000
		    in
			iter(plus(i,1), h' xorb g xorb (g >> 0w16))
		    end
	    in
		toInt(iter(0,0w0))
	    end
    end
*)
    val equal			= op =

    fun collate  cmp (s1,s2)	= collate'(cmp,s1,s2,0)
    and collate'(cmp,s1,s2,i) where (i = size s1)
				= if size s1 = size s2 then EQUAL
						       else LESS
      | collate'(cmp,s1,s2,i) where (i = size s2)
				= GREATER
      | collate'(cmp,s1,s2,i)	= case cmp(sub'(s1,i), sub'(s2,i))
				    of EQUAL => collate'(cmp,s1,s2,i+1)
				     | other => other

    fun isPrefix s1 s2		= isPrefix'(s1,s2,0)
    and isPrefix'(s1,s2,i)	= i = size s1 orelse
				  i <> size s2 andalso
				  sub'(s1,i) = sub'(s2,i)
				  andalso isPrefix'(s1,s2,i+1)

    fun isSuffix s1 s2		= isSuffix'(s1,s2,size s1-1,size s2-1)
    and isSuffix'(s1,s2,i1,i2)	= i1 = ~1 orelse		(**)
				  i2 <> ~1 andalso
				  sub'(s1,i1) = sub'(s2,i1)
				  andalso isSuffix'(s1,s2,i1-1,i2-1)

    fun fields  f  s		= fields'(f, explode s, nil)
    and fields'(f, nil, ss)	= List.rev ss
      | fields'(f, cs,  ss)	= let val (cs1,cs2) = field'(f,cs,nil) in
				      fields'(f, cs2, implode(cs1)::ss)
				  end
    and field'(f,  nil,  cs')	= (List.rev cs', nil)
      | field'(f, c::cs, cs') where (f c)
      				= (List.rev cs', c::cs)
      | field'(f, c::cs, cs')	= field'(f, cs, c::cs')

    fun tokens  f   s		= tokens'(f, explode s, nil)
    and tokens'(f,  nil,  ss)	= List.rev ss
      | tokens'(f, c::cs, ss) where (f c)
      				= tokens'(f,cs,ss)
      | tokens'(f, c::cs, ss)	= let val (cs1,cs2) = token'(f,cs,nil) in
				      tokens'(f, cs2, implode(c::cs1)::ss)
				  end
    and token'(f,  nil,  cs')	= (List.rev cs', nil)
      | token'(f, c::cs, cs') where (f c)
      				= (List.rev cs', c::cs)
      | token'(f, c::cs, cs')	= token'(f, cs, c::cs')

    fun separate s' ss		= concat(separate'(s', ss))
    and separate'(s', nil)	= nil
      | separate'(s', s::nil)	= s::nil
      | separate'(s', s::ss)	= s::s'::separate'(s', ss)

    fun toWide s		= s					(**)
    fun fromWide s		= s						(**)

    fun toString s		= translate Char.toString s
    fun toCString s		= translate Char.toCString s


    (* Scanning *)

    fun scan getc src		= scan' getc src [] false
    and scan' getc src cs b	= case Char.scan getc src
				    of SOME(c, src') =>
				       scan' getc src' (c::cs) true
				     | NONE => scanTrGap getc src cs b
    and scanTrGap getc src cs b	= case getc src
				    of SOME(#"\\", src') =>
				       (case scanGap getc src'
					  of SOME src'' =>
						scanTrGap getc src'' cs true
					   | NONE => scan'' src cs b
				       )
				     | SOME _ => scan'' src cs b
				     | NONE   => scan'' src cs true
    and scanGap getc src	= case getc src
				    of NONE              => NONE
				     | SOME(#"\\", src') => SOME src'
				     | SOME(c, src') =>
				       if Char.isSpace c
				       then scanGap getc src'
				       else NONE
    and scan'' src cs true	= SOME(implode(List.rev cs), src)
      | scan'' src cs false	= NONE

    fun scanC getc src		= scanC' getc src [] false
    and scanC' getc src cs b	= case Char.scanC getc src
				    of SOME(c, src') =>
				       scanC' getc src' (c::cs) true
				     | NONE =>
				  case getc src
				    of SOME _ => scan'' src cs b
				     | NONE   => scan'' src cs true

    val fromString		= StringCvt.scanString scan
    val fromCString		= StringCvt.scanString scanC
end
