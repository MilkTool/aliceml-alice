(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 1999
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(* Hardwired *)

__prebound Prebound

datatype bool   = datatype Prebound.bool
type     int    = Prebound.int
type     word   = Prebound.word
type     real   = Prebound.real
type     string = Prebound.string
type     char   = Prebound.char
datatype list   = datatype Prebound.list
datatype ref    = datatype Prebound.ref
datatype exn    = datatype Prebound.exn

exception Match = Prebound.Match
exception Bind  = Prebound.Bind


(* Toplevel *)

infix  7  * / div mod
infix  6  + - ^
infixr 5  :: @
infix  4  = <> > >= < <=
infix  3  := o
infix  0  before

(*--** __primitive val use : string -> unit = "use" *)

__primitive val op=  : ''a * ''a -> bool = "="
__primitive val op<> : ''a * ''a -> bool = "<>"


(* Overloaded Identifiers *)

__primitive val op~ :	int -> int = "~"

__primitive val op+ :	int * int -> int = "+"
__primitive val op- :	int * int -> int = "-"
__primitive val op* :	int * int -> int = "*"
__primitive val op div:	int * int -> int = "div"
__primitive val op mod:	int * int -> int = "mod"

__primitive val op< :	int * int -> bool = "<"
__primitive val op> :	int * int -> bool = ">"
__primitive val op<= :	int * int -> bool = "<="
__primitive val op>= :	int * int -> bool = ">="


(* General *)

structure General =
  struct

    type unit = {}
    type exn  = exn

    exception Bind = Bind
    __primitive constructor Chr: exn = "General.Chr"
    __primitive constructor Div: exn = "General.Div"
    __primitive constructor Domain: exn = "General.Domain"
    __primitive constructor Fail of string: exn = "General.Fail"
    exception Match = Match
    __primitive constructor Overflow: exn = "General.Overflow"
    __primitive constructor Size: exn = "General.Size"
    __primitive constructor Span: exn = "General.Span"
    __primitive constructor Subscript: exn = "General.Subscript"

    datatype order = LESS | EQUAL | GREATER

    fun !(ref v) = v

    __primitive val op:= : 'a ref * 'a -> unit = ":="

    fun (f o g) a  = f(g a)
    fun a before b = a
    fun ignore a   = ()

  end

open General


(* Option *)

structure Option =
  struct

    datatype 'a option = NONE | SOME of 'a

    __primitive constructor Option: exn = "Option.Option"

    fun getOpt(SOME v, _) = v
      | getOpt(NONE,   a) = a

    fun isSome(SOME v) = true
      | isSome NONE    = false

    fun valOf(SOME v) = v
      | valOf NONE    = raise Option

    fun filter f a = if f a then SOME a else NONE

    fun join NONE    = NONE
      | join(SOME v) = v

    fun map f  NONE    = NONE
      | map f (SOME v) = SOME(f v)

    fun mapPartial f  NONE    = NONE
      | mapPartial f (SOME v) = f v

    fun compose (f,g) a =
	case g a
	  of NONE   => NONE
	   | SOME v => SOME(f v)

    fun composePartial (f,g) a =
	case g a
	  of NONE   => NONE
	   | SOME v => f v

  end

datatype option = datatype Option.option


(* Bool *)

structure Bool =
  struct

    datatype bool = datatype bool

    fun not true  = false
      | not false = true

    fun toString true  = "true"  : string
      | toString false = "false" : string

  end

val not = Bool.not


(* List *)

structure List =
  struct

    datatype list = datatype list

    __primitive constructor Empty: exn = "List.Empty"

    fun null [] = true
      | null _  = false

    fun length xs =
	let fun length'(nil,   n) = n
	      | length'(y::ys, n) = length'(ys,n+1)
	in length'(xs,0) end

    fun   nil   @ ys = ys
      | (x::xs) @ ys = x :: xs @ ys

    fun hd(x::xs) = x
      | hd  _     = raise Empty

    fun tl(x::xs) = xs
      | tl  _     = raise Empty

    fun last(x::nil) = x
      | last(x::xs)  = last xs
      | last  nil    = raise Empty

    fun getItem(x::xs) = SOME(x,xs)
      | getItem  nil   = NONE

    fun nth(l,i) =
	let fun nth'(x::xs, 0) = x
	      | nth'(x::xs, j) = nth'(xs, j-1)
	      | nth'(nil,   j) = raise Subscript
	in if i >= 0 then nth'(l,i) else raise Subscript end

    fun rev l =
	let fun rev'( nil,  ys) = ys
	      | rev'(x::xs, ys) = rev'(xs, x::ys)
	in rev'(l,nil) end

    fun take(l,i) =
	let fun take'(x::xs, 0, ys) = rev ys
	      | take'(x::xs, j, ys) = take'(xs, j-1, x::ys)
	      | take'(nil,   j, ys) = raise Subscript
	in if i >= 0 then take'(l,i,nil) else raise Subscript end

    fun drop(l,i) =
	let fun drop'(xs,    0) = xs
	      | drop'(x::xs, j) = drop'(xs, j-1)
	      | drop'(nil,   j) = raise Subscript
	in if i >= 0 then drop'(l,i) else raise Subscript end

    fun concat  nil   = nil
      | concat(l::ls) = l @ concat ls

    fun revAppend( nil,  ys) = ys
      | revAppend(x::xs, ys) = revAppend(xs, x::ys)

    fun app f   nil   = ()
      | app f (x::xs) = (f x ; app f xs)

    fun map f   nil   = nil
      | map f (x::xs) = f x :: map f xs

    fun mapPartial f   nil   = nil
      | mapPartial f (x::xs) =
	let val yo = f x
	    val ys = mapPartial f xs
	in case yo of NONE => ys | SOME y => y::ys end

    fun find f   nil   = NONE
      | find f (x::xs) = if f x then SOME x else find f xs

    fun filter f   nil   = nil
      | filter f (x::xs) =
	let val b  = f x
	    val ys = filter f xs
	in if b then x::ys else ys end

    fun partition f l =
	let fun partition'( nil,  pos, neg) = (rev pos, rev neg)
	      | partition'(x::xs, pos, neg) =
		if f x then partition'(xs, x::pos, neg)
		       else partition'(xs, pos, x::neg)
	in partition'(l,nil,nil) end

    fun foldl f b   nil   = b
      | foldl f b (x::xs) = foldl f (f(x,b)) xs

    fun foldr f b   nil   = b
      | foldr f b (x::xs) = f(x, foldr f b xs)

    fun exists f   nil   = false
      | exists f (x::xs) = f x orelse exists f xs

    fun all f   nil   = true
      | all f (x::xs) = f x andalso all f xs

    fun tabulate(n, f) =
	let fun tabulate'(i,l) = if i = n then rev l
					  else tabulate'(i+1, f i :: l)
	in if n >= 0 then tabulate'(0, nil) else raise Size end

  end


(* ListPair *)

structure ListPair =
  struct

    fun zip(l1, l2) =
	let fun zip'( nil,    _,   l) = List.rev l
	      | zip'(  _,    nil,  l) = List.rev l
	      | zip'(x::xs, y::ys, l) = zip'(xs, ys, (x,y)::l)
	in zip'(l1, l2, nil) end

    fun unzip l =
	let fun unzip'(    nil,   l1, l2) = (List.rev l1, List.rev l2)
	      | unzip'((x,y)::l', l1, l2) = unzip'(l', x::l1, y::l2)
	in unzip'(l, nil, nil) end

    fun map f ( nil,    _  ) = nil
      | map f (  _,    nil ) = nil
      | map f (x::xs, y::ys) = f(x,y) :: map f (xs,ys)

    fun app f ( nil,    _  ) = ()
      | app f (  _,    nil ) = ()
      | app f (x::xs, y::ys) = (f(x,y) ; app f (xs,ys))

    fun foldl f c ( nil,    _  ) = c
      | foldl f c (  _,    nil ) = c
      | foldl f c (x::xs, y::ys) = f(x, y, foldl f c (xs,ys))

    fun foldr f c ( nil,    _  ) = c
      | foldr f c (  _,    nil ) = c
      | foldr f c (x::xs, y::ys) = foldr f (f(x,y,c)) (xs,ys)

    fun exists f ( nil,    _  ) = false
      | exists f (  _,    nil ) = false
      | exists f (x::xs, y::ys) = f(x,y) orelse exists f (xs,ys)

    fun all f ( nil,    _  ) = true
      | all f (  _,    nil ) = true
      | all f (x::xs, y::ys) = f(x,y) andalso all f (xs,ys)

  end


(* Char *)

structure Char =
    struct
	type char = char

	__primitive val <= : char * char -> bool = "Char.<="

	__primitive val ord : char -> int = "Char.ord"
	__primitive val chr : int -> char = "Char.chr"

	__primitive val isDigit :    char -> bool = "Char.isDigit"
	__primitive val isHexDigit : char -> bool = "Char.isHexDigit"
	__primitive val isSpace :    char -> bool = "Char.isSpace"

	__primitive val toCString :  char -> string = "Char.toCString"
    end


(* String *)

structure String =
    struct
	type string = string

	__primitive val op^ : string * string -> string = "String.^"
	__primitive val str : char -> string = "String.str"
	__primitive val size : string -> int = "String.size"
	__primitive val substring : string * int * int -> string =
							"String.substring"
	__primitive val sub : string * int -> char = "String.sub"
	__primitive val explode : string -> char list = "String.explode"

	fun extract (s, i, NONE) = substring (s, i, size s - i)
	  | extract (s, i, SOME j) = substring (s, i, j)

	fun concat l = List.foldr (fn (s, rest) => s ^ rest) "" l

	fun toCString s =
		List.foldr (fn (c, rest) => Char.toCString c ^ rest) "" (explode s)

	fun implode l = concat (List.map str l)

	fun map f s = implode (List.map f (explode s))

	__primitive val compare : string * string -> order = "String.compare"

	fun s < t = compare (s, t) = LESS

	local
	    fun token (c::cr, f) =
		if f c then
		    let
			val (cs, rest) = token (cr, f)
		    in
			(c::cs, rest)
		    end
		else (nil, cr)
	      | token (nil, _) = (nil, nil)

	    fun tokens' (c::cr, f) =
		if f c then tokens' (cr, f)
		else
		    let
			val (cs, rest) = token (cr, f)
		    in
			implode (c::cs)::tokens' (rest, f)
		    end
	      | tokens' (nil, _) = nil
	in
	    fun tokens f s = tokens' (explode s, f)
	end
    end


(* StringCvt *)

signature STRING_CVT =
    sig
	datatype radix = BIN | OCT | DEC | HEX

	type ('a, 'b) reader = 'b -> ('a * 'b) option

	type cs

	val dropl: (char -> bool) -> (char, 'a) reader -> 'a -> 'a

	val skipWS: (char, 'a) reader -> 'a -> 'a

	val scanString:
	    ((char, cs) reader -> ('a, cs) reader) -> string -> 'a option
    end

structure StringCvt :> STRING_CVT =
    struct
	datatype radix = BIN | OCT | DEC | HEX

	type ('a, 'b) reader = 'b -> ('a * 'b) option

	type cs = int

	fun dropl p getc =
	    let
		fun h src =
		    case getc src of
			NONE => src
		      | SOME (c, rest) => if p c then h rest else src
	    in
		h
	    end

	fun skipWS getc = dropl Char.isSpace getc

	fun scanString scan s =
	    let
		val len = String.size s
		fun getc i =
		    if i < len then SOME (String.sub (s, i), i + 1)
		    else NONE
	    in
		case scan getc 0 of
		    NONE => NONE
		  | SOME (res, _) => SOME res
	    end
    end


(* Int *)

local

structure Int =
    struct
	type int = int

	open StringCvt

	val op+ = op+

	fun decval c = Char.ord c - Char.ord #"0"
	fun hexval c =
	    if Char.ord #"0" <= Char.ord c andalso Char.ord c <= Char.ord #"9"
	    then Char.ord c - Char.ord #"0"
	    else (Char.ord c - Char.ord #"A" + 10) mod 32
	fun skipWSget getc source = getc (dropl Char.isSpace getc source)

	fun isBinDigit #"0" = true
	  | isBinDigit #"1" = true
	  | isBinDigit _ = false

	fun isOctDigit c = Char.ord c >= Char.ord #"0" andalso
			   Char.ord c <= Char.ord #"7"

	fun scan radix getc source =
	    let
		val (isDigit, factor) =
		    case radix of
			BIN => (isBinDigit,       2)
		      | OCT => (isOctDigit,       8)
		      | DEC => (Char.isDigit,    10)
		      | HEX => (Char.isHexDigit, 16)
		fun dig1 sgn NONE = NONE
		  | dig1 sgn (SOME (c, rest)) =
		    let
			fun digr res src =
			    case getc src of
				NONE => SOME (sgn * res, src)
			      | SOME (c', rest') =>
				    if isDigit c' then
					digr (factor * res + hexval c') rest'
				    else
					SOME (sgn * res, src)
		    in
			if isDigit c then digr (hexval c) rest else NONE
		    end
		fun getdigs sgn after0 inp =
		    case dig1 sgn inp of
			NONE => SOME (0, after0)
		      | res => res
		fun hexopt sgn NONE = NONE
		  | hexopt sgn (SOME (#"0", after0)) =
		    if radix <> HEX then getdigs sgn after0 (getc after0)
		    else
			(case getc after0 of
			     NONE => SOME(0, after0)
			   | SOME ((#"x" | #"X"), rest) =>
				 getdigs sgn after0 (getc rest)
			   | inp => getdigs sgn after0 inp)
		  | hexopt sgn inp = dig1 sgn inp
		fun sign NONE = NONE
		  | sign (SOME (#"~", rest)) = hexopt ~1 (getc rest)
		  | sign (SOME (#"-", rest)) = hexopt ~1 (getc rest)
		  | sign (SOME (#"+", rest)) = hexopt 1 (getc rest)
		  | sign inp = hexopt  1 inp
	    in
		sign (skipWSget getc source)
	    end

	__primitive val compare: int * int -> order = "Int.compare"

	__primitive val toString : int -> string = "Int.toString"

	val op>= = op>=
	val op< = op<

	val fromString = scanString (scan DEC)   (*--** crashes *)

	fun min (i, j) = if i > j then j else i
	fun max (i, j) = if i < j then j else i

	fun fromInt i   = i
	fun fromLarge i = i
	fun toLarge i   = i
    end

structure LargeInt = Int

in

signature INTEGER =
    sig
	type int

	val + : int * int -> int
	val >= : int * int -> bool
	val < : int * int -> bool

	val scan:
	    StringCvt.radix -> (char, 'a) StringCvt.reader -> 'a ->
	    (int * 'a) option

	val compare: int * int -> order

	val toString: int -> string

	val fromString: string -> int option

	val min: int * int -> int
	val max: int * int -> int

	val fromInt: Int.int -> int
	val fromLarge: LargeInt.int -> int
	val toLarge: int -> LargeInt.int
    end

structure Int :> INTEGER where type int = int = Int
structure LargeInt :> INTEGER where type int = LargeInt.int = LargeInt

end (* local *)


(* Real *)

structure Real =
    struct
	type real = real

	fun scan(r: (char,'a) StringCvt.reader) = scan r   (*--** *)
	fun toString(x: real) = ""   (*--** *)
	fun fromString(s: string) = NONE (*--** *)
	fun compare(x: real, y:real) = EQUAL (*--** *)
	fun trunc(x: real) = 0 (*--** *)
	fun (x: real) < (y: real) = false (*--** *)
    end

structure LargeReal = Real


(* Array *)

structure Array =
    struct
	__eqtype 'a array

	__primitive val array : int * 'a -> 'a array = "Array.array"
	__primitive val fromList : 'a list -> 'a array = "Array.fromList"
	__primitive val length : 'a array -> int = "Array.length"
	__primitive val sub : 'a array * int -> 'a = "Array.sub"
	__primitive val update : 'a array * int * 'a -> unit = "Array.update"

	fun copy {src, si, len, dst, di} =
	    let
		val bound =
		    case len of
			NONE => length src
		      | SOME n => si + n
		val offset = di - si
		fun copy' i =
		    if i < bound then
			(update (dst, i + offset, sub (src, i));
			 copy' (i + 1))
		    else ()
	    in
		copy' si
	    end

	fun foldl f z a =
	    let
		val n = length a
		fun foldl' (i, z') =
		    if i < n then foldl' (i + 1, f (sub (a, i), z'))
		    else z'
	    in
		foldl' (0, z)
	    end

	fun app f a =
	    let
		val n = length a
		fun app' i =
		    if i < n then (f (sub (a, i)); app' (i + 1))
		    else ()
	    in
		app' 0
	    end
    end

type array = Array.array


(* Vector *)

structure Vector =
    struct
	eqtype 'a vector

	__primitive val fromList : 'a list -> 'a vector = "Vector.fromList"
	__primitive val sub : 'a vector * int -> 'a = "Vector.sub"

	fun tabulate (n, f) = fromList (List.tabulate (n, f))
    end

val vector = Vector.fromList


(* More members exported to toplevel *)

val getOpt = Option.getOpt
val isSome = Option.isSome
val valOf = Option.valOf

val null = List.null
val hd = List.hd
val tl = List.tl
val length = List.length
val rev = List.rev
val op@ = List.@
val app = List.app
val map = List.map
val foldr = List.foldr
val foldl = List.foldl

val ord = Char.ord
val chr = Char.chr

val str = String.str
val size = String.size
val concat = String.concat
val explode = String.explode
val implode = String.implode
val substring = String.substring
val op^ = String.^
