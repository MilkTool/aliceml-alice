import structure Channel   from "x-alice:/lib/data/Channel"
import structure Inspector from "x-alice:/lib/tools/Inspector"
import signature SPACE     from "x-alice:/lib/gecode/SPACE-sig"
import signature FD        from "x-alice:/lib/gecode/FD-sig"
import signature FS        from "x-alice:/lib/gecode/FS-sig"

import structure Common   from "x-alice:/lib/constraints/distribution/Common"
import structure MkEngine from "x-alice:/lib/constraints/distribution/MkEngine"
import structure GManager from "x-alice:/lib/constraints/distribution/GManager"
import structure Debug    from "x-alice:/lib/constraints/distribution/Debug"

val itos = Int.toString

(*** Search problem :
 *   Choose one number in each column (numbers1, numbers2)
 *   All numbers must be different
 *)
val max = 10
val size = 5
val numbers1 = #[1, 1, 2, 3, 1]
val numbers2 = #[2, 3, 4, 5, 6]

infix %
fun a % b = Vector.sub (a,b)

structure Big :> Common.SCRIPT_GEN =
struct
(*    type sol = int vector *)

  functor MkScript (Space : SPACE)
    (FD : FD where type space = Space.space)
    (FS : FS) =
    struct
      (*	    type variables = FD.intvar vector *)

      val cn = FD.BND

      fun fromInt sp n = FD.intvar (sp,#[(n,n)])
      fun toInt   sp v = FD.Reflect.value (sp,v)

      fun script () =
        let
          val space = Space.new () 
          val vars = FD.rangeVec(space, size, (0, max))
          val reif = FD.boolvarVec (space, size)
          val nreif = FD.boolvarVec (space, size)
        in
          FD.distinct (space, vars, cn) ;
          VectorPair.app (fn (b1, b2) => FD.nega(space, b1, b2)) (reif, nreif) ;

          Vector.appi
          (fn (i, var) =>
           (FD.Reified.equal (space, var, fromInt space (numbers1%i), reif%i, cn) ;
            FD.Reified.equal (space, var, fromInt space (numbers2%i), nreif%i, cn)))
          vars ;

          FD.branch(space, Vector.map FD.Reflect.boolvar2intvar reif, FD.B_NONE, FD.B_MIN);
          (vars, space)
        end

      val searchMode = Common.ALL
        
      fun getSolution (v,space) = Vector.map (toInt space) v
        
    end

  fun print v =
    Vector.foldl (fn (a, s) => s ^ " ; " ^ itos a) "" v

  val rdist = 1

end


val _ =

    let
	open Debug

	(* We select the problem we want to explore. *)
	structure Prob = Big

        val initScript = "/usr/local/bin/sfb-demo.sh"
	    
	(* Hosts used as remote workers. *)
	val hosts = [("localhost", "Tony", initScript),
		     ("localhost", "Bill", initScript)]
	    
	(* We select the text or the graphical manager. *)
	structure Manager = GManager Prob

	(* We build the search engine. *)
	structure Engine = MkEngine Manager Prob
	    
	(* As soon as the engine starts, it returns a channel of solutions. *)
	val sols = Engine.start(dbAll, hosts)

	val l = Channel.toList sols
    in
      (* Inspect the solutions *)
      Inspector.inspect l ;

      (* Print all the solutions. *)
      List.app (fn s => print ("SOLUTION : " ^ (Prob.print s) ^ "\n")) l ;
      
      print "\n\nSearch is done.\nType \"q[ENTER]\" to quit.\n" ;
      
      while Option.map (String.isPrefix "q") (TextIO.inputLine TextIO.stdIn) <> SOME true do () ;
        
        print "Bye.\n" ;
        OS.Process.exit OS.Process.success
    end

