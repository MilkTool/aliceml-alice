(*
 * Authors:
 *   Thorsten Brunklaus <brunklaus@ps.uni-sb.de>
 *   Christian Schulte <schulte@ps.uni-sb.de>
 *
 * Copyright:
 *   Thorsten Brunklaus, 2001
 *   Christian Schulte, 2001
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure FD     from "FD"
import signature LINEAR from "LINEAR-sig"

structure Linear :> LINEAR =
    struct
	infix  7  `*
	infix  6  `+ `-
	infix  5  `#
	infix  4  `= `<> `> `>= `< `<=
	infix  3  `<->

	datatype fdop = PLUS | MINUS | MUL

	datatype domain_element =
	    `` of int
	  | `# of int * int

	type domain = domain_element list

	datatype term =
	    fd of FD.fd
	  | `  of int
	  | `+ of term * term
	  | `- of term * term
	  | `* of term * term
	
	datatype term' =
	    Id    of term
	  | BinOp of fdop * term' * term'
	  | Op    of fdop * term' list

	datatype rel =
	    `<   of term * term
	  | `<=  of term * term
	  | `=   of term * term
	  | `<>  of term * term
	  | `>=  of term * term
	  | `>   of term * term
	  | `<-> of rel * term

	datatype status =
	    ATOMIC of FD.fd
	  | SUM | SUMC | SUMCN
	  | NEGSUM of status * (term' list)
	  | MALFORMED

	fun transform (op`+(a, b)) = BinOp(PLUS, transform a, transform b)
	  | transform (op`-(a, b)) = BinOp(MINUS, transform a, transform b)
	  | transform (op`*(a, b)) = BinOp(MUL, transform a, transform b)
	  | transform t            = Id t

	fun flatten (x as (Id _)) = x
	  | flatten (BinOp(label, a, b)) = Op(label, flatten'(label, a, [b]))
	and flatten'(l, t as BinOp(opl, a, b), ts) where (l = opl) =
	    flatten'(l, a, b::ts)
	  | flatten'(label, t, ts) = map flatten (t::ts)

	fun getFD (Id (fd v))  = v
	  | getFD (Id (op` i)) = FD.fromInt i
	  | getFD _            = raise Subscript

	fun getInt (Id(op` i)) = i
	  | getInt _           = raise Subscript

	local
	    fun idTest (Id (op` i)) = true
	      | idTest (Id (fd v))  = true
	      | idTest _            = false
	in
	    fun isPlainSum ts = List.all idTest ts
	end

	fun checkConst (Op(MUL, [Id(op`(_)), Id(fd _)])) = false
	  | checkConst (Id _)                            = false
	  | checkConst _                                 = true

	fun isConstSum ts = not (List.exists checkConst ts)

	(* Reverse Logic (needed for List.exists) *)
	fun allAtomic nil           = false
	  | allAtomic ((Id  _)::tr) = allAtomic tr
	  | allAtomic _             = true

	fun isNSum ts =
	    not (List.exists
		 (fn (Op(MUL, (Id(op` _))::tr)) => allAtomic tr | _ => true) ts)

	fun analyzeSum ts = if isPlainSum ts then SUM
			    else if isConstSum ts then SUMC
				 else if isNSum ts then SUMCN
				      else MALFORMED
					  
	fun analyzeCN ts = if not(allAtomic ts) then SUMCN else MALFORMED

	fun analyze (Id (fd v))                      = ATOMIC v
	  | analyze (Id (op` i))                     = ATOMIC (FD.fromInt i)
	  | analyze (Op(MUL, [Id(op` _), Id(fd _)])) = SUMC
	  | analyze (Op(MUL, (Id(op` _))::ts))       = analyzeCN ts
	  | analyze (Op(MUL, ts))                    = analyzeCN ts
	  | analyze (Op(MINUS, ts))                  = NEGSUM(analyzeSum ts, ts)
	  | analyze (Op(PLUS, ts))                   = analyzeSum ts

	fun createSumVector (Op(PLUS, ts)) = Vector.fromList (map getFD ts)
	  | createSumVector _              = raise Subscript

	fun makeConst (Op(MUL, [c, v])) = (getInt c, getFD v)
	  | makeConst t                 = (1, getFD t)

	fun createSumCVector (Op(PLUS, ts)) = Vector.fromList (map makeConst ts)
	  | createSumCVector (Op(Mul, [Id (op` i), t as (Id _)])) =
	    #[(i, getFD t)]
	  | createSumCVector _  = raise Subscript

	fun splitInt (ts as ((Id (fd _))::_)) = (1, ts)
	  | splitInt ((Id (op` i))::ts)        = (i, ts)

	fun createSumCNEntry (Op(MUL, ts)) =
	    let
		val (i, ts) = splitInt ts
	    in
		(i, Vector.fromList (map getFD ts))
	    end
	  | createSumCNEntry (t as (Id _)) = (1, Vector.fromList([getFD t]))
	  | createSumCNEntry  _            = raise Subscript

	fun createSumCNVector (Op(PLUS, ts)) =
	    Vector.fromList (map createSumCNEntry ts)
	  | createSumCNVector _ = raise Subscript

	fun negateSum (i, v) = (~i, v)

	fun negateAtomic (Id (fd v))  = (~1, v)
	  | negateAtomic (Id (op` i)) = (~1, FD.fromInt i)

	fun makeNegSum (t::tr) =
	    let
		val tv  = getFD t
		val trs = map negateAtomic tr
	    in
		Vector.fromList ([(1, tv)] @ trs)
	    end
	  | makeNegSum _ = raise Subscript

	fun negSumCFirst (Op(MUL, [Id (op` i), Id (fd v)])) = (i, v)
	  | negSumCFirst (Id (op` i))                       = (1, FD.fromInt i)
	  | negSumCFirst (Id (fd v))                        = (1, v)
	  | negSumCFirst _                                  = raise Subscript

	fun negSumCEntry e = negateSum (negSumCFirst e)
	  
	fun makeNegSumC (t::tr) =
	    let
		val trs = map negSumCEntry tr
	    in
		Vector.fromList ([(negSumCFirst t)] @ trs)
	    end
	  | makeNegSumC _ = raise Subscript

	fun negSumCNFirst (Op(MUL, (Id (op` i))::tr)) =
	    (i, Vector.fromList (map getFD tr))
	  | negSumCNFirst (Id (op` i)) = (1, #[FD.fromInt i])
	  | negSumCNFirst (Id (fd v)) = (1, #[v])
	  | negSumCNFirst _ = raise Subscript

	fun negSumCNEntry e = negateSum (negSumCNFirst e)

	fun makeNegSumCN (t::tr) =
	    let
		val trs = map negSumCNEntry tr
	    in
		Vector.fromList ([(negSumCNFirst t)] @ trs)
	    end
	  | makeNegSumCN _ = raise Subscript

	(* Handle Variable Aliasing *)
	local
	    fun member(v, vs) =
		List.exists (fn (_, x) => FD.Reflect.eq(x, v)) vs

	    fun simplify'(v, vs, newvec) =
		let
		    val vvs = List.filter (fn (_, x) => FD.Reflect.eq(x, v)) vs
		    val cs  = foldl (fn ((i, _), e) => e + i) 0 vvs 
		in
		    if cs = 0 then newvec else (cs, v)::newvec
		end

	    fun simplify(nil, vs, (visited, newvec))             = newvec
	      | simplify((i, v)::vr, vs, t as (visited, newvec)) =
		if member(v, newvec) then simplify(vr, vs, t) else
		    let
			val visited = v::visited
			val newvec  = simplify'(v, vs, newvec)
		    in
			simplify(vr, vs, (visited, newvec))
		    end

	    fun checkReturn nil = raise Subscript (* Stupid constraint *)
	      | checkReturn vs  = Vector.fromList vs
	in
	    fun simplifySumCVector v =
		let
		    val vs = Vector.toList v
		in
		    (case vs of
			 [_]   => v
		       | e::er => checkReturn (simplify(vs, vs, (nil, nil))))
		end
	    
	    fun simplifySumVector v =
		simplifySumCVector (Vector.map (fn x => (1, x)) v)
	end

	fun needType(SUM, t)  = if t <> SUMCN then SUMC else SUMCN
	  | needType(SUMC, t) = if t <> SUMCN then SUMC else SUMCN
	  | needType _        = SUMCN

	fun getConstTerm (Op(MUL, [Id (op` i), Id (fd v)])) = (i, v)
	  | getConstTerm (t as (Id _))                      = (1, getFD t)
	  | getConstTerm _                                  = raise Subscript

	fun getTerms(SUM, (Op(PLUS, ts))) = (map (fn x => (1, getFD x)) ts)
	  | getTerms(SUMC,(Op(PLUS, ts))) = map getConstTerm ts
	  | getTerms(SUMC,(t as (Op(MUL, _)))) = [getConstTerm t] 
	  | getTerms _                         = raise Subscript
	    	
	local
	    fun convertElem (op`` i)     = FD.SINGLE(i)
	      | convertElem (op`#(a, b)) = FD.RANGE(a, b)
		
	    fun convertDomain ts = Vector.fromList (map convertElem ts)
		
	    fun fdToTerm v = fd v
	in
	    fun var NONE          = fd(FD.fd NONE)
	      | var (SOME domain) = fd(FD.fd (SOME (convertDomain domain)))

	    fun bin () = fd(FD.bin ())

	    fun vec(n, domain) =
		(Vector.map fdToTerm (FD.fdVec(n, convertDomain domain)))
	end

	fun termToFD (fd v)  = v
	  | termToFD (op` i) = FD.fromInt i
	  | termToFD _       = raise Subscript

	fun distribute(mode, v) =
	    spawn FD.distribute(mode, Vector.map termToFD v)

	fun distinct v = FD.distinct (Vector.map termToFD v)

	fun post (op`<(a, b))   = post'(a, b, FD.LESS)
	  | post (op`<=(a, b))  = post'(a, b, FD.LESSEQ)
	  | post (op`=(a, b))   = post'(a, b, FD.EQUAL)
	  | post (op`<>(a, b))  = post'(a, b, FD.NOTEQUAL)
	  | post (op`>=(a, b))  = post'(a, b, FD.GREATEREQ)
	  | post (op`>(a, b))   = post'(a, b, FD.GREATER)
	  | post (op`<->(r, c)) = postReified(r, c)
	and post'(a, b, rel) =
	    let
		val a' = flatten (transform a)
		val b' = flatten (transform b)
	    in
		(case (analyze a', analyze b') of
		     (ATOMIC av, ATOMIC bv) =>
			 (case rel of
			      FD.LESS      => FD.less(av, bv)
			    | FD.LESSEQ    => FD.lessEq(av, bv)
			    | FD.EQUAL     => FD.equal(av, bv)
			    | FD.NOTEQUAL  => FD.notequal(av, bv)
			    | FD.GREATEREQ => FD.greaterEq(av, bv)
			    | FD.GREATER   => FD.greater(av, bv))
		   | (SUM, ATOMIC bv) =>
			 FD.sum(createSumVector a', rel, bv)
		   | (SUMC, ATOMIC bv) =>
			 FD.sumC(createSumCVector a', rel, bv)
		   | (SUMCN, ATOMIC bv) =>
			 FD.sumCN(createSumCNVector a', rel, bv)
		   | (NEGSUM (SUM, ts), ATOMIC bv) =>
			 FD.sumC(makeNegSum ts, rel, bv)
		   | (NEGSUM(SUMC, ts), ATOMIC bv) =>
			 FD.sumC(makeNegSumC ts, rel, bv)
		   | (NEGSUM(SUMCN, ts), ATOMIC bv) =>
			 FD.sumCN(makeNegSumCN ts, rel, bv)
		   | (at, bt) =>
			 (case needType(at, bt) of
			      SUMC =>
				  let
				      val ats  = getTerms(at, a')
				      val bts  = getTerms(bt, b')
				      val sums = (ats @ (map negateSum bts))
				  in
				      FD.sumC(Vector.fromList sums,
					      rel, FD.fromInt 0)
				  end
			    | SUMCN => () (* to be done *) ))
	    end
	and postReified(op`<(a, b), c)  = postReified'(a, b, c, FD.LESS)
	  | postReified(op`<=(a, b), c) = postReified'(a, b, c, FD.LESSEQ)
	  | postReified(op`=(a, b), c)  = postReified'(a, b, c, FD.EQUAL)
	  | postReified(op`<>(a, b), c) = postReified'(a, b, c, FD.NOTEQUAL)
	  | postReified(op`>=(a, b), c) = postReified'(a, b, c, FD.GREATEREQ)
	  | postReified(op`>(a, b), c)  = postReified'(a, b, c, FD.GREATER)
	  | postReified _               = raise Subscript
	and postReified'(a, b, c, rel) =
	    let
		val a' = flatten (transform a)
		val b' = flatten (transform b)
		val cv = getFD (flatten (transform c))
	    in
		(case (analyze a', analyze b') of
		     (SUM, ATOMIC bv) =>
			 FD.Reified.sum(createSumVector a', rel, bv, cv)
		   | (SUMC, ATOMIC bv) =>
			 FD.Reified.sumC(createSumCVector a', rel, bv, cv)
		   | (SUMCN, ATOMIC bv) =>
			 FD.Reified.sumCN(createSumCNVector a', rel, bv, cv)
		   | (NEGSUM(SUM, ts), ATOMIC bv) =>
			 FD.Reified.sumC(makeNegSum ts, rel, bv, cv)
		   | (NEGSUM(SUMC, ts), ATOMIC bv) =>
			 FD.Reified.sumC(makeNegSumC ts, rel, bv, cv)
		   | (NEGSUM(SUMCN, ts), ATOMIC bv) =>
			 FD.Reified.sumCN(makeNegSumCN ts, rel, bv, cv)
		   | (at, bt) =>
			 (case needType(at, bt) of
			      SUMC =>
				  let
				      val ats  = getTerms(at, a')
				      val bts  = getTerms(bt, b')
				      val sums = (ats @ (map negateSum bts))
				  in
				      FD.Reified.sumC(Vector.fromList sums,
						      rel, FD.fromInt 0, cv)
				  end
			    | SUMCN =>
				  () (* to be done *)))
	    end
    end
