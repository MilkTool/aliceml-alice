(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Assert  from "../utility/Assert"
import structure Name    from "Name"
import structure Label   from "Label"
import structure Path    from "Path"
import structure PathSet from "PathSet"
import structure PathMap from "PathMap"
import signature TYPE    from "TYPE-sig"


(*******************************************************************************
On Tuples and Records:

As in SML, tuples are just a special case of records. We treat them specially
however for reasons of efficiency. Tuple and record types can be freely
interconverted.

On Type Functions:

We evaluate type application lazily. Reduction is triggered on demand, i.e. by
unification or by inspection. Not all applications can be reduced (in
particular applications to abstract type constructors) so we deal with some
sort of head normal form.

We don't normally do eta-reduction, since it is expensive. During unification
eta reduction is not needed since lambdas may only show up there under very
restrictive circumstances anyway (see below). Eta-reduction is still needed
however for equals, to equate eta-convertible type functions. It's done on
demand.

On Sharing:

For efficiency reasons, we try to maximise sharing of type structures. This
reduces space cost and speeds up comparison and unification, as a simple
reference comparison often suffices. Not only unification but even the equality
test (used by module type checking) merges types silently whenever possible.

There are several cases where we have to clone a type:

* Type functions before reduction of type application.
* Type schemes (types with toplevel quantifiers) on instantiation.
* All sorts of types on signature instantiation.

For the first two it would be sufficient to only clone subgraphs containing the
variables bound by the lambdas/quantifiers; for the third we only would need to
clone subgraphs containing signature-local constructors. But since minimizing
cloning is difficult in the presence of cycles (we have recursive types) and
the pay-off is unclear, we currently don't do it.

It is very important to maintain sharing between subgraphs of different type
terms on signature instantiation. Not doing this can lead to a quadratic blowup
of type terms during module type checking, particularly desastrous in the
presence of structural datatypes. Therefor we need a special-and-ugly interface
for cloning a sequence of related types.

On Recursive Types:

Stockhausen makes datatypes structural sum types. This is a problem since
SML has non-uniform recursive datatypes. So in fact we not only get recursive
types but recursive type functions. It is not obvious whether type checking
remains decidable in the general case (in our current scheme with lazy
application unification might fail to terminate).

To stay on the safe side we use an iso-recursive interpretation of types:
applications to such functions are never reduced. That is, there is no implicit
unrolling of recursive types, mu is completely structural. For two recursive
types to be compatible they must therefor be constructed from equal type
functions. As a consequence, List(Int) and IntList will not be compatible in
the following example:

	List a  = Nil | Cons(a, List a)
	IntList = Nil | Cons(Int, IntList)

Maybe this can be made a bit more permissive, but in general it seems
impossible to have non-uniform datatypes as well as arbitrary (equi) recursive
types - type checking would become undecidable.

It is also unclear to me whether some sort of hash-consing can be applied to
recursive types or even recursive type functions.

On Type Abbreviations:

We try to maintain type abbreviations to generate more user friendly output.
This is managed through a special node ABBREV, which refers to the original
type term as well as to the reduced/substituted one.

*******************************************************************************)

structure TypePrivate =
struct

  (* Types *)

    datatype sort = OPEN | CLOSED
    datatype kind = STAR | ARROW of kind * kind		(* [kappa,k] *)

    type lab  = Label.t					(* [lab,l] *)
    type path = Path.t					(* [pi,p] *)
    type con  = kind * sort * path			(* [chi,c] *)

    datatype typ' =					(* [tau',t'] *)
	  HOLE   of kind * int	(* variable for inference *)
	| LINK   of typ		(* forward (needed for unification) *)
	| MARK   of typ'	(* for traversal *)
	| FUN    of typ * typ	(* arrow type *)
	| TUPLE  of typ vector	(* tuple *)
	| PROD   of row		(* record *)
	| SUM    of row		(* sum type (datatype) *)
	| VAR    of kind * int	(* bound variable or skolem types *)
	| CON    of con		(* constructor (of arbitrary kind) *)
	| ALL    of var * typ	(* universal quantification *)
	| EXIST  of var * typ	(* existential quantification *)
	| LAMBDA of var * typ	(* abstraction (type function) *)
	| APPLY  of typ * typ	(* application *)
	| MU     of typ		(* recursive type barrier *)
	| ABBREV of typ * typ	(* abbreviations (#2 is unabbreviated type) *)

    and row =						(* [rho,r] *)
	  NIL
	| RHO   of int ref * row
	| FIELD of lab * typ * row

    withtype typ = typ' ref				(* [tau,t] *)
    and      var = typ' ref				(* [alpha,a] *)

    type t = typ

    type path_rea = path PathMap.t
    type typ_rea  = typ PathMap.t

    (*
     * We establish the following invariants:
     * - rows are sorted by label, rho variables appear as head only
     * - types are always in head normal form
     * - sequential quantifiers are ordered such that the bound variables
     *   appear in depth-first leftmost traversal order inside the body
     *)


(*DEBUG*)
    fun pr(FUN _)	= "ARROW"
      | pr(TUPLE _)	= "TUPLE"
      | pr(PROD _)	= "PROD"
      | pr(SUM _)	= "SUM"
      | pr(CON _)	= "CON"
      | pr(VAR _)	= "VAR"
      | pr(ALL _)	= "ALL"
      | pr(EXIST _)	= "EXIST"
      | pr(LAMBDA _)	= "LAMBDA"
      | pr(APPLY _)	= "APPLY"
      | pr(MU _)	= "MU"
      | pr(LINK _)	= "LINK"
      | pr(MARK _)	= "MARK"
      | pr(HOLE _)	= "HOLE"
      | pr(ABBREV _)	= "ABBREV"


  (* Level management *)

    val globalLevel	= 0
    val level		= ref(globalLevel+1)

    fun enterLevel()	= level := !level+1
    fun exitLevel()	= level := !level-1
    fun resetLevel()	= level := 1


  (* Kinds *)

    exception Kind

    fun isStar STAR		= true
      | isStar _		= false

    fun domKind(ARROW(k1,k2))	= k1
      | domKind STAR		= raise Kind

    fun ranKind(ARROW(k1,k2))	= k2
      | ranKind STAR		= raise Kind


    fun kind(ref t')		= kind' t'

    and kind'(LINK t | MU t)	= kind t
      | kind'(ABBREV(_,t))	= kind t
      | kind'(HOLE(k,_))	= k
      | kind'(VAR(k,_))		= k
      | kind'(CON(k,_,_))	= k
      | kind'(LAMBDA(a,t))	= ARROW(kind a, kind t)
      | kind'(APPLY(t1,t2))	= ranKind(kind t1)
      | kind'(MARK t')		= kind' t'
      | kind' _			= STAR

    val kindVar			= kind


  (* Type graph traversal *)

    (* We have two ways to traverse types:
     * - ignoring abbreviations (eg. for closure check)
     * - not ignoring abbreviations (eg. realisations, lifting)
     *)

    fun app1'(( HOLE _
	      | VAR _
	      | CON _ ), f, b)		= ()
      | app1'(( LINK t
	      | MU t ), f, b)		= f t
      | app1'(( ALL(a,t)
	      | EXIST(a,t)
	      | LAMBDA(a,t) ), f, b)	= (f a ; f t)
      | app1'(( FUN(t1,t2)
	      | APPLY(t1,t2) ), f, b)	= (f t1 ; f t2)
      | app1'(( ABBREV(t1,t2) ), f, b)	= if b then (f t1 ; f t2) else f t2
      | app1'(( TUPLE ts ), f, b)	= Vector.app f ts
      | app1'(( PROD r
	      | SUM r ), f, b)		= appRow(r,f)
      | app1'(( MARK _ ), f, b)		= raise Assert.failure

    and appRow(FIELD(_,t,r), f)		= (f t ; appRow(r,f))
      | appRow(RHO(_,r), f)		= appRow(r,f)
      | appRow(NIL, f)			= ()


    fun foldl1'(( HOLE _
		| VAR _
		| CON _ ), f,c,b)	= c
      | foldl1'(( LINK t
		| MU t ), f,c,b)	= f(t,c)
      | foldl1'(( ALL(a,t)
		| EXIST(a,t)
		| LAMBDA(a,t) ), f,c,b)	= f(t, f(a,c))
      | foldl1'(( FUN(t1,t2)
		| APPLY(t1,t2)), f,c,b)	= f(t2, f(t1,c))
      | foldl1'(( ABBREV(t1,t2)),f,c,b)	= if b then f(t2, f(t1,c)) else f(t2,c)
      | foldl1'(( TUPLE ts ), f,c,b)	= Vector.foldl f c ts
      | foldl1'(( PROD r
		| SUM r ), f,c,b)	= foldlRow(r,f,c)
      | foldl1'(( MARK _ ), f,c,b)	= raise Assert.failure

    and foldlRow(FIELD(_,t,r), f,c)	= foldlRow(r, f, f(t,c))
      | foldlRow(RHO(_,r), f,c)		= foldlRow(r, f, c)
      | foldlRow(NIL, f,c)		= c


    fun unmark(t as ref(MARK t')) 	=
(*ASSERT				  assert t' of non MARK _ => *)
					  ( t := t' ; app1'(t', unmark, true) )
      | unmark _	            	= ()


    fun appHow b f t =
	let
	    fun app(ref(MARK _)) = ()
	      | app t =
		let
		    val _  = f t
		    val t' = !t
		    val _  = t := MARK t'
		in
		    app1'(t',app,b)
		end
	in
	    app t before unmark t handle e => ( unmark t ; raise e )
	end

    fun app f		= appHow true f
    fun appNoAbbrevs f	= appHow false f

    fun foldlHow b f c t =
	let
	    fun fold(ref(MARK _), c) = c
	      | fold(t, c) =
		let
		    val c' = f(t,c)
		    val t' = !t
		    val _  = t := MARK t'
		in
		    foldl1'(t',fold,c',b)
		end
	in
	    fold(t,c) before unmark t handle e => ( unmark t ; raise e )
	end

    fun foldl f		= foldlHow true f
    fun foldlNoAbbrevs f= foldlHow false f


  (* Cloning *)

    fun clone t =
	let
	    (* We want to be able to handle recursive types, so we have to
	     * implement graph copying here.
	     *)

	    val trail = ref []

	    fun dupBound(t1 as ref t1') =
(*ASSERT	assert case t1' of VAR _ => true | _ => false *)
		if case t1' of VAR _ => false | _ => true
		then raise Assert.failure else
		let
		    val _   = trail := (t1,t1') :: !trail
		    val t2  = ref(MARK t1')
		    val _   = t1 := LINK t2
		in
		    t2
		end

	    fun dup(t1 as ref t1') =
		let
		    val _   = trail := (t1,t1') :: !trail
		    val t2  = ref(MARK t1')
		    val _   = t1 := LINK t2
		    val t2' = MARK(clone' t1')
		    val _   = t2 := t2'
		in
		    t2
		end

	    and clone(ref(LINK t))	= clone t
	      | clone(t as ref(MARK _
			      |VAR _
			      |HOLE _))	= t
	      | clone t			= dup t

	    and clone'(FUN(t1,t2))	= FUN(clone t1, clone t2)
	      | clone'(TUPLE ts)	= TUPLE(Vector.map clone ts)
	      | clone'(PROD r)		= PROD(cloneRow r)
	      | clone'(SUM r)		= SUM(cloneRow r)
	      | clone'(CON c)		= CON c
	      | clone'(ALL(a,t))	= ALL(dupBound a, clone t)
	      | clone'(EXIST(a,t))	= EXIST(dupBound a, clone t)
	      | clone'(LAMBDA(a,t))	= LAMBDA(dupBound a, clone t)
	      | clone'(APPLY(t1,t2))	= APPLY(clone t1, clone t2)
	      | clone'(MU t)		= MU(clone t)
	      | clone'(ABBREV(t1,t2))	= ABBREV(clone t1, clone t2)
	      | clone' _		= raise Assert.failure

	    and cloneRow(FIELD(a,t,r))	= FIELD(a, clone t, cloneRow r)
	      | cloneRow(RHO(n,r))	= RHO(ref(!n), cloneRow r)
	      | cloneRow(NIL)		= NIL

	    val t2 = clone t
	in
	    List.app op:= (!trail) ;
	    unmark t2 ;
	    t2
	end


  (* Continuous cloning *)

    type clone_state = { trail: (typ * typ') list ref, typs: typ list ref }

    fun cloneStart() = {trail = ref [], typs = ref []} : clone_state
    fun cloneFinish({trail,typs} : clone_state) = 
	( List.app op:= (!trail)
	; List.app unmark (!typs)
	)

    fun cloneCont {trail,typs} t =
	let
	    fun dupBound(t1 as ref t1') =
(*ASSERT	assert case t1' of VAR _ => true | _ => false *)
		if case t1' of VAR _ => false | _ => true
		then raise Assert.failure else
		let
		    val _   = trail := (t1,t1') :: !trail
		    val t2  = ref(MARK t1')
		    val _   = t1 := LINK t2
		in
		    t2
		end

	    fun dup(t1 as ref t1') =
		let
		    val _   = trail := (t1,t1') :: !trail
		    val t2  = ref(MARK t1')
		    val _   = t1 := LINK t2
		    val t2' = MARK(clone' t1')
		    val _   = t2 := t2'
		in
		    t2
		end

	    and clone(ref(LINK t))	= clone t
	      | clone(t as ref(MARK _
			      |VAR _
			      |HOLE _))	= t
	      | clone t			= dup t

	    and clone'(FUN(t1,t2))	= FUN(clone t1, clone t2)
	      | clone'(TUPLE ts)	= TUPLE(Vector.map clone ts)
	      | clone'(PROD r)		= PROD(cloneRow r)
	      | clone'(SUM r)		= SUM(cloneRow r)
	      | clone'(CON c)		= CON c
	      | clone'(ALL(a,t))	= ALL(dupBound a, clone t)
	      | clone'(EXIST(a,t))	= EXIST(dupBound a, clone t)
	      | clone'(LAMBDA(a,t))	= LAMBDA(dupBound a, clone t)
	      | clone'(APPLY(t1,t2))	= APPLY(clone t1, clone t2)
	      | clone'(MU t)		= MU(clone t)
	      | clone'(ABBREV(t1,t2))	= ABBREV(clone t1, clone t2)
	      | clone' _		= raise Assert.failure

	    and cloneRow(FIELD(a,t,r))	= FIELD(a, clone t, cloneRow r)
	      | cloneRow(RHO(n,r))	= RHO(ref(!n), cloneRow r)
	      | cloneRow(NIL)		= NIL

	    val t2 = clone t
	in
	    typs := t2 :: !typs ;
	    t2
	end


  (* Occur check (not used by unification) *)

    exception Occurs

    fun occurs(t1,t2) =
	let
	    fun occurs t = if t1 = t then raise Occurs else ()
	in
	    ( app occurs t2 ; false ) handle Occurs => true
	end


  (* Reduction to head normal form *)

    (*UNFINISHED: avoid multiple cloning of curried lambdas somehow *)

    fun reduce(t as ref(APPLY(t1,t2))) =
	let
	    fun reduceApply(t1 as ref(LAMBDA(a,_)), to) =
		( t := HOLE(kind a, !level)
		; case !(clone t1)
		    of LAMBDA(a,t11) =>
			( a := LINK t2
			; t := (case to
				  of NONE   => LINK t11
				   | SOME t => ABBREV(ref(APPLY(t,t2)), t11) )
			; reduce t
			)
		    | _ => raise Assert.failure
		)
	      | reduceApply(ref(LINK t1), to) =
		    reduceApply(t1, to)

	      | reduceApply(ref(ABBREV(t11,t12)), to) =
		    reduceApply(t12, SOME(Option.getOpt(to,t11)))
	      (*
	      | reduceApply(ref(MU t11), to) =
		    reduceApply(t11, to)
	      *)
	      | reduceApply _ = ()
	in
	    reduceApply(t1, NONE)
	end

      | reduce(ref(LINK t | ABBREV(_,t))) = reduce t

      | reduce _ = ()


    (*
     * We don't normally do eta-reduction, since it is expensive.
     * During unification we curently allow no lambdas anyway.
     * Eta-reduction is still needed however for equals, to equate
     * eta-convertible type functions. It's done on demand.
     *)

    fun reduceEta t = reduceEta2(t, false)
    and reduceEta2(t as ref(LAMBDA _), modified) =
	let
	    fun reduceLambda(ref(LAMBDA(a,t1)), vs) =
		    reduceLambda(t1, a::vs)

	      | reduceLambda(ref(APPLY(t1,t2)), a::vs) =
		    reduceLambda'(t1, t2, a, vs)

	      | reduceLambda(t1, []) =
		    ( t := LINK t1 ; reduceEta2(t1, true) )

	      | reduceLambda(ref(LINK t1), vs) =
		    reduceLambda(t1, vs)

	      | reduceLambda(ref(ABBREV(t1,t2)), vs) =
		    reduceLambda(t2, vs)

	      | reduceLambda _ = modified

	    and reduceLambda'(t1, ref(LINK t2), a, vs) =
		    reduceLambda'(t1,t2,a,vs)
	      | reduceLambda'(t1, t2, ref(LINK a), vs) =
		    reduceLambda'(t1,t2,a,vs)
	      | reduceLambda'(t1, t2, a, vs) =
		if t2 = a andalso not(occurs(a,t1)) then
		    reduceLambda(t1, vs)
		else
		    modified
	in
	    reduceLambda(t, [])
	end

      | reduceEta2(ref(LINK t), modified) = reduceEta2(t, modified)

      | reduceEta2(t, modified) = modified


  (* Creation and injections *)

    fun unknown' k	= HOLE(k, !level)
    fun unknown k	= ref(unknown' k)

    fun inArrow tt	= ref(FUN tt)
    fun inTuple ts	= ref(TUPLE ts)
    fun inProd r	= ref(PROD r)
    fun inSum r		= ref(SUM r)
    fun inVar a		= a
    fun inCon c		= ref(CON c)
    fun inAll at	= ref(ALL at)
    fun inExist at	= ref(EXIST at)
    fun inLambda at	= ref(LAMBDA at)
    fun inApply(t1,t2)	= let val t = ref(APPLY(t1,t2)) in reduce t ; t end
    fun inMu t		= ref(MU t)
    fun inAbbrev(t1,t2)	= ref(ABBREV(t1,t2))

    fun var k		= ref(VAR(k, !level))


  (* Operations on rows *)

    exception Row

    fun unknownRow()		= RHO(ref(!level), NIL)
    fun emptyRow()		= NIL

    fun openRow(r as RHO _)	= r
      | openRow r		= RHO(ref(!level), r)

    fun extendRow(l,t,NIL)	= FIELD(l,t,NIL)
      | extendRow(l,t,RHO(n,r))	= RHO(n, extendRow(l,t,r))
      | extendRow(l1,t1, r1 as FIELD(l2,t2,r2)) =
	case Label.compare(l1,l2)
	  of EQUAL   => raise Row
	   | LESS    => FIELD(l1, t1, r1)
	   | GREATER => FIELD(l2, t2, extendRow(l1,t1,r2))

    fun tupToRow  ts			= tupToRow'(ts,0)
    and tupToRow'(ts,i)			= if i = Vector.length ts then
					      NIL
					  else
					      FIELD(Label.fromInt(i+1),
						    Vector.sub(ts,i),
						    tupToRow'(ts,i+1))

    fun rowToTup r			= rowToTup'(r,1,[])
    and rowToTup'(RHO _,i,ts)		= raise Row
      | rowToTup'(NIL,i,ts)		= Vector.rev(Vector.fromList ts)
      | rowToTup'(FIELD(a,t,r),i,ts)	= case Label.toLargeInt a
					    of NONE     => raise Row
					     | SOME i'  =>
					  (if Int.fromLarge i' <> i then
					      raise Row
					   else
					      rowToTup'(r,i+1,t::ts)
					  ) handle Overflow => raise Row

    fun isTupRow r			= (rowToTup r;true) handle Row => false

    fun isEmptyRow(NIL | RHO _)		= true
      | isEmptyRow _			= false

    fun isUnknownRow(RHO _)		= true
      | isUnknownRow _			= false

    fun headRow(FIELD(a,t,r))		= (a,t)
      | headRow(RHO(_,r))		= headRow r
      | headRow(NIL)			= raise Row

    fun tailRow(FIELD(a,t,r))		= r
      | tailRow(RHO(n,r))		= RHO(n, tailRow r)
      | tailRow(NIL)			= raise Row

    fun lookupRow(NIL, a)		= raise Row
      | lookupRow(RHO(_,r), a)		= lookupRow(r,a)
      | lookupRow(FIELD(a',t,r), a)	= case Label.compare(a',a)
					    of EQUAL   => t
					     | LESS    => lookupRow(r,a)
					     | GREATER => raise Row


  (* Projections and extractions *)

    exception Type

    fun isAbbrev(ref(LINK t))			= isAbbrev t
      | isAbbrev(ref(ABBREV _))			= true
      | isAbbrev _				= false
    fun asAbbrev(ref(LINK t))			= asAbbrev t
      | asAbbrev(ref(ABBREV tt))		= tt
      | asAbbrev _				= raise Type

    fun asType(ref(LINK t))			= asType t
      | asType(ref(ABBREV(_,t)))		= asType t
      | asType(t as ref(t' as LAMBDA _))	= if reduceEta t then asType t
								 else t'
      | asType(ref t')				= t'

    fun isUnknown t	= case asType t of HOLE _   => true | _ => false
    fun isArrow t	= case asType t of FUN _    => true | _ => false
    fun isTuple t	= case asType t of PROD r   => isTupRow r
					 | TUPLE _  => true | _ => false
    fun isProd t	= case asType t of PROD _   => true
					 | TUPLE _  => true | _ => false
    fun isSum t		= case asType t of SUM _    => true | _ => false
    fun isVar t		= case asType t of VAR _    => true | _ => false
    fun isCon t		= case asType t of CON _    => true | _ => false
    fun isAll t		= case asType t of ALL _    => true | _ => false
    fun isExist t	= case asType t of EXIST _  => true | _ => false
    fun isLambda t	= case asType t of LAMBDA _ => true | _ => false
    fun isApply t	= case asType t of APPLY _  => true | _ => false
    fun isMu t		= case asType t of MU _     => true | _ => false

    fun asArrow t	= case asType t of FUN tt    => tt | _ => raise Type
    fun asTuple t	= case asType t of PROD r    => (rowToTup r handle Row
							       => raise Type)
					 | TUPLE ts  => ts | _ => raise Type
    fun asProd t	= case asType t of TUPLE ts  => tupToRow ts
					 | PROD r    => r  | _ => raise Type
    fun asSum t		= case asType t of SUM r     => r  | _ => raise Type
    fun asVar t		= case asType t of VAR _     => t  | _ => raise Type
    fun asCon t		= case asType t of CON c     => c  | _ => raise Type
    fun asAll t		= case asType t of ALL at    => at | _ => raise Type
    fun asExist t	= case asType t of EXIST at  => at | _ => raise Type
    fun asLambda t	= case asType t of LAMBDA at => at | _ => raise Type
    fun asApply t	= case asType t of APPLY tt  => tt | _ => raise Type
    fun asMu t		= case asType t of MU t      => t  | _ => raise Type

    fun isType'(ref(LINK t))			= isType' t
      | isType'(ref(ABBREV(_,t)))		= isType' t
      | isType'(t as ref(APPLY _))		= isTypeApply'(t,0)
      | isType'(ref(MU t))			= isType' t
      | isType'(t as ref(t' as LAMBDA _))	= if reduceEta t then isType' t
								 else t'
      | isType'(ref t')				= t'
    and isTypeApply'(ref(LINK t1 | MU t1), n)	= isTypeApply''(t1,n)
      | isTypeApply'(ref(APPLY(t1,t2)), n)	= isTypeApply'(t1,n+1)
      | isTypeApply'(ref(ABBREV(t1,t2)), n)	= isTypeApply'(t2,n)
      | isTypeApply'(t, n)			= APPLY(t,t)	(*dummy*)
    and isTypeApply''(ref(LINK t1 | MU t1), n)	= isTypeApply''(t1,n)
      | isTypeApply''(ref(ABBREV(t1,t2)), n)	= isTypeApply''(t2,n)
      | isTypeApply''(ref t', 0)		= t'
      | isTypeApply''(ref(LAMBDA(a,t1)), n)	= isTypeApply''(t1,n-1)
      | isTypeApply''(t, n)			= APPLY(t,t)	(*dummy*)

    fun isUnknown' t	= case isType' t of HOLE _   => true | _ => false
    fun isArrow' t	= case isType' t of FUN _    => true | _ => false
    fun isTuple' t	= case isType' t of PROD r   => isTupRow r
					  | TUPLE _  => true | _ => false
    fun isProd' t	= case isType' t of PROD _   => true
					  | TUPLE _  => true | _ => false
    fun isSum' t	= case isType' t of SUM _    => true | _ => false
    fun isVar' t	= case isType' t of VAR _    => true | _ => false
    fun isCon' t	= case isType' t of CON _    => true | _ => false
    fun isAll' t	= case isType' t of ALL _    => true | _ => false
    fun isExist' t	= case isType' t of EXIST _  => true | _ => false
    fun isLambda' t	= case isType' t of LAMBDA _ => true | _ => false
    fun isApply' t	= case isType' t of APPLY _  => true | _ => false

    fun asType'(ref(LINK t))			= asType' t
      | asType'(ref(ABBREV(_,t)))		= asType' t
      | asType'(t as ref(t' as APPLY _))	= asTypeApply'(t',t,[])
      | asType'(ref(MU t))			= asType' t
      | asType'(t as ref(t' as LAMBDA _))	= if reduceEta t then asType' t
								 else t'
      | asType'(ref t')				= t'
    (* Note that we can only legally have a LAMBDA node following an APPLY
       node if there is a MU node inbetween. *)
    and asTypeApply'(t', ref(LINK t1), ts)	= asTypeApply'(t', t1, ts)
      | asTypeApply'(t', ref(APPLY(t1,t2)), ts)	= asTypeApply'(t', t1, t2::ts)
      | asTypeApply'(t', ref(ABBREV(t1,t2)),ts)	= asTypeApply'(t', t2, ts)
      | asTypeApply'(t', t as ref(MU _), ts)	=
	let (* unroll *)
	    val tt = clone t
	    val t1 = asMu tt
	in
	    tt := LINK t; asTypeApply''(t1, ts)
	end
      | asTypeApply'(t', _, _)			= t'
    and asTypeApply''(ref(LINK t1 | MU t1), ts)	= asTypeApply''(t1,ts)
      | asTypeApply''(ref(ABBREV(t1,t2)), ts)	= asTypeApply''(t2,ts)
      | asTypeApply''(ref(LAMBDA(a,t1)), t::ts)	= (a := LINK t ;
						   asTypeApply''(t1, ts))
      | asTypeApply''(t1, t::ts)		= asTypeApply''
							(ref(APPLY(t1,t)), ts)
      | asTypeApply''(ref t', [])		= t'

    fun asArrow' t	= case asType' t of FUN tt    => tt | _ => raise Type
    fun asTuple' t	= case asType' t of PROD r    => (rowToTup r handle Row
								=> raise Type)
					  | TUPLE ts  => ts | _ => raise Type
    fun asProd' t	= case asType' t of TUPLE ts  => tupToRow ts
					  | PROD r    => r  | _ => raise Type
    fun asSum' t	= case asType' t of SUM r     => r  | _ => raise Type
    fun asVar' t	= case asType' t of VAR _     => t  | _ => raise Type
    fun asCon' t	= case asType' t of CON c     => c  | _ => raise Type
    fun asAll' t	= case asType' t of ALL at    => at | _ => raise Type
    fun asExist' t	= case asType' t of EXIST at  => at | _ => raise Type
    fun asLambda' t	= case asType' t of LAMBDA at => at | _ => raise Type
    fun asApply' t	= case asType' t of APPLY tt  => tt | _ => raise Type


    fun pathCon(_,_,p)	= p
    fun path t		= pathCon(asCon t)

(*
    fun holes t = foldl (fn(t as ref(HOLE _), a) => t::a | (t,a) => a) t
    fun paths t = foldl (fn(t as ref(CON c), a) => pathCon(c)::a | (t,a) => a) t
*)

    fun paths t =
    	let
	    val s = PathSet.new()
	in
	    app (fn(ref(CON c)) => PathSet.insert(s, pathCon c) | _ => ()) t ;
	    s
	end


  (* Check for holes *)

    exception Unclosed

    fun checkClosedRow(RHO _)		= raise Unclosed
      | checkClosedRow _		= ()

    fun checkClosed'(HOLE _)		= raise Unclosed
      | checkClosed'(PROD r | SUM r)	= checkClosedRow r
      | checkClosed' _			= ()

    fun isClosed t =
	( appNoAbbrevs (fn ref t' => checkClosed' t') t ; true )
	handle Unclosed => false


  (* Instantiation *)

    (* Instantiate universally quantified types, skolemise
     * existentially qualified types. If there is any quantification,
     * then we have to copy the type.
     * Skolemisation does it the other way round (needed for checking rank 2
     * signature applications and existential types).
     *)

    (*ASSUME that no quantifiers appear under abbreviations
   	(this might break with higher-order polymorphism!) *)

    fun instance'(ref(ALL(a,t)))	= ( a := unknown'(kind a); instance' t )
      | instance'(ref(EXIST(a,t)))	= instance' t
      | instance' t			= t

    fun instance(t as ref(ALL _| EXIST _))	= instance'(clone t)
      | instance(ref(LINK t))			= instance t
      | instance t				= t

    fun skolem'(ref(ALL(a,t)))		= skolem' t
      | skolem'(ref(EXIST(a,t)))	= ( a := unknown' STAR ; skolem' t )
      | skolem' t			= t

    fun skolem(t as ref(ALL _| EXIST _))	= skolem'(clone t)
      | skolem(ref(LINK t))			= skolem t
      | skolem t				= t



  (* Hashing *)

    val same = op=

    fun plusHash(a,b)		= a + b handle Overflow =>
					if a < b then plusHash(a, b mod a)
						 else plusHash(a mod b, b)

    fun hash t =
	let
	    fun hash(ref t', a)		= plusHash(hash' t', a)
	    and hash'(HOLE(k,n))	= n
	      | hash'(VAR(k,n))		= n
	      | hash'(PROD r)		= hashRow r
	      | hash'(SUM r)		= hashRow r
	      | hash'(CON c)		= hashCon c
	      | hash' _			= 0

	    and hashRow NIL		= 0
	      | hashRow(RHO(n,r))	= hashRow r
	      | hashRow(FIELD(a,t,r))	= plusHash(Label.hash a, hashRow r)

	    and hashCon(k,w,p)		= Path.hash p
	in
	    foldlNoAbbrevs hash 0 t
	end



  (* Closure *)

    fun close t =
    	let
	    fun close(a as ref(HOLE(k,n)), f) =
		if n > !level then
		    ( a := VAR(k,n) ; fn t => f(inAll(a,t)) )
		else f

	      | close(a as ref(VAR(k,n)), f) =
		(* UNFINISHED: rethink this *)
		(* We have to quantify over VARs as well.
		 * The reason is that there may be several types being
		 * closed that share parts of their graphs.
		 * Note that this means we have to take care to choose
		 * the correct level when we use VAR for skolem types.
		 *)
		if n > !level then
		    fn t => f(inAll(a,t))
		else f

	      | close(ref(ALL(a,t) | EXIST(a,t) | LAMBDA(a,t)), f) =
		( a := MARK(!a) ; f )	(* bit of a hack... *)

	      | close(t as ref(PROD r), f) = ( t := PROD(closeRow r) ; f )
	      | close(t as ref(SUM r), f)  = ( t := SUM(closeRow r) ; f )

	      | close(_, f) = f

	    and closeRow(r as RHO(n,r')) = if !n > !level then r' else r
	      | closeRow r               = r
	in
	    (* UNFINISHED: This should better use foldlNoAbbrev, but then
	     * we had to lift free vars in abbreviations somehow. *)
	    foldl close (fn t => t) t t
	end


  (* Lifting a type to the current level *)

    exception Lift of var

    fun lift t = app lift1 t
    and lift1(t as ref(t' as HOLE(k,n))) =
	    if n > !level then t := HOLE(k,!level) else ()
      | lift1(t as ref(VAR(k,n))) =
	    if n > !level then raise Lift t else ()
      | lift1(ref(PROD r | SUM r)) = liftRow r
      | lift1(ref(LAMBDA(a,_) | ALL(a,_) | EXIST(a,_))) =
(*ASSERT    assert case !a of VAR _ => true | _ => false =>*)
	    if case !a of VAR _ => false | _ => true
	    then raise Assert.failure else
	    a := VAR(kindVar a, globalLevel)
      | lift1 t = ()

    and liftRow(RHO(n,r))	= if !n > !level then n := !level else ()
      | liftRow _		= ()


  (* Filling *)

    exception Fill

    fun fill(t1 as ref(HOLE(k,n)), t2)	=
(*ASSERT		 		= assert k1 = kind t2 =>*)
if k <> kind t2 then raise Assert.failure else
(*ASSERT		 		= assert not(isLambda t2) =>*)
if isLambda t2 then raise Assert.failure else (* should always be MU! *)
					  t1 := LINK t2
      | fill    _			= raise Fill


  (* Unification *)

    exception Unify of typ * typ


    fun liftAndCheck(n,t1,t2) =
	let
	    fun lift(t as ref(t' as HOLE(k,n'))) =
		    t := MARK(if n' <= n then t' else HOLE(k,n))
	      | lift(ref(MARK _)) = ()
	      | lift(t as ref(t' as (PROD r | SUM r))) =
		    ( liftRow r ; t := MARK t' ; app1'(t', lift, true) )
	      | lift(t as ref t') = ( t := MARK t' ; app1'(t', lift, true) )

	    and liftRow(RHO(n',r)) = if !n' > n then n' := n else ()
	      | liftRow _          = ()

	    fun check(t as ref t') =
		if t1 = t then
		    ( unmark t2 ; raise Unify(t1,t2) )
		else case t'
		  of HOLE(k,n') => t := MARK(if n' <= n then t' else HOLE(k,n))
		   | MARK _     => ()
		   | MU _       => ( t := MARK t' ; app1'(t', lift, true) )
		   | _          => ( t := MARK t' ; app1'(t', check, true) )
	in
	    check t2 ; unmark t2
	end


    fun unify(t1,t2) =
	let
	    val trail = ref []

	    fun unify(t1, ref(LINK t2)) = unify(t1,t2)
	      | unify(ref(LINK t1), t2) = unify(t1,t2)
	      | unify(t1 as ref t1', t2 as ref t2') =
		let
		    fun recur f x =
			( t1 := LINK t2
			; trail := (t1,t1') :: !trail
			; f x
			)

		    fun recurBinder(a1 as ref a1', a2, t1, t2) =
			( a1 := LINK a2
			; trail := (a1,a1') :: !trail
			; recur unify (t1,t2)
			)
		in
		    if t1 = t2 then () else
		    case (t1',t2')
		      of (HOLE(k1,n1), HOLE(k2,n2)) =>
(*ASSERT		 assert k1 = k2 =>*)
if k1 <> k2 then raise Assert.failure else
			 if n1 < n2 then t2 := LINK t1
				    else t1 := LINK t2

		       | (HOLE(k1,n), _) =>
(*ASSERT		 assert k1 = kind' t2' =>*)
if k1 <> kind' t2' then raise Assert.failure else
(*ASSERT		 assert not(isLambda t2) =>*)
if isLambda t2 then raise Assert.failure else
			 ( liftAndCheck(n,t1,t2) ; t1 := LINK t2 )

		       | (_, HOLE(k2,n)) =>
(*ASSERT		 assert kind' t1' = k2 =>*)
if kind' t1' <> k2 then raise Assert.failure else
(*ASSERT		 assert not(isLambda t1) =>*)
if isLambda t1 then raise Assert.failure else
			 ( liftAndCheck(n,t2,t1) ; t2 := LINK t1 )

		       | (ABBREV(t11,t12), _) =>
			 unify (t12,t2)

		       | (_, ABBREV(t21,t22)) =>
			 unify (t1,t22)

		       | (MU(t11), MU(t21)) =>
			 recur unify (t11,t21)
		       (*
		       | (MU(t11), _) =>
			 ( t2 := MU(ref t2') ; unify(t1,t2) )

		       | (_, MU(t21)) =>
			 ( t1 := MU(ref t1') ; unify(t1,t2) )
		       *)
		       | (FUN(tt1), FUN(tt2)) =>
			 recur unifyPair (tt1,tt2)

		       | (TUPLE(ts1), TUPLE(ts2)) =>
			 (recur unifyVector (ts1,ts2)
			  handle Domain => raise Unify(t1,t2))

		       | (TUPLE(ts), PROD(r)) =>
			 (recur unifyTupleProd (ts,r,t2)
			  handle Domain => raise Unify(t1,t2))

		       | (PROD(r), TUPLE(ts)) =>
			 (recur unifyTupleProd (ts,r,t1)
			  handle Domain => raise Unify(t1,t2))

		       | (PROD(r1), PROD(r2)) =>
			 recur unifyRow (t1, t2, r1, r2, PROD)

		       | (SUM(r1), SUM(r2)) =>
			 recur unifyRow (t1, t2, r1, r2, SUM)

		       | (CON(_,_,p1), CON(_,_,p2)) =>
			 if Path.equals(p1,p2) then t1 := LINK t2
					       else raise Unify(t1,t2)

		       | (APPLY(tt1), APPLY(tt2)) =>
			 (* Note that we do not allow general lambdas during
			  * unification, so application is considered to be
			  * in normal form. *)
			 recur unifyPair (tt1,tt2)

		       | (LAMBDA(a1,t11), LAMBDA(a2,t21)) =>
			 (* The only place lambdas might occur during
			  * unification is below mu and as arguments to
			  * abstract type constructors. The type functions
			  * must be equal in both cases. *)
			 (*UNFINISHED: do we need eta reduction?*)
			 recurBinder(a1, a2, t11, t21)

		       | ( (ALL(a1,t11), ALL(a2,t21))
			 | (EXIST(a1,t11), EXIST(a2,t21)) ) =>
			 recurBinder(a1, a2, t11, t21)

		       | _ => raise Unify(t1,t2)
		end

	    and unifyPair((t11,t12), (t21,t22)) =
		( unify(t11,t21) ; unify(t12,t22) )

	    and unifyVector(ts1,ts2) =
		if Vector.length ts1 <> Vector.length ts2 then
		    raise Domain
		else
		    VectorPair.app unify (ts1,ts2)

	    and unifyTupleProd(ts,r,t) = unifyTupleProd'(ts,r,t,0,false)
	    and unifyTupleProd'(ts, RHO(_,r), t, i, b) =
		unifyTupleProd'(ts, r, t, i, true)
	      | unifyTupleProd'(ts, NIL, t, i, b) =
		if b orelse i = Vector.length ts then
		    t := TUPLE ts
		else
		    raise Domain
	      | unifyTupleProd'(ts, r as FIELD(a,t',r'), t, i, b) =
		case Label.toLargeInt a
		  of NONE     => raise Domain
		   | SOME i'  =>
		case Int.compare(Int.fromLarge i', i+1)
		     handle Overflow => raise Domain
		  of EQUAL   => ( unify(t', Vector.sub(ts,i))
				  handle Subscript => raise Domain
				; unifyTupleProd'(ts, r', t, i+1, b) )
		   | GREATER => if not b then raise Domain else
				  unifyTupleProd'(ts, r, t, i+1, b)
		   | LESS    => raise Domain (* cannot happen *)

	    and unifyRow(t1, t2, r1, r2, PRODorSUM) =
		let
		    fun loop(RHO(n1,r1), _,  RHO(n2,r2), _ ) =
			    RHO(ref(Int.min(!n1, !n2)), loop(r1,true, r2,true))
		      | loop(RHO(_,r1), _, r2, _) =
			    loop(r1, true, r2, false)
		      | loop(r1, _, RHO(_,r2), _) =
			    loop(r1, false, r2, true)
		      | loop(NIL, _, NIL, _) =
			    NIL
		      | loop(NIL, true, FIELD(l,t,r2'), b2) =
			    FIELD(l,t, loop(NIL, true, r2', b2))
		      | loop(FIELD(l,t,r1'), b1, NIL, true) =
			    FIELD(l,t, loop(r1', b1, NIL, true))
		      | loop(r1 as FIELD(l1,t11,r1'), b1,
			     r2 as FIELD(l2,t21,r2'), b2) =
			(case Label.compare(l1,l2)
			   of EQUAL   => ( unify(t11,t21)
					 ; FIELD(l1,t11, loop(r1',b1, r2',b2)) )
			    | LESS    => if not b2 then raise Unify(t1,t2) else
					 FIELD(l1,t11, loop(r1',b1, r2,b2))
			    | GREATER => if not b1 then raise Unify(t1,t2) else
					 FIELD(l2,t21, loop(r1,b1, r2',b2))
			)
		      | loop _ = raise Unify(t1,t2)
		in
		    t2 := PRODorSUM(loop(r1, false, r2, false))
		end
	in
	    unify(t1,t2)
	    handle Unify tt => ( List.app op:= (!trail) ; raise Unify tt )
	end


  (* Matching *)

    fun matches(t1,t2) =
	let
	    val t1' = instance t1
	    val t2' = skolem t2
	in
	    ( unify(t1',t2') ; true ) handle Unify _ => false
	end


  (* Comparison *)

    (* To maximise sharing, links are kept after comparison iff the
     * types are equal. If the types are not equal, all updates are
     * undone. This could be optimized by keeping equal subtrees, but what for?
     *)

    fun equals(t1,t2) =
	let
	    val trail = ref []

	    fun equals(t1, ref(LINK t2)) = equals(t1,t2)
	      | equals(ref(LINK t1), t2) = equals(t1,t2)
	      | equals(t1 as ref t1', t2 as ref t2') =
		let
		    fun recur p x =
			( t1 := LINK t2
			; trail := (t1,t1') :: !trail
			; p x
			)

		    fun recurBinder(a1 as ref a1', a2, t1, t2) =
			( a1 := LINK a2
			; trail := (a1,a1') :: !trail
			; recur equals (t1,t2)
			)

		    fun equalsTupProd(ts, r, t) =
			let val ts' = rowToTup r in
			    t := TUPLE ts'; recur equalsVector (ts,ts')
			end
			handle Row => false
		in
		    t1 = t2 orelse
		    case (t1',t2')
		      of (ABBREV(t11,t12), _) =>
			 equals(t12,t2)

		       | (_, ABBREV(t21,t22)) =>
			 equals(t1,t22)

		       | (MU(t11), MU(t21)) =>
			 recur equals (t11,t21)
		       (*
		       | (MU(t11), _) =>
			 recur equals (t11,t2)

		       | (_, MU(t21)) =>
			 recur equals (t1,t21)
		       *)
		       | (FUN(tt1), FUN(tt2)) =>
			 recur equalsPair (tt1,tt2)

		       | (TUPLE(ts1), TUPLE(ts2)) =>
			 recur equalsVector (ts1,ts2)

		       | (TUPLE(ts), PROD(r)) =>
			 equalsTupProd(ts,r,t2)

		       | (PROD(r), TUPLE(ts)) =>
			 equalsTupProd(ts,r,t1)

		       | ( (PROD(r1), PROD(r2))
			 | (SUM(r1),  SUM(r2)) ) =>
			 recur equalsRow (r1,r2)

		       | (CON(_,_,p1), CON(_,_,p2)) =>
			 Path.equals(p1,p2)

		       | (APPLY(tt1), APPLY(tt2)) =>
			 recur equalsPair (tt1,tt2)

		       | (LAMBDA(a1,t11), LAMBDA(a2,t21)) =>
			 if reduceEta t1 orelse reduceEta t2 then
			     equals(t1,t2)
			 else
			     recurBinder(a1, a2, t11, t21)

		       | (LAMBDA _, _) =>
			 reduceEta t1 andalso equals(t1,t2)

		       | (_, LAMBDA _) =>
			 reduceEta t2 andalso equals(t1,t2)

		       | ( (ALL(a1,t11),   ALL(a2,t21))
			 | (EXIST(a1,t11), EXIST(a2,t21)) ) =>
			 recurBinder(a1, a2, t11, t21)

		       | _ => false
		end

	    and equalsPair((t11,t12), (t21,t22)) =
		equals(t11,t21) andalso equals (t12,t22)

	    and equalsVector(ts1,ts2) =
		Vector.length ts1 = Vector.length ts2 andalso
		VectorPair.all equals (ts1,ts2)

	    and equalsRow(NIL,             NIL)             = true
	      | equalsRow(RHO(_,r1),       RHO(_,r2))       = equalsRow(r1,r2)
	      | equalsRow(FIELD(l1,t1,r1), FIELD(l2,t2,r2)) =
		l1 = l2 andalso equals(t1,t2) andalso equalsRow(r1,r2)
	      | equalsRow _ = false
	in
	    equals(t1,t2) orelse ( List.app op:= (!trail) ; false )
	end


  (* Realisation *)

    fun realisePath(rea, t) = app (realisePath1 rea) t
    and realisePath1 rea (t as ref(CON(k,s,p))) =
	( case PathMap.lookup(rea, p)
	    of SOME p' => t := CON(k,s,p')
	     | NONE    => ()
	)
      | realisePath1 rea t = ()

    (*
     * Realisations need not be idempotent (fully expanded). Would be nice
     * to have this property because it would make substitution more efficient,
     * but full expansion is difficult to achieve for the intersect function).
     *)

    fun realise(rea, t) =
	let
	    val apps = ref[]

	    fun realise1(t1 as ref(CON(k,s,p))) =
		(case PathMap.lookup(rea, p)
		   of SOME t2 => t1 := LINK t2		(* expand *)
			(*UNFINISHED: do we have to clone t2? *)
		    | NONE    => ()
		)
	      | realise1(t1 as ref(APPLY _)) = apps := t1::(!apps)
	      | realise1 t1 = ()
	in
	    app realise1 t ; List.app reduce (!apps)
	end


  (* Intersection *)

    exception Intersect

    fun intersect(t1:typ, t2:typ) = ()
    (* UNFINISHED *)


  (* Synchronisation for thread safety *)

    val lock		= Lock.lock()

    val inApply		= Lock.sync lock inApply
    val isUnknown	= Lock.sync lock isUnknown
    val isArrow		= Lock.sync lock isArrow
    val isTuple		= Lock.sync lock isTuple
    val isProd		= Lock.sync lock isProd
    val isSum		= Lock.sync lock isSum
    val isVar		= Lock.sync lock isVar
    val isCon		= Lock.sync lock isCon
    val isAll		= Lock.sync lock isAll
    val isExist		= Lock.sync lock isExist
    val isLambda	= Lock.sync lock isLambda
    val isApply		= Lock.sync lock isApply
    val isMu		= Lock.sync lock isMu
    val isAbbrev	= Lock.sync lock isAbbrev
    val isUnknown'	= Lock.sync lock isUnknown'
    val isArrow'	= Lock.sync lock isArrow'
    val isTuple'	= Lock.sync lock isTuple'
    val isProd'		= Lock.sync lock isProd'
    val isSum'		= Lock.sync lock isSum'
    val isVar'		= Lock.sync lock isVar'
    val isCon'		= Lock.sync lock isCon'
    val isAll'		= Lock.sync lock isAll'
    val isExist'	= Lock.sync lock isExist'
    val isLambda'	= Lock.sync lock isLambda'
    val isApply'	= Lock.sync lock isApply'
    val asArrow		= Lock.sync lock asArrow
    val asTuple		= Lock.sync lock asTuple
    val asProd		= Lock.sync lock asProd
    val asSum		= Lock.sync lock asSum
    val asVar		= Lock.sync lock asVar
    val asCon		= Lock.sync lock asCon
    val asAll		= Lock.sync lock asAll
    val asExist		= Lock.sync lock asExist
    val asLambda	= Lock.sync lock asLambda
    val asApply		= Lock.sync lock asApply
    val asMu		= Lock.sync lock asMu
    val asAbbrev	= Lock.sync lock asAbbrev
    val asArrow'	= Lock.sync lock asArrow'
    val asTuple'	= Lock.sync lock asTuple'
    val asProd'		= Lock.sync lock asProd'
    val asSum'		= Lock.sync lock asSum'
    val asVar'		= Lock.sync lock asVar'
    val asCon'		= Lock.sync lock asCon'
    val asAll'		= Lock.sync lock asAll'
    val asExist'	= Lock.sync lock asExist'
    val asLambda'	= Lock.sync lock asLambda'
    val asApply'	= Lock.sync lock asApply'

    val kind		= Lock.sync lock kind
    val kindVar		= Lock.sync lock kindVar
    val path		= Lock.sync lock path
    val paths		= Lock.sync lock paths

    val instance	= Lock.sync lock instance
    val skolem		= Lock.sync lock skolem
    val clone		= Lock.sync lock clone
    val cloneStart	= Lock.sync lock cloneStart
    val cloneCont	= Lock.sync lock cloneCont
    val cloneFinish	= Lock.sync lock cloneFinish
    val realise		= Lock.sync lock realise
    val realisePath	= Lock.sync lock realisePath

    val fill		= Lock.sync lock fill
    val unify		= Lock.sync lock unify
    val intersect	= Lock.sync lock intersect
    val close		= Lock.sync lock close
    val isClosed	= Lock.sync lock isClosed
    val equals		= Lock.sync lock equals
    val matches		= Lock.sync lock matches
    val hash		= Lock.sync lock hash

end


structure Type : (*DEBUG :>*) TYPE = TypePrivate
