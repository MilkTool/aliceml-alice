(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(*******************************************************************************

Types represent the type terms of the core type system, as used in the compiler
for type inference, for annotating the intermediate language, and at runtime to
implement dynamic typing. We have to make certain compromises to make the
implementation suitable for all these purposes.

Note that we use the term `type' to include type constructors, i.e. our type
language includes a full lambda calculus.

On Sharing:

For efficiency reasons, we try to maximise sharing of type structures. This
reduces space cost and speeds up comparison and unification. It is particularly
important to maintain sharing between subgraphs of different type terms on
signature substitution. Not doing this can lead to a quadratic blowup of type
terms during module type checking, particularly desastrous in the presence of
structural datatypes. Therefore, we need a special interface for realising a
sequence of related types.

An alternative would be hash-consing, but that is difficult to exploit in the
presence of circular structure and named variables, and the integration with
unification is non-obvious.

On Thread Safety:

To be appropriate for runtime typing, most operations have to be thread-safe.
We conjecture that thread-safety is given for all operations as long as they
don't operate on types containing holes. In the particular case of matching,
which creates fresh holes, they are safe because they can never escape the
thread.

On Kinds:

Extensible types must be represented by a special kind EXT. This implies atomic
subkinding between EXT and STAR. In order to have a nice encoding of modules
we also support singleton kinds. At some places we must therefore not just check
kind equality but allow for subkinding.

On Tuples and Records:

As in SML, tuples are just a special case of records. We treat tuple rows
specially however for efficiency reasons. Such indexed rows can be freely
interconverted with named rows by using numeric labels.

TODO: Make rows into types and reflect them properly in the kind system.
Currently, row variables are not really proper.

On Type Abbreviations:

We try to maintain type abbreviations to generate more user friendly output.
This is managed through a special node ABBREV, which refers to the original
type term as well as to the reduced/substituted one.

On Recursive Types:

Stockhausen makes datatypes structural sum types. This is a problem since
SML has non-uniform recursive datatypes. So in fact we not only get recursive
types but recursive type functions. It is not obvious whether type checking
remains decidable in the general case.

In order to stay on the safe side we restrict recursive types to the form
mu.\a1...\an.tau where tau is either a sum or a product type. Recursive type
functions never get reduced, we use (mu.\a1...\an.tau)(t1)..(tn) as the normal
form and define equality fully structural. Note that this implies a variation
of an iso-recursive interpretation, as there is no implicit unrolling. For two
recursive types to be compatible they must be constructed from equal type
functions. As a consequence, List(Int) and IntList will not be compatible in
the following example:

	List a  = Nil | Cons(a, List a)
	IntList = Nil | Cons(Int, IntList)

As a further restriction, a recursive type (function) may not contain any free
type variables. This allows more efficient substitution and unification for
(the potentially large) representations of mutual recursive types.

On Well-formedness and Normal Forms:

We do eager reduction, so all types are always in normal form. We thus define
a type t to be well-formed (wf) iff is well-kinded, all nested types and rows
are wf, and

	t = HOLE(k,_)	and k <> SING _
	t = VAR(k,_)	and k <> SING _
	t = ABS(k,_)	and k <> SING _
	t = LINK t'
	t = FUN(t1,t2)
	t = PROD r
	t = SUM r
	t = MU t'	and t' mu-wf
	t = ALL(a,t')	and a = VAR _
	t = EXIST(a,t')	and a = VAR _
	t = LAMBDA(a,t') and a = VAR _ and t'* <> APPLY(t'',a) where a notin t''
	t = APPLY(t1,t2) and t1* <> LAMBDA _
	t = ABBREV(t1,t2)

and t is mu-wf iff it is wf and

	t = LINK t'	and t' mu-wf
	t = PROD r	and holes(r) = 0
	t = SUM r	and holes(r) = 0
	t = LAMBDA(a,t') and t' mu-wf

and a row r is wf iff all nested types are wf and

	r = INDEXED ts
	r = NAMED(lts,_) and forall li,lj in lts, li<lj if i<j

where t* is defined as follows:

	t* = t'*	if t = LINK t'
	t* = t'*	if t = ABBREV(_,t')
	t* = t		otherwise

All public operations ought to guarantee well-formedness.

Note that unification only correctly deals with a subset of all well-formed
types. TODO: Have to specify this in detail.

On Type Levels and other Annotations:

As usual, holes carry a number indicating their scope level, to allow for
efficient generalisation. Likewise, variables - which can be used as skolem
types - carry a level to detect existential type variables escaping their
scope easily.

To keep the representation compact (we externalise it) we do not annotate the
type level at each individual node. Neither do we annotate free variables at
each node, like some other implementations do. Unification seems to be
reasonable efficient without it (presuming the restriction about free variables
under MU).

On Unification:

Unification is kinded. But to keep decidability, variables (holes) may not be
unified with lambda terms. To deal with the normal form of recursive types we
allow unification with recursive type functions, however, as well as structural
unification of two lambda terms. Both are safe, as they never produce a redex.

Occurences of MU cut off the occur check. Note that since there are no free
type variables allowed under MU, there can never be a hole either, anyway.

*******************************************************************************)

import structure Assert  from "../utility/Assert"
import structure Cell    from "../utility/Cell"
import structure Name    from "Name"
import structure Label   from "Label"
import structure Path    from "Path"
import structure PathMap from "PathMap"
import signature TYPE    from "TYPE-sig"

(*DEBUG
import fun print from "../system/TextIO"
*)

structure Type :> TYPE =
struct
  (* Types *)

    open Cell

    type lab  = Label.t					(* [lab,l] *)
    type path = Path.t					(* [pi,p] *)

    datatype typ' =					(* [tau',t'] *)
	  LINK   of typ		(* forward (needed for unification) *)
	| HOLE   of kind * int	(* variable for inference *)
	| VAR    of kind * int	(* bound variable or skolem types *)
	| ABS    of kind * path	(* constructor (of arbitrary kind) *)
	| FUN    of typ * typ	(* arrow type *)
	| PROD   of row		(* product (tuple or record) *)
	| SUM    of row		(* sum type (datatype) *)
	| MU     of typ		(* recursive type *)
	| ALL    of var * typ	(* universal quantification *)
	| EXIST  of var * typ	(* existential quantification *)
	| LAMBDA of var * typ	(* abstraction (type function) *)
	| APPLY  of typ * typ	(* application *)
	| ABBREV of typ * typ	(* abbreviations (#2 is unabbreviated type) *)

    and kind' =						(* [kappa',k'] *)
	  STAR			(* plain type *)
	| EXT			(* extensible type *)
	| ARROW  of kind * kind	(* type function *)
	| SING   of typ		(* singleton *)

    and row' =						(* [rho,r] *)
	  INDEXED of typ vector
	| NAMED   of (lab * typ) list * int option

    withtype typ	= typ' cell			(* [tau,t] *)
    and      var	= typ' cell			(* [alpha,a] *)
    and      row	= row'
    and      kind	= kind' cell			(* [kappa,k] *)

    structure Map	= Cell.MkMap(type t = typ')
    structure KindMap	= Cell.MkMap(type t = kind')

    type t		= typ
    type canonical_typ	= typ
    type rea		= typ PathMap.t
    type subst		= typ Map.t


  (* Level management *)

    val globalLevel	= 0
    val level		= ref(globalLevel+1)

    fun enterLevel()	= level := !level+1
    fun exitLevel()	= level := !level-1
    fun resetLevel()	= level := globalLevel+1


  (* Very basic helpers *)

    val same		= Cell.equals
    val sameKind	= Cell.equals

    fun fromCanonical t	= t
    fun canonical t	= case content t of LINK t => canonical t | _ => t

    (* Almost everything in this module is mutually recursive. To avoid
     * confusing reordering and allow for easy tracing (see below) we use
     * the old forward reference trick.
     *)

    val appFwd 		= ref NONE : ((typ -> unit) -> typ -> unit) option ref
    val equalsFwd 	= ref NONE : (typ * typ -> bool) option ref
    val substFwd	= ref NONE : (subst * typ -> typ) option ref

    fun app f		= Option.valOf(!appFwd)    f
    fun equals(t1,t2)	= Option.valOf(!equalsFwd) (t1,t2)
    fun subst(m,t)	= Option.valOf(!substFwd)  (m,t)


  (* Debugging aids *)

    fun trace f s	= f
    val newKind		= new

    (*DEBUG: The following allows tracing of all type nodes.

    fun id t = Int.toString(hash t)

    val rec typ'ToString =
	fn LINK t	=> "LINK(" ^ id t ^ ")"
	 | HOLE _	=> "HOLE"
	 | VAR _	=> "VAR"
	 | ABS(_,p)	=> "ABS(" ^ Label.toString(Path.toLab p) ^ "["
				  ^ Int.toString(Path.hash p) ^ "])"
	 | FUN(t1,t2)	=> "FUN(" ^ id t1 ^ "," ^ id t2 ^ ")"
	 | PROD r	=> "PROD(" ^ rowToString r ^ ")"
	 | SUM r	=> "SUM(" ^ rowToString r ^ ")"
	 | MU t		=> "MU(" ^ id t ^ ")"
	 | ALL(a,t)	=> "ALL(" ^ id a ^ "," ^ id t ^ ")"
	 | EXIST(a,t)	=> "EXIST(" ^ id a ^ "," ^ id t ^ ")"
	 | LAMBDA(a,t)	=> "LAMBDA(" ^ id a ^ "," ^ id t ^ ")"
	 | APPLY(t1,t2)	=> "APPLY(" ^ id t1 ^ "," ^ id t2 ^ ")"
	 | ABBREV(t1,t2) => "ABBREV(" ^ id t1 ^ "," ^ id t2 ^ ")"

    and rowToString =
	fn INDEXED ts   => String.separate "," (Vector.toList(Vector.map id ts))
	 | NAMED(lts,d) => String.separate "," (List.map fieldToString lts @
				      (if Option.isNone d then [] else ["..."]))
    and fieldToString =
	fn (l,t)        => Label.toString l ^ ":" ^ id t

    fun typToString t = id t ^ "=" ^ typ'ToString(content t)

    val currentFn = ref "external"

    fun trace f s x =
	let
	    val s' = !currentFn
	in
	    currentFn := s;
	    f x before currentFn := s'
	    handle e => (currentFn := s' ; raise e)
	end

    val new = fn t' =>
	let
	    val t = new t'
	in
	    print("new " ^ id t ^ " = " ^ typ'ToString t' ^
		  " by " ^ !currentFn ^ "\n");
	    t
	end

    val replace = fn(t,t') =>
	( print("replace " ^ id t ^ " = " ^ typ'ToString(content t) ^
		" with " ^ typ'ToString t' ^ " by " ^ !currentFn ^ "\n");
	  replace(t,t')
	)

    val replace = fn(t1,t2') =>
	let val t1' = content t1 in
	    replace(t1,t2');
	    if case (t1', t2')
		 of (HOLE _, LAMBDA _)	=> false
		  | ( (HOLE _, _)
		    | (_, LINK _)
		    | (PROD _, PROD _)
		    | (SUM _, SUM _)
		    | (VAR _, VAR _)
		    | (MU _, MU _) )	=> true
		  | _ => false
	    then () else ( print "!!!!"; TextIO.inputLine TextIO.stdIn; () )
	end
    *)


  (* Kinds *)

    exception Kind

    val kStar			= newKind STAR
    val kExt			= newKind EXT
    fun starKind()		= kStar
    fun extKind()		= kExt
    fun arrowKind(k1,k2)	= newKind(ARROW(k1,k2))
    fun singKind t		= let val k = kind t in
				      if isSingKind k
				      then k
				      else newKind(SING t)
				  end

    and kindVar a		= kind a
    and kind t =
	case content t
	  of ( LINK t | MU t
	     | ABBREV(_,t) )	=> kind t
	   | HOLE(k,_)		=> k
	   | VAR(k,_)		=> k
	   | ABS(k,_)		=> k
	   | LAMBDA(a,t)	=> arrowKind(kind a, kind t)
	   | APPLY(t1,t2)	=> #2(asArrowKind(kind t1))
	   | _			=> starKind()

    and asArrowKind k =
	case content k
	  of (STAR | EXT)	=> raise Kind
	   | ARROW kk		=> kk
	   | SING t		=> asArrowKind(kind t)
    and asSingKind k =
	case content k
	  of SING t		=> t
	   | _			=> raise Kind

    and isStarKind k =
	case content k
	  of (STAR | EXT)	=> true
	   | ARROW _		=> false
	   | SING t		=> isStarKind(kind t)
    and isExtKind k =
	case content k
	  of EXT		=> true
	   | (STAR | ARROW _)	=> false
	   | SING t		=> isExtKind(kind t)
    and isArrowKind k =
	case content k
	  of (STAR | EXT)	=> false
	   | ARROW _		=> true
	   | SING t		=> isArrowKind(kind t)
    and isSingKind k =
	case content k
	  of SING _		=> true
	   | _			=> false

    fun equalsKind(k1,k2) =
	Cell.equals(k1,k2) orelse
	case (content k1, content k2)
	  of (STAR, STAR)	=> true
	   | (EXT,  EXT)	=> true
	   | (ARROW(k11,k12),
	      ARROW(k21,k22))	=> equalsKind(k21,k11) andalso
				   equalsKind(k12,k22)
	   | (SING t1, SING t2)	=> equals(t1,t2)
	   | _			=> false

    fun matchesKind(k1,k2) =
	Cell.equals(k1,k2) orelse
	case (content k1, content k2)
	  of (STAR, STAR)	=> true
	   | (EXT,  STAR)	=> true
	   | (EXT,  EXT)	=> true
	   | (ARROW(k11,k12),
	      ARROW(k21,k22))	=> matchesKind(k21,k11) andalso
				   matchesKind(k12,k22)
	   | (SING t1, SING t2)	=> equals(t1,t2)
	   | (SING t1, _)	=> matchesKind(kind t1, k2)
	   | _			=> false


  (* Creation and injection, reduction *)

    exception Type

    fun asType t =
	case content t
	  of (LINK t | ABBREV(_,t))	=> asType t
	   | _				=> t
    fun asType' t = content(asType t)

    fun canonicalVar t	=
	let val t' = canonical t in
	    case content t'
	      of VAR(k,n)		=> if n = globalLevel then ()
					   else replace(t', VAR(k,globalLevel))
	       | HOLE(k,n)		=> replace(t', VAR(k,globalLevel))
	       | _			=> raise Type;
	    t'
	end

    fun unknown' k	= new(HOLE(k, !level))
    fun newVar' k	= new(VAR(k, !level))

    fun abs'(k,p)	= new(ABS(k,p))
    fun arrow'(t1,t2)	= new(FUN(t1,t2))
    fun tuple' ts	= new(PROD(INDEXED ts))
    fun prod' r		= new(PROD r)
    fun sum' r		= new(SUM r)
    fun mu' t		= new(MU t)
    fun all'(a,t)	= new(ALL(canonicalVar a, t))
    fun exist'(a,t)	= new(EXIST(canonicalVar a, t))

    fun abbrev'(t1,t2)	= new(ABBREV(reduceAbbrevL t1, reduceAbbrevR t2))
    and reduceAbbrevL t	=
	case content t
	  of (ABBREV(t1,_) | LINK t1)	=> reduceAbbrevL t1
	   | _				=> t
    and reduceAbbrevR t	=
	case content t
	  of (ABBREV(_,t2) | LINK t2)	=> reduceAbbrevR t2
	   | _				=> t

    fun lambda'(a,t) = reduceEta(canonicalVar a, t)
    and reduceEta(a,t) =
	case content t
	  of APPLY(t1,t2) =>
		if Cell.equals(a, asType t2) andalso not(occurs(a,t1))
		then t1
		else new(LAMBDA(a,t))
	   | (LINK t1 | ABBREV(_,t1)) =>
		reduceEta(a,t1)
	   (* Not needed, since k is never singleton
	   | (HOLE(k,_) | VAR(k,_) | ABS(k,_)) =>
		if isSingKind k
		then reduceEta(a, asSingKind k)
		else new(LAMBDA(a,t))
	   *)
	   | _ =>
		new(LAMBDA(a,t))
    and occurs(t1,t2) =
	let
	    exception Occurs
	    fun occurs1 t = if Cell.equals(t1,t) then raise Occurs else ()
	in
	    ( app occurs1 t2 ; false ) handle Occurs => true
	end

    fun apply'(t1,t2) = reduceBeta(t1, t1, canonical t2, NONE)
    and reduceBeta(t1, t1', t2, to) =
	case content t1'
	  of LAMBDA(a,t3) =>
	     let
		 val m   = Map.new()
		 val _   = Map.insert(m, a, t2)
		 val t3' = subst(m,t3)
	     in
		 case to of NONE    => t3'
			  | SOME t4 => abbrev'(apply'(t4,t2), t3')
	     end
	   | LINK t1' =>
		reduceBeta(t1, t1', t2, to)
	   | ABBREV(t11,t12) =>
		reduceBeta(t1, t12, t2, SOME(Option.getOpt(to,t11)))
	   (* Not needed, since k is never singleton
	   | (HOLE(k,_) | VAR(k,_) | ABS(k,_)) =>
		if isSingKind k
		then reduceBeta(t1, asSingKind k, t2, to)
		else new(APPLY(t1,t2))
	   *)
	   | _ =>
		new(APPLY(t1,t2))

    (*DEBUG*)
    val abbrev' = trace abbrev' "abbrev'"
    val lambda' = trace lambda' "lambda'"
    val apply'  = trace apply'  "apply'"

    (* kind-safe interface *)

    fun canonicalStar t	= let val t' = canonical t in
			      if isStarKind(kind t')
			      then t'
			      else raise Kind
			  end

    fun unknown k	= if isSingKind k then asSingKind k else unknown' k
    val newVar		= newVar'
    fun var a		= let val k = kind a in
			  if isSingKind k then asSingKind k else a end
    fun abs(k,p)	= if isSingKind k then asSingKind k else abs'(k,p)
    fun arrow(t1,t2)	= arrow'(canonicalStar t1, canonicalStar t2)
    fun tuple ts	= tuple'(Vector.map canonicalStar ts)
    val prod		= prod'
    val sum		= sum'
    fun all(a,t)	= all'(a, canonicalStar t)
    fun exist(a,t)	= exist'(a, canonicalStar t)
    fun abbrev(t1,t2)	= if matchesKind(kind t2, kind t1)
			  then abbrev'(t1,t2)
			  else raise Kind
    val lambda		= lambda'
    fun apply(t1,t2)	= if matchesKind(kind t2, #1(asArrowKind(kind t1)))
			  then apply'(t1,t2)
			  else raise Kind


  (* Rows *)

    exception Row

    fun emptyRow()		= INDEXED #[]
    fun unknownRow()		= NAMED([], SOME(!level))

    fun isIndexed r =
	case r
	  of INDEXED _		=> true
	   | NAMED(lts,d)	=> Option.isNone d andalso isIndexed'(lts,1)
    and isIndexed'(lts,i) =
	case lts
	  of []			=> true
	   | (l,t)::lts'	=>
	case Label.toInt l
	  of NONE		=> false
	   | SOME i'		=> i' = i andalso isIndexed'(lts',i+1)

    fun indexedToNamed ts =
	List.tabulate(Vector.length ts,
		      fn i => (Label.fromInt(i+1), Vector.sub(ts,i)))

    fun namedToIndexed lts =
	Vector.rev(Vector.fromList(List.mapi namedToIndexed' lts))
	handle Overflow => raise Row
    and namedToIndexed'(i,(l,t)) =
	case Label.toInt l
	  of NONE		=> raise Row
	   | SOME i'		=> if i' = i+1 then t else raise Row

    fun asIndexed r =
	case r
	  of INDEXED ts		=> ts
	   | NAMED(lts,NONE)	=> namedToIndexed lts
	   | NAMED(_,SOME _)	=> raise Row
    fun asNamed r =
	case r
	  of INDEXED ts		=> (indexedToNamed ts, NONE)
	   | NAMED x		=> x

    fun extendRow(l,t,r)	= let val (lts,d) = asNamed r in
				     NAMED(extendRow'(l,canonicalStar t,lts), d)
				  end
    and extendRow'(l,t, [])                   = [(l,t)]
      | extendRow'(l,t, lts as (l',t')::lts') =
	case Label.compare(l,l')
	  of EQUAL		=> raise Row
	   | LESS		=> (l,t)::lts
	   | GREATER		=> (l',t')::extendRow'(l,t,lts')

    fun isEmptyRow r =
	case r
	  of INDEXED #[]	=> true
	   | NAMED([],_)	=> true
	   | _			=> false

    fun isUnknownRow r =
	case r
	  of INDEXED _		=> false
	   | NAMED(_,d)		=> isSome d

    fun hdRow r =
	(case r
	   of INDEXED ts	=> (Label.fromInt 1, Vector.sub(ts,0))
	    | NAMED(lts,d)	=> List.hd lts
	)
	handle(Subscript|Empty)	=> raise Row

    fun tlRow r =
	let
	    val (lts,d) = asNamed r
	in
	    NAMED(List.tl lts, d) handle Empty => raise Row
	end

    fun lookupRow(r,l) =
	case r
	  of INDEXED ts		=> (Vector.sub(ts,Option.valOf(Label.toInt l)-1)
				    handle (Option | Subscript) => raise Row)
	   | NAMED(lts,d)	=> lookupRow'(lts,l)
    and lookupRow'([], l) =
	    raise Row
      | lookupRow'((l',t)::lts, l) =
	case Label.compare(l',l)
	  of EQUAL		=> t
	   | LESS		=> lookupRow'(lts,l)
	   | GREATER		=> raise Row


  (* Fixed point for recursive types *)

    (*
     * The fix function takes a list of type equations of the form
     *   ci = \vi1 .. \vin . tau
     * where tau is a sum or product type without holes, and constructs the
     * fixed point type graph of these mutual recursive equations. The function
     * raises Domain if one of the LHSs is not a hole (or an abbreviation
     * thereof) or a RHS does not meet the above requirements.
     *)

    exception Fix

    fun fixLHS(t, to) =
	case content t
	  of LINK t1       => fixLHS(t1, to)
	   | ABBREV(t1,t2) => fixLHS(t2, SOME(Option.getOpt(to, t1)))
	   | HOLE _        => (t, to)
	   | _             => raise Fix

    fun fixRHS t =
	case content t
	  of (LINK t1 | ABBREV(_,t1) | LAMBDA(_,t1)) => fixRHS t1
	   | (PROD _ | SUM _) => () (*if isClosed t then () else raise Fix*)
	   | _                => raise Fix

    fun tie(t1,t2) =
	let
	    val (t1',to) = fixLHS(t1, NONE)
	    val  _       = fixRHS t2
	    val  t2'     = mu' t2
	in
	    if not(matchesKind(kind t2', kind t1')) then raise Fix else
	    replace(t1', case to of NONE    => LINK t2'
				  | SOME t3 => ABBREV(t3,t2'))
	end

    val fix = Vector.app tie

    (*DEBUG*)
    val fix = trace fix "fix"


  (* Projections and extractions *)

    fun isAbbrev t =
	case content t
	  of LINK t1			=> isAbbrev t1
	   | ABBREV _			=> true
	   | _				=> false
    fun asAbbrev t =
	case content t
	  of LINK t1			=> asAbbrev t1
	   | ABBREV tt			=> tt
	   | _				=> raise Type

    fun isUnknown t	= case asType' t of HOLE _   => true | _ => false
    fun isVar t		= case asType' t of VAR _    => true | _ => false
    fun isAbs t		= case asType' t of ABS _    => true | _ => false
    fun isArrow t	= case asType' t of FUN _    => true | _ => false
    fun isTuple t	= case asType' t of PROD r   => isIndexed r | _ => false
    fun isProd t	= case asType' t of PROD _   => true | _ => false
    fun isSum t		= case asType' t of SUM _    => true | _ => false
    fun isMu t		= case asType' t of MU _     => true | _ => false
    fun isAll t		= case asType' t of ALL _    => true | _ => false
    fun isExist t	= case asType' t of EXIST _  => true | _ => false
    fun isLambda t	= case asType' t of LAMBDA _ => true | _ => false
    fun isApply t	= case asType' t of APPLY _  => true | _ => false

    fun asVar t		= case asType' t of VAR _     => t  | _ => raise Type
    fun asAbs t		= case asType' t of ABS(k,p)  => p  | _ => raise Type
    fun asArrow t	= case asType' t of FUN tt    => tt | _ => raise Type
    fun asTuple t	= case asType' t of PROD r    => (asIndexed r handle Row
								=> raise Type)
							    | _ => raise Type
    fun asProd t	= case asType' t of PROD r    => r  | _ => raise Type
    fun asSum t		= case asType' t of SUM r     => r  | _ => raise Type
    fun asMu t		= case asType' t of MU t      => t  | _ => raise Type
    fun asAll t		= case asType' t of ALL at    => at | _ => raise Type
    fun asExist t	= case asType' t of EXIST at  => at | _ => raise Type
    fun asLambda t	= case asType' t of LAMBDA at => at | _ => raise Type
    fun asApply t	= case asType' t of APPLY tt  => tt | _ => raise Type

    (* modulo unrolling *)

    fun isType' t =
	case content t
	  of (LINK t1 | ABBREV(_,t1))
				=> isType' t1
	   | APPLY _		=> isTypeApply(t,0)
	   | t'			=> t'
    and isTypeApply(t, n) =
	case content t
	  of (LINK t1 | ABBREV(_,t1))
				=> isTypeApply(t1,n)
	   | APPLY(t1,t2)	=> isTypeApply(t1,n+1)
	   | MU t1		=> isTypeFunc(t1,n)
	   | _			=> APPLY(t,t)	(*dummy*)
    and isTypeFunc(t, 0) = content t
      | isTypeFunc(t, n) =
	case content t
	  of (LINK t1 | MU t1)	=> isTypeFunc(t1,n)
	   | ABBREV(t1,t2)	=> isTypeFunc(t2,n)
	   | LAMBDA(a,t1)	=> isTypeFunc(t1,n-1)
	   | _			=> APPLY(t,t)	(*dummy*)

    fun isTuple' t	= case isType' t of PROD r   => isIndexed r | _ => false
    fun isProd' t	= case isType' t of PROD _   => true | _ => false
    fun isSum' t	= case isType' t of SUM _    => true | _ => false

    fun asType' t =
	case content t
	  of (LINK t1 | ABBREV(_,t1))	=> asType' t1
	   | MU t1			=> content t1
	   | t' as APPLY _		=> asTypeApply(t',t,[])
	   | t'				=> t'
    and asTypeApply(t',t,ts) =
	case content t
	  of APPLY(t1,t2)		=> asTypeApply(t',t1,t2::ts)
	   | (LINK t1 | ABBREV(_,t1))	=> asTypeApply(t',t1,ts)
	   | MU t1			=> let val m = Map.new() in
					       Map.insert(m,t,t);
					       asTypeLambda(t',m,t1,ts)
					   end
	   | _				=> t'
    and asTypeLambda(t',m,t,ts) =
	case (content t, ts)
	  of (_, [])			=> content(subst(m,t))
	   | (LAMBDA(a,t1), t2::ts')	=> (Map.insert(m,a,t2);
					    asTypeLambda(t',m,t1,ts'))
	   | ((LINK t1|ABBREV(_,t1)),_)	=> asTypeLambda(t',m,t1,ts)
	   |  _				=> t'

    (*DEBUG*)
    val asType'		= trace asType' "asType'"

    fun asTuple' t	= case asType' t of PROD r => (asIndexed r handle Row =>
								   raise Type)
							 | _ => raise Type
    fun asProd' t	= case asType' t of PROD r => r  | _ => raise Type
    fun asSum' t	= case asType' t of SUM r  => r  | _ => raise Type


  (* General purpose type graph traversal *)

    (* We have two ways of traversing types:
     * - ignoring abbreviations (eg. for closure check)
     * - not ignoring abbreviations (eg. realisations, lifting)
     *)

    fun app1(t,f,b)			= app1'(content t, f, b)
    and app1'(( HOLE _
	      | VAR _
	      | ABS _ ), f, b)		= ()
      | app1'(( LINK t
	      | MU t ), f, b)		= f t
      | app1'(( ALL(a,t)
	      | EXIST(a,t)
	      | LAMBDA(a,t) ), f, b)	= (f a ; f t)
      | app1'(( FUN(t1,t2)
	      | APPLY(t1,t2) ), f, b)	= (f t1 ; f t2)
      | app1'(( ABBREV(t1,t2) ), f, b)	= if b then (f t1 ; f t2) else f t2
      | app1'(( PROD r
	      | SUM r ), f, b)		= appRow1(r,f)

    and appRow1(INDEXED ts, f)		= Vector.app f ts
      | appRow1(NAMED(lts,d), f)	= List.app (f o #2) lts


    fun foldl1(t,f,c,b)			= foldl1'(content t, f, c, b)
    and foldl1'(( HOLE _
		| VAR _
		| ABS _ ), f,c,b)	= c
      | foldl1'(( LINK t
		| MU t ), f,c,b)	= f(t,c)
      | foldl1'(( ALL(a,t)
		| EXIST(a,t)
		| LAMBDA(a,t) ), f,c,b)	= f(t, f(a,c))
      | foldl1'(( FUN(t1,t2)
		| APPLY(t1,t2)), f,c,b)	= f(t2, f(t1,c))
      | foldl1'(( ABBREV(t1,t2)),f,c,b)	= if b then f(t2, f(t1,c)) else f(t2,c)
      | foldl1'(( PROD r
		| SUM r ), f,c,b)	= foldlRow1(r,f,c)

    and foldlRow1(INDEXED ts, f,c)	= Vector.foldl f c ts
      | foldlRow1(NAMED(lts,d), f,c)	= List.foldl (fn((l,t),c)=>f(t,c)) c lts

    fun app'(b,f,t) =
	let
	    val m = Map.new()

	    fun app t =
		if Map.member(m,t) then () else
		( f t;
		  Map.insert(m,t,());
		  app1(t,app,b)
		)
	in
	    app t
	end

    fun app f t          = app'(true, f, t)
    fun appNoAbbrevs f t = app'(false, f, t)

    fun foldl'(b,f,c,t) =
	let
	    val m = Map.new()

	    fun foldl(t,c) =
		if Map.member(m,t) then c else
		let
		    val c' = f(t,c)
		in
		    Map.insert(m,t,());
		    foldl1(t,foldl,c',b)
		end
	in
	    foldl(t,c)
	end

    fun foldl f c t          = foldl'(true, f, c, t)
    fun foldlNoAbbrevs f c t = foldl'(false, f, c, t)


  (* Cloning for substitution. *)

    (* Minimizes the part of the graph that is being copied.
     *
     * To make handling of recursive types efficient we only descent
     * below MU if the rea is non-empty! Since we only use the function
     * with empty rea to substitute type variables, and no free variables
     * may appear below mu, this is okay. Otherwise one could still enter
     * some dummy entry...
     *
     * For recursive types, we do not take care of inner sharing to avoid
     * another map (inner sharing will be rare because the compiler does not
     * construct recursive types by unification, they have to
     * be explicitly written down by the programmer which limits their size
     * to linear unfoldings).
     * --- I don't understand this comment anymore... 8-}
     *)

    fun build(mt,mk, rea, t) =
	case Map.lookup(mt,t)
	  of SOME t'		=> t'
	   | NONE		=>
	case content t
	  of LINK t1		=> build(mt,mk, rea, t1)
	   | (HOLE _ | VAR _)	=> buildOld(mt,t)
				   (* Mh, we cannot handle substitution in
				    * singleton kinds in holes and vars... *)
	   | ABS(k,p) 		=> (case PathMap.lookup(rea, p)
				      of SOME t' =>
					     if matchesKind(kind t',k)
					     then buildNew(mt,t,t')
					     else raise Kind
				       | NONE =>
					 let val k' = buildKind(mt,mk,rea,k) in
					     if Cell.equals(k,k')
					     then buildOld(mt,t)
					     else buildNew(mt,t,abs'(k',p))
					 end
				   )
	   | FUN(t1,t2)		=> buildPair(mt,mk, rea, t, arrow',t1,t2)
	   | PROD r		=> buildRow(mt,mk, rea, t, prod',r)
	   | SUM r		=> buildRow(mt,mk, rea, t, sum',r)
	   | ALL(a,t1)		=> buildBind(mt,mk, rea, t, all',a,t1)
	   | EXIST(a,t1)	=> buildBind(mt,mk, rea, t, exist',a,t1)
	   | LAMBDA(a,t1)	=> buildBind(mt,mk, rea, t, lambda',a,t1)
	   | APPLY(t1,t2)	=> buildPair(mt,mk, rea, t, apply',t1,t2)
	   | ABBREV(t1,t2)	=> buildPair(mt,mk, rea, t, abbrev',t1,t2)
	   | MU t1		=> if not(hasFree(ref [t], mt,mk, rea, t1))
				   then buildOld(mt, t)
				   else let
				       val t'  = buildNew(mt, t, new(MU t1))
				       val t1' = build(mt,mk, rea, t1)
				   in
				       replace(t', MU t1'); t'
				   end
    and buildOld(mt,t)    = (Map.insert(mt,t,t); t)
    and buildNew(mt,t,t') = (Map.insert(mt,t,t'); t')

    and buildBind(mt,mk, rea, t, toTyp, a,t1) =
	let
	    val t1  = canonical t1
	    val t1' = case Map.lookup(mt,a)
			of NONE    => build(mt,mk,rea,t1)
			 | SOME a' => (Map.insert(mt,a,a);
				       build(mt,mk,rea,t1)
				       before Map.insert(mt,a,a'))
	in
	    if Cell.equals(t1,t1')
	    then buildOld(mt, t)
	    else buildNew(mt, t, toTyp(a,t1'))
	end

    and buildPair(mt,mk, rea, t, toTyp, t1,t2) =
	let
	    val t1  = canonical t1
	    val t2  = canonical t2
	    val t1' = build(mt,mk,rea,t1)
	    val t2' = build(mt,mk,rea,t2)
	in
	    if Cell.equals(t1,t1') andalso Cell.equals(t2,t2')
	    then buildOld(mt, t)
	    else buildNew(mt, t, toTyp(t1',t2'))
	end

    and buildRow(mt,mk, rea, t, toTyp, INDEXED ts) =
	let
	    val ts' = Vector.map (fn ti => build(mt,mk,rea,ti)) ts
	in
	    if VectorPair.all (fn(t,t') => Cell.equals(canonical t,t')) (ts,ts')
	    then buildOld(mt, t)
	    else buildNew(mt, t, toTyp(INDEXED ts'))
	end
      | buildRow(mt,mk, rea, t, toTyp, NAMED(lts,d)) =
	let
	    val lts' = List.map (fn(li,ti) => (li, build(mt,mk,rea,ti))) lts
	in
(*ASSERT    assert isNone d => *)
	    if isSome d then raise Assert.failure else
	    if ListPair.all (fn((_,t),(_,t')) => Cell.equals(canonical t,t'))
			    (lts,lts')
	    then buildOld(mt, t)
	    else buildNew(mt, t, toTyp(NAMED(lts',d)))
	end

    and buildKind(mt,mk, rea, k) =
	case KindMap.lookup(mk,k)
	  of SOME k'		=> k'
	   | NONE		=>
	case content k
	  of (STAR | EXT)	=> buildOldKind(mk,k)
	   | ARROW(k1,k2)	=>
		let
		    val k1' = buildKind(mt,mk,rea,k1)
		    val k2' = buildKind(mt,mk,rea,k2)
		in
		    if Cell.equals(k1,k1') andalso Cell.equals(k2,k2')
		    then buildOldKind(mk, k)
		    else buildNewKind(mk, k, arrowKind(k1',k2'))
		end
	   | SING t		=>
		let
		    val t' = build(mt,mk,rea,t)
		in
		    if Cell.equals(t,t')
		    then buildOldKind(mk, k)
		    else buildNewKind(mk, k, singKind t')
		end

    and buildOldKind(mk,k)    = (KindMap.insert(mk,k,k); k)
    and buildNewKind(mk,k,k') = (KindMap.insert(mk,k,k'); k')

    and hasFree(mus, mt,mk, rea, t) =
	(*ASSUME that if rea is empty we are only substituting vars! *)
	not(PathMap.isEmpty rea) andalso
	not(List.exists (fn t' => Cell.equals(t',t)) (!mus)) andalso
	case Map.lookup(mt,t)
	  of SOME t'		=> not(Cell.equals(t,t'))
	   | NONE		=>
	case content t
	  of LINK t1		=> hasFree(mus, mt,mk, rea, t1)
	   | (HOLE _ | VAR _)	=> false (* cannot treat singletons... *)
	   | ABS(k,p) 		=> Option.isSome(PathMap.lookup(rea, p))
				   orelse kindHasFree(mus, mt,mk, rea, k)
	   | ( FUN(t1,t2)
	     | APPLY(t1,t2)
	     | ABBREV(t1,t2) )	=> hasFree(mus,mt,mk,rea,t1) orelse
				   hasFree(mus,mt,mk,rea,t2)
	   | (PROD r | SUM r)	=> rowHasFree(mus,mt,mk,rea,r)
	   | MU t1		=> (mus := t :: !mus; hasFree(mus,mt,mk,rea,t1))
	   | ( ALL(a,t1)
	     | EXIST(a,t1) 
	     | LAMBDA(a,t1) )	=> hasFree(mus, mt,mk, rea, t1)

    and rowHasFree(mus, mt,mk, rea, r) =
	case r
	  of INDEXED ts   => Vector.exists (fn t => hasFree(mus,mt,mk,rea,t)) ts
	   | NAMED(lts,_) => List.exists (fn(l,t)=>hasFree(mus,mt,mk,rea,t)) lts

    and kindHasFree(mus, mt,mk, rea, k) =
	case KindMap.lookup(mk,k)
	  of SOME k'		=> not(Cell.equals(k,k'))
	   | NONE		=>
	case content k
	  of (STAR | EXT)	=> false
	   | ARROW(k1,k2)	=> kindHasFree(mus,mt,mk,rea,k1) orelse
				   kindHasFree(mus,mt,mk,rea,k2)
	   | SING t		=> hasFree(mus,mt,mk,rea,t)


  (* Substitution and realisation *)

    fun subst(m, t) =
	if Map.isEmpty m
	then t
	else build(m, KindMap.new(), PathMap.new(), t)

    fun realise(rea, t) =
	if PathMap.isEmpty rea
	then t
	else build(Map.new(), KindMap.new(), rea, t)

    fun realiseKind(rea, k) =
	if PathMap.isEmpty rea
	then k
	else buildKind(Map.new(), KindMap.new(), rea, k)

    type realise_state = {typ : typ Map.t, kind : kind KindMap.t}

    fun realiseStart() = {typ = Map.new(), kind = KindMap.new()}

    fun realiseCont(m : realise_state, rea, t) =
	if PathMap.isEmpty rea
	then t
	else build(#typ m, #kind m, rea, t)

    fun realiseKindCont(m : realise_state, rea, k) =
	if PathMap.isEmpty rea
	then k
	else buildKind(#typ m, #kind m, rea, k)


    (*DEBUG*)
    val subst           = trace subst "subst"
    val realise         = trace realise "realise"
    val realiseCont     = trace realiseCont "realiseCont"
    val realiseKind     = trace realiseKind "realiseKind"
    val realiseKindCont = trace realiseKindCont "realiseKindCont"


  (* Instantiation *)

    (* Instantiate universally quantified types, skolemise
     * existentially qualified types.
     * Skolemisation does it the other way round (needed for checking rank 2
     * signature applications and existential types).
     *)

    fun instance t = instance'(Map.new(), t)
    and instance'(m, t) =
	case content t
	  of LINK t	=> instance'(m,t)
	   | ABBREV(t1,t2) => instance'(m,t2)
	   | ALL(a,t)	=> (Map.insert(m, a, unknown'(kind a));
			    instance'(m,t))
	   | EXIST(a,t)	=> (Map.insert(m, a, newVar'(kind a));
			    instance'(m,t))
	   | _		=> subst(m, t)

    fun skolem t = skolem'(Map.new(), t)
    and skolem'(m, t) =
	case content t
	  of LINK t	=> skolem'(m,t)
	   | ABBREV(t1,t2) => skolem'(m,t2)
	   | ALL(a,t)	=> (Map.insert(m, a, newVar'(kind a));
			    instance'(m,t))
	   | EXIST(a,t)	=> (Map.insert(m, a, unknown'(kind a));
			    instance'(m,t))
	   | _		=> subst(m, t)

    (*DEBUG*)
    val instance = trace instance "instance"
    val skolem   = trace skolem "skolem"


  (* Check for holes *)

    exception Unclosed

    fun checkClosedRow(NAMED(_,SOME _))	= raise Unclosed
      | checkClosedRow _		= ()

    fun checkClosed'(HOLE _)		= raise Unclosed
      | checkClosed'(PROD r | SUM r)	= checkClosedRow r
      | checkClosed' _			= ()

    fun isClosed t =
	( appNoAbbrevs (fn t => checkClosed'(content t)) t ; true )
	handle Unclosed => false


  (* Closure *)

    (* Quantifies over all holes with level larger than current
     * and replaces them by variables.
     *)

    fun close ts =
	let
	    val generalise =
		foldl close1 (fn t => t) (tuple'(Vector.fromList ts))
		(* TODO: This should better use foldlNoAbbrev, but then
		 * we had to lift holes in abbreviations somehow. *)
	in
	    List.map generalise ts
	end

    and close1(t, f) =
	case content t
	  of HOLE(k,n)	=> if n <= !level then f else (fn t2 => f(all'(t,t2)))
	   | PROD r	=> (replace(t, PROD(closeRow r)) ; f)
	   | SUM r	=> (replace(t, SUM(closeRow r)) ; f)
	   | _		=> f

    and closeRow r =
	case r
	  of NAMED(r',SOME n)	=> if n <= !level then r else NAMED(r',NONE)
	   | _			=> r

    (*DEBUG*)
    val close = trace close "close"


  (* Combined occur check and lifting of a type to the current level *)

    exception Lift  of var
    exception Unify of typ * typ

    fun liftAndCheck(n,t1,t2) =
	let
	    val m = Map.new()

	    fun lift t =
		if Cell.equals(t1,t) then raise Unify(t1,t2) else
		if Map.member(m,t) then () else
		Map.insert(m,t,()) before
		(case content t
		  of HOLE(k,n')	=> if n' <= n then () else replace(t, HOLE(k,n))
		   | VAR(k,n')	=> if n' <= n then () else raise Lift t
		   | PROD r	=> liftRow(t, PROD, r)
		   | SUM r	=> liftRow(t, SUM, r)
		   | MU _	=> ()	(*ASSUME no holes under mu *)
		   | t'		=> app1'(t', lift, true)
		)
	    and liftRow(t, CONS, r) =
		(case r
		   of NAMED(fs,SOME n')	=>
			if n' <= n then ()
			else replace(t, CONS(NAMED(fs,SOME n)))
		    | _			=> ();
		 appRow1(r, lift)
		)
	in
	    lift t2
	end

    val dummy      = newVar(starKind())
    fun lift'(n,t) = liftAndCheck(n, dummy, t)
    fun lift t     = liftAndCheck(!level, dummy, t)

    (*DEBUG*)
    val liftAndCheck = trace liftAndCheck "liftAndCheck"
    val lift'        = trace lift' "lift'"
    val lift         = trace lift "lift"


  (* Unification *)

    (* Unification has to be thread-safe, at least in the absence of holes.
     * However, we want to maximise sharing and thus merge any types that have
     * been discovered to be equal. We use the following algorithm:
     *
     * We maintain a map m that maps any bound variable or MU we encountered on
     * the current path from t1's root, to its counterpart in t2. When we see it
     * again we simply lookup the counterpart and see if it is the same as the
     * other type (modulo links that may have been introduced by concurrent
     * threads in the meantime).
     *
     * Moreover, every step returns the list of types in the domain of m
     * it encountered during traversal. If this list is empty we can safely
     * merge the types because it does not contain free variables.
     *
     * Note that it would be simpler if we used de Bruijn notation and syntactic
     * mu - we would not need the map.
     *)

    fun merge(t1,t2,ts) =
	(if List.null ts
	 then replace(t1, LINK(canonical t2))
	 else ();
	 ts)

    fun bind(mayBind,n1,t1,t2,k1) =
	if mayBind andalso matchesKind(kind t2, k1) andalso not(isLambda t2)
	then (liftAndCheck(n1,t1,t2) ; replace(t1, LINK(canonical t2)) ; [])
	else raise Unify(t1,t2)

    fun unify'(mayBind,m,t1,t2) =
	if Cell.equals(t1,t2) then [] else
	case Map.lookup(m,t1)
	  of SOME t3 => (unifyBound(t3,t2) ; [t1])
	   | NONE =>
	case (content t1, content t2)
	  of (LINK t11, _) => unify'(mayBind,m,t11,t2)
	   | (_, LINK t21) => unify'(mayBind,m,t1,t21)

	   | (HOLE(k1,n1), HOLE(k2,n2)) =>
		(bind(mayBind,n1,t1,t2,k1)
		 handle Unify _ => bind(mayBind,n2,t2,t1,k2)
		)
	   | (HOLE(k1,n1), _) =>
		bind(mayBind,n1,t1,t2,k1)
	   | (_, HOLE(k2,n2)) =>
		bind(mayBind,n2,t2,t1,k2)

	   | (ABBREV(t11,t12), _) => unify'(mayBind,m,t12,t2)
	   | (_, ABBREV(t21,t22)) => unify'(mayBind,m,t1,t22)

	   | (ABS(k1,p1), ABS(k2,p2)) =>
		if Path.equals(p1,p2) andalso equalsKind(k1,k2)
		then merge(t1,t2,[])
		else raise Unify(t1,t2)

	   | ( (FUN(t11,t12), FUN(t21,t22))
	     | (APPLY(t11,t12), APPLY(t21,t22)) )=>
		merge(t1,t2, unify'(mayBind,m,t11,t21) @
			     unify'(mayBind,m,t12,t22))

	   | ( (t1' as PROD(r1), PROD(r2))
	     | (t1' as SUM(r1), SUM(r2)) ) =>
		(* Mh, row variables cannot be treated correctly under binders.
		 * If they occur, we immediately link the types, no matter
		 * what binders are in scope. This means that row variables
		 * should not appear under binders.
		 * TODO: Fix this by having proper row variables, i.e. holes
		 * of row kind. *)
		(case (r1, r2)
		   of (INDEXED ts1, INDEXED ts2) =>
			merge(t1,t2, unifyIndexed(mayBind,m, t1,t2, ts1,ts2))
		    | (NAMED(lts1,d1), INDEXED ts2) =>
			merge(t1,t2,
			      unifyIndexedRow'(mayBind,m, t1,t2, ts2, lts1,d1))
			(* d1 will be deleted by merge (assuming there is no
			 * binder delaying the merge). *)
		    | (INDEXED ts1, NAMED(lts2,d2)) =>
			merge(t2,t1,
			      unifyIndexedRow'(mayBind,m, t2,t1, ts1, lts2,d2))
			(* d2 will be deleted by merge (assuming there is no
			 * binder delaying the merge). *)
		    | (NAMED(lts1,d1), NAMED(lts2,d2)) =>
			let
			    val (lts,d,ts) =
				unifyRow'(mayBind,m, t1,t2, lts1,d1,lts2,d2)
			    val CONS = case t1' of PROD _ => PROD | _ => SUM
			in
			    if mayBind andalso
			       (Option.isSome d1 orelse Option.isSome d2)
			    then let val r' = CONS(NAMED(lts,d))
				 in replace(t1,r'); replace(t2,r') end
			    else ();
			    merge(t1,t2,ts)
			end
		)
	   | (MU(t11), MU(t21)) =>
		(Map.insert(m,t1,t2);
		 merge(t1,t2, List.filter (fn t => not(Cell.equals(t,t1)))
					  (unify'(mayBind,m,t11,t21)))
		 before Map.delete(m,t1)
		)
	   | ( (LAMBDA(a1,t11), LAMBDA(a2,t21))
	     | (ALL(a1,t11), ALL(a2,t21))
	     | (EXIST(a1,t11), EXIST(a2,t21)) ) =>
		let
		    val ao = Map.lookup(m,a1)
		in
		    Map.insert(m,a1,a2);
		    merge(t1,t2, List.filter (fn t => not(Cell.equals(t,a1)))
					     (unify'(mayBind,m,t11,t21)))
		    before (case ao of NONE    => Map.delete(m,a1)
				     | SOME a' => Map.insert(m,a1,a'))
		end
	   | _ => raise Unify(t1,t2)

    and unifyBound(t3,t2) =
	Cell.equals(t3,t2) orelse
	case (content t3, content t2)
	  of ((LINK t3 | ABBREV(_,t3)), _) => unifyBound(t3,t2)
	   | (_, (LINK t2 | ABBREV(_,t2))) => unifyBound(t3,t2)
	   | _ => raise Unify(t3,t2)

    and unifyIndexed(mayBind,m, t1,t2, ts1,ts2) =
	if Vector.length ts1 = Vector.length ts2
	then VectorPair.foldl (fn(t1,t2,ts) => unify'(mayBind,m,t1,t2) @ ts) []
			      (ts1,ts2)
	else raise Unify(t1,t2)

    and unifyIndexedRow'(mayBind,m, t1,t2, ts1, lts2,d2) =
	let
	    fun nth i  = Vector.sub(ts1, i)
	    fun fail _ = raise Unify(t1,t2)
	    val lift   = if not mayBind then fail else
			 case d2 of NONE   => fail
				  | SOME n => fn t => lift'(n,t)

	    fun unifyFields(i, [], ts) =
		    (Vector.appi (lift o #2) (ts1,i,NONE) ; ts)
	      | unifyFields(i, lts2 as (l,t2)::lts2', ts) =
		    if i = Vector.length ts1 then fail() else
		    case Label.toInt l
		      of NONE    => fail()
		       | SOME i' =>
		    case Int.compare(i,i'-1)
		      of LESS    => (lift(nth i) ; unifyFields(i+1, lts2, ts))
		       | GREATER => fail()	(* l might have been 0 *)
		       | EQUAL   => let val ts' = unify'(mayBind, m, nth i, t2)
				    in unifyFields(i+1, lts2', ts'@ts) end
	in
	    unifyFields(0, lts2, [])
	end

    and unifyRow'(mayBind,m, t1,t2, lts1,d1, lts2,d2) =
	let
	    fun fail t = raise Unify(t1,t2)
	    fun lift d = if not mayBind then fail else
			 case d of NONE   => fail
				 | SOME n => fn t => lift'(n,t)
	    val lift1 = lift d1
	    val lift2 = lift d2

	    fun unifyFields([], [], lts, ts) = (List.rev lts, ts)
	      | unifyFields([], (l,t)::lts2', lts, ts) =
		    (lift1 t; unifyFields([], lts2', (l,t)::lts, ts))
	      | unifyFields((l,t)::lts1', [], lts, ts) =
		    (lift2 t; unifyFields(lts1', [], (l,t)::lts, ts))
	      | unifyFields(lts1 as (l1,t1')::lts1',
			    lts2 as (l2,t2')::lts2', lts, ts) =
		case Label.compare(l1,l2)
		  of LESS =>
			(lift2 t1'; unifyFields(lts1', lts2, (l1,t1')::lts, ts))
		   | GREATER =>
			(lift1 t2'; unifyFields(lts1, lts2', (l2,t2')::lts, ts))
		   | EQUAL =>
			let val ts' = unify'(mayBind,m,t1',t2')
			in unifyFields(lts1', lts2', (l1,t1')::lts, ts'@ts) end

	    val (lts,ts) = unifyFields(lts1,lts2,[],[])
	    val  d       = if Option.isSome d1 andalso Option.isSome d2
			   then SOME(Int.min(Option.valOf d1, Option.valOf d2))
			   else NONE
	in
	    (lts,d,ts)
	end

    val unify' = fn(mayBind,m,t1,t2) =>
(*ASSERT assert List.null(unify'(mayBind,m,t1,t2)) => ()*)
	if List.null(unify'(mayBind,m,t1,t2))
	then ()
	else raise Assert.failure
	  

  (* Equality, matching, and public interface to unification *)

    fun unify(t1,t2) = unify'(true, Map.new(), t1, t2)

    fun equals(t1,t2) =
	(unify'(false, Map.new(), t1, t2) ; true) handle Unify _ => false

    fun matches(t1,t2) =
	let
	    val t1' = instance t1
	    val t2' = skolem t2
	in
	    (unify(t1',t2') ; true) handle Unify _ => false
	end

    (*DEBUG*)
    val unify   = trace unify "unify"
    val equals  = trace equals "equals"
    val matches = trace matches "matches"


  (* Free paths *)

    fun paths t =
    	let
	    val s = PathMap.new()

	    fun path t = case content t of ABS(k,p) => PathMap.insert(s,p,k)
					 | _        => ()
	in
	    appNoAbbrevs path t;
	    s
	end


  (* Tie forwarding knots *)

    val _ = appFwd    := SOME app
    val _ = equalsFwd := SOME equals
    val _ = substFwd  := SOME subst
end
