(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Assert   from "../utility/Assert"
import functor   MkStamp  from "../utility/MkStamp"
import functor   MkRefMap from "../utility/MkRefMap"
import structure Name     from "Name"
import structure Label    from "Label"
import structure Path     from "Path"
import structure PathMap  from "PathMap"
import signature TYPE     from "TYPE-sig"


(*******************************************************************************
On Tuples and Records:

As in SML, tuples are just a special case of records. We treat them specially
however for reasons of efficiency. Tuple and record types can be freely
interconverted.

On Type Functions:

We evaluate type application lazily. Reduction is triggered on demand, i.e. by
unification or by inspection. Not all applications can be reduced (in
particular applications to abstract type constructors) so we deal with some
sort of head normal form.

We don't normally do eta-reduction, since it is expensive. During unification
eta reduction is not needed since lambdas may only show up there under very
restrictive circumstances anyway (see below). Eta-reduction is still needed
however for equals, to equate eta-convertible type functions. It's done on
demand.

On Sharing:

For efficiency reasons, we try to maximise sharing of type structures. This
reduces space cost and speeds up comparison and unification, as a simple
reference comparison often suffices. Not only unification but even the equality
test (used by module type checking) merges types silently whenever possible.

There are several cases where we have to clone a type:

* Type functions before reduction of type application.
* Type schemes (types with toplevel quantifiers) on instantiation.
* All sorts of types on signature instantiation.

For the first two it would be sufficient to only clone subgraphs containing the
variables bound by the lambdas/quantifiers; for the third we only would need to
clone subgraphs containing signature-local constructors. But since minimizing
cloning is difficult in the presence of cycles (we have recursive types) and
the pay-off is unclear, we currently don't do it.

It is very important to maintain sharing between subgraphs of different type
terms on signature instantiation. Not doing this can lead to a quadratic blowup
of type terms during module type checking, particularly desastrous in the
presence of structural datatypes. Therefor we need a special-and-ugly interface
for cloning a sequence of related types.

On Recursive Types:

Stockhausen makes datatypes structural sum types. This is a problem since
SML has non-uniform recursive datatypes. So in fact we not only get recursive
types but recursive type functions. It is not obvious whether type checking
remains decidable in the general case (in our current scheme with lazy
application unification might fail to terminate).

To stay on the safe side we use an iso-recursive interpretation of types:
applications to such functions are never reduced. That is, there is no implicit
unrolling of recursive types, mu is completely structural. For two recursive
types to be compatible they must therefor be constructed from equal type
functions. As a consequence, List(Int) and IntList will not be compatible in
the following example:

	List a  = Nil | Cons(a, List a)
	IntList = Nil | Cons(Int, IntList)

Maybe this can be made a bit more permissive, but in general it seems
impossible to have non-uniform datatypes as well as arbitrary (equi) recursive
types - type checking would become undecidable.

It is also unclear to me whether some sort of hash-consing can be applied to
recursive types or even recursive type functions.

On Type Abbreviations:

We try to maintain type abbreviations to generate more user friendly output.
This is managed through a special node ABBREV, which refers to the original
type term as well as to the reduced/substituted one.

*******************************************************************************)

structure Type :> TYPE =
struct

  (* Types *)

    structure Stamp = MkStamp()

    datatype sort = OPEN | CLOSED
    datatype kind = STAR | ARROW of kind * kind		(* [kappa,k] *)

    type lab  = Label.t					(* [lab,l] *)
    type path = Path.t					(* [pi,p] *)
    type con  = kind * sort * path			(* [chi,c] *)

    datatype typ' =					(* [tau',t'] *)
	  HOLE   of kind * int	(* variable for inference *)
	| LINK   of typ		(* forward (needed for unification) *)
	| FUN    of typ * typ	(* arrow type *)
	| TUPLE  of typ vector	(* tuple *)
	| PROD   of row		(* record *)
	| SUM    of row		(* sum type (datatype) *)
	| VAR    of kind * int	(* bound variable or skolem types *)
	| CON    of con		(* constructor (of arbitrary kind) *)
	| ALL    of var * typ	(* universal quantification *)
	| EXIST  of var * typ	(* existential quantification *)
	| LAMBDA of var * typ	(* abstraction (type function) *)
	| APPLY  of typ * typ	(* application *)
	| MU     of typ		(* recursive type barrier *)
	| ABBREV of typ * typ	(* abbreviations (#2 is unabbreviated type) *)

    and row =						(* [rho,r] *)
	  NIL
	| RHO   of int ref * row
	| FIELD of lab * typ * row

    (*TODO: I would rather delete TUPLE types and change row to
     *   TUPLE  of typ vector
     * | RECORD of (lab * typ) list * int option ref
     * On the other hand, this is probably less compatible with poly records...
     *)

    withtype typ = (typ' * Stamp.t) ref			(* [tau,t] *)
    and      var = (typ' * Stamp.t) ref			(* [alpha,a] *)

    type t = typ
    type canonical_typ = typ

    type path_rea = path PathMap.t
    type typ_rea  = typ PathMap.t


    (*
     * We establish the following invariants:
     * - rows are sorted by label, rho variables appear as head only
     * - types are always in head normal form
     * - sequential quantifiers are ordered such that the bound variables
     *   appear in depth-first leftmost traversal order inside the body
     *)


  (* Very basic helpers *)

    fun typ'(ref(t',_))			= t'
    fun new t'				= ref(t', Stamp.new())
    fun replace(t as ref(_,z), t')	= t := (t',z)
    val same				= op=
    fun hash(ref(_,z))			= Stamp.hash z

    fun canonical(ref(LINK t,_))	= canonical t
      | canonical t			= t

    fun fromCanonical t			= t


    fun trace f s = f

    (*DEBUG: The following allows tracing of all type nodes.

    val currentFn = ref "external"

    fun trace f s x =
	let
	    val s' = !currentFn
	in
	    currentFn := s;
	    f x before currentFn := s'
	    handle e => (currentFn := s' ; raise e)
	end

    fun id(ref(_,z)) = Stamp.toString z

    val printTyp' =
	fn HOLE _	=> "HOLE"
	 | LINK t	=> "LINK(" ^ id t ^ ")"
	 | FUN(t1,t2)	=> "FUN(" ^ id t1 ^ "," ^ id t2 ^ ")"
	 | TUPLE ts	=> "TUPLE(" ^ String.separate ","
					(Vector.toList(Vector.map id ts)) ^ ")"
	 | PROD _	=> "PROD(...)"
	 | SUM _	=> "SUM(...)"
	 | VAR _	=> "VAR"
	 | CON _	=> "CON"
	 | ALL(a,t)	=> "ALL(" ^ id a ^ "," ^ id t ^ ")"
	 | EXIST(a,t)	=> "EXIST(" ^ id a ^ "," ^ id t ^ ")"
	 | LAMBDA(a,t)	=> "LAMBDA(" ^ id a ^ "," ^ id t ^ ")"
	 | APPLY(t1,t2)	=> "APPLY(" ^ id t1 ^ "," ^ id t2 ^ ")"
	 | MU t		=> "MU(" ^ id t ^ ")"
	 | ABBREV(t1,t2) => "ABBREV(" ^ id t1 ^ "," ^ id t2 ^ ")"

    fun new t' =
	let
	    val z = Stamp.new()
	in
	    print("new " ^ Stamp.toString z ^ " = " ^ printTyp' t' ^
		  " by " ^ !currentFn ^ "\n");
	    ref(t',z)
	end

    fun replace(t as ref(t'',z), t') =
	( print("replace " ^ Stamp.toString z ^ " = " ^ printTyp' t'' ^
		" with " ^ printTyp' t' ^ " by " ^ !currentFn ^ "\n");
	  t := (t',z)
	)
    *)


  (* Level management *)

    val globalLevel	= 0
    val level		= ref(globalLevel+1)

    fun enterLevel()	= level := !level+1
    fun exitLevel()	= level := !level-1
    fun resetLevel()	= level := 1


  (* Kinds *)

    exception Kind

    fun isStar STAR		= true
      | isStar _		= false

    fun domKind(ARROW(k1,k2))	= k1
      | domKind STAR		= raise Kind

    fun ranKind(ARROW(k1,k2))	= k2
      | ranKind STAR		= raise Kind


    fun kind t			= kind'(typ' t)
    and kind'(LINK t | MU t)	= kind t
      | kind'(ABBREV(_,t))	= kind t
      | kind'(HOLE(k,_))	= k
      | kind'(VAR(k,_))		= k
      | kind'(CON(k,_,_))	= k
      | kind'(LAMBDA(a,t))	= ARROW(kind a, kind t)
      | kind'(APPLY(t1,t2))	= ranKind(kind t1)
      | kind' _			= STAR

    val kindVar			= kind


  (* Type graph traversal *)

    structure Map = MkRefMap(structure Stamp = Stamp
			     type t          = typ' * Stamp.t
			     val stamp       = #2 : 'a * 'b -> 'b)

    (* We have two ways to traverse types:
     * - ignoring abbreviations (eg. for closure check)
     * - not ignoring abbreviations (eg. realisations, lifting)
     *)

    fun app1'(( HOLE _
	      | VAR _
	      | CON _ ), f, b)		= ()
      | app1'(( LINK t
	      | MU t ), f, b)		= f t
      | app1'(( ALL(a,t)
	      | EXIST(a,t)
	      | LAMBDA(a,t) ), f, b)	= (f a ; f t)
      | app1'(( FUN(t1,t2)
	      | APPLY(t1,t2) ), f, b)	= (f t1 ; f t2)
      | app1'(( ABBREV(t1,t2) ), f, b)	= if b then (f t1 ; f t2) else f t2
      | app1'(( TUPLE ts ), f, b)	= Vector.app f ts
      | app1'(( PROD r
	      | SUM r ), f, b)		= appRow(r,f)

    and appRow(FIELD(_,t,r), f)		= (f t ; appRow(r,f))
      | appRow(RHO(_,r), f)		= appRow(r,f)
      | appRow(NIL, f)			= ()


    fun foldl1'(( HOLE _
		| VAR _
		| CON _ ), f,c,b)	= c
      | foldl1'(( LINK t
		| MU t ), f,c,b)	= f(t,c)
      | foldl1'(( ALL(a,t)
		| EXIST(a,t)
		| LAMBDA(a,t) ), f,c,b)	= f(t, f(a,c))
      | foldl1'(( FUN(t1,t2)
		| APPLY(t1,t2)), f,c,b)	= f(t2, f(t1,c))
      | foldl1'(( ABBREV(t1,t2)),f,c,b)	= if b then f(t2, f(t1,c)) else f(t2,c)
      | foldl1'(( TUPLE ts ), f,c,b)	= Vector.foldl f c ts
      | foldl1'(( PROD r
		| SUM r ), f,c,b)	= foldlRow(r,f,c)

    and foldlRow(FIELD(_,t,r), f,c)	= foldlRow(r, f, f(t,c))
      | foldlRow(RHO(_,r), f,c)		= foldlRow(r, f, c)
      | foldlRow(NIL, f,c)		= c

    fun appHow(b,f,t) =
	let
	    val m = Map.new()

	    fun app t = if Map.member(m,t) then () else
			( f t;
			  Map.insert(m,t,());
			  app1'(typ' t, app, b)
			)
	in
	    app t
	end

    fun app f t          = appHow(true, f, t)
    fun appNoAbbrevs f t = appHow(false, f, t)

    fun foldlHow(b,f,c,t) =
	let
	    val m = Map.new()

	    fun fold(t,c) = if Map.member(m,t) then c else
			    let
				val c' = f(t,c)
			    in
				Map.insert(m,t,());
				foldl1'(typ' t, fold, c', b)
			    end
	in
	    fold(t,c)
	end

    fun foldl f b t          = foldlHow(true, f, b, t)
    fun foldlNoAbbrevs f b t = foldlHow(false, f, b, t)


  (* Cloning *)

    type clone_state   = typ Map.t

    fun cloneStart()   = Map.new()
    fun cloneCont(m,t) =
	let
	    (* We want to be able to handle recursive types, so we have to
	     * implement graph copying here.
	     *)

	    fun dup t1 =
(*ASSERT	assert not(Map.member(m,t1)) *)
		if Map.member(m,t1) then raise Assert.failure else
		(* Without cycles, this could be
		let
		    val t2 = new(clone'(typ' t1'))
		in
		    Map.insert(m,t1,t2);
		    t2
		end
		*)
		let
		    val t1' = typ' t1
		    val t2  = new t1'
		in
		    Map.insert(m,t1,t2);
		    replace(t2, clone' t1');
		    t2
		end

	    and clone t1 =
		case typ' t1
		  of LINK t  => clone t
		   | HOLE _  => t1
		   | VAR _   => Option.getOpt(Map.lookup(m,t1), t1)
		   | _       =>
		case Map.lookup(m,t1)
		  of SOME t2 => t2
		   | NONE    => dup t1

	    and clone'(FUN(t1,t2))	= FUN(clone t1, clone t2)
	      | clone'(TUPLE ts)	= TUPLE(Vector.map clone ts)
	      | clone'(PROD r)		= PROD(cloneRow r)
	      | clone'(SUM r)		= SUM(cloneRow r)
	      | clone'(t' as ( CON _
	      		     | VAR _ ))	= t'
	      | clone'(ALL(a,t))	= ALL(dup(canonical a), clone t)
	      | clone'(EXIST(a,t))	= EXIST(dup(canonical a), clone t)
	      | clone'(LAMBDA(a,t))	= LAMBDA(dup(canonical a), clone t)
	      | clone'(APPLY(t1,t2))	= APPLY(clone t1, clone t2)
	      | clone'(MU t)		= MU(clone t)
	      | clone'(ABBREV(t1,t2))	= ABBREV(clone t1, clone t2)
	      | clone' _		= raise Assert.failure

	    and cloneRow(FIELD(a,t,r))	= FIELD(a, clone t, cloneRow r)
	      | cloneRow(RHO(n,r))	= RHO(ref(!n), cloneRow r)
	      | cloneRow(NIL)		= NIL
	in
	    clone t
	end

    (*DEBUG*)
    val cloneCont = trace cloneCont "clone"

    fun clone t = cloneCont(cloneStart(), t)


  (* Occur check (not used by unification) *)

    exception Occurs

    fun occurs(t1,t2) =
	let
	    fun occurs t = if t1 = t then raise Occurs else ()
	in
	    ( app occurs t2 ; false ) handle Occurs => true
	end


  (* Reduction to head normal form *)

    (*UNFINISHED: avoid multiple cloning of curried lambdas somehow *)

    fun reduce t =
	case typ' t
	  of APPLY(t1,t2)		=> reduceApply(t, t1, t2, NONE)
	   | (LINK t1 | ABBREV(_,t1))	=> reduce t1
	   | _				=> ()

    and reduceApply(t, t1, t2, to) =
	case typ' t1
	  of LAMBDA(a,_) =>
	     ( replace(t, HOLE(kind a, !level))
	     ; case typ'(clone t1)
		 of LAMBDA(a,t11) =>
		     ( replace(a, LINK t2)
		     ; replace(t, case to
				    of NONE   => LINK t11
				     | SOME t => ABBREV(new(APPLY(t,t2)), t11))
		     ; reduce t
		     )
		  | _ => raise Assert.failure
	     )
	   | LINK t1		=> reduceApply(t, t1, t2, to)
	   | ABBREV(t11,t12)	=> reduceApply(t, t12, t2,
					       SOME(Option.getOpt(to,t11)))
	   | _			=> ()

    (*DEBUG*)
    val reduce = trace reduce "reduce"

    (*
     * We don't normally do eta-reduction, since it is expensive.
     * During unification we curently allow no lambdas anyway.
     * Eta-reduction is still needed however for equals, to equate
     * eta-convertible type functions. It's done on demand.
     *)

    fun reduceEta t = reduceEta'(t, false)

    and reduceEta'(t, modified) =
	case typ' t
	  of (LINK t1 | ABBREV(_,t1))	=> reduceEta'(t1, modified)
	   | LAMBDA _			=> reduceLambda(t, t, [], modified)
	   | _				=> modified

    and reduceLambda(t, t0, vs, modified) =
	case (typ' t0, vs)
	  of ((LINK t1 | ABBREV(_,t1)), vs)
	   				=> reduceLambda(t, t1, vs, modified)
	   | (LAMBDA(a,t1), vs)		=> reduceLambda(t, t1, a::vs, modified)
	   | (APPLY(t1,t2), a::vs)	=> reduceLambda'(t,t1,t2,a,vs,modified)
	   | (_, [])			=> ( replace(t, LINK t0);
					     reduceEta'(t, true) )
	   | _				=> modified

    and reduceLambda'(t, t1, t2, a, vs, modified) =
	case typ' t2
	  of (LINK t21 | ABBREV(_,t21))	=> reduceLambda'(t,t1,t21,a,vs,modified)
	   | _				=> reduceLambda''(t,t1,t2,a,vs,modified)

    and reduceLambda''(t, t1, t2, a, vs, modified) =
	case typ' a
	  of LINK b 			=> reduceLambda''(t,t1,t2,b,vs,modified)
	   | _       			=> if t2 = a andalso not(occurs(a,t1))
					   then reduceLambda(t,t1, vs, modified)
					   else modified

    (*DEBUG*)
    val reduceEta = trace reduceEta "reduceEta"


  (* Creation and injections *)

    fun unknown' k	= HOLE(k, !level)
    fun unknown k	= new(unknown' k)

    fun inArrow tt	= new(FUN tt)
    fun inTuple ts	= new(TUPLE ts)
    fun inProd r	= new(PROD r)
    fun inSum r		= new(SUM r)
    fun inVar a		= a
    fun inCon c		= new(CON c)
    fun inAll at	= new(ALL at)
    fun inExist at	= new(EXIST at)
    fun inLambda at	= let val t = new(LAMBDA at) in reduceEta t ; t end
    fun inApply(t1,t2)	= let val t = new(APPLY(t1,t2)) in reduce t ; t end
    fun inMu t		= new(MU t)	(* t must be lambdas of sum/prod/tuple*)
    fun inAbbrev(t1,t2)	= new(ABBREV(t1,t2))

    fun var k		= new(VAR(k, !level))


  (* Operations on rows *)

    exception Row

    fun unknownRow()		= RHO(ref(!level), NIL)
    fun emptyRow()		= NIL

    fun openRow(r as RHO _)	= r
      | openRow r		= RHO(ref(!level), r)

    fun extendRow(l,t,NIL)	= FIELD(l,t,NIL)
      | extendRow(l,t,RHO(n,r))	= RHO(n, extendRow(l,t,r))
      | extendRow(l1,t1, r1 as FIELD(l2,t2,r2)) =
	case Label.compare(l1,l2)
	  of EQUAL   => raise Row
	   | LESS    => FIELD(l1, t1, r1)
	   | GREATER => FIELD(l2, t2, extendRow(l1,t1,r2))

    fun tupToRow  ts			= tupToRow'(ts,0)
    and tupToRow'(ts,i)			= if i = Vector.length ts then
					      NIL
					  else
					      FIELD(Label.fromInt(i+1),
						    Vector.sub(ts,i),
						    tupToRow'(ts,i+1))

    fun rowToTup r			= rowToTup'(r,1,[])
    and rowToTup'(RHO _,i,ts)		= raise Row
      | rowToTup'(NIL,i,ts)		= Vector.rev(Vector.fromList ts)
      | rowToTup'(FIELD(a,t,r),i,ts)	= case Label.toLargeInt a
					    of NONE     => raise Row
					     | SOME i'  =>
					  (if Int.fromLarge i' <> i then
					      raise Row
					   else
					      rowToTup'(r,i+1,t::ts)
					  ) handle Overflow => raise Row

    fun isTupRow r			= (rowToTup r; true) handle Row => false

    fun isEmptyRow(NIL | RHO(_,NIL))	= true
      | isEmptyRow _			= false

    fun isUnknownRow(RHO _)		= true
      | isUnknownRow _			= false

    fun headRow(FIELD(a,t,r))		= (a,t)
      | headRow(RHO(_,r))		= headRow r
      | headRow(NIL)			= raise Row

    fun tailRow(FIELD(a,t,r))		= r
      | tailRow(RHO(n,r))		= RHO(n, tailRow r)
      | tailRow(NIL)			= raise Row

    fun lookupRow(NIL, a)		= raise Row
      | lookupRow(RHO(_,r), a)		= lookupRow(r,a)
      | lookupRow(FIELD(a',t,r), a)	= case Label.compare(a',a)
					    of EQUAL   => t
					     | LESS    => lookupRow(r,a)
					     | GREATER => raise Row


  (* Projections and extractions *)

    exception Type

    fun isAbbrev t			= isAbbrev'(typ' t)
    and isAbbrev'(LINK t)		= isAbbrev t
      | isAbbrev'(ABBREV _)		= true
      | isAbbrev' _			= false

    fun asAbbrev t			= asAbbrev'(typ' t)
    and asAbbrev'(LINK t)		= asAbbrev t
      | asAbbrev'(ABBREV tt)		= tt
      | asAbbrev' _			= raise Type

    fun asType t =
	case typ' t
	  of (LINK t | ABBREV(_,t))	=> asType t
(*NEW	   | t' as LAMBDA _		=> if reduceEta t then asType t else t' *)
	   | t'				=> t'

    fun isUnknown t	= case asType t of HOLE _   => true | _ => false
    fun isArrow t	= case asType t of FUN _    => true | _ => false
    fun isTuple t	= case asType t of PROD r   => isTupRow r
					 | TUPLE _  => true | _ => false
    fun isProd t	= case asType t of PROD _   => true
					 | TUPLE _  => true | _ => false
    fun isSum t		= case asType t of SUM _    => true | _ => false
    fun isVar t		= case asType t of VAR _    => true | _ => false
    fun isCon t		= case asType t of CON _    => true | _ => false
    fun isAll t		= case asType t of ALL _    => true | _ => false
    fun isExist t	= case asType t of EXIST _  => true | _ => false
    fun isLambda t	= case asType t of LAMBDA _ => true | _ => false
    fun isApply t	= case asType t of APPLY _  => true | _ => false
    fun isMu t		= case asType t of MU _     => true | _ => false

    fun asArrow t	= case asType t of FUN tt    => tt | _ => raise Type
    fun asTuple t	= case asType t of PROD r    => (rowToTup r handle Row
							       => raise Type)
					 | TUPLE ts  => ts | _ => raise Type
    fun asProd t	= case asType t of TUPLE ts  => tupToRow ts
					 | PROD r    => r  | _ => raise Type
    fun asSum t		= case asType t of SUM r     => r  | _ => raise Type
    fun asVar t		= case asType t of VAR _     => t  | _ => raise Type
    fun asCon t		= case asType t of CON c     => c  | _ => raise Type
    fun asAll t		= case asType t of ALL at    => at | _ => raise Type
    fun asExist t	= case asType t of EXIST at  => at | _ => raise Type
    fun asLambda t	= case asType t of LAMBDA at => at | _ => raise Type
    fun asApply t	= case asType t of APPLY tt  => tt | _ => raise Type
    fun asMu t		= case asType t of MU t      => t  | _ => raise Type

    fun isType t =
	case typ' t
	  of (LINK t1 | MU t1 | ABBREV(_,t1))
				=> isType t1
	   | APPLY _		=> isTypeApply(t,0)
(*NEW	   | t' as LAMBDA _	=> if reduceEta t then isType t else t'*)
	   | t'			=> t'
    and isTypeApply(t, n) =
	case typ' t
	  of (LINK t1 | MU t1)	=> isTypeFunc(t1,n)
	   | APPLY(t1,t2)	=> isTypeApply(t1,n+1)
	   | ABBREV(t1,t2)	=> isTypeApply(t2,n)
	   | _			=> APPLY(t,t)	(*dummy*)
    and isTypeFunc(t, 0) = typ' t
      | isTypeFunc(t, n) =
	case typ' t
	  of (LINK t1 | MU t1)	=> isTypeFunc(t1,n)
	   | ABBREV(t1,t2)	=> isTypeFunc(t2,n)
	   | LAMBDA(a,t1)	=> isTypeFunc(t1,n-1)
	   | _			=> APPLY(t,t)	(*dummy*)

    fun isUnknown' t	= case isType t of HOLE _   => true | _ => false
    fun isArrow' t	= case isType t of FUN _    => true | _ => false
    fun isTuple' t	= case isType t of PROD r   => isTupRow r
					 | TUPLE _  => true | _ => false
    fun isProd' t	= case isType t of PROD _   => true
					 | TUPLE _  => true | _ => false
    fun isSum' t	= case isType t of SUM _    => true | _ => false
    fun isVar' t	= case isType t of VAR _    => true | _ => false
    fun isCon' t	= case isType t of CON _    => true | _ => false
    fun isAll' t	= case isType t of ALL _    => true | _ => false
    fun isExist' t	= case isType t of EXIST _  => true | _ => false
    fun isLambda' t	= case isType t of LAMBDA _ => true | _ => false
    fun isApply' t	= case isType t of APPLY _  => true | _ => false

    fun asType t =
	case typ' t
	  of (LINK t1 | MU t1 | ABBREV(_,t1))
					=> asType t1
	   | t' as APPLY _		=> asTypeApply(t',t,[])
(*NEW	   | t' as LAMBDA _		=> if reduceEta t then asType t else t'*)
	   | t'				=> t'
    (* Note that we can only legally have a LAMBDA node following an APPLY
       node if there is a MU node inbetween. *)
    and asTypeApply(t', t, ts) =
	case typ' t
	  of (LINK t1 | ABBREV(_,t1))	=> asTypeApply(t', t1, ts)
	   | APPLY(t1,t2)		=> asTypeApply(t', t1, t2::ts)
	   | MU _			=> let (* unroll *)
					       val tt = clone t
					       val t1 = asMu tt
					   in
					       replace(tt, LINK t);
					       asTypeFunc(t1, ts)
					   end
	   | _				=> t'
    and asTypeFunc(t, []) = typ' t
      | asTypeFunc(t, t2::ts) =
	case typ' t
	  of (LINK t1 | MU t1 | ABBREV(_,t1))
					=> asTypeFunc(t1,ts)
	   | LAMBDA(a,t1)		=> ( replace(a, LINK t2);
					     asTypeFunc(t1, ts)
					   )
	   | _				=> asTypeFunc(new(APPLY(t,t2)), ts)

    (*DEBUG*)
    val asType = trace asType "asType"

    fun asArrow' t	= case asType t of FUN tt    => tt | _ => raise Type
    fun asTuple' t	= case asType t of PROD r    => (rowToTup r handle Row
							       => raise Type)
					 | TUPLE ts  => ts | _ => raise Type
    fun asProd' t	= case asType t of TUPLE ts  => tupToRow ts
					 | PROD r    => r  | _ => raise Type
    fun asSum' t	= case asType t of SUM r     => r  | _ => raise Type
    fun asVar' t	= case asType t of VAR _     => t  | _ => raise Type
    fun asCon' t	= case asType t of CON c     => c  | _ => raise Type
    fun asAll' t	= case asType t of ALL at    => at | _ => raise Type
    fun asExist' t	= case asType t of EXIST at  => at | _ => raise Type
    fun asLambda' t	= case asType t of LAMBDA at => at | _ => raise Type
    fun asApply' t	= case asType t of APPLY tt  => tt | _ => raise Type


    fun pathCon(_,_,p)	= p
    fun path t		= pathCon(asCon t)

    fun paths t =
    	let
	    val s = PathMap.new()

	    fun path t = case typ' t of CON(k,_,p) => PathMap.insert(s,p,k)
				      | _          => ()
	in
	    appNoAbbrevs path t;
	    s
	end


  (* Check for holes *)

    exception Unclosed

    fun checkClosedRow(RHO _)		= raise Unclosed
      | checkClosedRow _		= ()

    fun checkClosed'(HOLE _)		= raise Unclosed
      | checkClosed'(PROD r | SUM r)	= checkClosedRow r
      | checkClosed' _			= ()

    fun isClosed t =
	( appNoAbbrevs (fn t => checkClosed'(typ' t)) t ; true )
	handle Unclosed => false


  (* Instantiation *)

    (* Instantiate universally quantified types, skolemise
     * existentially qualified types. If there is any quantification,
     * then we have to copy the type.
     * Skolemisation does it the other way round (needed for checking rank 2
     * signature applications and existential types).
     *)

    (*ASSUME that no quantifiers appear under abbreviations or links
   	(this might break with higher-order polymorphism!) *)

    fun instance' t =
	case typ' t
	  of ALL(a,t)		=> (replace(a, unknown'(kind a)) ; instance' t)
	   | EXIST(a,t)		=> instance' t
	   | _			=> t

    (*DEBUG*)
    val instance' = trace instance' "instance'"

    fun instance t =
	case typ' t
	  of LINK t		=> instance t
	   | (ALL _| EXIST _)	=> instance'(clone t)
	   | _			=> t

    fun skolem' t =
	case typ' t
	  of ALL(a,t)		=> skolem' t
	   | EXIST(a,t)		=> (replace(a, unknown'(kind a)) ; skolem' t)
	   | _			=> t

    (*DEBUG*)
    val skolem' = trace skolem' "skolem'"

    fun skolem t =
	case typ' t
	  of LINK t		=> skolem t
	   | (ALL _| EXIST _)	=> skolem'(clone t)
	   | _			=> t


  (* Closure *)

    fun close ts =
	let
	    val generalise =
		foldl close1 (fn t => t) (inTuple(Vector.fromList ts))
		(* UNFINISHED: This should better use foldlNoAbbrev, but then
		 * we had to lift free vars in abbreviations somehow. *)
	in
	    List.map generalise ts
	end

    and close1(t, f) =
	case typ' t
	  of HOLE(k,n)	=> if n <= !level then f else
			   (replace(t, VAR(k,globalLevel)) ;
			    fn t2 => f(inAll(t,t2)))
	   | PROD r	=> (replace(t, PROD(closeRow r)) ; f)
	   | SUM r	=> (replace(t, SUM(closeRow r)) ; f)
	   | _		=> f

    and closeRow(r as RHO(n,r')) = if !n <= !level then r else r'
      | closeRow r               = r

    (*DEBUG*)
    val close = trace close "close"


  (* Lifting a type to the current level *)

    exception Lift of var

    fun lift t = app lift1 t
    and lift1 t =
	case typ' t
	  of t' as HOLE(k,n)	=> if n <= !level then () else
				   replace(t, HOLE(k,!level))
	  | VAR(k,n)		=> if n <= !level then () else raise Lift t
	  | (PROD r | SUM r)	=> liftRow r
	  | (LAMBDA(a,_) | ALL(a,_) | EXIST(a,_)) =>
				   replace(a, VAR(kindVar a, globalLevel))
	  | _			=> ()

    and liftRow(RHO(n,r))	= if !n > !level then n := !level else ()
      | liftRow _		= ()

    (*DEBUG*)
    val lift = trace lift "lift"


  (* Filling *)

    exception Fill

    fun fill(t1, t2) =
	case typ' t1
	  of HOLE(k,n)	=>
(*Assertions trigger lazy types...
(*ASSERT		   assert k1 = kind t2 =>*)
			   if k <> kind t2 then raise Assert.failure else
(*ASSERT		   assert not(isLambda t2) =>*) (* should be MU! *)
			   if isLambda t2 then raise Assert.failure else
*)
			   replace(t1, LINK t2)
	   | _		=> raise Fill

    (*DEBUG*)
    val fill = trace fill "fill" : typ * typ -> unit



  (* Unification *)

    exception Unify of typ * typ


    fun liftAndCheck(n,t1,t2) =
	let
	    val m = Map.new()

	    fun lift t =
		if Map.member(m,t) then () else
		( Map.insert(m,t,());
		  case typ' t
		    of HOLE(k,n') => if n'<=n then () else replace(t, HOLE(k,n))
		     | t' as (PROD r | SUM r)
				  => (liftRow r; app1'(t', lift, true))
		     | t'         => app1'(t', lift, true)
		)

	    and liftRow(RHO(n',r)) = if !n' <= n then () else n' := n
	      | liftRow _          = ()

	    fun check t =
		if t1 = t then raise Unify(t1,t2) else
		if Map.member(m,t) then () else
		( Map.insert(m,t,());
		  case typ' t
		    of HOLE(k,n') => if n'<=n then () else replace(t, HOLE(k,n))
		     | t' as MU _ => app1'(t', lift, true)
		     | t'         => app1'(t', check, true)
		)
	in
	    check t2
	end


    fun unify(t1,t2) =
	let
	    val trail = ref []

	    fun unify(t1,t2) =
		let
		    val t1' = typ' t1
		    val t2' = typ' t2

		    fun recur f x =
			( replace(t1, LINK t2)
			; trail := (t1,t1') :: !trail
			; f x
			)

		    fun recurBinder(a1, a2, t1, t2) =
			let
			    val a1' = typ' a1
			in
			    ( replace(a1, LINK a2)
			    ; trail := (a1,a1') :: !trail
			    ; recur unify (t1,t2)
			    )
			end
		in
		    if t1 = t2 then () else
		    case (t1',t2')
		      of (LINK t11, _) => unify(t11,t2)
		       | (_, LINK t21) => unify(t1,t21)

		       | (HOLE(k1,n1), HOLE(k2,n2)) =>
(*ASSERT		 assert k1 = k2 =>*)
			 if k1 <> k2 then raise Assert.failure else
			 if n1 < n2 then replace(t2, LINK t1)
				    else replace(t1, LINK t2)

		       | (HOLE(k1,n), _) =>
(*ASSERT		 assert k1 = kind' t2' =>*)
			 if k1 <> kind' t2' then raise Assert.failure else
(*ASSERT		 assert not(isLambda t2) =>*)
			 if isLambda t2 then raise Assert.failure else
			 ( liftAndCheck(n,t1,t2) ; replace(t1, LINK t2) )

		       | (_, HOLE(k2,n)) =>
(*ASSERT		 assert kind' t1' = k2 =>*)
			 if kind' t1' <> k2 then raise Assert.failure else
(*ASSERT		 assert not(isLambda t1) =>*)
			 if isLambda t1 then raise Assert.failure else
			 ( liftAndCheck(n,t2,t1) ; replace(t2, LINK t1) )

		       | (ABBREV(t11,t12), _) => unify (t12,t2)
		       | (_, ABBREV(t21,t22)) => unify (t1,t22)
		       | (MU(t11), MU(t21))   => recur unify (t11,t21)
		       | (FUN(tt1), FUN(tt2)) => recur unifyPair (tt1,tt2)

		       | (TUPLE(ts1), TUPLE(ts2)) =>
			 (recur unifyVector (ts1,ts2)
			  handle Domain => raise Unify(t1,t2))

		       | (TUPLE(ts), PROD(r)) =>
			 (recur unifyTupleProd (ts,r,t2)
			  handle Domain => raise Unify(t1,t2))

		       | (PROD(r), TUPLE(ts)) =>
			 (recur unifyTupleProd (ts,r,t1)
			  handle Domain => raise Unify(t1,t2))

		       | (PROD(r1), PROD(r2)) =>
			 recur unifyRow (t1, t2, r1, r2, PROD)

		       | (SUM(r1), SUM(r2)) =>
			 recur unifyRow (t1, t2, r1, r2, SUM)

		       | (CON(_,_,p1), CON(_,_,p2)) =>
			 if Path.equals(p1,p2) then replace(t1, LINK t2)
					       else raise Unify(t1,t2)

		       | (APPLY(tt1), APPLY(tt2)) =>
(*NEW			 (* Note that we do not allow general lambdas during
			  * unification, so application is considered to be
			  * in normal form. *)
*)			 recur unifyPair (tt1,tt2)

		       | (LAMBDA(a1,t11), LAMBDA(a2,t21)) =>
(*NEW			 (* The only place lambdas might occur during
			  * unification is below mu and as arguments to
			  * abstract type constructors. The type functions
			  * must be equal in both cases. *)
			 (*UNFINISHED: do we need eta reduction?*)
*)			 recurBinder(a1, a2, t11, t21)

		       | ( (ALL(a1,t11), ALL(a2,t21))
			 | (EXIST(a1,t11), EXIST(a2,t21)) ) =>
			 recurBinder(a1, a2, t11, t21)

		       | _ => raise Unify(t1,t2)
		end

	    and unifyPair((t11,t12), (t21,t22)) =
		( unify(t11,t21) ; unify(t12,t22) )

	    and unifyVector(ts1,ts2) =
		if Vector.length ts1 <> Vector.length ts2 then
		    raise Domain
		else
		    VectorPair.app unify (ts1,ts2)

	    and unifyTupleProd(ts,r,t) = unifyTupleProd'(ts,r,t,0,false)
	    and unifyTupleProd'(ts, RHO(_,r), t, i, b) =
		unifyTupleProd'(ts, r, t, i, true)
	      | unifyTupleProd'(ts, NIL, t, i, b) =
		if b orelse i = Vector.length ts then
		    replace(t, TUPLE ts)
		else
		    raise Domain
	      | unifyTupleProd'(ts, r as FIELD(a,t',r'), t, i, b) =
		case Label.toLargeInt a
		  of NONE     => raise Domain
		   | SOME i'  =>
		case Int.compare(Int.fromLarge i', i+1)
		     handle Overflow => raise Domain
		  of EQUAL   => ( unify(t', Vector.sub(ts,i))
				  handle Subscript => raise Domain
				; unifyTupleProd'(ts, r', t, i+1, b) )
		   | GREATER => if not b then raise Domain else
				  unifyTupleProd'(ts, r, t, i+1, b)
		   | LESS    => raise Domain (* cannot happen *)

	    and unifyRow(t1, t2, r1, r2, PRODorSUM) =
		let
		    fun loop(RHO(n1,r1), _,  RHO(n2,r2), _ ) =
			    RHO(ref(Int.min(!n1, !n2)), loop(r1,true, r2,true))
		      | loop(RHO(_,r1), _, r2, _) =
			    loop(r1, true, r2, false)
		      | loop(r1, _, RHO(_,r2), _) =
			    loop(r1, false, r2, true)
		      | loop(NIL, _, NIL, _) =
			    NIL
		      | loop(NIL, true, FIELD(l,t,r2'), b2) =
			    FIELD(l,t, loop(NIL, true, r2', b2))
		      | loop(FIELD(l,t,r1'), b1, NIL, true) =
			    FIELD(l,t, loop(r1', b1, NIL, true))
		      | loop(r1 as FIELD(l1,t11,r1'), b1,
			     r2 as FIELD(l2,t21,r2'), b2) =
			(case Label.compare(l1,l2)
			   of EQUAL   => ( unify(t11,t21)
					 ; FIELD(l1,t11, loop(r1',b1, r2',b2)) )
			    | LESS    => if not b2 then raise Unify(t1,t2) else
					 FIELD(l1,t11, loop(r1',b1, r2,b2))
			    | GREATER => if not b1 then raise Unify(t1,t2) else
					 FIELD(l2,t21, loop(r1,b1, r2',b2))
			)
		      | loop _ = raise Unify(t1,t2)
		in
		    replace(t2, PRODorSUM(loop(r1, false, r2, false)))
		end
	in
	    unify(t1,t2)
	    handle Unify tt => ( List.app replace (!trail) ; raise Unify tt )
	end

    (*DEBUG*)
    val unify = trace unify "unify"



  (* Matching *)

    fun matches(t1,t2) =
	let
	    val t1' = instance t1
	    val t2' = skolem t2
	in
	    ( unify(t1',t2') ; true ) handle Unify _ => false
	end


  (* Comparison *)

    (* To maximise sharing, links are kept after comparison iff the
     * types are equal. If the types are not equal, all updates are
     * undone. This could be optimized by keeping equal subtrees, but what for?
     *)

    fun equals(t1,t2) =
	let
	    val trail = ref []

	    fun equals(t1,t2) =
		let
		    val t1' = typ' t1
		    val t2' = typ' t2

		    fun recur p x =
			( replace(t1, LINK t2)
			; trail := (t1,t1') :: !trail
			; p x
			)

		    fun recurBinder(a1, a2, t1, t2) =
			let
			    val a1' = typ' a1
			in
			    replace(a1, LINK a2);
			    trail := (a1,a1') :: !trail;
			    recur equals (t1,t2)
			end

		    fun equalsTupProd(ts, r, t) =
			let
			    val ts' = rowToTup r
			    val t'  = typ' t
			in
			    replace(t, TUPLE ts');
			    trail := (t,t') :: !trail;
			    recur equalsVector (ts,ts')
			end
			handle Row => false
		in
		    t1 = t2 orelse
		    case (t1',t2')
		      of (LINK t11, _) => equals(t11,t2)
		       | (_, LINK t21) => equals(t1,t21)
		       | (ABBREV(t11,t12), _) =>
			 equals(t12,t2)

		       | (_, ABBREV(t21,t22)) =>
			 equals(t1,t22)

		       | (MU(t11), MU(t21)) =>
			 recur equals (t11,t21)

		       | (FUN(tt1), FUN(tt2)) =>
			 recur equalsPair (tt1,tt2)

		       | (TUPLE(ts1), TUPLE(ts2)) =>
			 recur equalsVector (ts1,ts2)

		       | (TUPLE(ts), PROD(r)) =>
			 equalsTupProd(ts,r,t2)

		       | (PROD(r), TUPLE(ts)) =>
			 equalsTupProd(ts,r,t1)

		       | ( (PROD(r1), PROD(r2))
			 | (SUM(r1),  SUM(r2)) ) =>
			 recur equalsRow (r1,r2)

		       | (CON(_,_,p1), CON(_,_,p2)) =>
			 Path.equals(p1,p2)

		       | (APPLY(tt1), APPLY(tt2)) =>
			 recur equalsPair (tt1,tt2)

		       | (LAMBDA(a1,t11), LAMBDA(a2,t21)) =>
(*NEW			 if reduceEta t1 orelse reduceEta t2 then
			     equals(t1,t2)
			 else
*)
			 recurBinder(a1, a2, t11, t21)

(*		       | (LAMBDA _, _) =>
			 reduceEta t1 andalso equals(t1,t2)

		       | (_, LAMBDA _) =>
			 reduceEta t2 andalso equals(t1,t2)
*)
		       | ( (ALL(a1,t11),   ALL(a2,t21))
			 | (EXIST(a1,t11), EXIST(a2,t21)) ) =>
			 recurBinder(a1, a2, t11, t21)

		       | _ => false
		end

	    and equalsPair((t11,t12), (t21,t22)) =
		equals(t11,t21) andalso equals (t12,t22)

	    and equalsVector(ts1,ts2) =
		Vector.length ts1 = Vector.length ts2 andalso
		VectorPair.all equals (ts1,ts2)

	    and equalsRow(NIL,             NIL)             = true
	      | equalsRow(RHO(_,r1),       RHO(_,r2))       = equalsRow(r1,r2)
	      | equalsRow(FIELD(l1,t1,r1), FIELD(l2,t2,r2)) =
		l1 = l2 andalso equals(t1,t2) andalso equalsRow(r1,r2)
	      | equalsRow _ = false
	in
	    equals(t1,t2) orelse ( List.app replace (!trail) ; false )
	end

    (*DEBUG*)
    val equals = trace equals "equals"



  (* Realisation *)

    fun realisePath(rea, t) = app (realisePath1 rea) t
    and realisePath1 rea t =
	case typ' t
	  of CON(k,s,p)	=> (case PathMap.lookup(rea, p)
			      of SOME p' => replace(t, CON(k,s,p'))
			       | NONE    => ()
			   )
	   | _		=> ()

    (*DEBUG*)
    val realisePath = trace realisePath "realisePath"


    (*
     * Realisations need not be idempotent (fully expanded). Would be nice
     * to have this property because it would make substitution more efficient,
     * but full expansion is difficult to achieve for the intersect function).
     *)

    fun realise(rea, t) =
	let
	    val apps = ref[]
	    val lams = ref[]

	    fun realise1 t1 =
		case typ' t1
		  of CON(k,s,p) => (case PathMap.lookup(rea, p)
				      of SOME t2 => replace(t1, LINK t2)
					(*UNFINISHED: do we have to clone t2? *)
				       | NONE    => ()
				   )
	      | APPLY _		=> apps := t1::(!apps)
	      | LAMBDA _	=> lams := t1::(!lams)
	      | _		=> ()
	in
	    app realise1 t;
	    List.app reduce (!apps);
	    List.app (ignore o reduceEta) (!lams)
	end

    (*DEBUG*)
    val realise = trace realise "realise"


  (* Intersection *)

    exception Intersect

    fun intersect(t1:typ, t2:typ) = ()
    (* UNFINISHED *)

end
