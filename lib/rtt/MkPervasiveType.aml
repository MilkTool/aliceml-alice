(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Name           from "Name"
import structure Label          from "Label"
import structure Path           from "Path"
import structure Type           from "Type"
import structure PathSet        from "PathSet"
import signature PERVASIVE_TYPE from "PERVASIVE_TYPE-sig"


functor MkPervasiveType(val labid_false :	string
			val labid_true :	string
			val typid_bool :	string
			val typid_int :		string
			val typid_word :	string
			val typid_real :	string
			val typid_char :	string
			val typid_string :	string
			val typid_exn :		string
			val typid_ref :		string
			val typid_vec :		string
			val typid_array :	string
			val typid_strict :	string
			val typid_conarrow :	string
			val valid_match :	string
			val valid_bind :	string
			val modid_pervasive :	string
			) :> PERVASIVE_TYPE =
struct
    type lab		= Label.t
    type name		= Name.t
    type path		= Path.t
    type typ		= Type.typ

    val lab_false	= Label.fromString labid_false
    val lab_true	= Label.fromString labid_true

    val name_pervasive	= Name.ExId modid_pervasive
    val name_bool	= Name.ExId typid_bool
    val name_int	= Name.ExId typid_int
    val name_word	= Name.ExId typid_word
    val name_real	= Name.ExId typid_real
    val name_char	= Name.ExId typid_char
    val name_string	= Name.ExId typid_string
    val name_exn	= Name.ExId typid_exn
    val name_ref	= Name.ExId typid_ref
    val name_vec	= Name.ExId typid_vec
    val name_array	= Name.ExId typid_array
    val name_strict	= Name.ExId typid_strict
    val name_conarrow	= Name.ExId typid_conarrow

    val name_match	= Name.ExId valid_match
    val name_bind	= Name.ExId valid_bind

    val paths		= PathSet.new()
    val path_bool	= Path.pervasive typid_bool
			  (* non-generative *)
    val path_int	= Path.pervasive typid_int
    val _		= PathSet.insert(paths, path_int)
    val path_word	= Path.pervasive typid_word
    val _		= PathSet.insert(paths, path_word)
    val path_real	= Path.pervasive typid_real
    val _		= PathSet.insert(paths, path_real)
    val path_char	= Path.pervasive typid_char
    val _		= PathSet.insert(paths, path_char)
    val path_string	= Path.pervasive typid_string
    val _		= PathSet.insert(paths, path_string)
    val path_exn	= Path.pervasive typid_exn
    val _		= PathSet.insert(paths, path_exn)
    val path_ref	= Path.pervasive typid_ref
    val _		= PathSet.insert(paths, path_ref)
    val path_vec	= Path.pervasive typid_vec
    val _		= PathSet.insert(paths, path_vec)
    val path_array	= Path.pervasive typid_array
    val _		= PathSet.insert(paths, path_array)
    val path_strict	= Path.pervasive typid_strict
    val _		= PathSet.insert(paths, path_strict)
    val path_conarrow	= Path.pervasive typid_conarrow
    val _		= PathSet.insert(paths, path_conarrow)

    val kind_star	= Type.starKind()
    val kind_ext	= Type.extKind()
    val kind_arrow	= Type.arrowKind(kind_star, kind_star)

    val typ_int		= Type.abs(kind_star,  path_int)
    val typ_word	= Type.abs(kind_star,  path_word)
    val typ_real	= Type.abs(kind_star,  path_real)
    val typ_char	= Type.abs(kind_star,  path_char)
    val typ_string	= Type.abs(kind_star,  path_string)
    val typ_exn		= Type.abs(kind_ext,   path_exn)
    val typ_ref		= Type.abs(kind_arrow, path_ref)
    val typ_vec		= Type.abs(kind_arrow, path_vec)
    val typ_array	= Type.abs(kind_arrow, path_array)
    val typ_strict	= Type.abs(kind_arrow, path_strict)
    val typ_conarrow	= Type.abs(kind_arrow, path_conarrow)

    val typ_zero	= Type.apply(typ_strict, Type.tuple #[])
    val row_bool	= Type.extendRow(lab_false, typ_zero,
			  Type.extendRow(lab_true, typ_zero, Type.emptyRow()))
    val typ_bool	= Type.abbrev(Type.abs(kind_star, path_bool),
				      Type.unknown kind_star)
    val _               = Type.fix #[(typ_bool, Type.sum row_bool)]


    exception Lookup

    fun lookup s =
	if      s = typid_int    then typ_int
	else if s = typid_word   then typ_word
	else if s = typid_real   then typ_real
	else if s = typid_char   then typ_char
	else if s = typid_string then typ_string
	else if s = typid_exn    then typ_exn
	else if s = typid_ref    then typ_ref
	else if s = typid_vec	 then typ_vec
	else if s = typid_array  then typ_array
	else if s = typid_strict then typ_strict
	else if s = typid_conarrow then typ_conarrow
	else raise Lookup
end
