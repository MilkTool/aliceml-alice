(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(*******************************************************************************

On Paths:

We use `paths' to name types, modules, and interfaces. A path is a unique name
with additional location information. Location information is not required for
type checking but is maintained solely for the pretty printing purposes and to
simplify external binding analysis on interfaces (like performed by
BindEnvFromSig, for example).

There are three binders for module paths: signature items, functors, and
dependent interfaces. Type and interface paths are only bound by interface
items. The location information of a path p is as follows:

- For the parameter x in a functor or interface function, p = x
- For an item x in a _free_ signature, p = x
- For an item x in a singleton signature, i.e. a signature that is the interface
  of a functor or interface parameter or an enclosing signature's module item,
  p = p'.x, where p' is the path of the corresponding binder.

As an example, consider the following interface with annotated path locations:

	sig{
	    type t[t]
	    module a[a] : sig{
		type u[a.u]
		module b[a.b] : sig{type v[a.b.v]}
		module c[a.c] : fun(d[d] : sig{type v[d.v]}) -> sig{type w[w]}
		interface j[a.j]
	    }
	    interface k[k] = sig{type t[t]}
	}

A pretty printer should suppress any path component that is the path of an
enclosing entity (e.g. the a. prefix inside the signature of a).

Instantiation does prefix all nested paths of a signature with the given path p.

On Abbreviations:

As for types, we try to maintain abbreviations to generate more user friendly
output. This is managed through a special node ABBREV, which refers to the
original type term as well as to the reduced/substituted one.

On Lookup:

To make lookups more efficient, signatures cache a lookup hash table. To reduce
size of signature representation among pickling, this can explicitly be flushed
using the compress function.

On Singletons:

Since we have no functor paths, we only have few axioms for canonicalising
singleton interfaces. But we have similar axioms for singleton kinds:

	SING_{SING_k j}(j')  = SING_k j
	SING_{DEP x:j.k}(j') = DEP x:j.SING_k(j' x)

TODO:

- Make signature extension functional (requires functional lookup table).

*******************************************************************************)

import structure Assert       from "../utility/Assert"
import structure Cell         from "../utility/Cell"
import functor   MkHashImpMap from "../utility/MkHashImpMap"
import structure GlobalStamp  from "../utility/GlobalStamp"
import structure Name         from "Name"
import structure Label        from "Label"
import structure Path         from "Path"
import structure PathSet      from "PathSet"
import structure PathMap      from "PathMap"
import structure Type         from "Type"
import structure Fixity       from "Fixity"
import signature INF          from "INF-sig"

(*DEBUG
import structure Addr         from "../utility/Addr"
import structure TextIO       from "../system/TextIO"
import structure PrettyPrint  from "../utility/PrettyPrint"
import structure PPPath       from "PPPath"
import structure PPType       from "PPType"
*)

structure Inf :> INF =
struct
  (* Types *)

    open Cell

    type lab	= Label.t
    type path	= Path.t
    type typ	= Type.t
    type tkind	= Type.kind
    type fix    = Fixity.t


    (* A map for signatures *)

    datatype space = FIX' | VAL' | TYP' | MOD' | INF'

    structure Tab = MkHashImpMap(type t = space * lab
				 val equals = op=
				 fun hash(_,l) = Label.hash l)

    datatype inf' =
	  TOP					(* top *)
	| ABS    of kind * path			(* interface constructor *)
	| SIG    of sign			(* signature *)
	| THAT   of mod				(* singleton *)
	| FUN    of path * inf * inf		(* arrow (functor) *)
	| LAMBDA of path * inf * inf		(* abstraction (dep. function)*)
	| APPLY  of inf * mod			(* application *)
	| ABBREV of inf * inf			(* abbreviations *)

    and item =
	  FIX    of lab  * fix			(* fixity *)
	| VAL    of lab  * typ			(* value *)
	| TYP    of path * tkind		(* type *)
	| MOD    of path * inf			(* module *)
	| INF    of path * kind			(* interface *)

    and kind' =
	  GROUND				(* ordinary interface *)
	| SING   of inf				(* singleton *)
	| DEP    of path * inf * kind		(* dependent *)

    withtype mod  = path * inf' cell		(* [m] *)
    and      inf  = inf' cell			(* [jota,j] *)
    and      kind = kind' cell			(* [kappa,k] *)
    and      sign = item list ref *		(* [sigma,s] *)
		    item Tab.t option ref *
		    GlobalStamp.t
			(* The list of items in a sig is in reverse order! *)

    type t = inf

    structure Map     = Cell.MkMap(type t = inf')
    structure KindMap = Cell.MkMap(type t = kind')


  (* Realisations *)

    type typ_rea = typ PathMap.t
    type mod_rea = mod PathMap.t
    type inf_rea = inf PathMap.t

    type rea	 = { typ_rea : typ_rea
		   , mod_rea : mod_rea
		   , inf_rea : inf_rea
		   }

    fun newRea() = { typ_rea = PathMap.new()
		   , mod_rea = PathMap.new()
		   , inf_rea = PathMap.new()
		   } : rea

    fun isEmptyRea {typ_rea, mod_rea, inf_rea} =
	PathMap.isEmpty typ_rea andalso
	PathMap.isEmpty mod_rea andalso
	PathMap.isEmpty inf_rea

    val dummyRea = newRea()

    fun cloneRea {typ_rea, mod_rea, inf_rea} : rea =
	{ typ_rea = PathMap.clone typ_rea
	, mod_rea = PathMap.clone mod_rea
	, inf_rea = PathMap.clone inf_rea
	}

    fun unionRea({typ_rea, mod_rea, inf_rea}, rea : rea) =
	(PathMap.unionDisjoint(typ_rea, #typ_rea rea);
	 PathMap.unionDisjoint(mod_rea, #mod_rea rea);
	 PathMap.unionDisjoint(inf_rea, #inf_rea rea))


  (* Mismatch information *)

    datatype mismatch =
	  MissingFix       of lab
	| MissingVal       of lab
	| MissingTyp       of lab
	| MissingMod       of lab
	| MissingInf       of lab
	| MismatchFix      of lab * fix * fix
	| MismatchVal      of lab * typ * typ
	| MismatchTyp      of lab * tkind * tkind
	| MismatchMod      of lab * mismatch
	| MismatchInf      of lab * mismatch
	| MismatchDom      of mismatch
	| MismatchRan      of mismatch
	| MismatchArg      of mismatch
	| Incompatible     of inf * inf
	| IncompatibleMod  of path * path
	| IncompatibleKind of kind * kind

    exception Mismatch of mismatch


  (* Very basic helpers *)

    (* Almost everything in this module is mutually recursive. To avoid
     * confusing reordering and allow for easy tracing (see below) we use
     * the old forward reference trick.
     *)

    fun dummy _		= raise Assert.failure
    val apply'Fwd 	= ref dummy : (inf * mod -> inf) ref
    val matchFwd 	= ref dummy : (inf * inf -> inf * rea) ref
    val matchKindFwd 	= ref dummy : (kind * kind -> unit) ref
    val realiseFwd	= ref dummy : (rea * inf -> inf) ref
    val realiseKindFwd	= ref dummy : (rea * kind -> kind) ref

    fun apply'(j,m)	   = !apply'Fwd(j,m)
    fun match(j1,j2)	   = !matchFwd(j1,j2)
    fun matchKind(k1,k2)   = !matchKindFwd(k1,k2)
    fun realise(rea,j)	   = !realiseFwd(rea,j)
    fun realiseKind(rea,k) = !realiseKindFwd(rea,k)


  (* Debugging aids *)

    val newKind = new

    (*DEBUG: The following allows tracing of all interface nodes.

    fun pth p = (Label.toString(Path.toLab p) handle Domain => "_") ^
		"$" ^ Int.toString(Path.hash p)

    fun id j = Int.toString(hash (*DEBUG Addr.addr*) j)

    val rec inf'ToString =
	fn TOP		=> "TOP"
	 | ABS(_,p)	=> "ABS(" ^ pth p ^ ")"
	 | SIG s	=> "SIG(" ^ sigToString s ^ ")"
	 | THAT(p,j)	=> "THAT(" ^ pth p ^ "," ^ inf j ^ ")"
	 | FUN(p,j1,j2)	=> "FUN(" ^ pth p ^ "," ^ inf j1 ^ "," ^ inf j2 ^ ")"
	 | LAMBDA(p,j1,j2)
			=> "LAMBDA(" ^ pth p ^ "," ^ inf j1 ^ "," ^ inf j2 ^ ")"
	 | APPLY(j1,(p,j2))
			=> "APPLY(" ^ inf j1 ^ "," ^ pth p ^ "," ^ inf j2 ^ ")"
	 | ABBREV(j1,j2) => "ABBREV(" ^ inf j1 ^ "," ^ inf j2 ^ ")"

    and inf = fn j => id j (*DEBUG ^ "=" ^ inf'ToString(content j)*)

    and sigToString = fn(ref itemsr,_,_) =>
	String.separate ";" (List.rev (List.map itemToString itemsr))

    and itemToString =
	fn FIX(l,f) => "" (*DEBUG "fix " ^ Label.toString l*)
	 | VAL(l,t) => "" (*DEBUG "val " ^ Label.toString l*)
	 | TYP(p,k) => "typ " ^ pth p ^ ":" ^ PrettyPrint.toString(PPType.ppKind k, 1000000)
	 | MOD(p,j) => "mod " ^ pth p ^ ":" ^ inf j
	 | INF(p,k) => "inf " ^ pth p ^ ":" ^ kind k

    and kind'ToString =
	fn GROUND	=> "GROUND"
	 | SING j	=> "SING(" ^ inf j ^ ")"
	 | DEP(p,j,k)	=> "DEP(" ^ pth p ^ "," ^ inf j ^ "," ^ kind k ^ ")"

    and kind = fn k => id k (*DEBUG ^ "=" ^ kind'ToString (content k)*)

    fun infToString j  = id j ^ "=" ^ inf'ToString (content j)
    fun kindToString k = id k ^ "=" ^ kind'ToString (content k)

    val new = fn j' =>
	let
	    val j = new j'
	in
	    TextIO.print("new " ^ id j ^ " = " ^ inf'ToString j' ^ "\n");
	    j
	end

    val replace = fn(j,j') =>
	( TextIO.print("replace " ^ id j ^ " = " ^ inf'ToString (content j) ^
		       " with " ^ inf'ToString j' ^ "\n");
	  replace(j,j')
	)

    val newKind = fn k' =>
	let
	    val k = newKind k'
	in
	    TextIO.print("new " ^ id k ^ " = " ^ kind'ToString k' ^ "\n");
	    k
	end

    *)


  (* Kinds *)

    exception Kind

    val kGround			= newKind GROUND
    fun groundKind()		= kGround
    fun depKind(p,j,k)		= newKind(DEP(p,j,k))
    fun singKind j		= let val k = kind j in
				      case content k
					of GROUND => newKind(SING j)
					 | SING _ => k
					 | DEP(p,j1,k1) =>
					    let val j' = apply'(j,(p,j1)) in
					     newKind(DEP(p,j1,newKind(SING j')))
					    end
				  end

    and kind j =
	case content j
	  of ( TOP
	     | SIG _
	     | THAT _
	     | FUN _ )		=> groundKind()
	   | ABS(k,p)		=> k
	   | LAMBDA(p,j1,j2)	=> depKind(p, j1, kind j2)
	   | ABBREV(j1,j2)	=> kind j2
	   | APPLY(j1,(p2,j2))	=> let val (p',j3,j4) = asDepKind(kind j1)
				       val (j3',rea)  = match(j2,j3)
				   in
				       PathMap.insert(#mod_rea rea,p',(p2,j3'));
				       realiseKind(rea,j4)
				   end

    and asDepKind k =
	case content k
	  of DEP pjk		=> pjk
	   | SING j		=> asDepKind(kind j)
	   | _			=> raise Kind
    and asSingKind k =
	case content k
	  of SING j		=> j
	   | _			=> raise Kind

    fun isGroundKind k =
    	case content k
	  of GROUND		=> true
	   | SING j		=> isGroundKind(kind j)
	   | _			=> false
    fun isDepKind k =
	case content k
	  of DEP _		=> true
	   | SING j		=> isDepKind(kind j)
	   | _			=> false
    fun isSingKind k =
	case content k
	  of SING j		=> true
	   | _			=> false



  (* Projections and extractions *)

    exception Interface

    fun isAbbrev j	= case content j of ABBREV _ => true | _ => false
    fun asAbbrev j	= case content j of ABBREV z => z | _ => raise Interface

    fun asInf j		= case content j
			    of ABBREV(_,j2) => asInf j2
			     | j'           => j'

    fun isTop j		= case asInf j of TOP      => true | _ => false
    fun isAbs j		= case asInf j of ABS _    => true | _ => false
    fun isSig j		= case asInf j of SIG _    => true | _ => false
    fun isSing j	= case asInf j of THAT _   => true | _ => false
    fun isArrow j	= case asInf j of FUN _    => true | _ => false
    fun isLambda j	= case asInf j of LAMBDA _ => true | _ => false
    fun isApply j	= case asInf j of APPLY _  => true | _ => false

    fun asAbs j		= case asInf j of ABS(k,p) => p | _ => raise Interface
    fun asSig j		= case asInf j of SIG s    => s | _ => raise Interface
    fun asSing j	= case asInf j of THAT m   => m | _ => raise Interface
    fun asArrow j	= case asInf j of FUN x    => x | _ => raise Interface
    fun asLambda j	= case asInf j of LAMBDA x => x | _ => raise Interface
    fun asApply j	= case asInf j of APPLY x  => x | _ => raise Interface

    (* modulo singletons *)

    fun asInf' j	= case content j
			    of (ABBREV(_,j2) | THAT(_,j2)) => asInf' j2
			     | j'                          => j'

    fun isTop' j	= case asInf' j of TOP      => true | _ => false
    fun isAbs' j	= case asInf' j of ABS _    => true | _ => false
    fun isSig' j	= case asInf' j of SIG _    => true | _ => false
    fun isArrow' j	= case asInf' j of FUN _    => true | _ => false

    fun asAbs' j	= case asInf' j of ABS(k,p) => p | _ => raise Interface
    fun asSig' j	= case asInf' j of SIG s    => s | _ => raise Interface
    fun asArrow' j	= case asInf' j of FUN x    => x | _ => raise Interface


  (* Creation and injection, reduction *)

    val top'		= let val j = new TOP in fn() => j end
    fun abs'(k,p)	= new(ABS(k,p))
    fun sign' s		= new(SIG s)
    fun arrow'(p,j1,j2)	= new(FUN(p,j1,j2))

    fun abbrev'(j1,j2)	= new(ABBREV(reduceAbbrevL j1, reduceAbbrevR j2))
    and reduceAbbrevL j	=
	case content j
	  of ABBREV(j1,_)	=> reduceAbbrevL j1
	   | _			=> j
    and reduceAbbrevR j	=
	case content j
	  of ABBREV(_,j2)	=> reduceAbbrevR j2
	   | _			=> j

    fun sing'(m as (p,j)) = reduceSing(m,j)
    and reduceSing(m,j) =
	case content j
	  of ABBREV(_,j2)	=> reduceSing(m,j2)
	   | THAT _		=> j
	   | _			=> new(THAT m)

    fun lambda'(p,j1,j2) = reduceEta(p,j1,j2)
    and reduceEta(p1,j1,j2) =
	case content j2
	  of APPLY(j3,(p4,j4)) =>
		if Path.equals(p1,p4) andalso not(occurs(p1,j3))
		then j3
		else new(LAMBDA(p1,j1,j2))
	   | ABBREV(_,j3) =>
		reduceEta(p1,j1,j3)
	   (* Not needed, since k is never singleton
	   | ABS(k,_) =>
		if isSingKind k
		then reduceEta(p1, j1, asSingKind k)
		else new(LAMBDA(p1,j1,j2))
	   *)
	   | _ =>
		new(LAMBDA(p1,j1,j2))
    and occurs(p,j) = true (*TODO*)

    fun apply'(j,m) = reduceBeta(j,j,m,NONE)
    and reduceBeta(j,j',m,jo) =
	case content j'
	  of LAMBDA(p,j1,j2) =>
	     let
		val (j1',rea) = match(#2 m,j1)
		val  _        = PathMap.insert(#mod_rea rea, p, (#1 m,j1'))
		val  j2'      = realise(rea,j2)
	     in
		case jo of NONE     => j2'
			 | SOME j'' => abbrev'(apply'(j'',m), j2')
	     end
	   | ABBREV(j1,j2) =>
		reduceBeta(j, j2, m, SOME(Option.getOpt(jo,j1)))
	   (* Not needed, since k is never singleton
	   | ABS(k,_) =>
		if isSingKind k
		then reduceBeta(j, asSingKind k, m, jo)
		else new(APPLY(j,m))
	   *)
	   | _ =>
		new(APPLY(j,m))


    (* kind-safe interface *)

    fun ground t =
	if isGroundKind(kind t)
	then t
	else raise Kind

    val top		= top'
    fun abs(k,p)	= if isSingKind k then asSingKind k else abs'(k,p)
    val sign		= sign'
    fun arrow(p,j1,j2)	= arrow'(p, ground j1, ground j2)
    fun sing(p,j)	= sing'(p, ground j)
    fun abbrev(j1,j2)	= (ignore(matchKind(kind j2, kind j1))
			   handle Mismatch _ => raise Kind;
			   abbrev'(j1,j2))
    fun lambda(p,j1,j2)	= lambda'(p, ground j1, j2)
    fun apply(j,m)	= let val j' = apply'(j,m) in
			      if not(isApply j') then () (* matched already *)
			      else ignore(match(#2 m, #2(asDepKind(kind j))));
			      j'
			  end


  (* Signature helpers *)

    fun itemDom(FIX(l,_))	= (FIX',l)
      | itemDom(VAL(l,_))	= (VAL',l)
      | itemDom(TYP(p,_))	= (TYP',Path.toLab p)
      | itemDom(MOD(p,_))	= (MOD',Path.toLab p)
      | itemDom(INF(p,_))	= (INF',Path.toLab p)

    fun itemPath(TYP(p,_))	= p
      | itemPath(MOD(p,_))	= p
      | itemPath(INF(p,_))	= p
      | itemPath _		= raise Assert.failure

    fun stamp (_,_,z)		= z

    fun tab((itemsr, ref(SOME tab), _) : sign) = tab
      | tab((itemsr, r as ref NONE, _) : sign) =
	let
	    val tab = Tab.new()
	in
	    List.app (fn item => Tab.insertDisjoint(tab, itemDom item, item))
		     (!itemsr);
	    r := SOME tab;
	    tab
	end


  (* Signature construction *)

    fun newSig itemsr	= (ref itemsr, ref NONE, GlobalStamp.new())
    fun emptySig()	= newSig []
    fun emptySig' s	= (ref [], ref NONE, stamp s)	(* TODO: Hack! *)

    fun hide(FIX(l,q))	= ()
      | hide(VAL(l,t))	= ()
      | hide(TYP(p,k))	= Path.hide p
      | hide(MOD(p,j))	= Path.hide p
      | hide(INF(p,k))	= Path.hide p

    fun extend(s as (itemsr,_,_), dom, item) =
	(Tab.insertWithi (extendClash itemsr) (tab s, dom, item);
	 itemsr := item :: !itemsr)
    and extendClash itemsr (dom,item',item) =
	(itemsr := List.filter (fn item => itemDom item <> dom) (!itemsr);
	 hide item';
	 item)

    fun pathToLab p		= Label.fromName(Path.asName p) (* avoid dot *)

    fun extendFix(s,l,q)	= extend(s, (FIX',l), FIX(l,q))
    fun extendVal(s,l,t)	= extend(s, (VAL',l), VAL(l,t))
    fun extendTyp(s,p,k)	= extend(s, (TYP', pathToLab p), TYP(p,k))
    fun extendMod(s,p,j)	= extend(s, (MOD', pathToLab p), MOD(p,j))
    fun extendInf(s,p,k)	= extend(s, (INF', pathToLab p), INF(p,k))


  (* Signature inspection *)

    exception Item

    fun items(ref items, _, _)	= items

    fun isFixItem(FIX _)	= true
      | isFixItem _		= false
    fun isValItem(VAL _)	= true
      | isValItem _		= false
    fun isTypItem(TYP _)	= true
      | isTypItem _		= false
    fun isModItem(MOD _)	= true
      | isModItem _		= false
    fun isInfItem(INF _)	= true
      | isInfItem _		= false

    fun asFixItem(FIX lq)	= lq
      | asFixItem _		= raise Item
    fun asValItem(VAL lt)	= lt
      | asValItem _		= raise Item
    fun asTypItem(TYP pk)	= pk
      | asTypItem _		= raise Item
    fun asModItem(MOD pj)	= pj
      | asModItem _		= raise Item
    fun asInfItem(INF pk)	= pk
      | asInfItem _		= raise Item


  (* Signature lookup *)

    fun strong(item as (FIX _ | VAL _))	= item
      | strong(item as TYP(p,k))	= if Type.isSingKind k then item
					  else TYP(p,
						   Type.singKind(Type.abs(k,p)))
      | strong(item as MOD(p,j))	= if isSing j then item
					  else MOD(p, sing'(p,j))
      | strong(item as INF(p,k))	= if isSingKind k then item
					  else INF(p, singKind(abs'(k,p)))

    fun selectFix(FIX(l,q))		= q
      | selectFix _			= raise Assert.failure
    fun selectVal(VAL(l,t))		= t
      | selectVal _			= raise Assert.failure
    fun selectTyp(TYP(p,k))		= k
      | selectTyp _			= raise Assert.failure
    fun selectMod(MOD(p,j))		= j
      | selectMod _			= raise Assert.failure
    fun selectInf(INF(p,k))		= k
      | selectInf _			= raise Assert.failure

    fun selectTyp'(TYP(p,k))		= Type.asSingKind k
      | selectTyp' _			= raise Assert.failure
    fun selectMod'(MOD(p,j))		= asSing j
      | selectMod' _			= raise Assert.failure
    fun selectInf'(INF(p,k))		= asSingKind k
      | selectInf' _			= raise Assert.failure

    exception Lookup

    fun lookup space (s,l) =
	case Tab.lookup(tab s, (space,l))
	  of SOME item => item
	   | NONE      => raise Lookup

    val pathTyp		= itemPath o lookup TYP'
    val pathMod		= itemPath o lookup MOD'
    val pathInf		= itemPath o lookup INF'

    val lookupFix	= selectFix o lookup FIX'
    val lookupVal	= selectVal o lookup VAL'
    val lookupTyp	= selectTyp o lookup TYP'
    val lookupMod	= selectMod o lookup MOD'
    val lookupInf	= selectInf o lookup INF'

    val lookupTyp'	= selectTyp' o strong o lookup TYP'
    val lookupMod'	= selectMod' o strong o lookup MOD'
    val lookupInf'	= selectInf' o strong o lookup INF'


  (* Strip signature lookup tables *)

    fun compress j =
	case content j
	  of TOP		=> ()
	   | ABS(k,_)		=> compressKind k
	   | SIG s		=> compressSig s
	   | THAT(_,j)		=> compress j
	   | ( FUN(_,j1,j2)
	     | LAMBDA(_,j1,j2)
	     | APPLY(j1,(_,j2))
	     | ABBREV(j1,j2) )	=> (compress j1 ; compress j2)

    and compressKind k =
	case content k
	  of GROUND		=> ()
	   | SING j		=> compress j
	   | DEP(_,j,k)		=> (compress j ; compressKind k)

    and compressSig(isr,tab,_)	= (List.app compressItem (!isr); tab := NONE)

    and compressItem(MOD(_,j))	= compress j
      | compressItem(INF(_,k))	= compressKind k
      | compressItem _		= ()


  (* Closure check *)

    exception Unclosed of lab * typ

    fun close s			= List.app closeItem (items s)
    and closeItem(FIX _)	= ()
      | closeItem(VAL(l,t))	= if Type.isClosed t then ()
				  else raise Unclosed(l,t)
      | closeItem(TYP(_,k))	= ()
      | closeItem(MOD(_,j))	= closeInf j
      | closeItem(INF(_,k))	= ()
	(* ASSUME that types and interfaces are always closed *)

    and closeInf j =
	case content j
	  of (TOP | ABS _)	=> ()
	   | SIG s		=> close s
	   | THAT(_,j1)		=> closeInf j1
	   | ( FUN(_,j1,j2)
	     | LAMBDA(_,j1,j2)
	     | APPLY(j1,(_,j2)))=> (closeInf j1; closeInf j2)
	   | ABBREV(j1,j2)	=> closeInf j2


  (* Cloning for substitution. *)

    fun build(mj,mk,mt, rea : rea, j) =
	case Map.lookup(mj,j)
	  of SOME j'		=> j'
	   | NONE		=>
	case content j
	  of TOP		=> buildOld(mj,j)
	   | ABS(k,p) 		=> (case PathMap.lookup(#inf_rea rea, p)
				      of SOME j' =>
					    (matchKind(kind j',k)
					     handle Mismatch _ => raise Kind;
					     buildNew(mj,j,j'))
				       | NONE =>
					 let val k'=buildKind(mj,mk,mt,rea,k) in
					     if Cell.equals(k,k')
					     then buildOld(mj,j)
					     else buildNew(mj,j,abs'(k',p))
					 end
				   )
	   | SIG s		=> buildSig(mj,mk,mt, rea, j, sign',s)
	   | THAT m		=> buildSing(mj,mk,mt, rea, j, sing',m)
	   | FUN(p,j1,j2)	=> buildBind(mj,mk,mt, rea, j, arrow',p,j1,j2)
	   | LAMBDA(p,j1,j2)	=> buildBind(mj,mk,mt, rea, j, lambda',p,j1,j2)
	   | APPLY(j1,m)	=> buildApply(mj,mk,mt, rea, j, apply',j1,m)
	   | ABBREV(j1,j2)	=> buildPair(mj,mk,mt, rea, j, abbrev',j1,j2)

    and buildOld(mj,j)    = (Map.insert(mj,j,j); j)
    and buildNew(mj,j,j') = (Map.insert(mj,j,j'); j')

    and buildBind(mj,mk,mt, rea, j, toInf, p,j1,j2) =
	let
	    val j1' = build(mj,mk,mt, rea, j1)
	    val j2' = case PathMap.lookup(#mod_rea rea, p)
			of NONE   => build(mj,mk,mt, rea, j2)
			 | SOME m => (PathMap.insert(#mod_rea rea,p,(p,j1'));
				      build(mj,mk,mt, rea, j2)
				      before PathMap.insert(#mod_rea rea,p,m))
	in
	    if Cell.equals(j1,j1') andalso Cell.equals(j2,j2')
	    then buildOld(mj, j)
	    else buildNew(mj, j, toInf(p,j1',j2'))
	end

    and buildPair(mj,mk,mt, rea, j, toInf, j1,j2) =
	let
	    val j1' = build(mj,mk,mt, rea, j1)
	    val j2' = build(mj,mk,mt, rea, j2)
	in
	    if Cell.equals(j1,j1') andalso Cell.equals(j2,j2')
	    then buildOld(mj, j)
	    else buildNew(mj, j, toInf(j1',j2'))
	end

    and buildApply(mj,mk,mt, rea, j, toInf, j1, m as (p,j2)) =
	let
	    val j1'            = build(mj,mk,mt, rea,j1)
	    val j2'            = build(mj,mk,mt, rea,j2)
	    val m' as (p',j2') = case PathMap.lookup(#mod_rea rea, p)
				   of NONE        => (p,j2')
				    | SOME(p',j3) =>
				      let  val (j2'',_) = match(j3,j2')
				      in (p',j2'') end
				      handle Mismatch _ => raise Interface
	in
	    if Path.equals(p,p') andalso Cell.equals(j1,j1')
				 andalso Cell.equals(j2,j2')
	    then buildOld(mj, j)
	    else buildNew(mj, j, toInf(j1',m'))
	end

    and buildSing(mj,mk,mt, rea, j, toInf, m as (p,j1)) =
	let
	    val j1'            = build(mj,mk,mt, rea, j1)
	    val m' as (p',j1') = case PathMap.lookup(#mod_rea rea, p)
				   of NONE        => (p,j1')
				    | SOME(p',j3) =>
				      let  val (j1'',_) = match(j3,j1')
				      in (p',j1'') end
				      handle Mismatch _ => raise Interface
	in
	    if Path.equals(p,p') andalso Cell.equals(j1,j1')
	    then buildOld(mj, j)
	    else buildNew(mj, j, toInf m')
	end

    and buildSig(mj,mk,mt, rea, j, toInf, s) =
	let
	    val change       = ref false
	    fun newItem item = (change := true; item)

	    fun buildItem(item as FIX _) =
		    item
	      | buildItem(item as VAL(l,t)) =
		let
		    val t' = Type.realiseCont(mt, #typ_rea rea, t)
		in
		    if Type.same(t,t')
		    then item
		    else newItem(VAL(l,t'))
		end
	      | buildItem(item as TYP(p,k)) =
		let
		    val k' = Type.realiseKindCont(mt, #typ_rea rea, k)
		in
		    case PathMap.lookup(#typ_rea rea, p)
		      of SOME t =>
			 let val k = Type.singKind t in
			     if Type.matchesKind(k,k')
			     then newItem(TYP(p,k))
			     else raise Mismatch(MismatchTyp(Path.toLab p,k,k'))
			 end
		       | NONE =>
			 if Type.sameKind(k,k')
			 then item
			 else newItem(TYP(p,k'))
		end
	      | buildItem(item as MOD(p,j)) =
		let
		    val j' = build(mj,mk,mt, rea, j)
		in
		    case PathMap.lookup(#mod_rea rea, p)
		      of SOME m =>
			 let val  j      = sing' m
			     val (j'',_) = match(j,j') handle Mismatch m =>
				    raise Mismatch(MismatchMod(Path.toLab p, m))
			 in
			     newItem(MOD(p,j''))
			 end
		    | NONE =>
			 if Cell.equals(j,j')
			 then item
			 else newItem(MOD(p,j'))
		end
	      | buildItem(item as INF(p,k)) =
		let
		    val k' = buildKind(mj,mk,mt, rea, k)
		in
		    case PathMap.lookup(#inf_rea rea, p)
		      of SOME j =>
			 let val k = singKind j in
			     matchKind(k,k') handle Mismatch m =>
			     raise Mismatch(MismatchInf(Path.toLab p, m));
			     newItem(INF(p,k))
			 end
		       | NONE =>
			 if Cell.equals(k,k')
			 then item
			 else newItem(INF(p,k'))
		end

	    val items' = List.map buildItem (items s)
	in
	    if !change
	    then buildNew(mj, j, toInf(newSig items'))
	    else buildOld(mj, j)
	end

    and buildKind(mj,mk,mt, rea, k) =
	case KindMap.lookup(mk,k)
	  of SOME k'		=> k'
	   | NONE		=>
	case content k
	  of GROUND		=> buildOldKind(mk,k)
	   | SING j		=> buildSingKind(mj,mk,mt, rea, k, singKind,j)
	   | DEP(p,j,k1)	=> buildBindKind(mj,mk,mt,rea, k,depKind,p,j,k1)

    and buildOldKind(mk,k)    = (KindMap.insert(mk,k,k); k)
    and buildNewKind(mk,k,k') = (KindMap.insert(mk,k,k'); k')

    and buildSingKind(mj,mk,mt, rea, k, toKind, j) =
	let
	    val j' = build(mj,mk,mt, rea, j)
	in
	    if Cell.equals(j,j')
	    then buildOldKind(mk, k)
	    else buildNewKind(mk, k, toKind j')
	end

    and buildBindKind(mj,mk,mt, rea, k, toKind, p,j,k1) =
	let
	    val j'  = build(mj,mk,mt, rea, j)
	    val k1' = case PathMap.lookup(#mod_rea rea, p)
			of NONE   => buildKind(mj,mk,mt, rea, k1)
			 | SOME m => (PathMap.insert(#mod_rea rea,p,(p,j'));
				      buildKind(mj,mk,mt, rea, k1)
				      before PathMap.insert(#mod_rea rea,p,m))
	in
	    if Cell.equals(j,j') andalso Cell.equals(k1,k1')
	    then buildOldKind(mk, k)
	    else buildNewKind(mk, k, toKind(p,j',k1'))
	end


  (* Realisation *)

    and realise(rea, j) =
	if isEmptyRea rea
	then j
	else build(Map.new(), KindMap.new(), Type.realiseStart(), rea, j)


  (* Instantiation (bound renaming) *)

    fun instance(p,j) =
	let
	    val rea = newRea()
	    val j'  = instance'(rea,p,j)
	in
	    ( realise(rea,j'), rea )
	end

    and instance'(rea,p,j) =
	case content j
	  of TOP	=> j
	   | ABS _	=> j
	   | SIG s	=> instanceSig(rea,p,j,s)
	   | THAT _	=> j
	   | FUN _	=> j
	   | LAMBDA _	=> j
	   | APPLY _	=> j
	   | ABBREV(j1,j2) =>
	     let
		 val j2' = instance'(rea,p,j2)
	     in
		 if Cell.equals(j2,j2')
		 then j
		 else abbrev'(j1,j2')
	     end

    and instanceSig(rea, p0, j, s) =
	let
	    val change = ref false

	    fun instanceItem(item as (FIX _ | VAL _)) =
		    item
	      | instanceItem(item as TYP(p,k)) =
		let
		    val p' = Path.dot(p0, Path.toLab p)
		in
		    if Type.isSingKind k then ()
		    else (PathMap.insert(#typ_rea rea, p, Type.abs(k,p'));
(*DEBUG
TextIO.print "instance: ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p, 80);
TextIO.print " -> ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p', 80);
TextIO.print "\n";
*)());
		    change := true;
		    TYP(p',k)
		end
	      | instanceItem(item as MOD(p,j)) =
		let
		    val p' = Path.dot(p0, Path.toLab p)
		    val j' = instance'(rea,p',j)
		in
		    if isSing j then ()
		    else (PathMap.insert(#mod_rea rea, p, (p',j'));
(*DEBUG
TextIO.print "instance: ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p, 80);
TextIO.print " -> ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p', 80);
TextIO.print "\n";
*)());
		    change := true;
		    MOD(p',j')
		end
	      | instanceItem(item as INF(p,k)) =
		let
		    val p' = Path.dot(p0, Path.toLab p)
		in
		    if isSingKind k then ()
		    else PathMap.insert(#inf_rea rea, p, abs'(k,p'));
		    change := true;
		    INF(p',k)
		end

	    val items' = List.map instanceItem (items s)
	in
	    if !change
	    then sign'(newSig items')
	    else j
	end


  (* Minimisation (currently unused) *)

    fun minimise(u,j) =
	case content j
	  of TOP		=> j
	   | ABS(k,p)		=> top'()
	   | SIG s		=> let val s' = minimiseSig(u,s) in
				       if s = s' then j
				       else if List.null(items s') then top'()
				       else sign' s'
				   end
	   | THAT m		=> (minimiseMod(u,m) ; j)
	   | FUN(p,j1,j2)	=> let val j2' = minimise(u,j2) in
				       minimise'(u,j1);
				       if Cell.equals(j2,j2') then j
				       else if isTop' j2 then top'()
				       else arrow'(p,j1,j2')
				   end (* should remove p,j1 refs from u! *)
	   | LAMBDA(p,j1,j2)	=> (minimise'(u,j2);
				    minimise'(u,j1);
				    j) (* should remove p,j1 refs from u! *)
	   | APPLY(j,m)		=> (minimise'(u,j); minimiseMod(u,m); j)
	   | ABBREV(j1,j2)	=> let val j2' = minimise(u,j2) in
				       minimise'(u,j1);
				       if Cell.equals(j2,j2') then j
				       else if isTop' j2' then top'()
				       else abbrev'(j1,j2')
				   end

    and minimiseSig(u, s) =
	let
	    val change = ref false

	    fun minimiseItem(item as FIX _) =
		    (change := true; NONE)
	      | minimiseItem(item as VAL(l,t)) =
		if false (*TODO...*) then
		    (change := true; NONE)
		else
		    (PathMap.appi (fn(p,_) => PathSet.insert(u,p))
				  (Type.paths t);
		     SOME item)
	      | minimiseItem(item as TYP(p,k)) =
		if PathSet.member(u,p) then
		    (PathMap.appi (fn(p,_) => PathSet.insert(u,p))
				  (Type.pathsKind k);
		     SOME item)
		else
		    (change := true; NONE)
	      | minimiseItem(item as MOD(p,j)) =
		if PathSet.member(u,p) then
		    (minimise'(u,j); SOME item)
		else let
		    val j' = minimise(u,j)
		in
		    if Cell.equals(j,j') then SOME item
		    else if isTop' j' then (change := true; NONE)
		    else (change := true; SOME(MOD(p,j')))
		    (* should remove p,j refs from u! *)
		end
	      | minimiseItem(item as INF(p,k)) =
		if PathSet.member(u,p) then
		    (minimiseKind(u,k); SOME item)
		else
		    (change := true; NONE)

	    val items' = List.mapPartial minimiseItem (items s)
	in
	    if !change
	    then newSig items'
	    else s
	end

    and minimise'(u,j) =
	case content j
	  of TOP		=> ()
	   | ABS(k,p)		=> (minimiseKind(u,k); PathSet.insert(u,p))
	   | SIG s		=> minimiseSig'(u,s)
	   | THAT m		=> minimiseMod(u,m)
	   | ( FUN(p,j1,j2)
	     | LAMBDA(p,j1,j2))	=> (minimise'(u,j2); minimise'(u,j1))
				   (* should remove p,j1 refs from u! *)
	   | APPLY(j,m)		=> (minimise'(u,j); minimiseMod(u,m))
	   | ABBREV(j1,j2)	=> (minimise(u,j2); minimise'(u,j1))

    and minimiseSig'(u, s) =
	let
	    fun minimiseItem(FIX _) = ()
	      | minimiseItem(VAL(l,t)) =
		if false (*TODO...*) then () else
		    PathMap.appi (fn(p,_) => PathSet.insert(u,p)) (Type.paths t)
	      | minimiseItem(TYP(p,k)) =
		if not(PathSet.member(u,p)) then () else
		    PathMap.appi (fn(p,_) => PathSet.insert(u,p))
				 (Type.pathsKind k)
	      | minimiseItem(MOD(p,j)) =
		    minimise'(u,j)
	      | minimiseItem(INF(p,k)) =
		if not(PathSet.member(u,p)) then () else
		    minimiseKind(u,k)
	in
	    List.app minimiseItem (items s)
	end

    and minimiseMod(u, (p,j))	= (PathSet.insert(u,p); minimise'(u,j))

    and minimiseKind(u,k) =
	case content k
	  of GROUND		=> ()
	   | SING j		=> minimise'(u,j)
	   | DEP(p,j,k)		=> (minimiseKind(u,k); minimise'(u,j))
				   (* should remove p,j refs from u! *)


  (* Matching *)

    (* build a realisation suitable for matching *)

    fun matchRea(s1,s2) =
	let
	    val rea = newRea()
	in
	    if stamp s1 = stamp s2 then () else matchRea'(rea,s1,s2);
	    rea
	end

    and matchRea'(rea,s1,s2) = List.appr (matchReaItem(rea, tab s1)) (items s2)

    and matchReaItem (rea,tab1) item2 =
	let
	    val dom as (_,l) = itemDom item2
	in
	    case item2
	      of TYP(p2,k2) =>
		 if Type.isSingKind k2 then () else
		 let val k1 = selectTyp(strong(Tab.lookupExistent(tab1,dom)))
		 in
(*DEBUG
TextIO.print "matchRea: ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p2, 80);
TextIO.print " -> ";
PrettyPrint.output(TextIO.stdOut, PPType.ppTyp(Type.asSingKind k1), 80);
TextIO.print "\n";
*)
		     if Type.matchesKind(k1,k2)
		     then PathMap.insert(#typ_rea rea, p2, Type.asSingKind k1)
		     else raise Mismatch(MismatchTyp(l,k1,k2))
		 end
	       | MOD(p2,j2) =>
		 let val j1  = selectMod(strong(Tab.lookupExistent(tab1,dom)))
		     val j2' = realise(rea, j2)
		 in
(*DEBUG
TextIO.print "matchRea: ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p2, 80);
TextIO.print " -> ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath(#1(asSing j1)), 80);
TextIO.print(inf'ToString(content j1));
TextIO.print "\n";
*)
		     PathMap.insert(#mod_rea rea, p2, asSing j1);
		     if not(isSig' j2') then () else
		     if not(isSig' j1)
		     then raise Mismatch(MismatchMod(l, Incompatible(j1,j2')))
		     else matchRea'(rea, asSig' j1, asSig' j2')
			  handle Mismatch m => raise Mismatch(MismatchMod(l,m))
		 end
	       | INF(p2,k2) =>
		 if isSingKind k2 then () else
		 let val k1 = selectInf(strong(Tab.lookupExistent(tab1,dom)))
		 in
(*DEBUG
TextIO.print "matchRea: ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p2, 80);
TextIO.print " -> ";
TextIO.print(inf(asSingKind k1));
TextIO.print "\n";
*)
		     matchKind(k1,k2) handle Mismatch m =>
			raise Mismatch(MismatchInf(l,m));
		     PathMap.insert(#inf_rea rea, p2, asSingKind k1)
		 end
	       | _ => ()
	end
	handle Tab.Lookup _ => ()


    (* actual matching *)

    fun match(j1,j2) = match'(false,j1,j2)
    and match'(isNested,j1,j2) =
	if Cell.equals(j1,j2) then (j2, newRea()) else
	case (content j1, content j2)
	  of (_, TOP) =>
		(j2, newRea())
	   | (THAT m1, THAT m2) =>
		let
		    val (m,rea) = matchMod(isNested,m1,m2)
		in
		    if Cell.equals(#2 m2, #2 m)
		    then (j2, rea)
		    else (sing' m, rea)
		end
	   | (THAT(p1,j1'), _) =>
		let
		    val (j,rea) = match'(isNested,j1',j2)
		in
		    (sing'(p1,#1(instance(p1,j))), rea)
		end
	   | (ABS(_,p1), ABS(_,p2)) =>
		if Path.equals(p1,p2)
		then (j2, newRea())
		else raise Mismatch(Incompatible(j1,j2))
	   | (SIG s1, SIG s2) =>
		if isNested then (matchSig(s1,s2,j2), dummyRea) else
		let
		    val rea  = matchRea(s1,s2)
		    val j2'  = realise(rea,j2)
		    val j2'' = matchSig(s1, asSig j2', j2')
		in
		    (j2'', rea)
		end
	   | (FUN(p1,j11,j12), FUN(p2,j21,j22)) =>
		let
		    val (j11',rea1) = match(j21,j11) handle Mismatch m =>
					raise Mismatch(MismatchDom m)
		    val  _          = PathMap.insert(#mod_rea rea1,p1,(p2,j11'))
		    val (j22',rea2) = match(realise(rea1,j12), j22)
				      handle Mismatch m =>
					raise Mismatch(MismatchRan m)
		in
		    (j2, newRea())
		    (* For applicative functors this would be???
		    if Cell.equals(j22,j22')
		    then (j2, rea2)
		    else (arrow'(p2,j21,j22'), rea2)
		    *)
		end
	   | (LAMBDA(p1,j11,j12), LAMBDA(p2,j21,j22)) =>
		let
		    val (j11',rea) = match(j21,j11) handle Mismatch m =>
					raise Mismatch(MismatchDom m)
		in
		    PathMap.insert(#mod_rea rea, p1, (p2,j11'));
		    equal(realise(rea,j12), j22) handle Mismatch m =>
					raise Mismatch(MismatchRan m);
		    (j2, newRea())
		end
	   | (APPLY(j1',m1), APPLY(j2',m2)) =>
		let
		    val (j',rea1) = match(j1',j2')
		    val (m',rea2) = matchMod(isNested,m1,m2) handle Mismatch m=>
					raise Mismatch(MismatchArg m)
		in
		    unionRea(rea2,rea1) handle PathMap.Collision _ =>
			raise Mismatch(Incompatible(j1,j2));
		    if Cell.equals(j2',j') andalso Cell.equals(#2 m2, #2 m')
		    then (j2, rea2)
		    else (apply'(j',m'), rea2)
		end
	   | (ABBREV(_,j1), _) => match'(isNested,j1,j2)
	   | (_, ABBREV(_,j2)) => match'(isNested,j1,j2)

	   | _ => raise Mismatch(Incompatible(j1,j2))

    and matchMod(isNested, (p1,j1), (p2,j2)) =
	if not(Path.equals(p1,p2))
	then raise Mismatch(IncompatibleMod(p1,p2)) else
	let
	    val (j2',rea) = match'(isNested,j1,j2)
	in
	    ((p2,j2'), rea)
	end

    and matchSig(s1,s2,j2) =
	if stamp s1 = stamp s2 then j2 else
	let
	    val change = ref false
	    val tab1   = tab s1

	    fun matchItem item2 =
		let
		    val dom as (_,l) = itemDom item2
		    val item1        = strong(Tab.lookupExistent(tab1,dom))
		in
		    case (item1, item2)
		      of (FIX(l1,q1), FIX(l2,q2)) =>
			 if q1 = q2 then item2
			 else raise Mismatch(MismatchFix(l,q1,q2))
		       | (VAL(l1,t1), VAL(l2,t2)) =>
			 if Type.matches(t1,t2) then item2
			 else raise Mismatch(MismatchVal(l,t1,t2))
		       | (TYP(p1,k1), TYP(p2,k2)) =>
			 if Type.matchesKind(k1,k2) then
			     if Type.equalsKind(k1,k2)
			     then item2
			     else (change := true ; TYP(p2,k1))
			 else raise Mismatch(MismatchTyp(l,k1,k2))
		       | (MOD(p1,j1), MOD(p2,j2)) =>
			 (let
			     val (j2',_) = match'(true,j1,j2)
			  in
			     if Cell.equals(j2,j2')
			     then item2
			     else (change := true ; MOD(p2,j2'))
			  end handle Mismatch mismatch =>
			  raise Mismatch(MismatchMod(l, mismatch)))
		       | (INF(p1,k1), INF(p2,k2)) =>
			 ((matchKind(k1,k2);
			     if Cell.equals(k1,k2)
			     then item2
			     else (change := true ; INF(p2,k1))
			 ) handle Mismatch mismatch =>
			  raise Mismatch(MismatchInf(l, mismatch)))
		       | _ => raise Assert.failure
		end
		handle Tab.Lookup(FIX',l) => raise Mismatch(MissingFix l)
		     | Tab.Lookup(VAL',l) => raise Mismatch(MissingVal l)
		     | Tab.Lookup(TYP',l) => raise Mismatch(MissingTyp l)
		     | Tab.Lookup(MOD',l) => raise Mismatch(MissingMod l)
		     | Tab.Lookup(INF',l) => raise Mismatch(MissingInf l)

	     val items2' = List.mapr matchItem (items s2)
	in
	    if !change
	    then sign'(newSig items2')
	    else j2
	end

    and matchKind(k1,k2) =
	if Cell.equals(k1,k2) then () else
	case (content k1, content k2)
	  of (GROUND, GROUND) => ()
	   | (SING _, GROUND) => ()
	   | (SING j1, SING j2) => equal(j1,j2)
	   | (DEP(p1,j1,k11), DEP(p2,j2,k21)) =>
		let
		    val (j',rea) = match(j2,j1) handle Mismatch m =>
					raise Mismatch(MismatchDom m)
		in
		    PathMap.insert(#mod_rea rea, p1, (p2,j'));
		    matchKind(realiseKind(rea,k11), k21) handle Mismatch m =>
					raise Mismatch(MismatchRan m)
		end
	   | _ => raise Mismatch(IncompatibleKind(k1,k2))

    and equal(j1,j2) = ignore(match(j1,j2); match(j2,j1))



  (* Intersection *)

    fun intersect(j1,j2) = j1


    fun intersect(j1,j2) = intersect'(false,j1,j2)
    and intersect'(isNested,j1,j2) =
	if Cell.equals(j1,j2) then j2 else
	case (content j1, content j2)
	  of (TOP, _) =>
		(* T /\ j2 = j2 *)
		j2
	   | (_, TOP) =>
		(* j1 /\ T = j1 *)
		j1
	   | (THAT m1, THAT m2) =>
		let
		    val m = intersectMod(isNested,m1,m2)
		in
		    if Cell.equals(#2 m2, #2 m)
		    then j2
		    else sing' m
		end
	   | (THAT(p1,j1'), _) =>
		let
		    val j = intersect'(isNested,j1',j2)
		in
		    sing'(p1, #1(instance(p1,j)))
		end
	   | (_, THAT(p2,j2')) =>
		let
		    val j = intersect'(isNested,j1,j2')
		in
		    sing'(p2, #1(instance(p2,j)))
		end
	   | (ABS(_,p1), ABS(_,p2)) =>
		if Path.equals(p1,p2)
		then j2
		else raise Mismatch(Incompatible(j1,j2))
	   | (SIG s1, SIG s2) =>
		(* s1 /\ s2 = ... *)
		(*TODO: currently unidirectional only *)
		if isNested then j1 else
		let
		    val rea  = matchRea(s2,s1)
		    val _    = PathMap.deleteAll(#mod_rea rea)
				(* hack until we do it right *)
		    val j1'  = realise(rea,j1)
		in
		    j1'
		end
(*
	   | (FUN(p1,j11,j12), FUN(p2,j21,j22)) =>
		let
		    val (j11',rea1) = match(j21,j11) handle Mismatch m =>
					raise Mismatch(MismatchDom m)
		    val  _          = PathMap.insert(#mod_rea rea1,p1,(p2,j11'))
		    val (j22',rea2) = match(realise(rea1,j12), j22)
				      handle Mismatch m =>
					raise Mismatch(MismatchRan m)
		in
		    if Cell.equals(j22,j22')
		    then (j2, rea2)
		    else (arrow'(p2,j21,j22'), rea2)
		end
	   | (LAMBDA(p1,j11,j12), LAMBDA(p2,j21,j22)) =>
		let
		    val (j11',rea) = match(j21,j11) handle Mismatch m =>
					raise Mismatch(MismatchDom m)
		in
		    PathMap.insert(#mod_rea rea, p1, (p2,j11'));
		    equal(realise(rea,j12), j22) handle Mismatch m =>
					raise Mismatch(MismatchRan m);
		    (j2, newRea())
		end
	   | (APPLY(j1',m1), APPLY(j2',m2)) =>
		let
		    val (j',rea1) = match(j1',j2')
		    val (m',rea2) = matchMod(isNested,m1,m2) handle Mismatch m=>
					raise Mismatch(MismatchArg m)
		in
		    unionRea(rea2,rea1) handle PathMap.Collision _ =>
			raise Mismatch(Incompatible(j1,j2));
		    if Cell.equals(j2',j') andalso Cell.equals(#2 m2, #2 m')
		    then (j2, rea2)
		    else (apply'(j',m'), rea2)
		end
*)	   | (ABBREV(_,j1), _) => intersect'(isNested,j1,j2)
	   | (_, ABBREV(_,j2)) => intersect'(isNested,j1,j2)

	   | _ => raise Mismatch(Incompatible(j1,j2))

    and intersectMod(isNested, (p1,j1), (p2,j2)) =
	if not(Path.equals(p1,p2))
	then raise Mismatch(IncompatibleMod(p1,p2)) else
	let
	    val j2' = intersect'(isNested,j1,j2)
	in
	    (p2,j2')
	end

(* OLD----------------------------
    fun intersect(j1,j2) =
	let
	    val j1' = clone j1
	    val j2' = clone j2
	    val rea = newRea()
	in
	    intersect'(rea, j1', j2')
	end

    and intersect'(rea, j1, ref TOP) = j1
      | intersect'(rea, ref TOP, j2) = j2
      | intersect'(rea, j1 as ref(CON(_,p1)), j2 as ref(CON(_,p2))) =
	if Path.equals(p1,p2) then
	    j1
	else
	    raise Mismatch(Incompatible(j1,j2))

      | intersect'(rea, j1 as ref(SIG s1), ref(SIG s2)) =
	    ( intersectSig(rea, s1, s2) ; j1 )

      | intersect'(rea, ref(FUN(p1,j11,j12)), ref(FUN(p2,j21,j22))) =
	(*UNFINISHED*)
	    raise Assert.failure

      | intersect'(rea, ref(LAMBDA(p1,j11,j12)), ref(LAMBDA(p2,j21,j22))) =
	(*UNFINISHED*)
	    raise Assert.failure

      | intersect'(rea, j1 as ref(APPLY(j11,p1,j12)), ref(APPLY(j21,p2,j22))) =
	(*UNFINISHED*)
	    raise Assert.failure

      | intersect'(rea, ref(LINK j1), j2)	= intersect'(rea, j1, j2)
      | intersect'(rea, j1, ref(LINK j2))	= intersect'(rea, j1, j2)

      | intersect'(rea, j1 as ref(ABBREV(j11,j12)), j2)	=
	(*UNFINISHED: need some node for intersection... *)
	( intersect'(rea, j12, j2)
	; j1 := ABBREV(j11,j2)
	; j1
	)
      | intersect'(rea, j1, j2 as ref(ABBREV(j21,j22))) =
	(*UNFINISHED: need some node for intersection... *)
	( intersect'(rea, j1, j22)
	; j2 := ABBREV(j21,j1)
	; j2
	)
      | intersect'(rea, j1,j2) = raise Mismatch(Incompatible(j1,j2))


    (* UNFINISHED: does ignore dependencies on second argument signature *)

    and intersectSig(rea, s1 as (itemsr1 as ref items1, tabor1),
			  s2 as (itemsr2 as ref items2, tabor2)) =
	let
	    fun pairDef(rea', toZ, b, x1, NONE, x2, SOME z) =
		    ( if b then PathMap.insert(rea', idPath x1, z) else ()
		    ; false )
	      | pairDef(rea', toZ, b, x1, SOME z, x2, NONE) =
		    ( if b then PathMap.insert(rea', idPath x2, z) else ()
		    ; true )
	      | pairDef(rea', toZ, b, x1, SOME z1, x2, SOME z2) =
		    ( if b then PathMap.insert(rea', idPath x2, z1) else ()
		    ; true )
	      | pairDef(rea', toZ, b, x1, NONE, x2, NONE) =
		    ( if b then PathMap.insert(rea', idPath x2, toZ(idPath x1))
			   else ()
		    ; true )

	    fun pair1(b, FIX(x1,q1), FIX(x2,q2)) = true
	      | pair1(b, VAL(x1,t1), VAL(x2,t2)) = true
	      | pair1(b, TYP(x1,k1,d1), TYP(x2,k2,d2)) =
		    pairDef(#typ_rea rea, pathToTyp k1, b, x1, d1, x2, d2)
	      | pair1(b, MOD(x1,j1,d1), MOD(x2,j2,d2)) =
		    pairDef(#mod_rea rea, pathToPath, b, x1, d1, x2, d2)
		    before pairNested(j1,j2)
	      | pair1(b, INF(x1,k1,d1), INF(x2,k2,d2)) =
		    pairDef(#inf_rea rea, pathToInf k1, b, x1, d1, x2, d2)
	      | pair1 _ =
		    raise Assert.failure

	    and pair(tab1, [], pairs, left) = ( List.rev pairs, List.rev left )
	      | pair(tab1, item2::items, pairs, left) =
		case Tab.lookup(tab1, (itemSpace item2, itemLab item2))
		  of NONE => pair(tab1, items, pairs, item2::left)
		   | SOME [] => raise Assert.failure
		   | SOME(item1::_) =>
		     (* Nested structures are already realised.
		      * We would loop during realisation if we inserted
		      * identity realisations. *)
		     ( if pair1(not(Path.equals(itemPath item1,itemPath item2)),
				!item1, !item2) then ()
		       else item1 :=: item2
		     ; pair(tab1, items, (item1,item2)::pairs, left)
		     )

	    (* Necessary to create complete realisation. *)
	    and pairNested(ref(SIG s1), ref(SIG(ref items2,_))) =
		    ignore(pair(getTab s1, items2, [], []))
	      | pairNested(ref(FUN _), ref(FUN _)) =
		(*UNFINISHED: when introducing functor paths*) ()
	      | pairNested(ref(LINK j1), j2) = pairNested(j1, j2)
	      | pairNested(j1, ref(LINK j2)) = pairNested(j1, j2)
	      | pairNested(ref(ABBREV(_,j1)), j2) = pairNested(j1, j2)
	      | pairNested(j1, ref(ABBREV(_,j2))) = pairNested(j1, j2)
	      | pairNested _ = ()

	    val (pairs,left) = pair(getTab s1, items2, [], [])
	    val realiseState = Type.realiseStart()
	in
	    realiseSig(realiseState, rea, s1) ;
	    realiseSig(realiseState, rea, s2) ;
	    List.app (intersectItem rea) pairs ;
	    itemsr1 := items1 @ left ;
	    itemsr2 := !itemsr1 ;
	    tabor1 := NONE ;
	    tabor2 := NONE
	end

    and intersectItem rea (item1 as ref item1', ref item2') =
	    item1 := intersectItem'(rea, item1', item2')

    and intersectItem'(rea, FIX(x1,q1), FIX(x2,q2)) =
	let
	    val l = idLab x1
	    val q = intersectFix(l, q1, q2)
	in
	    FIX(x1,q)
	end
      | intersectItem'(rea, VAL(x1,t1), VAL(x2,t2)) =
	let
	    val l = idLab x1
	    val t = intersectTyp(l, t1, t2)
	in
	    VAL(x1,t)
	end
      | intersectItem'(rea, TYP(x1,k1,d1), TYP(x2,k2,d2)) =
	let
	    val l = idLab x1
	    val k = intersectTKind(l, k1, k2)
	    val d = intersectTypDef(l, d1, d2)
	in
	    TYP(x1,k,d)
	end
      | intersectItem'(rea, MOD(x1,j1,d1), MOD(x2,j2,d2)) =
	let
	    val l = idLab x1
	    val j = intersectInf(l, j1, j2)
	    val d = intersectModDef(l, d1, d2)
	in
	    MOD(x1,j,d)
	end
      | intersectItem'(rea, INF(x1,k1,d1), INF(x2,k2,d2)) =
	let
	    val l = idLab x1
	    val k = intersectKind(l, k1, k2)
	    val d = intersectInfDef(l, d1, d2)
	in
	    INF(x1,k,d)
	end
      | intersectItem' _ = raise Assert.failure

    and intersectFix(l,q1,q2) =
	if q1 = q2 then q1 else
	    raise Mismatch(MismatchFix(l,q1,q2))

    and intersectTyp(l,t1,t2) =
	( Type.intersect(t1,t2) ; t1 )
	handle Type.Intersect =>
	    raise Mismatch(MismatchVal(l,t1,t2))

    and intersectTKind(l,k1,k2) =
	if k1 = k2 then k1 else
	    raise Mismatch(MismatchTyp(l,k1,k2))

    and intersectInf(l,j1,j2) =
	intersect'(newRea(), j1, j2)
	handle Mismatch mismatch =>
	    raise Mismatch(MismatchMod(l, mismatch))

    and intersectKind(l,k1,k2) =
	( equaliseKind(k1,k2) ; k1 )
	handle Mismatch mismatch =>
	    raise Mismatch(MismatchInf(l, mismatch))


    and intersectTypDef(l, NONE,    NONE)	= NONE
      | intersectTypDef(l, SOME t1, NONE)	= SOME t1
      | intersectTypDef(l, NONE,    SOME t2)	= SOME t2
      | intersectTypDef(l, SOME t1, SOME t2)	=
	    if Type.equals(t1,t2) then SOME t1 else
		raise Mismatch(ManifestTyp(l, SOME t1, t2))

    and intersectModDef(l, NONE,    NONE)	= NONE
      | intersectModDef(l, SOME p1, NONE)	= SOME p1
      | intersectModDef(l, NONE,    SOME p2)	= SOME p2
      | intersectModDef(l, SOME p1, SOME p2)	=
	    if Path.equals(p1,p2) then SOME p1 else
		raise Mismatch(ManifestMod(l, SOME p1, p2))

    and intersectInfDef(l, NONE,    NONE)	= NONE
      | intersectInfDef(l, SOME j1, NONE)	= SOME j1
      | intersectInfDef(l, NONE,    SOME j2)	= SOME j2
      | intersectInfDef(l, SOME j1, SOME j2)	=
	    ( equalise(j1,j2) ; SOME j1 ) handle Mismatch mismatch =>
		raise Mismatch(ManifestInf(l, SOME mismatch))

OLD-------------------*)

  (* Tie forwarding knots *)

    val _ = apply'Fwd      := apply'
    val _ = matchFwd       := match
    val _ = matchKindFwd   := matchKind
    val _ = realiseFwd     := realise
    val _ = realiseKindFwd := realiseKind
end
