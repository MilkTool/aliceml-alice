(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Name           from "Name"
import structure Label          from "Label"
import structure Path           from "Path"
import structure PathMap        from "PathMap"
import structure Type           from "Type"
import structure Fixity         from "Fixity"
import signature SIMPLE_IMP_MAP from "../utility/SIMPLE_IMP_MAP-sig"

signature INF =
sig
  (* Types *)

    type lab   = Label.t
    type path  = Path.t
    type typ   = Type.t
    type tkind = Type.kind
    type fix   = Fixity.t

    type kind						(* [kappa,k] *)
    type sign						(* [sigma,s] *)
    type item
    type inf						(* [jota,j] *)
    type mod = path * inf				(* [mod] *)
    type t   = inf

    structure Map :	SIMPLE_IMP_MAP where type key = inf
    structure KindMap :	SIMPLE_IMP_MAP where type key = kind


  (* Realisations *)

    type typ_rea = typ PathMap.t
    type mod_rea = mod PathMap.t
    type inf_rea = inf PathMap.t

    type rea	 = { typ_rea : typ_rea
		   , mod_rea : mod_rea
		   , inf_rea : inf_rea
		   }

    val newRea :	unit -> rea
    val isEmptyRea :	rea -> bool


  (* Kinds *)

    exception Kind

    val groundKind :	unit -> kind
    val singKind :	inf  -> kind
    val depKind :	path * inf * kind -> kind

    val isGroundKind :	kind -> bool			(* modulo subkinding *)
    val isSingKind :	kind -> bool
    val isDepKind :	kind -> bool

    val asSingKind :	kind -> inf			(* Kind *)
    val asDepKind :	kind -> path * inf * kind	(* Kind *)

    val kind :		inf -> kind


  (* Injections *)

    val top :		unit		 -> inf
    val abs :		kind * path	 -> inf
    val sign :		sign		 -> inf
    val arrow :		path * inf * inf -> inf
    val lambda :	path * inf * inf -> inf
    val apply :		inf * mod        -> inf
    val sing :		mod              -> inf
    val abbrev :	inf * inf        -> inf

  (* Inquiries *)

    val isTop :		inf -> bool	(* modulo abbreviations *)
    val isAbs :		inf -> bool
    val isSig :		inf -> bool
    val isArrow :	inf -> bool
    val isLambda :	inf -> bool
    val isApply :	inf -> bool
    val isSing :	inf -> bool
    val isAbbrev :	inf -> bool	(* precise *)

    val isTop' :	inf -> bool	(* modulo abbreviations & singletons *)
    val isAbs' :	inf -> bool
    val isSig' :	inf -> bool
    val isArrow' :	inf -> bool

  (* Projections *)

    exception Interface

    val asAbs :		inf -> path			(* Interface *)
    val asSig :		inf -> sign			(* Interface *)
    val asArrow :	inf -> path * inf * inf		(* Interface *)
    val asLambda :	inf -> path * inf * inf		(* Interface *)
    val asApply :	inf -> inf  * mod		(* Interface *)
    val asSing :	inf -> mod			(* Interface *)
    val asAbbrev :	inf -> inf  * inf		(* Interface *)

    val asAbs' :	inf -> path			(* Interface *)
    val asSig' :	inf -> sign			(* Interface *)
    val asArrow' :	inf -> path * inf * inf		(* Interface *)

  (* Instantiation, realisation, etc. *)

    val instance :	path * inf -> inf * rea
    val realise :	rea  * inf -> inf		(* Mismatch *)

    val compress :	inf  -> unit
    val compressSig :	sign -> unit

  (* Matching and intersection *)

    datatype mismatch =
	  MissingFix       of lab
	| MissingVal       of lab
	| MissingTyp       of lab
	| MissingMod       of lab
	| MissingInf       of lab
	| MismatchFix      of lab * fix * fix
	| MismatchVal      of lab * typ * typ
	| MismatchTyp      of lab * tkind * tkind
	| MismatchMod      of lab * mismatch
	| MismatchInf      of lab * mismatch
	| MismatchDom      of mismatch
	| MismatchRan      of mismatch
	| MismatchArg      of mismatch
	| Incompatible     of inf * inf
	| IncompatibleMod  of path * path
	| IncompatibleKind of kind * kind

    exception Mismatch of mismatch

    val matchKind :	kind * kind -> unit		(* Mismatch *)
    val match :		inf * inf -> inf * rea		(* Mismatch *)
    val intersect :	inf * inf -> inf		(* Mismatch *)

  (* Signature construction *)

    val emptySig :	unit -> sign
    val emptySig' :	sign -> sign			(* TODO: Hack! *)

    val extendFix :	sign * lab  * fix   -> unit	(* Path.Path *)
    val extendVal :	sign * lab  * typ   -> unit	(* Path.Path *)
    val extendTyp :	sign * path * tkind -> unit	(* Path.Path *)
    val extendMod :	sign * path * inf   -> unit	(* Path.Path *)
    val extendInf :	sign * path * kind  -> unit	(* Path.Path *)

  (* Signature inspection *)

    val items :		sign -> item list		(* reversed! *)

    exception Item

    val isFixItem :	item -> bool
    val isValItem :	item -> bool
    val isTypItem :	item -> bool
    val isModItem :	item -> bool
    val isInfItem :	item -> bool

    val asFixItem :	item -> lab * fix		(* Item *)
    val asValItem :	item -> lab * typ		(* Item *)
    val asTypItem :	item -> path * tkind		(* Item *)
    val asModItem :	item -> path * inf		(* Item *)
    val asInfItem :	item -> path * kind		(* Item *)

    exception Lookup

    val lookupFix :	sign * lab -> fix		(* Lookup *)
    val lookupVal :	sign * lab -> typ		(* Lookup *)
    val lookupTyp :	sign * lab -> tkind		(* Lookup *)
    val lookupMod :	sign * lab -> inf		(* Lookup *)
    val lookupInf :	sign * lab -> kind		(* Lookup *)

    val lookupTyp' :	sign * lab -> typ		(* Lookup, Type.Kind *)
    val lookupMod' :	sign * lab -> mod		(* Lookup, Interface *)
    val lookupInf' :	sign * lab -> inf		(* Lookup, Kind *)

    val pathTyp :	sign * lab -> path		(* Lookup *)
    val pathMod :	sign * lab -> path		(* Lookup *)
    val pathInf :	sign * lab -> path		(* Lookup *)

  (* Closure check *)

    exception Unclosed of lab * typ

    val close :		sign -> unit			(* Unclosed *)
end
