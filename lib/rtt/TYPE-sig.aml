(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Name           from "Name"
import structure Label          from "Label"
import structure Path           from "Path"
import structure PathMap        from "PathMap"
import signature SIMPLE_IMP_MAP from "../utility/SIMPLE_IMP_MAP-sig"


signature TYPE =
sig

  (* Types *)

    datatype sort = OPEN | CLOSED
    datatype kind = STAR | ARROW of kind * kind		(* [kappa,k] *)

    type lab  = Label.t					(* [lab,l] *)
    type path = Path.t					(* [pi,p] *)
    type con  = kind * sort * path			(* [chi,c] *)

    type row						(* [rho,r] *)
    type var						(* [alpha,a] *)
    type typ						(* [tau,t] *)
    type t = typ

    type path_rea = path PathMap.t
    type typ_rea  = typ PathMap.t

    type canonical_typ
    val canonical : typ -> canonical_typ
    val fromCanonical : canonical_typ -> typ
    structure Map : SIMPLE_IMP_MAP where type key = canonical_typ


  (* Kinds *)

    exception Kind

    val isStar :	kind -> bool
    val domKind :	kind -> kind			(* [Kind] *)
    val ranKind :	kind -> kind			(* [Kind] *)

  (* Injections *)

    val unknown :	kind      -> typ
    val inArrow :	typ * typ -> typ
    val inTuple :	typ vector -> typ
    val inProd :	row       -> typ
    val inSum :		row       -> typ
    val inVar :		var       -> typ
    val inCon :		con       -> typ
    val inAll :		var * typ -> typ
    val inExist :	var * typ -> typ
    val inLambda :	var * typ -> typ
    val inApply :	typ * typ -> typ
    val inMu :		typ       -> typ
    val inAbbrev :	typ * typ -> typ

    val var :		kind -> var

  (* Inquiries *)

    val isUnknown :	typ -> bool	(* modulo abbreviations *)
    val isArrow :	typ -> bool
    val isTuple :	typ -> bool
    val isProd :	typ -> bool
    val isSum :		typ -> bool
    val isVar :		typ -> bool
    val isCon :		typ -> bool
    val isAll :		typ -> bool
    val isExist :	typ -> bool
    val isLambda :	typ -> bool
    val isApply :	typ -> bool
    val isMu :		typ -> bool
    val isAbbrev :	typ -> bool	(* precise *)

    val isUnknown' :	typ -> bool	(* modulo unrolling *)
    val isArrow' :	typ -> bool
    val isTuple' :	typ -> bool
    val isProd' :	typ -> bool
    val isSum' :	typ -> bool
    val isVar' :	typ -> bool
    val isCon' :	typ -> bool
    val isAll' :	typ -> bool
    val isExist' :	typ -> bool
    val isLambda' :	typ -> bool
    val isApply' :	typ -> bool


  (* Projections *)

    exception Type

    val asArrow :	typ -> typ * typ		(* [Type] *)
    val asTuple :	typ -> typ vector		(* [Type] *)
    val asProd :	typ -> row			(* [Type] *)
    val asSum :		typ -> row			(* [Type] *)
    val asVar :		typ -> var			(* [Type] *)
    val asCon :		typ -> con			(* [Type] *)
    val asAll :		typ -> var * typ		(* [Type] *)
    val asExist :	typ -> var * typ		(* [Type] *)
    val asLambda :	typ -> var * typ		(* [Type] *)
    val asApply :	typ -> typ * typ		(* [Type] *)
    val asMu :		typ -> typ			(* [Type] *)
    val asAbbrev : 	typ -> typ * typ		(* [Type] *)

    val asArrow' :	typ -> typ * typ		(* [Type] *)
    val asTuple' :	typ -> typ vector		(* [Type] *)
    val asProd' :	typ -> row			(* [Type] *)
    val asSum' :	typ -> row			(* [Type] *)
    val asVar' :	typ -> var			(* [Type] *)
    val asCon' :	typ -> con			(* [Type] *)
    val asAll' :	typ -> var * typ		(* [Type] *)
    val asExist' :	typ -> var * typ		(* [Type] *)
    val asLambda' :	typ -> var * typ		(* [Type] *)
    val asApply' :	typ -> typ * typ		(* [Type] *)

  (* Complex extractions *)

    val kind :		typ -> kind
    val kindVar :	var -> kind

    val path :		typ -> path			(* [Type] *)
    val pathCon :	con -> path

    val paths :		typ -> kind PathMap.t

  (* Operations on rows *)

    exception Row

    val unknownRow :	unit -> row
    val emptyRow :	unit -> row
    val openRow :	row  -> row
    val extendRow :	lab * typ * row -> row		(* [Row] *)

    val isEmptyRow :	row -> bool			(* no known fields *)
    val isUnknownRow :	row -> bool
    val headRow :	row -> lab * typ		(* sorted, [Row] *)
    val tailRow :	row -> row			(* sorted, [Row] *)
    val lookupRow :	row * lab -> typ		(* [Row] *)

  (* Copying and instantiation *)

    val instance :	typ -> typ
    val skolem :	typ -> typ
    val clone :		typ -> typ

    type clone_state
    val cloneStart :	unit -> clone_state
    val cloneCont :	clone_state * typ -> typ

    val realise :	typ_rea  * typ -> unit
    val realisePath :	path_rea * typ -> unit

  (* Unification and closure *)

    exception Fill
    exception Unify of typ * typ
    exception Intersect

    val fill :		typ * typ  -> unit	(* does no occur check! *)
    val unify :		typ * typ  -> unit	(* [Unify] *)
    val intersect :	typ * typ  -> unit
    val close :		typ list -> typ list
    val isClosed :	typ -> bool

  (* Comparison *)

    val equals :	typ * typ -> bool
    val matches :	typ * typ -> bool

  (* Hashing *)

    val hash :		typ -> int
    val same :		typ * typ  -> bool	(* identitiy, yuck... *)

  (* Level management *)

    exception Lift of var

    val lift :		typ  -> unit		(* [Lift] *)
    val enterLevel :	unit -> unit
    val exitLevel :	unit -> unit
    val resetLevel :	unit -> unit
end
