(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Name           from "Name"
import structure Label          from "Label"
import structure Path           from "Path"
import structure PathMap        from "PathMap"
import signature SIMPLE_IMP_MAP from "../utility/SIMPLE_IMP_MAP-sig"


signature TYPE =
sig
  (* Types *)

    type lab  = Label.t					(* [lab,l] *)
    type path = Path.t					(* [pi,p] *)

    type kind						(* [kappa,k] *)
    type typ						(* [tau,t] *)
    type var						(* [alpha,a] *)
    type row						(* [rho,r] *)
    type t = typ

    type rea = typ PathMap.t


  (* Maps of types *)

    type canonical_typ

    val canonical :	typ -> canonical_typ
    val fromCanonical :	canonical_typ -> typ

    structure Map :	SIMPLE_IMP_MAP where type key = canonical_typ


  (* Kinds *)

    exception Kind

    val starKind :	unit -> kind
    val extKind :	unit -> kind
    val arrowKind :	kind * kind -> kind
    val singKind :	typ -> kind

    val isStarKind :	kind -> bool			(* module subkinding *)
    val isExtKind :	kind -> bool
    val isArrowKind :	kind -> bool
    val isSingKind :	kind -> bool

    val asArrowKind :	kind -> kind * kind		(* Kind *)
    val asSingKind :	kind -> typ			(* Kind *)

    val equalKind :	kind * kind -> bool

    val kind :		typ -> kind
    val kindVar :	var -> kind


  (* Injections *)

    exception Type
    exception Fix

    val newVar :	kind -> var

    val unknown :	kind      -> typ
    val var :		var       -> typ
    val con :		path * kind -> typ
    val arrow :		typ * typ   -> typ		(* Kind *)
    val tuple :		typ vector  -> typ		(* Kind *)
    val prod :		row       -> typ
    val sum :		row       -> typ
    val all :		var * typ -> typ		(* Type, Kind *)
    val exist :		var * typ -> typ		(* Type, Kind *)
    val lambda :	var * typ -> typ		(* Type *)
    val apply :		typ * typ -> typ		(* Kind *)
    val abbrev :	typ * typ -> typ		(* Kind *)

    val fix :		(typ * typ) vector -> unit	(* Fix *)

  (* Inquiries *)

    val isUnknown :	typ -> bool	(* modulo abbreviations *)
    val isVar :		typ -> bool
    val isCon :		typ -> bool
    val isArrow :	typ -> bool
    val isTuple :	typ -> bool
    val isProd :	typ -> bool
    val isSum :		typ -> bool
    val isMu :		typ -> bool
    val isAll :		typ -> bool
    val isExist :	typ -> bool
    val isLambda :	typ -> bool
    val isApply :	typ -> bool
    val isAbbrev :	typ -> bool	(* precise *)

    val isTuple' :	typ -> bool	(* modulo abbreviations & unrolling *)
    val isProd' :	typ -> bool
    val isSum' :	typ -> bool

  (* Projections *)

    val asVar :		typ -> var			(* Type *)
    val asCon :		typ -> path			(* Type *)
    val asArrow :	typ -> typ * typ		(* Type *)
    val asTuple :	typ -> typ vector		(* Type *)
    val asProd :	typ -> row			(* Type *)
    val asSum :		typ -> row			(* Type *)
    val asMu :		typ -> typ			(* Type *)
    val asAll :		typ -> var * typ		(* Type *)
    val asExist :	typ -> var * typ		(* Type *)
    val asLambda :	typ -> var * typ		(* Type *)
    val asApply :	typ -> typ * typ		(* Type *)
    val asAbbrev : 	typ -> typ * typ		(* Type *)

    val asTuple' :	typ -> typ vector		(* Type *)
    val asProd' :	typ -> row			(* Type *)
    val asSum' :	typ -> row			(* Type *)

  (* Operations on rows *)

    exception Row

    val unknownRow :	unit -> row
    val emptyRow :	unit -> row
    val extendRow :	lab * typ * row -> row		(* Row *)

    val isUnknownRow :	row -> bool
    val isEmptyRow :	row -> bool
    val hdRow :		row -> lab * typ		(* sorted, Row *)
    val tlRow :		row -> row			(* sorted, Row *)
    val lookupRow :	row * lab -> typ		(* Row *)

  (* Copying and instantiation *)

    val instance :	typ -> typ
    val skolem :	typ -> typ

    val realise :	rea * typ -> typ			(* Kind *)
    val realiseKind :	rea * kind -> kind			(* Kind *)

    type realise_context
    val realiseStart :	unit -> realise_context
    val realiseCont :	realise_context * rea * typ -> typ	(* Kind *)
    val realiseKindCont: realise_context * rea * kind -> kind	(* Kind *)

  (* Comparison *)

    type mismatch      = typ * typ
    type kind_mismatch = mismatch option
    exception Mismatch     of mismatch
    exception KindMismatch of kind_mismatch

    val equal :		typ * typ -> bool
    val match :		typ * typ -> unit		(* Mismatch *)
    val matchKind :	kind * kind -> unit		(* KindMismatch *)

    type match_context
    val matchStart :	unit -> match_context
    val matchBranch :	match_context -> match_context
    val matchCont :	match_context * rea * typ * typ -> unit	(* Mismatch *)
    val equalCont :	match_context * rea * typ * typ -> unit	(* Mismatch *)
    val matchKindCont :	match_context * rea * kind * kind -> unit (* KindM. *)
    val equalKindCont :	match_context * rea * kind * kind -> unit (* KindM. *)

  (* Unification and closure *)

    exception Lift of var

    val lift :		typ  -> unit			(* Lift *)
    val unify :		typ * typ  -> unit		(* Mismatch, Lift *)
    val close :		typ list -> typ list
    val isClosed :	typ -> bool

    val paths :		typ -> kind PathMap.t
    val pathsKind :	kind -> kind PathMap.t

  (* Hashing *)

    val hash :		typ -> int
    val same :		typ * typ -> bool	(* for efficiency hacks... *)
    val sameKind :	kind * kind -> bool

  (* Level management *)

    val enterLevel :	unit -> unit
    val exitLevel :	unit -> unit
    val resetLevel :	unit -> unit
end
