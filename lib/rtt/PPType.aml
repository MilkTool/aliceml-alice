(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2001-2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Assert        from "../utility/Assert"

import structure Label         from "Label"
import structure Path          from "Path"
import structure Type          from "Type"
import structure PervasiveType from "PervasiveType"

import structure PrettyPrint   from "../utility/PrettyPrint"
import structure PPMisc        from "PPMisc"
import structure PPPath        from "PPPath"
import signature PP_TYPE       from "PP_TYPE-sig"


structure PPType :> PP_TYPE =
struct

    (* Import *)

    open Type
    open PrettyPrint
    open PPMisc

    infixr ^^ ^/^


    (* Helpers *)

    fun unarg t =
	case inspect t
	 of Apply(t1,t2) =>
	    if not(equal(t1, PervasiveType.typ_strict)) then SOME t else
	    (case inspect t2
	     of Prod r =>
		if isEmptyRow r
		then NONE
		else SOME t2
	      | _ => SOME t2
	    )
	  | _ => SOME t

    fun uncurry t =
	case inspect t
	 of Apply(t1,t2) =>
	    let
		val (t3,ts) = uncurry t1
	    in
		(t3, ts@[t2])
	    end
	  | _ => (t,[])
	
    fun parenPrec p (p',doc) =
	if p > p' then
	    paren doc
	else
	    doc


    (* Simple objects *)

    fun ppLab l = text(Label.toString l)

    fun varToString(isBound, n) =
	let
	    val c = String.str(Char.chr(Char.ord #"a" + n mod 26))
	    val i = n div 26
	in
	    (if isBound then "'" else "'_") ^
	    (if i = 0 then c else c ^ Int.toString i)
	end

  (* Name management for holes *)

    val counter = ref 0
    val holes   = Map.new() : int Map.t

    fun holeIndex t =
	case Map.lookup(holes, canonical t)
	 of SOME n => n
	  | NONE =>
	let
	    val n = !counter+1
	in
	    (* Clean up map *)
	    List.app (fn t => Map.deleteExistent(holes, t))
		(Map.foldi (fn(t,_,ts) => if isUnknown(fromCanonical t)
					  then ts else t::ts) [] holes);
	    Map.insertDisjoint(holes, canonical t, n);
	    counter := n;
	    n
	end


  (* Kinds *)

    (* Precedence:
     *	0 : arrow (ty1 -> ty2)
     *	1 : star
     *)

    fun ppKind k = fbox(below(ppKindPrec 0 k))

    and ppKindPrec p k =
	case inspectKind k
	 of StarKind		=> text "#"
	  | ExtKind		=> text "#+"
	  | ArrowKind(k1,k2)	=> parenPrec p (0, ppKindPrec 1 k1 ^/^ text "->"
						   ^/^ ppKindPrec 0 k2)
	  | SingKind t		=> text "<" ^^ ppTyp t ^^ text ">"


  (* Types *)

    (* Precedence:
     *  0 : kind annotation (ty : kind)
     *	1 : binders (EXIST ty1 . ty2)
     *	2 : function arrow (ty1 -> ty2)
     *	3 : tuple (ty1 * ... * tyn)
     *	4 : constructed type (tyseq tycon)
     *)

    and ppTyp t = ppTyp' [] t
    and ppTyp' ps t =
	let
	    val m = Map.new()
	    val a = ref 0

	    fun ppVar isBound = text(varToString(isBound, !a before a := !a+1))

	    fun ppTyp t = fbox(below(ppTypPrec 0 t))

	    and ppTypPrec p t =
		let val t' = canonical t in
		    case Map.lookup(m,t')
		      of SOME doc => doc
		       | NONE     => let val doc = ppTypPrec' p t in
					 Map.insert(m,t',doc) ; doc
				     end
		end

	    and ppTypPrec' p t =
		if isAbbrev t then
		    let
			val (t1,t2) = asAbbrev t
		    in
			ppTypPrec p t1
(*DEBUG
			paren(ppTypPrec p t1 ^/^ text "as" ^/^ ppTypPrec p t2)
*)
		    end
		else case inspect t
		 of Unknown =>
		    let
			val k   = kind t
			val doc = text("'" ^ Int.toString(holeIndex t))
		    in
			case inspectKind k
			 of StarKind => doc
			  | _ => parenPrec p (0, doc ^/^ text ":" ^/^ ppKind k)
		    end
		  | Var a =>
		    let
			val k   = kindVar a
			val doc = ppVar false	(* unbound! *)
		    in
			case inspectKind k
			 of StarKind => doc
			  | _ => parenPrec p (0, doc ^/^ text ":" ^/^ ppKind k)
		    end
		  | Con p =>
			PPPath.ppPath' ps p
		  | Arrow(t1,t2) =>
		    let
			val doc = ppTypPrec 3 t1 ^/^ text "->" ^/^
				  ppTypPrec 2 t2
		    in
			parenPrec p (2, doc)
		    end
		  | Prod r =>
		    if isTupleRow r then
			case asTupleRow r
			 of #[]  => text "unit"
			  | #[t] => brace(ppField(text ":", Label.fromInt 1, t))
			  | ts   =>
			let
			   val doc = ppStarList (ppTypPrec 4) (Vector.toList ts)
			in
			   parenPrec p (3, fbox(below(nest doc)))
			end
		    else
			brace(fbox(below(ppRow(text ",", text ":", r))))
		  | Sum r =>
			brack(fbox(below(ppRow(text " |", text "of", r))))
		  | All(a,t') =>
(*DEBUG
		    let
			val doc = ppBinder("ALL",a,t')
		    in
			parenPrec p (1, fbox(below doc))
		    end
*)
			(Map.insert(m, canonical(var a), ppVar true);
			 ppTyp t')
		  | Exist(a,t') =>
		    let
			val doc = ppBinder("EXIST",a,t')
		    in
			parenPrec p (1, fbox(below doc))
		    end
		  | Lambda(a,t') =>
		    let
			val doc = ppBinder("FN",a,t')
		    in
			parenPrec p (1, fbox(below doc))
		    end
		  | Apply(t1,t2) =>
		    let
			val (t3,ts) = uncurry t
		    in
			fbox(nest(ppSeqPrec ppTypPrec 4 ts ^/^ ppTypPrec 5 t3))
		    end
		  | Mu t' =>
		    let
			val doc = ppVar true
		    in
			Map.insert(m, canonical t, doc);
			parenPrec p (1,
			    fbox(
				abox(
				    hbox(
					text "MU" ^/^
					doc ^/^
					text "."
				    ) ^^
				    nest(break ^^
					ppTyp t'
				    )
				)
			    )
			)
		    end

	    and ppRow(sep,ann,r) =
		case inspectRow r
		 of UnknownRow		=> text "..."
		  | EmptyRow		=> empty
		  | FieldRow(l,t,r')	=>
		    let
			val doc1 = ppField(ann,l,t)
			val doc2 = ppRow(sep,ann,r')
		    in
			if isEmpty doc2
			then doc1
			else doc1 ^^ sep ^/^ doc2
		    end

	    and ppField(ann,l,t) =
		case unarg t
		  of NONE => ppLab l
		   | SOME t' =>
		     abox(
			 hbox(
			     ppLab l ^/^
			     ann
			 ) ^^
			 nest(break ^^
			     ppTyp t'
			 )
		     )

	    and ppBinder(s,a,t) =
		let
		    val doc = ppVar true
		in
		    Map.insert(m, canonical(var a), doc);
		    abox(
			hbox(
			    text s ^/^
			    doc ^/^
			    text "."
			) ^^
			nest(break ^^
			    ppTyp t
			)
		    )
		end
	in
	    ppTyp t
	end
end
