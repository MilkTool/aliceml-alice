(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Assert        from "../utility/Assert"

import structure Label         from "Label"
import structure Path          from "Path"
import structure Type          from "Type"
import structure PervasiveType from "PervasiveType"

import structure PrettyPrint   from "../utility/PrettyPrint"
import structure PPMisc        from "PPMisc"
import structure PPPath        from "PPPath"
import signature PP_TYPE       from "PP_TYPE-sig"


structure PPType :> PP_TYPE =
struct

    (* Import *)

    open Type
    open PrettyPrint
    open PPMisc

    infixr ^^ ^/^


    (* Helpers *)

    fun unarg t =
	if not(Type.isApply t) then SOME t else
	let
	    val (t1,t2) = Type.asApply t
	in
	    if not(Type.equal(t1, PervasiveType.typ_strict)) then
		SOME t
	    else if Type.isTuple t2
	    andalso Vector.length(Type.asTuple t2) = 0 then
		NONE
	    else
		SOME t2
	end

    fun uncurry t =
	if not(isApply t) then (t,[]) else
	let
	    val (t1,t2) = asApply t
	    val (t3,ts) = uncurry t1
	in
	    (t3, ts@[t2])
	end
	
    fun parenPrec p (p',doc) =
	if p > p' then
	    paren doc
	else
	    doc


    (* Simple objects *)

    fun ppLab l		= text(Label.toString l)

    fun varToString(isBound, n) =
	let
	    val c = String.str(Char.chr(Char.ord #"a" + n mod 26))
	    val i = n div 26
	in
	    (if isBound then "'" else "'_") ^
	    (if i = 0 then c else c ^ Int.toString i)
	end


  (* Kinds *)

    (* Precedence:
     *	0 : arrow (ty1 -> ty2)
     *	1 : star
     *)

    fun ppKind k = fbox(below(ppKindPrec 0 k))

    and ppKindPrec p k =
	if isSingKind k then
	    text "<" ^^ ppTyp(asSingKind k) ^^ text ">"
	else if isExtKind k then
	    text "#+"
	else if isStarKind k then
	    text "#"
	else if isArrowKind k then
	    let
		val (k1,k2) = asArrowKind k
		val doc     = ppKindPrec 1 k1 ^/^ text "->" ^/^ ppKindPrec 0 k2
	    in
		parenPrec p (0, doc)
	    end
	else
	    raise Assert.failure

  (* Types *)

    (* Precedence:
     *  0 : kind annotation (ty : kind)
     *	1 : binders (EXIST ty1 . ty2)
     *	2 : function arrow (ty1 -> ty2)
     *	3 : tuple (ty1 * ... * tyn)
     *	4 : constructed type (tyseq tycon)
     *)

    and ppTyp t = ppTyp' [] t
    and ppTyp' ps t =
	let
	    val m = Map.new()
	    val a = ref 0

	    fun ppVar isBound = text(varToString(isBound, !a before a := !a+1))

	    fun ppTyp t = fbox(below(ppTypPrec 0 t))

	    and ppTypPrec p t =
		let val t' = canonical t in
		    case Map.lookup(m,t')
		      of SOME doc => doc
		       | NONE     => let val doc = ppTypPrec' p t in
					 Map.insert(m,t',doc) ; doc
				     end
		end

	    and ppTypPrec' p t =
		if isAbbrev t then
(*DEBUG
		    paren(
*)
		    ppTypPrec p (#1(asAbbrev t))
(*
		    ^/^ text "as" ^/^ ppTypPrec p (#2(asAbbrev t)) )
*)
		else if isUnknown t then
		    let
			val k   = kind t
			val t'  = fromCanonical(canonical t)
			val doc = text("'" ^ Int.toString(hash t'))
		    in
			if isStarKind k
			then doc
			else parenPrec p (0, doc ^/^ text ":" ^/^ ppKind k)
		    end
		else if isVar t then
		    let
			val k   = kind t
			val doc = ppVar false ^^	(* unbound! *)
				  text("'" ^ Int.toString(hash t))
		    in
			if isStarKind k
			then doc
			else parenPrec p (0, doc ^/^ text ":" ^/^ ppKind k)
		    end
		else if isAbs t then
		    PPPath.ppPath' ps (asAbs t)
		else if isArrow t then
		    let
			val (t1,t2) = asArrow t
			val  doc    = ppTypPrec 3 t1 ^/^ text "->" ^/^
				      ppTypPrec 2 t2
		    in
			parenPrec p (2, doc)
		    end
		else if isTuple t then
		    case asTuple t
		      of #[]  => text "unit"
		       | #[t] => brace(ppField(text ":", Label.fromInt 1, t))
		       | ts   => 
		    let
			val doc = ppStarList (ppTypPrec 4) (Vector.toList ts)
		    in
			parenPrec p (3, fbox(below(nest doc)))
		    end
		else if isProd t then
		    brace(fbox(below(ppRow(",", ":", asProd t))))
		else if isSum t then
		    brack(fbox(below(ppRow(" |", "of", asSum t))))
		else if isAll t then
		    let
			val (a,t1) = asAll t
(*DEBUG
			val doc    = ppBinder("ALL",a,t1)
		    in
			parenPrec p (1, fbox(below doc))
		    end
*)
		    in
			Map.insert(m, canonical(var a), ppVar true);
			ppTyp t1
		    end
		else if isExist t then
		    let
			val (a,t1) = asExist t
			val doc    = ppBinder("EX",a,t1)
		    in
			parenPrec p (1, fbox(below doc))
		    end
		else if isLambda t then
		    let
			val (a,t1) = asLambda t
			val doc    = ppBinder("FN",a,t1)
		    in
			parenPrec p (1, fbox(below doc))
		    end
		else if isApply t then
		    let
			val (t1,t2) = asApply t
			val (t3,ts) = uncurry t
		    in
			fbox(nest(ppSeqPrec ppTypPrec 4 ts ^/^ ppTypPrec 5 t3))
		    end
		else if isMu t then
		    let
			val t1  = asMu t
			val doc = ppVar true
		    in
			Map.insert(m, canonical t, doc);
			parenPrec p (1,
			    fbox(
				abox(
				    hbox(
					text "MU" ^/^
					doc ^/^
					text "."
				    ) ^^
				    nest(break ^^
					ppTyp t1
				    )
				)
			    )
			)
		    end
		else
		    raise Assert.failure

	    and ppRow(sep,ann,r) = ppRow'(text sep, text ann, isUnknownRow r, r)
	    and ppRow'(sep,ann,unknown,r) =
		if isEmptyRow r then
		    if unknown
		    then text "..."
		    else empty
		else
		    let
			val (l,t) = hdRow r
			val  doc  = ppField(ann,l,t)
			val  r'   = tlRow r
		    in
			if isEmptyRow r' andalso not unknown
			then doc
			else doc ^^ sep ^/^ ppRow'(sep, ann, unknown, r')
		    end

	    and ppField(ann,l,t) =
		case unarg t
		  of NONE => ppLab l
		   | SOME t' =>
		     abox(
			 hbox(
			     ppLab l ^/^
			     ann
			 ) ^^
			 nest(break ^^
			     ppTyp t'
			 )
		     )

	    and ppBinder(s,a,t) =
		let
		    val doc = ppVar true
		in
		    Map.insert(m, canonical(var a), doc);
		    abox(
			hbox(
			    text s ^/^
			    doc ^/^
			    text "."
			) ^^
			nest(break ^^
			    ppTyp t
			)
		    )
		end
	in
	    ppTyp t
	end
end
