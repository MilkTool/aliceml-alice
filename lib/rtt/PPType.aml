(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Assert        from "../utility/Assert"

import structure Label         from "Label"
import structure Path          from "Path"
import structure Type          from "Type"
import structure PervasiveType from "PervasiveType"

import structure PrettyPrint   from "../utility/PrettyPrint"
import structure PPMisc        from "PPMisc"
import structure PPPath        from "PPPath"
import signature PP_TYPE       from "PP_TYPE-sig"


structure PPType :> PP_TYPE =
struct

    (* Import *)

    open Type
    open PrettyPrint
    open PPMisc

    infixr ^^ ^/^


    (* Helpers *)

    fun uncurry t =
	if not(isApply t) then (t,[]) else
	let
	    val (t1,t2) = asApply t
	    val (t3,ts) = uncurry t1
	in
	    (t3, ts@[t2])
	end
	
    fun parenPrec p (p',doc) =
	if p > p' then
	    paren doc
	else
	    doc


    (* Simple objects *)

    fun ppLab l		= text(Label.toString l)
    fun ppCon (k,_,p)	= PPPath.ppPath p

    fun varToString(isBound, n) =
	let
	    fun rep(0,c) = c
	      | rep(n,c) = c ^ rep(n-1,c)

	    val c = String.str(Char.chr(Char.ord #"a" + n mod 26))
	in
	    (if isBound then "'" else "'_") ^ rep(n div 26, c)
	end


    (* Kinds *)

    (* Precedence:
     *	0 : arrow (ty1 -> ty2)
     *	1 : star
     *)

    fun ppKind k = fbox(below(ppKindPrec 0 k))

    and ppKindPrec p  STAR		= text "*"
      | ppKindPrec p (ARROW(k1,k2))	= 
	let
	    val doc = ppKindPrec 1 k1 ^/^ text "->" ^/^ ppKindPrec 0 k2
	in
	    parenPrec p (0, doc)
	end


    (* Types *)

    (* Precedence:
     *  0 : kind annotation (ty : kind)
     *	1 : binders (EXIST ty1 . ty2)
     *	2 : function arrow (ty1 -> ty2)
     *	3 : tuple (ty1 * ... * tyn)
     *	4 : constructed type (tyseq tycon)
     *)

    fun ppTyp t =
	let
	    val m = Map.new()
	    val a = ref 0

	    fun ppVar isBound = text(varToString(isBound, !a before a := !a+1))

	    fun ppTyp t = fbox(below(ppTypPrec 0 t))

	    and ppTypPrec p t =
		let val t' = canonical t in
		    case Map.lookup(m,t')
		      of SOME doc => doc
		       | NONE     => let val doc = ppTypPrec' p t in
					 Map.insert(m,t',doc) ; doc
				     end
		end

	    and ppTypPrec' p t =
		if isAbbrev t then
(*DEBUG
		    paren(
*)
		    ppTypPrec p (#1(asAbbrev t))
(*
		    ^/^ text "as" ^/^ ppTypPrec p (#2(asAbbrev t)) )
*)
		else if isUnknown t then
		    let
			val k   = kind t
			val doc = ppVar false
		    in
			if k = STAR
			then doc
			else parenPrec p (0, doc ^/^ text ":" ^/^ ppKind k)
		    end
		else if isArrow t then
		    let
			val (t1,t2) = asArrow t
			val  doc    = ppTypPrec 3 t1 ^/^ text "->" ^/^
				      ppTypPrec 2 t2
		    in
			parenPrec p (2, doc)
		    end
		else if isTuple t then
		    case asTuple t
		      of #[] => text "unit"
		       | ts  => 
		    let
			val doc = ppStarList (ppTypPrec 4) (Vector.toList ts)
		    in
			parenPrec p (3, fbox(below(nest doc)))
		    end
		else if isProd t then
		    brace(fbox(below(ppRow(",", ":", asProd t))))
		else if isSum t then
		    brack(fbox(below(ppRow("|", "of", asSum t))))
		else if isVar t then
		    let
			val k   = kind t
			val doc = ppVar false ^^ text "?"	(* unbound! *)
		    in
			if k = STAR
			then doc
			else parenPrec p (0, doc ^/^ text ":" ^/^ ppKind k)
		    end
		else if isCon t then
		    ppCon(asCon t)
		else if isAll t then
		    let
			val (a,t1) = asAll t
(*DEBUG
			val doc    = ppBinder("ALL",a,t1)
		    in
			parenPrec p (1, fbox(below doc))
		    end
*)
		    in
			Map.insert(m, canonical(inVar a), ppVar true);
			ppTyp t1
		    end
		else if isExist t then
		    let
			val (a,t1) = asExist t
			val doc    = ppBinder("EX",a,t1)
		    in
			parenPrec p (1, fbox(below doc))
		    end
		else if isLambda t then
		    let
			val (a,t1) = asLambda t
			val doc    = ppBinder("FN",a,t1)
		    in
			parenPrec p (1, fbox(below doc))
		    end
		else if isApply t then
		    let
			val (t1,t2) = asApply t
			val (t3,ts) = uncurry t
		    in
			fbox(nest(ppSeqPrec ppTypPrec 4 ts ^/^ ppTypPrec 5 t3))
		    end
		else if isMu t then
		    let
			val t1  = asMu t
			val doc = ppVar true
		    in
			Map.insert(m, canonical t, doc);
			abox(
			    hbox(
				text "MU" ^/^
				doc ^/^
				text "."
			    ) ^^
			    nest(break ^^
				ppTyp t1
			    )
			)
		    end
		else
		    raise Assert.failure

	    and ppRow(sep,ann,r) = ppRow'(text sep, text ann, isUnknownRow r, r)
	    and ppRow'(sep,ann,unknown,r) =
		if isEmptyRow r then
		    if unknown
		    then text "..."
		    else empty
		else
		    let
			val (l,t) = headRow r
			val  doc  = ppField(ann,l,t)
			val  r'   = tailRow r
		    in
			if isEmptyRow r' andalso not unknown
			then doc
			else doc ^/^ sep ^/^ ppRow'(sep, ann, unknown, r')
		    end

	    and ppField(ann,l,t) =
		if Type.equals(t, PervasiveType.typ_zero) then
		    ppLab l
		else
		    abox(
			hbox(
			    ppLab l ^/^
			    ann
			) ^^
			nest(break ^^
			    ppTyp t
			)
		    )

	    and ppBinder(s,a,t) =
		let
		    val doc = ppVar true
		in
		    Map.insert(m, canonical(inVar a), doc);
		    abox(
			hbox(
			    text s ^/^
			    doc ^/^
			    text "."
			) ^^
			nest(break ^^
			    ppTyp t
			)
		    )
		end
	in
	    ppTyp t
	end
end
