(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Assert      from "../utility/Assert"

import structure Label       from "Label"
import structure Path        from "Path"
import structure Type        from "Type"
import structure Fixity      from "Fixity"
import structure Inf         from "Inf"

import structure PrettyPrint from "../utility/PrettyPrint"
import structure PPMisc      from "PPMisc"
import structure PPPath      from "PPPath"
import structure PPType      from "PPType"
import signature PP_INF      from "PP_INF-sig"


structure PPInf :> PP_INF =
struct

    (* Import *)

    open Inf
    open Fixity
    open PrettyPrint
    open PPMisc

    infixr ^^ ^/^


    (* Helpers *)

    fun uncurry j =
	if isApply j then
	    let
		val (j1,p,j2) = asApply j
		val (j',ps)   = uncurry j1
	    in
		(j,ps@[p])
	    end
	else
	    (j,[])


    (* Simple objects *)

    fun ppLab l			= text(Label.toString l)
    fun ppCon (k,p)		= PPPath.ppPath p

    fun ppFix NONFIX		= text "nonfix"
      | ppFix(PREFIX n)		= text "prefix" ^/^ text(Int.toString n)
      | ppFix(POSTFIX n)	= text "postfix" ^/^ text(Int.toString n)
      | ppFix(INFIX(n,LEFT))	= text "infix" ^/^ text(Int.toString n)
      | ppFix(INFIX(n,RIGHT))	= text "infixr" ^/^ text(Int.toString n)
      | ppFix(INFIX(n,NEITHER))	= text "infixn" ^/^ text(Int.toString n)


    (* Interfaces *)

    (* Precedence:
     *	0 : binders (LAMBDA(id : inf1) . inf2)
     *	1 : constructed type (inf(path))
     *)

    fun ppInf j = fbox(below(ppInf' j))

    and ppInf' j =
	if isAbbrev j then
(*DEBUG
	    paren(
*)
	    ppInf'(#1(asAbbrev j))
(*
	    ^/^ text "as" ^/^ ppInf'(#2(asAbbrev j)) )
*)
	else if isTop j then
	    text "any"
	else if isCon j then
	    ppCon(asCon j)
	else if isSig j then
	    ppSig'(asSig j)
	else if isArrow j then
	    let
		val (p,j1,j2) = asArrow j
	    in
		fbox(below(ppBinder("fct",p,j1,j2)))
	    end
	else if isLambda j then
	    let
		val (p,j1,j2) = asLambda j
	    in
		fbox(below(ppBinder("fn",p,j1,j2)))
	    end
	else if isApply j then
	    let
		val (j',ps) = uncurry j
	    in
		fbox(nest(List.foldl (fn(p,d) => d ^/^ paren(PPPath.ppPath p))
				      (ppInf j') ps))
	    end
	else
	    raise Assert.failure

    and ppBinder(s,p,j1,j2) =
	    abox(
		fbox(
		    text s ^^
		    text "(" ^^
		    below(
			PPPath.ppPath p ^/^
			text ":" ^^
			nest(break ^^
			    ppInf j1
			)
		    ) ^^
		    text ")" ^/^
		    text "->"
		) ^^
		nest(break ^^
		    ppInf j2
		)
	    )


    (* Signatures *)

    and ppSig' s =
	let
	    val doc = ppSig s
	in
	    abox(below(
		text "sig" ^^
		(if isEmpty doc then
		    empty
		 else
		    nest(vbox(break ^^ doc))
		) ^^ break ^^
		text "end"
	    ))
	end

    and ppSig s = vbox(List.foldl ppItem empty (items s))

    and ppItem(item, doc) =
	if isValItem item then
	    let
		val (l,t) = asValItem item
	    in
		if String.sub(Label.toString l,0) = #"'" then
		    doc
		else
		    abox(
			hbox(
			    text "val" ^/^ ppLab l ^/^ text ":"
			) ^^
			nest(break ^^
			    abox(PPType.ppTyp t)
			)
		    ) ^/^ doc
	    end
	else if isTypItem item then
	    let
		val (l,k,d) = asTypItem item
	    in
		if Option.isNone d then
		    abox(
			hbox(
			    text "type" ^/^
			    ppLab l ^/^
			    text ":"
			) ^^
			nest(break ^^
			    abox(PPType.ppKind k)
			)
		    ) ^/^ doc
		else
		    abox(
			hbox(
			    text "type" ^/^
			    ppLab l ^/^
			    text "="
			) ^^
			nest(break ^^
			    abox(PPType.ppTyp(Option.valOf d))
			)
		    ) ^/^ doc
	    end
	else if isModItem item then
	    let
		val (l,j,d) = asModItem item
	    in
		abox(
		    hbox(
			text(if isArrow j then "functor"
					  else "structure") ^/^
			ppLab l ^/^
			text ":"
		    ) ^^
		    nest(break ^^
			abox(ppInf j) (* ^^
			(case d of NONE => empty | SOME p =>
			    if Path.equals(p,lookupModPath(s,l)) then
				empty
			    else
				nest(break ^^
				    hbox(text "=" ^/^ hbox(PPPath.ppPath p))
				)
			) *)
		    )
		) ^/^ doc
	    end
	else if isInfItem item then
	    let
		val (l,k,d) = asInfItem item
	    in
		if Option.isNone d then
		    abox(
			hbox(
			    text "signature" ^/^
			    ppLab l ^/^
			    text ":"
			) ^^
			nest(break ^^
			    abox(ppKind k)
			)
		    ) ^/^ doc
		else
		    abox(
			hbox(
			    text "signature" ^/^
			    ppLab l ^/^
			    text "="
			) ^^
			nest(break ^^
			    abox(ppInf(Option.valOf d))
			)
		    ) ^/^ doc
	    end
	else if isFixItem item then
	    let
		val (l,f) = asFixItem item
	    in
		hbox(
		    ppFix f ^/^
		    ppLab l
		) ^/^ doc
	    end
	else
	    raise Assert.failure


    (* Kinds *)

    and ppKind k = fbox(below(ppKind' k))

    and ppKind' k =
	if isGround k then
	    text "*"
	else if isDependent k then
	    let
		val (p,j,k') = asDependent k
	    in
		fbox(below(
		    abox(
			fbox(
			    text "PI" ^/^
			    text "(" ^^
			    below(break ^^
				PPPath.ppPath p ^/^
				text ":" ^^
				nest(break ^^
				    ppInf j
				)
			    ) ^/^
			    text ")" ^/^
			    text "."
			) ^^
			nest(break ^^
			    ppKind k
			)
		    )
		))
	    end
	else
	    raise Assert.failure

end
