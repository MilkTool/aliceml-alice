(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2001-2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Assert      from "../utility/Assert"

import structure Label       from "Label"
import structure Path        from "Path"
import structure Type        from "Type"
import structure Fixity      from "Fixity"
import structure Inf         from "Inf"

import structure PrettyPrint from "../utility/PrettyPrint"
import structure PPMisc      from "PPMisc"
import structure PPPath      from "PPPath"
import structure PPType      from "PPType"
import signature PP_INF      from "PP_INF-sig"


structure PPInf :> PP_INF =
struct

    (* Import *)

    open Inf
    open Fixity
    open PrettyPrint
    open PPMisc

    infixr ^^ ^/^


    (* Helpers *)

    fun unapply  t     = unapply'(t,[])
    and unapply'(t,ps) =
	case inspect t
	 of Apply(j',m) => unapply'(j',#1(asMod m)::ps)
	  | _           => (t,ps)


    (* Simple objects *)

    fun ppLab l			= text(Label.toString l)

    fun ppFix NONFIX		= text "nonfix"
      | ppFix(PREFIX n)		= text "prefix" ^/^ text(Int.toString n)
      | ppFix(POSTFIX n)	= text "postfix"^/^ text(Int.toString n)
      | ppFix(INFIX(n,LEFT))	= text "infix"  ^/^ text(Int.toString n)
      | ppFix(INFIX(n,RIGHT))	= text "infixr" ^/^ text(Int.toString n)
      | ppFix(INFIX(n,NEITHER))	= text "infixn" ^/^ text(Int.toString n)


    (* Interfaces *)

    (* Precedence:
     *	0 : binders (LAMBDA(id : inf1) . inf2)
     *	1 : constructed type (inf(path))
     *)

    fun ppInf j = fbox(below(ppInf'([], j)))

    and ppInf'(ps,j) =
	if isAbbrev j then
	    let
		val (j1,j2) = asAbbrev j
	    in
		ppInf'(ps,j1)
(*DEBUG
		paren(ppInf'(ps,j1) ^/^ text "as" ^/^ ppInf'(ps,j2))
*)
	    end
	else case inspect j
	 of Top   => text "any"
	  | Con p => PPPath.ppPath' ps p
	  | Sig s => ppSig'(ps, s)
	  | Arrow(p,j1,j2) => fbox(below(ppBinder("fct",ps,p,j1,j2)))
	  | Exist(p,j1,j2) => ppInf'(ps,j2)
(*DEBUG
			      fbox(below(ppBinder("ex",ps,p,j1,j2)))
*)
	  | Lambda(p,j1,j2) => fbox(below(ppBinder("fn",ps,p,j1,j2)))
	  | Apply _ =>
	    let
		val (j',ps') = unapply j
	    in
		fbox(nest(List.foldl
				(fn(p,d) => d ^/^ paren(PPPath.ppPath' ps p))
				(ppInf'(ps,j')) ps'))
	    end
	  | Sing m =>
	    let
		val (p,j') = asMod m
	    in
		abox(
		    fbox(
			text "(" ^^
			below(break ^^
			    PPPath.ppPath' ps p ^/^
			    text ":" ^^
			    nest(break ^^
				ppInf'(ps,j')
			    )
			) ^/^
			text ")"
		    )
		)
	    end

    and ppBinder(s,ps,p,j1,j2) =
	    abox(
		fbox(
		    text s ^^
		    text "(" ^^
		    below(
			PPPath.ppPath p ^/^
			text ":" ^^
			nest(break ^^
			    ppInf'(p::ps,j1)
			)
		    ) ^^
		    text ")" ^/^
		    text "->"
		) ^^
		nest(break ^^
		    ppInf'(ps,j2)
		)
	    )


    (* Signatures *)

    and ppSig s = ppSig''([],s)

    and ppSig'(ps,s) =
	let
	    val doc = ppSig''(ps,s)
	in
	    abox(below(
		text "sig" ^^
		(if isEmpty doc then
		    empty
		 else
		    nest(vbox(break ^^ doc))
		) ^^ break ^^
		text "end"
	    ))
	end

    and ppSig''(ps,s) = vbox(List.foldl (ppItem ps) empty (items s))

    and ppItem ps (item, doc) =
	case inspectItem item
	 of FixItem(l,f) =>
		hbox(
		    ppFix f ^/^
		    ppLab l
		) ^/^ doc
	  | ValItem(l,t) =>
	    if String.sub(Label.toString l,0) = #"'" then
		doc
	    else
		abox(
		    hbox(
			text "val" ^/^ ppLab l ^/^ text ":"
		    ) ^^
		    nest(break ^^
			abox(PPType.ppTyp' ps t)
		    )
		) ^/^ doc
	  | TypItem(p,k) =>
	    if Type.isSingKind k then
		abox(
		    hbox(
			text "type" ^/^
			ppLab(Path.toLab p) ^/^
(*DEBUG
			PPPath.ppPath' ps p ^/^
*)
			text "="
		    ) ^^
		    nest(break ^^
			let
			    val t  = Type.asSingKind k
			    val t' = if not(Type.isAbbrev t) then t else
				     let val (t1,t2) = Type.asAbbrev t in
					 case Type.inspect t1
					 of Type.Con p1 =>
					    if Path.equal(p1,p) then t2
					    else t
					  | _ => t
				     end
			in
			    abox(PPType.ppTyp' ps t')
			end
		    )
		) ^/^ doc
	    else
		abox(
		    hbox(
			text "type" ^/^
			ppLab(Path.toLab p) ^/^
(*DEBUG
			PPPath.ppPath' ps p ^/^
*)
			text ":"
		    ) ^^
		    nest(break ^^
			abox(PPType.ppKind k)
		    )
		) ^/^ doc
	  | ModItem(p,j) =>
		abox(
		    hbox(
			text(if isArrow j then "functor"
					  else "structure") ^/^
			    ppLab(Path.toLab p) ^/^
(*DEBUG
			    PPPath.ppPath' ps p ^/^
*)
			text ":"
		    ) ^^
		    nest(break ^^
			(if isSing j then
			     let
				 val (p',j') = asMod(asSing j)
			     in
				 abox(ppInf'(p::ps,j')) ^/^
				 hbox(text "=" ^/^ PPPath.ppPath' ps p')
			     end
			 else
			     abox(ppInf'(p::ps,j))
			)
		    )
		) ^/^ doc
	  | InfItem(p,k) =>
	    if isSingKind k then
		abox(
		    hbox(
			text "signature" ^/^
			ppLab(Path.toLab p) ^/^
(*DEBUG
			PPPath.ppPath' ps p ^/^
*)
			text "="
		    ) ^^
		    nest(break ^^
			let
			    val j  = asSingKind k
			    val j' = if not(isAbbrev j) then j else
				     let val (j1,j2) = asAbbrev j in
					 if isCon j1 andalso
					    Path.equal(asCon j1, p)
					 then j2
					 else j
				     end
			in
			    abox(ppInf'(ps, j'))
			end
		    )
		) ^/^ doc
	    else
		abox(
		    hbox(
			text "signature" ^/^
			ppLab(Path.toLab p) ^/^
(*DEBUG
			PPPath.ppPath' ps p ^/^
*)
			text ":"
		    ) ^^
		    nest(break ^^
			abox(ppKind'(ps,k))
		    )
		) ^/^ doc
	  | HiddenItem item' =>
		doc
(*DEBUG
		text "? " ^^ ppItem ps (item', doc)
*)


    (* Kinds *)

    and ppKind(ps,k) = fbox(below(ppKind'(ps,k)))

    and ppKind'(ps,k) =
	case inspectKind k
	 of GroundKind => text "#"
	  | DepKind(p,j,k') =>
		fbox(below(
		    abox(
			fbox(
			    text "PI" ^/^
			    text "(" ^^
			    below(break ^^
				PPPath.ppPath p ^/^
				text ":" ^^
				nest(break ^^
				    ppInf'(p::ps,j)
				)
			    ) ^/^
			    text ")" ^/^
			    text "."
			) ^^
			nest(break ^^
			    ppKind'(ps,k)
			)
		    )
		))
	  | SingKind j =>
		abox(
		    fbox(
			text "<" ^^
			below(break ^^
			    ppInf'(ps,j)
			) ^/^
			text ">"
		    )
		)
end
