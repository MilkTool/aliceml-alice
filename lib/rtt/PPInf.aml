(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2001-2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Assert      from "../utility/Assert"

import structure Label       from "Label"
import structure Path        from "Path"
import structure Type        from "Type"
import structure Fixity      from "Fixity"
import structure Inf         from "Inf"

import structure PrettyPrint from "../utility/PrettyPrint"
import structure PPMisc      from "PPMisc"
import structure PPPath      from "PPPath"
import structure PPType      from "PPType"
import signature PP_INF      from "PP_INF-sig"


structure PPInf :> PP_INF =
struct

    (* Import *)

    open Inf
    open Fixity
    open PrettyPrint
    open PPMisc

    infixr ^^ ^/^


    (* Helpers *)

    fun uncurry j =
	if isApply j then
	    let
		val (j1,m)  = asApply j
		val (p,_)   = asMod m
		val (j',ps) = uncurry j1
	    in
		(j',ps@[p])
	    end
	else
	    (j,[])


    (* Simple objects *)

    fun ppLab l			= text(Label.toString l)

    fun ppFix NONFIX		= text "nonfix"
      | ppFix(PREFIX n)		= text "prefix" ^/^ text(Int.toString n)
      | ppFix(POSTFIX n)	= text "postfix"^/^ text(Int.toString n)
      | ppFix(INFIX(n,LEFT))	= text "infix"  ^/^ text(Int.toString n)
      | ppFix(INFIX(n,RIGHT))	= text "infixr" ^/^ text(Int.toString n)
      | ppFix(INFIX(n,NEITHER))	= text "infixn" ^/^ text(Int.toString n)


    (* Interfaces *)

    (* Precedence:
     *	0 : binders (LAMBDA(id : inf1) . inf2)
     *	1 : constructed type (inf(path))
     *)

    fun ppInf j = fbox(below(ppInf'([], j)))

    and ppInf'(ps,j) =
	if isAbbrev j then
(*DEBUG
	    paren(
*)
	    ppInf'(ps, #1(asAbbrev j))
(*
	    ^/^ text "as" ^/^ ppInf'(ps, #2(asAbbrev j)) )
*)
	else if isSing j then
	    let
		val (p,j') = asMod(asSing j)
	    in
		abox(
		    fbox(
			text "(" ^^
			below(break ^^
			    PPPath.ppPath' ps p ^/^
			    text ":" ^^
			    nest(break ^^
				ppInf'(ps,j')
			    )
			) ^/^
			text ")"
		    )
		)
	    end
	else if isTop j then
	    text "any"
	else if isCon j then
	    PPPath.ppPath' ps (asCon j)
	else if isSig j then
	    ppSig'(ps, asSig j)
	else if isArrow j then
	    let
		val (p,j1,j2) = asArrow j
	    in
		fbox(below(ppBinder("fct",ps,p,j1,j2)))
	    end
	else if isExist j then
(*DEBUG*)
	    ppInf'(ps, #3(asExist j))
(*
	    let
		val (p,j1,j2) = asExist j
	    in
		fbox(below(ppBinder("ex",ps,p,j1,j2)))
	    end
*)
	else if isLambda j then
	    let
		val (p,j1,j2) = asLambda j
	    in
		fbox(below(ppBinder("fn",ps,p,j1,j2)))
	    end
	else if isApply j then
	    let
		val (j',ps') = uncurry j
	    in
		fbox(nest(List.foldl
				(fn(p,d) => d ^/^ paren(PPPath.ppPath' ps p))
				(ppInf'(ps,j')) ps'))
	    end
	else
	    raise Assert.failure

    and ppBinder(s,ps,p,j1,j2) =
	    abox(
		fbox(
		    text s ^^
		    text "(" ^^
		    below(
			PPPath.ppPath p ^/^
			text ":" ^^
			nest(break ^^
			    ppInf'(p::ps,j1)
			)
		    ) ^^
		    text ")" ^/^
		    text "->"
		) ^^
		nest(break ^^
		    ppInf'(ps,j2)
		)
	    )


    (* Signatures *)

    and ppSig s = ppSig''([],s)

    and ppSig'(ps,s) =
	let
	    val doc = ppSig''(ps,s)
	in
	    abox(below(
		text "sig" ^^
		(if isEmpty doc then
		    empty
		 else
		    nest(vbox(break ^^ doc))
		) ^^ break ^^
		text "end"
	    ))
	end

    and ppSig''(ps,s) = vbox(List.foldl (ppItem ps) empty (items s))

    and ppItem ps (item, doc) =
	if isFixItem item then
	    let
		val (l,f) = asFixItem item
	    in
		hbox(
		    ppFix f ^/^
		    ppLab l
		) ^/^ doc
	    end
	else if isValItem item then
	    let
		val (l,t) = asValItem item
	    in
		if String.sub(Label.toString l,0) = #"'" then
		    doc
		else
		    abox(
			hbox(
			    text "val" ^/^ ppLab l ^/^ text ":"
			) ^^
			nest(break ^^
			    abox(PPType.ppTyp' ps t)
			)
		    ) ^/^ doc
	    end
	else if isTypItem item then
	    let
		val (p,k) = asTypItem item
	    in
		if Type.isSingKind k then
		    abox(
			hbox(
			    text "type" ^/^
			    ppLab(Path.toLab p) ^/^
(*DEBUG
			    PPPath.ppPath' ps p ^/^
*)
			    text "="
			) ^^
			nest(break ^^
			    let
				val t  = Type.asSingKind k
				val t' = if not(Type.isAbbrev t) then t else
					 let val (t1,t2) = Type.asAbbrev t in
					     case Type.inspect t1
					     of Type.Con p1 =>
					        if Path.equal(p1,p) then t2
						else t
					      | _ => t
					 end
			    in
				abox(PPType.ppTyp' ps t')
			    end
			)
		    ) ^/^ doc
		else
		    abox(
			hbox(
			    text "type" ^/^
			    ppLab(Path.toLab p) ^/^
(*DEBUG
			    PPPath.ppPath' ps p ^/^
*)
			    text ":"
			) ^^
			nest(break ^^
			    abox(PPType.ppKind k)
			)
		    ) ^/^ doc
	    end
	else if isModItem item then
	    let
		val (p,j) = asModItem item
	    in
		abox(
		    hbox(
			text(if isArrow j then "functor"
					  else "structure") ^/^
			    ppLab(Path.toLab p) ^/^
(*DEBUG
			    PPPath.ppPath' ps p ^/^
*)
			text ":"
		    ) ^^
		    nest(break ^^
			(if isSing j then
			     let
				 val (p',j') = asMod(asSing j)
			     in
				 abox(ppInf'(p::ps,j')) ^/^
				 abox(text "=" ^/^ PPPath.ppPath' ps p')
			     end
			 else
			     abox(ppInf'(p::ps,j))
			)
		    )
		) ^/^ doc
	    end
	else if isInfItem item then
	    let
		val (p,k) = asInfItem item
	    in
		if isSingKind k then
		    abox(
			hbox(
			    text "signature" ^/^
			    ppLab(Path.toLab p) ^/^
(*DEBUG
			    PPPath.ppPath' ps p ^/^
*)
			    text "="
			) ^^
			nest(break ^^
			    let
				val j  = asSingKind k
				val j' = if not(isAbbrev j) then j else
					 let val (j1,j2) = asAbbrev j in
					     if isCon j1 andalso
					        Path.equal(asCon j1, p)
					     then j2
					     else j
					 end
			    in
				abox(ppInf'(ps, j'))
			    end
			)
		    ) ^/^ doc
		else
		    abox(
			hbox(
			    text "signature" ^/^
			    ppLab(Path.toLab p) ^/^
(*DEBUG
			    PPPath.ppPath' ps p ^/^
*)
			    text ":"
			) ^^
			nest(break ^^
			    abox(ppKind'(ps,k))
			)
		    ) ^/^ doc
	    end
	else (* hidden *)
	    empty
(*DEBUG
	    ^^ text "? " ^^ ppItem ps (asHiddenItem item, doc)
*)

    (* Kinds *)

    and ppKind k = fbox(below(ppKind' k))

    and ppKind'(ps,k) =
	if isSingKind k then
	    abox(
		fbox(
		    text "<" ^^
		    below(break ^^
			ppInf'(ps, asSingKind k)
		    ) ^/^
		    text ">"
		)
	    )
	else if isGroundKind k then
	    text "#"
	else if isDepKind k then
	    let
		val (p,j,k') = asDepKind k
	    in
		fbox(below(
		    abox(
			fbox(
			    text "PI" ^/^
			    text "(" ^^
			    below(break ^^
				PPPath.ppPath p ^/^
				text ":" ^^
				nest(break ^^
				    ppInf'(p::ps,j)
				)
			    ) ^/^
			    text ")" ^/^
			    text "."
			) ^^
			nest(break ^^
			    ppKind'(ps,k)
			)
		    )
		))
	    end
	else
	    raise Assert.failure
end
