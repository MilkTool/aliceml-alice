(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure OS          from "../system/OS"
import structure TextIO      from "../system/TextIO"
import structure CommandLine from "../system/CommandLine"
import structure Url         from "../utility/Url"
import structure HttpServer  from "HttpServer"

signature HTTP_SERVER_MAIN =
    sig
	val main: string list -> OS.Process.status
    end

structure HttpServerMain :> HTTP_SERVER_MAIN =
    struct
	structure StringMap = HttpServer.StringMap

	val documentRoot = "/tmp/httproot"

	fun documentHandler (request: HttpServer.request) =
	    let
		val relFile = Url.toString (Url.setQuery (#uri request, NONE))
		val file = TextIO.openIn (documentRoot ^ relFile)
		val content = TextIO.inputAll file
	    in
		TextIO.closeIn file;
		{code = 200, contentType = "text/plain", content}
	    end

	fun debugHandler (request: HttpServer.request) =
	    {code = 200, contentType = "text/plain",
	     content = (#method request ^ " " ^ Url.toString (#uri request) ^
			" " ^ #protocol request ^ "\n" ^
			StringMap.foldi
			    (fn (name, value, rest) =>
				name ^ ": " ^ value ^ "\n" ^ rest)
			    "" (#headers request))}

	val blackHole: unit = Promise.future (Promise.promise ())

	fun start port =
	    let
		val url = HttpServer.start (SOME port)
	    in
		HttpServer.registerFor (Url.empty, debugHandler);
		TextIO.print ("started server at " ^ Url.toString url ^ "\n");
		Future.await blackHole
	    end

	fun usage s =
	    (TextIO.output
	     (TextIO.stdErr,
	      "Usage: " ^ CommandLine.name () ^ " <port>\n");
	     OS.Process.failure)

	fun main [portString] =
	    (case Int.fromString portString of
		 SOME port => (start port; OS.Process.success)
	       | NONE => usage ())
	  | main _ = usage ()
    end

val _ = OS.Process.exit (HttpServerMain.main (CommandLine.arguments ()))
