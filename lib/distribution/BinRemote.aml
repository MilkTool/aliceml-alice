(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2001-2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import signature COMPONENT_MANAGER
    from "x-alice:/lib/system/COMPONENT_MANAGER-sig"
import structure Unix              from "x-alice:/lib/system/Unix"
import structure Url               from "x-alice:/lib/system/Url"
import structure Http              from "x-alice:/lib/system/Http"
import structure HttpServer        from "x-alice:/lib/system/HttpServer"
import structure HttpClient        from "x-alice:/lib/system/HttpClient"
import signature REMOTE            from "REMOTE-sig"
import structure UnsafeRemote      from "UnsafeRemote"

import structure Debug from "x-alice:/lib/system/Debug"

signature REMOTE_PORT =
    sig
	type ticket = Url.t

	exception Ticket
	exception Protocol of int * string

	val export: string -> ticket
	val download: ticket -> string

	val exportFn: (string -> string) -> ticket
	val call: ticket -> string -> string
    end

structure HttpRemotePort :> REMOTE_PORT =
    struct
	type ticket = Url.t

	exception Ticket
	exception Protocol of int * string

	val pickleContentType = "application/x-alice-pickle"

	val rootUrl =
	    lazy (Url.fromString
		      ("http://" ^ (UnsafeRemote.getLocalIP ()) ^ ":" ^
		       Int.toString (HttpServer.start NONE) ^ "/"))

	val counter = ref 0

	fun register handler =
	    let
		val p = Promise.promise ()
		val n = Ref.exchange (counter, Promise.future p)
		val uri = Url.setPath (Url.empty, ["export", Int.toString n])
	    in
		Promise.fulfill (p, n + 1);
		HttpServer.register (uri, handler);
		Url.resolve rootUrl uri
	    end

	(* Error Handling *)

	exception Response of Http.response

	val ok                   = 200
	val badRequest           = 400
	val methodNotAllowed     = 405
	val unsupportedMediaType = 415

	fun errorResponse statusCode =
	    Http.makeResponse
		{statusCode,
		 contentType = "text/plain",
		 body = Http.reasonPhrase statusCode}

	fun checkMethod (request: Http.request, method) =
	    if #method request <> method then
		let
		    val response = errorResponse methodNotAllowed
		in
		    Http.StringMap.insert (#headers response, "Allow", method);
		    raise Response response
		end
	    else ()

	fun checkContentType (request: Http.request, contentType) =
	    case Http.StringMap.lookup (#headers request, "content-type") of
		SOME s where (s = contentType) => ()
	      | SOME _ => raise Response (errorResponse unsupportedMediaType)
	      | NONE => raise Response (errorResponse badRequest)

	(* Provided Functionality *)

	fun export packedValue =
	    let
		fun handler request =
		    (checkMethod (request, "GET");
		     Http.makeResponse
			 {statusCode = ok,
			  contentType = pickleContentType,
			  body = packedValue})
		    handle Response response => response
	    in
		register handler
	    end

	fun download url =
	    let
		val response =
		    HttpClient.get url
		    handle HttpClient.Authority => raise Ticket
	    in
		#body response
	    end

	fun exportFn f =
	    let
		fun handler request =
		    (checkMethod (request, "POST");
		     checkContentType (request, pickleContentType);
		     Http.makeResponse
			 {statusCode = ok,
			  contentType = pickleContentType,
			  body = f (#body request)})
		    handle Response response => response
	    in
		register handler
	    end

	fun call url packedValue =
	    let
		val response =
		    HttpClient.post (url, {contentType = pickleContentType,
					   body = packedValue})
		    handle HttpClient.Authority => raise Ticket
	    in
		(*--** check "content-type" header *)
		case #statusCode response of
		    200 => #body response
		  | statusCode =>
			raise Protocol (statusCode, #reasonPhrase response)
	    end
    end

functor MkRemote(RemotePort: REMOTE_PORT) :> REMOTE =
    struct
	exception Protocol = RemotePort.Protocol

	(*--------------------------------------------------------------
	 * Proxies and RPC
	 *)

	datatype 'a result = RETURN of 'a | RAISE of exn

	fun proxyCallback (url, x) =
	    let
		val packedValue =
		    RemotePort.call url (UnsafeRemote.packValue x)
	    in
		case UnsafeRemote.unpackValue packedValue of
		    RETURN y => y
		  | RAISE e => raise e
	    end

	val _ = UnsafeRemote.setCallback proxyCallback

	__primitive val dynamicCall : HttpRemotePort.ticket * 'a -> 'b =
	    "Remote.dynamicCall"

	fun proxy f =
	    let
		fun f' x =
		    UnsafeRemote.packValue
			(RETURN (f (UnsafeRemote.unpackValue x))
			 handle e => RAISE e)
		val url = RemotePort.exportFn f'
	    in
		fn x => dynamicCall (url, x)
	    end

	(*--------------------------------------------------------------
	 * Take and Offer
	 *)

	type ticket = string

	exception Ticket = RemotePort.Ticket

	fun offer value =
	    (* make the snapshot here: can raise Sited exception *)
	    Url.toString (RemotePort.export (UnsafeRemote.packValue value))

	fun take ticket =
	    let
		val packedValue = RemotePort.download (Url.fromString ticket)
	    in
		UnsafeRemote.unpackValue packedValue
	    end

	functor Offer(signature S structure X: S) =
	    let
		structure P = Package.Pack(signature S = S structure X = X)
	    in
		(val ticket = offer P.package)
	    end

	functor Take(val ticket: string signature S) =
	    Package.Unpack(val package = take ticket
			   signature S = S)

	(*--------------------------------------------------------------
	 * Remote Execution
	 *)

	functor Execute(val host: string
			signature RESULT
			functor Start(ComponentManager:
				      COMPONENT_MANAGER): RESULT) =
	    let
		val p = Promise.promise ()
		structure T =
		    Offer(signature S =
			      (signature RESULT
			       functor Start(ComponentManager:
					     COMPONENT_MANAGER): RESULT
			       val return: Package.t -> unit)
			  structure X =
			      (signature RESULT = RESULT
			       structure Start = Start
			       val return =
				   proxy (fn package =>
					     Promise.fulfill (p, package))))
		val _ = (*--**DEBUG*)
		    TextIO.print ("ssh " ^ host ^ " alicerun " ^
				  "x-alice:/lib/distribution/RemoteServer " ^
				  T.ticket ^ "\n")
		val _ =
		    Unix.execute ("ssh",
				  [host, "alicerun",
				   "x-alice:/lib/distribution/RemoteServer",
				   T.ticket])
	    in
		Package.Unpack(val package = Promise.future p
			       signature S = RESULT)
	    end
    end

structure Remote = MkRemote(HttpRemotePort)
