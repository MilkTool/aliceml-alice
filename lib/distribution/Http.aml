(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Socket        from "../system/Socket"
import structure StringHashKey from "../utility/StringHashKey"
import structure MkHashImpMap  from "../utility/MkHashImpMap"
import structure Url           from "../utility/Url"
import signature HTTP          from "HTTP-sig"

structure Http :> HTTP =
    struct
	structure StringMap = MkHashImpMap(StringHashKey)

	type document = {contentType: string, body: string}
	type request =
	     {method: string, uri: Url.t, protocol: string,
	      headers: string StringMap.t, body: string}
	type response =
	     {protocol: string, statusCode: int, reasonPhrase: string,
	      headers: string StringMap.t, body: string}
	type simple_response =
	     {statusCode: int, contentType: string, body: string}

	exception Closed
	exception Format

	fun dropCRLF [#"\r", #"\n"] = nil
	  | dropCRLF (c::cr) = c::dropCRLF cr
	  | dropCRLF nil = raise Format

	fun readLine socket =
	    let
		val s = Socket.inputLine socket handle _ => raise Closed
	    in
		String.implode (dropCRLF (String.explode s))
	    end

	fun splitAt (s, c) = splitAt' (s, c, 0)
	and splitAt' (s, c, i) =
	    if i = String.size s then raise Format
	    else if String.sub (s, i) = c then
		(String.substring (s, 0, i),
		 String.extract (s, i + 1, NONE))
	    else splitAt' (s, c, i + 1)

	fun trim s = String.extract (s, dropSpaces (s, 0), NONE)
	and dropSpaces (s, i) =
	    if i = String.size s then i
	    else if Char.isSpace (String.sub (s, i)) then dropSpaces (s, i + 1)
	    else i

	fun readHeaders socket =
	    let
		val headers = StringMap.new ()
	    in
		readHeaders' (socket, headers);
		headers
	    end
	and readHeaders' (socket, headers) =
	    case readLine socket of
		"" => ()
	      | s =>
		    let
			val (name, value) = splitAt (s, #":")
			val name = String.map Char.toLower name
			val value = trim value
		    in
			if StringMap.member (headers, name) then raise Format
			else StringMap.insertDisjoint (headers, name, value);
			readHeaders' (socket, headers)
		    end

	fun readBody (socket, headers) =
	    case StringMap.lookup (headers, "contentLength") of
		SOME s =>
		    ((case Int.fromString s of
			  SOME n =>
			      let
				  val body = Socket.inputN (socket, n)
			      in
				  if String.size body <> n then raise Format
				  else body
			      end
			| NONE => raise Format)
		     handle Overflow => raise Format)
	      | NONE => ""

	fun readRequest socket =
	    let
		val requestLine = readLine socket
		val rl =
		    case String.tokens (fn c => c = #" ") requestLine of
			[method, requestURI, protocol] =>
			    {method, uri = requestURI, protocol}
		      | [method, requestURI] =>
			    {method, uri = requestURI, protocol = "HTTP/1.0"}
		      | _ => raise Format
		val headers = readHeaders socket
		val body = readBody (socket, headers)
	    in
		{method = #method rl,
		 uri = Url.fromString (#uri rl)
		       handle Url.Malformed => raise Format,
		 protocol = #protocol rl,
		 headers, body}
	    end

	fun parseResponseLine s =
	    let
		val (protocol, rest) = splitAt (s, #" ")
		val (statusCode, reasonPhrase) = splitAt (rest, #" ")
		val statusCode =
		    if String.size statusCode = 3 then
			case Int.fromString statusCode of
			    SOME statusCode => statusCode
			  | NONE => raise Format
		    else raise Format
	    in
		{protocol, statusCode, reasonPhrase}
	    end

	fun readResponse socket =
	    let
		val {protocol, statusCode, reasonPhrase} =
		    parseResponseLine (readLine socket)
		val headers = readHeaders socket
		val body = readBody (socket, headers)
	    in
		{protocol, statusCode, reasonPhrase, headers, body}
	    end

	fun writeRequest (socket, {method, uri, protocol, headers, body}) =
	    Socket.output
		(socket,
		 method ^ " " ^ Url.toString uri ^ " " ^ protocol ^ "\r\n" ^
		 StringMap.foldi
		     (fn (name, value, rest) =>
			 name ^ ": " ^ value ^ "\r\n" ^ rest)
		     ("\r\n" ^ body) headers)

	fun writeResponse (socket, {protocol, statusCode, reasonPhrase,
				    headers, body}) =
	    Socket.output
		(socket,
		 protocol ^ " " ^ Int.toString statusCode ^ " " ^
		 reasonPhrase ^ "\r\n" ^
		 StringMap.foldi
		     (fn (name, value, rest) =>
			 name ^ ": " ^ value ^ "\r\n" ^ rest)
		     ("\r\n" ^ body) headers)

	fun reasonPhrase statusCode =
	    case statusCode of
		100 => "Continue"
	      | 101 => "Switching Protocols"
	      | 200 => "OK"
	      | 201 => "Created"
	      | 202 => "Accepted"
	      | 203 => "Non-Authoritative Information"
	      | 204 => "No Content"
	      | 205 => "Reset Content"
	      | 206 => "Partial Content"
	      | 300 => "Multiple Choices"
	      | 301 => "Moved Permanently"
	      | 302 => "Found"
	      | 303 => "See Other"
	      | 304 => "Not Modified"
	      | 305 => "Use Proxy"
	      | 307 => "Temporary Redirect"
	      | 400 => "Bad Request"
	      | 401 => "Unauthorized"
	      | 402 => "Payment Required"
	      | 403 => "Forbidden"
	      | 404 => "Not Found"
	      | 405 => "Method Not Allowed"
	      | 406 => "Not Acceptable"
	      | 407 => "Proxy Authentication Required"
	      | 408 => "Request Timeout"
	      | 409 => "Conflict"
	      | 410 => "Gone"
	      | 411 => "Length Required"
	      | 412 => "Precondition Failed"
	      | 413 => "Request Entity Too Large"
	      | 414 => "Request-URI Too Long"
	      | 415 => "Unsupported Media Type"
	      | 416 => "Requested Range Not Satisfiable"
	      | 417 => "Expectation Failed"
	      | 500 => "Internal Server Error"
	      | 501 => "Not Implemented"
	      | 502 => "Bad Gateway"
	      | 503 => "Service Unavailable"
	      | 504 => "Gateway Timeout"
	      | 505 => "HTTP Version Not Supported"
	      | _ => "Unknown"

	fun makeResponse {statusCode, contentType, body} =
	    let
		val headers = StringMap.new ()
	    in
		StringMap.insert (headers, "Content-Type", contentType);
		StringMap.insert (headers, "Content-Length",
				  Int.toString (String.size body));
		(*--** Date, Server *)
		{protocol = "HTTP/1.1", statusCode,
		 reasonPhrase = reasonPhrase statusCode, headers, body}
	    end
    end
