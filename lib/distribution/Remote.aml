(*
 * Authors:
 *   Thorsten Brunklaus <brunklaus@ps.uni-sb.de>
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Thorsten Brunklaus and Leif Kornstaedt, 2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import signature COMPONENT_MANAGER
			      from "x-alice:/lib/system/COMPONENT_MANAGER-sig"
import structure Unix         from "x-alice:/lib/system/Unix"

import signature REMOTE       from "REMOTE-sig"
import structure UnsafeRemote from "UnsafeRemote"

structure Remote :> REMOTE =
    struct
	exception Ticket = UnsafeRemote.Ticket

	type ticket = string

	fun proxy f = UnsafeRemote.proxy (fn x => f x)
	val offer = UnsafeRemote.offer
	val take = UnsafeRemote.take

	functor Offer(signature S structure X: S) =
	    (val ticket =
		 let
		     structure P =
			 Package.Pack(signature S = S structure X = X)
		 in
		     offer P.package
		 end)

	functor Take(val ticket: string signature S) =
	    Package.Unpack(val package = take ticket
			   signature S = S)

	functor Execute(val host: string
			signature RESULT
			functor Start(ComponentManager:
				      COMPONENT_MANAGER): RESULT) =
	    let
		val p = Promise.promise ()
		structure T =
		    Offer(signature S =
			      (signature RESULT
			       functor Start(ComponentManager:
					     COMPONENT_MANAGER): RESULT
			       val return: Package.t -> unit)
			  structure X =
			      (signature RESULT = RESULT
			       structure Start = Start
			       val return =
				   proxy (fn package =>
					     Promise.fulfill (p, package))))
		val _ =   (*--**DEBUG*)
		    TextIO.print ("ssh " ^ host ^ " alicerun " ^
				  "x-alice:/lib/distribution/RemoteServer " ^
				  T.ticket ^ "\n")
		val proc =
		    Unix.execute ("ssh",
				  [host, "alicerun",
				   "x-alice:/lib/distribution/RemoteServer",
				   T.ticket])
	    in
		Package.Unpack(val package = Promise.future p
			       signature S = RESULT)
	    end
    end
