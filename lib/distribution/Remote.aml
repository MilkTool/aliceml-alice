(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2001-2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import signature COMPONENT_MANAGER
    from "x-alice:/lib/system/COMPONENT_MANAGER-sig"
import structure Unix              from "x-alice:/lib/system/Unix"
import structure Url               from "x-alice:/lib/utility/Url"
import structure Http              from "Http"
import structure HttpServer        from "HttpServer"
import structure HttpClient        from "HttpClient"
import signature REMOTE            from "REMOTE-sig"
import structure UnsafeRemote      from "UnsafeRemote"

structure Remote :> REMOTE =
    struct
	val pickleContentType = "application/x-alice-pickle"

	local
	    val host = UnsafeRemote.getLocalIP ()
	    val port = HttpServer.start NONE
	in
	    val rootUrl =
		Url.fromString ("http://" ^ host ^ ":" ^
				Int.toString port ^ "/")
	end

	fun register handler =
	    Url.resolve rootUrl (HttpServer.register handler)

	(*--------------------------------------------------------------
	 * Proxies and RPC
	 *)

	datatype 'a result = RETURN of 'a | RAISE of exn

	fun makeRpcHandler f (request: Http.request) =
	    let
		val x = UnsafeRemote.unpackValue (#body request)
		val result = RETURN (f x) handle e => RAISE e
	    in
		Http.makeResponse
		    {statusCode = 200,
		     contentType = pickleContentType,
		     body = UnsafeRemote.packValue result}
	    end

	fun proxyCallback (url, x) =
	    let
		val response =
		    HttpClient.post (url, {contentType = pickleContentType,
					   body = UnsafeRemote.packValue x})
	    in
		case UnsafeRemote.unpackValue (#body response) of
		    RETURN y => y
		  | RAISE e => raise e
	    end

	val _ = UnsafeRemote.setCallback proxyCallback

	fun proxy f =
	    let
		val url = register (makeRpcHandler f)
	    in
		fn x => UnsafeRemote.dynamicCall (url, x)
	    end

	(*--------------------------------------------------------------
	 * Take and Offer
	 *)

	exception Ticket

	type ticket = string

	fun makeTakeHandler value =
	    let
		(* make the snapshot here: can raise Sited exception *)
		val packedValue = UnsafeRemote.packValue value
	    in
		fn (request: Http.request) =>
		   Http.makeResponse
		       {statusCode = 200,
			contentType = pickleContentType,
			body = packedValue}
	    end

	fun offer value =
	    Url.toString (register (makeTakeHandler value))

	fun take ticket =
	    let
		val response =
		    HttpClient.get (Url.fromString ticket)
		    handle HttpClient.Authority => raise Ticket
	    in
		UnsafeRemote.unpackValue (#body response)
	    end

	functor Offer(signature S structure X: S) =
	    let
		structure P = Package.Pack(signature S = S structure X = X)
	    in
		(val ticket = offer P.package)
	    end

	functor Take(val ticket: string signature S) =
	    Package.Unpack(val package = take ticket
			   signature S = S)


	(*--------------------------------------------------------------
	 * Remote Execution
	 *)

(*
	functor Execute(val host: string
			signature RESULT
			functor Start(ComponentManager:
				      COMPONENT_MANAGER): RESULT) =
	    let
		val p = Promise.promise ()
		structure T =
		    Offer(signature S =
			      (signature RESULT
			       functor Start(ComponentManager:
					     COMPONENT_MANAGER): RESULT
			       val return: Package.t -> unit)
			  structure X =
			      (signature RESULT = RESULT
			       structure Start = Start
			       val return =
				   proxy (fn package =>
					     Promise.fulfill (p, package))))
	    in
		(*--**DEBUG*)
		TextIO.print ("ssh " ^ host ^ " alicerun " ^
			      "x-alice:/lib/distribution/RemoteServer " ^
			      T.ticket ^ "\n");
		Unix.execute ("ssh",
			      [host, "alicerun",
			       "x-alice:/lib/distribution/RemoteServer",
			       T.ticket]);
		Package.Unpack(val package = Promise.future p
			       signature S = RESULT)
	    end
*)
    end
