(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure TextIO        from "../system/TextIO"
import structure Socket        from "../system/Socket"
import structure FromEqHashKey from "../utility/HASH_KEY-sig"
import structure MkHashImpMap  from "../utility/MkHashImpMap"
import structure Url           from "../utility/Url"
import structure UnsafeRemote  from "UnsafeRemote"
import structure Http          from "Http"
import signature HTTP_SERVER   from "HTTP_SERVER-sig"

structure HttpServer :> HTTP_SERVER =
    struct
	type handler = Http.request -> Http.response

	val rootURI: Url.t option ref = ref NONE

	fun notFoundHandler (request: Http.request) =
	    Http.makeResponse
		{statusCode = 404,
		 contentType = "text/html",
		 body =
		 "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\"\n\
		 \<HTML><HEAD>\n\
		 \<TITLE>404 Not Found</TITLE>\n\
		 \</HEAD><BODY>\n\
		 \<H1>Not Found</H1>\n\
		 \The requested URL " ^ Url.toString (#uri request) ^
		 " was not found on this server.<P>\n\
		 \<HR>\n\
		 \<ADDRESS>Stockhausen HTTP Server" ^
		 (case !rootURI of
		      SOME uri => " at " ^ Url.toString uri
		    | NONE => "") ^ "</ADDRESS>\n\
		 \</BODY></HTML>\n"}

	structure UrlMap = MkHashImpMap(FromEqHashKey(Url))

	val handlerMap: handler UrlMap.t = UrlMap.new ()

	fun findHandler uri = findHandler' (List.rev (Url.getPath uri))
	and findHandler' ss =
	    let
		val uri = Url.setPath (Url.empty, List.rev ss)
	    in
		case UrlMap.lookup (handlerMap, uri) of
		    SOME handler => handler
		  | NONE =>
			case ss of
			    _::sr => findHandler' sr
			  | nil => notFoundHandler
	    end

	fun handleConnection (socket, host, port) =
	    let
		(*--** more sophisticated logging *)
		val _ = TextIO.print ("connection from " ^ host ^ ":" ^
				      Int.toString port ^ "\n")
		val request = Http.readRequest socket
		val handler = findHandler (#uri request)
		val response = handler request
		    handle _ =>
			   Http.makeResponse
			       {statusCode = 501, contentType = "text/plain",
				body = "Internal server error"}
	    in
		Http.writeResponse (socket, response);
		Socket.close socket
	    end
	    handle Http.Format =>
		(TextIO.print "format error\n";
		 Socket.close socket)

	fun start portOpt =
	    case !rootURI of
		SOME uri => uri
	      | NONE =>
		    let
			fun server (socket, host, port) =
			    handleConnection (socket, host, port)
			    handle Http.Closed => ()
			val (_, serverPort) = Socket.server (portOpt, server)
			val serverHost = UnsafeRemote.getLocalIP ()
			val url =
			    Url.fromString ("http://" ^ serverHost ^ ":" ^
					    Int.toString serverPort ^ "/")
		    in
			rootURI := SOME url; url
		    end

	fun getRootURI () = start NONE

	fun registerFor (uri, handler) =
	    let
		val uri' = Url.setPath (Url.empty, Url.getPath uri)
	    in
		UrlMap.insert (handlerMap, uri', handler)
	    end

	val counter = ref 0

	fun register handler =
	    let
		val p = Promise.promise ()
		val n = Ref.exchange (counter, Promise.future p)
		val uri = Url.setPath (Url.empty, ["export", Int.toString n])
	    in
		Promise.fulfill (p, n + 1);
		registerFor (uri, handler);
		uri
	    end
    end
