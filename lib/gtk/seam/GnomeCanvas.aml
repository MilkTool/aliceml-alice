(*
 * Authors:
 *   Robert Grabowski <grabow@ps.uni-sb.de>
 *
 * Copyright:
 *   Robert Grabowski, 2003
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Core from "Core"
import structure GnomeCanvasEnums from "GnomeCanvasEnums"
import structure GnomeCanvasUnsafe from "GnomeCanvasUnsafe"
import signature GNOME_CANVAS from "GNOME_CANVAS-sig"

structure GnomeCanvas :> GNOME_CANVAS =
struct
    (* Gdk/Gtk Lowlevel must be initialized first *)
    val _ = Future.await Core.signalConnect
    open Core
    open GnomeCanvasEnums 
    open GnomeCanvasUnsafe

    (* Create a GnomeCanvasItem *)
    fun itemCreate (root, ty, arglist) =
    let
	fun flatten nil = nil
	  | flatten ((a,b)::args) = [Core.STRING a, b]@(flatten args)
	val item = itemNew(root, ty)
	val _ = case arglist of
	            nil => ()
		  | (fst,fstarg)::args => 
			itemSetValist(item, fst, (fstarg::flatten(args)))
    in
	item
    end

    (* Get a GnomeCanvasPoints* array from a coordinate list *)
    fun makePoints plist =
    let
	val plist' = if (length plist) mod 2 = 0 then plist else plist@[0]
	val points = pointsNew((length plist') div 2)
	val _ = foldl (fn (x,i) => 
		         ( pointsSetCoords(points,i,x) ; i+1 ) )
		      0 plist'
    in
	points
    end

end
