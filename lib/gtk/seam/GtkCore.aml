import structure NativeGtkCore from "NativeGtkCore"
import structure GtkTypes from "GtkTypes"
import signature GTK_CORE from "GTK_CORE-sig"

structure GtkCore :> GTK_CORE =
struct
    val NULL = NativeGtkCore.null()
    val TRUE = NativeGtkCore.gtkTrue()
    val FALSE = NativeGtkCore.gtkFalse()

    type object = GtkTypes.object
    type arg = GtkTypes.arg
    type callBackFunction = object * arg list -> unit

    type refInfo = (object -> object) * (object -> unit)
    val GtkWidgetRef = (NativeGtkCore.widgetRef, NativeGtkCore.widgetUnref)
    val GtkObjectRef = (NativeGtkCore.objectRef, NativeGtkCore.objectUnref)
    val GObjectRef = (NativeGtkCore.gObjectRef, NativeGtkCore.gObjectUnref)
    val DeleteRef = (fn p => p, NativeGtkCore.deleteUnref)
    val NoRef = (fn p => p, fn _ => ())

    val printObject = NativeGtkCore.printObject

    (* signal table functions *)
    fun doSignalConnect (obj,signame,callback,after) =
	let
	    val connid = NativeGtkCore.signalConnect (obj,signame,after)
	    val _      = NativeGtkCore.signalMapAdd(connid,callback)
	    val (_,_,ids) = NativeGtkCore.weakMapCondGet
		                (obj, (NULL,fn _ => (), ref nil))
	    val _ = (ids := (connid::(!ids)))
	in
	    connid
	end

    local
	fun checkSignalConnect _     (_,"destroy",_)        = ~1
	  | checkSignalConnect after (obj,signame,callback) =
	    doSignalConnect (obj,signame,callback,after)
    in
	val signalConnect      = checkSignalConnect false
	val signalConnectAfter = checkSignalConnect true

	fun signalDisconnect (obj, connid) =
	    ( NativeGtkCore.signalDisconnect(obj,connid) ;
	      NativeGtkCore.signalMapRemove connid )
    end

    (* event stream listener *)
    local
	fun runCallback(connid, obj, args) =
	    NativeGtkCore.signalMapCondGet(connid, fn _ => ()) (obj,args)
    in
	fun listener nil                         = ()
	  | listener ((connid,obj,args)::stream) =
	    ( runCallback (connid, obj, args) ; listener stream )
    end

    (* finalization handling *)
    local
	fun addDestroyEvent (obj as (p,_,_)) =
	    let
                (* - Gtk ruft "destroy", damit Anwendung alle (Gtk-)Referenzen
		     auf Objekt loswird
                   - durch die Konstruktion der event-Funktion besteht bis
		     zum "destroy" eine (Alice-)Referenz auf das Objekt
		   - die event-Funktion entfernt alle bisher registrierten
		     Signale des Objekts aus der Tabelle und damit alle
		     Alice-Referenzen, die sie kennt 
		     (disconnecten macht Gtk selbst)
		   - sind alle Alice-Referenzen weg, entfernt der finalizer
		     auch die Gtk-Referenz
		   - die Gtk-Hauptschleife entdeckt irgendwann, dass es keine
		     Gtk-Referenz mehr gibt, und entfernt das Objekt komplett*)
		fun event _ =
		    let val x = ref obj
		    in	List.app NativeGtkCore.signalMapRemove (!(#3(!x)))
		    end
	    in
		( doSignalConnect(p,"destroy",event,true) ; () )
	    end

	fun newObject (p,refInfo,hasSignals) =
	    let
		val p'  = #1(refInfo) p
		val obj = (p', #2(refInfo), ref nil)
	    in
		( if hasSignals then addDestroyEvent (obj) else () ;
  	          NativeGtkCore.weakMapAdd (p',obj) ;
		  p' )
	    end 
    in
	fun addObject (p,refInfo,hasSignals) =
	    if p = NULL orelse NativeGtkCore.weakMapIsMember p 
		 then p
	         else newObject (p,refInfo,hasSignals)
	fun finalizer nil                        = ()
	  | finalizer ((obj as (p,unref,_))::xs) = ( unref p ; finalizer xs )
    end

    (* main loop *)
    local
	fun sleep ms = Future.await(Future.alarm(Time.fromMilliseconds ms))
    in
	val initPoll = 10
	val maxPoll = 50
	val pollStep = 5

	fun mainLoop sTime =
	let
	    val haveEvents = NativeGtkCore.eventsPending()
	    val sTimeNew = 
		if haveEvents then initPoll
		    else sTime + (if sTime >= maxPoll then 0 else pollStep)
	in
	    (if haveEvents then NativeGtkCore.mainIteration() else () ;
		 sleep sTime;  
		 mainLoop sTimeNew)
	end
    end

    (* Init Core Module *)
    fun init () = if NativeGtkCore.isLoaded() then () else
	let
	    val eventStream : (int * object * arg list) list = 
	                                     NativeGtkCore.getEventStream()
	    val finalStream : (object * (object->unit) * int list ref) list =
		                             NativeGtkCore.getFinalStream()
	in
	    NativeGtkCore.init ();
	    spawn (listener eventStream);
	    spawn (finalizer finalStream);
	    spawn (mainLoop initPoll)
	end
end
