import structure NativeGtkCore from "NativeGtkCore"
import structure GtkTypes from "GtkTypes"
import signature GTK_CORE from "GTK_CORE-sig"

structure GtkCore :> GTK_CORE =
struct
    val NULL = NativeGtkCore.null()
    val TRUE = NativeGtkCore.gtkTrue()
    val FALSE = NativeGtkCore.gtkFalse()

    type object = GtkTypes.object
    exception TypeMismatch = GtkTypes.TypeMismatch
    type arg = GtkTypes.arg
    type callBackFunction = object * arg list -> unit

    type refInfo = (object -> object) * (object -> unit)
    val GtkWidgetRef = (NativeGtkCore.widgetRef, NativeGtkCore.widgetUnref)
    val GtkObjectRef = (NativeGtkCore.objectRef, NativeGtkCore.objectUnref)
    val GObjectRef = (NativeGtkCore.gObjectRef, NativeGtkCore.gObjectUnref)
    val DeleteRef = (fn p => p, NativeGtkCore.deleteUnref)
    val NoRef = (fn p => p, fn _ => ())

    (* weak map *)
    local
	val weakMap = 
	    ref nil : ( object * (object->unit) * int list ref ) list ref

        fun weakMapRemove p = List.filter (fn (p',_,_) => p<>p') (!weakMap)
    in
	fun weakMapAdd (_,obj) = ( weakMap := (obj::(!weakMap)) )
	fun weakMapContains p = List.exists (fn (p',_,_) => p=p') (!weakMap)
	fun weakMapGet p def = 
	    foldl (fn (obj,e)=>if p = (#1obj) then obj else e) def (!weakMap)

	fun finalizer nil                        = ()
	  | finalizer ((obj as (p,unref,_))::xs) = 
	        (weakMapRemove p ; unref p ; finalizer xs)
    end
    
    (* signal table *)
    local
	val sigTable = ref nil : (int * callBackFunction) list ref
    in
	fun addToSignalTable (connid,callback) =
	    (sigTable := ((connid,callback)::(!sigTable)))

	fun removeFromSignalTable connid =
	    sigTable := List.filter (fn (cid,_) => connid<>cid) (!sigTable)

	fun runCallback (connid, obj, args) =
	    List.app 
	      (fn (cid,f)=>if connid=cid then f(obj,args) else ())
	      (!sigTable)

    end

    fun doSignalConnect (obj,signame,callback,after) =
	let
	    val connid = NativeGtkCore.signalConnect (obj,signame,after)
	    val _      = addToSignalTable(connid,callback)
	    val (_,_,ids) = weakMapGet obj (NULL,fn _ => (), ref nil)
	    val _ = (ids := (connid::(!ids)))
	in
	    connid
	end

    local
	fun checkSignalConnect _     (_,"destroy",_)        = ~1
	  | checkSignalConnect after (obj,signame,callback) =
	    doSignalConnect (obj,signame,callback,after)
    in
	val signalConnect      = checkSignalConnect false
	val signalConnectAfter = checkSignalConnect true

	fun signalDisconnect (obj, connid) =
	    ( NativeGtkCore.signalDisconnect(obj,connid) ;
	      removeFromSignalTable connid )
    end

    local
	fun addDestroyEvent (obj as (p,_,_)) =
	    let
                (* - Gtk ruft "destroy", damit Anwendung alle (Gtk-)Referenzen
		     auf Objekt loswird
                   - durch die Konstruktion der event-Funktion besteht bis
		     zum "destroy" eine (Alice-)Referenz auf das Objekt
		   - die event-Funktion entfernt alle Alice-Referenzen, die
                     sie kennt
		   - sind alle Alice-Referenzen weg, entfernt der finalizer
		     auch die Gtk-Referenz
		   - die Gtk-Hauptschleife entdeckt irgendwann, dass es keine
		     Gtk-Referenz mehr gibt, und entfernt das Objekt komplett*)
		val sigid = Promise.promise()
		fun event _ =
		    case obj of (p, _, ref ids) =>
			( List.app removeFromSignalTable ids ;
			  signalDisconnect(p, Promise.future sigid) )
	    in
		Promise.fulfill(sigid, 
				doSignalConnect(p,"destroy",event,false))
	    end

	fun newObject (p,refInfo,hasSignals) =
	    let
		val obj     = (#1(refInfo) p, #2(refInfo), ref nil)
	    in
		( if hasSignals then addDestroyEvent (obj) else () ;
  	          weakMapAdd (p,obj) )
	    end 
    in
	fun addObject (p,refInfo,hasSignals) =
	    (if p = NULL orelse weakMapContains p 
		 then () 
	         else newObject (p,refInfo,hasSignals) ; 
             p)
    end


    fun listener nil                        = ()
      | listener ((connid,obj,args)::stream) =
	( runCallback (connid, obj, args) ; listener stream )


    fun sleep ms = Future.await (Future.alarm (Time.fromMilliseconds ms))

    val initPoll = 10
    val maxPoll = 50
    val pollStep = 5

    fun mainLoop sTime =
	let
	    val haveEvents = NativeGtkCore.eventsPending()
	    val sTimeNew = 
		if haveEvents then initPoll
		    else sTime + (if sTime >= maxPoll then 0 else pollStep)
	in
	    (if haveEvents then NativeGtkCore.mainIteration() else () ;
		 sleep sTime;  
		 mainLoop sTimeNew)
	end

    fun init () = 
    let
	val eventStream : (int * object * arg list) list = 
	                                     NativeGtkCore.getEventStream()
	val _ = NativeGtkCore.init ()
	val _ = spawn (listener eventStream)
	val _ = spawn (mainLoop initPoll)
    in
	()
    end
      handle _ => ()

end
