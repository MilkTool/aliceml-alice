import structure NativeGtkCore from "NativeGtkCore"
import signature GTK_CORE from "GTK_CORE-sig"

structure GtkCore :> GTK_CORE =
struct
    type object

    datatype event =
	EVENT_NOTHING
      | EVENT_DELETE
      | EVENT_DESTROY
      | EVENT_EXPOSE of 
	{window:object, send:bool, 
	 area_x:int, area_y:int, area_height:int, area_width:int,
	 region:object, count:int}
      | EVENT_MOTION_NOTIFY of
	{window:object, send:bool, time:int,
	 x:real, y:real,
	 state:int, is_hint:int,
	 device: object, x_root:real, y_root:real}
      | EVENT_BUTTON_PRESS of
	{window:object, send:bool, time:int,
	 x:real, y:real, state:int, button:int,
	 device: object, x_root:real, y_root:real}
      | EVENT_2BUTTON_PRESS of
	{window:object, send:bool, time:int,
	 x:real, y:real, state:int, button:int,
	 device: object, x_root:real, y_root:real}
      | EVENT_3BUTTON_PRESS of
	{window:object, send:bool, time:int,
	 x:real, y:real, state:int, button:int,
	 device: object, x_root:real, y_root:real}
      | EVENT_BUTTON_RELEASE of
	{window:object, send:bool, time:int,
	 x:real, y:real, state:int, button:int,
	 device: object, x_root:real, y_root:real}
      | EVENT_KEY_PRESS of
	{window:object, send:bool, time:int, state:int,
	 keyval:int, length:int, string:string, 
	 hardware_keycode:int, group:int}
      | EVENT_KEY_RELEASE of
	{window:object, send:bool, time:int, state:int,
	 keyval:int, length:int, string:string, 
	 hardware_keycode:int, group:int}
      | EVENT_ENTER_NOTIFY of
	{window:object, send:bool, subwindow:object, time:int,
	 x:real, y:real, x_root:real, y_root:real,
	 mode:int, detail:int, focus:bool, state:int}
      | EVENT_LEAVE_NOTIFY of
	{window:object, send:bool, subwindow:object, time:int,
	 x:real, y:real, x_root:real, y_root:real,
	 mode:int, detail:int, focus:bool, state:int}
      | EVENT_FOCUS_CHANGE of {window:object, send:bool, hasFocus:bool}
      | EVENT_CONFIGURE of
	{window:object, send:bool, x:int, y:int,
 	 width:int, height:int}
      | EVENT_MAP
      | EVENT_UNMAP
      | EVENT_PROPERTY_NOTIFY
      | EVENT_SELECTION_CLEAR
      | EVENT_SELECTION_REQUEST
      | EVENT_SELECTION_NOTIFY
      | EVENT_PROXIMITY_IN
      | EVENT_PROXIMITY_OUT
      | EVENT_DRAG_ENTER
      | EVENT_DRAG_LEAVE
      | EVENT_DRAG_MOTION
      | EVENT_DRAG_STATUS
      | EVENT_DROP_START
      | EVENT_DROP_FINISHED
      | EVENT_CLIENT_EVENT
      | EVENT_VISIBILITY_NOTIFY of
	{window:object, send:bool, state:int}
      | EVENT_NO_EXPOSE of {window:object, send:bool}
      | EVENT_SCROLL of
	{window:object, send:bool, time:int, x:real, y:real,
	 state:int, direction:int, device:object,
	 x_root:real, y_root:real}
      | EVENT_WINDOW_STATE
      | EVENT_SETTING
      | EVENT_UNSUPPORTED of object

    datatype arg = 
	BOOL of bool
      | INT of int
      | REAL of real
      | STRING of string
      | OBJECT of object
      | LIST of object list
      | EVENT of event

    val NULL = NativeGtkCore.null()
    val TRUE = NativeGtkCore.gtkTrue()
    val FALSE = NativeGtkCore.gtkFalse()

    type callBackFunction = object * arg list -> unit

    val printObject = NativeGtkCore.printObject
    val forceGC = NativeGtkCore.forceGC

    (* signal table functions *)
    fun doSignalConnect (obj,signame,callback,after) =
	let
	    val connid = NativeGtkCore.signalConnect (obj,signame,after)
	    val _      = NativeGtkCore.signalMapAdd (connid,callback,obj)
	in
	    connid
	end

    local
	fun checkSignalConnect _     (_,"destroy",_)        = ~1
	  | checkSignalConnect after (obj,signame,callback) =
	    doSignalConnect (obj,signame,callback,after)
    in
	val signalConnect      = checkSignalConnect false
	val signalConnectAfter = checkSignalConnect true

	fun signalDisconnect (obj, connid) =
	    ( NativeGtkCore.signalDisconnect(obj,connid) ;
	      NativeGtkCore.signalMapRemove connid )
    end

    (* event stream listener *)
    local
	fun runCallback(connid, obj, args) =
	    NativeGtkCore.signalMapCondGet(connid, fn _ => ()) (obj,args)
    in
	fun listener nil                         = ()
	  | listener ((connid,obj,args)::stream) =
	    ( runCallback (connid, obj, args) ; listener stream )
    end

    (* finalization handling *)
    local

	fun addDestroyEvent obj =
	    let
                (* - Gtk ruft "destroy", damit Anwendung alle (Gtk-)Referenzen
		     auf Objekt loswird
                   - durch die Konstruktion der event-Funktion besteht bis
		     zum "destroy" eine (Alice-)Referenz auf das Objekt
		   - die event-Funktion entfernt alle bisher registrierten
		     Signale des Objekts aus der Tabelle und damit alle
		     Alice-Referenzen, die sie kennt 
		     (disconnecten macht Gtk selbst)
		   - sind alle Alice-Referenzen weg, entfernt der finalizer
		     auch die Gtk-Referenz
		   - die Gtk-Hauptschleife entdeckt irgendwann, dass es keine
		     Gtk-Referenz mehr gibt, und entfernt das Objekt komplett*)

		fun event _ = List.app NativeGtkCore.signalMapRemove
		                       (NativeGtkCore.signalMapGetConnIds obj)
	    in
		( doSignalConnect(obj,"destroy",event,true) ; () )
	    end

	fun newObject obj =
	    ( if NativeGtkCore.hasSignals obj
		  then addDestroyEvent obj
	          else () ;
	      NativeGtkCore.weakMapAdd obj ;
	      obj )
    in
	fun addObject obj =
	    if obj = NULL then obj else
	    let
		val obj' = NativeGtkCore.weakMapCondGet(obj,NULL)
(*!		val _ = print "condget done.\n"
		val _ = TextIO.flushOut TextIO.stdOut*)
	    in
		if obj' = NULL 
		    then newObject obj 
		    else NativeGtkCore.unrefObject obj'
	    end 
    end

    (* main loop *)
    local
	fun sleep ms = Future.await(Future.alarm(Time.fromMilliseconds ms))
    in
	val initPoll = 10
	val maxPoll = 50
	val pollStep = 5

	fun mainLoop sTime =
	let
	    val haveEvents = NativeGtkCore.eventsPending()
	    val sTimeNew = 
		if haveEvents then initPoll
		    else sTime + (if sTime >= maxPoll then 0 else pollStep)
	in
	    (if haveEvents then NativeGtkCore.mainIteration() else () ;
		 sleep sTime;  
		 mainLoop sTimeNew)
	end
    end

    (* Init Core Module *)
    fun init () = if NativeGtkCore.isLoaded() then () else
	let
	    val eventStream : (int * object * arg list) list = 
	                                     NativeGtkCore.getEventStream()
	in
	    NativeGtkCore.init ();
	    spawn (listener eventStream);
	    spawn (mainLoop initPoll)
	end
end
