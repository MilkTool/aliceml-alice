import structure NativeGtk from "NativeGtk"
import structure GtkTypes from "GtkTypes"
import signature GTK_CORE from "GTK_CORE-sig"

structure GtkCore :> GTK_CORE =
struct
    val NULL = NativeGtk.null()
    val TRUE = NativeGtk.gtkTrue()
    val FALSE = NativeGtk.gtkFalse()

    type object = GtkTypes.object
    exception TypeMismatch = GtkTypes.TypeMismatch
    type arg = GtkTypes.arg
    type callBackFunction = object * arg list -> unit

    local
	val sigTable = ref nil : 
  	        (int * object * int * callBackFunction) list ref
	val lastNumber = ref 0
    in
	fun addToSignalTable (obj,callback,connectFun) =
	let
	    val connid = connectFun (!lastNumber)
	in
	    (sigTable:= ((!lastNumber,obj,connid,callback)::(!sigTable));
	     lastNumber := (!lastNumber) + 1 ;
	     connid )
	end

	fun removeFromSignalTable (obj,connid) =
	    sigTable := 
	      List.filter (fn (_,ob,cid,_) => connid<>cid orelse obj<>ob)
			  (!sigTable)

	fun findConnID (obj,callback) =
	    foldl (fn ((_,ob,connid,cb),e) => 
	     if ob=obj andalso cb=callback then connid else e) (~1) (!sigTable)

	fun runCallback (funid, obj, args) =
	    List.app 
	      (fn (funid',_,_,f)=>if funid=funid' then f(obj,args) else ())
	      (!sigTable)

    end

    (* TO-DO: connid in ids (WeakDict) eintragen          *)
    (*        bei "delete-event" callback in ds eintragen *)
    fun signalConnect (obj, signame, callback) = 
	addToSignalTable(obj,callback,
			 fn n => NativeGtk.signalConnect(obj,signame,n,false))
    fun signalConnectAfter(obj, signame, callback) =
	addToSignalTable(obj,callback,
			 fn n => NativeGtk.signalConnect(obj,signame,n,true))
    fun signalConnectDelete(obj,callback) =
	addToSignalTable(obj,callback,
			 fn n => NativeGtk.signalConnectDelete(obj,n))

    fun signalDisconnect (obj, connid) =
	( NativeGtk.signalDisconnect(obj,connid) ;
 	  removeFromSignalTable(obj,connid) )
    fun signalDisconnectByFunc (obj, callback) = 
	signalDisconnect(obj,findConnID(obj,callback))

    local
	fun isInPointerTable _ = false
	fun addToPointerTable _ = ()

	fun newObject (p,tinfo) =
	    let
		val obj     = (p, tinfo, ref nil, ref nil)
		fun event _ =
		    case obj of (p, _, ref ids, ref ds) =>
			( List.app (fn d  => d(p,nil)) ds ;
			  List.app (fn id => removeFromSignalTable(p,id)) ids ;
			  signalDisconnectByFunc(p,event) )
	    in
		(if tinfo = 0 then signalConnectDelete (p,event) else 0;
		 addToPointerTable (p,obj))
	    end 
    in
	fun addObject (p,tinfo) =
	    (if isInPointerTable p then () else newObject (p,tinfo) ; p)
    end


    fun listener nil                        = ()
      | listener ((funid,obj,args)::stream) =
	( runCallback (funid, obj, args) ; listener stream )


    fun sleep ms = Future.await (Future.alarm (Time.fromMilliseconds ms))

    val initPoll = 10
    val maxPoll = 50
    val pollStep = 5

    fun mainLoop sTime =
	let
	    val haveEvents = (NativeGtk.eventsPending() = TRUE)
	    val sTimeNew = 
		if haveEvents then initPoll
		    else sTime + (if sTime >= maxPoll then 0 else pollStep)
	in
	    (if haveEvents then NativeGtk.mainIteration() else false ;
		 sleep sTime;  
		 mainLoop sTimeNew)
	end

    fun init () = 
    let
	val eventStream : (int * object * arg list) list = 
	                                     NativeGtk.getEventStream()
	val _ = NativeGtk.init ()
	val _ = spawn (listener eventStream)
	val _ = spawn (mainLoop initPoll)
    in
	()
    end
      handle _ => ()
end
