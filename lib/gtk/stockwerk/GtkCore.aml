import structure NativeGtkCore from "NativeGtkCore"
import structure GtkTypes from "GtkTypes"
import signature GTK_CORE from "GTK_CORE-sig"

structure GtkCore :> GTK_CORE =
struct
    val NULL = NativeGtkCore.null()
    val TRUE = NativeGtkCore.gtkTrue()
    val FALSE = NativeGtkCore.gtkFalse()

    type object = GtkTypes.object
    type arg = GtkTypes.arg
    type callBackFunction = object * arg list -> unit

    val printObject = NativeGtkCore.printObject

    (* signal table functions *)
    fun doSignalConnect (obj,signame,callback,after) =
	let
	    val connid = NativeGtkCore.signalConnect (obj,signame,after)
	    val _      = NativeGtkCore.signalMapAdd(connid,callback)
	in
	    connid
	end

    local
	fun checkSignalConnect _     (_,"destroy",_)        = ~1
	  | checkSignalConnect after (obj,signame,callback) =
	    doSignalConnect (obj,signame,callback,after)
    in
	val signalConnect      = checkSignalConnect false
	val signalConnectAfter = checkSignalConnect true

	fun signalDisconnect (obj, connid) =
	    ( NativeGtkCore.signalDisconnect(obj,connid) ;
	      NativeGtkCore.signalMapRemove connid )
    end

    (* event stream listener *)
    local
	fun runCallback(connid, obj, args) =
	    NativeGtkCore.signalMapCondGet(connid, fn _ => ()) (obj,args)
    in
	fun listener nil                         = ()
	  | listener ((connid,obj,args)::stream) =
	    ( runCallback (connid, obj, args) ; listener stream )
    end

    (* finalization handling *)
    local
	fun addDestroyEvent obj =
	    let
                (* - Gtk ruft "destroy", damit Anwendung alle (Gtk-)Referenzen
		     auf Objekt loswird
                   - durch die Konstruktion der event-Funktion besteht bis
		     zum "destroy" eine (Alice-)Referenz auf das Objekt
		   - die event-Funktion entfernt alle bisher registrierten
		     Signale des Objekts aus der Tabelle und damit alle
		     Alice-Referenzen, die sie kennt 
		     (disconnecten macht Gtk selbst)
		   - sind alle Alice-Referenzen weg, entfernt der finalizer
		     auch die Gtk-Referenz
		   - die Gtk-Hauptschleife entdeckt irgendwann, dass es keine
		     Gtk-Referenz mehr gibt, und entfernt das Objekt komplett*)
		fun event _ =
		    let val x = ref obj
			val ids = nil (* NativeGtkCore.signalMapGetIds *)
		    in	(!x) ; 
			List.app NativeGtkCore.signalMapRemove ids
		    end
	    in
		( doSignalConnect(obj,"destroy",event,true) ; () )
	    end

	fun newObject obj =
	    let
		val obj' = NativeGtkCore.refObject obj
	    in
		( if NativeGtkCore.hasSignals obj'
		      then addDestroyEvent obj'
		      else () ;
  	          NativeGtkCore.weakMapAdd obj' ;
		  obj' )
	    end 
    in
	fun addObject obj =
	    if obj = NULL orelse NativeGtkCore.weakMapIsMember obj
		 then obj
	         else newObject obj
    end

    (* main loop *)
    local
	fun sleep ms = Future.await(Future.alarm(Time.fromMilliseconds ms))
    in
	val initPoll = 10
	val maxPoll = 50
	val pollStep = 5

	fun mainLoop sTime =
	let
	    val haveEvents = NativeGtkCore.eventsPending()
	    val sTimeNew = 
		if haveEvents then initPoll
		    else sTime + (if sTime >= maxPoll then 0 else pollStep)
	in
	    (if haveEvents then NativeGtkCore.mainIteration() else () ;
		 sleep sTime;  
		 mainLoop sTimeNew)
	end
    end

    (* Init Core Module *)
    fun init () = if NativeGtkCore.isLoaded() then () else
	let
	    val eventStream : (int * object * arg list) list = 
	                                     NativeGtkCore.getEventStream()
	in
	    NativeGtkCore.init ();
	    spawn (listener eventStream);
	    spawn (mainLoop initPoll)
	end
end
