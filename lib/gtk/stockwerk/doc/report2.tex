\documentclass{article}
\usepackage{german}

\setlength{\textwidth}{14cm}
\setlength{\oddsidemargin}{1cm}

\begin{document}

\title{Fopra: GTK f"ur Alice - Abschlussbericht}
\author{Robert Grabowski}
\maketitle

\tableofcontents

\part{Einleitung}

\section{Inhalt des Berichts}

In diesem Bericht werden Entwurf und Implementierung der 
GTK+-Schnittstelle f"ur Alice beschrieben. Mit GTK+ l"asst sich relativ einfach
eine grafische Benutzeroberfl"achen (GUI) in C erstellen. 
Durch die Schnittstelle soll
dies auch dem Alice-Programmierer m"oglich sein.

"Inhalt. Im Folgenden werden die Schnittstelle und GTK+ kurz vorgestellt.
Daraufhin wird der Entwurf der Schnittstelle er"ortert, wobei auch auf
allgemeine, nicht GTK-spezifische Kozepte hingewiesen wird.
Es folgt eine Beschreibung der Implementierung, bevor der Bericht mit einem
Ausblick auf weiterf"uhrende Arbeiten schlie"st.

\section{Die Schnittstelle}

Als Grundlage f"ur diese Arbeit dienen zwei bereits existierende
Schnittstellen f"ur GTK+ 1.2 von Thorsten Brunklaus:
eine Anbindung an Mozart, und eine an Alice auf der Mozart-VM.
Die hier besprochene Schnittstelle bindet GTK+ 2.x an Alice auf der SEAM-VM.
Sie ist in der Anwendung weitestgehend kompatibel mit der bereits existierenden
Alice-Anbindung. Die gr"osten Unterschiede liegen bei GTK+ selbst,
bedingt durch den Versionssprung.

Alle erw"ahnten Schnittstellen sind sowohl unter Windows als auch unter
Linux lauff"ahig. Benutzt werden die GTK+-Schnittstellen unter anderem von
den Inspector-Tools.

\section{GTK+}

GTK+ ist ein Bibliothekspaket zum komfortablen Erstellen von grafischen
Benutzeroberfl"achen. Urspr"unglich im Jahr 1996 nur zur Verwendung im
Grafikprogramm GIMP geschrieben\footnote{GTK steht f"ur ``GIMP Toolkit''}, 
bildet es
inzwischen die Grundlage sehr vieler Anwendungen, insbesondere des 
GNOME-Desktops. GTK+ ist komplett
in C geschrieben, doch bei der Entwicklung wurde von Anfang an darauf geachtet,
m"oglichst gute Voraussetzungen f"ur die Anbindung an andere
Programmiersprachen zu schaffen.

\subsection*{Konzept-"Uberblick}

Bei der Programmierung einer Oberfl"ache mit GTK+ kommen folgende Ideen
zum Tragen:

\begin{itemize}
\item Widgets.
      Ein Widget ist ein Objekt, das ein
      Element der Benutzeroberfl"ache darstellt, wie
      Fenster, Schaltfl"achen und Men"us.
      Die GUI-Programmierung besteht im Wesentlichen aus der
      Erstellung von Widgets und dem Setzen ihrer Attribute, die
      z.B. Aussehen und Verhaltensweisen beeinflussen.

\item Ereignisbehandlungsroutinen. Diese auch ``Event Handler'' oder
      ``Callbacks'' genannten Funktionen reagieren auf bestimmte Ereignisse, 
      wie z.B. Mausbewegungen oder Tastatureingaben. Man kann eigene
      Callback-Funktionen bei GTK+ registrieren.

\item Hauptschleife. Das Programm "ubergibt die Kontrolle an die
      GTK+-Hauptschleife. Diese "uberpr"uft periodisch, ob Ereignisse
      vorliegen,
      und ruft ggf. die f"ur ein Ereignis registrierten Callback-Funktionen
      auf.

\item Speicherverwaltung. Nicht mehr ben"otigte Objekte werden von
      GTK+ automatisch entfernt.

\end{itemize}

\subsection*{Aufbau}

GTK+ 2.0 besteht aus den folgenden Bibliotheken:

\begin{itemize}
\item GLib -- grundlegende Funktionen wie Klassensystem und
      Speichermanagement
\item GDK -- plattformunabh"angige Abstraktion der Grafikfunktionen
      des Betriebssystems
\item Pango -- abstrahiert Schriftartenfunktionen des Betriebssystems
\item ATK -- stellt Funktionen f"ur Eingabehilfen zur Verf"ugung
\item GTK -- enth"alt die eigentliche Sammlung von Widgets
\end{itemize}

In diesem Alice-GTK+-Binding werden nur Schnittstellen f"ur die Bibliotheken
GTK und GDK generiert, denn auf die anderen Bibliotheken muss in der Regel beim
Programmieren von GTK+-Anwendungen nicht direkt zugegriffen werden.

\subsection*{GnomeCanvas}

Dar"uberhinaus enth"alt das Binding eine Schnittstelle f"ur das
GnomeCanvas-Widget, welches eine abstrakte
Fl"ache zum Zeichnen von Texten, Bilder und primitiven
Objekten darstellt. Die GnomeCanvas-Bibliothek ist eigentlich nicht Teil
von GTK+, sondern geh"ort bereits zum Gnome-Projekt. Eine Schnittstelle ist 
dennoch erforderlich, da diverse Alice-Tools
wie der Inspector dieses Widget zentral zum Anzeigen von Informationen
nutzen.

\subsection*{GTK und GTK+}

Obwohl das Sammlung der Bibliotheken ``GTK+'' hei"st und ``GTK'' nur eine
einzelne Bibliothek ist, wird im Folgenden aus Gr"unden der Vereinfachung
und Lesbarkeit immer nur von ``GTK'' gesprochen, womit das gesamte
Paket gemeint ist.


\part{Entwurf}

\section{Alice-Schnittstellen f"ur C-Bibliotheken}

In diesem Abschnitt werden allgemeine Konzepte f"ur die Entwicklung von
Alice-Bindings er"ortert. Gleichzeitig wird erkl"art,
wie gewisse Probleme speziell in der GTK-Schnittstelle gel"ost sind.

Eine C-Bibliothek besteht im Wesentlichen eine Reihe von Funktionen.
Zus"atzlich werden komplexe Datentypen deklariert, die bei der Verwendung
mit den Funktionen sinnvoll sind. Ein Binding hat die Aufgabe, diese
Funktionen und Datentypen dem Alice-Programmierer zur Verf"ugung zu stellen.

\subsection*{Funktions-Abbildung}

Weil Bibliotheksfunktionen nicht direkt von Alice aufrufbar sind,
wird f"ur alle Funktionen ein Wrapper geschrieben, der in Alice
sichtbar ist und der den eigentlichen Funktionsaufruf t"atigt.

Ein Wrapper muss zus"atzlich ein Datenmarshalling durchf"uhren, d.h. vor
dem eigentlichen Funktionsaufruf Alice-Werte in C-Werte umwandeln und
umgekehrt. Die genaue Arbeitsweise h"angt nat"urlich davon ab, wie mit
C-Datentypen in Alice umgegangen wird.

\subsection*{Datentyp-Abbildung}

Es gibt zwei ``extreme'' M"oglichkeiten f"ur die Datentyp-Abbildung.

Eine M"oglichkeit besteht darin, alle C-Werte in Alice als Werte von abstrakten
Datentypen darzustellen. In diesem Fall muss die Schnittstelle aber Operatoren
f"ur diese abstrakten Typen zur Verf"ugung stellen, wie z.B. Zuweisungs- und
Vergleichsoperatoren f"ur C-Integers.
Zwar umschifft dieser Weg einige grunds"atzliche Probleme,
jedoch wird durch den indirekten Zugriff auf C-Werte die Programmierung
unter Alice deutlich erschwert.

Als Alternative k"onnte man versuchen, f"ur alle C-Typen ein m"oglichst
"ahnliches Alice-Pendant zu finden, was den Umgang mit der Schnittstelle
f"ur den Alice-Programmierer ungemein erleichtert. Allerdings entsteht
dadurch im Binding ein ineffizienter Overhead f"ur die st"andige
Datenkonversion, vor allem aber gibt es nicht immer
ein passendes Typ-"Aquivalent in Alice.

Das GTK-Binding geht einen Mittelweg zwischen beiden genannten M"oglichkeiten:
primitive Datentypen und Enumerationstypen werden auf "ahnliche Alice-Typen
abgebildet, w"ahrend Verbundtypen in Alice abstrakt bleiben.
Gr"unde f"ur diese Entscheidung und Implementationsdetails werden in Abschnitt
??? erkl"art.

\subsection*{Die automatische Generierung und ihre Grenzen}

Sobald man sich auf eine bestimmte Abbildung festgelegt hat, liegt es nahe,
das Binding anhand der Bibliothekssignatur (???) automatisch generieren zu
lassen. Leider enthalten reine C-Deklarationen manchmal zuwenig semantische
Informationen, um eine m"oglichst akkurate Alice-Schnittstelle generieren
zu k"onnen.\footnote{Ein Beispiel daf"ur sind Ein- und Ausgabeparameter, die
weiter unten besprochen werden.} Weil auch dies auch bei GTK der Fall
ist und eine Annotierung mit Meta-Daten nicht vorliegt, macht der Generator
an einigen Stellen bestimmte Annahmen, die zumindest f"ur die GTK-Bibliotheken
zutreffen. Ausserdem kann f"ur Einzelf"alle eine gesonderte Code-Generierung
festgelegt werden.

Zu beachten ist, dass die so generierte Alice-Schnittstelle im Wesentlichen
eine 1:1-Abbildung der C-Bibliothek ist. Alice-Programme, die die Schnittstelle
benutzen, sind also reichlich imperativ und auf Seiteneffekten beruhend.
Der Ausblick am Ende dieses Berichts erl"autert Ideen f"ur eine h"ohere,
funktionale Schicht.

Die direkte Abbildung auf unterer Ebene bringt noch ein weiteres Problem
mit sich: Wenn die Bibliothek in Alice genauso benutzt wird wie in C, 
k"onnen unter Umst"anden fundamentale Alice-Konzepte wie die Nebenl"aufigkeit
ausgehebelt werden. In diesem Fall m"ussen die entsprechenden Teile der
Schnittstelle auf jeden Fall von Hand geschrieben werden.
Bei GTK sind dies die Hauptschleife, die Ereignisbehandlung sowie die
Garbage Collection, welche im n"achsten Abschnitt erkl"art werden.

\section{Hauptschleife und Ereignisbehandlung}

\subsection{Implementierung in C}

Der Kontrollfluss eines in C geschriebenen GTK-Programms sieht normalerweise
wie folgt aus: (Bild)

\begin{enumerate}
\item Es werden sogenannte ``Callback-Funktionen'' bei GTK registriert, die
      bei bestimmten Ereignissen reagieren sollen.
\item Das Hauptprogramm "ubergibt die Kontrolle an die GTK-Hauptschleife,
      welche erst zum Ende des Programms zur"uckkehrt.
\item Die Hauptscheife "uberpr"uft regelm"a"sig, ob Ereignisse vorliegen.
\item Wenn ein Ereignis eintritt (z.B. der Benutzer eine Schaltfl"ache 
      dr"uckt), werden die f"ur dieses Ereignis registrierten
      ``Callback-Funktionen'' aufgerufen.
\end{enumerate}

Zu beachten ist dabei, dass die Ereignisse synchron abgearbeitet werden,
d.h. erst wenn die Callback-Funktion zur"uckgekehrt ist, kann die Hauptschleife
wieder neue Ereignisse abarbeiten.

Der naheliegende Ansatz, dieses Konzept unver"andert auf Alice-Programme
zu "ubertragen, muss aus zwei Gr"unden scheitern.
 
Zum einen sind Aufrufe von C-Funktionen f"ur die Alice-VM atomar. W"ahrend die
Programmkontrolle bei der Hauptschleife liegt, was fast immer der Fall ist,
ist die virtuelle Maschine blockiert. Dadurch kann sie keine weiteren
Alice-Threads mehr abarbeiten, und die Nebenl"aufigkeit ist nicht mehr
sichergestellt.

Zum anderen k"onnen Alice-Callback-Funktionen nicht bei GTK registriert werden,
geschweige denn von C aus aufgerufen werden.

\subsection{Implementierung in Alice}

Die Probleme werden wie folgt gel"ost:

\begin{itemize}
\item Teile der Hauptschleife werden nach Alice ``hochgezogen''.
\item Alice-Callbacks werden indirekt "uber ein Ereignisstrom-Modell
      aufgerufen.
\end{itemize}

Eine schematische "Ubersicht liefert Abbildung ???.

Die Hauptschleife wird aufgeteilt in einen C- und einen Alice-Teil.\footnote{
Dies ist kein ``Hack'', sondern explizit von den GTK-Entwicklern als
M"oglichkeit vorgesehen.}
In einem eigenen Alice-Thread wird dabei das Verhalten
der GTK-Hauptschleife ``simuliert'': Der Thread ruft periodisch
GTK-Funktionen auf, die "uberpr"ufen, ob Ereignisse vorliegen bzw. diese
abarbeiten. Durch diese Konstruktion kehrt der Programmfluss immer wieder
zu Alice zur"uck, wodurch die VM nicht blockiert wird.

Die Realisierung des indirekten Aufrufs der Alice-Callback-Funktion 
ist etwas komplizierter:

\begin{enumerate}
\item Soll eine Funktion f"ur ein Ereignis registriert werden,
      wird f"ur sie eine eindeutige ID generiert. 
      Bei GTK wird statt der Funktion ein in C geschriebener
      ``generischer Marshaller'' registriert, und zwar so, dass er bei jedem
      Aufruf die ID als Argument erh"alt.
\item Wird das Ereignis ausgel"ost, ruft GTK den Marshaller mit der ID auf.
      Dieser schreibt die ID auf den Ereignisstrom.
\item Auf Alice-Seite wartet ein ``listener-Thread'' auf Daten vom Strom.
      Dieser Thread kann anhand einer ankommenden ID die zugeh"orige
      Alice-Callback-Funktion herausfinden und aufrufen.
\end{enumerate}

Durch den Strom werden die Ereignisse nacheinander in der richtigen
Reihenfolge abgearbeitet. Es gibt jedoch einen wichtigen Unterschied
zur Ereignisbehandlung bei einem C-Programm: Die Ereignisse werden asynchron
abgearbeitet, d.h. die Hauptschleife kann bereits ein Ereignis bearbeiten,
w"ahrend ein anderes noch in einer Alice-Callback-Funktion abgearbeitet wird.
(Grund??? Probleme???)

\section{Garbage-Collection}

GTK+ besitzt eine eigene interne Speicherverwaltung, die daf"ur sorgt,
das GTK-Objekte entfernt werden, sobald sie nicht mehr ben"otigt werden.
Dies wird "uber einen Z"ahler realisiert, der festh"alt, wieviele
Referenzen auf das Objekt bestehen. Sobald der Z"ahler auf 0 sinkt,
entfernt GTK das Objekt aus dem Speicher.

Das Problem dabei ist, das der Z"ahler zun"achst nur bibliotheksintern
verwaltet wird. Nachdem eine GTK-Funktion eine Referenz
auf ein Objekt geliefert hat und diese Referenz in Alice sichtbar ist,
kann es passieren, dass GTK das Objekt intern nicht mehr ben"otigt und
daher entfernt, weil die Bibliothek keine Kenntnis von der Alice-Referenz
besitzt. Wird die Alice-Referenz dann weiterhin benutzt, kann das fatale
Folgen haben.

Daher erh"oht die Schnittstelle selbst den Referenzz"ahler automatisch:

\begin{itemize}
\item Sobald eine GTK-Funktion eine Objekt-Referenz liefert und es noch keine
      Referenz von Alice auf das Objekt gibt, wird der GTK-Referenzz"ahler
      um eins erh"oht.
\item Sobald unter Alice letzte Referenz auf das Objekt verschwindet, wird
      dessen Z"ahler wieder um eins verringert (Fussnote: ueber AliceFinalis)
\end{itemize}

Solange eine Referenz auf ein Objekt in Alice also sichtbar ist, muss der
GTK-Referenzz"ahler mindestens 1 sein, was GTK am Entfernen des Objekts
hindert.


\part{Implementierung}

\section{Allgemeiner Aufbau der Schnittstelle}

Abbildung ??? zeigt den allgemeinen Aufbau der GTK-Schnittstelle.
Sowohl die generierte Schnittstelle als auch der handgeschriebenen ``Kern''
besitzen einen in C implementierten Teil, der die eigentliche Kommunikation
mit der Bibliothek abwickelt, als auch eine in Alice implementierte
Schicht, die von der unteren Ebene abstrahiert und u.a. eine h"ohere
Typsicherheit bietet. F"ur den Zugriff der Alice-Schicht auf die C-Ebene
und umgekehrt sorgt das Foreign Function Interface (FFI) von Alice.

\section{Generator}

Die Generierung l"auft in mehreren Phasen ab.

(Aufbau wie auf Folien; Phasen)

\section{Abbildung der Datentypen}

F"ur welche konkreten Elemente kann das Binding "uberhaupt eine Schnittstelle
liefern? Neben den primitiven Datentypen von C sind dies die in der Bibliothek
deklarierten Funktionen, Enumerationstypen, Verbundtypen, Typ-Aliasnamen
und externen Variablen.

\paragraph{Primitive Datentypen}

Primitive C-Datentypen werden in der Regel auf m"oglichst
"ahnliche primitive Alice-Typen abgebildet. Einen "Uberblick gibt Tabelle ???.
(Fussnote: object list)

Dabei sind die folgenden Dinge zu beachten:

object ist ein abstrakter Datentyp, der einen C-Zeiger repr"asentiert.
Es ist ohne die GTK-Bibliothek nicht m"oglich, ein Wert vom Typ object zu
konstruieren oder zu dereferenzieren, lediglich ein Vergleich ist m"oglich.
Mehr ist auch nicht n"otig, denn f"ur Zeiger auf Verbundtypen gibt es
Zugriffsfunktionen, und Zeiger auf andere Werte werden als Ausgabeparameter
betrachtet (siehe unten).

Bei Strings, Arrays und Listen kann sich in C der Zustand/Inhalt "andern,
ohne dass diese "Anderungen auf Alice-Seite reflektiert werden. Anhand der
Konzeption von GTK kann jedoch davon ausgegangen werden, dass diese Typen
nur als ``Container'' f"ur den Datentransport benutzt werden, und etwaige
"Anderungen durch eine GTK-Funktion in einem neuen ``Container'' zur"uckkommen.

\paragraph{Enumerationstypen}

Enumerationstypen werden auf Alice-Datatypes mit nullstelligen
Konstruktoren abgebildet. Dadurch wird eine neue Typsicherheit eingef"uhrt,
die unter C nicht vorhanden war, da dort alle Enumerationskonstanten im Grunde
Integer-Werte sind. Die Konstruktor-Integer-Konversion geht aber
ein wenig auf Kosten der Geschwindigkeit. 
Eine andere M"oglichkeit w"are, auf Kosten der Typsicherheit 
die Enumerationskonstanten direkt als Integerkonstanten (Variablen) unter Alice
zur Verf"ugung zu stellen. Allerdings sind z.B. pattern matchings nur "uber
Konstruktoren, nicht aber "uber Variablen m"oglich.

\paragraph{Verbundtypen}
Bei Verbundtypen\footnote{Das sind in C ``structs'' und ``unions''.} 
liegt es nahe,
sie als Alice-Records zu repr"asentieren. Das ist aber sehr teuer, zumal in C
nur Zeiger auf Verbunde, nicht jedoch Verbunde selbst
an Funktionen "ubergeben werden k"onnen.
Daher reicht der Typ ``object'' f"ur die Benutzung von Verbunden aus.
Zudem kann und sollte der Programmierer GTK-Verbunde nie selbst
erstellen oder entfernen, sondern nur die entsprechenden Funktionen benutzen.
Die Schnittstelle muss sich also nicht um eigene Konstruktoren und Destruktoren
k"ummern. Allerdings erfordert die GTK-Programmierung bisweilen einen direkten
Zugriff auf Felder eines Verbunds zugreift. Daher werden f"ur jeden
Verbundtyp Feldzugriffsfunktionen generiert.

\paragraph{Typaliasnamen und externe Variablen}
Diese werden von
der Schnittstelle nicht behandelt. Eine Abbildung von Typaliasnamen auf
type-Deklarationen in Alice w"urde erst richtig Sinn machen, wenn man
statt des nicht n"aher spezifizierten ``object'' einen polymorphen
``$\alpha$ pointer'' benutzen w"urde. Ein Zugriff auf externe Variablen
ist bei der GTK-Programmierung in aller Regel nicht n"otig.

\section{Funktionswrapper}

F"ur jede Funktion wird ein Funktionswrapper generiert, der das
Datenmarshalling durchf"uhrt, d.h. Werte eines Alice-Typs in Werte eines
C-Typs konvertiert und umgekehrt. Der Alice-Funktionstyp folgt dabei der
C-Funktionsdeklaration; mehrere Argumente werden als Tupel "ubergeben.
Die Funktionsnamen sind nach der ``lower CAML case''-Konvention
umgewandelt.

\begin{verbatim}
void gtk_scale_set_draw_value (GtkScale*, gboolean)
val scaleSetDrawValue : object * bool -> unit
\end{verbatim}

\subsection*{Ein- und Ausgabeparameter}

Manche GTK-Funktionen nehmen Zeiger auf primitive Typen entgegen:

\begin{verbatim}
void gtk_entry_get_layout_offsets (GtkEntry*, int*, int*)
\end{verbatim}

Mittels solcher Zeiger kann die Funktion zus"atzliche Ausgabewerte
zur"uckliefern. Da in Alice mehrere R"uckgabewerte (als Tupel) m"oglich sind,
betrachtet die Schnittstelle alle Zeiger mit Ausnahme von Verbundzeigern,
Strings und Listen als Ausgabeparameter und erstellt daher den folgende
Wrapper:

\begin{verbatim}
val entryGetLayoutOffsets : object -> int * int
\end{verbatim}

M"oglicherweise greift die GTK-Funktion aber zus"atzlich noch lesend auf 
einen solchen Wert zu. Aufgrund fehlender semantischer Informationen kann
der Generator nicht wissen, ob es sich um einen kombinierten Ein- und
Ausgabe-Parameter handelt.
Daher wird f"ur eine solche Funktion ein weiterer Wrapper generiert,
der jeden Ausgabeparametern zus"atzlich als Eingabeparameter betrachtet:

\begin{verbatim}
val entryGetLayoutOffsets' : object * int * int -> int * int
\end{verbatim}

Es liegt dann am Programmierer, die richtige Variante verantwortungsbewusst
zu benutzen.

\subsection*{Funktionen mit variablen Argumentlisten}

Im Bereich der Sprachanbindungen ist dies eines der d"ustersten Kapitel,
welches hier aber trotzdem nicht verschwiegen werden soll, denn leider
macht GTK intensiv von diesem ``Feature'' Gebrauch.

Funktionen mit variablen Argumentlisten k"onnen beliebig viele Argumente
erhalten, und jedes Argument kann von einem beliebigen Typ sein.

Die "Ubergabe der Argumente von Alice an die Schnittstelle l"asst sich dabei
noch halbwegs elegant gestalten. Auf Alice-Seite wird eine Liste vom Typ
``arg list'' "ubergeben, wobei ``arg'' wie folgt definiert ist:

\begin{verbatim}
datatype arg = INT of int | BOOL of bool | STRING of string | ...
\end{verbatim}

Das eigentliche Problem besteht darin, dass zur "Ubersetzungszeit
\textit{der Schnittstelle} Anzahl und Typen der Argumente bekannt sein m"ussen.
Sie werden aber fr"uhestens zur "Ubersetzungszeit des
Alice-Programms bekannt.

Es gibt in C keine plattformunabh"angige M"oglichkeit,
variable Argumentlisten zur Laufzeit zu bauen und einer Funktion zu "ubergeben.
Die GTK-Schnittstelle l"ost das Problem momentan auf eine Art, die
auf x86-Plattformen unter Windows und Linux keine Probleme
zu bereiten scheint. Man kann die Plattformunabh"angigkeit noch ``steigern'',
indem auf Alice-Seite solche Funktionen mit h"ochstens einem Argument
aufgerufen werden.

Eine bessere L"osung w"are es, eine spezielle low-level-Bibliothek
wie ``libffi'' zu benutzen, die das plattformabh"angige dynamische "Ubergeben
von variablen Argumenten abstrahiert.

\section{Weitere Details}

(Core-Details? events: arg list; GC: object-Tupel)

%% \section{Core}

%% \subsection{Hauptschleife und Event-Handling}

%% \subsubsection{Ereignisbehandlung in C}

%% Der Kontrollfluss eines in C geschriebenen GTK-Programms sieht normalerweise
%% wie folgt aus: (Bild)

%% \begin{enumerate}
%% \item Es werden sogenannte ``Callback-Funktionen'' bei GTK registriert, die
%%       bei bestimmten Ereignissen reagieren sollen.
%% \item Das Hauptprogramm "ubergibt die Kontrolle an die GTK-Hauptschleife,
%%       welche erst zum Ende des Programms zur"uckkehrt.
%% \item Die Hauptscheife "uberpr"uft regelm"a"sig, ob Ereignisse vorliegen.
%% \item Wenn ein Ereignis eintritt (z.B. der Benutzer eine Schaltfl"ache 
%%       dr"uckt), werden die f"ur dieses Ereignis registrierten
%%       ``Callback-Funktionen'' aufgerufen.
%% \end{enumerate}

%% Zu beachten ist dabei, dass die Ereignisse synchron abgearbeitet werden,
%% d.h. erst wenn die Callback-Funktion zur"uckgekehrt ist, kann die Hauptschleife
%% wieder neue Ereignisse abarbeiten.


%% \subsubsection{Naiver Ansatz / Probleme}

%% Eine naive Umsetzung dieses Prozesses muss aus folgenden Gr"unden scheitern:

%% \begin{itemize}
%% \item Aufrufe von C-Funktionen sind f"ur die Alice-VM atomar. Die virtuelle
%%       Maschine ist daher blockiert, solange die Hauptschleife l"auft, 
%%       was fast immer der Fall ist. Dadurch kann die VM keine weiteren Alice-
%%       Threads mehr abgearbeiten, und die Nebenl"aufigkeit ist nicht mehr
%%       sichergestellt. (Fussnote: GC auch nicht)
%% \item Alice-Callback-Funktionen k"onnen nicht bei GTK registriert werden,
%%       geschweige denn von C aus aufgerufen werden.

%% \end{itemize}

%% \subsubsection{L"osung}

%% Die Probleme werden wie folgt gel"ost:

%% \begin{itemize}
%% \item Teile der Hauptschleife werden nach Alice ``hochgezogen''.
%% \item Alice-Callbacks werden indirekt "uber ein Ereignisstrom-Modell
%%       aufgerufen.
%% \end{itemize}

%% Eine schematische "Ubersicht liefert Abbildung ???.
%% Die genaue Implementierung sieht wie folgt aus:

%% Die Hauptschleife wird aufgeteilt in einen C- und einen Alice-Teil.
%% (Fussnote: kein Hack) In einem eigenen Alice-Thread wird dabei das Verhalten
%% der GTK-Hauptschleife ``simuliert'': Der Thread ruft periodisch
%% GTK-Funktionen auf, die "uberpr"ufen, ob Ereignisse vorliegen bzw. diese
%% abarbeiten. Durch diese Konstruktion kehrt der Programmfluss immer wieder
%% zu Alice zur"uck, wodurch die VM nicht blockiert wird.

%% Bei der Bindung einer Alice-Funktion f an ein Objekt o f"ur ein Ereignis e
%% laufen die folgenden Dinge ab:

%% \begin{enumerate}
%% \item Bei GTK wird ein in C geschriebener ``generischer Marshaller''
%%       f"ur Objekt o und Ereignis e registriert. (Fussnote: GTK bietet diese
%%       M"oglichkeit) GTK liefert daraufhin eine Verbindungsnummer ID zur"uck.
%% \item Die Alice-Funktion f wird in einer Hash-Tabelle eingetragen;
%%       der Schl"ussel zur Funktion ist die ID.
%% \end{enumerate}

%% Bei der Ausl"osung von Ereignis e bei Objekt o passiert folgendes:

%% \begin{enumerate}
%% \item Die Hauptschleife ruft den ``generischen Marshaller'' auf. Als Argumente
%%       bekommt dieser die ID, das Objekt o, sowie eine variable Liste von
%%       Argumenten args f"ur das Ereignis e.
%% \item Der Marshaller schreibt ID, o und args auf den Ereignisstrom.
%% \item Auf Alice-Seite wartet ein ``listener-Thread'' auf Daten vom Strom.
%%       Der Thread liest ID, o und args, und findet mit der Hash-Tabelle anhand
%%       der ID die Callback-Funktion f heraus.
%% \item Der Thread ruft f mit o und args als Argumenten auf. Sobald f beendet
%%       ist, wird wieder auf neue Daten vom Strom gewartet.
%% \end{enumerate}

%% Durch den Strom werden die Ereignisse nacheinander in der richtigen
%% Reihenfolge abgearbeitet. Es gibt jedoch einen wichtigen Unterschied
%% zur Ereignisbehandlung bei einem C-Programm: Die Ereignisse werden asynchron
%% abgearbeitet, d.h. die Hauptschleife kann bereits ein Ereignis bearbeiten,
%% w"ahrend ein anderes noch in einer Alice-Callback-Funktion abgearbeitet wird.
%% (Grund??? Probleme???)

%% \subsection{Garbage-Collection}

%% GTK+ besitzt eine eigene interne Speicherverwaltung, die daf"ur sorgt,
%% das GTK-Objekte entfernt werden, sobald sie nicht mehr ben"otigt werden.
%% Dies wird "uber einen Z"ahler realisiert, der festh"alt, wieviele
%% Referenzen auf das Objekt bestehen. Sobald der Z"ahler auf 0 sinkt,
%% entfernt GTK das Objekt aus dem Speicher.

%% Das Problem dabei ist, das der Z"ahler zun"achst nur bibliotheksintern
%% verwaltet wird. Nachdem eine GTK-Funktion eine Referenz
%% auf ein Objekt geliefert hat und diese Referenz in Alice sichtbar ist,
%% kann es passieren, dass GTK das Objekt intern nicht mehr ben"otigt und
%% daher entfernt, weil die Bibliothek keine Kenntnis von der Alice-Referenz
%% besitzt. Wird die Alice-Referenz dann weiterhin benutzt, kann das fatale
%% Folgen haben.

%% Die L"osung des Problems besteht darin, den Referenzz"ahler eines Objekts
%% solange um eins erh"oht zu halten, wie eine Referenz auf das Objekt in
%% Alice sichtbar ist:

%% \begin{itemize}
%% \item Sobald eine GTK-Funktion eine Objekt-Referenz liefert und es noch keine
%%       Referenz von Alice auf das Objekt gibt, wird der GTK-Referenzz"ahler
%%       um eins erh"oht.
%% \item Sobald unter Alice letzte Referenz auf das Objekt verschwindet, wird
%%       dessen Z"ahler wieder um eins verringert (Fussnote: ueber AliceFinalis)
%% \end{itemize}

%% Solange eine Referenz auf ein Objekt in Alice also besteht, muss der
%% GTK-Referenzz"ahler mindestens 1 sein, was GTK am Entfernen des Objekts
%% hindert.

%% \subsection{Weitere Funktionen}

%% (init, NULL, TRUE, FALSE ?)

\part{Ausblick}

Weiterf"uhrende Arbeiten k"onnten sowohl ``in die Tiefe'' gehen und die
GTK-Schnittstelle ausbauen, als auch ``in die Breite'' und die automatische
Generierung verallgemeinern.

\section{Funktionale GUI-Programmierung}

Die hier vorgestellte Schnitstelle bietet eine Anbindung auf niedriger Ebene.
Durch die 1:1-Abbildung sieht die GTK-Programmierung unter Alice "ahnlich
aus wie unter C. Diese unter Alice unelegante Programmierweise kann
nur mit einer eine funktionale, abstrahierende Schicht "uber der
eigentlichen GTK-Schnittstelle umgangen werden.

Einen Anfang daf"ur bildet die GtkBuilder-Struktur von Thorsten Brunklaus.
Das Layout ganzer Fensterinhalte kann als Wert mittels Konstruktoren
repr"asentiert werden. Darauf hingen"ugt der Aufruf einer einzigen Funktion,
welche diesen Wert anschlie"send in eine Reihe von GTK-Befehlen "ubersetzt.

W"unschenswert w"are es, spezielle Features der Programmiersprache Alice
gleich zu nutzen. So k"onnten z.B. "ahnliche Mitteilungsfenster
in einem Funktor zusammengefasst werden, und dieser k"onnte wiederum als
Package im Netz zur allgemeinen Verf"ugung stehen. In jedem Fall ist eine
solche funktionale UI-Schnittstelle nicht mehr automatisch generierbar.

\section{Allgemeines Genererierungstool}

Auch wenn der Generator in der jetzigen Form bereits m"oglichst unabh"angig
von GTK arbeitet, macht er dennoch einige GTK-spezifische Annahmen, die
eine Anwendung f"ur andere Bibliotheken erschweren.

Daher w"are es n"utzlich, diese Annahmen zu parametrisieren, um einen
allgemeinen Generator zu erhalten, der f"ur beliebige C-Bibliotheken
eine Anbindung an Alice generieren kann. (Sven???)

\section*{Quellenangaben}

www.gtk.org

\end{document}
