
*** Allgemein/Ideen ***

* stockwerk-gtk-binding in den CVS main trunk
- stockhausen neu bauen -> Problem!!
- datatype arg auch in GtkUnsafe verfuegbar machen
- Makefile hat noch ein Problem (Aenderungen an .cc fuehren nicht zum Rebuild)


* Enums
- GC (Weak Dictionary)
* datatypes/Signals bauen
* Dateien komplett umbenennen, 
* libgnomecanvas statt GtkCanvas installieren
- Windows

* Test-Programm besser
* Makefile besser: Gtk.aml haengt von GtkCore.aml ab usw.

* Problem: beim Benutzen der UnsafeGtk-Komponente gibt es einen segfault
* casting-Mist in UnsafeGtk.cc ueberpruefen
* #include liefert unterminated string constant Fehler (wegen ')
* sind alle Out-Parameter reine Out-Parameter? ist es nicht sicherer,
  alle outs als ins UND outs zu deklarieren (dafuer mehr Arbeit beim User)
  -> zwei Varianten der Funktion: eine mit out-only, eine mit in-out

- get/set-Methoden fuer GdkEvent-Structs, wie Typsicherheit herstellen?
- Classes -> haben bereits set/get-Methoden
- bestimmte Structs (z.B. GdkPoint) bekommen welche

* GtkTrue und gtkFalse liefern int's (fuer bools true und false benutzen)

Ideen fuer GtkTreeTypes:

CLASSES... enthaelt *alle* Klassen
  nur fuer STRUCTUREs, die auch in CLASSES sind, gibt es get/set-Funktionen 



*** Projekt ***

* Bericht (2,3 Seiten) bis Freitag
* alles ordentlich bei CVS commiten
* CUA-mode
* website anpassen
* gtk 2.0 holen und lokal installieren
* genauen plan machen, welche funktionen uebersetzt werden sollen

X GTKCanvas? -> geht nicht, braucht GTK 1.2
X ckit fuer alice



*** Generator ***

* GDK-Zeugs testen; Exception- und Type-Sharing
* Problem: Alice kann Enums ab 2^30 nicht akzeptieren (nur bis 2^30-1)
* gdk_pixbuf_new_from_xpm....
* gtkclean.c mit -DGTK_DEPRECATED erzeugen?
* besseren include- und user-defined-Mechanismus ausdenken
* Parser/TypeManager aufraeumen
* MkUnsafe.sml/MkSafe.sml besser strukturieren
* gchar* wird nicht als STRING erkannt
* leere inarglist moeglich
* bool als BOOL erkennen
* vorhandene Darstellung nutzen
* isValueArg? was genau sind Werteparameter?
* CLASS -> Baum generieren
* POINTER(TYPEREF(POINTER(STRUCTREF))) ist auch ein valuearg!
* bitfield size declared -> muss uns das aergern?
* gtkraw.c erstellen
* MkIntermediate in Vorhandes integrieren
* dabei alle Datentypen und ty-Operationen von parse separieren
* Idee: ty-Operationen kommen in den TypeManager
* native interface generieren und uebersetzen



*** UnsafeGtk ***

* GList/GSList immer als object list, ausser wenn in MkSpecial anders definiert
* Event-Dispatcher: Stream bauen, registrierte callback-Funktion aufrufen
* Stream: Marshaller wandelt GValues in eigenen Alice-Datentyp um und
    schreibt dies auf den Stream
    (stream = Liste mit Future als letztes Element)
    Callback-Funktion muss selbst die Argumentwerte wieder rausmoebeln
X Marshaller-Rueckgabewert?

* UnsafeGtk als DLL

- was tun mit valists?
* object-Typueberpruefung: in UnsafeGtk.cc! ueber GType-Funktionen
    bei Fehlschlag: exception liefern

* Listen: GList immer als 'object list
    deklarieren: mit DECLARE_LIST_ELEMS und glist_append
    zurueckgeben: eigene Funktion basteln
* Listen: nicht immer nur als object list behandeln? -> doch
* Funktion bauen, die NULL-Pointer zurueckliefert
* Arrays testen
* Problem beim Uebersetzen mit CSTRING-Arrays

Fehler die beim Uebersetzen von UnsafeGtk.cc auftraten:
* Rueckgabewert von Gtk-Funktion war const char *, wurde zugewiesen
  an char * (ret)
* "changes signedness"-Fehler
* verlangte Arrays koennen nicht als void-Pointer deklariert werden

X gtk_init: evtl. in der C-Funktion Kommandozeilenparameter uebergeben
X ...und veraenderte Parameterliste als neue gueltige hinbekommen? -> nein.

* zurueckgegebene Bools werden nicht richtig erkannt? -> nee, ist so
* was tun mit ARRAYs in arglist?
* was tun mit Listen-Typen? -> DECLARE_LIST
* was tun mit FUNCTIONS in arglist? als POINTER(FUNCTION _) oder als FUNCTION _?


*** SafeGtk ***

- GC: Weak dictionary: Zugriff auf C-dictionary wird moeglich sein
- immer, wenn eine Funktion ein object rausschmeisst (bzw. object auf stream
  geschrieben wird) nachsehen, ob object in dictionary. wenn nein:
  hinzufuegen + gtk-ref aufrufen
- finalizer thread ruft fuer ankommende objects auf eigenem Strom gtk-unref auf


* warum wird callback function erst beim zweiten Event aufgerufen?
- callback-Funktionen in Hashtable abspeichern
* sleep-Funktion ist zu provisorisch?



*** Test ***

* Mini-Interface schreiben und testen
* Mini-Interface mit Futures testen
* Beispiel-Komponente schreiben

Fehler:
- ckit2.sml in stockwerk-vm testen; ggf. in alice bugzilla eintragen
* Int.toString(2^32) haengt sich auf
- mehrfaches spawn (fib 40) stuerzt ab
- val ~1 = 1; stuerzt ab
