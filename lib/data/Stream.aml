(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(*
 *  Items marked with (**) are extensions to the Standard Basis.
 *)

import signature STREAM from "STREAM-sig"

structure Stream :> STREAM =
    struct
	type 'a stream = 'a list Promise.promise ref
	type 'a t      = 'a stream

	exception Closed

	fun stream () =
	    let
		val p = Promise.promise ()
	    in
		(ref p, Promise.future p)
	    end

	fun send (stream, x) =
	    let
		val new = Promise.promise ()
		val old = Ref.exchange (stream, new)
	    in
		Promise.fulfill (old, x::Promise.future new)
	    end handle Promise.Promise => raise Closed

	fun close stream =
	    let
		val new = Promise.promise ()
		val old = Ref.exchange (stream, new)
	    in
		Promise.fulfill (old, nil);
		Promise.fulfill (new, Promise.future old)
	    end handle Promise.Promise => ()

	fun isClosed stream =
	    let
		val xs = Promise.future (!stream)
	    in
		Future.isDetermined xs andalso List.null xs
	    end
    end
