(*
 * Authors:
 *   Gabor Szokoli <szokoli@ps.uni-sb.de>
 *   Guido Tack <tack@ps.uni-sb.de>
 *
 * Copyright:
 *   Gabor Szokoli and Guido Tack, 2004
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure FS        from "x-alice:/lib/gecode/FS"
import structure Print     from "x-alice:/lib/system/Print"

import structure GecodeTest from "GecodeTest"

type t = int -> int list -> (string * (unit -> unit) list)

structure TestSuite :
  sig
      val union : t
      val inter : t
      val subset : t
      val noSubset : t
      val superOfInter : t
      val subOfUnion : t
      val diff : t
      val disjoint : t
      val distinct : t
      val partition : t
      val equals : t
      val convexHull : t
  end
  =
  struct

	fun range2II (i1,i2) = 
	let
		val _= assert (i1 >= 0);
		val diff = i2 - i1
		val ones = IntInf.<< ((IntInf.fromInt 2),Word.fromInt diff ) - (IntInf.fromInt 1)
	in
		IntInf.<<(ones, Word.fromInt i1)
	end
	
	(*Eta forewa! :-) *)
	val vdom2II = Vector.foldl ( fn (r,a)=> IntInf.orb ((range2II r),a) ) (IntInf.fromInt 0)

	fun vBoolTern v1 (a,b,c) space =
	let
            val a = vdom2II ( FS.Reflect.lowerBound (space,a))
            val b = vdom2II ( FS.Reflect.lowerBound (space,b))
            val c = vdom2II ( FS.Reflect.lowerBound (space,c))
	in
		v1 (a,b,c)
	end
	fun vBoolBin v1 (a,b) space =
	let
            val a = vdom2II ( FS.Reflect.lowerBound (space,a))
            val b = vdom2II ( FS.Reflect.lowerBound (space,b))
	in
		v1 (a,b)
	end
	
	fun vBoolN v1 (a,x) space =
	let 
            val a = vdom2II ( FS.Reflect.lowerBound (space,a))
            val x = Vector.map (fn xi=> vdom2II ( FS.Reflect.lowerBound (space,xi))) x
    in
    	v1(a,x)
    end
                                  
        (*
         * Verifier functions
         *
         *)
	
	fun vUnion1 (a,b,c) = (IntInf.orb(b,c) = a)
	
	fun vUnionN1 (u,x) = 
		(Vector.foldl IntInf.orb (IntInf.fromInt 0) x) = u
	
	fun vInter1 (a,b,c) = (IntInf.andb(b,c) = a)

	fun vInterN1 (i,x) = 
		(Vector.foldl IntInf.andb (Vector.sub (x,0)) x) = i

	(*These two expect lists instead of vectors!*)
	fun vDisjointN2 (_, nil) = true
	| vDisjointN2 (u, h::t) =
		if (IntInf.andb (u,h) = IntInf.fromInt 0) then vDisjointN2( IntInf.orb (u,h),t)
		else false;

	fun vPartitionN2 (p,u, nil) = (p = u)
	| vPartitionN2 (p,u, h::t) =
		if (IntInf.andb (u,h) = IntInf.fromInt 0) then vPartitionN2(p, IntInf.orb(u,h), t)
		else false;


	fun vSubSet1 (a,b) =
		IntInf.andb (IntInf.xorb(a,b),a)= IntInf.fromInt 0		
		
	
	fun vNoSubSet1 (root2 as (a,b))  = 
            if not (vSubSet1 root2) then true else
            (print "root: (";
             print (IntInf.fmt StringCvt.BIN a);
             print ",";
             print (IntInf.fmt StringCvt.BIN b);
             print ")\n"; false)
		
	fun vSuperOfInt1 (a,b,c) =
		vSubSet1(IntInf.andb(b,c),a)
	fun vSubOfUni1 (a,b,c) =
		vSubSet1(a,IntInf.orb(b,c))
	
	fun vDiff1 (a,b,c) = IntInf.andb (IntInf.xorb(c,b),b) = c
	fun vDisjoint1 (a,b) = IntInf.andb(a,b) = IntInf.fromInt 0
	fun vDistinct1 (a,b) = IntInf.xorb(a,b) > IntInf.fromInt 0
	fun vPartition1 (a,b,c) = (vDisjoint1 (b,c) ) andalso (vUnion1 (a,b,c))
	
	fun vEquals1 (a,b) = a=b
	
	
	fun vConvex a space = 
	let
	    val ad = FS.Reflect.lowerBound (space,a)
	in
	    Vector.length ad = 1
	end
	
	fun vSameMinMax (a,b) space =
	let
	    val a = FS.Reflect.lowerBound (space,a)
	    val b = FS.Reflect.lowerBound (space,b)	    
	in
		Pair.fst (Vector.sub (a,0)) = Pair.fst (Vector.sub (b,0)) andalso
			Pair.snd (Vector.sub (a,(Vector.length a)-1)) = 
			Pair.snd (Vector.sub (b,(Vector.length b)-1)) 
	end
	
	fun vConvexHull (a,b) space =
            if not (vConvex a space) then
                (print "not Convex!\n";
                 Print.printVal (FS.Reflect.lowerBound (space,a));
                 print "\n";
                 false)
            else
                if not ( vBoolBin vSubSet1 (b,a) space )
                then
                (print "no subset!\n";
                 Print.printVal (FS.Reflect.lowerBound (space,a));
                 print "\n";
                 Print.printVal (FS.Reflect.lowerBound (space,b));                 
                 print "\n";
                 false)
                else if not ( vSameMinMax (a,b) space )
                	then (print "no tight hull!\n";
	                 Print.printVal (FS.Reflect.lowerBound (space,a));
	                 print "\n";
    	             Print.printVal (FS.Reflect.lowerBound (space,b));                              
    	             print "\n";
        	         false)
					else true





        (*
         * Test cases
         *
         *)

        fun union max seeds =
            GecodeTest.ternarySet ("Union",max,seeds,
                                   FS.union,
                                   vBoolTern vUnion1)
        fun inter max seeds =
            GecodeTest.ternarySet ("Intersection",max,seeds,
                                   FS.intersect,
                                   vBoolTern vInter1)

        fun subset max seeds =
            GecodeTest.binarySet ("Subset",max,seeds,
                                   FS.subset,
                                   vBoolBin vSubSet1)
        fun noSubset max seeds =
            GecodeTest.binarySet ("NoSubset",max,seeds,
                                   FS.noSubset,
                                   vBoolBin vNoSubSet1)
        fun superOfInter max seeds =
            GecodeTest.ternarySet ("SuperOfInter",max,seeds,
                                   FS.superOfInter,
                                   vBoolTern vSuperOfInt1)
        fun subOfUnion max seeds =
            GecodeTest.ternarySet ("SubOfUnion",max,seeds,
                                   FS.subOfUnion,
                                   vBoolTern vSubOfUni1)
        fun diff max seeds =
            GecodeTest.ternarySet ("Diff",max,seeds,
                                   FS.difference,
                                   vBoolTern vDiff1)
        fun disjoint max seeds =
            GecodeTest.binarySet ("Disjoint",max,seeds,
                                  FS.disjoint,
                                  vBoolBin vDisjoint1)
        fun distinct max seeds =
            GecodeTest.binarySet ("Distinct",max,seeds,
                                  FS.distinct,
                                  vBoolBin vDistinct1)
        fun partition max seeds =
            GecodeTest.ternarySet ("Partition",max,seeds,
                                   FS.partition,
                                   vBoolTern vPartition1)
        fun equals max seeds =
            GecodeTest.binarySet ("Equals",max,seeds,
                                   FS.equals,
                                   vBoolBin vEquals1)
        fun convexHull max seeds =
            GecodeTest.binarySet ("ConvexHull",max,seeds,
                                   FS.convexHull,
                                   vConvexHull)
  end
