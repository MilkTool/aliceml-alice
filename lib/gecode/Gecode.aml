(*
 * Author:
 *   Guido Tack <tack@ps.uni-sb.de>
 *
 * Copyright:
 *   Guido Tack, 2003
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import "UnsafeGecode"
import "GECODE-sig"
import "x-alice:/lib/system/UnsafeValue"

structure Gecode :> GECODE =
  struct
    type space
    type intvar
    type boolvar
    type searchengine

    datatype b_var_sel =
	     B_MAX_MAX
	   | B_MAX_MIN
	   | B_MIN_MAX
	   | B_MIN_MIN
	   | B_NONE
	   | B_SIZE_MAX
	   | B_SIZE_MIN
	   | B_WIDTH_MAX
	   | B_WIDTH_MIN

    datatype b_val_sel =
	     B_MAX
	   | B_MED
	   | B_MIN
	   | B_SPLIT_MAX
	   | B_SPLIT_MIN
	   | B_VAL

    datatype relation =
	     EQ (* Equality         == *)
	   | GQ (* Greater or equal >= *)
	   | GR (* Greater          >  *)
	   | LE (* Less             <  *)
	   | LQ (* Less or equal    <= *)
	   | NQ (* Disequality      != *)

    datatype conlevel = VAL | VAL_EX | BND | BND_EX
		      | DOM | DOM_EX | OTR | DEF

    type searchbestengine
    datatype searchbestresult =
	     SB_CONSTRAIN of space * space
	   | SB_DONE
	   | SB_SOLUTION of space

    datatype status = BRANCH | FAILED | SOLVED
    datatype avalsel = AVAL_MIN | AVAL_MED | AVAL_MAX

    open UnsafeGecode

    exception NoVal

    val boolvar2intvar = UnsafeValue.cast

    fun getVal (s,v) =
	let
	    val min = getMin(s,v)
	in
	    if min<>getMax(s,v) then raise NoVal
	    else min
	end

    fun searchAll s =
	let
	    val se = getSearchEngine s
	    fun lazy nextSol () = 
		     let
			 val n = next se
		     in
			 case n of
			     NONE => nil
			   | SOME s' => s'::nextSol()
		     end
	in
	    nextSol()
	end

    val searchOne = next o getSearchEngine

    fun searchBest (s, constrain) =
	let
	    val se = getSearchBestEngine s
	    fun nextSol () =
		case nextBest se of
		    SB_DONE => nil
		  | SB_SOLUTION s' => s'::(lazy nextSol())
		  | SB_CONSTRAIN(s1, s2) =>
		    (constrain(s1, s2);
		     nextSol())
	in
	    lazy nextSol()
	end
    fun getBool v = getVal(boolvar2intvar v)=1
  end
