import structure Debug       from "Debug"
import signature MKSPACENODE from "MKSPACENODE-sig"
import signature POLICY      from "MKSPACENODE-sig"
import structure Space       from "x-alice:/lib/gecode/Space"

structure MkSpaceNode :> MKSPACENODE = fct (Policy:POLICY) =>
struct

  open Debug

  exception Child

  type path = int list
  datatype space_node = Node of node_rep
  withtype node_rep =
    {mom    : space_node ,  (* Ancestor *)
     altNum : int ,         (* Which alternative, 0 means root node *)
     space  : Space.space option ref , (* Working space *)
     copy   : Space.space option ref ,
     status : Space.status ,
     bestId : int ,  (* ID number of the best solution known at this node. *)
     best   : Policy.sol option , (* Solution applied to this node. *)
     depth  : int }

  type t = space_node

  fun dbPrint (mask, msg) = Debug.dbPrint (mask, Policy.mask, msg)

  val undefined = lazy assert false

  val best = ref undefined
  val bestId = ref 0  (* ID Number of the current best solution *)

  val root =
    let 
      val status = Space.status Policy.root
      val spaceref = ref (SOME (Space.clone Policy.root))
      val copyref = ref (SOME Policy.root)
    in
    Node {mom    = undefined ,
          altNum = 0 ,
          space  = spaceref ,
          copy   = copyref ,
          status = status ,
          bestId = !bestId ,
          best   = NONE ,
          depth  = 0 }
    end

  fun status    (Node node) = #status node
  fun depth     (Node node) = #depth  node
  fun getBestId (Node node) = #bestId node

  (* Branch and Bound: are we in B&B (bab); bound is the bounding function *)
  val (bab, bound) =
    case Policy.bound of
      NONE => (false, undefined)
    | SOME b => (true, b)
        
  fun setBest sol =
    (best := sol ;
     bestId := !bestId + 1 ;
     dbPrint (dbBaB, "Updated best solution.\n"))
    
  (* Tail-recursive getPath *)
  fun getTailPath (Node node, tail) =
    let val altNum = #altNum node in
      if altNum = 0 then tail
      else getTailPath (#mom node, altNum :: tail)
    end

  fun getPath node = getTailPath (node, [])

  (* Debug *)
  fun pathToString node =
    List.foldl
    (fn (i,s) => s ^ (Int.toString i) ^ ", ")
    ""
    (getPath (Node node))
   
  (* Recomputes the space of this node. *)
  fun recompute node =
    let
      val mom = #mom node
      val space = getWorkingSpace mom
    in
      dbPrint(dbRecomp, "Recomputing node at PATH " ^(pathToString node)^ "\n");
      case status mom of
        Space.BRANCH descr =>
          (Space.commit (space, #altNum node, descr) ;
           
           (* Branch and Bound. *)
           if bab then
             case #best node of
               NONE     => ()
             | SOME sol => bound (space, sol)
           else () ;

           space)
      | _ => assert false
    end

  and getWorkingSpace (Node node) =
    let
      val rspace = #space node
      val rcopy  = #copy node
    in
      (*    wspace & copy *)
      case (!rspace, !rcopy) of 
        (NONE  , SOME s) => Space.clone s  (* clone copy   *)
      | (NONE  , NONE  ) => recompute node (* recomputation *)
      | (SOME s, acopy ) =>                (* donate space *)
          (rspace := NONE ;
           if acopy = NONE andalso Policy.copyq (#depth node)
             then (dbPrint (dbClone, "CLONE at path " ^ 
                            pathToString node ^ "\n") ;
                   rcopy := SOME (Space.clone s))
             else () ;
           s)
          
    end

  fun updateRef (r,v) = (assert (!r = NONE) ; r:=SOME v ; v)

  fun getSpace (Node node) = 
    let
      val _ = #status node (* Avoid recomputation if this node is new *)
      val rcopy  = #copy node
      val rspace = #space node
      val readOnlySpace =
        (*     copy & wspace *)
        case (!rcopy, !rspace) of
          (SOME s, _     ) => s
        | (NONE  , SOME s) => updateRef (rcopy, Space.clone s)
        | (NONE  , NONE  ) => updateRef (rcopy, recompute node)
    in
      Space.clone readOnlySpace
    end

  (* Create a new child, not Branch & Bound mode. *)
  fun newChildNormal (node, i) =
    let
      val spaceRef = ref NONE        
      val descr =
        case status node of
          Space.BRANCH descr => descr
        | _ => raise Child
        
      val status = lazy
        let val space = updateRef (spaceRef, getWorkingSpace node)
        in
          Space.commit (space, i, descr) ;
          Space.status space
        end
    in
      Node {mom    = node ,
            altNum = i ,
            space  = spaceRef ,
            copy   = ref NONE ,
            status = status,
            bestId = undefined ,
            best   = undefined ,
            depth  = depth node + 1 }
    end

  (* Create a new child in Branch and Bound mode *)
  fun newChildBaB (node, i) =
    let
      val spaceRef = ref NONE
      val promiseId  = Promise.promise ()
      val promiseSol = Promise.promise ()
      val momBestId = getBestId node

      val descr =
        case status node of
          Space.BRANCH descr => descr
        | _ => raise Child

      val status = lazy
        let
          val space = updateRef (spaceRef, getWorkingSpace node)

          (* Is there a best solution to apply? *)
          val currentBestId = !bestId
          val currentBest = !best (* Harmless race condition *)

          val _ = Space.commit (space, i, descr)
          val _ = assert currentBestId >= momBestId
          val _ = if currentBestId > momBestId
                    then
                      (Promise.fulfill (promiseId, currentBestId) ;
                       Promise.fulfill (promiseSol, SOME currentBest) ;
                       bound (space, currentBest))
                    else
                      (Promise.fulfill (promiseId, momBestId) ;
                       Promise.fulfill (promiseSol, NONE))

          val status = Space.status space

          (* When a solution is found, BOUND *)
          val _ = if status = Space.SOLVED andalso bab
                    then setBest (Policy.getSolution space)
                    else ()
        in
          status  
        end
    in
      Node {mom    = node ,
            altNum = i ,
            space  = spaceRef ,
            copy   = ref NONE ,
            status = status,
            bestId = Promise.future promiseId ,
            best   = Promise.future promiseSol ,
            depth  = depth node + 1 }
    end

  val newChild = if bab then newChildBaB else newChildNormal

end
