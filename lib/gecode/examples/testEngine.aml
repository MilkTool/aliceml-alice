(*
 * Author:
 *   Guido Tack <tack@ps.uni-sb.de>
 *
 * Copyright:
 *   Guido Tack, 2003
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Space     from "x-alice:/lib/gecode/Space"
import structure FS        from "x-alice:/lib/gecode/FS"
import structure Print     from "x-alice:/lib/system/Print"

	(**
	* Asserts v holds for all solutions, performs f if failed node met.
	*)
	
    fun testVerify s v f =
	let
	    fun dfe (s,d) =
		 case Space.status s of
		    Space.FAILED => (f (); Space.discard s)
		  | Space.SOLVED => (
		  assert (v s); 
		  Space.discard s)
		  | Space.BRANCH =>
		    let
			val c = Space.clone s
		    in
			Space.commit(s, 1);
			Space.commit(c, 2);
			(dfe (s,d+1));
			(dfe (c,d+1))
		    end
	in
	    dfe ((Space.clone s),0)
	end

	fun testVerifySimple s v = testVerify s v (fn () => assert false)	
	fun testVerifyComplex s v = testVerify s v (fn () => ())	
	
	fun unionTest () =
	let
		val space = Space.new()
		val root as #[a,b,c] = FS.setvarVec (space, 3)
		val top = FS.Value.make (space,#[(0,5)])
	in
		FS.subset (space, a, top);
		FS.subset (space, b, top);
		FS.subset (space, c, top);				
		FS.union (space, a, b, c);
(*        FS.setvarbranch(space, root, FS.FSB_NONE, FS.FSB_MIN); *)
		FS.randomBranch(space, root, 1);
		(root, space)
	end
	
	fun fakeVerify _ = true
	

	fun range2II (i1,i2) = 
	let
		val _= assert (i1 >= 0);
		val diff = i2 - i1
		val ones = IntInf.<< ((IntInf.fromInt 2),Word.fromInt diff ) - (IntInf.fromInt 1)
	in
		IntInf.<<(ones, Word.fromInt i1)
	end
	
	(*Eta forewa! :-) *)
	val vdom2II = Vector.foldl ( fn (r,a)=> IntInf.orb ((range2II r),a) ) (IntInf.fromInt 0)

	fun vBool v1 root space =
	let
		val root2 : (IntInf.int vector)= Vector.map 
				(  fn v => vdom2II ( FS.Reflect.lowerBound (space,v) )  )
				root
	in
		v1 root2
	end

	fun vUnion1 (root2 as #[a,b,c]) = (IntInf.orb(b,c) = a)
	val vUnion = vBool vUnion1

	fun vInter1 (root2 as #[a,b,c]) = (IntInf.andb(b,c) = a)
	(* a is a subset of b: no element in a and not in b*)
	fun vSubSet1 (root2 as #[a,b]) =
		IntInf.andb (IntInf.xorb(a,b),a)= IntInf.fromInt 0		
	fun vNoSubSet1 root2 = Bool.not (vSubSet1 root2)
		
	fun vSuperOfInt1 (root2 as #[a,b,c]) =
		vSubSet1(#[IntInf.andb(b,c),a])
	fun vSubOfUni1 max (root2 as #[a,b,c]) =
		vSubSet1(#[a,IntInf.orb(b,c)])
	
	fun vDiff1 (root2 as #[a,b,c]) = IntInf.andb (IntInf.xorb(c,b),b) = c
	fun vDisjoint1 (root2 as #[a,b]) = IntInf.andb(a,b) = IntInf.fromInt 0
	fun vDistinct1 (root2 as #[a,b]) = IntInf.xorb(a,b) > IntInf.fromInt 0
	fun vPartition1 (root2) = (vDisjoint1 root2 ) andalso (vUnion1 root2)
	
	fun vEquals1 (root2 as #[a,b]) = (a=b)
	
	
	fun vConvex #[a] space = 
	let
		ad = FS.Reflect.lowerBound (space,a)
	in
		Vector.length ad = 1
	end
	
	fun vConvexHull #[a,b] space =
		(vConvex #[a] space) andthen
		( (vBool SubSet1) #[b,a] space )
	
	
	val (root, space)= unionTest ()
	val _ = testVerifySimple space (vUnion root)
	val _ = print "done.\n";
	val _ = OS.Process.exit OS.Process.success