(*
 * Author:
 *   Gabor Szokoli <szokoli@ps.uni-sb.de>
 *
 * Copyright:
 *   Gabor Szokoli, 2003, 2004
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(*
 * True oz programmers can write oz programs in any language, observe:
 *)

import structure FD     from "FD"
import structure Space  from "Space"
import signature LINEAR from "LINEAR-sig"
(*import structure Print     from "x-alice:/lib/system/Print" *)

structure Linear :> LINEAR 	where type space = Space.space
							where type intvar = FD.intvar
							where type boolvar = FD.boolvar
							where type conlevel = FD.conlevel =
    struct

	type space = Space.space
	type intvar = FD.intvar
	type boolvar = FD.boolvar
	type conlevel = FD.conlevel


	infix  7  `*
	infix  6  `+ `-
	infix  5  `#
	infix  4  `= `<> `> `>= `< `<=
	infix  3  `<->

	datatype domain_element =
	    `` of int
	  | `# of int * int

	type domain = domain_element list

	datatype term =
	    FD of intvar
	  | `  of int
	  | `+ of term * term
	  | `- of term * term
	  | `* of term * term

	datatype rel =
	    `<   of term * term
	  | `<=  of term * term
	  | `=   of term * term
	  | `<>  of term * term
	  | `>=  of term * term
	  | `>   of term * term
	(*  | `<-> of rel * boolvar *)

(*Bool stuff*)
(*Somebody help me with priorities please!*)
	infix  3  `->
	infix  3  `<-
	infix  3  `==
	infix  3  `&
	infix  3  `|
	infix  3  XOR

	datatype b_term = 
	  BV of boolvar
	 | BC of bool
	 | HOLDS of rel
	 | `-> of b_term * b_term
	 | `<- of b_term * b_term
	 | `== of b_term * b_term
	 | `! of b_term
	 | `& of b_term * b_term
	 | `| of b_term * b_term
	 | XOR of b_term * b_term

fun fdterm2varVect (` _) = #[]
|fdterm2varVect (FD v) = #[v]
|fdterm2varVect (op `+(t1,t2)) = Vector.concat[fdterm2varVect t1,fdterm2varVect t2]
|fdterm2varVect (op `-(t1,t2)) = Vector.concat[fdterm2varVect t1,fdterm2varVect t2]
|fdterm2varVect (op `*(t1,t2)) = Vector.concat[fdterm2varVect t1,fdterm2varVect t2]

fun boolterm2boolvarVect(BC _) = #[]
|boolterm2boolvarVect(HOLDS _) = #[]
|boolterm2boolvarVect(BV v) = #[v]
|boolterm2boolvarVect(`!(t)) = boolterm2boolvarVect t
|boolterm2boolvarVect(op`==(t1,t2)) = Vector.concat [boolterm2boolvarVect t1,boolterm2boolvarVect t2]
|boolterm2boolvarVect(op`&(t1,t2)) = boolterm2boolvarVect(op`==(t1,t2))
|boolterm2boolvarVect(op`|(t1,t2)) = boolterm2boolvarVect(op`==(t1,t2))
|boolterm2boolvarVect(op XOR(t1,t2)) = boolterm2boolvarVect(op`==(t1,t2))
|boolterm2boolvarVect(op`->(t1,t2)) = boolterm2boolvarVect(op`==(t1,t2))
|boolterm2boolvarVect(op`<-(t1,t2)) = boolterm2boolvarVect(op`==(t1,t2))




exception NoWay
(*FD stuff*)

fun domain_elementConverter (``c) = (c,c)
(*| domain_elementConverter (op`#(c,c)) = FD.SINGLE c *)
| domain_elementConverter (op`#(a,b)) = 
	if a=b then (a,a)
	else if a < b then (a,b) else (b,a)  


fun fdterm (s,d)= 
	let
		val fdd = Vector.fromList(List.map domain_elementConverter d)
	in
		(case fdd of 
		#[(i,j)] where (i=j) =>  `i
		|x => FD (FD.intvar(s,x))
		)
	end		
 
fun fdtermVec (s,n,d)= 
	let
		val fdd = Vector.fromList(List.map domain_elementConverter d)
	in
		(case fdd of 
		#[(i,j)] where (i=j) => Vector.tabulate (n, (fn q => `i))
		|x => Vector.map (fn v =>FD(v)) (FD.intvarVec(s,n,x))
		)
	end

	

fun isProduct (FD _) = true
	| isProduct (` _) = true
	| isProduct (op`*(a,b)) = if (isProduct a) then (isProduct b) else false
	| isProduct _ = false

	(*perform multiplication on (a+b)*c*)
	fun termMul (a,b, c) =
		op`+(op`*(a,c),op`*(b,c))
		

	(*get rid of all a-b terms: a+(~1*b)  *)	
	fun unMinus (op`-(a,b)) = op`+(unMinus a, op`*(`(~1),unMinus b))
	| unMinus (op`+(a,b)) = op`+(unMinus a,unMinus b)
	| unMinus (op`*(a,b)) = op`*(unMinus a,unMinus b)
	| unMinus x=x 	
	

	(*re-order the binary term tree into sum of proucts exploiting (a+b)c = ac+bc*)
	(*Not too smart, does O(n^2) isProduct checks: "Make it work" phase *)
	fun toDNF (op`*(op`+(a,b),c)) = 
		toDNF(termMul(a,b,c))
	| toDNF (op`*(c,op`+(a,b))) = 
		toDNF(termMul(a,b,c))
	| toDNF (op`+(a,b)) = 
		op`+(toDNF(a),toDNF(b)) 
	| toDNF (op`*(a,b)) = 
		(case (isProduct a, isProduct b) of
		(true,true) => op`*(a,b) |
		(true,false) => toDNF (op`*(a,toDNF b)) |
		(false,true) => toDNF (op`*(toDNF a,b)) |
		(false,false) => toDNF (op`*(toDNF a, toDNF b))
		)
	| toDNF a = a



	exception ShouldBeDNF
	datatype leaf = VAR of FD.intvar | CONST of int
	type product = leaf list
	type sum = product list
	

	(*Binary term-tree into sum/product/leaf tree*)
	fun collapse1 (op`+(_,_)) = raise ShouldBeDNF
	| collapse1 (FD a) = [VAR a]
	| collapse1 (` a) = [CONST a]
	| collapse1 (op`*(a,b)) = (collapse1 a)@(collapse1 b)
	| collapse1 (op`-(_,_)) = raise NoWay
	fun collapse (op`+(a,b)) = (collapse a)@(collapse b)
	| collapse (FD a) = [[VAR a]]
	| collapse (` a) = [[CONST a]]
	| collapse (op`*(a,b)) = [collapse1 (op`*(a,b))]
	| collapse (op`-(_,_)) = raise NoWay
	fun isConst (CONST _)= true
	| isConst (VAR _) = false

	fun mulConsts nil = 1
	| mulConsts ((CONST a)::t) = a * mulConsts t	
	| mulConsts _ = raise NoWay

	fun multiplyConstants leafList = 
		let
			val(consts,vars)=List.partition isConst leafList
			val constProd = mulConsts consts
		in
			CONST(constProd)::vars
		end

	fun multiplyAllConstants a = List.map multiplyConstants a
	
	(*Filters 1 element constant lists*)
	fun isConstList [CONST _] = true
	| isConstList _ = false
	fun sumConsts nil = 0
	| sumConsts ([CONST a]::t) = a + sumConsts t
	| sumConsts _ = raise NoWay

	(*This only performs the addition of constants, should add same-order terms too*)

	fun sumAddables a =
		let 
			val(consts, terms)= List.partition isConstList a
			val constSum = sumConsts consts
		in
			[CONST(constSum)]::terms
		end
	
	fun constsNTerms a =
		let 
			val(consts, terms)= List.partition isConstList a
			val constSum = sumConsts consts
		in
			(constSum,terms)
		end
	
	(*OK, this is ugly: exploits that all product-lists are in the form [CONST, VAR,VAR,...] by now, so 1 and 2 element lists have to be constant or linear terms.*)

	fun isLinear nil = true
	| isLinear (p::t) = if List.length p < 3 then isLinear t else false

	fun createLinearElement [CONST c, VAR v] = (c,v)
	| createLinearElement _ = raise NoWay
	fun createLinearList s = Vector.fromList (List.map createLinearElement s)

	exception SumCNNotImplemented
	(*e is for eagerness of propagation*)



	
	fun post''(s, a, b, rel,e,linear) =
	    let
		val a' = sumAddables (multiplyAllConstants (collapse(toDNF(unMinus(op`-(a,b))))))
		val (b'' ,a'') = constsNTerms a'
	    in
		(*Special cases should be detected for rel and relI*)
		(*Then instead of linear only, the full range of FD would be needed as an argument*)
		if isLinear a'' then 		
			linear(s, createLinearList a'', rel, (~1)*b'',e)
		else
			(*Hmm, could provide the functionality using FD.times and aux variables...*)
			raise SumCNNotImplemented
	   end   

	fun post' (s, op`<(a, b),e,l)   = post''(s, a, b, FD.LE,e,l)
	  | post' (s, op`<=(a, b),e,l)  = post''(s, a, b, FD.LQ,e,l)
	  | post' (s, op`=(a, b),e,l)   = post''(s, a, b, FD.EQ,e,l)
	  | post' (s, op`<>(a, b),e,l)  = post''(s, a, b, FD.NQ,e,l)
	  | post' (s, op`>=(a, b),e,l)  = post''(s, a, b, FD.GQ,e,l)
	  | post' (s, op`>(a, b),e,l)   = post''(s, a, b, FD.GR,e,l)	

	fun post(s,r,e) = post'(s,r,e,FD.linear)	
(*	fun post(s,r,e) = post'(s,r,e,fn x => let val _=Print.printVal x in FD.linear x end)	*)
	
	fun postReified(s,r,c,e) = post'(s,r,e,(fn(s',a',r',b',e')=>FD.Reified.linear(s',a',r',b',c,e')))

(*boolean stuff*)

fun boolterm s = BV(FD.boolvar s)

fun booltermVec(s,n) = Vector.map (fn b=>BV b) (FD.boolvarVec (s,n))

	
	(*To And-Or-Not form, get rid of all other fancy stuff*)
	(*Make it look as CNFish as possible to avoid work later*)
	fun toAON(BC(c)) = BC(c)
	| toAON(BV(v)) = BV(v)
	| toAON(HOLDS(r)) = HOLDS(r)
	| toAON(`!(t)) = `!(toAON(t))
	| toAON(op`&(t1,t2)) = op`&(toAON(t1),toAON(t2))
	| toAON(op`|(t1,t2)) = op`|(toAON(t1),toAON(t2))
	| toAON(op`->(t1,t2)) = op`|(`!(toAON(t1)),toAON(t2))
	| toAON(op`<-(t2,t1)) = toAON(op`->(t1,t2))
	| toAON(op`==(t1,t2)) = let 
						val t1' = toAON(t1)
						val t2' = toAON(t2)
					in
						op`&(op`|(t1',`!(t2')), op`|(`!(t1'),t2'))
					end
 	| toAON(op XOR(t1,t2)) = toAON(op`==(t1,`!(t2)))
 	
	(*Push negations down to atoms, assumes AON input*)
	fun  pushNeg(`!(`!(t))) = pushNeg(t)
	| pushNeg(`!(BC true)) = BC false
	| pushNeg(`!(BC false)) = BC true
	| pushNeg(`!(op`&(t1,t2))) = op`|(pushNeg(`!(t1)),pushNeg(`!(t2)))
	| pushNeg(`!(op`|(t1,t2))) = op`&(pushNeg(`!(t1)),pushNeg(`!(t2)))
	| pushNeg(op`&(t1,t2)) = op`&(pushNeg(t1),pushNeg(t2))
	| pushNeg(op`|(t1,t2)) = op`|(pushNeg(t1),pushNeg(t2))
	| pushNeg(t) = t

	(*Use distributivity of OR over AND mercilessly until CNF*)
	(*Pretty dumb, just you wait Henry Higgins!*) 	
	fun distrib(op`|(op`&(a,b),c)) = (distrib(a`|c))`& (distrib(b`|c))
	| distrib(op`|(c,op`&(a,b))) = distrib(op`|(op`&(a,b),c))
	| distrib(op`&(a,b)) = op`& (distrib(a), distrib(b))
	| distrib(op`|(t1,t2))= 
		let
			val d1 = distrib t1
			val d2 = distrib t2
		in
			case (d1,d2) of
			(op`&(_,_),_)=>distrib(d1 `| d2)
			|( _ ,op`&(_,_))=>distrib(d2 `| d1)
			|(_,_)=>(d1 `| d2)
		end 
	| distrib(t)=t


	fun getOrList(op`&(t1,t2)) = raise NoWay
	| getOrList(op`|(t1,t2)) = (getOrList t1)@(getOrList t2)
	| getOrList(t)= [t]

	(*Create list of list of (possibly negated)ground *)
	fun getAndList(op`&(t1,t2))= (getAndList t1)@(getAndList t2)
	| getAndList(t)=[getOrList t]


	fun notTrue(BC true) = false
	| notTrue(_) = true
	fun notFalse(BC false) = false
	|notFalse(_)=true

	fun hasNoSameNegated nil = true
	| hasNoSameNegated(`!(h)::t) = if List.contains t h then false else hasNoSameNegated t
	| hasNoSameNegated(h::t) = if List.contains t (`! h) then false else hasNoSameNegated t

	(*Gets rid of clauses with constant true BV true*)
	fun dropTrue(cnf) = List.filter (List.all notTrue) cnf
	(*Gets rid of clauses with dynamic true (b|!b)*)
	fun dropDynTrue(cnf) = List.filter hasNoSameNegated cnf
	(*Gets rid of constant false terms in clauses (empty clause means fail)*)
	fun dropFalse(cnf) = List.map (List.filter notFalse) cnf

	fun consolidateCNF(cnf)= dropDynTrue(dropFalse(dropTrue(cnf)))

	(*Should use a cache for negating variables!*)
	fun groundToVar s (BV(v)) = v
	| groundToVar s (`!(BV (v))) = 
		let
			val nv = FD.boolvar(s)
			val _ = FD.nega(s,v,nv)
		in
			nv
		end
	| groundToVar s (HOLDS(r)) = 
		let
			val v = FD.boolvar(s)
			val _ = postReified(s,r,v,FD.DOM)
		in
			v
		end
	 | groundToVar s (`!(HOLDS(r))) = groundToVar s (`!(BV (groundToVar s (HOLDS(r)))))
	 | groundToVar _ _ = raise NoWay



	(*strip the variable-only cnf listlist from b_term encapsulation, perform reification*)
	fun stripCNF(s,cnf) = List.map (List.map (groundToVar s)) cnf
		
	fun getTrue(s)= let val b=FD.boolvar(s) 
		in FD.relI(s, FD.Reflect.boolvar2intvar b, FD.EQ, 1); b end

	(*Rough version, especially if failed spaces allow post-mortem introspection*)
	fun fail(s) = let val b = FD.intvar(s,#[(42,42)]) in FD.relI(s,b,FD.EQ,57) end

	fun postClause (s,t) nil = fail s
	| postClause (s,t) clause = FD.disjV(s, Vector.fromList clause, t) 
	
	fun postCNF(s,cnf) = 
		let val t=getTrue(s)
		in List.app (postClause (s,t)) cnf end

	fun postTrue(s,t) = 
		postCNF(s,(stripCNF(s,consolidateCNF(getAndList(distrib(pushNeg(toAON(t))))))))
		
    end
