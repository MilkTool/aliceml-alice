(*Representing constrint problems as first order data, functions to build and post it*)

signature MODEL =
sig
	datatype constant = INT of int | SET of (int * int) list
	type variable = int
	datatype value = CVAR of variable | CONST of const

	(*This is probably too general.*)
	datatype constraint = NULLARY of string 
		| UNARY of (string * value) 
		| BINARY of (string * int * value)
		| TERNARY of (string * value * value * value)
		| NARY of (string * (value list))
		| NARYONE of (string * int * (value list))	
		| NMARY of (string * (value list) * (value list))
		| NMARYONE of (string * int * (value list) * (value list))	

	(*Or maybe like this?*)
	datatype constraint2 = Convex(value) 
	| Equals of (value*value)
	| Distinct of (value * value)
	| Less of (value*value)
	| LessEqual of (value*value)
	| Plus of (value* value)
	| Times of (value * value)
	(*This is a design thing: we don't support 6 types of Linear, use a local variable and binary connectives.*)
	(*Expressable via Linear, but why not:*)
	| Sum of (value list)
	(*Actually, non-linear, but tradition binds.*)
	| Linear of (((value list)list)
	| AllDistinct (value list)
	(*No excuse here, needs all 6 forms. At least 4. TODO*)
	| Count(value list * value * value)
	| Select(value list * value * value)
	
	
	(*constraints plus set of significant variables*)
	type problem = (constraint list) * (value list)
	val newVar : problem -> value
	val newIntConst : int -> value
	val newSetConst : (int * int) list-> value	
	val isInt : value -> constraint
	val isBool : value -> constraint

	val convex : value -> constraint	
	
	val equals : (value * value) -> constraint
	
	
	
end
