(*
 * Author:
 *   Guido Tack <tack@ps.uni-sb.de>
 *
 * Copyright:
 *   Guido Tack, 2003
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import "Space"

signature FD =
sig
    (* Domain constraints *)
    val dom : 'p Space.space * 'p Space.fdvar * (int * int) vector -> unit
    val domR : 'p Space.space * 'p Space.fdvar * (int * int) vector *
	       'p Space.boolvar -> unit

    (* *********** *)
    (* PROPAGATORS *)
    (* *********** *)

    (* Relations *)

    datatype relation =
	     EQ (* Equality         == *)
	   | NQ (* Disequality      != *)
	   | LQ (* Less or equal    <= *)
	   | LE (* Less             <  *)
	   | GQ (* Greater or equal >= *)
	   | GR (* Greater          >  *)
	     
    datatype conlevel = 
	     BND | BND_EX | DEF | DOM | DOM_EX | 
	     OTR | VAL | VAL_EX

    val rel : 'p Space.space * 'p Space.fdvar * relation *
	      'p Space.fdvar -> unit
    val relI : 'p Space.space * 'p Space.fdvar * relation * int -> unit
    val relR : 'p Space.space * 'p Space.fdvar * relation * 'p Space.fdvar *
	       'p Space.boolvar -> unit
    val relIR : 'p Space.space * 'p Space.fdvar * relation * int *
		'p Space.boolvar -> unit
    val eq : 'p Space.space * 'p Space.fdvar * 'p Space.fdvar *
	     conlevel -> unit
    val eqV : 'p Space.space * 'p Space.fdvar vector * conlevel -> unit
    val eqR : 'p Space.space * 'p Space.fdvar * 'p Space.fdvar *
	      'p Space.boolvar * conlevel -> unit
    val eqVR : 'p Space.space * 'p Space.fdvar vector * 'p Space.boolvar *
	       conlevel -> unit

    (* Distinct constraints *)
    val distinct : 'p Space.space * 'p Space.fdvar vector * conlevel -> unit
    val distinctI : 'p Space.space * (int * 'p Space.fdvar) vector *
		    conlevel -> unit

    (* Counting constraints *)
    val countII : 'p Space.space * 'p Space.fdvar vector * relation *
		  int * relation * int -> unit
    val countVI : 'p Space.space * 'p Space.fdvar vector * relation *
		  'p Space.fdvar * relation * int -> unit
    val countIV : 'p Space.space * 'p Space.fdvar vector * relation *
		  int * relation * 'p Space.fdvar -> unit
    val countVV : 'p Space.space * 'p Space.fdvar vector * relation *
		  'p Space.fdvar * relation * 'p Space.fdvar -> unit

    (* Access constraints *)
    val element : 'p Space.space * 'p Space.fdvar vector * 'p Space.fdvar *
		  'p Space.fdvar -> unit
    val elementI : 'p Space.space * int vector * 'p Space.fdvar *
		   'p Space.fdvar -> unit
    val lex : 'p Space.space * 'p Space.fdvar vector * relation *
	      'p Space.fdvar vector -> unit
			       
    (* Boolean constraints *)			     
    val bool_not : 'p Space.space * 'p Space.boolvar * 'p Space.boolvar -> unit
    val bool_and : 'p Space.space * 'p Space.boolvar * 'p Space.boolvar *
		   'p Space.boolvar -> unit
    val bool_or  : 'p Space.space * 'p Space.boolvar * 'p Space.boolvar *
		   'p Space.boolvar -> unit
    val bool_imp : 'p Space.space * 'p Space.boolvar * 'p Space.boolvar *
		   'p Space.boolvar -> unit
    val bool_eq  : 'p Space.space * 'p Space.boolvar * 'p Space.boolvar *
		   'p Space.boolvar -> unit
    val bool_xor : 'p Space.space * 'p Space.boolvar * 'p Space.boolvar *
		   'p Space.boolvar -> unit
    val bool_andV: 'p Space.space * 'p Space.boolvar vector *
		   'p Space.boolvar -> unit
    val bool_orV : 'p Space.space * 'p Space.boolvar vector *
		   'p Space.boolvar -> unit

    (* Linear equations *)
    val linear : 'p Space.space * (int * 'p Space.fdvar) vector * relation *
		 int * conlevel -> unit
    val linearR : 'p Space.space * (int * 'p Space.fdvar) vector * relation *
		  int * 'p Space.boolvar * conlevel -> unit

    (* Arithmetic constraints *)					
    val min : 'p Space.space * 'p Space.fdvar vector * 'p Space.fdvar -> unit
    val max : 'p Space.space * 'p Space.fdvar vector * 'p Space.fdvar -> unit
    val abs : 'p Space.space * 'p Space.fdvar * 'p Space.fdvar * conlevel ->
	      unit
    val mult: 'p Space.space * 'p Space.fdvar * 'p Space.fdvar *
	      'p Space.fdvar -> unit
						  
    (* Branching strategies *)

    datatype b_var_sel =
	     B_MAX_MAX
	   | B_MAX_MIN
	   | B_MIN_MAX
	   | B_MIN_MIN
	   | B_NONE
	   | B_SIZE_MAX
	   | B_SIZE_MIN
	   | B_WIDTH_MAX
	   | B_WIDTH_MIN
	     
    datatype b_val_sel =
	     B_MAX
	   | B_MED
	   | B_MIN
	   | B_SPLIT_MAX
	   | B_SPLIT_MIN
	   | B_VAL

    val branch : 'p Space.space * 'p Space.fdvar vector * b_var_sel *
		 b_val_sel -> unit
				
    (* Value assignment *)

    datatype avalsel = AVAL_MIN | AVAL_MED | AVAL_MAX

    val assign : 'p Space.space * 'p Space.fdvar vector * avalsel -> unit

    (* Access to variables *)

    exception NoFD
    exception NoBool

    val boolvar2fdvar : 'p Space.boolvar -> 'p Space.fdvar
					     
    val getMin : 'p Space.space * 'p Space.fdvar -> int
    val getMax : 'p Space.space * 'p Space.fdvar -> int
    val getVal : 'p Space.space * 'p Space.fdvar -> int      (* NoVal *)
    val getBool : 'p Space.space * 'p Space.boolvar -> bool  (* NoBool *)

end
