(*
 * Author:
 *   Guido Tack <tack@ps.uni-sb.de>
 *
 * Copyright:
 *   Guido Tack, 2003
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Space from "Space"

signature FD =
sig
    type fdvar
    type boolvar

    datatype domain_element =
	     SINGLE of int
	   | RANGE  of int * int
		       
    type domain = domain_element vector

    (* Allocation of finite domain variables *)
    val fdvar :  Space.space * domain ->  fdvar
    val fdvarVec :  Space.space * int * domain ->  fdvar vector
    val range :  Space.space * (int * int) ->  fdvar
    val rangeVec :  Space.space * int * (int * int) ->  fdvar vector

    (* Allocation of reified finite domain variables *)
    val fdvarR :  Space.space * domain *  boolvar ->  fdvar
    val fdvarVecR :  Space.space * int * domain *  boolvar ->
		     fdvar vector

    (* Allocation of boolean (0/1) finite domain variables *)
    val boolvar :  Space.space ->  boolvar
    val boolvarVec :  Space.space * int ->  boolvar vector

    (* Domain constraints *)
    val dom :  Space.space *  fdvar * (int * int) vector -> unit
    val domR :  Space.space *  fdvar * (int * int) vector *
	        boolvar -> unit

    (* *********** *)
    (* PROPAGATORS *)
    (* *********** *)

    (* Relations *)

    datatype relation =
	     EQ (* Equality         == *)
	   | NQ (* Disequality      != *)
	   | LQ (* Less or equal    <= *)
	   | LE (* Less             <  *)
	   | GQ (* Greater or equal >= *)
	   | GR (* Greater          >  *)
	     
    datatype conlevel = 
	     BND | BND_EX | DEF | DOM | DOM_EX | 
	     OTR | VAL | VAL_EX

    val rel :  Space.space *  fdvar * relation *
	       fdvar -> unit
    val relI :  Space.space *  fdvar * relation * int -> unit
    val relR :  Space.space *  fdvar * relation *  fdvar *
	        boolvar -> unit
    val relIR :  Space.space *  fdvar * relation * int *
		 boolvar -> unit
    val eq :  Space.space *  fdvar *  fdvar *
	     conlevel -> unit
    val eqV :  Space.space *  fdvar vector * conlevel -> unit
    val eqR :  Space.space *  fdvar *  fdvar *
	       boolvar * conlevel -> unit
    val eqVR :  Space.space *  fdvar vector *  boolvar *
	       conlevel -> unit

    (* Distinct constraints *)
    val distinct :  Space.space *  fdvar vector * conlevel -> unit
    val distinctI :  Space.space * (int *  fdvar) vector *
		    conlevel -> unit

    (* Counting constraints *)
    val countII :  Space.space *  fdvar vector * relation *
		  int * relation * int -> unit
    val countVI :  Space.space *  fdvar vector * relation *
		   fdvar * relation * int -> unit
    val countIV :  Space.space *  fdvar vector * relation *
		  int * relation *  fdvar -> unit
    val countVV :  Space.space *  fdvar vector * relation *
		   fdvar * relation *  fdvar -> unit

    (* Access constraints *)
    val element :  Space.space *  fdvar vector *  fdvar *
		   fdvar -> unit
    val elementI :  Space.space * int vector *  fdvar *
		    fdvar -> unit
    val lex :  Space.space *  fdvar vector * relation *
	       fdvar vector -> unit
			       
    (* Boolean constraints *)			     
    val bool_not :  Space.space *  boolvar *  boolvar -> unit
    val bool_and :  Space.space *  boolvar *  boolvar *
		    boolvar -> unit
    val bool_or  :  Space.space *  boolvar *  boolvar *
		    boolvar -> unit
    val bool_imp :  Space.space *  boolvar *  boolvar *
		    boolvar -> unit
    val bool_eq  :  Space.space *  boolvar *  boolvar *
		    boolvar -> unit
    val bool_xor :  Space.space *  boolvar *  boolvar *
		    boolvar -> unit
    val bool_andV:  Space.space *  boolvar vector *
		    boolvar -> unit
    val bool_orV :  Space.space *  boolvar vector *
		    boolvar -> unit

    (* Linear equations *)
    val linear :  Space.space * (int *  fdvar) vector * relation *
		 int * conlevel -> unit
    val linearR :  Space.space * (int *  fdvar) vector * relation *
		  int *  boolvar * conlevel -> unit

    (* Arithmetic constraints *)					
    val min :  Space.space *  fdvar vector *  fdvar -> unit
    val max :  Space.space *  fdvar vector *  fdvar -> unit
    val abs :  Space.space *  fdvar *  fdvar * conlevel ->
	      unit
    val mult:  Space.space *  fdvar *  fdvar *
	       fdvar -> unit
    val power:  Space.space *  fdvar *  fdvar *
		fdvar -> unit
						  
    (* Branching strategies *)

    datatype b_var_sel =
	     B_MAX_MAX
	   | B_MAX_MIN
	   | B_MIN_MAX
	   | B_MIN_MIN
	   | B_NONE
	   | B_SIZE_MAX
	   | B_SIZE_MIN
	   | B_WIDTH_MAX
	   | B_WIDTH_MIN
	     
    datatype b_val_sel =
	     B_MAX
	   | B_MED
	   | B_MIN
	   | B_SPLIT_MAX
	   | B_SPLIT_MIN
	   | B_VAL

    val branch :  Space.space *  fdvar vector * b_var_sel *
		 b_val_sel -> unit
				
    (* Value assignment *)

    datatype avalsel = AVAL_MIN | AVAL_MED | AVAL_MAX

    val assign :  Space.space *  fdvar vector * avalsel -> unit

    (* Access to variables *)

    exception NoFD
    exception NoBool

    val boolvar2fdvar :  boolvar ->  fdvar
					     
    val getMin :  Space.space *  fdvar -> int
    val getMax :  Space.space *  fdvar -> int
    val getVal :  Space.space *  fdvar -> int      (* NoVal *)
    val getBool :  Space.space *  boolvar -> bool  (* NoBool *)
end
