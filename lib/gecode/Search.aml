(*
 * Author:
 *   Guido Tack <tack@ps.uni-sb.de>
 *
 * Copyright:
 *   Guido Tack, 2003
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import signature SEARCH       from "SEARCH-sig"
import structure Space        from "Space"

structure Search :> SEARCH =
struct

    fun searchAll s =
	let
	    fun dfe s =
		case Space.status s of
		    Space.FAILED => (Space.discard s; nil)
		  | Space.SOLVED => [s]
		  | Space.BRANCH =>
		    let
			val c = Space.clone s
		    in
			Space.commit(s, 1);
			Space.commit(c, 2);
			(dfe s)@(dfe c)
		    end
	in
	    dfe (Space.clone s)
	end

    fun searchOne s =
	let
	    exception Found of Space.space
	    fun dfe s =
		case Space.status s of
		    Space.FAILED => Space.discard s
		  | Space.SOLVED => raise (Found s)
		  | Space.BRANCH =>
		    let
			val c = Space.clone s
		    in
			Space.commit(s, 1);
			Space.commit(c, 2);
			dfe s;
			dfe c
		    end
	in
	    (dfe (Space.clone s); NONE) handle (Found s) => SOME s
	end

    fun bab (space, constrain) =
	let
	    fun babe fs bs best =
		case fs of
		    nil =>
		    (case bs of nil => best
			      | b::br => (constrain(b, valOf best);
					  babe [b] br best))
		  | f::fr =>
		    case Space.status f of
			Space.FAILED => (Space.discard f;
					 babe fr bs best)
		      | Space.SOLVED => babe nil (fr@bs) (SOME f)
		      | Space.BRANCH =>
			let
			    val c = Space.clone f
			in
			    Space.commit(f, 1);
			    Space.commit(c, 2);
			    babe (f::c::fr) bs best
			end
	in
	    babe [Space.clone space] nil NONE
	end
end
