(*
 * Author:
 *   Guido Tack <tack@ps.uni-sb.de>
 *
 * Copyright:
 *   Guido Tack, 2003
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import functor MkExplorerSearch  from "MkExplorerSearch"
import functor MkMainWindow      from "MkMainWindow"
import signature SPACE           from "x-alice:/lib/gecode/SPACE-sig"
import structure Type            from "x-alice:/lib/rtt/Type"
import signature EXPLORER_INSPECT from "EXPLORER_INSPECT-sig"
import functor MkTypes           from "MkTypes"
import functor MkCanvasHelper    from "MkCanvasHelper"

signature EXPLORER =
  sig
      type space
      type explorer (*= Types.explorer_state option ref*)
      val serve : (unit -> unit) -> unit
      val initExplorer : unit -> explorer
      val initWithSpace : space * string -> explorer
      val exploreAll : space -> explorer
      val exploreOne : space -> explorer
(*      val exploreBest : space * better -> explorer*)
      val addInfoAction : explorer * (space -> unit) * string -> unit
      val deleteInfoAction : explorer * string -> unit

      val initScript' : Type.typ -> (space -> 'a) -> explorer
      val exploreAllScript' : Type.typ -> (space -> 'a) -> explorer
      val exploreBestScript' :
	  Type.typ ->
	  (space -> 'a * (space * space -> unit))
	  -> explorer
      val exploreAllRoot' : Type.typ -> space -> 'a -> explorer
      val exploreOneScript' : Type.typ -> (space -> 'a) -> explorer
  end

functor MkExplorer (Space : SPACE)
                   (ExplorerInspect : EXPLORER_INSPECT
                                          where type space = Space.space)
                   :> EXPLORER
  where type space = Space.space=
  struct
  local
  structure Types = MkTypes(Space)
  structure CanvasHelper = MkCanvasHelper(Space)
  structure MainWindow = MkMainWindow(Space)
  structure ExplorerSearch = MkExplorerSearch(Space)
  in

  type space = Space.space
  type explorer = Types.explorer_state option ref
  
  fun newServer() = 
      let
	  val tail   = Promise.promise ()
	  val stream = Ref.ref tail
		       
	  fun process s = (case s of
			       nil   => ()
			     | p::pr => ((Exn.catch (fn packet => 
						     (print ("Uncaught exception "^
							     Exn.name (Exn.fromPacket packet)^"\n");
						      print ("Message: "^
							     Exn.message (Exn.fromPacket packet)^"\n");
						      Exn.dumpTrace packet)) p);
					 process pr))
	  fun send p =
	      let
		  val newtail = Promise.promise ()
		  val tail    = Ref.exchange(stream, newtail)
	      in
		  Promise.fulfill(tail, p::(Promise.future newtail))
	      end
      in
	  (spawn (process(Promise.future tail));
	   send)
      end

  val serve = newServer ()

  fun makeState () =
      MainWindow.createMainWindow serve
      : Types.explorer_state option ref

  val defaultExplorer = ref NONE

  fun initExplorer () = case !defaultExplorer of
			    NONE =>
			    let
				val s = makeState()
			    in
				defaultExplorer := SOME s;
				s
			    end
			  | SOME s => s

  fun initWithSpace (s, name) =
      let
	  val state = initExplorer()
      in
          serve (fn () => MainWindow.setWindowTitle name) ;
          serve (fn () => ExplorerSearch.initSearch
                              (serve, state, MainWindow.refresh,
                               CanvasHelper.resetCanvas, s, NONE));
	  state
      end

  fun exploreAll s =
      let
	  val state = initExplorer()
      in
          serve (fn () => ExplorerSearch.initSearch
                              (serve, state, MainWindow.refresh,
                               CanvasHelper.resetCanvas, s, NONE));
	  serve (fn () => ExplorerSearch.search
                              (serve, state,
                               MainWindow.refresh, MainWindow.setStatusMsg,
                               0, NONE));
	  state
      end

  fun exploreOne s =
      let
	  val state = initExplorer()
      in
          serve (fn () => ExplorerSearch.initSearch
                              (serve, state, MainWindow.refresh,
                               CanvasHelper.resetCanvas, s, NONE));
	  serve (fn () => ExplorerSearch.search
                              (serve, state,
                               MainWindow.refresh, MainWindow.setStatusMsg,
                               1, NONE));
	  state
      end

  fun exploreBest (s,b) =
      let
	  val state = initExplorer()
      in
          serve (fn () => ExplorerSearch.initSearch
                              (serve, state, MainWindow.refresh,
                               CanvasHelper.resetCanvas, s, SOME b));
	  serve (fn () => ExplorerSearch.search
                              (serve, state,
                               MainWindow.refresh, MainWindow.setStatusMsg,
                               0, NONE));
	  state
      end

  fun addInfoAction (e, action, name) =
      case (!e) of
	  SOME {inspect=inspect,
                curInspAction=curInspAction,...} =>
	  (inspect := List.filter (fn (_,n) => n<>name) (!inspect);
           inspect := (action, name)::(!inspect);
           curInspAction := name;
	   serve (fn () =>
		     MainWindow.updateInspectionActionsMenu
                         (!inspect, serve, e)))
	| _ => ()

  fun deleteInfoAction (e, name) =
      case (!e) of
	  SOME ({inspect=inspect,...} : Types.explorer_state) =>
	  (inspect := List.filter (fn (_,n) => n<>name) (!inspect);
	   serve (fn () =>
		     MainWindow.updateInspectionActionsMenu
                         (!inspect, serve, e)))
	| _ => ()

  fun initScript' t script =
      let
          val space = Space.new()
          val root = script space
          val e = initWithSpace (space, "Explorer")
      in
          addInfoAction(e, ExplorerInspect.inspect t root, "default");
          e
      end

  fun exploreAllScript' t script =
      let
          val space = Space.new()
          val root = script space
          val e = exploreAll space
      in
          addInfoAction(e, ExplorerInspect.inspect t root, "default");
          e
      end

  fun exploreOneScript' t script =
      let
          val space = Space.new()
          val root = script space
          val e = exploreOne space
      in
          addInfoAction(e, ExplorerInspect.inspect t root, "default");
          e
      end

  fun exploreBestScript' t script =
      let
          val space = Space.new()
          val (root, better) = script space
          val e = exploreBest(space, better)
      in
          addInfoAction(e, ExplorerInspect.inspect t root, "default");
          e
      end

  fun exploreAllRoot' t space root =
      let
          val e = exploreAll space
      in
          addInfoAction(e, ExplorerInspect.inspect t root, "default");
          e
      end
  end
  end
