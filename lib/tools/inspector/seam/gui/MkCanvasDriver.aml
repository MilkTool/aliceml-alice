import structure Gdk           from "x-alice:/lib/gtk/Gdk"
import structure Gtk           from "x-alice:/lib/gtk/Gtk"
import structure Canvas        from "x-alice:/lib/gtk/Canvas"
import structure Prefs         from "../Prefs"
import signature MAIN_WINDOW   from "MAIN_WINDOW-sig"
import signature CANVAS_DRIVER from "CANVAS_DRIVER-sig"

functor MkCanvasDriver (MainWin: MAIN_WINDOW) :> CANVAS_DRIVER =
struct

  structure Cn = Canvas

  val canvas = MainWin.canvas
  val rootGroup = Cn.root canvas

  (* Current size of the canvas. *)
  val width = ref 0
  (* New items are added to the canvas at this height. *)
  val height = ref Prefs.margin

  fun resizeCanvas () =
      let
	val width = real (!width + Prefs.margin + Prefs.rightMargin)
	val height = real (!height)
      in
	Cn.setScrollRegion (canvas, 0.0, 0.0, width, height) 
      end

  (* Init the canvas. *)
  val _ =
    (Cn.setBackgroundColor(canvas, Prefs.white) ;
     Cn.setPixelsPerUnit(canvas, 1.0);
     Cn.setCenterScrollRegion(canvas, false) ;
     resizeCanvas () ;
     ())
    
  (* Text items. *)
  val textItemType = Cn.textGetType ()
  val anchor = Gtk.INT (Gtk.GtkAnchorTypeToInt Gtk.ANCHOR_NORTH_WEST)

  val groupType = Cn.groupGetType ()

  val lineType = Cn.lineGetType ()
  val lineStyle = Gtk.INT (Gdk.GdkLineStyleToInt Gdk.LINE_ON_OFF_DASH)

  val lineWidth = ref MainWin.canvasWidth

  val gtkZero = Gtk.REAL 0.0
  val gtkOne  = Gtk.INT 1

  (**** LINE ****)

  fun createDashedLine (group, ypos) =
    Cn.itemCreate (group,
                            lineType,
                            [("points",
                              Gtk.OBJECT (Cn.makePoints
                                          [0, ypos, !lineWidth, ypos])),
                             ("fill_color_gdk", Gtk.OBJECT (!Prefs.sepColor)),
                             ("line_style", lineStyle),
                             ("width_pixels", gtkOne)])

  fun resizeLine (line, ypos) =
      Cn.itemSet(line, "points", 
		 Gtk.OBJECT (Cn.makePoints [0, ypos, !lineWidth, ypos]))

   fun mvByX (group, x) = Cn.itemMove(group, real x, 0.0)
   fun mvByY (group, y) = Cn.itemMove(group, 0.0, real y)
   fun mvByXY (group, x, y) = Cn.itemMove(group, real x, real y)
			   
   fun convertFromMouse (x, y) =
       let val (x, y) = Cn.windowToWorld (canvas, x, y)
       in (Real.trunc x, Real.trunc y)
       end
      
   fun newGroup' (group, x, y) =
       Cn.itemCreate (group, groupType, [("x", x), ("y", y)])

   fun newGroupX (group, x) = newGroup' (group, Gtk.REAL (real x), gtkZero)
   fun newGroupY (group, y) = newGroup' (group, gtkZero, Gtk.REAL (real y))
   fun newGroupXY (group, x, y) = newGroup' (group, Gtk.REAL (real x),
					     Gtk.REAL (real y))


   fun getParent n = Gtk.objectGetObject(n, "parent")
   val hide = Cn.itemHide
	      

   (* Maximal height of the different fonts. *)
   val maxHeight = ref 0
		   
   val topHiddenGroup = newGroupY (rootGroup, ~200)
   val testString = Gtk.STRING "[|?{#!YMZ&/yghl"

   fun initFont font =
       let
	 val testGlyph = Cn.itemCreate (topHiddenGroup,
					textItemType,
					[("text", testString),
					 ("anchor", anchor),
					 ("font", Gtk.STRING font)])
	 val height = Gtk.objectGetDouble(testGlyph, "text-height")
       in
	 Gtk.objectDestroy testGlyph ;
	 maxHeight := Int.max (!maxHeight, Real.round height)
       end

   fun initStyle ({font, usefont, ...} : Prefs.style) =
       if !usefont then initFont (!font) else ()
	    
   fun initFonts () = (maxHeight := 0 ;
		       initFont (!Prefs.fontname) ;
		       (* List.app initStyle (!Prefs.styles) *) ())

   val _ = initFonts ()

   (**** TEXT ITEMS ****)
   fun getWidth item = Int.max (1,
                                Real.round
                                    (Gtk.objectGetDouble(item, "text-width")))

   fun styleItem (item, ({font, usefont, colorClass, ...} : Prefs.style)) =
       let
	 val font = if !usefont then !font else !Prefs.fontname
	 val _ = Cn.itemSet (item, "font", Gtk.STRING font)
	 val _ = Cn.itemSet (item, "fill_color_gdk", Gtk.OBJECT (!colorClass))
	 val width  = getWidth item
	 val height = Int.max (1, Real.round (Gtk.objectGetDouble(item, "text-height")))
       in
	 if height >= !maxHeight then (item, width, height)
         else (Cn.itemSet (item, "y-offset",
			   Gtk.REAL (real ((!maxHeight - height) div 2))) ;
               (item, width, !maxHeight))
       end
		  
   fun newTextItem ((str, style), group, xpos) =
       let
	 (* We do not use x-offset because it is independent from 'moveItem'...
	  * hence some very curious behaviour. *)
	 val str = Gtk.latin1ToUtf8 str
	 val item = Cn.itemCreate (group,
				   textItemType,
				   [("text", Gtk.STRING str),
				    ("anchor", anchor)])
       in
	 mvByX (item, xpos) ;
	 styleItem (item, style)
       end

   fun newTextItemId ((str, style), group, xpos, id) =
     case id of
       NONE => newTextItem ((str, style), group, xpos)
     | SOME n =>
         let
          (* Note : <sub> misbehaves with font sizes. Not my fault. *)
           val markup = str ^ "<sub>" ^ (Int.toString n) ^ " </sub>"
           val item = Cn.itemCreate (group,
                                     textItemType,
                                     [("markup", Gtk.STRING markup),
                                      ("anchor", anchor)])
         in
           mvByX (item, xpos) ;
           styleItem (item, style)
         end

   fun addId (item, (str, style), nb) =
       let
	 val markup = str ^ "<sub>" ^ (Int.toString nb) ^ " </sub>"
       in
	 Cn.itemSet (item, "markup", Gtk.STRING markup) ;
	 styleItem (item, style)
       end
         
   fun updItem (item, (str, style)) =
       (Cn.itemSet (item, "text", Gtk.STRING str) ;
	styleItem (item, style))

   fun getGarmentPos ([], xpos) = xpos
     | getGarmentPos ((item, _) :: gs, xpos) =
     let
       val width = getWidth item
       val xpos' = xpos + width
     in
       getGarmentPos (gs, xpos')
     end

   fun shadeItem (item, _) =
     Cn.itemSet(item, "fill_color_gdk", 
                Gtk.OBJECT Prefs.shadeColor)
     

   fun unshadeItem (item, (_, ({font, colorClass, ...} : Prefs.style))) =
     Cn.itemSet(item, "fill_color_gdk", Gtk.OBJECT (!colorClass))

   fun shadeGarments gl = List.app shadeItem gl
   fun unshadeGarments gl = List.app unshadeItem gl

  (**** RECTANGLE ****)
   val rectType = Cn.rectGetType ()
		  
   fun drawSelection (group, x, y, w, h) =
       let
	 val x1 = Gtk.REAL (real x)
	 val y1 = Gtk.REAL (real y)
	 val x2 = Gtk.REAL (real (x+w))
	 val y2 = Gtk.REAL (real (y+h))
         val color = Gtk.OBJECT Prefs.selectColor
         val outline = Gtk.OBJECT Prefs.outlineColor
         val rect = Cn.itemCreate (group, rectType,
                                   [("x1", x1), ("y1", y1),
                                    ("x2", x2), ("y2", y2),
                                    ("fill_color_gdk", color),
                                    ("outline_color_gdk", outline)])
       in
         Cn.itemLowerToBottom rect ;
         rect
       end

end

