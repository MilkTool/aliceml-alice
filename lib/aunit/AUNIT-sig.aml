(*
 * Authors:
 *   Benedikt Grundmann <bgrund@ps.uni-sb.de>
 *
 * Copyright:
 *   Benedikt Grundmann, 2003
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)
signature AUNIT =
sig
	type testcase = string * (unit -> unit) 

	type testsuite = string * testcase list (* name, testcases *)
	
	datatype failure =			(* reason for failure *) 
		FAIL_EXN of exn 		(* Exception raised *)
	|	FAIL_ASSERT of string				 
	|	FAIL_TIMEOUT

	type result = {								(* result of executing a testsuite *)
		name: string,							(* name of the testsuite *)
		passedNum: int,							(* number of successful testcases *)
		failedNum: int,							(* number of failed testcases *)
		failedTC: (string * failure) list		(* list of failed testcases and reason *)
	}

	type config = {
		timeOut: Time.time,			(* if a testcase uses more time it fails *)
		separate: bool				(* execute each testcase in a separate process ? *)
	}

	val defaultCfg: config			(* [= { timeOut = Time.fromSeconds 60, separate = false }] *)

	val execute: config -> testsuite -> result
	(* [execute cfg suite] executes all testcases of [suite] using configuration [cfg].
	 * All testcases are executed independently of the outcome of previos testcases.
	 * In particular failure of a testcase doesn't prevent execution of the following
	 * testcases of the suite!
	 *)

	(********************** Basic asserts **********************)
	val assert: string * bool -> unit
	(* [assert (label, e)] fails unless [e = true] *)

	val assertExnP: (exn -> bool) -> string * (unit -> 'a) -> unit	
	(* [assertExnP exnp (label, f)] fails unless [f ()] raises an exception [e] 
	 * with [exnp e = true].
	 *)

	val assertFalse: string * bool -> unit
	(* [assertFalse (label, expr)] sugar for [assert (label, not expr)].
	 *)

	val assertExn: exn -> string * (unit -> 'a) -> unit
    (* [assertExn e (label, f)] sugar for [assertExnP (fn ex => ex = e) (label, f)].
	 *)

	val assertb: bool -> unit
	(* [assertb expr] sugar for [assert ("", expr)].  
	 * Use it, when it's the only assert of a testcase.
	 *)

end


