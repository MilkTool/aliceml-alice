(*
 * Authors:
 *   Benedikt Grundmann <bgrund@ps.uni-sb.de>
 *
 * Copyright:
 *   Benedikt Grundmann, 2003
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)
import signature AUNIT from "AUNIT-sig"
import structure MkSeparate from "MkSeparate"

structure AUnit :> AUNIT =
struct
	type testcase = string * (unit -> unit)

	type testsuite = string * testcase list
	
	datatype failure = 
		FAIL_EXN of exn 		(* Exception raised *)
	|	FAIL_ASSERT of string				 
	|	FAIL_TIMEOUT 

	type result = {
		name: string,
		passedNum: int,
		failedNum: int,
		failedTC: (string * failure) list
	}

	type config = {
		timeOut: Time.time,
		separate: bool
	}
	
	val defaultCfg = { timeOut = Time.fromSeconds 60, separate = false }

	exception Failed of string

	fun executeTC (cfg:config) (name, f) = 
		(case Future.awaitEither (f (), Future.alarm (#timeOut cfg)) of
			FST () => NONE
		|	SND () => SOME (FAIL_TIMEOUT)
		) handle Failed assertN	=> SOME (FAIL_ASSERT assertN)
			|	e				=> SOME (FAIL_EXN e)

	fun executeSepTC (cfg:config) tc = 
		let
			structure Sep = MkSeparate (val host = "localhost" 
										type arg = testcase
										type res = failure option
										val f 	 = executeTC cfg)
			val result = Sep.execute tc
		in
			Sep.shutdown ();
			result
		end
			
	fun combine (executeTC: testcase -> failure option) (tc, res:result) =
		case executeTC tc of
			NONE		=>	{ res where passedNum = #passedNum res + 1 } 
		|	SOME f		=>	{ res where failedNum = #failedNum res + 1, failedTC = (#1 tc, f) :: #failedTC res }
	
	fun execute cfg (name, testcases) = 
		let	val res = List.foldl (combine (if #separate cfg then executeSepTC cfg else executeTC cfg))
									{ name = name, passedNum = 0, failedNum = 0, failedTC = [] } testcases
		in
			{ res where failedTC = List.rev (#failedTC res) }
		end

	(********************** Basic asserts **********************)

	fun assert (name, expr) = if expr then () else raise Failed name

	fun assertExnP exnp (name, f) = if (f (); false) handle e => exnp e then () else raise Failed name

	fun assertFalse (name, expr) = if not expr then () else raise Failed name
	
	fun assertExn eWanted = assertExnP (fn e => e = eWanted) 

	fun assertb expr = if expr then () else raise Failed ""	
end


