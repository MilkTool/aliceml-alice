(*
 * Authors:
 *   Benedikt Grundmann <Benedikt-Grundmann@ps.uni-sb.de>
 *
 * Copyright:
 *   Benedikt Grundmann, 2003
 *
 * Last change:
 *   $Date$ 
 *)

(* Resizeable Arrays using amortized doubling *)


import signature RESARRAY from "RESARRAY-sig"

structure ResArray :> RESARRAY = 
struct
    type 'a array = int ref * 'a Array.array ref
    type t = array

    exception Empty

    val minCap = 16

    fun dummy () = lazy (raise Fail "!!")

    fun array (n, v) = (ref n, ref (Array.array (Int.max (n, minCap), v)))

    fun length (ref n, _) = n

    fun checkBounds (i, n) = if i < 0 orelse i >= n then raise Subscript else ()

    fun checkResize ((_, ar as ref a), neededCap) =
        let val dummy = dummy ()
            val cap = Array.length a 
            
            fun resize n =
                let val res = Array.array (n, dummy) in
                    Array.copy { di = 0, dst = res, src = a };
                    res
                end
        in
            if cap < neededCap then
                ar := resize (Int.max (neededCap, 2*cap))
            else
                if cap div 4 >= neededCap andalso cap div 4 >= minCap then
                    ar := resize (cap div 4)
                else ()
        end
        
    
    fun sub ((ref n, ref a), i) = (checkBounds (i, n);
                                      Array.sub (a, i))

    fun update ((ref n, ref a), i, v) = (checkBounds (i, n);
                                             Array.update (a, i, v))

    fun addOne (da as (r as ref n, ar), v) =    
        (checkResize (da, n + 1);
         Array.update (!ar, n, v);
         r := n + 1)

    fun removeOne (da as (r as ref n, ref a)) = 
        (if n = 0 then raise Empty else ();
         Array.update (a, n, dummy ());
         checkResize (da, n - 1);
         r := n - 1)

    fun vector (ref n, ref a) =
        Vector.tabulate (n, fn i => Array.sub (a, i))


    fun toList (ref n, ref a) =
        let fun loop (i, res) =
                if i < 0 then res
                else loop (i - 1, Array.sub (a, i) :: res)
        in
            loop (n - 1, [])
        end

    fun fromList l = 
        let val dummy = dummy ()
            val res = (ref 0, ref (Array.array (0, dummy )))
        in
            List.app (fn v => addOne (res, v)) l;
            res
        end

    fun tabulate (n, f) =
        let val dummy = dummy ()
            val res = (ref 0, ref (Array.array (0, dummy)))
            fun loop i =    if i >= n then ()
                            else (addOne (res, f i); loop (i + 1))
        in
            loop 0;
            res
        end

    fun fromVector v = tabulate (Vector.length v, fn i => Vector.sub (v, i))

    fun toVector a = Vector.tabulate (length a, fn i => sub (a, i))

    fun swap ((ref n, ref a), i1, i2) =
        (checkBounds (i1, n);
         checkBounds (i2, n);
         Array.swap (a, i1, i2))

    fun rev (ref n, ref a) =
        let val n2  = n div 2
            val i   = ref 0
        in
            while !i < n2 do Array.swap (a, !i, n - !i - 1)
        end

    fun doRange (start, n, f) =
        let fun loop i =
                if i >= n then ()
                else (f (start + i); loop (i + 1))
        in
            loop 0  
        end
    
    fun doRangeRev (start, n, f) =
        let fun loop i =
            if i > n then ()
            else (f (start + n - i); loop (i + 1)) 
        in
            loop 1
        end
        
    fun appi f (ref n, ref a) = doRange (0, n, fn i => f (i, Array.sub (a, i)))

    fun app f (ref n, ref a)    = doRange (0, n, fn i => f (Array.sub (a, i)))

    fun appri f (ref n, ref a) = doRange (0, n, fn i => f (i, Array.sub (a, i)))

    fun appr f (ref n, ref a) = doRange (0, n, fn i => f (Array.sub (a, i)))

    fun foldl f init (ref n, ref a) = 
        let val res = ref init in
            doRange (0, n, fn i => res := f (Array.sub (a, i), !res));
            !res
        end

    fun foldr f init (ref n, ref a) = 
        let val res = ref init in
            doRangeRev (0, n, fn i => res := f (Array.sub (a, i), !res));
            !res
        end


    fun foldli f init (ref n, ref a) =
        let val res = ref init in
            doRange (0, n, fn i => res := f (i, Array.sub (a, i), !res));
            !res
        end

    fun foldri f init (ref n, ref a) =
        let val res = ref init in
            doRangeRev (0, n, fn i => res := f (i, Array.sub (a, i), !res));
            !res
        end

    fun modify f (ref n, ref a) = 
        doRange (0, n, fn i => Array.update (a, i, f (Array.sub (a, i))))

    fun modifyi f (ref n, ref a) =
        doRange (0, n, fn i => Array.update (a, i, f (i, Array.sub (a, i))))

    fun all pred (ref n, ref a) =
        let fun loop i =
                if i >= n then true
                else pred (Array.sub (a, i)) andalso loop (i + 1)
        in
            loop 0
        end

    fun exists pred (ref n, ref a) =
        let fun loop i =
            if i >= n then false
            else pred (Array.sub (a, i)) orelse loop (i + 1)
        in
            loop 0
        end

    fun alli pred (ref n, ref a) =
        let fun loop i =
                if i >= n then true
                else pred (i, Array.sub (a, i)) andalso loop (i + 1)
        in
            loop 0
        end

    fun existsi pred (ref n, ref a) =
        let fun loop i =
            if i >= n then false
            else pred (i, Array.sub (a, i)) orelse loop (i + 1)
        in
            loop 0
        end

    fun find pred (ref n, ref a) = 
        let fun loop i =
            if i >= n then NONE
            else 
                let val v = Array.sub (a, i) in
                    if pred v then SOME v
                    else loop (i + 1)
                end
        in
            loop 0
        end

    fun findi pred (ref n, ref a) = 
        let fun loop i =
            if i >= n then NONE
            else 
                let val v = Array.sub (a, i) in
                    if pred (i, v) then SOME (i, v)
                    else loop (i + 1)
                end
        in
            loop 0
        end

    fun contains a v = isSome (find (fn v' => v = v') a)
    
    fun notContains a v = isNone (find (fn v' => v = v') a)

    fun equal eq (a1, a2) = length a1 = length a2 andalso
                                alli (fn (i, v1) => v1 = sub (a2, i)) a1


    fun collate cmp (r1,r2)     = collate'(cmp,r1,r2,0)
    and collate'(cmp,r1,r2,i)   = case (i = length r1, i = length r2)
                                    of (true,  true)  => EQUAL
                                     | (true,  false) => LESS
                                     | (false, true)  => GREATER
                                     | (false, false) =>
                                  case cmp(sub(r1,i), sub(r2,i))
                                    of EQUAL => collate'(cmp,r1,r2,i+1)
                                     | other => other

    fun isSorted  cmp r         = isSorted'(cmp,r,1)
    and isSorted'(cmp,r,i)      = i >= length r orelse
                                  cmp(sub(r,i-1), sub(r,i)) <> GREATER
                                  andalso isSorted'(cmp,r,i+1)

    fun sort cmp a =
    let
        fun partition(i,j,p) where (i = j) = j
          | partition(i,j,p) where (cmp(sub(a,i),p) <> GREATER) =
                partition(i+1,j,p)
          | partition(i,j,p) where (cmp(p,sub(a,j-1)) = LESS) =
                partition(i,j-1,p)
          | partition(i,j,p) =
                (swap(a,i,j-1); partition(i+1,j-1,p))

        fun sort(i,j) where (j-i <= 1) = ()
          | sort(i,j) where (j-i = 2)  =
                if cmp(sub(a,i), sub(a,j-1)) <> GREATER then ()
                else swap(a,i,j-1)
          | sort(i,j) =
            let
                val mid = (i+j) div 2
                val _ = if cmp(sub(a,i), sub(a,mid)) <> GREATER then ()
                        else swap(a,i,mid)
                val _ = if cmp(sub(a,mid), sub(a,j-1)) <> GREATER then ()
                        else (swap(a,mid,j-1);
                              if cmp(sub(a,i),sub(a,mid)) <> GREATER then ()
                              else swap(a,i,mid))
                val k = partition(i+1,j-1, sub(a,mid))
            in
                sort(i,k); sort(k,j)
            end
    in
        sort(0, length a)
    end

end


