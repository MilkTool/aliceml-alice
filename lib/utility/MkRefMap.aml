(*
 * Author:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(* This is a hack to make type dictionaries fast... *)

import signature STAMP            from "STAMP-sig"
import signature SIMPLE_IMP_MAP   from "SIMPLE_IMP_MAP-sig"
import structure UnsafeDictionary from "UnsafeMkRefMap"

functor MkRefMap(structure Stamp : STAMP
		 type t  val stamp : t -> Stamp.t) :>
	SIMPLE_IMP_MAP where type key = t ref =
struct
    type key = t ref
    type 'a map
    type 'a t = 'a map

    exception Delete    of key
    exception Collision of key
    exception Lookup    of key

    val new       = UnsafeDictionary.new
    val isEmpty   = UnsafeDictionary.isEmpty
    val deleteAll = UnsafeDictionary.deleteAll

    fun lookup(m,r) =
	case UnsafeDictionary.lookup(m, stamp(!r))
	  of NONE    => NONE
	   | SOME r' => lookup'(!r',r)

    and lookup'([], r) = NONE
      | lookup'((r1,x)::es, r) where (r = r1) = SOME x
      | lookup'(_::es, r) = lookup'(es, r)

    fun lookupExistent(m,r) =
	case lookup(m,r)
	  of SOME x => x
	   | NONE   => raise Lookup r

    fun member(m,r) = Option.isSome(lookup(m,r))

    fun insert(m,r,x) =
	let
	    val stamp = stamp(!r)
	in
	    case UnsafeDictionary.lookup(m, stamp)
	      of NONE    => UnsafeDictionary.insert(m, stamp, ref[(r,x)])
	       | SOME r' => r' := (r,x)::(!r')
	end

    fun insertDisjoint(m,r,x) =
	let
	    val stamp = stamp(!r)
	in
	    case UnsafeDictionary.lookup(m, stamp)
	      of NONE    => UnsafeDictionary.insert(m, stamp, ref[(r,x)])
	       | SOME r' =>
	    case lookup'(!r',r)
	      of NONE    => r' := (r,x)::(!r')
	       | SOME _  => raise Collision r
	end

    fun deleteExistent(m,r) =
	let
	    val stamp = stamp(!r)
	in
	    case UnsafeDictionary.lookup(m, stamp)
	      of NONE    => ()
	       | SOME r' =>
	    case delete'(!r',r,[],false)
	      of [] => UnsafeDictionary.delete(m, stamp)
	       | es => r' := es
	end

    and delete'([], r, es2, false) = raise Delete r
      | delete'([], r, es2, true)  = List.rev es2
      | delete'((e as (r1,_))::es1, r2, es2, b) =
	if r1 = r2
	then delete'(es1, r2, es2, true)
	else delete'(es1, r2, e::es2, b)

    fun delete(m,r) = deleteExistent(m,r) handle Delete _ => ()

    fun app f m =
	let
	    val ff = List.app (fn(_,x) => f x)
	in
	    UnsafeDictionary.app(fn r => ff(!r), m)
	end

    fun appi f m =
	let
	    val ff = List.app f
	in
	    UnsafeDictionary.app(fn r => ff(!r), m)
	end

    fun fold f y m =
	let
	    val ff = List.foldl (fn((_,x),y) => f(x,y))
	in
	    UnsafeDictionary.fold(fn(r,y) => ff y (!r), y, m)
	end

    fun foldi f y m =
	let
	    val ff = List.foldl (fn((k,x),y) => f(k,x,y))
	in
	    UnsafeDictionary.fold(fn(r,y) => ff y (!r), y, m)
	end

    fun union' insert (m1,m2)	= appi (fn(k,a) => insert(m1,k,a)) m2
    fun union x			= union' insert x
    fun unionDisjoint x		= union' insertDisjoint x

    fun clone m =
	let
	    val m' = new()
	    fun insert'(r,x) = insert(m,r,x)
	in
	    appi insert' m;
	    m'
	end
end
