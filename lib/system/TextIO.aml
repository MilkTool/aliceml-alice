(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2001-2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure IODesc       from "IODesc"
import structure IO           from "IO"
import structure TextPrimIO   from "TextPrimIO"
import structure StreamIO     from "StreamIO"
import structure ImperativeIO from "ImperativeIO"
import signature TEXT_IO      from "TEXT_IO-sig"

(*--** newline translation missing *)

structure TextIO :> TEXT_IO =
    struct
	structure TextStreamIO = (*--** : TEXT_STREAM_IO *)
	    StreamIO(structure PrimIO = TextPrimIO
		     structure Vector = CharVector
		     structure Array = CharArray
		     val someElem = #"\n")
	structure TextImperativeIO =
	    ImperativeIO(structure StreamIO = TextStreamIO
			 structure Vector = CharVector)
	open TextImperativeIO

	fun openIn name =
	    let
		val reader = TextPrimIO.RD (IODesc.openIn name)
		    handle cause =>
			raise IO.Io {cause, function = "openIn", name}
		val v = CharVector.fromList nil
	    in
		TextImperativeIO.mkInstream
		    (TextStreamIO.mkInstream (reader, v))
	    end

	fun inputLine f =
	    case input1 f of
		SOME c =>
		    if c = #"\n" then "\n"
		    else String.implode (c::inputLine' f)
	      | NONE => ""
	and inputLine' f =
	    case input1 f of
		SOME c =>
		    if c = #"\n" then [c]
		    else c::inputLine' f
	      | NONE => [#"\n"]

	fun openString s =
	    let
		val reader = TextPrimIO.openVector s
		val v = CharVector.fromList nil
	    in
		TextImperativeIO.mkInstream
		    (TextStreamIO.mkInstream (reader, v))
	    end

	fun openOut name =
	    let
		val writer = TextPrimIO.WR (IODesc.openOut name)
		    handle cause =>
			raise IO.Io {cause, function = "openOut", name}
	    in
		TextImperativeIO.mkOutstream
		    (TextStreamIO.mkOutstream (writer, IO.BLOCK_BUF))
	    end

	fun openAppend name =
	    let
		val writer = TextPrimIO.WR (IODesc.openAppend name)
		    handle cause =>
			raise IO.Io {cause, function = "openAppend", name}
	    in
		TextImperativeIO.mkOutstream
		    (TextStreamIO.mkOutstream (writer, IO.BLOCK_BUF))
	    end

	fun outputSubstr (f, s) = output (f, Substring.string s)

	val stdIn =
	    TextImperativeIO.mkInstream
		(TextStreamIO.mkInstream (TextPrimIO.RD IODesc.stdIn,
					  CharVector.fromList nil))

	val stdOut =
	    TextImperativeIO.mkOutstream
		(TextStreamIO.mkOutstream (TextPrimIO.WR IODesc.stdOut,
					   IO.LINE_BUF))

	val stdErr =
	    TextImperativeIO.mkOutstream
		(TextStreamIO.mkOutstream (TextPrimIO.WR IODesc.stdErr,
					   IO.NO_BUF))

	fun print s = (output (stdOut, s); flushOut stdOut)

	fun scanStream scan f =
	    case scan StreamIO.input1 (getInstream f) of
		NONE => NONE
	      | SOME (x, f') => (setInstream (f, f'); SOME x)
    end

val print = TextIO.print
