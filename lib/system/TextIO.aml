(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2001-2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure IODesc           from "IODesc"
import structure IO               from "IO"
import structure TextPrimIO       from "TextPrimIO"
import structure StreamIO         from "StreamIO"
import structure ImperativeIO     from "ImperativeIO"
import structure MkTextTranslator from "MkTextTranslator"
import signature TEXT_IO          from "TEXT_IO-sig"

(*--** newline translation missing *)

structure TextIO :> TEXT_IO =
    struct
	structure TextStreamIO = (*--** : TEXT_STREAM_IO *)
	    StreamIO(structure PrimIO = TextPrimIO
		     structure Vector = CharVector
		     structure Array = CharArray
		     val someElem = #"\n")
	structure TextImperativeIO =
	    ImperativeIO(structure StreamIO = TextStreamIO
			 structure Vector = CharVector)
	open TextImperativeIO

	structure TextTranslator =
	    MkTextTranslator(structure PrimIO = TextPrimIO
			     structure Vector = CharVector
			     structure Array = CharArray)

	fun textReader obj = TextTranslator.translateReader (TextPrimIO.RD obj)
	fun textWriter obj = TextTranslator.translateWriter (TextPrimIO.WR obj)

	fun openIn name =
	    let
		val reader = textReader (IODesc.openIn name)
		    handle cause =>
			raise IO.Io {cause, function = "openIn", name}
		val v = CharVector.fromList nil
	    in
		TextImperativeIO.mkInstream
		    (TextStreamIO.mkInstream (reader, v))
	    end

	fun inputLine f =
	    case input1 f of
		SOME c =>
		    if c = #"\n" then "\n"
		    else String.implode (c::inputLine' f)
	      | NONE => ""
	and inputLine' f =
	    case input1 f of
		SOME c =>
		    if c = #"\n" then [c]
		    else c::inputLine' f
	      | NONE => [#"\n"]

	fun openString s =
	    let
		val reader =
		    TextTranslator.translateReader (TextPrimIO.openVector s)
		val v = CharVector.fromList nil
	    in
		TextImperativeIO.mkInstream
		    (TextStreamIO.mkInstream (reader, v))
	    end

	fun openOut name =
	    let
		val writer = textWriter (IODesc.openOut name)
		    handle cause =>
			raise IO.Io {cause, function = "openOut", name}
	    in
		TextImperativeIO.mkOutstream
		    (TextStreamIO.mkOutstream (writer, IO.BLOCK_BUF))
	    end

	fun openAppend name =
	    let
		val writer = textWriter (IODesc.openAppend name)
		    handle cause =>
			raise IO.Io {cause, function = "openAppend", name}
	    in
		TextImperativeIO.mkOutstream
		    (TextStreamIO.mkOutstream (writer, IO.BLOCK_BUF))
	    end

	fun outputSubstr (f, s) = output (f, Substring.string s)

	val stdIn =
	    TextImperativeIO.mkInstream
		(TextStreamIO.mkInstream (textReader IODesc.stdIn,
					  CharVector.fromList nil))

	val stdOut =
	    TextImperativeIO.mkOutstream
		(TextStreamIO.mkOutstream (textWriter IODesc.stdOut,
					   IO.LINE_BUF))

	val stdErr =
	    TextImperativeIO.mkOutstream
		(TextStreamIO.mkOutstream (textWriter IODesc.stdErr,
					   IO.NO_BUF))

	fun print s = (output (stdOut, s); flushOut stdOut)

	fun scanStream scan f =
	    case scan StreamIO.input1 (getInstream f) of
		NONE => NONE
	      | SOME (x, f') => (setInstream (f, f'); SOME x)
    end

val print = TextIO.print
