(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2001-2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Url               from "../utility/Url"
import structure Inf               from "../rtt/Inf"
import structure TextIO            from "TextIO"
import structure IO                from "IO"
import structure OS                from "OS"
import structure Reflect           from "Reflect"
import structure Resolver          from "Resolver"
import structure UnsafeComponent   from "UnsafeComponent"
import structure UrlMap            from "UrlMap"
import signature COMPONENT_MANAGER from "COMPONENT_MANAGER-sig"
import signature COMPONENT         from "COMPONENT-sig"

structure Component :> COMPONENT =
struct
    nonfix mod
    type inf = Inf.t option
    type mod = Reflect.value

    datatype component =
	UNEVALUATED of { imports: (string * inf) vector,
			 body:    mod vector -> mod,
			 inf:     inf }
      | EVALUATED of { inf: inf, mod: mod }
    type t = component

    exception Sited    = UnsafeComponent.Sited
    exception Corrupt  = UnsafeComponent.Corrupt

    val extension = UnsafeComponent.extension

    local
	val b = Option.isSome (OS.Process.getEnv "ALICE_TRACE_COMPONENT")
    in
	fun trace s =
	    if b then TextIO.output (TextIO.stdErr,
				     "[component manager] " ^ s ^ "\n")
	    else ()
    end

    fun create (inf, mod) = EVALUATED {inf, mod}

    functor Create(signature S structure X: S) =
	let
	    structure Sig = Reflect.ReflectSig(signature S = S)
	    structure Mod = Reflect.Reflect(signature S = S
					    structure X = X)
	in
	    (val component = EVALUATED {inf = SOME Sig.x, mod = Mod.x})
	end

    val localize =
	let
	    val handlers =
		case OS.Process.getEnv "ALICE_LOAD" of
		    SOME s => Resolver.Handler.parse s
		  | NONE => [Resolver.Handler.default]
	    val resolver = Resolver.new ("load", handlers)
	in
	    Resolver.localize resolver
	end

    fun load url =
	let
	    val s = Url.toStringRaw url   (*--** use getLocalPath instead *)
	in
	    case localize s of
		SOME (Resolver.FILE s') =>
		    (UnsafeComponent.load s'
		     handle Corrupt => UnsafeComponent.linkNative s'
		     handle UnsafeComponent.Native msg =>
			    (trace ("linkNative: " ^ msg); raise Corrupt))
	      | SOME (Resolver.STRING s') => UnsafeComponent.unpack_ s'
	      | NONE =>
		    raise IO.Io {name = s,
				 function = "load",
				 cause = Option.Option}
	end

    val save = UnsafeComponent.save

    fun inf (UNEVALUATED {inf, ...}) = inf
      | inf (EVALUATED {inf, ...}) = inf

    functor MkManager() :> COMPONENT_MANAGER where type component = component =
    struct
	exception Conflict
	exception Mismatch of Url.t * Url.t option * Inf.mismatch

	datatype component = datatype component

	val map: (inf * mod) UrlMap.t =
	    UrlMap.new (Vector.map (fn (s, inf, mod) =>
				       (Url.fromString ("x-alice:/" ^ s),
					(inf, mod)))
				   (UnsafeComponent.getInitialTable ()))

	fun strictTypeCheck (SOME inf, SOME importInf, mod) =
	    (Inf.match (inf, importInf); mod) (*--** coercion *)
	  | strictTypeCheck (NONE, SOME _, mod) =
	    (trace ("warning: no export signature, accepted unchecked"); mod)
	  | strictTypeCheck (SOME _, NONE, mod) =
	    (trace ("warning: no import signature, accepted unchecked"); mod)
	  | strictTypeCheck (NONE, NONE, mod) =
	    (trace ("warning: no import/export signatures, accepted unchecked");
	     mod)

	fun lazyTypeCheck (inf, importInf, mod, url, baseUrlOpt) =
	    let
		val message =
		    Url.toString url ^
		    (case baseUrlOpt of
			 SOME baseUrl =>
			 " imported by " ^ Url.toString baseUrl
		       | NONE => "")
	    in
		lazy (trace ("type-checking " ^ message);
		      (strictTypeCheck (inf, importInf, mod)
		       handle Inf.Mismatch m =>
			   raise Mismatch (url, baseUrlOpt, m)) before
		      trace ("type-checked  " ^ message))
	    end

	fun link' url =
	    case UrlMap.lookupNew (map, url) of
		UrlMap.EXISTING entry => entry
	      | UrlMap.NEW p =>
		    let
			val component = lazy load url
			val inf = lazy inf component
			val mod = lazy eval (url, component)
			val entry = (inf, mod)
		    in
			Promise.fulfill (p, entry); entry
		    end
	and link url = create (link' url)
	and typedLink (url, importInf, baseUrlOpt) =
	    let
		val (inf, mod) = link' url
	    in
		lazyTypeCheck (inf, importInf, mod, url, baseUrlOpt)
	    end
	and eval (baseUrl, UNEVALUATED {imports, body, ...}) =
	    let
		fun resolve s = Url.resolve baseUrl (Url.fromString s)
		val imports' =
		    Vector.map (fn (importUrlS, importInf) =>
				   typedLink (resolve importUrlS,
					      importInf, SOME baseUrl))
			       imports
	    in
		trace ("evaluating " ^ Url.toString baseUrl);
		body imports' before
		trace ("evaluated  " ^ Url.toString baseUrl)
	    end
	  | eval (_, EVALUATED {mod, ...}) = Future.await mod

	functor Eval(val component: component val url: Url.t signature S): S =
	    let
		structure Sig = Reflect.ReflectSig(signature S = S)
		val mod = eval (url, component)
		val inf = inf component
		val mod' = strictTypeCheck (inf, SOME Sig.x, mod)
			   handle Inf.Mismatch m =>
			       raise Mismatch (url, NONE, m)
	    in
		Reflect.Unreflect(val x = mod' signature S = S)
	    end

	functor Link(val url: Url.t signature S): S =
	    let
		structure Sig = Reflect.ReflectSig(signature S = S)
		val mod = typedLink (url, SOME Sig.x, NONE)
	    in
		Reflect.Unreflect(val x = mod signature S = S)
	    end

	functor Enter(val url: Url.t signature S structure X: S) =
	    let
		structure Sig = Reflect.ReflectSig(signature S = S)
		structure Mod = Reflect.Reflect(signature S = S
						structure X = X)
		val _ =
		    case UrlMap.lookupNew (map, url) of
			UrlMap.EXISTING _ => raise Conflict
		      | UrlMap.NEW p => Promise.fulfill (p, (SOME Sig.x, Mod.x))
	    in
		()
	    end

	fun enter (url, component) =
	    case UrlMap.lookupNew (map, url) of
		UrlMap.EXISTING _ => raise Conflict
	      | UrlMap.NEW p =>
		    Promise.fulfill (p, (inf component,
					 lazy eval (url, component)))

	fun lookup url =
	    case UrlMap.lookup (map, url) of
		SOME (inf, mod) => SOME (EVALUATED {inf, mod})
	      | NONE => NONE

	fun start url = ignore (eval (url, link url))
    end
end
