(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Url               from "../utility/Url"
import structure Label             from "../rtt/Label"
import structure Inf               from "../rtt/Inf"
import structure Reflect           from "Reflect"
import structure UnsafeComponent   from "UnsafeComponent"
import structure Signature         from "Signature"
import structure UrlMap            from "UrlMap"
import signature COMPONENT_MANAGER from "COMPONENT_MANAGER-sig"
import signature COMPONENT         from "COMPONENT-sig"

structure Component :> COMPONENT =
struct
    type sign = Signature.t option
    type str = Reflect.value

    datatype component =
	UNEVALUATED of { imports: (Label.t * Url.t * sign) vector,
			 body:    Reflect.value,
			 sign:    sign }
      | EVALUATED of sign * str
    type t = component

    exception Sited    = UnsafeComponent.Sited
    exception Corrupt  = UnsafeComponent.Corrupt

    val extension = UnsafeComponent.extension

    fun signFromInf inf = SOME (Signature.fromSig (Inf.asSig inf))

    functor Create(signature S structure X: S) =
	let
	    structure Sig = Reflect.ReflectSig(signature S = S)
	    val sign = signFromInf Sig.x
	    structure Str = Reflect.Reflect(signature S = S
					    structure X = X)
	in
	    (val component = EVALUATED (sign, Str.x))
	end

    fun create (sign, str) = EVALUATED (sign, str)

    val load = UnsafeComponent.load
    val save = UnsafeComponent.save

    fun sign (UNEVALUATED {sign, ...}) = sign
      | sign (EVALUATED (sign, _)) = sign

    functor MkManager() :> COMPONENT_MANAGER where type component = component =
    struct
	exception Conflict
	exception Mismatch

	type component = component

	val map: (sign * str) UrlMap.t = UrlMap.new ()

	fun lazyTypeCheck (SOME sign, SOME importSign, str) =
	    byneed (fn () =>
		    case Signature.match (sign, importSign, str) of
			SOME str => str
		      | NONE => raise Mismatch)
	  | lazyTypeCheck (_, _, str) = str

	fun strictTypeCheck (SOME sign, SOME importSign, str) =
	    (case Signature.match (sign, importSign, str) of
		 SOME str => str
	       | NONE => raise Mismatch)
	  | strictTypeCheck (_, _, str) = str

	fun link' url =
	    case UrlMap.lookupNew (map, url) of
		UrlMap.EXISTING entry => entry
	      | UrlMap.NEW p =>
		    let
			val component = byneed (fn () => load url)
			val sign = byneed (fn () => sign component)
			val str = byneed (fn () => eval (url, component))
			val entry = (sign, str)
		    in
			Promise.fulfill (p, entry); entry
		    end
	and link url = EVALUATED (link' url)
	and typedLink (url, importSign) =
	    let
		val (sign, str) = link' url
	    in
		lazyTypeCheck (sign, importSign, str)
	    end
	and eval (baseUrl, UNEVALUATED {imports, body, ...}) =
	    let
		val imports' =
		    Vector.map (fn (label, importUrl, importSign) =>
				(label,
				 typedLink (Url.resolve baseUrl importUrl,
					    importSign))) imports
	    in
		UnsafeComponent.apply (body, imports')
	    end
	  | eval (_, EVALUATED (_, str)) = Future.await str

	fun signFromInf inf = SOME (Signature.fromSig (Inf.asSig inf))

	functor Eval(val url: Url.t val component: component signature S): S =
	    let
		structure Sig = Reflect.ReflectSig(signature S = S)
		val str = eval (url, component)
		val sign = sign component
		val str' = strictTypeCheck (sign, signFromInf Sig.x, str)
	    in
		Reflect.Unreflect(val x = str' signature S = S)
	    end

	functor Link(val url: Url.t signature S): S =
	    let
		structure Sig = Reflect.ReflectSig(signature S = S)
		val str = typedLink (url, signFromInf Sig.x)
	    in
		Reflect.Unreflect(val x = str signature S = S)
	    end

	functor Enter(val url: Url.t signature S structure X: S) =
	    let
		structure Sig = Reflect.ReflectSig(signature S = S)
		val sign = signFromInf Sig.x
		structure Str = Reflect.Reflect(signature S = S
						structure X = X)
		val _ =
		    case UrlMap.lookupNew (map, url) of
			UrlMap.EXISTING _ => raise Conflict
		      | UrlMap.NEW p => Promise.fulfill (p, (sign, Str.x))
	    in
		()
	    end

	fun enter (url, component) =
	    case UrlMap.lookupNew (map, url) of
		UrlMap.EXISTING _ => raise Conflict
	      | UrlMap.NEW p =>
		    Promise.fulfill (p, (sign component,
					 byneed (fn () =>
						 eval (url, component))))

	fun lookup url =
	    case UrlMap.lookup (map, url) of
		SOME (sign, str) => SOME (EVALUATED (sign, str))
	      | NONE => NONE

	fun start url = ignore (eval (url, link url))
    end
end
