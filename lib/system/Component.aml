(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2001-2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Url               from "../utility/Url"
import structure Inf               from "../rtt/Inf"
import structure TextIO            from "TextIO"
import structure IO                from "IO"
import structure OS                from "OS"
import structure Reflect           from "Reflect"
import structure Resolver          from "Resolver"
import structure UnsafeComponent   from "UnsafeComponent"
import structure Signature         from "Signature"
import structure UrlMap            from "UrlMap"
import signature COMPONENT_MANAGER from "COMPONENT_MANAGER-sig"
import signature COMPONENT         from "COMPONENT-sig"

structure Component :> COMPONENT =
struct
    type sign = Signature.t option
    type str = Reflect.value

    datatype component =
	UNEVALUATED of { imports: (string * sign) vector,
			 body:    str vector -> str,
			 sign:    sign }
      | EVALUATED of sign * str
    type t = component

    exception Sited    = UnsafeComponent.Sited
    exception Corrupt  = UnsafeComponent.Corrupt

    val extension = UnsafeComponent.extension

    fun signFromInf inf = SOME (Signature.fromSig (Inf.asSig inf))

    functor Create(signature S structure X: S) =
	let
	    structure Sig = Reflect.ReflectSig(signature S = S)
	    val sign = signFromInf Sig.x
	    structure Str = Reflect.Reflect(signature S = S
					    structure X = X)
	in
	    (val component = EVALUATED (sign, Str.x))
	end

    fun create (sign, str) = EVALUATED (sign, str)

    val localize =
	let
	    val handlers =
		case OS.Process.getEnv "ALICE_LOAD" of
		    SOME s => Resolver.Handler.parse s
		  | NONE => [Resolver.Handler.default]
	    val resolver = Resolver.new ("load", handlers)
	in
	    Resolver.localize resolver
	end

    fun load url =
	let
	    val s = Url.toStringRaw url   (*--** use getLocalPath instead *)
	in
	    case localize s of
		SOME (Resolver.FILE s') => UnsafeComponent.load s'
	      | SOME (Resolver.STRING s') => UnsafeComponent.unpack_ s'
	      | NONE =>
		    raise IO.Io {name = s,
				 function = "load",
				 cause = Option.Option}
	end

    val save = UnsafeComponent.save

    fun sign (UNEVALUATED {sign, ...}) = sign
      | sign (EVALUATED (sign, _)) = sign

    functor MkManager() :> COMPONENT_MANAGER where type component = component =
    struct
	exception Conflict
	exception Mismatch

	datatype component = datatype component

	local
	    val b = Option.isSome (OS.Process.getEnv "ALICE_TRACE_COMPONENT")
	in
	    fun trace s =
		if b then TextIO.output (TextIO.stdErr,
					 "[component manager] " ^ s ^ "\n")
		else ()
	end

	val map: (sign * str) UrlMap.t =
	    UrlMap.new (Vector.map (fn (s, sign, str) =>
				       (Url.fromString ("x-alice:/" ^ s),
					(sign, str)))
				   (UnsafeComponent.getInitialTable ()))

	fun strictTypeCheck (SOME sign, SOME importSign, str) =
	    (case Signature.match (sign, importSign, str) of
		 SOME str => str
	       | NONE => raise Mismatch)
	  | strictTypeCheck (_, _, str) = str

	fun lazyTypeCheck (signOpt, importSignOpt, str, url, baseUrlOpt) =
	    lazy (trace ("type-checking " ^ Url.toString url ^
			 (case baseUrlOpt of
			      SOME baseUrl =>
				  " imported from " ^ Url.toString baseUrl
			    | NONE => ""));
		  strictTypeCheck (signOpt, importSignOpt, str))

	fun link' url =
	    case UrlMap.lookupNew (map, url) of
		UrlMap.EXISTING entry => entry
	      | UrlMap.NEW p =>
		    let
			val component = lazy load url
			val sign = lazy sign component
			val str = lazy eval (url, component)
			val entry = (sign, str)
		    in
			Promise.fulfill (p, entry); entry
		    end
	and link url = EVALUATED (link' url)
	and typedLink (url, importSign, baseUrlOpt) =
	    let
		val (sign, str) = link' url
	    in
		lazyTypeCheck (sign, importSign, str, url, baseUrlOpt)
	    end
	and eval (baseUrl, UNEVALUATED {imports, body, ...}) =
	    let
		fun resolve s = Url.resolve baseUrl (Url.fromString s)
		val imports' =
		    Vector.map (fn (importUrlS, importSign) =>
				   typedLink (resolve importUrlS,
					      importSign, SOME baseUrl))
			       imports
	    in
		trace ("evaluating " ^ Url.toString baseUrl);
		body imports'
	    end
	  | eval (_, EVALUATED (_, str)) = Future.await str

	fun signFromInf inf = SOME (Signature.fromSig (Inf.asSig inf))

	functor Eval(val component: component val url: Url.t signature S): S =
	    let
		structure Sig = Reflect.ReflectSig(signature S = S)
		val str = eval (url, component)
		val sign = sign component
		val str' = strictTypeCheck (sign, signFromInf Sig.x, str)
	    in
		Reflect.Unreflect(val x = str' signature S = S)
	    end

	functor Link(val url: Url.t signature S): S =
	    let
		structure Sig = Reflect.ReflectSig(signature S = S)
		val str = typedLink (url, signFromInf Sig.x, NONE)
	    in
		Reflect.Unreflect(val x = str signature S = S)
	    end

	functor Enter(val url: Url.t signature S structure X: S) =
	    let
		structure Sig = Reflect.ReflectSig(signature S = S)
		val sign = signFromInf Sig.x
		structure Str = Reflect.Reflect(signature S = S
						structure X = X)
		val _ =
		    case UrlMap.lookupNew (map, url) of
			UrlMap.EXISTING _ => raise Conflict
		      | UrlMap.NEW p => Promise.fulfill (p, (sign, Str.x))
	    in
		()
	    end

	fun enter (url, component) =
	    case UrlMap.lookupNew (map, url) of
		UrlMap.EXISTING _ => raise Conflict
	      | UrlMap.NEW p =>
		    Promise.fulfill (p, (sign component,
					 lazy eval (url, component)))

	fun lookup url =
	    case UrlMap.lookup (map, url) of
		SOME (sign, str) => SOME (EVALUATED (sign, str))
	      | NONE => NONE

	fun start url = ignore (eval (url, link url))
    end
end
