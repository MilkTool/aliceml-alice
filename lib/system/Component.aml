(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt and Andreas Rossberg, 2001-2004
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Inf               from "../rtt/Inf"
import structure TextIO            from "TextIO"
import structure PrettyPrint       from "../utility/PrettyPrint"
import structure PPInf             from "../rtt/PPInf"
import structure IO                from "IO"
import structure OS                from "OS"
import structure Reflect           from "Reflect"
import structure Url               from "Url"
import structure Resolver          from "Resolver"
import structure UnsafeComponent   from "UnsafeComponent"
import structure DynMatch          from "DynMatch"
import structure UrlMap            from "UrlMap"
import signature COMPONENT         from "COMPONENT-sig"

structure Component : COMPONENT =
struct
    nonfix mod
    type inf = Inf.t option
    type mod = Reflect.module

    __primitive type component = "Component.component"
    type t = component
    datatype component' =
	UNEVALUATED of { imports: (string * inf) vector,
			 body:    mod vector -> mod,
			 inf:     inf }
      | EVALUATED of { inf: inf, mod: mod }

    __primitive val cast : 'a -> 'b = "Unsafe.cast"

    exception Sited    = UnsafeComponent.Sited
    exception Corrupt  = UnsafeComponent.Corrupt
    exception NotFound = UnsafeComponent.NotFound
    exception Mismatch = UnsafeComponent.Mismatch
    exception Eval     = UnsafeComponent.Eval
    exception Failure  = UnsafeComponent.Failure
    exception Internal of exn

    val extension = UnsafeComponent.extension

    fun trace (NONE, s)   = ()
      | trace (SOME f, s) =
	(TextIO.output (f, "[component manager] " ^ s ^ "\n");
	 TextIO.flushOut f)

    val defaultLogStream =
	Option.map (fn "" => TextIO.stdErr
		     | s  => TextIO.openOut s handle IO.Io _ =>
			     (trace (SOME TextIO.stdErr,
				     "warning: could not open log file " ^ s ^
				     ", falling back to stderr");
			      TextIO.stdErr))
		   (OS.Process.getEnv "ALICE_TRACE_COMPONENT")

    fun create (mod, inf) = cast (EVALUATED {inf, mod})

    functor Create(signature S structure X: S) =
	let
	    structure Sig = Reflect.ReflectSig(signature S = S)
	    structure Mod = Reflect.Reflect(signature S = S
					    structure X = X)
	in
	    (val component = create (Mod.x, SOME Sig.x))
	end

    val defaultResolver =
	let
	    val handlers =
		case OS.Process.getEnv "ALICE_LOAD" of
		    SOME s => Resolver.Handler.parse s
		  | NONE => [Resolver.Handler.default]
	in
	    Resolver.resolver {name = "load", handlers, memoize = true}
	end

    fun load' (logStream, resolver) url =
	case Resolver.localize resolver url of
	    SOME (Resolver.FILE name) =>
		(UnsafeComponent.load name
		 handle Corrupt =>
		     UnsafeComponent.linkNative name
		     handle cause as UnsafeComponent.Native msg =>
			    (trace (logStream, "linkNative: " ^ msg);
			     raise IO.Io {name, function = "load", cause})
			  | cause as Corrupt =>
			    (trace (logStream,
				    "linkNative: could not resolve symbol");
			     raise IO.Io {name, function = "load", cause}))
	  | SOME (Resolver.STRING string) =>
		(UnsafeComponent.unpack_ string
		 handle cause =>
		     raise IO.Io {name = Url.toStringRaw url,
				  function = "load", cause})
	  | NONE => raise IO.Io {name = Url.toStringRaw url,
				 function = "load", cause = NotFound}

    val load = load' (defaultLogStream, defaultResolver)

    fun save (name, component) =
	UnsafeComponent.save (name, component)
	handle cause => raise IO.Io {name, function = "save", cause}

    fun inf component = inf' (cast component)
    and inf' (UNEVALUATED {inf, ...}) = inf
      | inf' (EVALUATED {inf, ...}) = inf

    fun imports component = imports' (cast component)
    and imports' (UNEVALUATED {imports, ...}) =
	Vector.map (Pair.mapFst Url.fromString) imports
      | imports' (EVALUATED _) = #[]

    val initialTable = lazy UnsafeComponent.getInitialTable ()

    signature COMPONENT_MANAGER =
    sig
	exception Conflict

	val logStream: TextIO.outstream option ref

	functor Eval(val component: component
		     val url: Url.t
		     signature S): S

	functor Link(val url: Url.t
		     signature S): S

	functor Enter(val url: Url.t
		      signature S
		      structure X: S): any

	val eval: Url.t * component -> Reflect.module
	val load: Url.t -> component
	val link: Url.t -> component
	val enter: Url.t * component -> unit
	val lookup: Url.t -> component option

	val start: Url.t -> unit
    end

    functor MkManager(val resolver: Resolver.t) : COMPONENT_MANAGER =
    struct
	(*--** should query and fragment be rejected instead of ignored? *)

	exception Conflict

	val logStream = ref defaultLogStream

	val map: (mod * inf) UrlMap.t =
	    lazy UrlMap.map (Vector.map (fn (s, inf, mod) =>
					 (Url.fromString ("x-alice:/" ^ s),
					  (mod, inf)))
			     initialTable)

	fun matchWith (rea, SOME inf, SOME importInf) =
	    Inf.matchWith (rea, inf, importInf)
	  | matchWith (rea, NONE, SOME _) =
	    trace (!logStream,
		   "warning: no export signature, accepted unchecked")
	  | matchWith (rea, SOME _, NONE) =
	    trace (!logStream,
		   "warning: no import signature, accepted unchecked")
	  | matchWith (rea, NONE, NONE) =
	    trace (!logStream,
		   "warning: no import/export signatures, accepted unchecked")

	fun infToString NONE = "(none)"
	  | infToString (SOME inf) = PrettyPrint.toString (PPInf.ppInf inf, 80)

	fun typeCheck (inf, rea, importInf, mod, url, baseUrlOpt) : mod =
	    let
		val url' = Url.toString url
		val baseUrlOpt' = Option.map Url.toString baseUrlOpt
		val message = url' ^ (case baseUrlOpt' of
					  SOME s => " imported by " ^ s
					| NONE => " linked explicitly")
	    in
		trace (!logStream, "type-checking " ^ message);
		matchWith (rea, inf, importInf)
		handle Inf.Mismatch m =>
		     (trace (!logStream, "type-checking failed");
		      trace (!logStream, "signature expected" ^
					 (case baseUrlOpt' of
					      NONE => ""
					    | SOME s => " by " ^ s) ^
			    		 ":\n" ^ infToString importInf);
		      trace (!logStream, "signature found in " ^ url' ^
					 ":\n" ^ infToString inf);
		      raise Failure (url,
				     Mismatch {component = url,
					       request = baseUrlOpt,
					       cause = m}))
		   | Failure (url', e) =>
		     (trace (!logStream, "exception " ^ exnName e ^
					 " propagated from " ^
					 Url.toString url' ^
					 " during type-checking");
		      raise Failure (url, e))
		   | e =>
		     (trace (!logStream, "internal exception " ^ exnName e ^
					 " during type-checking");
		      raise Failure (url, Internal e));
		trace (!logStream, "type-checked  " ^ message);
		mod
	    end

	val load = load' (!logStream, resolver)

	fun lazyLink url : mod * inf =
	    case UrlMap.lookupNew (map, url) of
		UrlMap.EXISTING entry => entry
	      | UrlMap.NEW p =>
		    let
			val result =
			    lazy eval' (url, load url handle e =>
						      raise Failure (url, e))
			val entry = (lazy #1 result, lazy #2 result)
		    in
			Promise.fulfill (p, entry); entry
		    end
	and typedLink (url, rea, importInf, baseUrlOpt) : mod =
	    let
		val (mod, inf) = lazyLink url
		val rea' = Inf.cloneRea rea
		val mod' = lazy typeCheck (inf, rea', importInf, mod,
					   url, baseUrlOpt)
	    in
		case importInf of
		    NONE => ()
		  | SOME inf' => DynMatch.matchWith (rea, mod', inf');
		mod'
	    end
	and eval' (baseUrl, component) = eval'' (baseUrl, cast component)
	and eval'' (_, EVALUATED {mod, inf}) = (Future.await mod, inf)
	  | eval'' (baseUrl, UNEVALUATED {imports, body, inf}) =
	    let
		fun resolve s =
		    let
			val url = Url.fromString s
			val url = Url.setQuery (url, NONE)
			val url = Url.setFragment (url, NONE)
		    in
			Url.resolve baseUrl url
		    end
		val rea = Inf.rea ()
		val imports' =
		    Vector.map (fn (importUrlS, importInf) =>
				   typedLink (resolve importUrlS, rea,
					      importInf, SOME baseUrl))
			       imports
		val _ = trace (!logStream, "evaluating " ^ Url.toString baseUrl)
		val mod = body imports'
			 handle e as (non (Failure (_, _))) =>
			     (trace (!logStream,
				     "evaluation failed in " ^
				     Url.toString baseUrl);
			      raise Failure (baseUrl, Eval e))
		val _ = trace (!logStream, "evaluated  " ^ Url.toString baseUrl)
		val dynInf =
		    case inf of
			NONE => NONE
		      | SOME inf' =>
			SOME (lazy DynMatch.strengthenWith (rea, mod, inf'))
	    in
		(mod, dynInf)
	    end

	fun validate url =
	    let
		val cwd = Url.fromString (OS.FileSys.getDir () ^ "/")
		val cwd = Url.setScheme (cwd, SOME "file")
		val url = Url.resolve cwd url
		val url = Url.setQuery (url, NONE)
		val url = Url.setFragment (url, NONE)
	    in
		url
	    end

	functor Eval(val component: component val url: Url.t signature S): S =
	    let
		structure Sig = Reflect.ReflectSig(signature S = S)
		val url = validate url
		val (mod, inf) = eval' (url, component)
		val _ = matchWith (Inf.rea (), inf, SOME Sig.x)
			handle Inf.Mismatch m =>
			    raise Mismatch
				  {component = url, request = NONE, cause = m}
	    in
		Reflect.Reify(val x = mod signature S = S)
	    end

	functor Link(val url: Url.t signature S): S =
	    let
		structure Sig = Reflect.ReflectSig(signature S = S)
		val mod = typedLink (validate url, Inf.rea (), SOME Sig.x, NONE)
	    in
		Reflect.Reify(val x = mod signature S = S)
	    end

	functor Enter(val url: Url.t signature S structure X: S) =
	    let
		structure Sig = Reflect.ReflectSig(signature S = S)
		structure Mod = Reflect.Reflect(signature S = S
						structure X = X)
		val _ =
		    case UrlMap.lookupNew (map, validate url) of
			UrlMap.EXISTING _ => raise Conflict
		      | UrlMap.NEW p =>
			    Promise.fulfill (p, (Mod.x, SOME Sig.x))
	    in
		()
	    end

	fun eval (url, component) = #1 (eval' (validate url, component))

	fun link url = create (lazyLink (validate url))

	fun enter (url', component) withval url = validate url' end =
	    case UrlMap.lookupNew (map, url) of
		UrlMap.EXISTING _ => raise Conflict
	      | UrlMap.NEW p => Promise.fulfill (p, lazy eval' (url, component))

	fun lookup url =
	    case UrlMap.lookup (map, validate url) of
		SOME entry => SOME (create entry)
	      | NONE => NONE

	fun start url' withval url = validate url' end =
	    ignore (eval' (url, create (lazyLink url)))
    end
end
