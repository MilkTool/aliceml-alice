(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure IODesc       from "IODesc"
import structure IO           from "IO"
import structure BinPrimIO    from "BinPrimIO"
import structure StreamIO     from "StreamIO"
import structure ImperativeIO from "ImperativeIO"
import signature BIN_IO       from "BIN_IO-sig"

structure BinIO :> BIN_IO =
    struct
	structure BinStreamIO =
	    StreamIO(structure PrimIO = BinPrimIO
		     structure Vector = Word8Vector
		     structure Array = Word8Array
		     structure VectorSlice = Word8VectorSlice
		     structure ArraySlice = Word8ArraySlice
		     val someElem = Word8.fromInt 0)
	structure BinImperativeIO =
	    ImperativeIO(structure StreamIO = BinStreamIO
			 structure Vector = Word8Vector)
	open BinImperativeIO

	fun openIn name =
	    let
		val reader = BinPrimIO.RD (IODesc.openIn name)
		    handle cause =>
			raise IO.Io {cause, function = "openIn", name}
		val v = Word8Vector.fromList nil
	    in
		BinImperativeIO.mkInstream (BinStreamIO.mkInstream (reader, v))
	    end

	fun openOut name =
	    let
		val writer = BinPrimIO.WR (IODesc.openOut name)
		    handle cause =>
			raise IO.Io {cause, function = "openOut", name}
	    in
		BinImperativeIO.mkOutstream
		    (BinStreamIO.mkOutstream (writer, IO.BLOCK_BUF))
	    end

	fun openAppend name =
	    let
		val writer = BinPrimIO.WR (IODesc.openAppend name)
		    handle cause =>
			raise IO.Io {cause, function = "openAppend", name}
	    in
		BinImperativeIO.mkOutstream
		    (BinStreamIO.mkOutstream (writer, IO.BLOCK_BUF))
	    end
    end
