(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure IO        from "IO"
import signature PRIM_IO   from "PRIM_IO-sig"
import signature STREAM_IO from "STREAM_IO-sig"

functor StreamIO(structure PrimIO: PRIM_IO
		 structure Vector: MONO_VECTOR
				       where type elem = PrimIO.elem
					 and type vector = PrimIO.vector
		 structure Array: MONO_ARRAY
				      where type elem = PrimIO.elem
					and type array = PrimIO.array
					and type Vector.vector = PrimIO.vector
		 val someElem: PrimIO.elem) :>
	STREAM_IO
	    where type elem = PrimIO.elem
	      and type vector = PrimIO.vector
	      and type reader = PrimIO.reader
	      and type writer = PrimIO.writer =
    struct
	type elem = PrimIO.elem
	type vector = PrimIO.vector
	type reader = PrimIO.reader
	type writer = PrimIO.writer
	type pos = PrimIO.pos

	datatype history' =
	    READER of reader * (vector * int) option
	  | BUFFER of vector * history
	  | TRUNCATED of string
	withtype history = history' ref

	type instream = history * int

	datatype outstream' =
	    WRITER of writer * PrimIO.array * int ref * IO.buffer_mode
	  | TERMINATED of string
	withtype outstream = outstream' ref

	type out_pos = outstream * pos

	fun input' (f as (history, offset), nMarkRead, function):
	    vector * int * instream =
	    let
		val p = Promise.promise ()
		val state = Ref.exchange (history, Promise.future p)
	    in
		case state of
		    READER (reader as PrimIO.RD {name, chunkSize,
						 readVec, ...}, bufOpt) =>
			let
			    val (v, i) =
				case bufOpt of
				    SOME (v, i) => (v, i)
				  | NONE =>
				    (valOf readVec chunkSize
				     handle cause =>
					 (Promise.fulfill (p, state);
					  raise IO.Io {name, function, cause}),
				     0)
			    val k = Vector.length v
			in
			    if k <= offset + nMarkRead then
				let
				    val history' = ref (READER (reader, NONE))
				in
				    Promise.fulfill (p, BUFFER (v, history'));
				    (v, offset, (history', 0))
				end
			    else
				let
				    val nRead = Int.min (k, nMarkRead)
				    val offset' = offset + nRead
				    val i' = Int.max (i, offset')
				in
				    Promise.fulfill
					(p, READER (reader, SOME (v, i')));
				    (v, offset, (history, offset'))
				end
			end
		  | BUFFER (v, history') =>
			(Promise.fulfill (p, state);
			 (v, offset, (history', 0)))
		  | TRUNCATED _ =>
			(Promise.fulfill (p, state);
			 (Vector.fromList nil, 0, f))
	    end

	fun input f =
	    let
		val (v, offset, f') = input' (f, Vector.maxLen, "input")
	    in
		(Vector.extract (v, offset, NONE), f')
	    end

	fun input1 f =
	    let
		val (v, offset, f') = input' (f, 1, "input1")
	    in
		if Vector.length v = 0 then NONE
		else SOME (Vector.sub (v, offset), f')
	    end

	fun inputN (f, n) where (n < 0 orelse n > Vector.maxLen) =
	    raise General.Size
	  | inputN (f, n) =
	    let
		val (vs, f') = inputN' (f, n)
	    in
		(Vector.concat vs, f')
	    end
	and inputN' (f, n) =
	    let
		val (v, offset, f') = input' (f, n, "inputN")
		val k = Vector.length v - offset
	    in
		if k = 0 then (nil, f')
		else if k >= n then
		    ([Vector.extract (v, offset, SOME n)], f')
		else
		    let
			val (vs, f'') = inputN' (f, n - k)
		    in
			(Vector.extract (v, offset, NONE)::vs, f'')
		    end
	    end

	(*--** use endPos, if available, or avail to guess size *)
	fun inputAll f =
	    let
		val (vs, f') = inputAll' f
	    in
		(Vector.concat vs, f')
	    end
	and inputAll' f =
	    let
		val (v, offset, f') = input' (f, Vector.maxLen, "inputAll")
		val k = Vector.length v - offset
	    in
		if k = 0 then (nil, f')
		else
		    let
			val (vs, f'') = inputAll' f
		    in
			(Vector.extract (v, offset, NONE)::vs, f'')
		    end
	    end

	fun canInput (f as (history, offset), n) =
	    let
		val p = Promise.promise ()
		val state = Ref.exchange (history, Promise.future p)
		fun return k = SOME (Int.min (n, k))
	    in
		case state of
		    READER (reader as PrimIO.RD {name, readVecNB, ...},
			    NONE) =>
			((case valOf readVecNB n of
			      SOME v =>
				  (Promise.fulfill
				       (p, READER (reader, SOME (v, 0)));
				   return (Vector.length v))
			    | NONE => (Promise.fulfill (p, state); NONE))
			 handle cause =>
			     raise IO.Io {name, function = "canInput", cause})
		  | (READER (_, SOME (v, _)) | BUFFER (v, _)) =>
			(Promise.fulfill (p, state);
			 return (Vector.length v - offset))
		  | TRUNCATED _ =>
			(Promise.fulfill (p, state); return 0)
	    end

	fun closeIn (history, _) = closeIn' history
	and closeIn' history =
	    let
		val p = Promise.promise ()
		val state = Ref.exchange (history, Promise.future p)
	    in
		case state of
		    READER (reader as PrimIO.RD {name, close, ...}, bufOpt) =>
			let
			    val history' = TRUNCATED name
			    val history' =
				case bufOpt of
				    NONE => history'
				  | SOME (_, 0) => history'
				  | SOME (v, i) =>
					BUFFER (Vector.extract (v, 0, SOME i),
						ref history')
			in
			    Promise.fulfill (p, history');
			    close ()
			    handle cause =>
				raise IO.Io {name, function = "closeIn", cause}
			end
		  | BUFFER (_, f') =>
			(Promise.fulfill (p, state); closeIn' f')
		  | TRUNCATED _ =>
			(Promise.fulfill (p, state); ())
	    end

	fun endOfStream f =
	    Vector.length (#1 (input' (f, 0, "endOfStream"))) = 0

	fun mkInstream (reader, v) =
	    (if Vector.length v = 0 then ref (READER (reader, NONE))
	     else ref (READER (reader, SOME (v, 0))), 0)

	fun getReader (history, _) = getReader' history
	and getReader' history =
	    let
		val p = Promise.promise ()
		val state = Ref.exchange (history, Promise.future p)
	    in
		case state of
		    READER (reader as PrimIO.RD {name, ...}, bufOpt) =>
			let
			    val history' = TRUNCATED name
			    val (history', v) =
				case bufOpt of
				    NONE => (history', Vector.fromList nil)
				  | SOME (v, 0) => (history', v)
				  | SOME (v, i) =>
					(BUFFER (Vector.extract (v, 0, SOME i),
						 ref history'),
					 Vector.extract (v, i, NONE))
			in
			    Promise.fulfill (p, history');
			    (reader, v)
			end
		  | BUFFER (_, f') =>
			(Promise.fulfill (p, state); getReader' f')
		  | TRUNCATED name =>
			(Promise.fulfill (p, state);
			 raise IO.Io {name, function = "getReader",
				      cause = IO.ClosedStream})
	    end

	fun writeBuffer (buf, i, len, writeArr) =
	    let
		val k = writeArr {buf, i, sz = SOME len}
	    in
		if k = len then ()
		else writeBuffer (buf, i + k, len - k, writeArr)
	    end

(*--** implement LINE_BUF *)
(*--** if write raises an exception, adjust stillFree accordingly *)

	fun output (f, v) =
	    let
		val p = Promise.promise ()
		val state = Ref.exchange (f, Promise.future p)
	    in
		case state of
		    WRITER (writer as PrimIO.WR {name, ...},
			    buf, stillFree, bufferMode) =>
			((output' (writer, buf, Array.length buf, stillFree,
				   v, Vector.length v, 0, bufferMode);
			  Promise.fulfill (p, state))
			 handle cause =>
			     (Promise.fulfill (p, state);
			      raise IO.Io {name, function = "output", cause}))
		  | TERMINATED name =>
			(Promise.fulfill (p, state);
			 raise IO.Io {name, function = "output",
				      cause = IO.ClosedStream})
	    end
	and output' (writer as PrimIO.WR {writeArr, ...}, buf, bufLen,
		     stillFree, v, vLen, written, bufferMode) =
	    let
		val free = !stillFree
		val k = Int.min (vLen - written, free)
		val free' = free - k
		val written' = written + k
	    in
		Array.copyVec {src = v, si = written, len = SOME k,
			       dst = buf, di = bufLen - free};
		stillFree := free';
		if free' = 0 orelse bufferMode = IO.NO_BUF then
		    (writeBuffer (buf, 0, bufLen, valOf writeArr);
		     if written' = vLen then ()
		     else output' (writer, buf, bufLen, stillFree,
				   v, vLen, written', bufferMode))
		else ()
	    end

	fun output1 (f, x) =
	    let
		val p = Promise.promise ()
		val state = Ref.exchange (f, Promise.future p)
	    in
		case state of
		    WRITER (writer as PrimIO.WR {name, writeArr, ...},
			    buf, stillFree, bufferMode) =>
			let
			    val free = !stillFree
			    val bufLen = Array.length buf
			    val free' = free - 1
			in
			    stillFree := (if free' = 0 then bufLen else free');
			    Array.update (buf, bufLen - free, x);
			    if free' = 0 orelse bufferMode = IO.NO_BUF then
				writeBuffer (buf, 0, bufLen, valOf writeArr)
				handle cause =>
				    (Promise.fulfill (p, state);
				     raise IO.Io {name, function = "output1",
						  cause})
			    else ();
			    Promise.fulfill (p, state)
			end
		  | TERMINATED name =>
			(Promise.fulfill (p, state);
			 raise IO.Io {name, function = "output1",
				      cause = IO.ClosedStream})
	    end

	fun flush (buf, stillFree, writeArr) =
	    let
		val free = !stillFree
		val bufLen = Array.length buf
	    in
		stillFree := bufLen;
		if free < bufLen then
		    writeBuffer (buf, 0, bufLen - free, writeArr)
		else ()
	    end

	fun flushOut f =
	    let
		val p = Promise.promise ()
		val state = Ref.exchange (f, Promise.future p)
	    in
		case state of
		    WRITER (writer as PrimIO.WR {name, writeArr, ...},
			    buf, stillFree, _) =>
			(flush (buf, stillFree, valOf writeArr)
			 handle cause =>
			     (Promise.fulfill (p, state);
			      raise IO.Io {name, function="flushOut", cause});
			 Promise.fulfill (p, state))
		  | TERMINATED _ => Promise.fulfill (p, state)
	    end

	fun closeOut f =
	    let
		val p = Promise.promise ()
		val state = Ref.exchange (f, Promise.future p)
	    in
		case state of
		    WRITER (PrimIO.WR {name, writeArr, close, ...},
			    buf, stillFree, _) =>
			(Promise.fulfill (p, TERMINATED name);
			 flush (buf, stillFree, valOf writeArr)
			 handle cause =>
			     (close ()
			      handle cause =>
				  raise IO.Io {name, function="closeOut",
					       cause};
			      raise IO.Io {name, function="closeOut", cause});
			 close ()
			 handle cause =>
			     raise IO.Io {name, function="closeOut", cause})
		  | TERMINATED _ => Promise.fulfill (p, state)
	    end

	fun setBufferMode (f, bufferMode) =
	    let
		val p = Promise.promise ()
		val state = Ref.exchange (f, Promise.future p)
	    in
		case state of
		    WRITER (writer as PrimIO.WR {name, writeArr, ...},
			    buf, stillFree, _) =>
			(if bufferMode = IO.NO_BUF then
			     flush (buf, stillFree, valOf writeArr)
			     handle cause =>
				 (Promise.fulfill (p, state);
				  raise IO.Io {name, function="setBufferMode",
					       cause})
			 else ();
			 Promise.fulfill
			     (p, WRITER (writer, buf, stillFree, bufferMode)))
		  | TERMINATED name =>
			(Promise.fulfill (p, state);
			 raise IO.Io {name, function = "setBufferMode",
				      cause = IO.ClosedStream})
	    end

	fun getBufferMode f =
	    let
		val p = Promise.promise ()
		val state = Ref.exchange (f, Promise.future p)
	    in
		case state of
		    WRITER (_, _, _, bufferMode) =>
			(Promise.fulfill (p, state); bufferMode)
		  | TERMINATED name =>
			(Promise.fulfill (p, state);
			 raise IO.Io {name, function = "getBufferMode",
				      cause = IO.ClosedStream})
	    end

	fun mkOutstream (writer as PrimIO.WR {chunkSize, ...}, bufferMode) =
	    ref (WRITER (PrimIO.augmentWriter writer,
			 Array.array (chunkSize, someElem),
			 ref chunkSize, bufferMode))

	fun getWriter f =
	    let
		val p = Promise.promise ()
		val state = Ref.exchange (f, Promise.future p)
	    in
		case state of
		    WRITER (writer as PrimIO.WR {name, writeArr, ...},
			    buf, stillFree, bufferMode) =>
			(Promise.fulfill (p, TERMINATED name);
			 flush (buf, stillFree, valOf writeArr)
			 handle cause =>
			     raise IO.Io
				 {name, function="getWriter", cause};
			 (writer, bufferMode))
		  | TERMINATED name =>
			(Promise.fulfill (p, state);
			 raise IO.Io {name, function = "getWriter",
				      cause = IO.ClosedStream})
	    end

	fun getPosOut f =
	    let
		val p = Promise.promise ()
		val state = Ref.exchange (f, Promise.future p)
	    in
		case state of
		    WRITER (writer as PrimIO.WR {name, writeArr, getPos, ...},
			    buf, stillFree, bufferMode) =>
			(flush (buf, stillFree, valOf writeArr)
			 handle cause =>
			     (Promise.fulfill (p, state);
			      raise IO.Io
				  {name, function="getPosOut", cause});
			 (f, valOf getPos ()) before
			 Promise.fulfill (p, state)
			 handle cause =>
			     (Promise.fulfill (p, state);
			      raise IO.Io
				  {name, function="getPosOut", cause}))
		  | TERMINATED name =>
			(Promise.fulfill (p, state);
			 raise IO.Io {name, function = "getPosOut",
				      cause = IO.ClosedStream})
	    end
    end
