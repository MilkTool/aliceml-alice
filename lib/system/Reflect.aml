(*
 * Author:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt and Andreas Rossberg, 2001-2003
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Label         from "../rtt/Label"
import structure Type          from "../rtt/Type"
import structure Inf           from "../rtt/Inf"
import structure UnsafeReflect from "UnsafeReflect"
import structure UnsafeValue   from "UnsafeValue"
import signature REFLECT       from "REFLECT-sig"

structure Reflect : REFLECT =
    struct
	type value
	type module

	val cast = UnsafeValue.cast
	val realToVector = UnsafeReflect.realToVector

	val reflect = cast
	val reify   = cast

	(* TODO: Q&D, has to correspond to translation *)
	datatype package' = Package__ of module * Inf.t

	val lab_x = Label.fromString "x"
	val lab_t = Label.fromString "$t"

	fun reflectPackage p = case cast p : package' of Package__ mj => mj
	fun reflectValPackage p =
	    let
		val (m,j) = reflectPackage p
	    in
		(UnsafeValue.projPoly(m,lab_x) : value,
		 UnsafeValue.projPoly(m,lab_t) : Type.t)
	    end


	functor Reflect(signature S structure X: S) =
	    let
		structure Str = UnsafeReflect.Reflect(signature S = S
						      structure X = X)
	    in
		(val x = cast Str.x)
	    end

	functor Reify(val x: module signature S) =
	    UnsafeReflect.Reify(val x = cast x signature S = S)

	structure ReflectSig = UnsafeReflect.ReflectSig
	structure ReifySig = UnsafeReflect.ReifySig

	functor ReflectType(type t) =
	    let
		structure Sig = ReflectSig(signature S = (type t = t))
	    in
		(val x = Inf.lookupTyp'(Inf.asSig(cast Sig.x),
					Label.fromString "t"))
	    end
    end
