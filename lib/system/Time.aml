(*
 * Authors:
 *   Benedikt Grundmann <bgrund@ps.uni-sb.de>
 *
 * Copyright:
 *   Benedikt Grundmann, 2004
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)


(*
 *  Items marked with (**) are extensions to the Standard Basis.
 *)

import signature TIME           from "TIME-sig"
import structure UnsafeTime     from "UnsafeTime"

structure Time : TIME =
struct
    structure LInt = LargeInt

    (* TODO: an optimized variant of this routine should
       be part of LargeInt.
     *)
    fun quotRem (a : LargeInt.int, b : LargeInt.int) =
        let
            val q   = LInt.quot (a, b)
            val r   = LInt.rem (a, b)
        in
            ( (q, r) : (LargeInt.int * LargeInt.int) )
        end
 
    
    (*********** conversion Time -> String **********)

    fun largeInt s = valOf (LInt.fromString s)

    (* maximum precision possible (nanosecond resolution) *)
    val maxPrec     = 9
    (* number of seconds in a nano second *)
    val nanoSec     =    largeInt "1000000000"
    (* rounding borders *)
    val borders     = #[ largeInt "5"
                       , largeInt "50"
                       , largeInt "500"
                       , largeInt "5000"
                       , largeInt "50000"
                       , largeInt "500000"
                       , largeInt "5000000"
                       , largeInt "50000000"
                       , largeInt "500000000"
                       ]
                    
    val zero        = LInt.fromInt 0
    val minusOne    = LInt.fromInt (~1)
    val one         = LInt.fromInt 1
    val two         = LInt.fromInt 2
    val ten         = LInt.fromInt 10
    val border      = Vector.sub (borders, 0)
    
    fun isEven i = LInt.rem (i, two) = zero

    (* given a number [n] and a number of fractional
       digits to split of [p], split [n] at [p] into
       whole and fractional part.
     *)
    fun splitRaw (n, p) =
        assert (0 < p andalso p <= maxPrec) do
        let
            val border = Vector.sub (borders, p - 1)
        in
            quotRem (n, border * two)
        end
    
    (* given a number [n] and a number of fractional
       digits to split of [p], split [n] at [p] into 
       whole and fractional part, rounding if necessary.
     *)
    fun split (n, p) =
        assert (0 < p andalso p <= maxPrec) do
        let
            val border          = Vector.sub (borders, p - 1) 
            val (whole, frac)   = quotRem (n, border * two)
        in
            case LInt.compare (frac, border) of
                LESS    => (whole, frac)
              | GREATER => (whole + one, zero)
              | EQUAL   => if isEven whole 
                              then (whole, frac)
                              else (whole + one, zero)
        end

    fun fmt prec t = 
    let
	    val nsec        = Time.toNanoseconds t 
        val (neg, nsec) = if LInt.sign nsec < 0 
                            then (true, ~nsec) 
                            else (false, nsec)
	    fun fmtInt i = LInt.fmt StringCvt.DEC i
	    fun fmtSec (neg, i) = fmtInt (if neg then ~i else i)
    in
        if prec < 0 then raise General.Size
	    else if prec = 0 then
            let val (sec, _)    = split (nsec, maxPrec)
	        in
		        fmtSec (neg, sec)
	        end
	    else if prec >= maxPrec then
	        let val (sec, nsec) = quotRem (nsec, nanoSec)
	            val frac        = fmtInt nsec
            in
                concat [fmtSec (neg, sec), ".",
                        StringCvt.padRight #"0" prec frac]
	        end
	    else
            let (* remove excess digits *) 
                val (n, _)      = split (nsec, maxPrec - prec)
                (* do the raw split *)
                val (sec, frac) = splitRaw (n, prec) 
                val frac        = fmtInt frac
            in
                concat [fmtSec (neg, sec), ".",
                        StringCvt.padLeft #"0" prec frac]
            end
    end


    fun toString msec = fmt 3 msec

    
    (*********** conversion String -> Time **********)
  
    fun pow10 n =
        let 
            val ten = LargeInt.fromInt 10
            fun loop i res =
                if i = 0 then res
                else loop (i - 1) (res * ten)
        in
            loop n (LargeInt.fromInt 1)
        end

    fun d2i d = assert (Char.isDigit d) do Int.toLarge (Char.ord d - Char.ord #"0")

    fun ret (t, s) = SOME (Time.fromNanoseconds t, s)

    fun loop' (sign, getc, s, res, n) =
        case getc s of
            SOME (d, s') where (Char.isDigit d) =>
            if n > maxPrec then loop' (sign, getc, s', res, n + 1)
            else loop' (sign, getc, s', res * ten + d2i d, n + 1)
          | SOME (_, s') =>
            if n < maxPrec then ret (sign * res * pow10 (maxPrec - n), s')
            else if n = 0 then NONE
            else ret (sign * res, s')
          | NONE => 
            if n < maxPrec then ret (sign * res * pow10 (maxPrec - n), s)
            else if n = 0 then NONE
            else ret (sign * res, s)
 
            
    fun loop (sign, getc, s, res) =
        case getc s of
            SOME (d, s')    where (Char.isDigit d) => 
            loop (sign, getc, s', res * ten + d2i d)
          | SOME (#".", s') =>
            loop' (sign, getc, s', res, 0)
          | _                                   => NONE

    (* scan unsigned time. *)
    fun scanTime (sign, getc, s) =
        case getc s of
            SOME (d, s') where (Char.isDigit d) =>
            loop (sign, getc, s', d2i d)
          | SOME (#".", s')                     =>
            loop' (sign, getc, s', zero, 0)
          | _                                   =>
            NONE
        
    fun scan getc s =
    let
        fun sign s =
            case getc s of
                NONE                      => NONE
              | SOME (#"+", s')           => scanTime (one, getc, s')
              | SOME ((#"-" | #"~"), s')  => scanTime (minusOne, getc, s')
              | _                         => scanTime (one, getc, s)
    in
        sign (StringCvt.skipWS getc s)
    end


    fun fromString s = StringCvt.scanString scan s

    open Time

    type time = Time.time
    exception Time = Time.Time

    fun now () = Time.fromMilliseconds (UnsafeTime.now ())
end
