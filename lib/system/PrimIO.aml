(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure OS      from "OS"
import structure IO      from "IO"
import signature PRIM_IO from "PRIM_IO-sig"

functor PrimIO(structure V: MONO_VECTOR
	       structure A: MONO_ARRAY
		   where type Vector.vector = V.vector and type elem = V.elem
	       val someElem: A.elem
	       type pos
	       val compare: pos * pos -> order) :>
    PRIM_IO
	where type elem = A.elem
	  and type vector = A.Vector.vector
	  and type array = A.array =
    struct
	type elem = A.elem
	type vector = A.Vector.vector
	type array = A.array

	type pos = (pos,int) alt
	val compare = Alt.compare (compare, Int.compare)

	datatype reader = RD of
	    {name: string,
	     chunkSize: int,
	     readVec: (int -> vector) option,
	     readArr: ({buf: array, i: int, sz: int option} -> int) option,
	     readVecNB: (int -> vector option) option,
	     readArrNB:
		 ({buf: array, i: int, sz: int option} -> int option) option,
	     block: (unit -> unit) option,
	     canInput: (unit -> bool) option,
	     avail: unit -> int option,
	     getPos: (unit -> pos) option,
	     setPos: (pos -> unit) option,
	     endPos: (unit -> pos) option,
	     verifyPos: (unit -> pos) option,
	     close: unit -> unit,
	     ioDesc: OS.IO.iodesc option}

	datatype writer = WR of
	    {name: string,
	     chunkSize: int,
	     writeVec: ({buf: vector, i: int, sz: int option} -> int) option,
	     writeArr: ({buf: array, i: int, sz: int option} -> int) option,
	     writeVecNB:
		 ({buf: vector, i: int, sz: int option} -> int option) option,
	     writeArrNB:
		 ({buf: array, i: int, sz: int option} -> int option) option,
	     block: (unit -> unit) option,
	     canOutput: (unit -> bool) option,
	     getPos: (unit -> pos) option,
	     setPos: (pos -> unit) option,
	     endPos: (unit -> pos) option,
	     verifyPos: (unit -> pos) option,
	     close: unit -> unit,
	     ioDesc: OS.IO.iodesc option}

	fun openVector v =
	    let
		val pos = ref 0
		val closed = ref false
		fun check f x =
		    let
			val p = Promise.promise ()
		    in
			if Ref.exchange (closed, Promise.future p) then
			    (Promise.fulfill (p, true);
			     raise IO.ClosedStream)
			else (f x before Promise.fulfill (p, false))
		    end

		fun readVec sz =
		    let
			val p = !pos
			val n = Int.min (V.length v - p, sz)
		    in
			case Int.compare (n, 0) of
			    LESS => raise General.Size
			  | EQUAL => raise General.Domain
			  | GREATER => (pos := p + n;
					V.extract (v, p, SOME n))
		    end

		fun readArr {buf, i, sz} =
		    let
			val p = !pos
			val sz = Option.getOpt (sz, A.length buf - i)
			val n = Int.min (V.length v - p, sz)
		    in
			case Int.compare (n, 0) of
			    LESS => raise General.Size
			  | EQUAL => raise General.Domain
			  | GREATER => (pos := p + n;
					A.copyVec {src = v, si = p,
						   len = SOME n,
						   dst = buf, di = i};
					n)
		    end
	    in
		RD {name = "vector",
		    chunkSize = V.length v,
		    readVec = SOME (check readVec),
		    readArr = SOME (check readArr),
		    readVecNB = SOME (check (fn x => if Future.isFuture v
						     then NONE
						     else SOME (readVec x))),
		    readArrNB = SOME (check (fn x => if Future.isFuture v
						     then NONE
						     else SOME (readArr x))),
		    block = SOME (check (fn () => ignore (Future.await v))),
		    canInput = SOME (check (fn () => not (Future.isFuture v))),
		    avail = check (fn () => NONE),
		    getPos = SOME (fn () => SND (!pos)),
		    setPos = SOME (check (fn SND p => pos := p
					   | FST _ => raise General.Domain)),
		    endPos = SOME (check (fn () => SND (V.length v))),
		    verifyPos = SOME (check (fn () => SND (!pos))),
		    close = fn () => closed := true,
		    ioDesc = NONE}
	    end

	fun len (len, i, sz) =
	    (if i < 0 orelse i > len then raise General.Subscript else ();
	     case sz of
		 SOME sz =>
		     if sz > len - i then raise General.Size else sz
	       | NONE => len - i)

	fun nullRd (): reader =
	    let
		val closed = ref false
		fun check x _ =
		    let
			val p = Promise.promise ()
		    in
			if Ref.exchange (closed, Promise.future p) then
			    (Promise.fulfill (p, true);
			     raise IO.ClosedStream)
			else (Promise.fulfill (p, false); x)
		    end
	    in
		RD {name = "null",
		    chunkSize = 1,
		    readVec = SOME (check (V.fromList nil)),
		    readArr = SOME (check 0),
		    readVecNB = SOME (check (SOME (V.fromList nil))),
		    readArrNB = SOME (check (SOME 0)),
		    block = SOME (check ()),
		    canInput = SOME (check true),
		    avail = check (SOME 0),
		    getPos = SOME (fn () => SND 0),
		    setPos = SOME (fn x =>
				   check (fn SND 0 => ()
					   | _ => raise General.Domain) () x),
		    endPos = SOME (check (SND 0)),
		    verifyPos = SOME (check (SND 0)),
		    close = fn () => closed := true,
		    ioDesc = NONE}
	    end

	fun nullWr (): writer =
	    let
		val closed = ref false
		fun check f x =
		    let
			val p = Promise.promise ()
		    in
			if Ref.exchange (closed, Promise.future p) then
			    (Promise.fulfill (p, true);
			     raise IO.ClosedStream)
			else (Promise.fulfill (p, false); f x)
		    end
		fun getPos () = SND 0
	    in
		WR {name = "null",
		    chunkSize = 1,
		    writeVec = SOME (fn {buf, i, sz} =>
					check len (V.length buf, i, sz)),
		    writeArr = SOME (fn {buf, i, sz} =>
					check len (A.length buf, i, sz)),
		    writeVecNB =
			SOME (fn {buf, i, sz} =>
				 check (SOME o len) (V.length buf, i, sz)),
		    writeArrNB =
			SOME (fn {buf, i, sz} =>
				 check (SOME o len) (A.length buf, i, sz)),
		    block = SOME (check (fn () => ())),
		    canOutput = SOME (check (fn () => true)),
		    getPos = SOME getPos,
		    setPos = SOME (check (fn SND 0 => ()
					   | _ => raise General.Domain)),
		    endPos = SOME (check getPos),
		    verifyPos = SOME (check getPos),
		    close = fn () => closed := true,
		    ioDesc = NONE}
	    end

	fun augmentReader (RD {name, chunkSize, readVec, readArr, readVecNB,
			       readArrNB, block, canInput, avail, getPos,
			       setPos, endPos, verifyPos, close, ioDesc}) =
	    let
		val readVec' =
		    if isSome readVec then readVec
		    else if isSome readArr then
			SOME (fn sz =>
			      let
				  val buf = A.array (sz, someElem)
				  val i = valOf readArr {buf, i = 0, sz = NONE}
			      in
				  A.extract (buf, 0, SOME i)
			      end)
		    else if isSome block then (*--** first read, then block *)
			if isSome readVecNB then
			    SOME (fn sz => (valOf block ();
					    valOf (valOf readVecNB sz)))
			else if isSome readArrNB then
			    SOME (fn sz =>
				  let
				      val _ = valOf block ()
				      val buf = A.array (sz, someElem)
				      val i = valOf (valOf readArrNB
						  {buf, i = 0, sz = NONE})
				  in
				      A.extract (buf, 0, SOME i)
				  end)
			else NONE
		    else NONE
		val readArr' =
		    if isSome readArr then readArr
		    else if isSome readVec then
			SOME (fn {buf, i, sz} =>
			      let
				  val k = case sz of
					     SOME k => k
					   | NONE => A.length buf - i
				  val v = valOf readVec k
				  val k' = V.length v
			      in
				  A.copyVec {src = v, si = 0, len = SOME k',
					     dst = buf, di = i};
				  k'
			      end)
		    else if isSome block then (*--** first read, then block *)
			if isSome readArrNB then
			    SOME (fn {buf, i, sz} =>
				  (valOf block ();
				   valOf (valOf readArrNB {buf, i, sz})))
			else if isSome readVecNB then
			    SOME (fn {buf, i, sz} =>
				  let
				      val _ = valOf block ()
				      val k = case sz of
						  SOME k => k
						| NONE => A.length buf - i
				      val v = valOf (valOf readVecNB k)
				      val k' = V.length v
				  in
				      A.copyVec {src=v, si=0, len=SOME k',
						 dst=buf, di=i};
				      k'
				  end)
			else NONE
		    else NONE
		val readVecNB' =
		    if isSome readVecNB then readVecNB
		    else if isSome readArrNB then
			SOME (fn sz =>
			      let
				  val buf = A.array (sz, someElem)
			      in
				  case valOf readArrNB {buf,i=0,sz=NONE} of
				      SOME i =>
					  SOME (A.extract (buf, 0, SOME i))
				    | NONE => NONE
			      end)
		    else if Option.isSome canInput then
			if Option.isSome readVec then
			    SOME (fn sz =>
				  if valOf canInput () then
				      SOME (valOf readVec sz)
				  else NONE)
			else if Option.isSome readArr then
			    SOME (fn sz =>
				  if valOf canInput () then
				      let
					  val buf = A.array (sz, someElem)
					  val i =
					      valOf readArr {buf, i=0, sz=NONE}
				      in
					  SOME (A.extract (buf, 0, SOME i))
				      end
				  else NONE)
			else NONE
		    else NONE
		val readArrNB' =
		    if Option.isSome readArrNB then readArrNB
		    else if Option.isSome readVecNB then
			SOME (fn {buf, i, sz} =>
			      if valOf canInput () then
				  let
				      val k = case sz of
						  SOME k => k
						| NONE => A.length buf - i
				      val v = valOf readVec k
				      val k' = V.length v
				  in
				      A.copyVec {src=v, si=0, len=SOME k',
						 dst=buf, di=i};
				      SOME k'
				  end
			      else NONE)
		    else if Option.isSome canInput then
			if Option.isSome readArr then
			    SOME (fn {buf, i, sz} =>
				  if valOf canInput () then
				      SOME (valOf readArr {buf, i, sz})
				  else NONE)
			else if Option.isSome readVec then
			    SOME (fn {buf, i, sz} =>
				  if valOf canInput () then
				      let
					  val k = case sz of
						      SOME k => k
						    | NONE => A.length buf - i
					  val v = valOf readVec k
					  val k' = V.length v
				      in
					  A.copyVec {src=v, si=0, len=SOME k',
						     dst=buf, di=i};
					  SOME k'
				      end
				  else NONE)
			else NONE
		    else NONE
	    in
		RD {name, chunkSize, readVec = readVec', readArr = readArr',
		    readVecNB = readVecNB', readArrNB = readArrNB', block,
		    canInput, avail, getPos, setPos, endPos, verifyPos,
		    close, ioDesc}
	    end

	fun augmentWriter (WR {name, chunkSize, writeVec, writeArr, writeVecNB,
			       writeArrNB, block, canOutput, getPos, setPos,
			       endPos, verifyPos, close, ioDesc}) =
	    let
		val writeVec' =
		    if isSome writeVec then writeVec
		    else if isSome writeArr then
			SOME (fn {buf, i, sz} =>
			      let
				  val n = len (V.length buf, i, sz)
				  val a = A.array (n, someElem)
			      in
				  A.copyVec {src = buf, si = 0, len = SOME n,
					     dst = a, di = 0};
				  valOf writeArr {buf = a, i, sz}
			      end)
		    else if isSome block then (*--** first write, then block *)
			if isSome writeVecNB then
			    SOME (fn {buf, i, sz} =>
				  (valOf block ();
				   valOf (valOf writeVecNB {buf, i, sz})))
			else if isSome writeArrNB then
			    SOME (fn {buf, i, sz} =>
				  let
				      val _ = valOf block ()
				      val n = len (V.length buf, i, sz)
				      val a = A.array (n, someElem)
				  in
				      A.copyVec {src=buf, si=0, len=SOME n,
						 dst = a, di = 0};
				      valOf (valOf writeArrNB {buf = a, i, sz})
				  end)
			else NONE
		    else NONE
		val writeArr' =
		    if isSome writeArr then writeArr
		    else if isSome writeVec then
			SOME (fn {buf, i, sz} =>
			      valOf writeVec
				  {buf = A.extract (buf, i, sz), i, sz})
		    else if isSome block then (*--** first write, then block *)
			if isSome writeArrNB then
			    SOME (fn {buf, i, sz} =>
				  (valOf block ();
				   valOf (valOf writeArrNB {buf, i, sz})))
			else if isSome writeVecNB then
			    SOME (fn {buf, i, sz} =>
				  (valOf block ();
				   valOf (valOf writeVecNB
				       {buf = A.extract (buf, i, sz), i, sz})))
			else NONE
		    else NONE
		val writeVecNB' =
		    if isSome writeVecNB then writeVecNB
		    else if isSome writeArrNB then
			SOME (fn {buf, i, sz} =>
			      let
				  val n = len (V.length buf, i, sz)
				  val a = A.array (n, someElem)
			      in
				  A.copyVec {src = buf, si = 0, len = SOME n,
					     dst = a, di = 0};
				  valOf writeArrNB {buf = a, i, sz}
			      end)
		    else if isSome canOutput then
			if isSome writeVec then
			    SOME (fn {buf, i, sz} =>
				  if valOf canOutput () then
				      SOME (valOf writeVec {buf, i, sz})
				  else NONE)
			else if isSome writeArr then
			    SOME (fn {buf, i, sz} =>
				  if valOf canOutput () then
				      let
					  val n = len (V.length buf, i, sz)
					  val a = A.array (n, someElem)
				      in
					  A.copyVec {src=buf, si=0, len=SOME n,
						     dst=a, di=0};
					  SOME (valOf writeArr {buf=a, i, sz})
				      end
				  else NONE)
			else NONE
		    else NONE
		val writeArrNB' =
		    if isSome writeArrNB then writeArrNB
		    else if isSome writeVecNB then
			SOME (fn {buf, i, sz} =>
			      valOf writeVecNB
				  {buf = A.extract (buf, i, sz), i, sz})
		    else if isSome canOutput then
			if isSome writeArr then
			    SOME (fn {buf, i, sz} =>
				  if valOf canOutput () then
				      SOME (valOf writeArr {buf, i, sz})
				  else NONE)
			else if isSome writeVec then
			    SOME (fn {buf, i, sz} =>
				  if valOf canOutput () then
				      SOME (valOf (valOf writeVecNB
					  {buf=A.extract (buf, i, sz), i, sz}))
				  else NONE)
			else NONE
		    else NONE
	    in
		WR {name, chunkSize, writeVec = writeVec',
		    writeArr = writeArr', writeVecNB = writeVecNB',
		    writeArrNB = writeArrNB', block, canOutput, getPos,
		    setPos, endPos, verifyPos, close, ioDesc}
	    end

    end
