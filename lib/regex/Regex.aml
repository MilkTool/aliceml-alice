(*
 * Author:
 *   Marco Kuhlmann <kuhlmann@ps.uni-sb.de>
 *
 * Copyright:
 *   Marco Kuhlmann, 2003
 * 
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *) 

(*
 * This component provides an interface to a (subset of) POSIX-
 * compatible regular expressions.  The 'matchptr' array that
 * results from the application of the C 'regexec' function is
 * represented as a new type 'match'.  An explicit representation
 * of the C 'regex_t' type that holds a compiled pattern is
 * avoided by allowing the partial application of the 'match' and
 * the 'search' functions. (Note, however, that the functions
 * resulting from this partial application cannot be pickled.)
 *
 *)

import structure NativeRegex from "NativeRegex"

signature REGEX_SIG =
  sig

    type match

    infix matches

    val match      : string -> string -> match option     (* MalformedRE *)
    val matches    : string * string -> bool              (* MalformedRE *)
    val search     : string -> string -> match option     (* MalformedRE *)

    val nGroups    : match -> int
    val groups     : match -> string vector
    val group      : match * int -> string                (* NoSuchGroup *)
    val groupStart : match * int -> int                   (* NoSuchGroup *)
    val groupEnd   : match * int -> int                   (* NoSuchGroup *)
    val groupSpan  : match * int -> (int * int)           (* NoSuchGroup *)

    val regex      : match -> string
    val goal       : match -> string

  end

structure Regex :> REGEX_SIG =
  struct

    type match = {regx : string,
		  goal : string,
		  mtch : (int * int) vector}

    infix matches

    exception MalformedRE
    exception NoSuchGroup

    fun compile pattern =
	case NativeRegex.regcomp (pattern)
	  of SOME(r) => r
	   | NONE    => raise MalformedRE

    fun matchAux (pattern, compiledPattern, matchAgainst) =
	case NativeRegex.regexec (compiledPattern, matchAgainst)
	  of SOME(m) => SOME({regx = pattern, goal = matchAgainst, mtch = m})
	   | NONE    => NONE

    fun match pattern =
	let
	  val compiledPattern = compile pattern
	in
	  fn matchAgainst =>
	     matchAux (pattern, compiledPattern, matchAgainst)
	end

    fun p matches s = Option.isSome (match p s)
	 
    fun searchAux (pattern, compiledPattern, searchIn) =
	case matchAux (pattern, compiledPattern, searchIn)
	  of SOME(_) as match => match
	   | NONE => let val size = String.size searchIn in
		       if size > 0 then
			 searchAux (pattern, compiledPattern,
				    String.extract (searchIn, 1, NONE))
		       else
			 NONE
		     end

    fun search pattern =
	let
	  val compiledPattern = compile pattern
	in
	  fn searchIn =>
	     searchAux (pattern, compiledPattern, searchIn)
	end

    fun substring s =
	fn (i, j) => String.substring (s, i, j-i)

    fun groupAccess ({regx = _, goal = _, mtch = m} : match, i) =
	if 0 <= i andalso i < Vector.length m then
	  Vector.sub (m, i)
	else
	  raise NoSuchGroup

    fun group (match as {regx = _, goal = s, mtch = m}, i) =
	substring s (groupAccess (match, i))
	  
    fun groups {regx = _, goal = s, mtch = m} =
	Vector.map (substring s) m

    fun nGroups {regx = _, goal = _, mtch = m} =
	Vector.length m

    fun groupStart (match, i) = #1(groupAccess (match, i))

    fun groupEnd (match, i) = #2(groupAccess (match, i))

    fun groupSpan (match, i) = groupAccess (match, i)

    fun regex ({regx = s, goal = _, mtch = _} : match) = s

    fun goal ({regx = _, goal = s, mtch = _} : match) = s

  end
