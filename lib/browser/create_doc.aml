import structure Types from "type"
import structure MkpathTable from "MkpathTable"
import structure Type from "x-alice:/lib/rtt/Type"
import structure Path from "x-alice:/lib/rtt/Path"
import structure PervasiveType from "x-alice:/lib/rtt/PervasiveType"
import structure PathMap from "x-alice:/lib/rtt/PathMap"
import structure MkHashImpMap from "x-alice:/lib/utility/MkHashImpMap"
import structure UnsafeValue from "x-alice:/lib/system/UnsafeValue"
import structure Name from "x-alice:/lib/rtt/Name"
import structure Reflect from "x-alice:/lib/system/Reflect"

open Types
open MkpathTable

(*** Signatur CREATE_DOC ***)

signature CREATE_DOC =
sig
    exception createRefError
    exception createVectorError
    exception createArrayError 

    type 'a doc_creator = ('a * Type.t -> Node * int * int -> Node) * int 
	                  -> 'a * Type.t 
	                  -> doc 

(* Hilfsfunktionen *)
    val castVector   :  'b -> 'c vector
    val castArray    :  'b -> 'c array

(* Funktion zur Registrierung der create-Funktionen (s.u.) in der pathTable *)
    val registerType : 	Path.path * ( 'a doc_creator ) -> unit

(* Erzeugung der 'Knoten' vom Typ doc fuer die verschiedenen Pfadtypen *)
    val createInt    :  'a doc_creator 
    val createString :  'a doc_creator 
    val createChar   :  'a doc_creator 
    val createWord   :  'a doc_creator 
    val createReal   :  'a doc_creator 
    val createExn    :  'a doc_creator 
    val createRef    :  'a doc_creator  
    val createVector :  'a doc_creator 
    val createArray  :  'a doc_creator 
       
end;

(*** Struktur Create_Doc ***)

structure Create_Doc :> CREATE_DOC =
struct
    exception createRefError
    exception createVectorError
    exception createArrayError    

    type 'a doc_creator = ('a * Type.t -> Node * int * int  -> Node) * int 
	                  -> 'a * Type.t 
	                  -> doc 

    fun castVector value  = UnsafeValue.cast value : 'a vector
 
    fun castArray value  = UnsafeValue.cast value : 'a array

    (* einfache Pfadtypen *)

    fun registerType(path, f) = PathMap.insert(pathTable, path, f)



    fun createInt (f,width) (value,typ) 
	= SIMPLE
	{ value   = UnsafeValue.cast value: Reflect.value,
	  typ     = typ,
	  content = Int.toString(UnsafeValue.cast value: int)
           } 

    fun createString (f,width) (value,typ)
	= SIMPLE
	{ value   = UnsafeValue.cast value: Reflect.value,
	  typ     = typ,
	  content = UnsafeValue.cast value : string
	 }
	
    fun createChar (f,width) (value,typ)
	= SIMPLE 
	{ value   = UnsafeValue.cast value: Reflect.value,
	  typ     = typ,
	  content = Char.toString(UnsafeValue.cast value : char)
	 }
	   
    fun createWord (f,width) (value,typ)
	= let val i = Word.toInt(UnsafeValue.cast value : word)
              val v = Int.toString i
              val s = String.append("0w",v)
          in 
	      SIMPLE
	      { value   = UnsafeValue.cast value: Reflect.value,
	        typ     = typ,
	        content = s
	       }
          end

    fun createReal (f,width) (value,typ)
	= SIMPLE
	{ value   = UnsafeValue.cast value: Reflect.value,
	  typ     = typ,
	  content = Real.toString(UnsafeValue.cast value : real)
	 }

    fun createExn (f,width) (value,typ)
	= let val cn = UnsafeValue.conName(value) 
              val s = case cn of Name.ExId(n) => n
                               | Name.InId => ""
              val exn = String.append("<exception> : ",s)
          in 
	      SIMPLE
	      { value   = UnsafeValue.cast value: Reflect.value,
	        typ     = typ,
	        content = exn
	       }
	  end

    (* zusammengesetzte Pfadtypen *)

    fun createRef (g,width) (value,typ) 
	= let val a = !(UnsafeValue.cast value)
              val t = Type.inspect(typ)
              val tt = case t of Type.Apply(t1,t2) => t2
                              | _ => raise NoNode
              val ii = INTERNAL (g(a,tt)) 
	      val v = Vector.tabulate(1,fn x => ii)
	  in CONTAINER { value   = UnsafeValue.cast value: Reflect.value,
                         typ = typ,
			 kids = if width = 0 
				    then #[]
				else v,
			 more = if width = 0 
				    then true
				else false}
	  end
 
    fun createVector (f,width) (value,typ) = 
        let
            val elemTyp = case Type.inspect typ of
                Type.Apply(tuple) => #2(tuple)
              | _ => raise createVectorError

        in
            if Vector.length (castVector (value)) <= width then         
               CONTAINER
	      { value   = UnsafeValue.cast value: Reflect.value,
	        typ = typ,
	        kids = 
		Vector.tabulate(Vector.length (castVector (value)),
				fn i =>
				INTERNAL(f(Vector.sub(castVector(value),i),
					   elemTyp)) ),    
		more = false
                }
            else CONTAINER
                { value   = UnsafeValue.cast value: Reflect.value,
		  typ = typ,
		  kids = 
		  Vector.tabulate(width,
				  fn i => 
				  INTERNAL(f(Vector.sub(castVector(value),i),
					     elemTyp))),
		  more = true
		  }
	end
    
    fun createArray (f,width) (value,typ) = 
        let
            val elemTyp = case Type.inspect typ of
                Type.Apply(tuple) => #2(tuple)
              | _ => raise createArrayError
        in
            if Array.length (castArray (value)) <= width then         
		CONTAINER
		{ value   = UnsafeValue.cast value: Reflect.value,
		  typ = typ,
		  kids = 
		  Vector.tabulate(Array.length (castArray (value)),
				  fn i => 
				  INTERNAL(f(Array.sub(castArray (value),i),
					     elemTyp))),
		  more = false
		  }
            else CONTAINER
                { value   = UnsafeValue.cast value: Reflect.value,
		  typ = typ,
		  kids = 
		  Vector.tabulate(width,
				  fn i => 
				  INTERNAL(f(Array.sub(castArray (value),i),
					     elemTyp))),
		  more = true
		  }
	end    
    
end    
