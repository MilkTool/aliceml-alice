(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)


import structure Type          from "x-alice:/lib/rtt/Type"
import structure Label         from "x-alice:/lib/rtt/Label"
import structure UnsafeValue   from "x-alice:/lib/system/UnsafeValue"
import structure Types         from "Types"
import signature HELPER        from "HELPER-sig"

local 

open Types

in

structure Helper :> HELPER = 
struct

    exception copyArray_error

    fun createValue(va,t,act) = VALUE{value = va,
				      typ = t,
				      actions = act}

    fun isApply t = case t of Type.Apply(_,_) => true
                           | _ => false 

    fun unApply(Type.Apply(t1,t2))
       = let val t = ref (Type.inspect(t1)) 
             val l = ref [t2]
         in (while isApply (!t) do
             ( case !t of 
               Type.Apply(t11,t12) => (t := (Type.inspect(t11)) 
				       ; l:= [t12]@(!l))
             | _ => () ) ; (!t,!l))
	 end

    fun row2list row = case Type.inspectRow(row) of 
	Type.EmptyRow => nil
      | Type.UnknownRow => nil
      | Type.FieldRow(lab,t,row2) => 
	    (lab,t)::row2list(row2)

    fun labelvector (ll:(Label.lab * Type.typ) list) = 
	Vector.tabulate ((List.length(ll)), 
			 (fn i =>(#1( List.nth(ll,i))) ) )  

    fun array_map' (funct,a,i) = 
	if i < Array.length(a) 
	    then (funct(Array.sub(a,i));array_map' (funct,a,i+1)) 
	else ()

    fun array_map (funct,a) = array_map' (funct,a,0)

    fun copyArray' (a, b, i) = if i = Array.length(a) 
				   then ()
				       else
	                       (Array.update(b,i,Array.sub(a,i))
				; copyArray' (a,b,i+1))
    
    fun copyArray (a,b) = if Array.length(a) > Array.length(b) 
			      then raise copyArray_error 
				  else copyArray'(a,b,0)

    fun getKids n = case n of Concat(r) => #kids(r)
                            | Container(r) => #kids(r)
			    | _ => (Array.array(0,Empty))

    fun getParent n = case n of Concat(r) => #parent(r)
                              | Container(r) => #parent(r)
                              | Simple(r) => #parent(r) 
                              | Limit(r) => #parent(r)
                              | RelNode(r) => #parent(r)
                              | RelRefNode(r) => #parent(r)
                              | _ => raise Match

    fun getGroup n = case n of Concat(r) => #group(r)
                              | Container(r) => #group(r)
                              | Simple(r) => #group(r) 
                              | Limit(r) => #group(r)
                              | RelNode(r) => #group(r)
                              | RelRefNode(r) => #group(r)
                              | _ => raise Match


    fun getIndex n = case n of Concat(r) => #index(r)
                             | Container(r) => #index(r)
                             | Simple(r) => #index(r)
                             | Limit(r) => #index(r)
                             | RelNode(r) => #index(r) 
                             | RelRefNode(r) => #index(r)
                             | _ => raise Match

    fun getAncIndex n = if n = Empty 
			    then raise Match
			else if getParent n = Empty 
				 then getIndex n
			     else getAncIndex (getParent(n))

    fun getDesc n = case n of Simple(r) => #desc(r)
                            | Concat(r) => #desc(r)
                            | Container(r) => #desc(r) 
                            | Limit(r) => #desc(r)
                            | RelNode(r) => #desc(r)
                            | RelRefNode(r) => #desc(r)
                            | Empty => INTERPUNCT

    fun getValue desc = case desc of INTERPUNCT => raise Match
                                   | VALUE(r) => #value(r)

    fun getTyp desc = case desc of INTERPUNCT => raise Match
                                 | VALUE(r) => #typ(r)

    fun getDepth n = case n of Limit(r) => #depth(r)
                             | Concat(r) => #depth(r)
                             | Container(r) => #depth(r)
                             | Simple(r) => #depth(r)
                             | RelNode(r) => #depth(r)
                             | RelRefNode(r) => #depth(r)
                             | _ => raise Match

    fun getGroup n =  case n of Concat(r) => #group(r)
                              | Container(r) => #group(r)
                              | Simple(r) => #group(r) 
                              | Limit(r) => #group(r)
                              | RelNode(r) => #group(r)
                              | RelRefNode(r) => #group(r)
                              | _ => raise Match

    fun getValueAnc n = let val p = getParent(n) 
			in if p = Empty 
			       then n 
			   else if getDesc(p) = INTERPUNCT
				    then getValueAnc(p) 
				else p
			end
	                  			 
    fun checkContKids (a,i) = if i >=  Array.length(a) 
				  then false
			      else (case Array.sub(a,i) of
				    Concat(r) 
				    => if checkConcKids (#kids(r),0)
	                                 then true
				       else checkContKids (a,i+1)
			   	  | RelNode(r) 
			            => ( case !(#content(r)) of 
					 Concat(rr)  
					 => checkConcKids (#kids(rr),0) 
					    orelse checkContKids (a,i+1) 
				       | Container(rr) => true 
				       | _ => checkContKids (a,i+1) ) 
				  | _ => checkContKids (a,i+1) )

    and checkConcKids (a,i) = if i >=  Array.length(a) 
				  then false 
			      else (case Array.sub(a,i) of
				    Container(r) => true
                                  | Concat(r) 
				    => checkConcKids(#kids(r),0)
				       orelse checkConcKids (a,i+1)
				  | RelNode(r) 
				    => ( case !(#content(r)) of 
					 Concat(rr)  
					 => checkConcKids (#kids(rr),0)  
					    orelse checkConcKids (a,i+1) 
				       | Container(rr) => true 
				       | _ => checkConcKids (a,i+1) )
                                  | _ => checkConcKids (a,i+1) )

   and setsVertical n = case n of
       Container(r) => checkContKids (#kids(r),0)
     | _ => false

    fun inspectList(n,x) = inspectList'(n,x,[])

    and inspectList'(n,x,xs) =
	if not(Future.isDetermined x) 
	    then Indet(List.rev xs, x) 
	else
	  if List.null x 
	      then Det(List.rev xs, false) 
	  else
	    if n = 0 
		then Det(List.rev xs, true) 
	    else inspectList'(n-1, List.tl x, List.hd x :: xs)

    fun castList value = UnsafeValue.cast value : 'a list

    fun setContent (n,c) = case n of RelNode(r) => #content(r) := c
                                   | _ => ()
                                        
    fun incrCounter n = case n of RelNode(r) 
	                          => (#counter(r) := !(#counter(r)) + 1; n)
                                | _ => n	

   fun iterTake str = iterTake'(str,0,"")
 
   and iterTake' (str,i,a) = 
       if i >= (String.length(str)) 
	   then a
       else
	   let val test = String.sub(str,i) 
	   in if Char.equal(#" ",test)
		  then a
	      else iterTake' (str,i+1, String.append(a,Char.toString(test)))
	   end  

   fun castPromise value = UnsafeValue.cast value : 'a Promise.promise

end

end
