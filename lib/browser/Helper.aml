(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Gdk       from "x-alice:/lib/gtk/Gdk"
import structure Gtk       from "x-alice:/lib/gtk/Gtk"
import structure GtkCanvas from "x-alice:/lib/gtk/GtkCanvas"
import structure Type      from "x-alice:/lib/rtt/Type"
import structure Label     from "x-alice:/lib/rtt/Label"
import structure Types     from "Types"
import structure Window    from "Window"
import structure WindowManager from "WindowManager"
import signature HELPER    from "HELPER-sig"

open Types

structure Helper :> HELPER = 
struct

    exception copyArray_error

    fun createValue(va,t,act) = VALUE{value = va,
				      typ = t,
				      actions = act}

    
    fun createGroupItem (parent,x,y) = 
	           GtkCanvas.itemNew(parent, 
				     GtkCanvas.GROUP,
				     [("x", Gtk.DOUBLE y), 
				      ("y", Gtk.DOUBLE y)])


    fun setGroup pnode = case pnode of 
	Simple(r)    => createGroupItem(#group(r),0.0,0.0) 
      | Container(r) => createGroupItem(#group(r),0.0,0.0) 
      | Concat(r)    => createGroupItem(#group(r),0.0,0.0) 
      | Limit(r)     => createGroupItem(#group(r),0.0,0.0) 
      | Empty        => createGroupItem(!WindowManager.canvasroot,0.0,0.0)
    
    fun isApply t = case t of Type.Apply(_,_) => true
                           | _ => false 

    fun unApply(Type.Apply(t1,t2))
       = let val t = ref (Type.inspect(t1)) 
             val l = ref [t2]
         in (while isApply (!t) do
             ( case !t of 
               Type.Apply(t11,t12) => (t := (Type.inspect(t11)) 
				       ; l:= [t12]@(!l))
             | _ => () ) ; (!t,!l))
	 end

    fun row2list row = case Type.inspectRow(row) of 
	Type.EmptyRow => nil
      | Type.UnknownRow => nil
      | Type.FieldRow(lab,t,row2) => 
	    (lab,t)::row2list(row2)

    fun labelvector (ll:(Label.lab * Type.typ) list) = 
	Vector.tabulate ((List.length(ll)), 
			 (fn i =>(#1( List.nth(ll,i))) ) )  

    fun array_map' (funct,a,i) = 
	if i < Array.length(a) 
	    then (funct(Array.sub(a,i));array_map' (funct,a,i+1)) 
	else ()

    fun array_map (funct,a) = array_map' (funct,a,0)

    fun copyArray' (a, b, i) = if i = Array.length(a) 
				   then ()
				       else
	                       (Array.update(b,i,Array.sub(a,i))
				; copyArray' (a,b,i+1))
    
    fun copyArray (a,b) = if Array.length(a) > Array.length(b) 
			      then raise copyArray_error 
				  else copyArray'(a,b,0)

    fun getKids n = case n of Concat(r) => #kids(r)
                            | Container(r) => #kids(r)
			    | _ => (Array.array(0,Empty))

    fun checkVertical (a,i) = if i >=  Array.length(a) 
				  then false
			      else case Array.sub(a,i) of
				  Concat(r) 
                                  => if checkVertical (#kids(r),0)
					 then true
				     else checkVertical (a,i+1)
                                | Container(r) 
				  => if setsVertical (Array.sub(a,i))
					 then true
				     else checkVertical (a,i+1)
                                | _ => checkVertical (a,i+1)   

   and setsVertical n = case n of
       Container(r) => checkVertical (#kids(r),0)
     | _ => false

end;
