(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Inf from "x-alice:/lib/rtt/Inf"
import structure Type from "x-alice:/lib/rtt/Type"
import structure Reflect from "x-alice:/lib/system/Reflect" 

import structure GtkSupport from "GtkSupport"

signature NODE = 
sig
    
    datatype value = V of Reflect.value | M of Reflect.module
    
    datatype limit = DEPTH_LIMIT | WIDTH_LIMIT
	
    datatype status = CLEAN | DIRTY | DAZZLED 
	
    datatype color_class = INT_COLOR 
                         | REAL_COLOR
                         | CHAR_COLOR
                         | STR_COLOR
                         | WORD_COLOR
                         | EXN_COLOR
                         | REF_COLOR
                         | LABEL_COLOR
                         | SEP_COLOR
                         | EQU_COLOR
                         | LIMIT_COLOR
                         | BRACK_COLOR
                         | REL_COLOR
                         | DEFAULT

    (* datatype for storage of value and type information in nodes *)
   
    datatype desc = 
	INTERPUNCT
      | VALUE of {value : Reflect.value,
		  typ : Type.typ}
      | I_VALUE of {value : Reflect.module,
		    typ : Inf.t} 

    (* datatype for internal representation of values *)

    datatype node = 
	Simple of {desc : desc, 
		   parent : node,
		   index : int,
		   depth : int,
		   rep : string,
		   width : int ref,
		   color : color_class, 
		   status : status ref,
		   group : GtkSupport.tag}
	
      | Concat of {desc : desc, 
		   parent : node,
		   index : int,
		   depth : int,
		   kids : node array, 
		   width : int ref,
		   l_width: int ref,
		   height : int ref,
		   status : status ref,
		   group : GtkSupport.tag}
	
      | Container of {desc : desc, 
		      parent : node,
		      index : int,
		      depth : int,
		      kids : node array, 
		      width : int ref,
		      height : int ref,
		      l_width : int ref,
		      status : status ref,
		      group : GtkSupport.tag}
	
      | Limit of {desc : desc,
		  sort : limit, 
		  parent : node,
		  index : int,
		  depth : int,
		  status : status ref,
		  group : GtkSupport.tag}
	
      | RelNode of {desc : desc, 
		    content : node ref,
		    parent : node,  
		    index : int, 
		    depth : int,
		    counter : int ref, 
		    rep : string, 
		    relman : (value * int ref * int) list ref, 
		    width : int ref,
		    height : int ref,
		    color : color_class, 
		    status : status ref, 
		    group : GtkSupport.tag }  
	
      | RelRefNode of {desc : desc, 
		       parent : node, 
		       index : int,
		       depth : int,
		       rep : string, 
		       width : int ref, 
		       color : color_class, 
		       status : status ref,  
		       group : GtkSupport.tag}  
	
      | Empty

    (**********************************************)

    (* test for special case list *) 

    val compList : Type.t
    val isListType: Type.t -> bool

    (* test for special case sum type *)

    val isSumType: Type.t -> bool

    (**********************************************)

    (* operations on value *)
    
    val asValue: value -> Reflect.value
    val asModule: value -> Reflect.module

    val isValue: value -> bool
    val isModule: value -> bool

    (* operations on desc *)

    val createValue  :  Reflect.value * Type.t -> desc
    val createIValue :  Reflect.module * Inf.t -> desc
	
    val getValue : desc -> Reflect.value
    val getInfValue : desc -> Reflect.module

    val getTyp : desc -> Type.typ
    val getInf : desc -> Inf.t
	
    (****** operations on node ******)

    (** get-functions **)

    val getDesc : node -> desc
    val getReflectValue : node -> Reflect.value

    val getParent : node -> node
    val getIndex : node -> int
    val getDepth : node -> int
    val getRep : node -> string
    val getKids : node -> node Array.array
    val getContent : node -> node
    val getStatus : node -> status ref
    val getGroup : node -> GtkSupport.tag
    val getColor : node -> color_class
    val getSort : node -> limit

    (* needed by Layout *)

    val get_xdim : node -> int
    val get_ydim : node -> int
    val get_l_xdim : node -> int
    
    (* information about ancestors *)

    val getValueAnc : node -> node
    val getNoRelAnc : node -> node * int
    val getAncIndex : node -> int 

    (** modification of node fields **)

    val setContent : node * node -> unit
    val setGroup :  GtkSupport.tag * node -> GtkSupport.tag

    val setDazzled : node -> unit
    val updateChild : node * int * node -> unit   

    (** low level construction **)

    val relnumber: int ref

    val createSimple: 
        desc * node * int * int * string * color_class * GtkSupport.tag 
	-> node
    
    val createConcat: 
	desc * node * int * int * node array * GtkSupport.tag 
	-> node
	
    val createContainer: 
	desc * node * int * int * node array * GtkSupport.tag 
	-> node
    
    val createLimit: desc * limit * node * int * int * GtkSupport.tag 
	-> node

    val createRelNode : 
	desc * node * node * int * int * int ref * string * 
	(value * int ref * int) list * GtkSupport.tag -> node
   
    val createRelRefNode : 
	desc * node * int * int * string * GtkSupport.tag 
	-> node

    (** boolean tests **)

    val isSimple : node -> bool
    val isContainer : node -> bool
    val isRelNode : node -> bool
    val isRelRefNode : node -> bool
    
    val isLimit : node -> bool
    val isDepthLimit : node -> bool
    val isWidthLimit : node -> bool
    
    val isByneed : node -> bool 

    (* layout information *)
    val setsVertical : node -> bool 

end
