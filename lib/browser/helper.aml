import structure Type from "x-alice:/lib/rtt/Type"
import structure Path from "x-alice:/lib/rtt/Path"
import structure Gtk from "x-alice:/lib/gtk/Gtk"
import structure UnsafeValue from "x-alice:/lib/system/UnsafeValue"
import structure Label from "x-alice:/lib/rtt/Label"
import structure Types from "type"

open Types

(*** Signatur HELPER ***)

signature HELPER = 
sig

(* Test, ob ein ContNode als Kinder wieder zusammengesetzte Knoten hat *)    
    val lookup': Node array * int -> bool
    val lookup: Node array -> bool
    val hasContChild: Node -> bool

(* Hilfsfunktionen zur Modifizierung von Nodes *)
    val setContent: Node * Node -> unit 
    val updNodes: Node * int * Node -> unit
    val setParent: Node * Node -> unit

(* Hilfsfunktionen zur Typbestimmung *)
    val isApply: Type.desc -> bool
    val unApply: Type.desc -> Type.desc * Type.t list 
    val getPath: Type.desc -> Path.path

(* 'valOf'- Funktion zum Zugriff auf den Inhalt eines INTERNALs *)
    val fromInternal: doc -> (Node * int * int -> Node)

(* Operationen auf Rows *)
    val getlabellist : Type.row -> (Label.lab * Type.typ) list
    val labelvector : (Label.lab * Type.typ) list -> Label.lab Vector.vector
    val iterProjTagged : 'a * Label.lab Vector.vector -> 'b list
    val iterProj : 'a * Label.lab Vector.vector -> 'b list

(* Operationen auf Nodes *)
    val nodes: Node -> Node array
    val isSumLabel: Node -> bool

end;

(*** Struktur Helper ***)

structure Helper :> HELPER = 
struct
    
(* diverse Hilfsfunktionen, die in verschiedenen Strukturen benoetigt werden *)
    
    fun lookup' (a,i)  = let val l = Array.length(a)
			 in if i >= l 
				then false
			    else case Array.sub(a,i) of
				SimpleNode(r) => lookup' (a,i+1)
			      | BracketNode(r) 
				=> if Type.isSum(#istype(r))
				       then let val co = !(#content(r))
					        val coa = (case co of
					                   ContNode(rr)
                                                           => #nodes(rr)
                                                         | _ => raise NoNode)
                                            in if lookup coa 
						   then true
					       else lookup' (a,i+1)
					    end
				   else true
			      | LabelNode(r) => (case (!(#content(r))) of
						     BracketNode(_) => true
						   |_ =>  lookup' (a,i+1))
			      | SepNode(r) => (case (!(#content(r))) of
					       BracketNode(_) => true
					     |_ =>  lookup' (a,i+1))
			      | LimitNode(r) => lookup' (a,i+1)
			      | _=> raise lookupError
			 end
	       
    and  lookup a = lookup' (a,0)                         
	
    fun hasContChild n = case n of SimpleNode(r) => false
                       | BracketNode(r) => hasContChild(!(#content(r)))
		       | SepNode(r) => hasContChild(!(#content(r)))
		       | LabelNode(r) => hasContChild(!(#content(r)))
		       | EmptyNode => false
		       | ContNode(r) => lookup (#nodes(r))

   fun setContent (BracketNode(r),c) = #content(r) := c
     | setContent (SepNode(r),c) = #content(r) := c
     | setContent (LabelNode(r),c) = #content(r) := c
     | setContent (_ ,c) = ()  
 
   fun updNodes (ContNode(r),i,n) = Array.update(#nodes(r),i,n)
     | updNodes (_,i,n) = ()

   fun setParent (BracketNode(r),p) = #parent(r) := p
     | setParent (SepNode(r),p) = #parent(r) := p
     | setParent (LabelNode(r),p) = #parent(r) := p  
     | setParent (ContNode(r),p) = #parent(r) := p  
     | setParent (SimpleNode(r),p) = #parent(r) := p  
     | setParent (LimitNode(r),p) = #parent(r) := p  
     | setParent (EmptyNode,p) = () 
       
   fun isApply t = case t of Type.Apply(_,_) => true
                           | _ => false 

   fun unApply(Type.Apply(t1,t2))
       = let val t = ref (Type.inspect(t1)) 
             val l = ref [t2]
         in (while isApply (!t) do
             ( case !t of 
               Type.Apply(t11,t12) => (t := (Type.inspect(t11)) 
				       ; l:= [t12]@(!l))
             | _ => () ) ; (!t,!l))
	 end

   fun getPath (Type.Con(path)) = path
     | getPath _ = raise NoPath

   fun fromInternal (INTERNAL(f)) = f
     | fromInternal _ = raise NoInternal
  
   fun getlabellist row = case Type.inspectRow(row) of 
                            Type.EmptyRow => nil
			  | Type.UnknownRow => nil
			  | Type.FieldRow(lab,t,row2) => 
				(lab,t)::getlabellist(row2)

   fun labelvector (ll:(Label.lab * Type.typ) list) = 
       Vector.tabulate ((List.length(ll)), 
		 (fn i =>(#1( List.nth(ll,i))) ) )  

   fun iterProjTagged(v,vect) = let val l = Vector.length(vect)
				    val res = List.tabulate 
					(l,
					 fn i 
					 => UnsafeValue.projTagged(v,vect,i))
				in res 
				end
   fun iterProj(v,vect) = let val l = Vector.length(vect)
			      val res = List.tabulate 
				  (l,
				   fn i 
				   => UnsafeValue.proj(v,vect,i))
			  in res 
			  end
 
   fun nodes (ContNode(r)) = #nodes(r)
      | nodes _ = raise NoNode

   fun isSumLabel (LabelNode(r)) = let val p = !(#parent(r)) 
                                   in (case p of 
                                       ContNode(rr) 
				       => if Type.isSum(#istype(rr))
                                           then true else false
				     | SepNode(rr) 
                                       => let val pp = !(#parent(rr))
                                          in (case pp of
                                              ContNode(rrr) 
					      => if Type.isSum(#istype(rrr))
						     then true else false
                                            | _ => raise NoNode)
					  end
				     | _ => raise NoNode)
				   end
     | isSumLabel _ = false
 
                                                                
end
