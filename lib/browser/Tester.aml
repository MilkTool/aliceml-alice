import structure NewNode from "NewNode";
import structure Layout from "Layout";
import structure UnsafeInspector from "UnsafeInspector";
import structure Reflect from "x-alice:/lib/system/Reflect";

(* ganz einfache Werte *)

structure IntList = Reflect.ReflectType(type t = int vector list * int vector);
UnsafeInspector.inspect(([#[4,5]],#[4,5]),IntList.x);

structure Int = Reflect.ReflectType(type t = int);
UnsafeInspector.inspect(4,Int.x);

(*** Einstellungen von max. Tiefe, max. Breite und Modus koennen im
     Inspectormenu veraendert werden ***)

(* Tupel mir verschiedenen "einfachen" Werten - zum Testen des Breitenfilters
   geeignet *)

structure STuple = Reflect.ReflectType 
    (type t = int * real * string * word * exn * char);
val s_tuple = STuple.x;
exception Error;

UnsafeInspector.inspect ((111,5.0,"hi",0w17,Error,#"d"),s_tuple);

(* Record mit Referenz, Vektor und Array - zum Testen des RelModus mit
   struktureller Gleichheit geeignet *)

structure RVAAr1 = Reflect.ReflectType 
    (type t = real list array);
val rva_ar1 = RVAAr1.x;
val x = 1.0;

UnsafeInspector.inspect (Array.array(2,[x]), rva_ar1);
	  
structure RVARec = Reflect.ReflectType 
    (type t = {ref: string ref,vec1: (int * int) vector,
	       vec2: (int * int) vector, arr: real array});
val rva_rec = RVARec.x;
val my_array = let val a = Array.array(2,1.0)
		   val _ = Array.update(a,0,2.0)
	       in a end;

UnsafeInspector.inspect ({ref = ref "hallo",vec1 = #[(4,5),(6,7)],
                          vec2 = #[(6,7),(4,5)], arr = my_array},rva_rec); 

(* Datentyp *)
datatype foo = A 
             | B of int ref list
             | C of foo 
             | D of (string vector vector * int vector vector) list
             | E of int;
structure DataType = Reflect.ReflectType (type t = foo);
val data_type = DataType.x;
val same = ref 44; (* zum Testen des " Relation Mode - Token Equality" *)

UnsafeInspector.inspect (E 1,data_type);
UnsafeInspector.inspect (A,data_type);
UnsafeInspector.inspect (B [same,same,same],data_type);
UnsafeInspector.inspect (C (C (B [ref 55,ref 88])),data_type);
UnsafeInspector.inspect (D [{1 = #[#["hi","du"],#["guck","mal"]], 
			     2 = #[#[0,8,1,5],#[4,7,1,1]]},
			    {1 = #[#["ich","kann"],#["Listen","zeichnen"]], 
			     2 = #[#[0,8,1,5],#[4,7,1,1]]}                  ],
			 data_type);

structure Test = Reflect.ReflectType (type t = int vector list);
UnsafeInspector.inspect([#[1,2],#[1,1]],Test.x);

(*
structure IntList = Reflect.ReflectType (type t = (int * int) list);
val int_list = IntList.x;
val rec l = (3,4)::l;

UnsafeInspector.inspect (l,int_list); *)


(* Futures *)
structure Fut = Reflect.ReflectType (type t = int vector list);
val fut = Fut.x;
val prom1 = Promise.promise();
val prom2 = Promise.promise();
val future1 = Promise.future prom1;
val future2 = Promise.future prom2;

UnsafeInspector.inspect([future1,future2,future1,future1],fut);

Promise.fulfill(prom1,#[1,2]);

Promise.fulfill(prom2,#[2,3,4,5,6]);



