import structure UnsafeInspector from "UnsafeInspector";
import structure Reflect from "x-alice:/lib/system/Reflect";

(* ganz einfache Liste *)

structure SList = Reflect.ReflectType (type t = int list);

(* UnsafeInspector.inspect ([[1,2],[1,2]],SList.x) *)

UnsafeInspector.inspect ([1,2],SList.x);

val rec x = 1::x;
UnsafeInspector.inspect(x,SList.x);

(* Tupel mir verschiedenen "einfachen" Werten - zum Testen des Breitenfilters
   geeignet *)

structure STuple = Reflect.ReflectType 
    (type t = int * real * string * word * exn * char);
val s_tuple = STuple.x;
exception Error;

UnsafeInspector.inspect ((111,5.0,"hi",0w17,Error,#"d"),s_tuple);

(* Record mit Referenz, Vektor und Array - zum Testen des RelModus mit
   struktureller Gleichheit geeignet *)

structure RVARec = Reflect.ReflectType 
    (type t = {ref: string ref,vec1: (int * int) vector,
	       vec2: (int * int) vector, arr: real array});
val rva_rec = RVARec.x;
val my_array = let val a = Array.array(2,1.0)
		   val _ = Array.update(a,0,2.0)
	       in a end;

UnsafeInspector.inspect ({ref = ref "hallo",vec1 = #[(4,5),(6,7)],
                          vec2 = #[(6,7),(4,5)], arr = my_array},rva_rec); 

structure Rec = Reflect.ReflectType(type t = {arr: real array});
val recc = Rec.x;
UnsafeInspector.inspect({arr = my_array},recc);

structure Arr = Reflect.ReflectType(type t = real array);
val arr = Arr.x;
UnsafeInspector.inspect(my_array,arr);

(* Datentyp *)
datatype foo = A 
             | B of int ref list
             | C of foo 
             | D of (string vector vector * int vector vector) list

structure DataType = Reflect.ReflectType (type t = foo);
val data_type = DataType.x;
val same = ref 44; (* zum Testen des " Relation Mode - Token Equality" *)

UnsafeInspector.inspect (A,data_type);
UnsafeInspector.inspect (B [same,same,same],data_type);
UnsafeInspector.inspect (C (C (B [ref 55,ref 88])),data_type);
UnsafeInspector.inspect (D [{1 = #[#["hi","du"],#["guck","mal"]], 
			     2 = #[#[0,8,1,5],#[4,7,1,1]]},
			    {1 = #[#["ich","kann"],#["Listen","zeichnen"]], 
			     2 = #[#[0,8,1,5],#[4,7,1,1]]}                  ],
			 data_type);
UnsafeInspector.inspect(C(C(A)),data_type);

structure Test = Reflect.ReflectType (type t = int vector vector list);
UnsafeInspector.inspect([#[#[1,1],#[1,1]],#[#[2,2],#[2,2]]],Test.x);


structure IntList = Reflect.ReflectType (type t = (int * int) list);
val int_list = IntList.x;
val rec l = (3,4)::l;

UnsafeInspector.inspect (l,int_list); 

(* Futures *)
structure Fut = Reflect.ReflectType (type t = int vector list);
structure Fut2 = Reflect.ReflectType (type t = int vector vector)
val fut = Fut.x;
val fut2 = Fut2.x;

val prom1 = Promise.promise();
val prom2 = Promise.promise();
val prom3 = Promise.promise();    
val future1 = Promise.future prom1;
val future2 = Promise.future prom2;
val future3 = Promise.future prom3;

UnsafeInspector.inspect([future1,future2,future1,future1],fut);

UnsafeInspector.inspect(#[future2,future1],fut2);

Promise.fulfill(prom1,#[1,2]);

Promise.fulfill(prom2,#[2,3,4,5,6]);

(* Liste mit future *)

val lf = [#[7,8]]@future3;

UnsafeInspector.inspect(lf,fut);

Promise.fulfill(prom3,[#[1,2],#[9,10]]);

(* Promises *)
structure Prom = Reflect.ReflectType (type t = char Promise.promise list);
val promise1 = Promise.promise();
val promise2 = Promise.promise();

UnsafeInspector.inspect ([promise2,promise1,promise2],Prom.x);

Promise.fulfill(promise1,#"o");

Promise.fulfill(promise2,#"n");

(***)

val x = lazy 4711;

structure Int = Reflect.ReflectType (type t = int);

UnsafeInspector.inspect(x,Int.x);

(* Packages *)

structure P = Package.Pack (signature S = GTK structure X = Gtk);
structure Pack = Reflect.ReflectType (type t = Package.package);

UnsafeInspector.inspect(P.package,Pack.x);

(* val_Packages *)

structure P_v = Package.PackVal (type t = char vector * char vector
				 val x = (#[#"h",#"i"],#[#"d",#"u"]));
structure Pack_v = Reflect.ReflectType (type t = Package.val_package);

UnsafeInspector.inspect(P_v.package,Pack_v.x);



