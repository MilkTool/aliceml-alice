(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure TextIO from "x-alice:/lib/system/TextIO"
import structure Services from "Services"
import structure Types from "Types"
import structure Helper from "Helper"
import structure Layout from "Layout"
import signature DRAW_NODES from "DRAW_NODES-sig"
import structure ColorMap from "ColorMap"
import structure MkColorTable from "MkColorTable"

open Types Helper Layout 

structure DrawNodes :> DRAW_NODES =
struct

    exception  MissingColor
    exception DrawError
    exception NodeFound of node
    exception Scream

    datatype intention = DRAW | SEARCH of int * int
    	   
    (* atomDraw *)
    fun atomDraw (node,x,y)  = case node of
	Simple(r) 
	=>   ( let val (rx,ry) =  (Real.fromInt(x* 8 +2),
				   Real.fromInt(y*13 +2))
		   val color = case ColorMap.lookup(MkColorTable.colorTable,
						    #color(r))
		       of SOME x => x
		     | NONE   => raise MissingColor
		   val _ = Services.printXY (#rep(r),
					     #group(r),
					     rx,
					     ry,
					     color,
					     "8x13")
		   val _ = #status(r) := Types.CLEAN
	       in (x+String.length(#rep(r)),y)
	       end )
      | Limit(r) 
	=> (let val (rx,ry) =  (Real.fromInt(x* 8 +2),
				Real.fromInt(y*13 +2))
		val color = case ColorMap.lookup(MkColorTable.colorTable,
						 LIMIT_COLOR)
		    of SOME x => x
		  | NONE   => raise MissingColor
		val limitsig = if #sort(r) = Types.DEPTH_LIMIT
				   then "*" 
			       else "@"
		val _ = Services.printXY (limitsig,
					  #group(r),
					  rx,
					  ry,
					  color,
					  "8x13")
		val _ = #status(r) := Types.CLEAN     
	    in (x+1,y)
	    end )
      | RelRefNode(r)
        =>  ( let val (rx,ry) =  (Real.fromInt(x* 8 +2),
				  Real.fromInt(y*13 +2))
		   val color = case ColorMap.lookup(MkColorTable.colorTable,
						    #color(r))
		       of SOME x => x
		     | NONE   => raise MissingColor
		   val _ = Services.printXY (#rep(r),
					     #group(r),
					     rx,
					     ry,
					     color,
					     "8x13")
		   val _ = #status(r) := Types.CLEAN
	       in (x+String.length(#rep(r)),y)
	       end )
      | RelNode(r)
	=> ( let val (rx,ry) =  (Real.fromInt(x* 8 +2),
				  Real.fromInt(y*13 +2))
		   val color = case ColorMap.lookup(MkColorTable.colorTable,
						    #color(r))
		       of SOME x => x
		     | NONE   => raise MissingColor
		   val _ = Services.printXY (#rep(r),
					     #group(r),
					     rx,
					     ry,
					     color,
					     "8x13")
		   val _ = #status(r) := Types.CLEAN
	       in (x+String.length(#rep(r)),y)
	       end )
      | _ => raise DrawError

    and atomSearch(n,x,y,intent) = case intent of
	SEARCH(sx,sy) => (case n of
			      Simple(r) => atomSearch'(n,x,y,sx,sy,#rep(r),#desc(r))
			    | Limit(r) =>  atomSearch'(n,x,y,sx,sy,"!",#desc(r))
			    | RelNode(r) => atomSearch'(n,x,y,sx,sy,#rep(r),#desc(r))
			    | RelRefNode(r) => atomSearch'(n,x,y,sx,sy,#rep(r),#desc(r))
			    |  _ => raise Match)
      | _ => raise Match

    and atomSearch'(n,x,y,sx,sy,rep,desc) = 
	let 
	    val _ = TextIO.print(" entering atomSearch with " ^ rep ^ "\n")
	    val in_bounding_box = sx >= x 
		andalso sx < x + String.length(rep) 
		andalso sy = y
	    val interpunct = case desc of
		INTERPUNCT => true
	      | _ => false
	    val toBeDisplayed = case n of 
		(Limit _ | RelNode _ | RelRefNode _ ) => true
	      | _ => false
	    val _ =  TextIO.print(" Node fits in bounding_box:  " 
				  ^ Bool.toString(in_bounding_box)  ^ "\n")
	in
	    if (in_bounding_box  andalso not(interpunct)) orelse toBeDisplayed 
		then (x + String.length(rep),
		      y,
		      SOME(n))
	    else (x + String.length(rep),
		  y,
		  NONE)
	end

				
    (* drawSimple *)
    and drawSimple (n,x,y,intent) = let
	val _ = TextIO.print("Entering draw Simple \n ")
	    in
		case n of
	Simple(r) => (case intent of 
			  DRAW => if !(#status(r)) = DIRTY
				      then 
					  let
					      val (x2,y2) = atomDraw (n,x,y)
						  in
						      (x2,y2,NONE)
					  end
				  else (x+get_xdim(n),y+get_ydim(n),NONE)
			| SEARCH _ => atomSearch (n,x,y,intent))
      | _ => raise DrawError
	    end
	    
    (* drawLimit *)
    and drawLimit (n,x,y,intent) = case n of
	Limit(r) => (case intent of
			 DRAW => if !(#status(r)) = Types.DIRTY 
				     then 
					 let
					     val (x2,y2) = atomDraw (n,x,y)
					 in
					     (x2,y2,NONE)
					 end
				 else (x + get_xdim(n),y + get_ydim(n),NONE)
				     | SEARCH _ => atomSearch (n,x,y,intent))
      | _ => raise DrawError
			
    (* drawConcat *) 
    and drawConcat (n,x,y,intent) = case n of
	Concat(r) 
	=> let
	       val (search,sx,sy) = case intent of
		   DRAW => (false,0,0)
		 | SEARCH(sx,sy) => (true,sx,sy)
		        val _ = TextIO.print("Concat: starting search"  ^ "\n")
	in
	if !(#status(r)) = DIRTY  orelse search
	       then let val kids_list = Array.toList(#kids(r))
			val l = List.length(kids_list) - 1
			val i = ref 0
			val in_bounding_box = sx >= x 
			    andalso sx < x + !(#width(r))
			    andalso sy >= y 
			    andalso sy < y + !(#height(r))
			    val _ = TextIO.print("Concat: in bounding box: " 
						 ^ Bool.toString(in_bounding_box)
						 ^ " because sx = " ^Int.toString(sx)
						 ^ " and sy = " ^Int.toString(sy)
						 ^ " and x = " ^Int.toString(x)
						 ^ " and y = " ^Int.toString(y)
						 ^ "\n")
		    in 
			if search andalso (not(in_bounding_box)) 
			    then let
				val _ = TextIO.print(
		      " Concat was not in bounding box, search abandoned \n")
				    in
				(x+get_xdim(n),y+get_ydim(n)-1,NONE)
				end
				else 
				    ( while !i <= l do
					  (let val li = List.take(kids_list,!i)
					       val sum_xdim = 
						   if !i = l 
						       andalso !i > 0
						       andalso setsVertical (List.nth(kids_list,
										      !i-1))
						       then 
							   let val li' = List.take(kids_list,!i-1)
							   in sum_up(li',get_xdim,get_l_xdim) +
							       get_l_xdim(List.nth(kids_list,!i-1))
							   end 
						   else sum_up(li,get_xdim,get_l_xdim)
					       val max_ydim =  max(li,get_ydim)
					       val (x2,y2,found) = draw (List.nth(kids_list,!i),
						    x + sum_xdim,
						    if !i = 0 then y else y + max_ydim - 1,
							intent)
					       val _ = case found 
						   of SOME n => raise NodeFound(n)
						 | NONE => ()
					       in
						   ()
					   end ; i := !i + 1) 
					       ; #status(r) := CLEAN
					       ; (x+get_xdim(n),y+get_ydim(n) - 1,if in_bounding_box 
										      then SOME (n)
											  else NONE) )
					  handle NodeFound(n) => let
					      val _ = TextIO.print("Concat: found node!"  ^ "\n")
						  in
						      (x,y,SOME(n))
						      end
		    end
		
	else (x+get_xdim(n),y+get_ydim(n),NONE)
	   end
      | _ => raise DrawError
	   
    (* drawContainer *)
    and drawContainer(n,x,y,intent) =  case n of
       Container(r) 
       => let
              val _ = TextIO.print("Container: starting search" ^ "\n")
	      val (search,sx,sy) = case intent of
		  DRAW => (false,0,0)
		| SEARCH(xs,ys) => (true,xs,ys)
	      val in_bounding_box = sx >= x 
		  andalso sx < x + !(#width(r))
		  andalso sy >= y 
		  andalso sy < y + !(#height(r))
	  in
	      if !(#status(r)) = DIRTY orelse search 
		  then if Array.length(#kids(r)) = 0
			   then (x,y,if in_bounding_box then SOME(n) else NONE)
		       else (let             
				 val _ = if
				     not(search) 
					     then #status(r) := Types.CLEAN
					 else ()
				 val hor_funct = (fn (a,(x,y,found)) 
						  => case found of
						  SOME n => if not(search) 
								then draw(a,x,y,intent)
								    else raise NodeFound(n)
						| NONE => draw(a,x,y,intent))
				 val ver_funct = (fn (a,(x,y,found)) 
						  => let
							 val (x1,y1,found2) = 
							     draw(a,x,y,intent)
						     in
							 case found2 of
							     SOME n => raise NodeFound(n)
								 | NONE => (x,y1+1,found2)
						     end)
				 val funct = if setsVertical(n) 
						 then ver_funct
					     else hor_funct
				 val _ = TextIO.print("Container: setting vertical : " 
						      ^ Bool.toString(setsVertical(n)) ^ "\n")
				 
			     in
				 if 
				     search andalso not(in_bounding_box) 
				     then (x+get_xdim(n),y+get_ydim(n),NONE) 
				 else
				     let
					 val (new_x,new_y,new_found) = 
					     (Array.foldl funct (x,y,NONE) (#kids(r))) 
					     handle NodeFound n => let
						 val _ = TextIO.print("Container: found node!" ^ "\n")
								      in
									 (x,y,SOME(n))
									 end
					 val nothing_found = case new_found of
					     NONE => true
					   | SOME _ => false
				     in
					 if search andalso in_bounding_box andalso nothing_found
					     then (new_x,new_y,SOME(n))
					 else (new_x,new_y,new_found)
				     end
			     end)
	      else 
		  (x + get_xdim(n), y + get_ydim(n),NONE) 
	  end
     | _ => raise DrawError

    (* drawRelNode *)
    and drawRelNode (n,x,y,intent) = case n of
	RelNode(r) => (let
	    val _ = TextIO.print("Entering drawRelNode \n")
		in
	    case intent of
	    DRAW => if !(#status(r)) = DIRTY
			  then (case !(#counter(r)) of
                                1 => draw (!(#content(r)),x,y,intent)
			      | _ => let val (new_x,new_y) = atomDraw (n,x,y)
				     in draw (!(#content(r)),new_x,new_y,intent)
				     end)
		    else if !(#counter(r)) = 1
			     then (x+get_xdim(!(#content(r))),
				   y+get_ydim(!(#content(r))),
				   NONE)
			 else (x+get_xdim(n),y+get_ydim(n),NONE)
	| SEARCH(sx,sy) => (case !(#counter(r)) of
			     1 =>  draw (!(#content(r)),x,y,intent)
			   | _ => let 
				    val label_in_bounding_box = sx >= x 
					andalso sx < x + String.length(#rep(r)) 
					andalso sy = y  
				  in
				      if label_in_bounding_box then (x,y,SOME(n))
					  else draw (!(#content(r)), 
							 x + String.length(#rep(r))
							 ,y
							 ,intent)
				  end)
			     end)
	| _ => raise DrawError

    (* drawRelRefNode *)
    and drawRelRefNode (n,x,y,intent) = case n of
	RelRefNode(r) => case intent of
	    DRAW => if !(#status(r)) = DIRTY
			     then let
				      val (x2,y2) = atomDraw (n,x,y)
				  in
				      (x2,y2,NONE)
				  end
			 else (x+String.length(#rep(r)),y,NONE)
	  | SEARCH _ => atomSearch(n,x,y,intent) 
      | _ => raise DrawError
       
    (* draw *)
    and draw (n,x,y,intent) = case n of
	Simple(r) => (case intent of 
			  DRAW =>
			      if !(#status(r)) = DIRTY
				  then drawSimple (n,x,y,intent)
			      else (x+get_xdim(n),y+get_ydim(n),NONE)	
			| SEARCH _ => drawSimple (n,x,y,intent))
      | Concat(r) => (case intent of 
			  DRAW => if !(#status(r)) = DIRTY
			 then drawConcat (n,x,y,intent)
		     else (x+get_xdim(n),y+get_ydim(n),NONE)
			  | SEARCH _ => drawConcat (n,x,y,intent))
      | Container(r) => (case intent of
			     DRAW => if !(#status(r)) = DIRTY
			    then drawContainer (n,x,y,intent)
			else (x+get_xdim(n),y+get_ydim(n),NONE)
		| SEARCH _ => drawContainer(n,x,y,intent))	     
      | Limit(r) => (case intent of
			 DRAW => if !(#status(r)) = DIRTY
			then drawLimit (n,x,y,intent)
		    else (x+get_xdim(n),y+get_ydim(n),NONE)
		       | SEARCH _ => drawLimit (n,x,y,intent))
      | RelNode(r) => (case intent of
			   DRAW => (if !(#status(r)) = DIRTY
				       then drawRelNode (n,x,y,intent)
				   else ( case !(#counter(r)) of
					 1 => (x+get_xdim(!(#content(r))),
					       y+get_ydim(!(#content(r))),
					       NONE)
				       | _ => (x+get_xdim(n),y+get_ydim(n),NONE) ))
			       | SEARCH _ =>  drawRelNode (n,x,y,intent))
      | RelRefNode(r) => (case intent of
			       DRAW => if !(#status(r)) = DIRTY
					   then drawRelRefNode (n,x,y,intent)
				       else (x+get_xdim(n),y+get_ydim(n),NONE)
			     | SEARCH _ =>  drawRelRefNode (n,x,y,intent))
      | Empty => (x,y,NONE)

end
       
