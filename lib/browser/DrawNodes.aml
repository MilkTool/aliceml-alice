(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Inspector from "x-alice:/lib/tools/Inspector"
import structure TextIO from "x-alice:/lib/system/TextIO"
import structure Services from "Services"
import structure Types from "Types"
import structure Helper from "Helper"
import structure Layout from "Layout"
import signature DRAW_NODES from "DRAW_NODES-sig"
import structure ColorMap from "ColorMap"
import structure WindowHelper from "WindowHelper"
import structure Settings from "Settings"
import structure MkColorTable from "MkColorTable"
import structure GtkCanvas from "x-alice:/lib/gtk/GtkCanvas"

open Types Helper Layout 

structure DrawNodes :> DRAW_NODES =
struct

    exception MissingColor
    exception DrawError
    exception NodeFound of int * int * node

    datatype intention = DRAW | SEARCH of int * int
    	   
    (* atomDraw *)
    fun atomDraw (node,x,y)  = case node of
	Simple(r) 
	=> (let 
		val w = WindowHelper.fontWidth(!Settings.font)
		val h = WindowHelper.fontHeight(!Settings.font)
		val (rx,ry) = (Real.fromInt(x* w),Real.fromInt(y*h)) 
		val color = case ColorMap.lookup(MkColorTable.colorTable,
						 #color(r)) of 
		            SOME x => x
			  | NONE   => raise MissingColor
		val _ = Services.printXY (#rep(r),
					  #group(r),
					  rx,
					  ry,
					  color,
					  !Settings.font)
		val _ = #status(r) := Types.CLEAN
 	    in (x+String.length(#rep(r)),y)
	    end )
      | Limit(r) 
	=> (let
		val w = WindowHelper.fontWidth(!Settings.font)
		val h = WindowHelper.fontHeight(!Settings.font)
	        val (rx,ry) = (Real.fromInt(x* w),Real.fromInt(y*h)) 
		val color = case ColorMap.lookup(MkColorTable.colorTable,
						 LIMIT_COLOR) of 
		            SOME x => x
			  | NONE   => raise MissingColor
		val limitsig = if #sort(r) = Types.DEPTH_LIMIT
				   then "*" 
			       else "@"
		val _ = Services.printXY (limitsig,
					  #group(r),
					  rx,
					  ry,
					  color,
					  !Settings.font)
		val _ = #status(r) := Types.CLEAN     
	    in (x+1,y)
	    end )
      | RelRefNode(r)
        =>  ( let 	
		  val w = WindowHelper.fontWidth(!Settings.font)
		  val h = WindowHelper.fontHeight(!Settings.font)
		  val (rx,ry) = (Real.fromInt(x* w),Real.fromInt(y*h)) 
		  val color = case ColorMap.lookup(MkColorTable.colorTable,
						   #color(r)) of 
		              SOME x => x
			    | NONE   => raise MissingColor
		  val _ = Services.printXY (#rep(r),
					    #group(r),
					    rx,
					    ry,
					    color,
					    !Settings.font)
		  val _ = #status(r) := Types.CLEAN
	      in (x+String.length(#rep(r)),y)
	      end )
      | RelNode(r)
	=> ( let 
		 val w = WindowHelper.fontWidth(!Settings.font)
		 val h = WindowHelper.fontHeight(!Settings.font)
		 val (rx,ry) =  (Real.fromInt(x* w),
				 Real.fromInt(y*h))
		 val color = case ColorMap.lookup(MkColorTable.colorTable,
						  #color(r)) of 
		             SOME x => x
			   | NONE   => raise MissingColor
		 val _ = Services.printXY (#rep(r),
					   #group(r),
					   rx,
					   ry,
					   color,
					   !Settings.font)
		 val _ = #status(r) := Types.CLEAN
	     in (x+String.length(#rep(r)),y)
	     end )
      | _ => raise DrawError
	
    (* atomSearch *)
    and atomSearch(n,x,y,intent) = case intent of
	SEARCH(sx,sy) 
	=> (case n of
	    Simple(r) => atomSearch'(n,x,y,sx,sy,#rep(r),#desc(r))
	  | Limit(r) =>  atomSearch'(n,x,y,sx,sy,"!",#desc(r))
	  | RelNode(r) => atomSearch'(n,x,y,sx,sy,#rep(r),#desc(r))
	  | RelRefNode(r) => atomSearch'(n,x,y,sx,sy,#rep(r),#desc(r))
	  |  _ => raise Match)
      | _ => raise Match
	
    and atomSearch'(n,x,y,sx,sy,rep,desc) = 
	let 
	    val in_bounding_box = sx >= x 
		andalso sx < x + String.length(rep) 
		andalso sy = y
	    val interpunct = case desc of
		INTERPUNCT => true
	      | _ => false
	    val toBeDisplayed = case n of 
		(Limit _ | RelNode _ | RelRefNode _ ) => true
	      | _ => false
	in
	    if (in_bounding_box  andalso not(interpunct)) 
		orelse (in_bounding_box  andalso getParent(n) = Empty) 
		orelse toBeDisplayed
		then (x (* + String.length(rep) *),
		      y,
		      SOME(n))
	    else if in_bounding_box then (x + String.length(rep),
					  y,
					  SOME(Helper.getParent(n)))
		else (x + String.length(rep),
		      y,
		      NONE)
	end
		
    (* drawSimple *)
    and drawSimple (n,x,y,intent) = 
	case n of
	    Simple(r) => (case intent of 
			      DRAW => let
					  val (x2,y2) = atomDraw (n,x,y)
				      in
					  (x2,y2,NONE)
				      end
			    | SEARCH _ => atomSearch (n,x,y,intent))
	  | _ => raise DrawError
		
    
    (* drawLimit *)
    and drawLimit (n,x,y,intent) = case n of
	Limit(r) => (case intent of
        	     DRAW => let
				 val (x2,y2) = atomDraw (n,x,y)
			     in
				 (x2,y2,NONE)
			     end
		   | SEARCH _ => atomSearch (n,x,y,intent))
      | _ => raise DrawError
	    
    (* drawConcat *) 
    and drawConcat (n,x,y,intent) = case n of
	Concat(r)
	=> let 
	       val (search,sx,sy) = case intent of
		   DRAW => (false,0,0)
		 | SEARCH(xs,ys) => (true,xs,ys)
	       val in_bounding_box = sx >= x 
		   andalso sx < x + !(#width(r))
		   andalso sy >= y 
		   andalso sy < y + !(#height(r))
	   in
	       if (*!(#status(r)) = DIRTY *) true  orelse search 
		   then if Array.length(#kids(r)) = 0
			    then (x,y,if in_bounding_box then SOME(n) 
				      else NONE)
			else 
			(let val _ = if not(search) 
					 then #status(r) := Types.CLEAN
				     else ()
			     val hor_funct = 
				 (fn (a,(x,y,found)) 
				  => case found of
				     SOME n => if not(search) 
						   then draw(a,x,y,intent)
					       else raise NodeFound(x,y,n)
				   | NONE => draw(a,x,y,intent))
			     in
				 if search andalso not(in_bounding_box) 
				     then (x+get_xdim(n),y+get_ydim(n)-1,NONE) 
				 else
				 let 
				     val (new_x,new_y,new_found) = 
					 (Array.foldl hor_funct (x,y,NONE) 
					  (#kids(r))) 
				     handle NodeFound (foundx,foundy,n) 
				     => (foundx,foundy,SOME(n))
				     val nothing_found = case new_found of
					                 NONE => true
						       | SOME _ => false
				 in 
				     if search then (* besserer Codeteil *)
					 case new_found of 
					 SOME(node_found) 
					 => 
					 (case #desc(r) of
					  INTERPUNCT 
					  => if n = node_found
						 then  (x,y,
							SOME(getParent(n)))
					     else (new_x,new_y,new_found)
					| _ => if n = node_found 
						   then (x,y,SOME n)
					       else (new_x,new_y,new_found))
				       | NONE => (new_x,new_y,new_found)
				     else
					 (new_x,new_y,NONE)
				 end
			 end)
	       else (x+get_xdim(n),y+get_ydim(n),NONE)
	   end
      | _ => raise DrawError
	   
    (* drawContainer *)
    and drawContainer(n,x,y,intent) =  case n of
	Container(r) 
	=> let
	       val (search,sx,sy) = case intent of
		   DRAW => (false,0,0)
		 | SEARCH(xs,ys) => (true,xs,ys)
	       val in_bounding_box = sx >= x 
		   andalso sx < x + !(#width(r))
		   andalso sy >= y 
		   andalso sy < y + !(#height(r))
	   in
	       if (* !(#status(r)) = DIRTY *) true orelse search 
		   then if Array.length(#kids(r)) = 0
			    then (x,y,if in_bounding_box then SOME(n) 
				      else NONE)
			else 
			(let val _ = if not(search) 
					 then #status(r) := Types.CLEAN
				     else ()
			     val hor_funct = 
				 (fn (a,(x,y,_,found)) 
				  => let
					 val (new_x,new_y,new_found) 
					     = case found of
					     SOME n 
					     => if not(search) 
						    then draw(a,x,y,intent)
						else raise NodeFound(x,y,n)
					   | NONE => draw(a,x,y,intent)
				     in (new_x,new_y,0,new_found)
				     end)
                             val ver_funct = 
				 (fn (a,(x,y,_,found)) 
				  => let
					 val (x1,y1,found2) = 
					     draw(a,x,y,intent)
				     in
					 case found2 of
					     SOME n => raise NodeFound(x1,y1,n)
					   | NONE => (x,y1+1,x1,found2)
				     end)
			     val vertical = setsVertical(n)
			     val funct = if vertical 
					     then ver_funct
					 else hor_funct
			 in
				 if search andalso not(in_bounding_box) 
				     then (x+get_xdim(n),y+get_ydim(n)-1,NONE)
				 else
				 let val (new_x',new_y',new_x2,new_found) = 
				     (Array.foldl funct (x,y,0,NONE) 
				      (#kids(r))) 
				     handle NodeFound (foundx,foundy,n) 
				     => (foundx,foundy,foundx,SOME(n))
				     val nothing_found = case new_found of
					                 NONE => true
						       | SOME _ => false
				      val new_x = if vertical 
						      then new_x2
							  else new_x'
				      val new_y = if vertical 
					           andalso nothing_found 
						      then new_y' -1
						  else new_y'
				 in
				      if search then (* besserer Codeteil *)
					 case new_found of 
					 SOME(node_found) => 
					 (case #desc(r) of
					  INTERPUNCT 
					  => 
					  if n = node_found
					      then  (x,y,
						     SOME(getParent(n)))
					  else (new_x,new_y,new_found)
					| _ => if n = node_found 
						   then (x,y,SOME n)
					       else (new_x,new_y,new_found))
				       | NONE => (new_x,new_y,new_found)
				      else
					  (new_x,new_y,NONE)
				 end
			 end)
	       else (x + get_xdim(n), y + get_ydim(n),NONE) 
	   end
      | _ => raise DrawError
	   
    (* drawRelNode *)
    and drawRelNode (n,x,y,intent) = case n of
	RelNode(r) 
	=> (let val _ = TextIO.print("Entering drawRelNode \n")
	    in case intent of
	       DRAW => if !(#status(r)) = DIRTY
			   then (case !(#counter(r)) of
				 1 => draw (!(#content(r)),x,y,intent)
			       | _ => let val (new_x,new_y) = atomDraw (n,x,y)
				      in draw (!(#content(r)),new_x,new_y,
					       intent)
				      end)
		       else 
		       if !(#counter(r)) = 1
			   then (x+get_xdim(!(#content(r))),
				 y+get_ydim(!(#content(r))),
				 NONE)
		       else (x+get_xdim(n),y+get_ydim(n),NONE)
			 | SEARCH(sx,sy) 
			   => (case !(#counter(r)) of
			       1 =>  draw (!(#content(r)),x,y,intent)
			     | _ => let val label_in_bounding_box = 
				        sx >= x 
				       andalso sx < x + String.length(#rep(r)) 
				       andalso sy = y  
				    in
					if label_in_bounding_box 
					    then (x,y,SOME(n))
					else draw (!(#content(r)), 
						   x + String.length(#rep(r))
						   ,y
						   ,intent)
				    end)
	    end)
      | _ => raise DrawError
	
    (* drawRelRefNode *)
    and drawRelRefNode (n,x,y,intent) = case n of
	RelRefNode(r) => case intent of
	    DRAW => if !(#status(r)) = DIRTY
			     then let
				      val (x2,y2) = atomDraw (n,x,y)
				  in
				      (x2,y2,NONE)
				  end
			 else (x+String.length(#rep(r)),y,NONE)
	  | SEARCH _ => atomSearch(n,x,y,intent) 
	  | _ => raise DrawError
		
    (* move *)	     
    (* and move (n,x,y) = 
	let
	    val group = getGroup(n)
	    val (old_x,old_y) = Services.getPosition(group,
						     !Settings.font)
	    val dx = x - old_x
	    val dy = y - old_y
	    val _ = TextIO.print("moving from (" ^ Int.toString(old_x)  
				 ^ "/" ^ Int.toString(old_y) 
				 ^ ") to ("   
				 ^ Int.toString(x) ^ "/" 
				 ^ Int.toString(y) ^ ") \n")
	in
	    (Services.moveGroup(group,dx,dy,!Settings.font)
	     ;(x+get_xdim(n),y+get_ydim(n)-1,NONE))
	end *)

     and move (n,x,y) = 
	let
	    val _ = TextIO.print("Moving!\n")
	    val group = getGroup(n)
	    val w = WindowHelper.fontWidth(!Settings.font)
	    val h = WindowHelper.fontHeight(!Settings.font)
	    val rx = Real.fromInt(w * x)
	    val ry = Real.fromInt(h * y)
		in
		    (Services.itemMoveTo(group,rx,ry)
		     ;(x+get_xdim(n),y+get_ydim(n)-1,NONE))
	end   
    
    (* draw *)
    and draw (n,x,y,intent) = 
      ( TextIO.print ("DRAW: drawing with y = "^Int.toString(y)^"\n")
        ;
	case n of
	Simple(r) => (case intent of 
			  DRAW =>
			      if !(#status(r)) = DIRTY  
				  then drawSimple (n,x,y,intent)
			      else move(n,x,y)  	
			| SEARCH _ =>  drawSimple (n,x,y,intent))
      | Concat(r) => (case intent of 
			  DRAW => if !(#status(r)) = DIRTY  
			 then drawConcat (n,x,y,intent)
			     else move(n,x,y)  
			  | SEARCH _ => drawConcat (n,x,y,intent))
      | Container(r) => (case intent of
			     DRAW => if !(#status(r)) = DIRTY  
			    then drawContainer (n,x,y,intent)
			else move(n,x,y) 
		| SEARCH _ => drawContainer(n,x,y,intent))	     
      | Limit(r) => (case intent of
			 DRAW => if  !(#status(r)) = DIRTY  
			then drawLimit (n,x,y,intent)
		    else  move(n,x,y) 
		       | SEARCH _ => drawLimit (n,x,y,intent))
      | RelNode(r) 
	    => (case intent of
		    DRAW => (if  !(#status(r)) = DIRTY 
				 then drawRelNode (n,x,y,intent)
			     else ( move(n,x,y) 
				   ;( case !(#counter(r)) of
				   1 => (x+get_xdim(!(#content(r))),
					 y+get_ydim(!(#content(r))),
					 NONE)
				 | _ => (x+get_xdim(n),y+get_ydim(n),NONE) )))
		  | SEARCH _ =>  drawRelNode (n,x,y,intent))
	  | RelRefNode(r) => (case intent of
			      DRAW => if  !(#status(r)) = DIRTY  
					  then drawRelRefNode (n,x,y,intent)
				      else  move(n,x,y) 
			    | SEARCH _ =>  drawRelRefNode (n,x,y,intent))
	  | Empty => (x,y,NONE)
      )

end
       
