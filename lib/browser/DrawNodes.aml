(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Inspector from "x-alice:/lib/tools/Inspector"
import structure TextIO from "x-alice:/lib/system/TextIO"
import structure Services from "Services"
import structure Types from "Types"
import structure Helper from "Helper"
import structure Layout from "Layout"
import signature DRAW_NODES from "DRAW_NODES-sig"
import structure ColorMap from "ColorMap"
import structure WindowHelper from "WindowHelper"
import structure Settings from "Settings"
import structure MkColorTable from "MkColorTable"
import structure Gtk from "x-alice:/lib/gtk/Gtk"
import structure GtkCanvas from "x-alice:/lib/gtk/GtkCanvas"

open Types Helper Layout 

structure DrawNodes :> DRAW_NODES =
struct

    exception MissingColor
    exception DrawError
    exception NodeFound of int * int * node

    datatype intention = DRAW | SEARCH of int * int
    	   
    fun groupToPosition (node,x,y) = 
	    let
		val group = getGroup(node) 
		val w = Services.fontWidth()
		val h = Services.fontHeight()
		val (rx,ry) = (Real.fromInt(x* w),Real.fromInt(y*h))
	    in
		GtkCanvas.itemMove(group,rx,ry)
	    end

    (* atomDraw *)
    fun atomDraw (node,x,y,f)  = case node of
	Simple(r) 
	=> (let 
		val color = case ColorMap.lookup(MkColorTable.colorTable,
						 #color(r)) of 
		            SOME x => x
			  | NONE   => raise MissingColor
	    in
		(f(node,x,y)
		 ;Services.printXY (#rep(r),
				    #group(r),
				    0.0,
				    0.0,
				    color,
				    !Settings.fontname)
		 ;#status(r) := Types.CLEAN
		 ;(x+String.length(#rep(r)),y))
	    end )
      | Limit(r) 
	=> (let 
		val color = case ColorMap.lookup(MkColorTable.colorTable,
						 LIMIT_COLOR) of 
		            SOME x => x
			  | NONE   => raise MissingColor
		val limitsig = if #sort(r) = Types.DEPTH_LIMIT
				   then "*" 
			       else "@"
	    in
		(f(node,x,y)
		 ;Services.printXY (limitsig,
				    #group(r),
				    0.0,
				    0.0,
				    color,
				    !Settings.fontname)
		 ;#status(r) := Types.CLEAN     
	         ;(x+1,y))
	    end )
      | RelRefNode(r)
        =>  ( let 	
		  val color = case ColorMap.lookup(MkColorTable.colorTable,
						   #color(r)) of 
		              SOME x => x
			    | NONE   => raise MissingColor
	      in
		  (f(node,x,y)
		   ;Services.printXY (#rep(r),
				      #group(r),
				      0.0,
				      0.0,
				      color,
				      !Settings.fontname)
		   ;#status(r) := Types.CLEAN
	           ;(x+String.length(#rep(r)),y))
	      end )
      | RelNode(r)
	=> ( let 
		
		 val color = case ColorMap.lookup(MkColorTable.colorTable,
						  #color(r)) of 
		             SOME x => x
			   | NONE   => raise MissingColor
		 in
		     (f(node,x,y)
		      ;Services.printXY (#rep(r),
					 #group(r),
					 0.0,
					 0.0,
					 color,
					 !Settings.fontname)
		      ;#status(r) := Types.CLEAN
	              ; (x+String.length(#rep(r)),y))
	     end )
      | _ => raise DrawError
	    
    (* drawConcat *) 
    and drawConcat (n,x,y,f) = case n of
	Concat(r)
	=> (let
		val hor_funct = 
		    (fn (a,(x,y)) 
		     => draw(a,x,y,f))
	    in
		let 
		    val (new_x,new_y) = 
			(Array.foldl hor_funct (0,0) 
			 (#kids(r))) 
		in 
		    (f(n,x,y)
		     ; #status(r) := Types.CLEAN
		     ;(new_x+x,new_y+y))
		end
	    end)
      | _ => raise DrawError
	   
    (* drawContainer *)
    and drawContainer(n,x,y,f) =  case n of
	Container(r) 
	=> 	(let val _ = #status(r) := Types.CLEAN
			     val hor_funct = 
				 (fn (a,(x,y,_)) 
				  => let
					 val (new_x,new_y) 
					     = draw(a,x,y,f)
				     in (new_x,new_y,0)
				     end)
                             val ver_funct = 
				 (fn (a,(x,y,_)) 
				  => let
					 val (x1,y1) = 
					     draw(a,x,y,f)
				     in
				       (x,y1+1,x1)
				     end)
			     val vertical = setsVertical(n)
			     val funct = if vertical 
					     then ver_funct
					 else hor_funct
			 in
				 let val (new_x',new_y',new_x2) = 
				     (Array.foldl funct (0,0,0) 
				      (#kids(r))) 
				      val new_x = if vertical 
						      then new_x2
							  else new_x'
				      val new_y = if vertical 
						      then new_y' -1
						  else new_y'
				 in
					  (f(n,x,y)
					   ;(new_x+x,new_y+y))
				 end
			 end) 
      | _ => raise DrawError
	   
    (* drawRelNode *)
    and drawRelNode (n,x,y,f) = case n of
	RelNode(r) 
	=> (let val _ = TextIO.print("Entering drawRelNode \n")
	    in (f(n,x,y)
		;(case !(#counter(r)) of
		     1 => let
			      val (new_x,new_y) = draw (!(#content(r)),0,0,f)
			     in
				 (x+new_x,y+new_y)
				 end
		   | _ => let 
			      val (new_x,new_y) = atomDraw (n,0,0,f)
			      val content = !(#content(r))
			      val (x2,y2) = draw (content,
						  new_x,new_y,f)
			  in
			      (x + String.length(#rep(r)) +   
			       Layout.get_xdim(content),
			       y + Layout.get_ydim(n)-1)
			  end))
	    end)
      | _ => raise DrawError

    and move'(n,x,y) = let
			  val group = getGroup(n)
			  val (old_x,
			       old_y,
			       old_x2,
			       old_y2) = Services.getCoordinates group  
			  val dx = x-old_x
			  val dy = y-old_y
			  val _ = TextIO.print("Moving from x:"
					       ^ Int.toString(old_x)
					       ^ " and y:"
					       ^ Int.toString(old_y)
					       ^ " to x:"
					       ^ Int.toString(x)
					       ^ " and y:"
					       ^ Int.toString(y)
					       ^", dx is "
					       ^ Int.toString(dx)
					       ^ " and dy is "
					       ^ Int.toString(dy)
					       ^ "\n")
		      in
		        Services.moveGroup(group,dx,dy) 
		      end

    and move(n,x,y) = (move'(n,x,y)
		      ;(x+get_xdim(n),y+get_ydim(n)-1))

  
    (* draw *)
    and draw (n,x,y,f) = 
      ( TextIO.print ("DRAW: drawing with x = "
		      ^Int.toString(x)^" and y = "
		      ^Int.toString(y)^"\n")
        ;
	case n of
	Simple(r) => if !(#status(r)) = DIRTY  
				  then atomDraw (n,x,y,f)
				 else move(n,x,y)  	
      | Concat(r) => if !(#status(r)) = DIRTY  
			 then drawConcat (n,x,y,f)
			  else move(n,x,y)  
      | Container(r) => if !(#status(r)) = DIRTY  
			    then drawContainer (n,x,y,f)
				else move(n,x,y) 	     
      | Limit(r) => if  !(#status(r)) = DIRTY  
			then atomDraw (n,x,y,f)
			 else move(n,x,y) 
      | RelNode(r) => if  !(#status(r)) = DIRTY 
				 then drawRelNode (n,x,y,f)
		      else ( move(n,x,y) 
				   ;( case !(#counter(r)) of
				   1 => (x+get_xdim(!(#content(r))),
					 y+get_ydim(!(#content(r))))
				 | _ => (x+get_xdim(n),y+get_ydim(n)) ))
	  | RelRefNode(r) => if  !(#status(r)) = DIRTY  
					  then atomDraw (n,x,y,f)
					  else  move(n,x,y) 
	  | Empty => (x,y)
      )

end
       
