(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Inspector from "x-alice:/lib/tools/Inspector"
import structure TextIO from "x-alice:/lib/system/TextIO"
import structure GtkSupport from "GtkSupport"
import structure Types from "Types"
import structure Helper from "Helper"
import structure Layout from "Layout"
import signature DRAW_NODES from "DRAW_NODES-sig"
import structure ColorMap from "ColorMap"
import structure Settings from "Settings"
import structure MkColorTable from "MkColorTable"
import structure Gtk from "x-alice:/lib/gtk/Gtk"
import structure GtkCanvas from "x-alice:/lib/gtk/GtkCanvas"

open Types Helper Layout 

structure DrawNodes :> DRAW_NODES =
struct

    exception MissingColor
    exception DrawError
    exception NodeFound of int * int * node
    	   
    fun groupToPosition (node,x,y) = GtkSupport.moveGroup(getGroup(node),x,y)
				      
    fun move'(n,x,y) = let
			   val group = getGroup(n)
			   val (old_x,
				old_y,
				old_x2,
				old_y2) = GtkSupport.getCoordinates group 
			   val needs_printing =  old_x = 0 
			                         andalso old_y = 0
			                         andalso old_x2 = 0
			                         andalso old_y2 = 0
			   val dx = x-old_x
			   val dy = y-old_y
		       in
			   (GtkSupport.moveGroup(group,dx,dy)
			    ; needs_printing)
		       end

    fun move(n,x,y) = (move'(n,x,y)
		       ;(x+ Layout.get_l_xdim(n),
			 y+get_ydim(n)-1)) (* maybe get_l_xdim 
					    is 
					    not sufficient ! *)

    (* atomDraw *)
    fun atomDraw (node,x,y,upd) = 
	(if upd 
	     then if move' (node,x,y)
		      then (GtkSupport.print00(getRep(node),
					     getGroup(node),
					     getColor(node),
					     !Settings.fontname);())
		  else ()
	 else (groupToPosition(node,x,y)
	       ;GtkSupport.print00 (getRep(node),
				  getGroup(node),
				  getColor(node),
				  !Settings.fontname)
		       ; ())
	     ;getStatus(node) := Types.CLEAN
	     ;(x+String.size(getRep(node)),y))
   
    (* drawLimit *)
    fun drawLimit (node,x,y,upd) = 
	let 
	    val createArrow = if getSort(node) = Types.DEPTH_LIMIT
				  then GtkSupport.createArrowDown
			      else GtkSupport.createArrowRight
	in
	    (if upd 
		 then if move'(node,x,y)
			  then (createArrow(getGroup(node));())
		      else ()
	     else (groupToPosition(node,x,y)
		   ;createArrow(getGroup(node));())
		   ;getStatus(node) := Types.CLEAN 
		   ;(x+2,y))
	end
    
    and concatHorFunct upd  =  (fn (a,(x,y))  => draw(a,x,y,upd)) 

    (* drawConcat *) 
    and drawConcat (n,x,y,upd) = 
	let 
	       val (new_x,new_y) = 
		   (Array.foldl (concatHorFunct upd) (0,0) 
		    (getKids(n))) 
	   in 
	       (if upd then (move'(n,x,y);()) 
		else groupToPosition(n,x,y)
		; getStatus(n) := Types.CLEAN
		(* ; TextIO.print("Draw Concat returns: x=" 
		 ^ Int.toString(new_x+x)
		 ^ " y="
		 ^ Int.toString(new_y+y)
		 ^ "\n") *)
		;(new_x+x,new_y+y))
	   end

    and containerHorFunct upd =  (fn (a,(x,y,_))  => let
						       val (new_x,new_y) 
							   = draw(a,x,y,upd)
						   in (new_x,new_y,0)
						   end)
	
    and containerVerFunct upd = (fn (a,(x,y,_)) 
				  => let
					 val (x1,y1) = 
					     draw(a,x,y,upd)
				     in
				       (x,y1+1,x1)
				     end)
	   
    (* drawContainer *)
    and drawContainer(n,x,y,upd) =  
	let 
	    val vertical = setsVertical(n)
	    val funct = if vertical 
			    then (containerVerFunct upd)
			else (containerHorFunct upd)
	    val (new_x',new_y',new_x2) = 
		(Array.foldl funct (0,0,0) 
		 (getKids(n))) 
	    val (new_x,new_y) = if vertical 
				    then (new_x2,new_y' -1)
				else  (new_x',new_y') 
	in
	    (getStatus(n) := Types.CLEAN
	     ;if upd then (move'(n,x,y);()) 
	      else groupToPosition(n,x,y)
	      ; () (*TextIO.print("Draw Container returns: x=" 
			    ^ Int.toString(new_x+x)
			    ^ " y="
			    ^ Int.toString(new_y+y)
			    ^ "\n") *)
	     ;(new_x+x,new_y+y))
	end 
    
    
    (* drawRelNode *)
   and drawRelNode (n,x,y,upd) = case n of
	RelNode(r) 
	=> if !(#counter(r)) = 1 orelse isSimple(!(#content(r)))
		     then (if upd then (move'(n,x,y);()) 
			   else groupToPosition(n,x,y) 
			       ;let
				   val (new_x,new_y) = 
				       draw (!(#content(r)),0,0,upd)
			       in
				   (x+new_x,y+new_y)
			       end)
	   else if upd then let
				val _ = if move'(n,x,y) 
				    then (GtkSupport.print00 (#rep(r),
						 getGroup(n),
					         getColor(n),
				       	     !Settings.fontname);()) 
					else ()
			  val content = !(#content(r))
			  val (x2,y2) = draw (content,
					      String.size(#rep(r))
					      ,0
					      ,upd)
			     in
				   (x+x2, y+y2)
			     end
		else (groupToPosition(n,x,y)
		      ; GtkSupport.print00 (#rep(r),
					    getGroup(n),
					    getColor(n),
					    !Settings.fontname)
		      ;let
			   val content = !(#content(r))
			   val (x2,y2) = draw (content,
					       String.size(#rep(r))
					       ,0
					       ,upd)
		       in
			   (x+x2, y+y2)
		       end)
(* Version from Okt 22nd *)
 (*  and drawRelNode (n,x,y,upd) = case n of
	RelNode(r) 
	=> (let val _ = () (* TextIO.print("Entering drawRelNode \n") *)
	    in (if upd then (move'(n,x,y);()) (* important: move' needs to be a tester *) 
		else groupToPosition(n,x,y)
	       ; if !(#counter(r)) = 1 orelse isSimple(!(#content(r)))
		     then let
			   (*   val _ = GtkSupport.print00 ("_",
				  getGroup(n),
				  getColor(n),
				  !Settings.fontname) *)
			      val (new_x,new_y) = draw (!(#content(r)),0,0,upd)
			  in
			      (x+new_x,y+new_y)
			  end
		 else let 
			  (* val (new_x,_) = atomDraw 
			      (n,0,0,upd) *)
			  val _ = GtkSupport.print00 (#rep(r),
				  getGroup(n),
				  getColor(n),
				  !Settings.fontname)
			  val content = !(#content(r))
			  val (x2,y2) = draw (content,
					      String.size(#rep(r))
					      ,0
					      ,upd)
		      in
			  (x + (* String.size(#rep(r)) + *) x2   
			   (* Layout.get_l_xdim(content) *), (* was lxdim *)
			   y + (* Layout.get_ydim(n)-1 *) y2)
		      end  )
	    end) *)
      | _ => raise DrawError

    
  
    (* draw *)
    and draw (((Simple _ as n ) 
	     | (RelRefNode _ as n)) ,x,y,upd) = if !(getStatus(n)) = DIRTY  
						  then atomDraw (n,x,y,upd)
					      else move(n,x,y)  	
      | draw (Concat(_) as n,x,y,upd) = ((if (!(getStatus(n))) = DIRTY  
			 then drawConcat (n,x,y,upd)
			  else move(n,x,y))  
			      handle MissingColor => (Inspector.inspect ("MissingColor");(0,0))
	         handle DrawError => (Inspector.inspect ("DrawError");(0,0))
		     handle General.Subscript =>
			 (Inspector.inspect ("General.Subscript");(0,0))
			 handle Match =>(Inspector.inspect ("Match");(0,0))
			 handle General.Match =>
			     (Inspector.inspect ("General.Match");(0,0))
			     handle _ =>  (Inspector.inspect ("sth. else")
					   ;(0,0)))
      | draw (Container(_) as n,x,y,upd) = (((if (!(getStatus(n))) = DIRTY  
			    then drawContainer (n,x,y,upd)
				else move(n,x,y))
				 handle MissingColor => (Inspector.inspect ("MissingColor");(0,0))
	         handle DrawError => (Inspector.inspect ("DrawError");(0,0))
		     handle General.Subscript =>
			 (Inspector.inspect ("General.Subscript");(0,0))
			 handle Match =>(Inspector.inspect ("Match");(0,0))
			 handle General.Match =>
			     (Inspector.inspect ("General.Match");(0,0))
			     handle _ =>  (Inspector.inspect ("sth. else")
					    ; (0,0))))
      | draw (Limit(_) as n,x,y,upd) = if  (!(getStatus(n))) = DIRTY  
			then drawLimit (n,x,y,upd)
			 else move(n,x,y) 
      | draw (RelNode(r) as n,x,y,upd) = ((if  !(#status(r)) = DIRTY 
				 then drawRelNode (n,x,y,upd)
		      else ( move(n,x,y) 
				   ;( case !(#counter(r)) of
				   1 => (x+get_xdim(!(#content(r))),
					 y+get_ydim(!(#content(r))))
				 | _ => (x+get_xdim(n),y+get_ydim(n)) )))
			     handle MissingColor => (Inspector.inspect ("MissingColor");(0,0))
	         handle DrawError => (Inspector.inspect ("DrawError");(0,0))
		     handle General.Subscript =>
			 (Inspector.inspect ("General.Subscript");(0,0))
			 handle Match =>(Inspector.inspect ("Match");(0,0))
			 handle General.Match =>
			     (Inspector.inspect ("General.Match");(0,0))
			     handle _ =>  (Inspector.inspect ("sth. else")
					  ; (0,0)))
       | draw  (Empty,x,y,upd) =  (x,y)
     

end
       
