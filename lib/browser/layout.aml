import structure Type from "x-alice:/lib/rtt/Type"
import structure PervasiveType from "x-alice:/lib/rtt/PervasiveType"
import structure Path from "x-alice:/lib/rtt/Path"
import structure PathMap from "x-alice:/lib/rtt/PathMap"
import structure MkHashImpMap from "x-alice:/lib/utility/MkHashImpMap"
import structure Types from "type"
import structure Helper from "helper"

open Types
open Helper

(*** Signatur Layout ***)

signature LAYOUT =
sig

    exception xdimError
    exception koordErrorSimp
    exception koordErrorSep
    exception koordErrorLabel
    exception koordErrorCont
    exception koordErrorBrack
    exception koordErrorLimit
    exception koordErrorEmpty

(* erste Zeile, in die noch nicht gezeichnet wurde *)
    val act_line: int ref

(* Hilfsfunktionen zum Setzen der Dimensionen und Koordinaten *)
    (* x-dim *)
    val sum: Node list -> int
    val max: Node list -> int
    (* y-dim *)
    val sum_up': Node array * int * int -> int
    val sum_up: Node array -> int
    val maximum': Node array * int * int -> int
    val maximum: Node array -> int   
    (* x-/y-koord *)
    val sum_y': Node list * int * int -> int
    val sum_y: Node list -> int

(* Berechnung der x-Dimension - inklusive der x-Dimension des letzten Inhalts 
   bei ContNodes *)
    val get_xdim: Node -> int 
    val xdim: Node -> int
    val set_xdim: Node -> unit
    val get_l_xdim: Node -> int
    val set_l_xdim: Node -> unit 
   

(* Berechnung der y-Dimension *)
    val get_ydim: Node -> int
    val calc_ydim: Node -> int

(* Setzen der x- und y-Koordinaten *)
    val xy_koord: Node -> int * int 
    val set_xykoord: Node -> unit

    val layout: Node -> unit
end;

(*** Struktur Layout ***)

structure Layout :> LAYOUT =
struct
    
    exception xdimError
    exception koordErrorSimp
    exception koordErrorSep
    exception koordErrorLabel
    exception koordErrorCont
    exception koordErrorBrack
    exception koordErrorLimit
    exception koordErrorEmpty
    
    val act_line = ref 0  

    fun sum li = let val le = List.length(li)
		 in if le = 0 then 0 
		    else  xdim(hd(li)) + (sum (tl(li))) 
		 end   

    and max li = let val le = List.length(li) 
		 in if le = 0 then ~1
		    else if le = 1 then xdim(hd(li))
			 else 
			 (let val tli = tl(li)
			      val m = Int.max(xdim(hd(li)),xdim(hd(tli)))
			  in Int.max(m, max (tl(tli)))
			  end)
		 end

    and sum_up'(a,i,sum) = if i < Array.length(a) 
			   then sum_up'(a,i+1,sum + calc_ydim(Array.sub(a,i)))
			   else sum

    and sum_up a = sum_up'(a,0,0)
	
    and maximum'(a,i,mx) = if i < Array.length(a) 
			   then maximum' (a, i+1, 
			      if mx < calc_ydim(Array.sub(a,i))
                              then   get_ydim(Array.sub(a,i))
			      else mx)
			   else mx

    and maximum a = maximum'(a,0,0)

    and sum_y'(a,i,sum) = if i < List.length(a) 
			  then sum_y'(a,i+1,sum + calc_ydim(List.nth(a,i)))
			  else sum

    and sum_y a = sum_y'(a,0,0)

    (* x-Dimsension *) 
    
    and get_xdim n = case n of SimpleNode(r) => !(#xdim(r))
                             | ContNode(r) => !(#xdim(r))
			     | LabelNode(r) => !(#xdim(r))
			     | SepNode(r) => !(#xdim(r))
			     | BracketNode(r) => !(#xdim(r))
                             | LimitNode(r) => !(#xdim(r))
			     | EmptyNode => 0
                                                   
    and xdim n = case n of 
                 SimpleNode(r) 
		 => (case Type.inspect (#istype(r)) of
                     Type.Con(path)
                     => if Path.equal(path,PervasiveType.path_string)  
			    then 2 + String.length(#value(r))
			else if Path.equal(path,PervasiveType.path_char)
				 then 3 + String.length(#value(r)) 
			     else if  Path.equal(path,PervasiveType.path_ref)
				      then 4 + String.length(#value(r))
				  else String.length(#value(r)) 
                   | _ => raise xdimError) 
               | ContNode(r)
		 => let val a = #nodes(r)
			val li = Array.toList(a)
			val ti = Type.inspect(#istype(r))
		    in (case ti of
                        Type.Apply(t1,t2) 
                        => let val tap = Type.asApply(#istype(r))
			       val t = #1(tap)
			       val tt = Type.inspect(t)
			   in (case tt of 
			       Type.Con path
			       => if Path.equal(path, 
						PervasiveType.path_ref)
				      then 4 + sum li
				  else if hasContChild n 
					   then max li
				       else  sum li  
			     | _ => if hasContChild n 
					then max li
				    else  sum li) 
			   end 
		     | _  (* im Moment z.B. Prod(row) *)
                       => if hasContChild n
			    then max li
                          else sum li)
		    end
	       | LabelNode(r) => if isSumLabel n
				     then 1 + String.length(#label(r)) 
					    + xdim(!(#content(r)))
				 else 3 + String.length(#label(r)) 
				        + xdim(!(#content(r)))
	       | SepNode(r) => 2 + xdim(!(#content(r)))
               | BracketNode(r) 
		 =>(case Type.inspect (#istype(r)) of 
                    Type.Apply(t1,t2) 
		    =>(case Type.inspect t1 of 
                       Type.Con path
	                => if Path.equal(path, 
					 PervasiveType.path_vec)
			   then 3 + xdim(!(#content(r)))
			   else
			       if Path.equal(path, 
					     PervasiveType.path_ref)
			       then xdim(!(#content(r)))
			       else 2 + xdim(!(#content(r))) 
		      | _  => 2 + xdim(!(#content(r))) )
		  | Type.Prod(row) => 2 + xdim(!(#content(r)))
		  | _  => xdim(!(#content(r))) )
	       | LimitNode(r) => 1
	       | EmptyNode => 0

    and set_xdim n = case n of SimpleNode(r) => #xdim(r) := (xdim n)
                             | ContNode(r) 
                             => (#xdim(r) := (xdim n)
				 ; let val l = Array.length(#nodes(r))
				       val rl = ref l
				   in while !rl > 0 do
				      (set_xdim(Array.sub(#nodes(r),l- !rl))
				       ; rl := !rl - 1) 
				   end)
                             | LabelNode(r) 
                             => (#xdim(r) := (xdim n)
				; let val co = !(#content(r))
				  in set_xdim co end)
                             | SepNode(r) 
                             =>  (#xdim(r) := (xdim n)
                             ; let val co = !(#content(r))
                               in set_xdim co end)
                             | BracketNode(r) 
                             => (#xdim(r) := (xdim n)
                                ; let val co = !(#content(r))
				  in set_xdim co end)
                             | LimitNode(r) => #xdim(r) := (xdim n)
 			     | EmptyNode => ()

    and  get_l_xdim n = case n of ContNode(r) => !(#l_xdim(r))
                               | _ => 0
                           
    and  set_l_xdim n = case n of ContNode(r) 
	                         => let val a = #nodes(r)
					val li = Array.toList(a) 
                                        val le = List.length(li)
                                        val rl = ref (le-1)
					val la = List.last(li)
					val xla = get_xdim la
				    in if !rl >= 0 
                                       then let val la = List.last(li)
					        val xla = get_xdim la 
                                            in
					      (#l_xdim(r) := xla
					       ; while !rl >= 0 do
					       (set_l_xdim (List.nth(li,!rl))
						; rl := !rl - 1 ))
					    end
				       else #l_xdim(r) := 0
				    end
			       | BracketNode(r)
                                 => let val c = #content(r) 
				    in set_l_xdim (!c)
				    end
			       | SepNode(r)
                                 => let val c = #content(r) 
				    in set_l_xdim (!c)
				    end
                               | LabelNode(r)
                                 => let val c = #content(r) 
				    in set_l_xdim (!c)
				    end
			       | _ => () 
                                                                            
    (* y-Dimension *)

    and get_ydim n = case n of
	                EmptyNode       =>  0
		      | LimitNode(r)    =>  !(#ydim(r))
                      | SimpleNode(r)   =>  !(#ydim(r))
                      | LabelNode(r)    =>  !(#ydim(r))
                      | BracketNode(r)  =>  !(#ydim(r))
                      | ContNode(r)     =>  !(#ydim(r))
                      | SepNode(r)      =>  !(#ydim(r)) 


    and calc_ydim n = case n of
                      EmptyNode => 0
		    | LimitNode(r) => ((#ydim(r)) := 1  ; 1)
		    | SimpleNode(r) => ((#ydim(r)) := 1  ; 1)
		    | LabelNode(r)   
                    => (case !(#content(r)) of
			EmptyNode => ((#ydim(r)) := 1; 1)
		      | _ => (calc_ydim ( !(#content(r)) )
			      ; ((#ydim(r)) := get_ydim( !(#content(r))))
			      ;!(#ydim(r))) )
		    | SepNode(r)     
                    => (calc_ydim ( !(#content(r)) )
		       ; ((#ydim(r)) := get_ydim( !(#content(r))))
		       ;!(#ydim(r)) )
		    | BracketNode(r) 
		    => let val c = calc_ydim ( !(#content(r)) )
		       in ((#ydim(r)) := get_ydim( !(#content(r)))
			  ; c )
		       end
		    | ContNode(r) => if hasContChild(ContNode(r))
                                     then ((#ydim(r)):= sum_up(#nodes(r)) 
                                          ;(!(#ydim(r))) ) 
                                     else ((#ydim(r)) :=  maximum(#nodes(r))
                                          ;(!(#ydim(r))) )

    (* x- und y-Koordinaten *)

    and xy_koord (SimpleNode(rr)) = 
	         let val p = !(#parent(rr))
		 in (case p of 
		     EmptyNode => (0, !act_line)
		   | SepNode(r) => (!(#xkoord(r)),!(#ykoord(r)))
		   | LabelNode(r) 
			 => let val st = String.length(#label(r))
				val x_label = #xkoord(r)
				val y_label = #ykoord(r)
			    in if isSumLabel p
				   then (!x_label +st +1 , !y_label)
			       else (!x_label +st +3, !y_label)
			    end        
		    | ContNode(r) 
			  => let val i = !(#index(rr))
				 val x = #xkoord(r) 
				 val y = #ykoord(r)
				 val li = Array.toList(#nodes(r))
				 val lnew = List.take(li,i)
                              in if Type.isApply(#istype(r)) 
				 then
				 let val tap = Type.asApply(#istype(r))
				     val tt  = Type.inspect(#1(tap))
				 in (case tt of 
				     Type.Con path
				     => if Path.equal(path, 
						      PervasiveType.path_ref)
					    then (!x + 4, !y) 
					else    
					    if hasContChild p 
						then (!x,!y + sum_y lnew)
					    else (!x + sum lnew,!y)
				   | _ => if hasContChild p 
					      then (!x,!y + sum_y lnew)
					  else (!x + sum lnew,!y) ) 
				 end 
				 else if hasContChild p 
					      then (!x,!y + sum_y lnew)
					  else (!x + sum lnew,!y)
			     end
		    | _ => raise koordErrorSimp)
		 end

      | xy_koord (SepNode(rr)) = 
                 let val p = !(#parent(rr))
		 in (case p of 
			 ContNode(r) 
			 => let val i = !(#index(rr))
				val x = #xkoord(r) 
				val y = #ykoord(r)
				val li = Array.toList(#nodes(r))
				val lnew = List.take(li,i)
			    in if hasContChild p 
			       then (!x, !y + sum_y lnew)
			       else (!x + sum lnew,!y)
			    end 
		       | _ => raise koordErrorSep)
		 end
	     
      | xy_koord (LabelNode(rr)) = 
		 let val p = !(#parent(rr))
		 in (case p of
			 SepNode(r) => (!(#xkoord(r)),!(#ykoord(r)))
		       | ContNode(r) 
			     => let val i = !(#index(rr))
				    val x = #xkoord(r) 
				    val y = #ykoord(r)
				    val li = Array.toList(#nodes(r))
				    val lnew = List.take(li,i)
				in if hasContChild p 
				   then (!x, !y + sum_y lnew)
				   else (!x + sum lnew,!y)
				end 
			   | _ => raise koordErrorLabel)
		 end

      | xy_koord (BracketNode(rr)) =  
		 let val p = !(#parent(rr)) 
		 in (case p of
			 EmptyNode => (0,!act_line)
		       | ContNode(r) 
			     => let val i = !(#index(rr))
				    val x = #xkoord(r) 
				    val y = #ykoord(r)
				    val li = Array.toList(#nodes(r))
				    val lnew = List.take(li,i)
                                in if Type.isApply(#istype(r)) 
				   then
				   let val  tap = Type.asApply(#istype(r))
				       val tt  = Type.inspect(#1(tap))
				   in (case tt of 
				       Type.Con path
				       => if Path.equal(path, 
						      PervasiveType.path_ref)
					     then (!x + 4, !y) 
					  else    
					      if hasContChild p 
						  then (!x,!y + sum_y lnew)
					      else (!x + sum lnew,!y)
				     | _ => if hasContChild p 
						then (!x,!y + sum_y lnew)
					    else (!x + sum lnew,!y) ) 
				   end 
				   else if hasContChild p 
					    then (!x,!y + sum_y lnew)
					else (!x + sum lnew,!y) 
				end 
		       | SepNode(r) 
			     => (!(#xkoord(r)),!(#ykoord(r)))
		       | LabelNode(r) 
			      => let val st = String.length(#label(r))
				     val x_label = #xkoord(r)
				     val y_label = #ykoord(r)
				 in if isSumLabel p
					then (!x_label +st +1, !y_label)
				    else (!x_label +st +3, !y_label)
				 end                   
		       | _ => raise koordErrorBrack)
		 end

      | xy_koord (ContNode(rr)) = 
		 let val p = !(#parent(rr))
		 in (case p of
		     BracketNode(r) 
		        => let val x = #xkoord(r)
			       val y = #ykoord(r)
                               val ti = Type.inspect(#istype(r))
			   in (case ti of 
                               Type.Apply(t1,t2)
                               => let val tap = Type.asApply(#istype(r))
				      val t = #1(tap)
				      val tt = Type.inspect(t)
				  in (case tt of 
				      Type.Con path
				      => if Path.equal(path, 
						       PervasiveType.path_ref)
					     then (!x, !y)
					 else 
					     if Path.equal(path, 
						     PervasiveType.path_vec) 
						 then (!x+2, !y)
					     else (!x+1, !y)
				    | _ => (!x+1, !y))
				  end
                             | Type.Sum(_) => (!x,!y)
			     | _ => (!x+1, !y) )
			   end 
		      | _ => raise koordErrorCont) 
		 end

      | xy_koord (LimitNode(rr)) =
		 let val p = !(#parent(rr)) 
		 in (case p of
			 EmptyNode => (0,!act_line)
		       | ContNode(r) 
			     => let val i = !(#index(rr))
				    val x = #xkoord(r) 
				    val y = #ykoord(r)
				    val li = Array.toList(#nodes(r))
				    val lnew = List.take(li,i)
				in if Type.isApply(#istype(r)) 
				   then
				   let val  tap = Type.asApply(#istype(r))
				       val tt  = Type.inspect(#1(tap))
				   in (case tt of 
				       Type.Con path
				       => if Path.equal(path, 
						        PervasiveType.path_ref)
					      then (!x + 4, !y) 
					  else    
					      if hasContChild p 
						  then (!x,!y + sum_y lnew)
					      else (!x + sum lnew,!y)
				     | _ => if hasContChild p 
						then (!x,!y + sum_y lnew)
					    else (!x + sum lnew,!y) ) 
				   end 
				   else if hasContChild p 
					    then (!x,!y + sum_y lnew)
					else (!x + sum lnew,!y)
				end
		       | SepNode(r) 
			     => (!(#xkoord(r)),!(#ykoord(r)))
		       | LabelNode(r) 
			      => let val st = String.length(#label(r))
				     val x_label = #xkoord(r)
				     val y_label = #ykoord(r)
				 in if isSumLabel p
				     then (!x_label +st +1, !y_label) 
				    else (!x_label +st +3, !y_label)
				 end                   
		       | _ => raise koordErrorLimit)
		 end

      | xy_koord EmptyNode = raise koordErrorEmpty

    and set_xykoord n = case n of SimpleNode(r) 
                                  => (#xkoord(r) := #1(xy_koord n)
				      ;#ykoord(r) := #2(xy_koord n))
				| ContNode(r) 
                                => (#xkoord(r) := #1(xy_koord n)
				   ;#ykoord(r) := #2(xy_koord n)
				   ;let val l = Array.length(#nodes(r))
				        val rl = ref l
				    in while !rl > 0 do
				    (set_xykoord(Array.sub(#nodes(r),l- !rl))
				    ; rl := !rl - 1) 
				    end) 
			       | LabelNode(r) 
                               => (#xkoord(r) := #1(xy_koord n)
				   ;#ykoord(r) := #2(xy_koord n)
				   ;let val co = !(#content(r))
				    in set_xykoord co 
				    end)
			       | SepNode(r) 
                               => (#xkoord(r) := #1(xy_koord n)
				   ;#ykoord(r) := #2(xy_koord n)
				   ;let val co = !(#content(r))
				    in set_xykoord co 
				    end)
                               | BracketNode(r) 
	                       => (#xkoord(r) := #1(xy_koord n)
				   ;#ykoord(r) := #2(xy_koord n)
				   ;let val co = !(#content(r))
				    in set_xykoord co 
				    end)
                               | LimitNode(r)
                                 => (#xkoord(r) := #1(xy_koord n)
				     ;#ykoord(r) := #2(xy_koord n))
			       | EmptyNode => ()

    (* gesamtes Layout *)

    fun layout n = ( set_xdim n 
		    ; set_l_xdim n 
                    ; calc_ydim n
		    ; set_xykoord n)

end


