(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import signature MK_DICTIONARY from "MK_DICTIONARY-sig"

(* functor MkDictionary *)
functor MkDictionary (type t) :> MK_DICTIONARY where type elemtype = t =
struct
    type elemtype = t
	
    type dictionary = ((int * elemtype) list Array.array ref) 
	* int ref     (* counts no of elements *)
	* int ref     (* next index to be assigned *)
	    
    val empty = let
		    val a = ref(Array.array(5,[]))
		    val fill_count = ref 0
		    val next_i = ref 0
		in
		    (a, fill_count,next_i) 
		end
	
    (* inserts with given key, adjusts size if necessary *)    
    fun insert ((a,fill_count,_) as dict,(key,value)) = 
	let
	    val _ = fill_count := !fill_count + 1
	    val _ = if !fill_count > (Array.length(!a) div 2)
			then let
				 val newsize = Array.length(!a) * 2 + 1
				 val b = !a
				 val _ = a:= Array.array(newsize,[])
				 val _ = fill_count := 1
				 val ins = fn (k,v) => insert(dict,(k,v))
				 val _ = Array.app(fn slot  
						   => (List.app ins  slot)) b 
			     in
				 ()
			     end
		    else ()
	    val slot = key mod Array.length(!a)
	    val liste = (key,value)::Array.sub(!a,slot)
	in 
	    Array.update(!a,slot,liste)
	end
    
    (* searches for key *)
    fun lookup ((a,fill_count,_),key) = 
	let
	    val slot = key mod Array.length(!a)
	in
	    case List.find (fn (i,value) => i = key) (Array.sub(!a,slot))
		of
		    SOME (k,v) => SOME v
		  | NONE => NONE
	end

    fun iterLookup' ((a,fill_count,next_i) as dict,i,f) = 
	if i >=  !next_i
	    then NONE
	else let val found = lookup (dict,i)
		 val fulfilled = case found of
	                       NONE => false
                             | SOME x => f x
	     in if fulfilled
		    then SOME (valOf(found),i)
		else iterLookup'(dict,i+1,f) 
	     end

    fun iterLookup(dict,f) = iterLookup'(dict,0,f) 

    fun dict2list' ((a,fill_count,next_i) as dict,i,li) = 
	if i < 0 orelse i > (!next_i)
	    then rev(li)
	else let 
		 val found = lookup (dict,i)
	     in
		  case found of 
		              NONE => dict2list'(dict,i+1,li)
			    | SOME x => dict2list'(dict,i+1,x::li)
	     end

    fun dict2list dict = dict2list'(dict,0,nil)

    (* deletes all objects with specified key *)
    fun delete  ((a,fill_count,_),key) = 
	let
	    val slot = key mod Array.length(!a)
	    val (drop,take) = List.partition 
		(fn (i,v) => i = key) 
		(Array.sub(!a,slot))
	    val _ = fill_count := !fill_count - List.length(drop)
	in
	    Array.update(!a,slot,take)
	end

    (* inserts and assigns new key *)
    fun insertI  ((a,fill_count,next_i) as d,value) =
	let val key = !next_i
	    val _ = next_i := !next_i + 1
	    val _ = insert(d,(key,value))
	in
	    key
	end

    (* replaces value *)
    fun update ((a,(k,v))) = let
				 val _ = delete (a,k)
				 val _ = insert (a,(k,v))
			     in
				 ()
			     end

    fun getHighestIndexAssigned (_,_,next_index) = (!next_index) -1

    fun dumpAll (a,fill_count,next_i) = let 
					    val _ = a:= Array.array(5,[])
					    val _ = fill_count := 0
					    val _ = next_i := 0
					in
					    ()
					end
end;


