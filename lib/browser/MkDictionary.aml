(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import signature DICTIONARY from "DICTIONARY-sig"

(* functor MkDictionary *)
functor MkDictionary (type t) :> DICTIONARY where type elemtype = t =
struct
    type elemtype = t
	
    type dictionary = ((int * elemtype) list Array.array ref) 
	* int ref     (* counts no of elements *)
	* int ref     (* next index to be assigned *)
	

    (* empty dictionary instance *)

    val empty = let
		    val a = ref(Array.array(5,[]))
		    val fill_count = ref 0
		    val next_i = ref 0
		in
		    (a, fill_count,next_i) 
		end
	

    (* inserts with given key, adjusts size if necessary *)
    
    fun insert ((a,fill_count,_) as dict,(key,value)) = 
	let
	    val slot = 
		(fill_count := !fill_count + 1
	         ;if !fill_count > (Array.length(!a) div 2)
		      then let
			       val newsize = Array.length(!a) * 2 + 1
			       val b = !a
			       val ins = fn (k,v) => insert(dict,(k,v))
			   in
			       (a:= Array.array(newsize,[])
			        ;fill_count := 1
			        ;Array.app(fn slot  
					   => (List.app ins  slot)) b )
			   end
		  else ()
		  ; key mod Array.length(!a))
	    val liste = (key,value)::Array.sub(!a,slot)
	in 
	    Array.update(!a,slot,liste)
	end

    
    (* searches for key *)

    fun lookup ((a,fill_count,_),key) = 
	let
	    val slot = key mod Array.length(!a)
	in
	    case List.find (fn (i,value) => i = key) (Array.sub(!a,slot))
		of
		    SOME (k,v) => SOME v
		  | NONE => NONE
	end


    (* searches for an element with a specific property 
       (uses indicator function) *)

    fun iterLookup' ((a,fill_count,next_i) as dict,i,f) = 
	if i >=  !next_i
	    then NONE
	else let val found = lookup (dict,i)
		 val fulfilled = case found of
	                       NONE => false
                             | SOME x => f x
	     in if fulfilled
		    then SOME (valOf(found),i)
		else iterLookup'(dict,i+1,f) 
	     end

    fun iterLookup(dict,f) = iterLookup'(dict,0,f) 


    (* returns all elements sorted by their keys *)

    fun dict2list' ((a,fill_count,next_i) as dict,i,li) = 
	if i < 0 orelse i > (!next_i)
	    then rev(li)
	else let 
		 val found = lookup (dict,i)
	     in
		  case found of 
		              NONE => dict2list'(dict,i+1,li)
			    | SOME x => dict2list'(dict,i+1,x::li)
	     end

    fun dict2list dict = dict2list'(dict,0,nil)


    (* deletes all objects with specified key, 
       and adjusts size if necessary *)

    fun delete  ((a,fill_count,_) as dict,key) = 
	let
	    val slot = key mod Array.length(!a)
	    val (drop,take) = List.partition 
		(fn (i,v) => i = key) 
		(Array.sub(!a,slot))
	    val fill = (fill_count := !fill_count - List.length(drop)
			;!fill_count)
	in
	    (Array.update(!a,slot,take)
	     ; if fill < (Array.length(!a) div 4)
		   then
		       let 
			   val newsize = Array.length(!a) div 2
			   val ins = fn (k,v) => insert(dict,(k,v))
			   val b = !a
		       in
			   (a:= Array.array(newsize,[])
			    ;fill_count := 0
			    ; Array.app(fn slot  
			       		   => (List.app ins  slot)) b)
		       end
	       else ())
			       
	end


    (* inserts and assigns new key *)

    fun insertI  ((a,fill_count,next_i) as d,value) =
	let val key = !next_i
	    val _ = next_i := !next_i + 1
	    val _ = insert(d,(key,value))
	in
	    key
	end


    fun getHighestIndexAssigned (_,_,next_index) = (!next_index) -1


    (* replaces value *)

    fun update ((a,(k,v))) = let
				 val _ = delete (a,k)
				 val _ = insert (a,(k,v))
			     in
				 ()
			     end


    (* removes everything from the dictionary *)

    fun dumpAll (a,fill_count,next_i) = let 
					    val _ = a:= Array.array(5,[])
					    val _ = fill_count := 0
					    val _ = next_i := 0
					in
					    ()
					end
end;


