(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Fixity from "x-alice:/lib/rtt/Fixity"
import structure Inf from "x-alice:/lib/rtt/Inf"
import structure Label from "x-alice:/lib/rtt/Label"
import structure Path from "x-alice:/lib/rtt/Path"
import structure UnsafeValue from "x-alice:/lib/system/UnsafeValue"
import structure Reflect from "x-alice:/lib/system/Reflect"
import structure Types from "Types"
import structure Helper from "Helper"
import structure MainDictionary from "MainDictionary"
import structure RelManDictionary from "RelManDictionary"
import structure Dictionaries from "Dictionaries"
import structure Settings from "Settings"
import structure NewNode from "NewNode"
import signature NEW_NODE_INF from "NEW_NODE_INF-sig"

local 
    open Types Helper Dictionaries NewNode 
in

structure NewNodeInf :> NEW_NODE_INF =
struct
    
    (* newNodeInf *)
    fun newNodeInf (v,t) = let val va = UnsafeValue.cast v: Reflect.value
			       val i = MainDictionary.
				   getHighestIndexAssigned(dict) +1
			       val _ = RelManDictionary.update(reldict,(i,nil))
			       val _ = Settings.relnumber := 0
			       val node = createGraphInf (va,t,Empty,i,0)
			   in (MainDictionary.insertI(dict,(node)) ; node)
			   end 

    (* createGraphInf *)
    and createGraphInf (va,t,p,i,d) = 
	if !(Settings.relmode) 
	    then let val ind = if p = Empty then i else getAncIndex p
		     val relman = case RelManDictionary.lookup(reldict,ind)
			 of SOME x => x
		          | NONE => []
		     val str = "Ref"^Int.toString(!(Settings.relnumber))
		     val f = if !(Settings.tokenmode)
				 then fn x   
				     => if getDesc(x) = INTERPUNCT  
					    then false  
					else UnsafeValue.same
					    (getValue(getDesc(x)),va)   
			     else fn x   
				 => if getDesc(x) = INTERPUNCT  
					then false  
				    else getValue(getDesc(x)) = va 
		 in 
		     (case List.find f relman of   
			  NONE 
			  => let val desc = createIValue(va,t,NO_ACTIONS)   
				 val node = createRelNode (desc,Empty,p,i,d,
							   str^" as ",
							   relman,setGroup)
				 val c = createUsualGraphInf (va,t,node,0,d) 
				 val actrelman = case 
				     RelManDictionary.lookup(reldict,
							     ind)
				     of SOME x => x
				      | NONE => []
			     in ( case c of     
				 Simple(_) => c
			       | Empty => c    
			       | _ => ( setContent (node,c)   
				       ; RelManDictionary.update(reldict,
								 (ind,
		       			        List.append([node],actrelman)))
				       ; node ) )
			     end     
			| SOME n => let val rep = ( case n of 
						   RelNode(rr) => #rep(rr)
						 | _ => "_")
					val str = iterTake rep	
					val m = incrCounter n 
					val node = 
					    createRelRefNode (INTERPUNCT,p,i,d,
							      str,m,setGroup)
					val actrelman = case 
					    RelManDictionary.lookup(reldict,
								    ind)
					    of SOME x => x
					     | NONE => []
					val part = List.partition 
					                    (fn x => x = n)
							    actrelman
					val restlist = #2(part)
				    in (RelManDictionary.update(reldict,
								(ind,
	       					 List.append([m],restlist)))
					; node)
				    end)
		 end
	else createUsualGraphInf (va,t,p,i,d)
	    
    (* createUsualGraphInf *)
    and createUsualGraphInf (va,t,p,i,d) = 
	(case Inf.inspect t of 
	 Inf.Sig(s) => let val ilist = List.rev(Inf.items(s))
		       in treatSig (va,t,p,i,d,ilist)
		       end 
       | Inf.Arrow(path,i1,i2) 
	 => if d > !(Settings.max_depth)
		then createLimit (createIValue(va,t,NO_ACTIONS),DEPTH_LIMIT,
				  p,i,d,setGroup)
	    else createSimple (createIValue(va,t,NO_ACTIONS),p,i,d,"functor",
			       DEFAULT,setGroup)
       | Inf.Exist(path,i1,i2) => createUsualGraphInf (va,i2,p,i,d)
       | Inf.Sing(m) => let val ti = #2(Inf.asMod(m))
			  in createUsualGraphInf (va,ti,p,i,d)
			  end
       | _ => if d > !(Settings.max_depth)
		  then createLimit (createIValue(va,t,NO_ACTIONS),DEPTH_LIMIT,
				    p,i,d,setGroup)  
	      else createSimple (INTERPUNCT,p,i,d,"_",DEFAULT,setGroup) )

    (* treatSig *)
    and treatSig (va,t,p,i,d,ilist) = 
	if d > !(Settings.max_depth)
	    then createLimit (createIValue(va,t,NO_ACTIONS),DEPTH_LIMIT,p,i,d,
			      setGroup)
	else let val a_length = 2 + List.length(ilist)
		 val container = 
	             createContainer(createIValue(va,t,NO_ACTIONS),
				     p,i,d,Array.array(a_length,Empty),
				     ~1,~1,~1,setGroup)
		 val s_begin = createSimple(INTERPUNCT,container,0,d,"struct",
					    DEFAULT,setGroup)
		 val s_end = createSimple(INTERPUNCT,container,a_length-1,d,
					  "end",DEFAULT,setGroup)
	     in ( Array.update(getKids(container),0,s_begin) 
		 ; Array.update(getKids(container),a_length-1,s_end) 
                 ; setItems (va,ilist,container,d+1) 
		 ; container ) 
	     end   

    (* setItems *)
    and setItems (va,ilist,p,d) = 
	let val l = ref 1
	in while !l <= List.length(ilist) do
	    (let val node = let val vv = UnsafeValue.cast va
				val item = (List.nth(ilist,!l-1))
				val label = itemToLabel(item)
				val in_vv = UnsafeValue.projPoly(vv,label)
			    in createItemNode(in_vv,item,p,!l,d) 
			    end 
	     in Array.update(getKids(p),!l,node)
	     end
           ; l := !l + 1)
	end

    (* createItemNode *)
    and createItemNode (vv,item,p,i,d) = 
	case Inf.inspectItem item of
	Inf.FixItem(_,_) 
	=> let val fix = #2(Inf.asFixItem(item))
	       val str = case fix of
		         Fixity.NONFIX => "  nonfix" 
	               | Fixity.PREFIX(i) => "  prefix "^Int.toString(i)
		       | Fixity.POSTFIX(i) => "  postfix "^Int.toString(i)
		       | Fixity.INFIX(i,Fixity.LEFT) 
			 => "  infix "^Int.toString(i) 
		       | Fixity.INFIX(i,Fixity.RIGHT) 
			 => "  infixr "^Int.toString(i) 
		       | Fixity.INFIX(i,Fixity.NEITHER) 
			 => "  infixn "^Int.toString(i)
	   in createSimple (INTERPUNCT,p,i,d,str,DEFAULT,setGroup) (* Tiefe! *)
	   end 
      | Inf.ValItem(l,t) 
	=> let val conc = createConcat (INTERPUNCT,p,i,d,Array.array(4,Empty),
					~1,~1,setGroup)
	       val s_val = createSimple (INTERPUNCT,conc,0,d,"  val ",DEFAULT,
					 setGroup)
	       val lab = createSimple (INTERPUNCT,conc,1,d,
				       Label.toString(l),LABEL_COLOR,
				       setGroup)
	       val equ = createSimple (INTERPUNCT,conc,2,d," = ",SEP_COLOR,
				       setGroup)
	       val value =  createGraph (vv,t,conc,3,d)  
	   in ( Array.update(getKids(conc),0,s_val)
	       ; Array.update(getKids(conc),1,lab)
	       ; Array.update(getKids(conc),2,equ)
	       ; Array.update(getKids(conc),3,value)
	       ; Array.update(getKids(p),i,conc)
	       ; conc )
	   end
      | Inf.TypItem(path,_)
	=> let val label = Path.toLab(path)
	       val str = "  type "^Label.toString(label)
	   in createSimple (INTERPUNCT,p,i,d,str,DEFAULT,setGroup)
	   end  (* Tiefe! *)
      | Inf.ModItem(path,inf)
	=> let val conc = createConcat (INTERPUNCT,p,i,d,
					Array.array(4,Empty),~1,~1,setGroup)
	       val s_struct = createSimple (INTERPUNCT,conc,1,d,"  structure ",
					    DEFAULT,setGroup)
	       val name = createSimple (INTERPUNCT,conc,1,d,
					Label.toString(Path.toLab(path)),
					LABEL_COLOR,setGroup)
	       val equ = createSimple (INTERPUNCT,conc,2,d," = ",SEP_COLOR,
				       setGroup)
	       val value =  createGraphInf (vv,inf,conc,3,d) 
	   in ( Array.update(getKids(conc),0,s_struct)
	       ; Array.update(getKids(conc),1,name)
	       ; Array.update(getKids(conc),2,equ)
	       ; Array.update(getKids(conc),3,value)
	       ; Array.update(getKids(p),i,conc)
	       ; conc )
	   end
      | Inf.InfItem(path,_)
	=> let val conc = createConcat (INTERPUNCT,p,i,d,
					Array.array(2,Empty),~1,~1,
					setGroup)
	       val s_sig = createSimple (INTERPUNCT,conc,0,d,"  signature ",
					 DEFAULT,setGroup)
	       val name = createSimple (INTERPUNCT,conc,1,d,
					Label.toString(Path.toLab(path)),
					LABEL_COLOR,setGroup)
	   in ( Array.update(getKids(conc),0,s_sig)
	       ; Array.update(getKids(conc),1,name)
	       ; Array.update(getKids(p),i,conc)
	       ; conc)
	   end
      | Inf.HiddenItem(item') 
	=> let val conc = createConcat (INTERPUNCT,p,i,d,
					Array.array(2,Empty),~1,~1,
					setGroup)
	       val ask = createSimple (INTERPUNCT,conc,0,d,"  ? ",
				       DEFAULT,setGroup) 
	       val h_item = createItemNode (vv,item',conc,1,d)
	   in ( Array.update(getKids(conc),0,ask)
	       ; Array.update(getKids(conc),1,h_item)
	       ; Array.update(getKids(p),i,conc)
	       ; conc)
	   end

   (* itemToLabel *)
    and itemToLabel i = case Inf.inspectItem i of
	Inf.FixItem(l,_) => l
      | Inf.ValItem(l,_) => l
      | Inf.TypItem(path,_) => let val str = Label.toString(Path.toLab(path))
				in Label.fromString("$"^str)
				end
      | Inf.ModItem(path,_) => let val str = Label.toString(Path.toLab(path))
			       in Label.fromString(str^"$")
			       end
      | Inf.InfItem(path,_) => let val str = Label.toString(Path.toLab(path))
			       in Label.fromString("$"^str^"$")
			       end   
      | Inf.HiddenItem(i) => itemToLabel i
			       
end (* struct *)

end

