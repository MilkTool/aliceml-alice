(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Type from "x-alice:/lib/rtt/Type"
import structure PervasiveType from "x-alice:/lib/rtt/PervasiveType"
import structure Path from "x-alice:/lib/rtt/Path"
import structure PathMap from "x-alice:/lib/rtt/PathMap"
import structure Label from "x-alice:/lib/rtt/Label"
import structure Reflect from "x-alice:/lib/system/Reflect"
import structure UnsafeValue from "x-alice:/lib/system/UnsafeValue"
import structure Types from "Types"
import structure Helper from "Helper"
import structure MainDictionary from "MainDictionary"
import structure RelManDictionary from "RelManDictionary"
import structure MkPathTable from "MkPathTable"
import structure Settings from "Settings"
import signature NEW_NODE from "NEW_NODE-sig"

local
    open Types
    open Helper
    open MkPathTable
    open Settings

in	
    
structure NewNode :> NEW_NODE =
struct
    
    val dict = MainDictionary.empty
    val reldict = RelManDictionary.empty	

    exception createGraph_unknownNode
    
    (* newNode *)
    fun newNode (v,t) = let val va = UnsafeValue.cast v: Reflect.value
                            val i = MainDictionary.insert(Empty,dict)
			    val _ = RelManDictionary.update(i,reldict,nil)
			    val node =  createGraph (va,t,Empty,i,0)
			in (MainDictionary.insert(node,dict) ; node)
			end
  
    (* createGraph *)
    and createGraph (va,t,p,i,d) = 
	if !relmode 
	    then let val ind = if p = Empty then i else getAncIndex p
                     val relman = RelManDictionary.return(ind,reldict)
                     val l = List.length(relman)
                     val str = "Ref"^Int.toString(l)
		 in 
		     (case List.find (fn x   
				     => if getDesc(x) = INTERPUNCT  
					    then false  
					else UnsafeValue.same(getValue  
							      (getDesc(x)),  
							      va) )  
			            relman of   
		      NONE 
		      => let val desc = createValue(va,t,NO_ACTIONS)   
			     val node =     
				 createRelNode (desc,Empty,p,i,str,relman, 
						setGroup)   
			     val c = createUsualGraph (va,t,node,0,d)   
			 in ( case c of    
			     Simple(_) => c   
                                | Empty => c    
                                | _ => ( setContent (node,c)   
					; RelManDictionary.update(ind,reldict, 
			                     List.append(relman,[node]))  
					; node ) )  
			 end    
		    | SOME n => createRelRefNode (INTERPUNCT,p,i,str^" as ",  
						  n,setGroup) ) 
		 end  
	else createUsualGraph (va,t,p,i,d)

    (* createUsualGraph *)
    and createUsualGraph (va,t,p,i,d) = 
	(case Type.inspect t of
	   Type.Con path 
	   => newPath (va,t,p,i,d,path)
         | Type.Arrow _ 
	   =>  createSimple (createValue(va,t,NO_ACTIONS)
			     ,p,i,"fn",DEFAULT,setGroup)
         | Type.All(var,typ) 
	   => createGraph (va,typ,p,i,d)
	 | Type.Exist(var,typ) 
	   => createGraph (va,typ,p,i,d)
         | Type.Lambda(var,typ) 
	   => raise createGraph_unknownNode
         | Type.Apply(t1,t2)
           => (case unApply (Type.inspect(t)) of 
               (Type.Con path, ts) => newPath (va,t,p,i,d,path)
             | _ => let val typ = #1(Type.asApply(t)) 
		    in if Type.equal(typ,compList) (* Liste *)
			   then let val vv = castList va
				    val listdesc = inspectList(!max_width,vv)
				in queryDepthL (va,t,p,i,d,listdesc,
						listdescToNode)
				end
		       else raise createGraph_unknownNode
		    end)   
         | Type.Prod(row) => queryDepth(va,t,p,i,d,row,treatProd)
	 | Type.Mu(sum) => createGraph (va,sum,p,i,d)
         | Type.Sum(row) => queryDepth(va,t,p,i,d,row,treatSum) 
         | _ => raise  createGraph_unknownNode) 

    (* listdescToNode *)
    and listdescToNode (va,t,p,i,d,ld) = 
       case ld of 
	Indet(l,f) 
	=> let val desc = createValue(va,t,NO_ACTIONS)
               val length = List.length l
	       val na = Array.array(length,Empty)
	       val inty = #2(Type.asApply(t))   
	       val cont = createContainer (desc,p,i,na,~1,~1,~1,setGroup)
	       val nodearray = listElemArray(l,length,inty,cont,d,true)
	       val future = createSimple (INTERPUNCT,cont,length,"_",DEFAULT,
					  setGroup)
	   in ( Array.update(na,length,future)
	      ; copyArray(nodearray,na)
	      ; cont )
	   end
      | Det(l,b) 
        => let val desc = createValue(va,t,NO_ACTIONS)
	       val length = List.length l
               val na = if b then Array.array(length + 1,Empty)
			else Array.array(length,Empty)
	       val inty = #2(Type.asApply(t))   
	   in if b
		  then let val cont = createContainer (desc,p,i,na,~1,~1,~1,
						       setGroup)
			   val nodearray = listElemArray(l,length,inty,cont,
							 d,b)
			   val limit = createLimit (INTERPUNCT,WIDTH_LIMIT,
						    cont,length,d+1,setGroup)
		       in ( Array.update(na,length,limit)
			  ; copyArray(nodearray,na)
			  ; cont )
		       end
	      else let val concat = createConcat(desc,p,i,Array.array(3,Empty),
						 ~1,~1,setGroup) 
		       val lbra = createSimple (INTERPUNCT,concat,0,
						"[",BRACK_COLOR,setGroup)
		       val rbra = createSimple (INTERPUNCT,concat,2,
						"]",BRACK_COLOR,setGroup)
		       val cont = createContainer (desc,concat,1,na,~1,~1,~1,
						   setGroup)
		       val last = let val inva = UnsafeValue.cast(List.last(l))
		                         : Reflect.value
				  in createGraph(inva,inty,cont,length-1,d+1)
				  end      		   
		       val nodearray = listElemArray(List.take(l,length-1),
						     length-1,inty,cont,d,b)
		   in ( Array.update(na,length-1,last)
                      ; copyArray(nodearray,na)
		      ; Array.update(getKids(concat),0,lbra)
		      ; Array.update(getKids(concat),1,cont)
		      ; Array.update(getKids(concat),2,rbra)
		      ; concat )
		   end
	   end
    
    (* ListElemArray *)
    and listElemArray(list,length,listtyp,p,d,b) = 
	let val rl = ref (length - 1)
	    val na = Array.array(length,Empty)
	in ( while !rl >= 0 do
            (let val concat = createConcat(INTERPUNCT,p,!rl,
					   Array.array(2,Empty),
                                           ~1,~1,setGroup) 
                 val inva = UnsafeValue.cast(List.nth(list,!rl))
                            : Reflect.value
                 val elem = createGraph(inva,listtyp,concat,0,d+1)
                 val repr = if b = true then "::" else ", "
                 val sep = createSimple(INTERPUNCT,concat,1,repr,SEP_COLOR,
					setGroup)
	     in ( Array.update(getKids(concat),0,elem)
                ; Array.update(getKids(concat),1,sep)
                ; Array.update(na,!rl,concat))
	     end ; rl := !rl - 1)
	   ; na )
	end
                                             
    (* treatProd *)
    and treatProd (va,t,p,i,d,row) = 
	let
	      val upperConcat = createConcat(createValue(va,t,NO_ACTIONS),
					     p,i,Array.array(3,Empty)
					     ,~1,~1,setGroup)
	      val (lbra,rbra) = if Type.isTupleRow(row) 
				    then ("(",")")
				else ("{","}")
	      val (lbraNode,rbraNode) = (createSimple (INTERPUNCT,upperConcat,
						       0,lbra,BRACK_COLOR,
						       setGroup),
					 createSimple (INTERPUNCT,upperConcat,
						       2,rbra,BRACK_COLOR,
						       setGroup))
	      val container = createContfromRow (va,t,upperConcat,1,d,row, 
						 UnsafeValue.proj) 
	      val upperKids = getKids(upperConcat)
	  in
	      ( Array.update(upperKids,0,lbraNode)
	       ; Array.update(upperKids,1,container)
	       ; Array.update(upperKids,2,rbraNode)
	       ; upperConcat)
	  end
	
    (* treatSum *)
    and treatSum (va,t,p,i,d,row) = 
        let
	    val upperConcat = createConcat(createValue(va,t,NO_ACTIONS),
					   p,i,Array.array(4,Empty),
			                   ~1,~1,setGroup)
	    val lt_list   = row2list(row)
	    val l_vector  = labelvector(lt_list)
	    val index     = UnsafeValue.tag(va,l_vector)
	    val label     = Label.toString(Vector.sub(l_vector,index))
	                    ^" "
	    val labelnode =  createSimple (INTERPUNCT,upperConcat,
					   0,label,LABEL_COLOR,setGroup)
	    val typ = #2(List.nth(lt_list,index))
	    val intyp = if Type.isApply(typ) 
		        andalso Path.equal(Type.asCon(#1(Type.asApply(typ))),
					   PervasiveType.path_strict)
			    then  #2(Type.asApply(typ))
			else typ
	    val (lbra,rbra) =  let val row' = Type.asProd(intyp)
			       in if Type.isTupleRow(row')
				      then ("(",")")
				   else ("{","}")
			       end
			       handle Type.Type => ("","")
	    val (lbraNode,rbraNode) = (createSimple (INTERPUNCT,upperConcat,
						     1,lbra,BRACK_COLOR,
						     setGroup),
				       createSimple (INTERPUNCT,upperConcat,
						     3,rbra,BRACK_COLOR,
						     setGroup))
	    val container = case Type.inspect(intyp) of 
		Type.Prod(row') 
		=> if Type.isEmptyRow(row') 
		       then Empty
		   else
		       createContfromRow (va, t, upperConcat, 2, d, row', 
					  UnsafeValue.projTagged)
	      | _ => let
			 val inva = UnsafeValue.projTaggedTuple(va,1,0)
			 val node = createGraph (inva,intyp,upperConcat,0,d+1)
		     in 
			 node 
		     end
	    val upperKids = getKids(upperConcat)
	in
	    if container = Empty 
		then labelnode 
	    else (Array.update(upperKids,0,labelnode)
		  ; Array.update(upperKids,1,lbraNode)
		  ; Array.update(upperKids,2,container)
		  ; Array.update(upperKids,3,rbraNode)
		  ; upperConcat) 
	end

    (* createContfromRow *)
    and createContfromRow (va, t, p, i, d, row, proj) = 
	let
	    val lt_list   = row2list(row)
	    val l_vector  = labelvector(lt_list)
	    val wlimit    = List.length(lt_list) > !max_width 
	    val l         = if wlimit then !max_width
			    else List.length(lt_list)
	    val al = if wlimit then !max_width +1 else l
	    val container = createContainer(INTERPUNCT,
					    p,i,Array.array(al,Empty)
					    ,~1,~1,~1,setGroup)
	    val createProdC = if Type.isTupleRow(row)
				  then createProdConcatTuple
			      else createProdConcat
	    val nodes = 
		Array.tabulate(al,
			       (fn i => 
				if wlimit andalso i = !max_width
				    then createLimit (INTERPUNCT,
						      WIDTH_LIMIT,
						      container,
						      i,d,setGroup)
				else createProdC (Label.toString
						  (#1(List.nth(lt_list,i))),
						  proj(va,l_vector,i),
						  #2(List.nth(lt_list,i)),
						  container,i,d,al)) )
	    val _ = copyArray(nodes,getKids(container))
	in
	    container
	end

    (* createProdConcat *)
    and createProdConcat (label,va,t,p,i,d,l) = 
	let 
	    val last = if i = l-1 then true else false
	    val c_length = if last then 3 else 4
	    val concat = createConcat (INTERPUNCT,p,i,
				       Array.array(c_length,Empty),
				       ~1,~1,setGroup)
	    val l_node = createSimple (INTERPUNCT,concat,0,label,
				       LABEL_COLOR,setGroup)
	    val eq_node = createSimple (INTERPUNCT,concat,1," = ",
					EQU_COLOR,setGroup)
	    val sep_node = createSimple (INTERPUNCT,concat,3,", ",
					 SEP_COLOR,setGroup)
	    val node = createGraph (va,t,concat,2,d+1)
	    val concat_kids = getKids(concat)
	in
	    (Array.update(concat_kids,0,l_node)
	     ; Array.update(concat_kids,1,eq_node)
	     ; Array.update(concat_kids,2,node)
	     ; if last then () else 
	     Array.update(concat_kids,3,sep_node)
	     ;concat)
	end
    
    (* createProdConcatTuple *)
    and createProdConcatTuple (label,va,t,p,i,d,l) = 
	let 
	    val last = if i = l-1 then true else false
	    val c_length = if last then 1 else 2
	    val concat = createConcat (INTERPUNCT,p,i,
				       Array.array(c_length,Empty),
				       ~1,~1,setGroup)
	    val sep_node = createSimple (INTERPUNCT,concat,1,", ",
					 SEP_COLOR,setGroup)
	    val node = createGraph (va,t,concat,0,d+1)
	    val concat_kids = getKids(concat)
	in
	    if last 
		then node 
	    else 
		(Array.update(concat_kids,0,node)
		 ; Array.update(concat_kids,1,sep_node)
		 ;concat)                                       
	end
    
(*           (Array.update(concat_kids,0,node  )
	     ; if last then () else 
	     Array.update(concat_kids,1,sep_node)
	     ;concat)                                        *)

    (* newPath *)
    and newPath (v,t,p,i,d,path) =
        (case PathMap.lookup(pathTable, path) of
	   NONE => if d > !max_depth
		       then createLimit(INTERPUNCT,DEPTH_LIMIT,p,i,d,setGroup)
		   else createSimple(INTERPUNCT,p,i,"_",DEFAULT,setGroup)
         | SOME create => let val doc = create (!max_width,d,v,t)
                          in docToNode (doc,p,i,d) 
			  end )

    (* docToNode *)
    and docToNode (doc,p,i,d) =
        (case doc of
         SIMPLE(r) 
	   => let val color = 
	             (case #desc(r) of 
		      INTERPUNCT => (case #rep(r) of ", " => SEP_COLOR
		                                   | " = " => EQU_COLOR
						   | ("{" | "}" | "(" | ")"
                                                          | "#[" | "]" )  
						     => BRACK_COLOR
						   | _ => LABEL_COLOR)
		    | VALUE(rr) 
		      => (case Type.inspect(#typ(rr)) of
			  Type.Con path
			  => (if Path.equal(path,PervasiveType.path_int)
				  then INT_COLOR
			      else
			       if Path.equal(path,PervasiveType.path_real)
				   then REAL_COLOR
			       else 
			        if Path.equal(path,PervasiveType.path_char)
				    then CHAR_COLOR
				else 
				 if Path.equal(path,PervasiveType.path_string)
				     then STR_COLOR
				 else
	                          if Path.equal(path,PervasiveType.path_word) 
				      then WORD_COLOR
				  else 
				   if Path.equal(path,PervasiveType.path_exn)
				       then EXN_COLOR
				   else 
				    if Path.equal(path,PervasiveType.path_ref)
					then REF_COLOR
				    else DEFAULT)
			| _ => DEFAULT) ) 
	      in createSimple (#desc(r),p,i,#rep(r),color,setGroup) 
	      end  
        | CONCAT(r) => let val na = Array.array(Vector.length(#kids(r)),
						 Empty)
                            val concat = createConcat(#desc(r),p,i,na,~1,~1,
						      setGroup)
                            val rl = ref (Vector.length(#kids(r)) - 1)
			in (while !rl >= 0 do
			    (Array.update(na,
					  !rl,
					  docToNode(Vector.sub(#kids(r),!rl),
						    concat,!rl,d))
			     ; rl := !rl - 1)
			    ; concat)
			end
         | CONTAINER(r) => let val na = Array.array(Vector.length(#kids(r)),
						    Empty)
                               val container = createContainer(#desc(r),p,i,
                                                               na,~1,~1,~1,
							       setGroup)
			       val rl = ref (Vector.length(#kids(r)) - 1)
			   in (while !rl >= 0 do
			       (Array.update(na,
					     !rl,
					     docToNode(Vector.sub(#kids(r),
								  !rl),
						       container,!rl,d+1))
				; rl := !rl - 1)
			       ; container)
			   end
         | LIMIT(r) => createLimit(#desc(r),#sort(r),p,i,d,setGroup) 
         | EMBEDDED(v,t) => (createGraph(v,t,p,i,d)) )
		
    (* createSimple *) 
    and createSimple (desc,p,i,str,color,f) = Simple {desc = desc, 
						      parent = p,
						      index = i,
						      rep = str,
						      width = 
						      ref(String.length(str)), 
						      color = color, 
						      status = ref DAZZLED,
						      group = f(p)}
 
    (* createConcat *)
    and createConcat (desc,p,i,na,w,h,f) =  Concat {desc = desc,
						    parent = p,
						    index  = i,
						    kids = na, 
						    width  = ref w,
						    height = ref h,
						    status = ref DAZZLED,
						    group = f(p)}

    (* createContainer *)
    and createContainer (desc,p,i,na,w,h,l_w,f) =  
	Container {desc = desc, 
		   parent = p,
		   index = i,
		   kids = na, 
		   width = ref w,
		   height = ref h,
		   l_width = ref l_w,
		   status = ref DAZZLED,
		   group = f(p)}

    (* createLimit *)
    and createLimit (desc,sort,p,i,d,f) =  Limit  {desc = desc,
						   sort = sort, 
						   parent = p,
						   index  = i,
						   depth = d,
						   status = ref DAZZLED,
						   group = f(p)}

    (* createRelNode *)
    and createRelNode (desc,c,p,i,str,rman,f) = 
	RelNode {desc = desc, 
                 content = ref c,
		 parent = p,  
		 index = i, 
		 counter = ref 1, 
		 rep = str, 
		 relman = ref rman, 
		 width = ref ~1,
		 height = ref ~1,
		 color = REL_COLOR  , 
		 status = ref DAZZLED, 
		 group = f(p)}

    (* createRelRefNode *)
    and createRelRefNode (desc,p,i,str,rnode,f) = 
	RelRefNode {desc = desc, 
		    parent = p, 
		    index = i, 
		    rep = str, 
		    relnode = rnode,
		    width = ref(String.length(str)), 
		    color = REF_COLOR, 
		    status = ref DAZZLED,  
		    group = f(p)}  
                                                    
    (* queryDepth *)
    and queryDepth (va,t,p,i,d,row,f) = 
	if d > !max_depth 
	    then createLimit (createValue(va,t,NO_ACTIONS),DEPTH_LIMIT,
			      p,i,d,setGroup)
	else f (va,t,p,i,d,row)

    (* queryDepthL *)
    and queryDepthL (va,t,p,i,d,ld,f) = 
	if d > !max_depth 
	    then createLimit (createValue(va,t,NO_ACTIONS),DEPTH_LIMIT,
			      p,i,d,setGroup)
	else f (va,t,p,i,d,ld)

	    
end (* struct end *)
 
end (* local end *)
 
