(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Type from "x-alice:/lib/rtt/Type"
import structure PervasiveType from "x-alice:/lib/rtt/PervasiveType"
import structure Path from "x-alice:/lib/rtt/Path"
import structure PathMap from "x-alice:/lib/rtt/PathMap"
import structure Label from "x-alice:/lib/rtt/Label"
import structure Reflect from "x-alice:/lib/system/Reflect"
import structure UnsafeValue from "x-alice:/lib/system/UnsafeValue"
import structure Types from "Types"
import structure Helper from "Helper"
import structure Dictionary from "Dictionary"
import structure MkPathTable from "MkPathTable"
import signature NEW_NODE from "NEW_NODE-sig"

open Types
open Helper
open MkPathTable

structure NewNode :> NEW_NODE =
struct

    val max_width = ref 15
    val max_depth = ref 5
    val dict = Dictionary.empty
    
    exception createGraph_unknownNode

    (* newNode *)
    fun newNode (v,t) = let val va = UnsafeValue.cast v: Reflect.value
                            val i = Dictionary.insert(Empty,dict)
			    val node =  createGraph (va,t,Empty,i,0)
			in (Dictionary.insert(node,dict) ; node)
			end

    (* createGraph *)
    and createGraph (va,t,p,i,d) = 
	(case Type.inspect t of
	   Type.Con path 
	   => newPath (va,t,p,i,d,path)
         | Type.Arrow _ 
	   =>  createSimple (createValue(va,t,NO_ACTIONS)
			     ,p,i,"fn",DEFAULT,setGroup)
         | Type.All(var,typ) 
	   => createGraph (va,typ,p,i,d)
	 | Type.Exist(var,typ) 
	   => createGraph (va,typ,p,i,d)
         | Type.Lambda(var,typ) 
	   => raise createGraph_unknownNode
         | Type.Apply(t1,t2)
           => (case unApply (Type.inspect(t)) of 
               (Type.Con path, ts) => newPath (va,t,p,i,d,path)
             | _ => raise createGraph_unknownNode)   
         | Type.Prod(row) =>  raise createGraph_unknownNode  
	 | Type.Mu(sum) => createGraph(va,sum,p,i,d)
         | Type.Sum(row) =>  raise createGraph_unknownNode  
         | _ => raise  createGraph_unknownNode) 

    (* treatProd *)
    and treatProd (va,t,p,i,d,row) = 
	let
	      val upperConcat = createConcat(createValue(va,t,NO_ACTIONS),
					     p,i,Array.array(3,Empty)
					     ,~1,~1,setGroup)
	      val (lbra,rbra) = if Type.isTupleRow(row) 
				    then ("(","(")
				else ("{","}")
	      val (lbraNode,rbraNode) = (createSimple (INTERPUNCT,upperConcat,
						       0,lbra,BRACK_COLOR,
						       setGroup),
					 createSimple (INTERPUNCT,upperConcat,
						       2,rbra,BRACK_COLOR,
						       setGroup))
	      val container = createContfromRow (va,t,upperConcat,1,d,row, 
						 UnsafeValue.proj) 
	      val upperKids = getKids(upperConcat)
	  in
	      ( Array.update(upperKids,0,lbraNode)
	       ; Array.update(upperKids,1,container)
	       ; Array.update(upperKids,2,rbraNode)
	       ; upperConcat)
	  end
	
    (* treatSum *)
    and treatSum (va,t,p,i,d,row) = 
        let
	    val upperConcat = createConcat(createValue(va,t,NO_ACTIONS),
					   p,i,Array.array(4,Empty),
			                   ~1,~1,setGroup)
	    val lt_list   = row2list(row)
	    val l_vector  = labelvector(lt_list)
	    val index     = UnsafeValue.tag(va,l_vector)
	    val label     = Label.toString(Vector.sub(l_vector,index))
	    val labelnode =  createSimple (INTERPUNCT,upperConcat,
					   0,label,LABEL_COLOR,setGroup)
	    val (lbra,rbra) =  if Type.isTupleRow(row) 
				   then ("(","(")
			       else ("{","}")
	    val (lbraNode,rbraNode) = (createSimple (INTERPUNCT,upperConcat,
						     1,lbra,BRACK_COLOR,
						     setGroup),
				       createSimple (INTERPUNCT,upperConcat,
						     3,rbra,BRACK_COLOR,
						     setGroup))
	    val typ = #2(List.nth(lt_list,index))
	    val intyp = if Type.isApply(typ) 
		        andalso Path.equal(Type.asCon(#1(Type.asApply(typ))),
					   PervasiveType.path_strict)
			    then  #2(Type.asApply(typ))
			else typ
	    val container = case Type.inspect(intyp) of 
		Type.Prod(row') 
		=> if Type.isEmptyRow(row') 
		       then Empty
		   else
		       createContfromRow (va, t, upperConcat, 2, d, row', 
					  UnsafeValue.projTagged)
	      | _ => let
			 val inva = UnsafeValue.projTaggedTuple(va,1,0)
			 val node = createGraph (inva,intyp,upperConcat,0,d+1)
		     in 
			 node 
		     end
	    val upperKids = getKids(upperConcat)
	in
	    if container = Empty 
		then labelnode 
	    else (Array.update(upperKids,0,labelnode)
		  ; Array.update(upperKids,1,lbraNode)
		  ; Array.update(upperKids,2,container)
		  ; Array.update(upperKids,3,rbraNode)
		  ; upperConcat) 
	end

    (* createContfromRow *)
    and createContfromRow (va, t, p, i, d, row, proj) = 
	let
	    val lt_list   = row2list(row)
	    val l_vector  = labelvector(lt_list)
	    val wlimit    = List.length(lt_list) > !max_width 
	    val l         = if wlimit then !max_width
			    else List.length(lt_list)
	    val al = if wlimit then !max_width +1 else l
	    val container = createContainer(createValue(va,t,NO_ACTIONS),
					    p,i,Array.array(al,Empty)
					    ,~1,~1,~1,setGroup)
	    val createProdC = if Type.isTupleRow(row)
				  then createProdConcatTuple
			      else createProdConcat
	    val nodes = 
		Array.tabulate(al,
			       (fn i => 
				if wlimit andalso i = !max_width
				    then createLimit (INTERPUNCT,
						      WIDTH_LIMIT,
						      container,
						      i,d,setGroup)
				else 
				    createProdC (Label.toString
						 (#1(List.nth(lt_list,i))),
						 proj(va,l_vector,i),
						 #2(List.nth(lt_list,i)),
						 container,i,d,l)))
	    val _ = copyArray(nodes,getKids(container))
	in
	    container
	end

    (* createProdConcat *)
    and createProdConcat (label,va,t,p,i,d,l) = 
	let 
	    val last = if i = l-1 then true else false
	    val c_length = if last then 3 else 4
	    val concat = createConcat (INTERPUNCT,p,i,
				       Array.array(c_length,Empty),
				       ~1,~1,setGroup)
	    val l_node = createSimple (INTERPUNCT,concat,0,label,
				       LABEL_COLOR,setGroup)
	    val eq_node = createSimple (INTERPUNCT,concat,1," = ",
					EQU_COLOR,setGroup)
	    val sep_node = createSimple (INTERPUNCT,concat,3,", ",
					 SEP_COLOR,setGroup)
	    val node = createGraph (va,t,concat,2,d+1)
	    val concat_kids = getKids(concat)
	in
	    (Array.update(concat_kids,0,l_node)
	     ; Array.update(concat_kids,1,eq_node)
	     ; Array.update(concat_kids,2,node)
	     ; if last then () else 
	     Array.update(concat_kids,3,sep_node)
	     ;concat)
	end
    
    (* createProdConcatTuple *)
    and createProdConcatTuple (label,va,t,p,i,d,l) = 
	let 
	    val last = if i = l-1 then true else false
	    val c_length = if last then 1 else 2
	    val concat = createConcat (INTERPUNCT,p,i,
				       Array.array(c_length,Empty),
				       ~1,~1,setGroup)
	    val sep_node = createSimple (INTERPUNCT,concat,1,", ",
					 SEP_COLOR,setGroup)
	    val node = createGraph (va,t,concat,0,d+1)
	    val concat_kids = getKids(concat)
	in
	    (Array.update(concat_kids,0,node  )
	     ; if last then () else 
	     Array.update(concat_kids,1,sep_node)
	     ;concat)
	end

    (* newPath *)
    and newPath (v,t,p,i,d,path) =
        (case PathMap.lookup(pathTable, path) of
	   NONE => createSimple(INTERPUNCT,p,i,"_",DEFAULT,setGroup)
         | SOME create => let val doc = create (!max_width,d,v,t)
                          in docToNode (doc,p,i,d) 
			  end )

    (* docToNode *)
    and docToNode (doc,p,i,d) =
        (case doc of
           SIMPLE(r) => createSimple (#desc(r),p,i,#rep(r),DEFAULT,setGroup)
         | CONCAT(r) => let val na = Array.array(Vector.length(#kids(r)),
						 Empty)
                            val concat = createConcat(#desc(r),p,i,na,~1,~1,
						      setGroup)
                            val rl = ref (Vector.length(#kids(r)) - 1)
			in (while !rl >= 0 do
			    (Array.update(na,
					  !rl,
					  docToNode(Vector.sub(#kids(r),!rl),
						    concat,!rl,d+1))
			     ; rl := !rl - 1)
			    ; concat)
			end
         | CONTAINER(r) => let val na = Array.array(Vector.length(#kids(r)),
						    Empty)
                               val container = createContainer(#desc(r),p,i,
                                                               na,~1,~1,~1,
							       setGroup)
			       val rl = ref (Vector.length(#kids(r)) - 1)
			   in (while !rl >= 0 do
			       (Array.update(na,
					     !rl,
					     docToNode(Vector.sub(#kids(r),
								  !rl),
						       container,!rl,d+1))
				; rl := !rl - 1)
			       ; container)
			   end
         | LIMIT(r) => createLimit(#desc(r),#sort(r),p,i,d,setGroup) 
         | EMBEDDED(v,t) => (createGraph(v,t,p,i,d)) )
		
    (* createSimple *) 
    and createSimple (desc,p,i,str,color,f) = Simple {desc = desc, 
						      parent = p,
						      index = i,
						      rep = str,
						      width = 
						      ref(String.length(str)), 
						      color = color, 
						      status = ref DAZZLED,
						      group = f(p)}

    (* createConcat *)
    and createConcat (desc,p,i,na,w,h,f) =  Concat {desc = desc,
						    parent = p,
						    index  = i,
						    kids = na, 
						    width  = ref w,
						    height = ref h,
						    status = ref DAZZLED,
						    group = f(p)}

    (* createContainer *)
    and createContainer (desc,p,i,na,w,h,l_w,f) =  
	Container {desc = desc, 
		   parent = p,
		   index = i,
		   kids = na, 
		   width = ref w,
		   height = ref h,
		   l_width = ref l_w,
		   status = ref DAZZLED,
		   group = f(p)}

    (* createLimit *)
    and createLimit (desc,sort,p,i,d,f) =  Limit  {desc = desc,
						   sort = sort, 
						   parent = p,
						   index  = i,
						   depth = d,
						   status = ref DAZZLED,
						   group = f(p)}
                                                    
    (* queryDepth *)
    and queryDepth(va,t,p,i,d,row,f) = 
	if d > !max_depth 
	    then createLimit (createValue(va,t,NO_ACTIONS),DEPTH_LIMIT,
			      p,i,d,setGroup)
	else f (va,t,p,i,d,row)
	    
end

