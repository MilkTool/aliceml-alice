(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure TextIO from "x-alice:/lib/system/TextIO"

import structure Fixity from "x-alice:/lib/rtt/Fixity"
import structure Type from "x-alice:/lib/rtt/Type"
import structure Inf from "x-alice:/lib/rtt/Inf"
import structure PervasiveType from "x-alice:/lib/rtt/PervasiveType"
import structure Path from "x-alice:/lib/rtt/Path"
import structure Name from "x-alice:/lib/rtt/Name"
import structure PathMap from "x-alice:/lib/rtt/PathMap"
import structure Label from "x-alice:/lib/rtt/Label"
import structure Reflect from "x-alice:/lib/system/Reflect"
import structure UnsafeValue from "x-alice:/lib/system/UnsafeValue"
import structure Types from "Types"
import structure Helper from "Helper"
import structure MainDictionary from "MainDictionary"
import structure RelManDictionary from "RelManDictionary"
import structure ReinspectedRelDict from "ReinspectedRelDict"
import structure TransientDictionary from "TransientDictionary"
import structure Dictionaries from "Dictionaries"
import structure Update from "Update"
import structure MkPathTable from "MkPathTable"
import structure Services from "Services"
import structure Settings from "Settings"
import structure WindowManager from "WindowManager"
import structure NewNodeHelper from "NewNodeHelper"
import signature NEW_NODE from "NEW_NODE-sig"

local
    open Types Helper MkPathTable Settings Dictionaries NewNodeHelper
 
in	
    
structure NewNode :> NEW_NODE =
struct
    
    exception Future
    exception createGraph_unknownNode

    (* newNode *)
    fun newNode (v,t) = let val va = UnsafeValue.cast v: Reflect.value
                            val i = MainDictionary.
				getHighestIndexAssigned(dict) +1
			    val _ = RelManDictionary.update(reldict,(i,nil))
                            val _ = relnumber := 0
			    val node =  createGraph (va,t,Empty,i,0)
			    val (x1,y1,x2,y2) = Services.getCoordinates(
							 getGroup(node))
			    val _ = TextIO.print("NEWNODE: x1 = "
						 ^ Int.toString(x1)
						 ^ " y1 = "
						 ^ Int.toString(y1)
						 ^ " x2 = "
						  ^ Int.toString(x2)
						 ^ " y2 = "
						  ^ Int.toString(y2)
						 ^" \n" )
			in (MainDictionary.insertI(dict,(node)) ; node)
			end
  
    (* createGraph *)
    and createGraph (va,t,p,i,d) = 
	if !relmode (* Konstruktion im Relationsmodus *)
	    then let val ind = if p = Empty then i else getAncIndex p
                     val relman = case RelManDictionary.lookup(reldict,ind)
			 of SOME x => x
		       | NONE => []
		     val desc = createValue(va,t,NO_ACTIONS) 
                     val str = "Ref"^Int.toString(!relnumber)
                     val f = if !tokenmode
				 then fn x   
				      => if getDesc(x) = INTERPUNCT  
					     then false  
					 else UnsafeValue.same
					     (getValue(getDesc(x)),va)   
			     else fn x   
				  => if getDesc(x) = INTERPUNCT  
					 then false  
				     else getValue(getDesc(x)) = va 
		 in 
		     (case List.find f relman of   
		      NONE (* erstmalige Darstellung des Wertes *) 
		      => let val node = createRelNode (desc,Empty,p,i,d,
						       str^" as ",
						       relman,setGroup)
			     val c = createUsualGraph (va,t,node,0,d) 
			     val actrelman = case 
				 RelManDictionary.lookup(reldict,ind)
				 of SOME x => x
			          | NONE => []
			 in (setContent (node,c)   
			     ; RelManDictionary.update(reldict,
						       (ind,
						List.append([node],actrelman)))
			     ; node )
			 end     
		    | SOME n (* Wert bereits dargestellt - Referenzbildung *)
		      => let val rep = ( case n of RelNode(rr) => #rep(rr)
		                                 | _ => "_")
			     val str = iterTake rep	
			     val m = incrCounter n 
			     val node = 
				 if isSimple (getContent(n))
				     then createUsualGraph (va,t,p,i,d)
				 else 
				     let val ri_rel = 
					 case ReinspectedRelDict.lookup
					     (ri_reldict,ind) of SOME x => x
					                       | NONE => []
				     in case List.find f ri_rel 
					 of NONE => createRelRefNode (desc,p,i,
								      d,str,m,
								      setGroup)
				          | SOME no => if getDesc(no) = desc
					         andalso getParent(no) = p
						 andalso getIndex(no) = i
						 andalso getDepth(no) = d
							   then no
						       else createRelRefNode
							   (desc,p,i,d,str,m,
							    setGroup)
				     end
			     val actrelman = case 
				 RelManDictionary.lookup(reldict,ind) 
				 of SOME x => x
			       | NONE => []
			     val part = List.partition(fn x => x = n) actrelman
			     val restlist = #2(part)
			 in (RelManDictionary.update(reldict,
						     (ind,
						    List.append([m],restlist)))
			     ; node)
			 end)
		 end
	else createUsualGraph (va,t,p,i,d)
	    
    (* createUsualGraph *)
    and createUsualGraph (va,t,p,i,d) = 
	let val fut = UnsafeValue.cast va
	in if not(Future.isDetermined(fut))
	       then createFutureNode (va,t,p,i,d)
	   else
	   (case Type.inspect t of
	    Type.Con path 
	    => newPath (va,t,p,i,d,path)
	   | Type.Arrow _ 
	     => if d > !max_depth
		    then createLimit (createValue(va,t,NO_ACTIONS),DEPTH_LIMIT,
				      p,i,d,setGroup)
		else createSimple (createValue(va,t,NO_ACTIONS),p,i,d,"fn",
				   DEFAULT,setGroup)
	   | Type.All(var,typ) 
	     => createGraph (va,typ,p,i,d)
	   | Type.Exist(var,typ) 
	     => createGraph (va,typ,p,i,d)
	   | Type.Lambda(var,typ) 
	     => raise  createGraph_unknownNode 
           | Type.Apply(t1,t2)
             => (case unApply (Type.inspect(t)) of 
                 (Type.Con path, ts) 
		  => newPath (va,t,p,i,d,path)
		| _ => let val typ = #1(Type.asApply(t)) 
		       in if Type.equal(typ,compList) (* Liste *)
			      then let val vv = castList va
				       val listdesc = inspectList(!max_width,
								  vv)
				   in queryDepthL (va,t,p,i,d,listdesc,
						   listdescToNode)
				   end
			  else raise createGraph_unknownNode
		       end)  
	   | Type.Prod(row) => queryDepth(va,t,p,i,d,row,treatProd)
	   | Type.Mu(sum) => createGraph (va,sum,p,i,d)
	   | Type.Sum(row) => queryDepth(va,t,p,i,d,row,treatSum) 
	   | _ => raise  createGraph_unknownNode )
	end
		
(* spezielle Behandlung von Listen *)

   (* listdescToNode *)
    and listdescToNode (va,t,p,i,d,ld) = 
       case ld of 
	Indet(l,f) 
	=> let val desc = createValue(va,t,NO_ACTIONS)
               val length = List.length l
	       val na = Array.array(length,Empty)
	       val inty = #2(Type.asApply(t))   
	       val cont = createContainer (desc,p,i,d,na,setGroup)
	       val nodearray = listElemArray(l,length,inty,cont,d+1,true)
	       val future = createSimple (INTERPUNCT,cont,length,d+1,"_",
					  DEFAULT,setGroup)
	   in ( Array.update(na,length,future)
	      ; copyArray(nodearray,na)
	      ; cont )
	   end
      | Det(l,b) 
        => let val desc = createValue(va,t,NO_ACTIONS)
	       val length = List.length l
               val na = if b then Array.array(length + 1,Empty)
			else Array.array(length,Empty)
	       val inty = #2(Type.asApply(t))   
	   in if b
		  then let val cont = createContainer (desc,p,i,d,na,setGroup)
			   val nodearray = listElemArray(l,length,inty,cont,
							 d+1,b)
			   val limit = createLimit (INTERPUNCT,WIDTH_LIMIT,
						    cont,length,d+1,setGroup)
		       in ( Array.update(na,length,limit)
			  ; copyArray(nodearray,na)
			  ; cont )
		       end
	      else let val concat = createConcat(desc,p,i,d,
						 Array.array(3,Empty),setGroup)
 		       val lbra = createSimple (INTERPUNCT,concat,0,d,
						"[",BRACK_COLOR,setGroup)
		       val rbra = createSimple (INTERPUNCT,concat,2,d,
						"]",BRACK_COLOR,setGroup)
		       val cont = createContainer (INTERPUNCT,concat,1,d,
						   na,setGroup)
		       val nodearray = listElemArray(List.take(l,length-1),
						     length-1,inty,cont,d,b)
		       val last = let val inva = UnsafeValue.cast(List.last(l))
			                         : Reflect.value
				  in createGraph(inva,inty,cont,length-1,d+1)
				  end      	
		   in ( Array.update(na,length-1,last)
                      ; copyArray(nodearray,na)
		      ; Array.update(getKids(concat),0,lbra)
		      ; Array.update(getKids(concat),1,cont)
		      ; Array.update(getKids(concat),2,rbra)
		      ; concat )
		   end
	   end
    
    and listElemArray(list,length,listtyp,p,d,b) = 
	let val rl = ref 0
	    val na = Array.array(length,Empty)
	in ( while !rl < length do
            (let val concat = createConcat(INTERPUNCT,p,!rl,d,
					   Array.array(2,Empty),setGroup) 
                 val inva = UnsafeValue.cast(List.nth(list,!rl))
                            : Reflect.value
                 val elem = createGraph(inva,listtyp,concat,0,d+1)
                 val repr = if b = true then "::" else ", "
                 val sep = createSimple(INTERPUNCT,concat,1,d,repr,SEP_COLOR,
					setGroup)
	     in ( Array.update(getKids(concat),0,elem)
                ; Array.update(getKids(concat),1,sep)
                ; Array.update(na,!rl,concat))
	     end ; rl := !rl + 1)
	   ; na )
	end
                   
(* spezielle Behandlung von Records,Tupeln und Datentypen *)
                         
    (* treatProd *)
    and treatProd (va,t,p,i,d,row) = 
	let
	      val upperConcat = createConcat(createValue(va,t,NO_ACTIONS),
					     p,i,d,Array.array(3,Empty),
					     setGroup)
	      val (lbra,rbra) = if Type.isTupleRow(row) 
				    then ("(",")")
				else ("{","}")
	      val (lbraNode,rbraNode) = (createSimple (INTERPUNCT,upperConcat,
						       0,d,lbra,BRACK_COLOR,
						       setGroup),
					 createSimple (INTERPUNCT,upperConcat,
						       2,d,rbra,BRACK_COLOR,
						       setGroup))
	      val container = createContfromRow (va,t,upperConcat,1,d,row, 
						 UnsafeValue.proj) 
	      val upperKids = getKids(upperConcat)
	  in
	      ( Array.update(upperKids,0,lbraNode)
	       ; Array.update(upperKids,1,container)
	       ; Array.update(upperKids,2,rbraNode)
	       ; upperConcat)
	  end
	
    (* treatSum *)
    and treatSum (va,t,p,i,d,row) = 
        let
	    val lt_list   = row2list(row)
	    val l_vector  = labelvector(lt_list)
	    val index     = UnsafeValue.tag(va,l_vector)
	    val label     = Label.toString(Vector.sub(l_vector,index))
	                    ^" "
	    val typ = #2(List.nth(lt_list,index))
	    val intyp = if Type.isApply(typ) 
                        andalso Type.isCon(#1(Type.asApply(typ))) 
		        andalso Path.equal(Type.asCon(#1(Type.asApply(typ))),
					   PervasiveType.path_strict)
			    then  #2(Type.asApply(typ))
			else typ
	    val emptyrow = case Type.inspect(intyp) of 
		Type.Prod(row') 
		=> Type.isEmptyRow(row') 
	      | _ => false
	    val upperConcat = if emptyrow 
				  then Empty 
		    else createConcat(createValue(va,t,NO_ACTIONS),
				      p,i,d,Array.array(4,Empty),setGroup)
	    val (lbra,rbra) =  let val row' = Type.asProd(intyp)
			       in if Type.isTupleRow(row')
				      then ("(",")")
				   else ("{","}")
			       end
			       handle Type.Type => ("_","_")
	    val (lbraNode,rbraNode) = 
		if lbra = "_" orelse emptyrow
		    then (Empty,Empty) 
		else (createSimple(INTERPUNCT,upperConcat,1,d,lbra,BRACK_COLOR,
				   setGroup),
		      createSimple (INTERPUNCT,upperConcat,3,d,rbra,
				    BRACK_COLOR,setGroup))
	    val container = case Type.inspect(intyp) of 
		Type.Prod(row') 
		=> if Type.isEmptyRow(row') 
		       then Empty
		   else
		       createContfromRow (va, t, upperConcat, 2, d, row', 
					  UnsafeValue.projTagged)
	      | _ => let
			 val inva = UnsafeValue.projTaggedTuple(va,1,0)
			 val node = createGraph (inva,intyp,upperConcat,2,d+1) 
		     in 
			 node 
		     end
	    val labelnode =  createSimple (INTERPUNCT,
					   if container = Empty
					       then p else upperConcat,
					   if container = Empty
					       then i else 0,d,label,
					   LABEL_COLOR,setGroup) 
	    val upperKids = getKids(upperConcat)
	in
	    if container = Empty 
		then labelnode 
	    else (Array.update(upperKids,0,labelnode)
		  ; Array.update(upperKids,1,lbraNode)
		  ; Array.update(upperKids,2,container)
		  ; Array.update(upperKids,3,rbraNode)
		  ; upperConcat) 
	end

    (* createContfromRow *)
    and createContfromRow (va, t, p, i, d, row, proj) = 
	let
	    val lt_list   = row2list(row)
	    val l_vector  = labelvector(lt_list)
	    val wlimit    = List.length(lt_list) > !max_width 
	    val l         = if wlimit then !max_width
			    else List.length(lt_list)
	    val al = if wlimit then !max_width +1 else l
	    val container = createContainer(INTERPUNCT,p,i,d,
					    Array.array(al,Empty),setGroup)
	    val createProdC = if Type.isTupleRow(row)
				  then createProdConcatTuple
			      else createProdConcat
	    val nodes = 
		Array.tabulate(al,
			       (fn i => 
				if wlimit andalso i = !max_width
				    then createLimit (INTERPUNCT,
						      WIDTH_LIMIT,
						      container,
						      i,d,setGroup)
				else createProdC (Label.toString
						  (#1(List.nth(lt_list,i))),
						  proj(va,l_vector,i),
						  #2(List.nth(lt_list,i)),
						  container,i,d,al)) )
	    val _ = copyArray(nodes,getKids(container))
	in
	    container
	end

    (* createProdConcat *)
    and createProdConcat (label,va,t,p,i,d,l) = 
	let 
	    val last = (i = l-1) 
	    val c_length = if last then 3 else 4
	    val concat = createConcat (INTERPUNCT,p,i,d,
				       Array.array(c_length,Empty),setGroup)
	    val l_node = createSimple (INTERPUNCT,concat,0,d,label,
				       LABEL_COLOR,setGroup)
	    val eq_node = createSimple (INTERPUNCT,concat,1,d," = ",
					EQU_COLOR,setGroup)
	    val sep_node = if last 
			       then Empty
			   else createSimple (INTERPUNCT,
					      concat,3,d,", ",
					      SEP_COLOR,setGroup)
	    val node = createGraph (va,t,concat,2,d+1)
	    val concat_kids = getKids(concat)
	in
	    (Array.update(concat_kids,0,l_node)
	     ; Array.update(concat_kids,1,eq_node)
	     ; Array.update(concat_kids,2,node)
	     ; if last then () 
	       else Array.update(concat_kids,3,sep_node)
	     ;concat)
	end
    
    (* createProdConcatTuple *)
    and createProdConcatTuple (label,va,t,p,i,d,l) = 
	let 
	    val last = (i = l-1)
	    val c_length = if last then 1 else 2
	    val concat = if last then Empty
			 else createConcat (INTERPUNCT,p,i,d,
					    Array.array(c_length,Empty),
					    setGroup)
	    val sep_node = if last 
			       then Empty 
			   else createSimple (INTERPUNCT,concat,1,d,", ",
					      SEP_COLOR,setGroup)
	    val node = createGraph (va,t,if last then p else concat,
				    if last then i else 0,d+1)
	    val concat_kids = getKids(concat)
	in
	    if last 
		then node 
	    else 
		(Array.update(concat_kids,0,node)
		 ; Array.update(concat_kids,1,sep_node)
		 ;concat)                                       
	end

(* spezielle Behandlung von Werten, deren Typ ein sog. Pfadtyp ist *) 

    (* newPath *)
    and newPath (v,t,p,i,d,path) =
        (case PathMap.lookup(pathTable, path) of
	   NONE 
	   => if d > !max_depth
		  then createLimit(INTERPUNCT,DEPTH_LIMIT,p,i,d,setGroup)
	      else createSimple(INTERPUNCT,p,i,d,"_",DEFAULT,setGroup)
	 | SOME create 
	   => let val doc = create (!max_width,d,v,t)
	      in  docToNode (doc,p,i,d) 
	      end )

    (* docToNode *)
    and docToNode (doc,p,i,d) =
        (case doc of
         SIMPLE(r) 
	   => let val color = 
	             (case #desc(r) of 
		      INTERPUNCT => (case #rep(r) of ", " => SEP_COLOR
		                                   | " = " => EQU_COLOR
						   | ("{" | "}" | "(" | ")"
                                                          | "#[" | "]" )  
						     => BRACK_COLOR
						   | _ => LABEL_COLOR)
		    | VALUE(rr) 
		      => (case Type.inspect(#typ(rr)) of
			  Type.Con path
			  => (if Path.equal(path,PervasiveType.path_int)
				  then INT_COLOR
			      else
			       if Path.equal(path,PervasiveType.path_real)
				   then REAL_COLOR
			       else 
			        if Path.equal(path,PervasiveType.path_char)
				    then CHAR_COLOR
				else 
				 if Path.equal(path,PervasiveType.path_string)
				     then STR_COLOR
				 else
	                          if Path.equal(path,PervasiveType.path_word) 
				      then WORD_COLOR
				  else 
				   if Path.equal(path,PervasiveType.path_exn)
				       then EXN_COLOR
				   else 
				    if Path.equal(path,PervasiveType.path_ref)
					then REF_COLOR
				    else DEFAULT)
			| _ => DEFAULT) ) 
	      in createSimple (#desc(r),p,i,d,#rep(r),color,setGroup) 
	      end  
        | CONCAT(r) => let val na = Array.array(Vector.length(#kids(r)),
						 Empty)
                            val concat = createConcat(#desc(r),p,i,d,na,
						      setGroup)
                            val rl = ref 0
			in (while !rl <= (Vector.length(#kids(r)) - 1) do
			    (Array.update(na,
					  !rl,
					  docToNode(Vector.sub(#kids(r),
								   !rl),
							concat,!rl,d))
			     ; rl := !rl + 1)
			    ; concat)
			end
         | CONTAINER(r) => let val na = Array.array(Vector.length(#kids(r)),
						    Empty)
                               val container = createContainer(#desc(r),p,i,d,
                                                               na,setGroup)
			       val rl = ref 0
			   in (while !rl <= (Vector.length(#kids(r)) - 1) do
			       (Array.update(na,
					     !rl,
					     docToNode(Vector.sub(#kids(r),
								  !rl),
						       container,!rl,d+1))
				; rl := !rl + 1)
			       ; container)
			   end
         | LIMIT(r) => createLimit(#desc(r),#sort(r),p,i,d,setGroup) 
         | EMBEDDED(v,t) => (createGraph(v,t,p,i,d)) )

(* spezielle Behandlung von Futures *)
   
    (* createFutureNode *)
    and createFutureNode (va,t,p,i,d) = 
	let val desc = createValue(va,t,NO_ACTIONS)
            val fut = UnsafeValue.cast va
	    val simple =  createSimple (desc,p,i,d,"Future",DEFAULT,setGroup)
	in ( case TransientDictionary.iterLookup  
	                   (transdict, 
			    fn (vv,li) 
			    => List.exists(fn n  
					   => UnsafeValue.same  
					   (getValue(getDesc(n)),va))  
			    li 
			    handle General.Match => false) of 
	      SOME ((vv,li),i)   
	      => TransientDictionary.update(transdict,  
					    (i,(vv,List.append(li,[simple])))) 
            | NONE  
	      => (TransientDictionary.insertI(transdict,(va,[simple]))
		  ; Update.watcher(fut,va,createGraph,createGraphInf) ; ())
          ; simple )
	end 	
(*
    and createTransient (va,t,p,i,d,tt) = 
	let val prom = castPromise va
	    val future = Promise.future prom
	    val desc = createValue(va,t,NO_ACTIONS) 
            val indesc = createValue(va,tt,NO_ACTIONS) 
	    val concat = createConcat(desc,p,i,d,Array.array(3,Empty),setGroup)
 	    val first = createSimple(INTERPUNCT,concat,0,d,"promise {|", 
				     DEFAULT,setGroup) 
            val middle =  
		if Future.isDetermined future  
		    then createGraph (va,tt,concat,1,d)  
		else if d <= !max_depth 
			 then createSimple(indesc,concat,1,d,"future", 
					    DEFAULT,setGroup) 
		     else createLimit(indesc,DEPTH_LIMIT,concat,1,d+1, 
				      setGroup) 
            val last = createSimple(INTERPUNCT,concat,2,d,"|}",DEFAULT,
				    setGroup)
	in (Array.update(getKids(concat),0,first) 
	    ; Array.update(getKids(concat),1,middle) 
	    ; Array.update(getKids(concat),2,last) 
	    ; if Future.isDetermined(future)
		  then ()
	      else
	      case TransientDictionary.iterLookup  
	               (transdict, 
			fn (vv,li) 
			=> List.exists(fn n  
				       => UnsafeValue.same  
				       (getValue(getDesc(n)),va))  
			li 
		        handle General.Match => false) of 
	      SOME ((vv,li),i)   
	      => TransientDictionary.update(transdict,  
					 (i,(vv,List.append(li,[concat]))))  
            | NONE  
	      => (TransientDictionary.insertI(transdict,(va,[concat]))
		 ; Update.watcher(future,va,createGraph,createGraphInf) ; () )
	   ; concat)    
	end  
*)
  
(* entsprechende Funktionen zur internen Darstellung von Strukturen und
   Funktoren - analog zu newNode, createGraph und createUsualGraph (s.o.) *)

    (* newNodeInf *)
    and newNodeInf (v,t) = let val va = UnsafeValue.cast v: Reflect.value 
			       val i = MainDictionary. 
				   getHighestIndexAssigned(dict) +1 
			       val _ = RelManDictionary.update(reldict,(i,nil))
			       val _ = Settings.relnumber := 0 
			       val node = createGraphInf (va,t,Empty,i,0) 
			   in (MainDictionary.insertI(dict,(node)) ; node) 
			   end   
 
    (* createGraphInf *)
    and createGraphInf (va,t,p,i,d) = 
	if !(Settings.relmode) 
	    then let val ind = if p = Empty then i else getAncIndex p
		     val relman = case RelManDictionary.lookup(reldict,ind)
			 of SOME x => x
		          | NONE => []
		     val str = "Ref"^Int.toString(!(Settings.relnumber))
		     val f = if !(Settings.tokenmode)
				 then fn x   
				     => if getDesc(x) = INTERPUNCT  
					    then false  
					else UnsafeValue.same
					    (getValue(getDesc(x)),va)   
			     else fn x   
				 => if getDesc(x) = INTERPUNCT  
					then false  
				    else getValue(getDesc(x)) = va 
		 in 
		     (case List.find f relman of   
			  NONE 
			  => let val desc = createIValue(va,t,NO_ACTIONS)   
				 val node = createRelNode (desc,Empty,p,i,d,
							   str^" as ",
							   relman,setGroup)
				 val c = createUsualGraphInf (va,t,node,0,d) 
				 val actrelman = case 
				     RelManDictionary.lookup(reldict,
							     ind)
				     of SOME x => x
				      | NONE => []
			     in ( case c of     
				 Simple(_) => c
			       | Empty => c    
			       | _ => ( setContent (node,c)   
				       ; RelManDictionary.update(reldict,
								 (ind,
		       			        List.append([node],actrelman)))
				       ; node ) )
			     end     
			| SOME n => let val rep = ( case n of 
						   RelNode(rr) => #rep(rr)
						 | _ => "_")
					val str = iterTake rep	
					val m = incrCounter n 
					val node = 
					    createRelRefNode (INTERPUNCT,p,i,d,
							      str,m,setGroup)
					val actrelman = case 
					    RelManDictionary.lookup(reldict,
								    ind)
					    of SOME x => x
					     | NONE => []
					val part = List.partition 
					                    (fn x => x = n)
							    actrelman
					val restlist = #2(part)
				    in (RelManDictionary.update(reldict,
								(ind,
	       					 List.append([m],restlist)))
					; node)
				    end)
		 end
	else createUsualGraphInf (va,t,p,i,d)
	    
    (* createUsualGraphInf *)
    and createUsualGraphInf (va,t,p,i,d) = 
	(case Inf.inspect t of 
	 Inf.Sig(s) => let val ilist = List.rev(Inf.items(s))
		       in treatSig (va,t,p,i,d,ilist)
		       end 
       | Inf.Arrow(path,i1,i2) 
	 => if d > !max_depth
		then createLimit (createIValue(va,t,NO_ACTIONS),DEPTH_LIMIT,
				  p,i,d,setGroup)
	    else createSimple (createIValue(va,t,NO_ACTIONS),p,i,d,"functor",
			       DEFAULT,setGroup)
       | Inf.Exist(path,i1,i2) => createUsualGraphInf (va,i2,p,i,d)
       | Inf.Sing(m) => let val ti = #2(Inf.asMod(m))
			  in createUsualGraphInf (va,ti,p,i,d)
			  end
       | _ => if d > !max_depth
		  then createLimit (createIValue(va,t,NO_ACTIONS),DEPTH_LIMIT,
				    p,i,d,setGroup)  
	      else createSimple (INTERPUNCT,p,i,d,"_",DEFAULT,setGroup) )


    (* treatSig *)
    and treatSig (va,t,p,i,d,ilist) = 
	if d > !max_depth
	    then createLimit (createIValue(va,t,NO_ACTIONS),DEPTH_LIMIT,p,i,d,
			      setGroup)
	else let val a_length = 2 + List.length(ilist)
		 val container = 
	             createContainer(createIValue(va,t,NO_ACTIONS),p,i,d,
				     Array.array(a_length,Empty),setGroup)
		 val s_begin = createSimple(INTERPUNCT,container,0,d,"struct",
					    DEFAULT,setGroup)
		 val s_end = createSimple(INTERPUNCT,container,a_length-1,d,
					  "end",DEFAULT,setGroup)
	     in ( Array.update(getKids(container),0,s_begin) 
		 ; Array.update(getKids(container),a_length-1,s_end) 
                 ; setItems (va,ilist,container,d+1) 
		 ; container ) 
	     end   

    (* setItems *)
    and setItems (va,ilist,p,d) = 
	let val l = ref 1
	in while !l <= List.length(ilist) do
	    (let val node = let val vv = UnsafeValue.cast va
				val item = (List.nth(ilist,!l-1))
				val label = itemToLabel(item)
				val in_vv = UnsafeValue.projPoly(vv,label)
			    in createItemNode(in_vv,item,p,!l,d) 
			    end 
	     in Array.update(getKids(p),!l,node)
	     end
           ; l := !l + 1)
	end

    (* createItemNode *)
    and createItemNode (vv,item,p,i,d) = 
	case Inf.inspectItem item of
	Inf.FixItem(_,_) 
	=> let val fix = #2(Inf.asFixItem(item))
	       val str = case fix of
		         Fixity.NONFIX => "  nonfix" 
	               | Fixity.PREFIX(i) => "  prefix "^Int.toString(i)
		       | Fixity.POSTFIX(i) => "  postfix "^Int.toString(i)
		       | Fixity.INFIX(i,Fixity.LEFT) 
			 => "  infix "^Int.toString(i) 
		       | Fixity.INFIX(i,Fixity.RIGHT) 
			 => "  infixr "^Int.toString(i) 
		       | Fixity.INFIX(i,Fixity.NEITHER) 
			 => "  infixn "^Int.toString(i)
	   in createSimple (INTERPUNCT,p,i,d,str,DEFAULT,setGroup) 
	   end 
      | Inf.ValItem(l,t) 
	=> let val conc = createConcat (INTERPUNCT,p,i,d,Array.array(4,Empty),
					setGroup)
	       val s_val = createSimple (INTERPUNCT,conc,0,d,"  val ",DEFAULT,
					 setGroup)
	       val lab = createSimple (INTERPUNCT,conc,1,d,
				       Label.toString(l),LABEL_COLOR,
				       setGroup)
	       val equ = createSimple (INTERPUNCT,conc,2,d," = ",SEP_COLOR,
				       setGroup)
	       val value =  createGraph (vv,t,conc,3,d)  
	   in ( Array.update(getKids(conc),0,s_val)
	       ; Array.update(getKids(conc),1,lab)
	       ; Array.update(getKids(conc),2,equ)
	       ; Array.update(getKids(conc),3,value)
	       ; Array.update(getKids(p),i,conc)
	       ; conc )
	   end
      | Inf.TypItem(path,_)
	=> let val label = Path.toLab(path)
	       val str = "  type "^Label.toString(label)
	   in createSimple (INTERPUNCT,p,i,d,str,DEFAULT,setGroup)
	   end  (* Tiefe! *)
      | Inf.ModItem(path,inf)
	=> let val conc = createConcat (INTERPUNCT,p,i,d,
					Array.array(4,Empty),setGroup)
	       val s_struct = createSimple (INTERPUNCT,conc,1,d,"  structure ",
					    DEFAULT,setGroup)
	       val name = createSimple (INTERPUNCT,conc,1,d,
					Label.toString(Path.toLab(path)),
					LABEL_COLOR,setGroup)
	       val equ = createSimple (INTERPUNCT,conc,2,d," = ",SEP_COLOR,
				       setGroup)
	       val value =  createGraphInf (vv,inf,conc,3,d) 
	   in ( Array.update(getKids(conc),0,s_struct)
	       ; Array.update(getKids(conc),1,name)
	       ; Array.update(getKids(conc),2,equ)
	       ; Array.update(getKids(conc),3,value)
	       ; Array.update(getKids(p),i,conc)
	       ; conc )
	   end
      | Inf.InfItem(path,_)
	=> let val conc = createConcat (INTERPUNCT,p,i,d,
					Array.array(2,Empty),setGroup)
	       val s_sig = createSimple (INTERPUNCT,conc,0,d,"  signature ",
					 DEFAULT,setGroup)
	       val name = createSimple (INTERPUNCT,conc,1,d,
					Label.toString(Path.toLab(path)),
					LABEL_COLOR,setGroup)
	   in ( Array.update(getKids(conc),0,s_sig)
	       ; Array.update(getKids(conc),1,name)
	       ; Array.update(getKids(p),i,conc)
	       ; conc)
	   end
      | Inf.HiddenItem(item') 
	=> let val conc = createConcat (INTERPUNCT,p,i,d,
					Array.array(2,Empty),setGroup)
	       val ask = createSimple (INTERPUNCT,conc,0,d,"  ? ",
				       DEFAULT,setGroup) 
	       val h_item = createItemNode (vv,item',conc,1,d)
	   in ( Array.update(getKids(conc),0,ask)
	       ; Array.update(getKids(conc),1,h_item)
	       ; Array.update(getKids(p),i,conc)
	       ; conc)
	   end

(* Registrierung der Fkt. zum Reinspizieren von Werten beim WindowManager *)
   
    val _ = !WindowManager.register("reinspect",
				    fn n => Update.reinspect(n,
							     createGraph,
							     createGraphInf)) 
	
end (* struct end *)
 
end (* local end *)
 
