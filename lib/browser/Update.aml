(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Reflect from "x-alice:/lib/system/Reflect"
import structure UnsafeValue from "x-alice:/lib/system/UnsafeValue"
import structure BrowserSupport from "x-alice:/lib/system/BrowserSupport"
import structure Gtk from "x-alice:/lib/gtk/Gtk"
import structure Types from "Types"
import structure Helper from "Helper"
import structure MainDictionary from "MainDictionary"
import structure ReinspectedRelDict from "ReinspectedRelDict"
import structure TransientDictionary from "TransientDictionary"
import structure Dictionaries from "Dictionaries"
import structure Layout from "Layout"
import structure WindowHelper from "WindowHelper"
import structure WindowManager from "WindowManager"
import structure DrawNodes from "DrawNodes"
import structure Server from "Server"
import structure Services from "Services"
import structure Settings from "Settings"
import structure NewNodeHelper from "NewNodeHelper"
import signature UPDATE from "UPDATE-sig"

import structure TextIO from "x-alice:/lib/system/TextIO"

local
    open Types Helper 
in

structure Update :> UPDATE = 
struct
    
    exception UpdateError
     
    (* max *)
    fun max (nil,f) = 0
      | max ([x],f) = f(x)
      | max (x::xr,f) = let val m = Int.max(f(x),f(hd(xr)) )
			in Int.max(m, max(tl(xr),f) )
			end 

    (* updateChild *)
    fun updateChild (p,i,n) = case p of
	Concat(r) => (Array.update(#kids(r),i,n)
		      ; if not(getParent(n) = Empty)
			    then updateChild(#parent(r),getIndex(p),p)
			else () )
      | Container(r) => (Array.update(#kids(r),i,n)
			 ; if not(getParent(n) = Empty)
			       then updateChild(#parent(r),getIndex(p),p)
			   else () )
      | RelNode(r) => (#content(r) := n
		       ; if not(getParent(n) = Empty)
			     then updateChild(#parent(r),getIndex(p),p) 
			 else () )
      | Empty => () 
      | _ => raise UpdateError
	    
    (* setDazzled *)
    fun setDazzled n = 
	case n of
	Simple(r) => ( #status(r) := DAZZLED
		      ; setDazzled(getParent(n)) )
      | Concat(r) => ( #status(r) := DAZZLED
		      ; setDazzled(getParent(n)) )
      | Container(r) => ( #status(r) := DAZZLED
			 ; setDazzled(getParent(n)) )
      | RelNode(r) => ( #status(r) := DAZZLED
 		       ; setDazzled(getParent(n)) )
      | RelRefNode(r) => ( #status(r) := DAZZLED
			  ; setDazzled(getParent(n)) )
      | Limit(r) => ( #status(r) := DAZZLED
		     ; setDazzled(getParent(n)) )
      | Empty => () 
	    
    (* iterMove *)	    
    fun iterMove (dict,dy,i,highest_i)
	= if i > highest_i 
	      then () 
	  else
	      case MainDictionary.lookup(dict,i) of
	      NONE => iterMove(dict,dy,i+1,highest_i)
            | SOME (node,line) 
	      => ( Services.moveGroup(getGroup(node),0,dy)
		 ;  Services.yPosSepLine(line,getGroup(node)) 
		  ; iterMove (dict,dy,i+1,highest_i) )
		  
    (* update *)
    and update (n,va,f,g) = 
	if !(Settings.relmode) andalso isRelNode(getParent(n)) 
	    then ()
	else 
	( setDazzled n 
	 ; let val ind = getAncIndex n 
	       val (anc,ancline) = valOf(MainDictionary.lookup 
			       (Dictionaries.dict,ind)) 
	       val old_ydim = Layout.get_ydim(anc)
	       val (p,index) = getNoRelAnc n	 
	       val va_inf = UnsafeValue.cast va : Reflect.module
	       val new =
		   case getDesc(n) of
		       VALUE(r) => f(va,#typ(r),p,index,
				     getDepth(n))
		     | I_VALUE(r) => g(va_inf,#typ(r),p,index,
				       getDepth(n))
		     | INTERPUNCT => raise UpdateError 
	       val _ = updateChild(p,index,new)
	       val node = if getParent(new) = Empty then new else anc
	       val _ = if isRelRefNode new
			   then findRelNode(node,va)
		       else ()
	       val (_,y_pos) = Services.getPosition(getGroup(anc))
	   in ( Gtk.objectDestroy(getGroup(n))
	       ; if isRelNode new 
		     then let val ri_rel = 
			      case ReinspectedRelDict.lookup
				  (Dictionaries.ri_reldict,ind) 
				   of SOME x => x
				    | NONE => []
			  in ReinspectedRelDict.update(Dictionaries.ri_reldict,
						       (ind,
					           [new]@ri_rel))
			  end 
		 else ()
               ; Layout.layout(node)
	       ; MainDictionary.update(Dictionaries.dict, (ind,(node,ancline)))
	       ; DrawNodes.draw(node,0,y_pos,true) 
	       ; let val dy =  Layout.get_ydim(node) - old_ydim
		 in ( WindowManager.incr_act_line dy
		     ; iterMove (Dictionaries.dict,dy,getIndex(anc) + 1,
				 MainDictionary.getHighestIndexAssigned
				 (Dictionaries.dict))
		     ; Layout.setVisible(Layout.get_xdim(node),dy))
		 end )
	   end )

    (* findRelNode *)
    and findRelNode(anc,va) = 
	let val found = ref false
	    val va_inf = UnsafeValue.cast va : Reflect.module
	    val g = fn n => findRelNode(n,va)
	    val f = fn n => if isRelNode n 
		            andalso ( case getDesc(n) of
				      VALUE(r) => va = #value(r)
				    | I_VALUE(r) => va_inf = #value(r)
				    | _ => raise UpdateError )
				then ( found := true
				      ; setDazzled n)
			    else ()
	in ( case anc of
	     Concat(r) => ( f anc
			  ; if !found then ()
			    else array_map (f,getKids(anc))
			  ; if !found then ()
			    else array_map (g,getKids(anc)) )
	   | Container(r) => ( f anc
			     ; if !found then () 
			   
    else array_map (f,getKids(anc))
			     ; if !found then ()
			       else array_map (g,getKids(anc)) )
	   | RelNode(r) => (f anc
                           ; if !found then ()
			     else g (!(#content(r))) )
	   | _ => () )
	end
        
    (* tell *)
    and tell (va,li,f,g) =  
	let val new_li = List.sort (fn (n,m) => Int.compare(getAncIndex n, 
							    getAncIndex m)) 
	                           li
	in ( List.map (fn n => update(n,va,f,g)) new_li 
	    ; !WindowManager.resize() )
	end   

    (* watcher *)
    and watcher (future,va,f,g) = 
	Thread.thread 
	(fn () 
	 => ( case TransientDictionary.iterLookup 
	               (Dictionaries.transdict, 
			fn (_,l) =>
			List.exists 
			(fn n
			 => UnsafeValue.same(getValue(getDesc(n)),
					     va)) l) of 
	      NONE => () 
	    | SOME((vv,ll),i)  
	      => ( if Future.isLazy  future
		       then BrowserSupport.waitRequest(future)
		   else Future.await(future)
		  ; let val new_l = #2(valOf(TransientDictionary.lookup
					     (Dictionaries.transdict,i)))
		    in Server.serve(fn () => tell(va,new_l,f,g))
		    end ) ))
	
    (* reinspect *)
    and reinspect (n,f,g) = 
        let val va = getValue(getDesc(n))
	in  Server.serve(fn () => (update(n,va,f,g) ; !WindowManager.resize()))
	end
    handle General.Match => raise UpdateError
	
    (* foldDepth *)
    and foldDepth (n,i,f,g) = 
	Server.serve
	(fn () => 
	 let val old_depth = !(Settings.max_depth)
	 in 
	     ( setDazzled n
	      ; let val new_depth = findHighestDepth n + i
		in Settings.set_depth(if new_depth < 0 then 0 else new_depth)
		end
	      ; fold (n,f,g)
	      ; Settings.set_depth(old_depth) )
	 end)

    (* foldWidth *)
    and foldWidth (n,i,f,g) = 
	Server.serve
	(fn () => 
	 let val old_width = !(Settings.max_width)
	 in 
	     ( setDazzled n
	      ; let val new_width = findHighestWidth n + i
		in Settings.set_width(if new_width < 0 then 0 else new_width)
		end
	      ; fold (n,f,g)
	      ; Settings.set_width(old_width) )
	 end )
	
    (* fold *)
    and fold (n,f,g) = 
	let val ind = getAncIndex n 
	    val (anc,ancline) = valOf(MainDictionary.lookup 
					(Dictionaries.dict,ind)) 
	    val old_ydim = Layout.get_ydim(anc) 
	    val va = getValue(getDesc(n))
	    val va_inf = UnsafeValue.cast va : Reflect.module
	    val (p,index) = getNoRelAnc n
	    val new = 
		case getDesc n of 
		    INTERPUNCT => raise Match
		  | VALUE(r) => f (va,#typ(r),p,index,getDepth(n))
		  | I_VALUE(r) => g (va_inf,#typ(r),p,index,getDepth(n))
	    val _ = updateChild(p,index,new)  
	    val node = if getParent(new) = Empty then new else anc
	    val (_,y_pos) = Services.getPosition(getGroup(anc))
	in ( Gtk.objectDestroy(getGroup(n))
	    ; Layout.layout(node)
	    ; MainDictionary.update(Dictionaries.dict, (ind,(node,ancline)))
	    ; DrawNodes.draw(node,0,y_pos,true) 
	    ; let val dy =  Layout.get_ydim(node) - old_ydim
	      in ( WindowManager.incr_act_line dy
		  ; iterMove (Dictionaries.dict,dy,getIndex(anc) + 1,
			      MainDictionary.getHighestIndexAssigned
			      (Dictionaries.dict))
		  ; Layout.setVisible(Layout.get_xdim(node),dy))
	      end 
	    ; !WindowManager.resize() )
	end 

    (* findHighestDepth *)
    and findHighestDepth n = case n of
	Concat(r) => max(Array.toList(#kids(r)),
				fn no => if no = Empty 
					     then findHighestDepth n
					 else findHighestDepth no)
      | Container(r) => max(Array.toList(#kids(r)),
				   fn no => if no = Empty 
						then findHighestDepth n
					    else findHighestDepth no)
      | RelNode(r) => findHighestDepth (!(#content(r)))
      | _ => getDepth n

    (* findHighestWidth *)
    and findHighestWidth n = 
	let val new_i = ref 0 
	in ( findHighestWidth' (n,0,new_i)
	    ; !new_i )
	end 

    and findHighestWidth' (n,i,new_i) = case n of
	Concat(r) => array_map(fn no => findHighestWidth'(no,!new_i,new_i),
				  #kids(r))
      | RelNode(r) => findHighestWidth'(!(#content(r)),i,new_i)
      | Container(r) 
	    => ( let val li = Array.toList(#kids(r))
		     val test_i = List.length(li) - 
			 (if isLimit(List.last(li)) then 1 else 0)
		     val first = List.nth(li,0)
		 in if isSimple first
		     andalso String.equal("struct",getRep first)
			then ()
		    else new_i := Int.max(i,test_i)
		 end  
		; array_map(fn no => findHighestWidth'(no,!new_i,new_i),
			    #kids(r)) )
	  | _ => ()
   
end (* struct *)

end

