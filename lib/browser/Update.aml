(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Type from "x-alice:/lib/rtt/Type"
import structure Reflect from "x-alice:/lib/system/Reflect"
import structure UnsafeValue from "x-alice:/lib/system/UnsafeValue"

import structure Doc from "Doc"
import structure Node from "Node"
import structure GtkSupport from "GtkSupport"

import structure Settings from "Settings"
import structure Dictionaries from "Dictionaries"
import structure Layout from "Layout"
import structure Draw from "Draw"
import structure Server from "Server"

import signature UPDATE from "UPDATE-sig"

local
    open Doc Node
in

structure Update :> UPDATE = 
struct
    
    exception UpdateError
      
    (* operations that make use of the funcionality of Widget - 
       are being filled at start of the inspector *) 

    val incrActLine = ref (fn _ => ())
    val resize = ref (fn () => ()) 

    (* flag for stop button *)

    val stopflag = ref false; 

    (* width of the widest tree *)

    val screen_max_x = ref 0

    (*******************)
	
    (* some auxiliary functions *)

    fun max (xs,f) = foldl(fn (x,e) => Int.max(f(x),e)) 0 xs

    fun calcMaxXDim (dict,i)  = 
       if i > Dictionaries.Main.getHighestIndexAssigned(dict) 
	   then 0
       else 
	   case Dictionaries.Main.lookup(dict,i) of
	       NONE => calcMaxXDim(dict,i+1)
	     | SOME (node,_) => Int.max(get_xdim(node),
					calcMaxXDim(dict,i+1)) 


    fun  findRelNode(anc,va) = 
	let val found = ref false
	    val va_inf = UnsafeValue.cast va : Reflect.module
	    val g = fn n => findRelNode(n,va)
	    val f = fn n 
		    => if isRelNode n 
		       andalso ( case getDesc(n) of
				VALUE(r) => va = #value(r)
			      | I_VALUE(r) => va_inf = #value(r)
			      | _ => false) 
			   then ( found := true
				 ; setDazzled n)
		       else ()
	in ( case anc of
	    Concat(r) => ( f anc
			  ; if !found then ()
			    else Array.app f (getKids(anc))
			  ; if !found then ()
			    else Array.app g (getKids(anc)) )
	  | Container(r) => ( f anc
			     ; if !found then () 
			       else Array.app f (getKids(anc))
			     ; if !found then ()
			       else Array.app g (getKids(anc)) )
	  | RelNode(r) => (f anc
                           ; if !found then ()
			     else g (!(#content(r))) )
	  | _ => () )
	end

    (* finds highest depth in a (part of a) tree *)

   fun findHighestDepth n = 
       case n of
       Concat(r) => max(Array.toList(#kids(r)),
			fn no => if no = Empty orelse isDepthLimit no 
				     then getDepth n
				 else findHighestDepth no)
     | Container(r) => max(Array.toList(#kids(r)),
			   fn no => if no = Empty orelse isDepthLimit no
					then getDepth n
				    else findHighestDepth no)
     | RelNode(r) => findHighestDepth (!(#content(r)))
     | node => if isDepthLimit node then getDepth(getParent(node))
	       else getDepth node

   (* finds highest width in a (part of a) tree *)

    fun  findHighestWidth n = if (!(Settings.relmode) 
				  andalso isListType(getTyp(getDesc(n))) 
				  handle Match => false)
				  then Int.max(findHighestListWidth (n,0))
			      else findHighestWidth'(n,0)

    and findHighestWidth' (n,a) = 
	case n of
	Concat(r) => Array.foldl (fn(n,e) => Int.max(findHighestWidth'(n,a),e))
 	                          a (getKids(n))
      | RelNode(r) =>  findHighestWidth(getContent(n))
      | Container(r) 
	=> Int.max (Array.foldl 
			  (fn (n,(elem_e,count)) 
			   => if (isSimple n andalso  
				  (String.equal("struct",getRep n) 
				   orelse String.equal("end",getRep n) ) ) 
			   orelse isLimit n  
				  then (elem_e,count) 
			      else (Int.max(findHighestWidth'(n,a),elem_e),
				    count+1))
			  (a,0) 
			  (getKids(n))) 
      | _ => a

    and findHighestListWidth (no,a) = 
	let val n = if isRelNode no 
			then getContent no
		    else no
	in if not(isContainer(n))
	       then (a,0)
	   else let val head = Array.sub(getKids(Array.sub(getKids(n),0)),0)
		    val tail' = Array.sub(getKids(n),1)
		    val tail = if isRelNode tail' 
				   then getContent(tail') 
			       else tail'
		    val (tailmax,count) = findHighestListWidth (tail,a)
		in (Int.max(findHighestWidth head,tailmax),count +1)
		end		 
	end 
		   
    (*******************)

    (* ajustment of the width of the window *)   
    
    fun setVisible x = 
	if x > !screen_max_x 
	    then screen_max_x := x
	else screen_max_x := calcMaxXDim (Dictionaries.maindict,0)

    (* displacement of all "successor" trees after every update *)

    fun iterMove(dy,i) =
	if i > Dictionaries.Main.getHighestIndexAssigned(Dictionaries.maindict)
	    then ()
	else ( case Dictionaries.Main.lookup(Dictionaries.maindict,i) of
	            NONE => ()
                  | SOME (node,line) 
			=> ( GtkSupport.moveGroup(getGroup(node),0,dy,
						  Settings.getFontHeight(),
						  Settings.getFontWidth())
			   ; GtkSupport.yPosSepLine(line,getGroup(node),
						    Settings.getFontHeight()) )
             ; iterMove(dy,i+1) )

    (***************************************************)

    (* adjusts layout and representation for an updated node tree *)

    fun layoutDrawTree(topnode,canvas,old_ydim,y_pos) = 
	( Layout.layout(topnode) 
	 ; Draw.draw(topnode,0,y_pos,true) 
	 ;let 
	      val dy = get_ydim(topnode) - old_ydim
	  in
	      ( (!incrActLine) dy
	       ; iterMove (dy,getIndex(topnode) + 1))
	  end
	 ; setVisible(get_xdim(topnode)))


    (* main part of update - 
       is essential for reinspect, foldDepth, foldWith and watcher *)

    fun updateTree (no',va',f,g,canvas) = 
	let 
	    val val_anc = getValueAnc(no')
	    val val_anc_va =getReflectValue val_anc 
	    val (no,va) =  (if isListType(getTyp(getDesc(no')))
			   andalso 
			   isListType(getTyp(getDesc(val_anc)))
			   then (val_anc,val_anc_va)
			       else (no',va'))
		handle _ => (no',va')
	    val  n = if !(Settings.relmode) 
	             andalso isRelNode(getParent(no))
			 then getParent(no) 
		     else no
	    val ind = getAncIndex n 
	    val (anc,ancline) = valOf(Dictionaries.Main.lookup
				      (Dictionaries.maindict,ind)) 
	    val old_ydim = get_ydim(anc)
	    val (p,index) = if !(Settings.relmode) 
				then (getParent(n),getIndex(n)) 
			    else getNoRelAnc n
	    val old_settings = (!Settings.max_width,!Settings.max_depth)
	    val new = ( if !(Settings.relmode) (* RELATIONSMODUS *)
			    then ( Dictionaries.RelMan.delete
				  (Dictionaries.reldict,ind)
				  ; relnumber := 0 )
			else ()  
		       ; GtkSupport.stopButtonSetActive(true) 
		       ; case getDesc(n) of
			 VALUE(r) => f(NONE,va,#typ(r),p,index,
				       getDepth(n),canvas)
		       | I_VALUE(r) => let val va_inf =   
			                   UnsafeValue.cast va : Reflect.module
				       in g(va_inf,#typ(r),p,index,
					    getDepth(n),canvas)
				       end 
		       | INTERPUNCT => raise UpdateError )
	       val _ = ( GtkSupport.stopButtonSetActive(false)
			; if !stopflag 
			      then (Settings.set_width (#1(old_settings))
				    ; Settings.set_depth (#2(old_settings))
				    ; stopflag := false)
			  else () 
			; updateChild(p,index,new) )
	       val node = if getParent(new) = Empty then new else anc
	       val _ = if isRelRefNode new
			   then findRelNode(node,va)
		       else ()
	       val y_pos = #2(GtkSupport.getPosition(getGroup(anc),
						     Settings.getFontHeight(),
						     Settings.getFontWidth()))
	in ( Dictionaries.Main.update(Dictionaries.maindict,
				       (ind,(node,ancline)))
	    ; setDazzled n
	    ; GtkSupport.objectDestroy(getGroup(n))
	    ; (node,old_ydim,y_pos))
	end  
	

    (* core function - 
       is essential for reinspect, foldDepth, foldWith and watcher *)

    fun update(no,va,f,g,canvas) = 
	let
	    val (topnode,old_ydim,y_pos) = 
		(GtkSupport.stopButtonSetActive(true)
		 ;GtkSupport.layoutFreeze(canvas)
	         ;updateTree (no,va,f,g,canvas))
	in
	    (layoutDrawTree(topnode,canvas,old_ydim,y_pos) 
	     ;GtkSupport.stopButtonSetActive(false)
	     ;GtkSupport.layoutThaw(canvas))
	end
			       
    (*  mechanism of update watching for FUTURES *)    

    fun tell (va,i,li,f,g,canvas) =  
	let
	    fun updateRest (ind,nil) = nil
	      | updateRest(ind,x::xs) = if getAncIndex(x) = ind 
					    then  (updateTree(x,va,f,g,canvas)
						   ;updateRest(ind,xs))
					else x::xs
	    fun updateCycle nil    = ()
	      | updateCycle(x::xs) = 
		let 
		    val (topnode,old_ydim,y_pos)= 
			updateTree (x,va,f,g,canvas)
		    val restlist = updateRest(getAncIndex(x),xs)
		in
		    (layoutDrawTree(topnode,canvas,old_ydim,y_pos)
		     ;updateCycle(restlist))
		end
	    val _ = GtkSupport.stopButtonSetActive(true)
	    val new_li = List.sort (fn (n,m) => Int.compare(getAncIndex n, 
							    getAncIndex m)) 
		li
	in
	    (GtkSupport.layoutFreeze(canvas)
	     ; updateCycle new_li
	     ;(!resize)() 
	     ; GtkSupport.stopButtonSetActive(false)
	     ; GtkSupport.layoutThaw(canvas)
	     ; Dictionaries.Transient.delete(Dictionaries.transdict,i) )
	end

    (* UnsafeValue.awaitRequest is broken *)
    local
	val delay = Time.fromMilliseconds (LargeInt.fromInt 10)
    in
	fun futurePoll future =
	    if Future.isLazy future then
		(Future.alarm delay; futurePoll future)
	    else Future.await future
    end

    fun watcher (future,va,i,f,g,canvas) = 
	Thread.thread 
	(fn () 
	 =>  ( futurePoll future
	     ; let val new_l = #3(valOf(Dictionaries.Transient.lookup
					(Dictionaries.transdict,i)))
	       in Server.serve(fn () => tell(va,i,new_l,f,g,canvas))
	       end ) )

    (* REINSPECT *)

    fun  reinspect (n,f,g,canvas) = 
        let val va = getReflectValue n
	in  Server.serve(fn () => 
			 ( update(n,va,f,g,canvas) 
			  ; (!resize)() ))
	end
        handle General.Match  => raise UpdateError 
	
    (* folding of DEPTH *) 

    fun foldDepth (n,i,f,g,canvas) = 
	Server.serve
	(fn () => 
	 let
	     val old_depth = !(Settings.max_depth)
	 in 
	     ( setDazzled n
	      ; let val new_depth = findHighestDepth n + i 
		    val va = getReflectValue n
		in ( Settings.set_depth(if new_depth < 0 then 0 else new_depth)
		    ; update (n,va,f,g,canvas)
		    ; (!resize)()  )
		end 
	      ; Settings.set_depth(old_depth) )
	 end)

    (* folding of WIDTH *) 

    fun foldWidth (n,i,f,g,canvas) =
        Server.serve
	(fn () =>
         ( let val new_n = if not(getDesc(n) = INTERPUNCT) 
			       then n
			   else let val cp = getParent(n)
				in case getDesc(cp) of 
				    INTERPUNCT => getValueAnc(cp)
				  | _ => cp
				end	
	       val old_width = !(Settings.max_width)
	   in 
	       ( setDazzled new_n
		; let val new_width = findHighestWidth new_n + i  
		      val va = getReflectValue new_n
		  in ( Settings.set_width(if new_width < 0 then 0 
					  else new_width)
		      ; update (new_n,va,f,g,canvas)
		      ; (!resize)() )
		  end
		; Settings.set_width(old_width) )
	   end ))

end 

end

