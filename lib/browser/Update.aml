(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Reflect from "x-alice:/lib/system/Reflect";
import structure UnsafeValue from "x-alice:/lib/system/UnsafeValue";
import structure Gtk from "x-alice:/lib/gtk/Gtk"
import structure Types from "Types"
import structure Helper from "Helper"
import structure MainDictionary from "MainDictionary"
import structure TransientDictionary from "TransientDictionary"
import structure Dictionaries from "Dictionaries"
import structure Layout from "Layout"
import structure WindowHelper from "WindowHelper"
import structure WindowManager from "WindowManager"
import structure DrawNodes from "DrawNodes"
import structure Server from "Server"
import structure Services from "Services"
import structure Settings from "Settings"
import signature UPDATE from "UPDATE-sig"

import structure TextIO from "x-alice:/lib/system/TextIO"
import structure Inspector from "x-alice:/lib/tools/Inspector"

local
    open Types Helper 
in

structure Update :> UPDATE = 
struct
    
    exception UpdateError
     
    val minCounter = ref (MainDictionary.getHighestIndexAssigned
			  (Dictionaries.dict))
	
    (* updateChild *)
    fun updateChild (p,i,n) = case p of
	Concat(r) => (Array.update(#kids(r),i,n)
		      ; if not(getParent(n) = Empty)
			    then updateChild(#parent(r),getIndex(p),p)
			else () )
      | Container(r) => (Array.update(#kids(r),i,n)
			 ; if not(getParent(n) = Empty)
			       then updateChild(#parent(r),getIndex(p),p)
			   else () )
      | RelNode(r) => (#content(r) := n
		       ; if not(getParent(n) = Empty)
			     then updateChild(#parent(r),getIndex(p),p) 
			 else () )
      | Empty => () 
      | _ => raise UpdateError
	    
    (* setDazzled *)
    fun setDazzled n = case n of
	Simple(r) => ( #status(r) := DAZZLED
		      ; setDazzled(getParent(n)) )
      | Concat(r) => ( #status(r) := DAZZLED
		      ; setDazzled(getParent(n)) )
      | Container(r) => ( #status(r) := DAZZLED
			 ; setDazzled(getParent(n)) )
      | RelNode(r) => ( #status(r) := DAZZLED
		       ; setDazzled(getParent(n)) )
      | RelRefNode(r) => ( #status(r) := DAZZLED
			  ; setDazzled(getParent(n)) )
      | Limit(r) => ( #status(r) := DAZZLED
		     ; setDazzled(getParent(n)) )
      | Empty => ()
	    
    (* iterMove *)	    
    fun iterMove (dict,dy,i,highest_i)
	= if i > highest_i 
	      then () 
	  else
	      case MainDictionary.lookup(dict,i) of
	      NONE => iterMove(dict,dy,i+1,highest_i)
            | SOME node 
	      => ( Services.moveGroup(getGroup(node),0,dy,!Settings.font)
                 ; iterMove (dict,dy,i+1,highest_i) )
	
    (* update *)
    and update (n,va,f) = 
	( setDazzled n 
	 ; let val ind = getAncIndex n 
	       val anc = valOf(MainDictionary.lookup 
			       (Dictionaries.dict,ind)) 
	       val li = MainDictionary.dict2list(Dictionaries.dict,ind-1)
	       (*val y_pos = Layout.sum_up(li,fn n 
					 => if n = Empty then 0
					    else Layout.get_ydim(n)+1)*)
	       val old_ydim = Layout.get_ydim(anc)
	       val t = getTyp(getDesc(n)) 
		   handle General.Match => raise UpdateError
	       val new = f(va,t,getParent(n),getIndex(n),getDepth(n))
	       val _ = updateChild(getParent(n),getIndex(n),new)
              (*  val _ = TextIO.print("UPDATE: updateChild gemacht\n") *)
	       val node = if getParent(new) = Empty then new else anc 
	       val (x_pos,y_pos) = Services.getPosition(getGroup(node),
							!Settings.font)
              (* val _ = TextIO.print("UPDATE: node zugewiesen\n") *)
	   in ( Gtk.objectDestroy(getGroup(n)) 
              (* ; TextIO.print("UPDATE: alte Gruppe zerstoert\n") *)
	       ; Layout.layout(node)
               ; TextIO.print ("UPDATE: beginne zu zeichnen...\n")
	       ; MainDictionary.update(Dictionaries.dict, (ind,node)) 
               ; DrawNodes.draw(node,x_pos,y_pos,DrawNodes.DRAW) 
	       ; let val dy =  Layout.get_ydim(node) - old_ydim
		 in ( WindowManager.incr_act_line dy
		     ; iterMove (Dictionaries.dict,dy,getIndex(node) + 1,
				 MainDictionary.getHighestIndexAssigned
				 (Dictionaries.dict))
		    (* ; TextIO.print("UPDATE: iterMove beendet !! \n") *)
		     ; Layout.setVisible(Layout.get_xdim(node),dy)
		     ; !WindowManager.resize() )
		 end)
	   end )
	
    (* tell *)
    and tell (va,li,f) =  
	let val new_li = List.sort (fn (n,m) => Int.compare(getAncIndex n, 
							    getAncIndex m)) 
	                           li
	in (List.map (fn n => update(n,va,f)) new_li ; ())
	end   

       (* watcher *)
	and watcher (future,va,f) = 
	    Thread.thread 
	    (fn () 
	     => ( case TransientDictionary.iterLookup 
		                (Dictionaries.transdict, 
				 fn (_,l) =>
				 List.exists 
				 (fn n
				  => UnsafeValue.same(getValue(getDesc(n)),
						      va)) l) of 
		  NONE => () 
		| SOME((vv,ll),i)  
		  => ( Future.await(future)
		     ; let val new_l = #2(valOf(TransientDictionary.lookup
						(Dictionaries.transdict,i)))
		       in Server.serve(fn () => tell(va,new_l,f))
		       end ) ))

    (* reinspect *)
    and reinspect (n,f) = 
       (Thread.thread
	(fn () =>
        (let val va = getValue(getDesc(n))
	 in Server.serve(fn () => update(n,va,f))
	 end
	; TextIO.print ("REINSPECT: angeklickter Knoten hat Tiefe "
			^Int.toString(getDepth(n))
			^" und Tiefenlimit ist "
			^Int.toString(!(Settings.max_depth))
			^" !!!\n") )
	     handle General.Match => raise UpdateError )
      ; () )
 	    
end

end

