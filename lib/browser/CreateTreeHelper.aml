(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Inf from "x-alice:/lib/rtt/Inf"
import structure Type from "x-alice:/lib/rtt/Type"
import structure PervasiveType from "x-alice:/lib/rtt/PervasiveType"
import structure Label from "x-alice:/lib/rtt/Label"
import structure Path from "x-alice:/lib/rtt/Path"
import structure Reflect from "x-alice:/lib/system/Reflect"
import structure UnsafeValue from "x-alice:/lib/system/UnsafeValue"

import structure Node from "Node"
import structure Settings from "Settings"

import signature CREATE_TREE_HELPER from "CREATE_TREE_HELPER-sig"

local 
    open Node Settings
in

structure CreateTreeHelper :> CREATE_TREE_HELPER = 
struct

    datatype 'a list_desc = Det of 'a list * bool (* ohne Future *)
                          | Indet of 'a list * 'a list (* mit Future *)

   (* Bestimmung und Zerlegung von "Apply"-Typen *)   

    fun isApply t = case t of Type.Apply(_,_) => true
                           | _ => false 

    fun unApply'(Type.Apply(t1,t2),li) = unApply'(Type.inspect(t1), t2::li)
      | unApply'(sth,li) = (sth, rev li)

    fun unApply sth = unApply' (sth,nil)

    fun isAtomType t = Type.isCon t andalso
	               (let val path = Type.asCon t
			in 
			   Path.equal(path,PervasiveType.path_int) orelse
			   Path.equal(path,PervasiveType.path_word) orelse
                           Path.equal(path,PervasiveType.path_real) orelse
                           Path.equal(path,PervasiveType.path_char) orelse
                           Path.equal(path,PervasiveType.path_string) orelse
			   Path.equal(path,PervasiveType.path_exn)
		       end)
			    
    (* itemToLabel *)

    fun itemToLabel i = case Inf.inspectItem i of
	Inf.FixItem(l,_) => l
      | Inf.ValItem(l,_) => l
      | Inf.TypItem(path,_) => let val str = Label.toString(Path.toLab(path))
				in Label.fromString("$"^str)
				end
      | Inf.ModItem(path,_) => let val str = Label.toString(Path.toLab(path))
			       in Label.fromString(str^"$")
			       end
      | Inf.InfItem(path,_) => let val str = Label.toString(Path.toLab(path))
			       in Label.fromString("$"^str^"$")
			       end   
      | Inf.HiddenItem(i) => itemToLabel i

    (* zur Behandlung von Listen *)
    fun inspectList(n,x) = inspectList'(n,x,[])
	
    and inspectList'(n,x,xs) =
	if not(Future.isDetermined x) 
	    then Indet(List.rev xs, x) 
	else
	    if List.null x 
		then Det(List.rev xs, false) 
	    else
		if n = 0 
		    then Det(List.rev xs, true) 
		else inspectList'(n-1, List.tl x, List.hd x :: xs)
		    
    fun castList value = UnsafeValue.cast value : 'a list    

(* Rows *)

    fun row2list row = case Type.inspectRow(row) of 
	Type.EmptyRow => nil
      | Type.UnknownRow => nil
      | Type.FieldRow(lab,t,row2) => 
	    (lab,t)::row2list(row2)

    fun labelvector (ll:(Label.lab * Type.typ) list) = 
	Vector.tabulate ((List.length(ll)), 
			 (fn i =>(#1( List.nth(ll,i))) ) )  

    (* Operationen auf Arrays *)

    fun copyArray' (a, b, i) = if i = Array.length(a) 
				   then ()
				       else
	                       (Array.update(b,i,Array.sub(a,i))
				; copyArray' (a,b,i+1))
    
    fun copyArray (a,b) = if Array.length(a) > Array.length(b) 
			      then raise Match 
				  else copyArray'(a,b,0)

    (* berechnet f(0,x_{0}), f(1,x_{1}), ......, f(br,x_{br}) *)
    (* wird benutzt von setItems *)

    fun appi_break' (f,br,l,i) = if i <=br
				     then (f (i,hd(l))
					   ;appi_break' (f,br,tl(l),i+1))
				 else ()
				     
    fun appi_break (f,br,l) = appi_break'(f,br,l,0)    

end (* struct *)

end
    
