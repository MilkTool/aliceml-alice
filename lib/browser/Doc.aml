(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Inf from "x-alice:/lib/rtt/Inf"
import structure Label from "x-alice:/lib/rtt/Label"
import structure Name from "x-alice:/lib/rtt/Name"
import structure PathMap from "x-alice:/lib/rtt/PathMap"
import structure Type from "x-alice:/lib/rtt/Type"

import structure Component from "x-alice:/lib/system/Component"
import structure ComponentManager from "x-alice:/lib/system/ComponentManager"
import structure Reflect from "x-alice:/lib/system/Reflect" 
import structure UnsafeValue from "x-alice:/lib/system/UnsafeValue"
import structure Url from "x-alice:/lib/system/Url" 

import structure Settings from "Settings" 

import signature DOC from "DOC-sig"

structure Doc :> DOC =
struct

    datatype limit = DEPTH_LIMIT | WIDTH_LIMIT

    datatype color_class = INT_COLOR 
                         | REAL_COLOR
                         | CHAR_COLOR
                         | STR_COLOR
                         | WORD_COLOR
                         | EXN_COLOR
                         | REF_COLOR
                         | LABEL_COLOR
                         | SEP_COLOR
                         | EQU_COLOR
                         | LIMIT_COLOR
                         | BRACK_COLOR
                         | REL_COLOR
                         | DEFAULT

    (* datatype for storage of value and type information in nodes *)
	
    datatype desc = 
	INTERPUNCT
      | VALUE of {value : Reflect.value,
		  typ : Type.typ}
      | I_VALUE of {value : Reflect.module,
		    typ : Inf.t} 

    (* datatype representing the hierarchy of a datastructure 
       without being specific *)
    
    datatype doc = 
	
	SIMPLE of {desc : desc, 
		   rep : string, 
		   color : color_class }
	
      | CONCAT of {desc : desc, 
		   kids : doc vector }
	
      | CONTAINER of {desc : desc, 
		      kids : doc vector }
	
      | LIMIT of {desc : desc, 
		  sort : limit }
	
      | EMBEDDED of Reflect.value * Type.t 
	
      | EMBEDDED_INF of Reflect.module * Inf.t  


    (* functiontype for functions creating instances of doc *)
	
    type doc_creator = int * int * Reflect.value * Type.t -> doc  

    (***************************************)

    (***** storage (& registration) for doc creator functions *****)
		
    (* map storing doc creator functions *)
	
    val pathTable = PathMap.new() 

    (* identification of the path of promises and packages *)

    val coreSign = Inf.asSig(Option.valOf 
	     (Component.inf(ComponentManager.link 
	       (Url.fromString "x-alice:/lib/fundamental/Core")))) 

    val packageSign = Inf.asSig(Option.valOf 
		(Component.inf(ComponentManager.link 
		  (Url.fromString "x-alice:/lib/fundamental/Package")))) 

    (* returns the path (used for promises and packages) *)

     fun lookupPath(sign, modLab, typLab) =
	 let val sign' = Inf.asSig(Inf.lookupMod(sign, 
						 Label.fromString modLab))
	     val typ   = Inf.lookupTyp'(sign', Label.fromString typLab)
	     val typ'  = if Type.isApply typ 
			     then #1(Type.asApply typ) 
			 else typ
	 in Type.asCon typ'
	 end

     (***************************************)
	
    (* registration function for pathTable *)
	
    fun registerType (path, f) = PathMap.insert (pathTable, path, f) 


    (* operations on desc *)

    fun createValue(va,t) = VALUE{value = va,
				  typ = t}
	
    fun createIValue(va,t) = I_VALUE{value = va,
				     typ = t}
	
    fun getValue desc = case desc of VALUE(r) => #value(r)
                                   | _ => raise Match
	
    fun getInfValue desc = case desc of I_VALUE(r) => #value(r)
	                              | _ => raise Match

    fun getTyp desc = case desc of VALUE(r) => #typ(r)
                                 | _ => raise Match

    fun getInf desc = case desc of I_VALUE(r) => #typ(r)
                                 | _ => raise Match  
 

    (* auxiliaries for casting values *)

    fun castVector value = UnsafeValue.cast value : 'a vector
	
    fun castArray value = UnsafeValue.cast value : 'a array  


    (** doc-creator functions **)

    (* creates doc from int *)

    fun createInt (m_width,d,va,t) = 
	let val descr = createValue(va,t)
	in 
	    SIMPLE{desc = descr,
		  rep = Int.toString(UnsafeValue.cast va : int), 
		  color = INT_COLOR}
	end
    

    (* creates doc from string *)

    fun createString (m_width,d,va,t) = 
	let val descr = createValue(va,t)
	in 
	    SIMPLE{desc = descr,
		   rep = String.concat["\"",
				       UnsafeValue.cast va : string,
				       "\""],
				       color = STR_COLOR}
	end
					   
					       
    (* creates doc from character *)

    fun createChar (m_width,d,va,t) = 
	    let 
		val descr = createValue(va,t)
	    in 
	       SIMPLE{desc = descr,
		      rep = String.concat["#\"", 
					  Char.toString
					  (UnsafeValue.cast va : char),
					  "\""],
					  color = CHAR_COLOR}
	    end
					 

    (* creates doc from word *)

    fun createWord (m_width,d,va,t) = 
      let 
	  val descr = createValue(va,t)
	  val int_w = Word.toInt(UnsafeValue.cast va : word)
      in 
	  SIMPLE{desc = descr,
		 rep = String.concat["0w",
				     Int.toString(int_w)],
		 color = WORD_COLOR}
      end	  

					    
    (* creates doc from real *)

    fun createReal (m_width,d,va,t) = 
        let 
	    val descr = createValue(va,t)
	in 
	    SIMPLE{desc = descr,
		   rep = Real.toString(UnsafeValue.cast va : real),  
		   color = REAL_COLOR}
	end    


    (* creates doc from exn *)

    fun createExn (m_width,d,va,t) =
        let 
	    val descr = createValue(va,t)
	    val conname = UnsafeValue.conName(va)
	    val str = case conname of Name.ExId(n) => n 
	                            | Name.InId => ""
	in 
	    SIMPLE {desc = descr,
		    rep = String.concat["<exception> : ",
					str],
		    color = EXN_COLOR}
	end     
    

    (* creates doc from ref *)
    
    fun createRef (m_width,d,va,t) =
        let 
	    val descr = createValue(va,t)
	    val deref = !(UnsafeValue.cast(va))
	    val ref_value = UnsafeValue.cast deref : Reflect.value
	    val ref_typ = #2(Type.asApply t)
	    val conc1 = SIMPLE{desc = INTERPUNCT,
			       rep = "ref ",
			       color = REF_COLOR}
	    val conc2 = EMBEDDED(ref_value,ref_typ) 
	in 
            CONCAT{desc = descr,
		   kids = #[conc1,conc2]}
	end 
    
    
    (* creates doc tree from vector *)

    fun createVector (m_width,d,va,t) = 
	let 
	    val descr = createValue(va,t)
	    val vec = castVector va
	    val l = Vector.length(vec) 
	    val vec_typ = #2(Type.asApply t)
	    val cont_kids = 
		Vector.tabulate
		(if l > m_width then m_width + 1 else l,
		     fn i => 
		     if i = m_width
			 then LIMIT{desc = INTERPUNCT,
				    sort = WIDTH_LIMIT}
		     else if i = l - 1
			      then EMBEDDED
				  (Vector.sub(vec,i),
				   vec_typ)
			  else CONCAT{desc = INTERPUNCT,
				      kids = 
				      #[EMBEDDED
					(Vector.sub(vec,i),vec_typ),
					SIMPLE{desc = INTERPUNCT,
					       rep = ", ",
					       color = SEP_COLOR}]} )
	    val cont = CONTAINER{desc = INTERPUNCT,
				 kids = cont_kids}
	in 
	    CONCAT{desc = descr,
		   kids = #[SIMPLE{desc = INTERPUNCT,
				   rep = "#[",
				   color = BRACK_COLOR},
			    cont,
			    SIMPLE{desc = INTERPUNCT,
				   rep = "]",
				   color = BRACK_COLOR}] }
	end
                                      
         
    (* creates doc tree from array *)

    fun createArray (m_width,d,va,t) = 
        let 
	    val descr = createValue(va,t)
	    val arr = castArray va
	    val l = Array.length(arr) 
	    val arr_typ = #2(Type.asApply t)
	    val cont_kids = 
		Vector.tabulate
		(if l > m_width then m_width + 1 else l,
		     fn i => 
		     if i = m_width
			 then LIMIT{desc = INTERPUNCT,
				    sort = WIDTH_LIMIT}
		     else if i = l - 1
			      then (* without separator *)
				  CONCAT{desc = INTERPUNCT, 
					 kids = 
					 #[SIMPLE{desc = INTERPUNCT,
						  rep = Int.toString(i),
						  color = LABEL_COLOR},
					       SIMPLE{desc = INTERPUNCT,
						      rep = " = ",
						      color = EQU_COLOR},
					       EMBEDDED(Array.sub(arr,i),
							arr_typ)] }
			  else (* with separator *)
			      CONCAT{desc = INTERPUNCT,
				     kids = 
				     #[SIMPLE{desc = INTERPUNCT,
					      rep = Int.toString(i),
					      color = LABEL_COLOR},
				       SIMPLE{desc = INTERPUNCT,
					      rep = " = ",
					      color = EQU_COLOR},
				       EMBEDDED
				       (Array.sub(arr,i),arr_typ),
				       SIMPLE{desc = INTERPUNCT,
					      rep = ", ",
					      color = SEP_COLOR}]} )
	    val cont = CONTAINER{desc = INTERPUNCT,
				 kids = cont_kids}
	in 
	    CONCAT{desc = descr,
		   kids = #[SIMPLE{desc = INTERPUNCT,
				   rep = "<array> : {",
				   color = BRACK_COLOR},
			    cont,
			    SIMPLE{desc = INTERPUNCT,
				   rep = "}",
				   color = BRACK_COLOR}] }
	end 


    (* creates doc tree from promise *)

    and createPromise (m_width,d,va,t) = 
	let 
	    val descr = createValue(va,t)
	    val prom = UnsafeValue.cast va
	    val fut = Promise.future prom 
	    val inva = UnsafeValue.cast fut : Reflect.value
	    val inty = #2(Type.asApply(t))
	in 
	    CONCAT{desc = INTERPUNCT, 
		   kids = 
		   #[SIMPLE{desc = INTERPUNCT,
			    rep = "Promise{|",
			    color = DEFAULT},
		     EMBEDDED(inva,inty),
		     SIMPLE{desc = INTERPUNCT,
			    rep = "|}",
			    color = DEFAULT}]}
	end 


    (* auxiliary function to create a doc tree representing a package *)

    fun handlePackages (d,va,t,inner_doc) = 
	let 
	    val descr = createValue(va,t)
	in 
	    CONCAT{desc = descr, 
		   kids = 
		   #[SIMPLE{desc = INTERPUNCT,
			    rep = "Package{|",
			    color = DEFAULT},
		     inner_doc,
		     SIMPLE{desc = INTERPUNCT,
			    rep = "|}",
			    color = DEFAULT}]}
	end 
    

    (* creates a doc tree representing a package *)

    fun createPackage (m_width,d,va,t) = 
	let 
	    val (inva,inty) = Reflect.reflectPackage
	                      (UnsafeValue.cast va : Package.package)
	    val inner_doc = EMBEDDED_INF(inva,inty)
	in handlePackages (d,va,t,inner_doc)
	end 


    (* creates a doc tree representing a val_package *)

    fun createValPackage (m_width,d,va,t) = 
	let 
	    val (inva,inty) = Reflect.reflectValPackage
	                     (UnsafeValue.cast va: Package.val_package)
	    val inner_doc = EMBEDDED(inva,inty)
	in handlePackages (d,va,t,inner_doc) 
	end 

end 

