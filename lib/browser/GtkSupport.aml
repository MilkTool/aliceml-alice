(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Url         from "x-alice:/lib/system/Url"
import structure UnsafeValue from "x-alice:/lib/system/UnsafeValue"
import structure Gtk         from "x-alice:/lib/gtk/Gtk"
import structure Gdk         from "x-alice:/lib/gtk/Gdk"
import structure GnomeCanvas from "x-alice:/lib/gtk/GnomeCanvas"

(* import structure Print from "x-alice:/lib/system/Print" *)

structure GtkSupport =
    struct
	
	type tag = Gtk.object
	type color = Gtk.object

	(************ Primitive Gtk Instructions **************)
	(************ Einfache Gtk Instructionen **************)

	fun toplevelWindowNew() = Gtk.windowNew Gtk.WINDOW_TOPLEVEL
	val windowSetTitle = Gtk.windowSetTitle
	val windowSetPolicy = Gtk.windowSetPolicy
	val windowSetDefaultSize = Gtk.windowSetDefaultSize
	val widgetSetUsize =  Gtk.widgetSetUsize
	val widgetSetSensitive = Gtk.widgetSetSensitive
	val widgetShowAll = Gtk.widgetShowAll 
	val widgetHideAll = Gtk.widgetHideAll
	val widgetDestroy = Gtk.widgetDestroy
	val objectDestroy = Gtk.objectDestroy
	val containerAdd = Gtk.containerAdd
	val signalConnect = Gtk.signalConnect
	val signalConnectAfter = Gtk.signalConnectAfter
	val labelNew = Gtk.labelNew
	val radioButtonNewWithLabel = Gtk.radioButtonNewWithLabel
	val radioButtonGroup = Gtk.radioButtonGetGroup
	val toggleButtonSetActive = Gtk.toggleButtonSetActive
	val toggleButtonGetActive = Gtk.toggleButtonGetActive
	val spinButtonGetValueAsInt = Gtk.spinButtonGetValueAsInt
	val adjustmentNew = Gtk.adjustmentNew
	val widgetSetScrollAdjustments = Gtk.widgetSetScrollAdjustments
	val adjustmentGetFieldPageSize = Gtk.adjustmentGetFieldPageSize
	val adjustmentGetFieldUpper = Gtk.adjustmentGetFieldUpper
	val adjustmentGetFieldValue = Gtk.adjustmentGetFieldValue
	val layoutFreeze = Gtk.layoutFreeze
	val layoutThaw = Gtk.layoutThaw
	val menuBarAppend = Gtk.menuShellAppend
	val menuItemNewWithLabel = Gtk.menuItemNewWithLabel
	fun menuItemRightJustify item =
	    Gtk.menuItemSetRightJustified (item, true)

	    
	(************ GnomeCanvas Primitives ********************)
	(************ GnomeCanvas Instruktionen *****************)
	    
	fun canvasNew() = GnomeCanvas.new ()
	val canvasRoot = GnomeCanvas.root 
	val canvasItemNew = GnomeCanvas.itemCreate
	val canvasItemSet = GnomeCanvas.itemSet
	val canvasItemLowerToBottom = GnomeCanvas.itemLowerToBottom
	val canvasSetScrollRegion = GnomeCanvas.setScrollRegion
	val canvasItemMove = GnomeCanvas.itemMove
	    
	(************ Gdk Primitives **************************)
	(************ Gdk Befehle    **************************)

	type event = Gdk.event

	(************ Font Support   **************************)
	val fontBase = "Courier"
	    
	fun loadFont size =
	    let
		val fontName = (fontBase ^ " " ^ (Int.toString size))
		val anchor = Gtk.GtkAnchorTypeToInt Gtk.ANCHOR_NORTH_WEST
		val textType = GnomeCanvas.textGetType ()
		val textArgs =
		    [("text", Gtk.STRING " "),
		     ("x", Gtk.REAL 0.0),
		     ("y", Gtk.REAL 0.0),
		     ("anchor", Gtk.INT anchor),
		     ("font", Gtk.STRING fontName)]
		val canvas = GnomeCanvas.new ()
		val rootGroup = GnomeCanvas.root canvas
		val item =
		    GnomeCanvas.itemCreate (rootGroup, textType, textArgs)
		val (x1,y1, x2, y2) = GnomeCanvas.itemGetBounds item
		val fontX = Real.trunc (x2 - x1)
		val fontY = Real.trunc (y2 - y1)
	    in
		(fontName, fontX, fontY)
	    end
	    
	(************ Window creation helpers ******************)
	(************ Hilfsprozeduren zur 
	              Menu- und Fenstererzeugung ***************)
	    
	val uglyNULL = Gtk.NULL
	    
	(* ABSTRACTIONS FOR MENU CREATION *)

	(* SEP represents separation lines on the menu window *)
	datatype MenuLabel = SEP | LABEL of string

	(* Handler carries signal and appropriate handler function *)
	datatype Handler =
		 Handler of string * (Gtk.object * Gtk.arg list -> unit)
	    
	(* represents a hierarchy of menu items *)
	datatype MenuConstructObj = 
	    BarObj of MenuConstructObj list
	  | PopupObj of MenuConstructObj list
	  | MenuObj of {title: string, 
			items: MenuConstructObj list, 
			sensitive: bool} 
	  | EntryObj of MenuLabel * Handler list * bool  

	(* Represents one radio button and associated handlers *)
	datatype RadioButtonObj = RBObj of string * Handler list

	(* Represents one button and associated handlers *)
	datatype ButtonObj = BObj of string * Handler list
	    
	(* createMenu *)
	fun createMenu (BarObj(l)) =
	    let
		val bar = Gtk.menuBarNew()
		val create = (fn i => 
			      Gtk.menuShellAppend(bar,createMenu(i)))
	    in 
		(  (List.app create l) 
		 ;   bar) 
	    end  
	  | createMenu (PopupObj(l)) =  
	    let
		val menu = Gtk.menuNew()
		val create = (fn i => 
			      Gtk.menuShellAppend (menu,createMenu i))
	    in
		(List.app create l
		 ;Gtk.menuPopup(menu,
				uglyNULL,
				uglyNULL,
				uglyNULL,
				uglyNULL,
				3,0)
		 ;Gtk.widgetShowAll (menu)
		 ; menu)
	    end 
	  | createMenu (MenuObj(r)) = 
	    let
		val menu_item = Gtk.menuItemNewWithLabel( #title(r))
		val menu = Gtk.menuNew()
		val _ = Gtk.menuItemSetSubmenu(menu_item,menu)
		val create = fn i => 
		    Gtk.menuShellAppend(menu,createMenu i)
	    in
		(List.app create (#items(r))
		 ; widgetSetSensitive(menu_item,#sensitive(r)) 
		 ; menu_item)
	    end
	  | createMenu (EntryObj(label,handlerlist,sensitive)) =
	    let
		val item = case label of
		    SEP => Gtk.menuItemNew()
		  | LABEL(label) => Gtk.menuItemNewWithLabel(label)
		val connect = fn Handler(str,handler) 
		    => (Gtk.signalConnect (item,str, handler);())
	    in
		(List.app connect handlerlist
		 ; widgetSetSensitive(item,sensitive)
		 ; item)
	    end

	(* createCombo *)       
	fun createCombo strlist = 
	    let
		val combo = Gtk.comboNew()
	    in 
		(Gtk.comboSetPopdownStrings(combo,
					    UnsafeValue.cast(strlist) )
		;combo)
	    end

	(* createNotebookPages - 
	 takes notebook and string * Gtk object pair  
        and inserts page in Notebook *)		
	fun createNotebookPages n (title,page) = 
	    let
		val t = Gtk.labelNew title
	    in
		Gtk.notebookAppendPage(n, page, t)
	    end

	(* createNotebook - takes string * Gtk.object list 
        and creates notebook with strings as labels *)
	fun createNotebook l = 
	    let 
		val n =  Gtk.notebookNew ()
	    in
		(Gtk.notebookSetShowTabs(n, true (* 1 *) (* showlabel *))
		 ;Gtk.notebookSetTabPos(n,Gtk.POS_TOP)
		 ;List.app (createNotebookPages n) l
		 ;n)
	    end

	(* creates one button item and connects with handlers, 
	 needs predecessor *)
	fun createRadioItem (RBObj(stri,handlerlist),pred) = 
	    let
		val group = if pred =  
	            uglyNULL then  uglyNULL
			    else radioButtonGroup(pred)
		val button = Gtk.radioButtonNewWithLabel(group, stri)
		val connect = fn Handler(str,handler) 
		    => (Gtk.signalConnect (button,str, handler);())
	    in
		(List.app connect handlerlist; button)
	    end

	(* creates Radio Buttons from list of RBObj's *)
	fun createRadioButtons li = 
	    let
		val box =  Gtk.vboxNew(false ,4)
		val create = 
		    fn (x,e) => 
		    let
			val button = createRadioItem(x,e)
		    in
			(Gtk.boxPackStart(box,button,
						  false,
						  true,0)
			;button)
		    end
	    in
		(List.foldl create uglyNULL li; box)
	    end

	(* auxiliary function *)
	fun connect item = (fn Handler(str,handler) 
			    => (Gtk.signalConnect (item,str, handler);()))
		
	(* createButton *)
	fun createButton (BObj(title,handlerlist)) = 
	    let
		val button =  Gtk.buttonNewWithLabel(title)
		val con = connect button
	    in
		(List.app con handlerlist
		 ; button)
	    end
		       
	(* createButtonBox *)
	fun createButtonBox {buttons = l, borderwidth = b} =  
	    let
		val bbox = Gtk.hbuttonBoxNew()
	    in
		(Gtk.containerSetBorderWidth(bbox,b)
		 ;Gtk.buttonBoxSetLayout(bbox,
					 Gtk.BUTTONBOX_SPREAD)
		 ; List.app (fn b => Gtk.containerAdd(bbox,
					   (createButton b))) l
		 ; bbox)
	    end

	(* createTable *)
	fun createTable {rows = r, cols = c, entries = l}   = 
	    let 
		val table = Gtk.tableNew(r,c,true)
		val attach = (fn (obj,x1,x2,y1,y2) 
			      => Gtk.tableAttachDefaults(table,
					       obj,x1,x2,y1,y2))
	    in
		(List.app attach l
		 ; table )
	    end

	(* createSpinButton *)
	fun createSpinButton {init = i, 
			      lower = l, 
			      upper = u, 
			      inc = ic, 
			      dec = d}
	    = let
		  val a = Gtk.adjustmentNew(Real.fromInt(i), 
					    Real.fromInt(l),
					    Real.fromInt(u), 
					    Real.fromInt(ic), 
					    0.0, 
					    0.0)
	      in
		  Gtk.spinButtonNew(a,Real.fromInt(ic),d)
	      end

	(* vertical GTk box creation *)
	fun createVBoxDefaults l = 
	    let
		val vbox = Gtk.vboxNew(false,4)
		val p = fn i =>  Gtk.boxPackStart(vbox,i,
						  false ,
						  true ,0)
	    in
		(List.app p l
		 ; vbox)
	    end

	fun createVBox l = 
	    let
		val vbox = Gtk.vboxNew(false,0)
		val p = fn (a,i,j,k) =>  Gtk.boxPackStart(vbox,a,i,j,k)
	    in
		(List.app p l
		 ; vbox)
	    end

	(* Gtk frame creation *)
	fun createFrame (title,obj) = 
	    let 
		val frame = Gtk.frameNew(title)
	    in
		(Gtk.containerAdd(frame,obj)
		 ; frame)
	    end

	(* scroll window creation *)
	fun  createScrollWindowDefaults(inc1,inc2,max_x, max_y) =  
	    let
		val scrolled = Gtk.scrolledWindowNew(Gtk.NULL, Gtk.NULL)
		val hadj = Gtk.scrolledWindowGetHadjustment(scrolled)
		val vadj = Gtk.scrolledWindowGetVadjustment(scrolled)
	    in
		Gtk.scrolledWindowSetPolicy (scrolled,
					     Gtk.POLICY_ALWAYS,
					     Gtk.POLICY_ALWAYS);
		(scrolled,hadj,vadj)
	    end

	(* status bar creation, yields associated posting functions *)
	fun createStatusbar()  = 
	    let 
		val status = Gtk.statusbarNew()
		val type_context = 
		    Gtk.statusbarGetContextId(status,"type")
		val postMessageType = fn str =>
		    (Gtk.statusbarPop(status,
				      type_context)
		     ;Gtk.statusbarPush(status,type_context,
					str))
		val mode_context = 
		    Gtk.statusbarGetContextId(status,"mode")
		val postMessageMode = fn str =>
		    (Gtk.statusbarPop(status,
				      mode_context)
		     ;Gtk.statusbarPush(status,mode_context,
					str)) 
	    in
		(Gtk.boxSetHomogeneous(status,false)
		 ;(status,postMessageType,postMessageMode))
	    end

	(* Stop Button *)
	fun menuButton lab = let 
			     val button = menuItemNewWithLabel(lab)
			 in 
			     (widgetSetSensitive(button,false);button)
			 end

	val stopButton =
	    let
		val urlString = "x-alice:/tools/stop.xbm"
		val fileName  = Url.toLocalFile (Url.fromString urlString)
		val image     = Gtk.imageNewFromFile fileName
		val button    = Gtk.imageMenuItemNew ()
	    in
		Gtk.imageMenuItemSetImage (button, image);
		button
	    end

	val busyButton = menuButton "busy"
		     
	fun stopButtonSetActive b = widgetSetSensitive(stopButton,b)
	fun busyButtonSetActive b = widgetSetSensitive(busyButton,b)

			      

	    (* Text Window *)

	fun createTextWindow() = fn _ => 0
(*
	    let
		val textwindow = ref uglyNULL
		val alive = ref false
		val text = 
		    Gtk.textNew(uglyNULL,uglyNULL)
		val scrolled = Gtk.scrolledWindowNew(uglyNULL,uglyNULL)
		fun send str = 
		    (if not(!alive) 
			 then 
			     (textwindow := toplevelWindowNew()  
			      ; containerAdd(!textwindow,scrolled)
			      ;Gtk.widgetSetUsize(!textwindow,300,200)
			      ;Gtk.windowSetTitle(!textwindow,
			   "Alice Browser - Type Information")
			      ;widgetShowAll(!textwindow)
			      ; signalConnect (!textwindow, 
					       "delete-event", 
					       fn _ => 
				    (Gtk.containerRemove(!textwindow,
							 scrolled)
				     ; alive := false
				     ; Gtk.textBackwardDelete(text,
				                Gtk.textGetLength(text))
				     ; widgetDestroy(!textwindow)))
			      ; alive := true;0)
		     else 
			 Gtk.textBackwardDelete(text,
				                Gtk.textGetLength(text))
		     ;Gtk.textInsert(text,
				     uglyNULL,
				     uglyNULL,
				     uglyNULL,
				     str,
				     ~1))
	    in
		( containerAdd(scrolled,text)
		 ; Gtk.scrolledWindowSetPolicy(scrolled,
					       Gtk.POLICY_AUTOMATIC,
					       Gtk.POLICY_AUTOMATIC)
		; send)
	    end
*)

(******************** Complex Handler Functions **************************)

	(* "About..."-WindowHandler *)
	val aboutWindow =  (fn () =>  
	  let
	      val dialog = Gtk.dialogNew()
	      val ddialog = (fn _ =>  Gtk.widgetDestroy(dialog)) 
	      val ok = createButton(BObj("OK",[Handler("clicked",ddialog)]))
	      val l =  Gtk.labelNew("Alice Browser \n"
				    ^ "Created by \n"
				    ^ "Bernadette Blum & Marvin Schiller")
	  in
		  ( Gtk.windowSetTitle(dialog,"information")
		   ; Gtk.containerAdd((Gtk.dialogGetFieldActionArea(dialog)),
				      ok)
		   ; Gtk.containerAdd((Gtk.dialogGetFieldVbox(dialog)),l)
		   ;Gtk.widgetShowAll(dialog))
	  end)  

	(* Scrolling *)
	    
	fun scroll (d,scrolled,adj,max) = 
	    let
		val pages =  Gtk.adjustmentGetFieldPageSize(adj)
		val value = Gtk.adjustmentGetFieldValue(adj)
	    in
		( if Real.>(Real.+(Real.+(value,d),pages),max) 
		      then  Gtk.adjustmentSetValue(adj,Real.-(max,pages))
		  else  Gtk.adjustmentSetValue(adj,Real.+(value,d))
		      ;())
	    end  

	(* handles scrolling via key press *)
	fun handleGdkKeyPress ([Gdk.EVENT(event)],
			       scrolled,hadj,vadj,max_x,max_y) = 
	    case event of 
		Gdk.EVENT_KEY_PRESS({keyval = 65361,...}) => 
		    scroll(~10.0,scrolled,hadj,max_x) 
	      | Gdk.EVENT_KEY_PRESS({keyval = 65363,...}) => 
		    scroll(10.0,scrolled,hadj,max_x) 
	      | Gdk.EVENT_KEY_PRESS({keyval = 65362,...}) => 
		    scroll(~10.0,scrolled,vadj,max_y)    
	      | Gdk.EVENT_KEY_PRESS({keyval = 65364,...}) => 
		    scroll(10.0,scrolled,vadj,max_y)
	      | _ => ()

	(* Yields coordinates relative to the whole canvas *)
	fun calcAbsoluteMousePointerPosition(x,y,hadj,vadj) = 
	    let
		val valueh = adjustmentGetFieldValue(hadj)
		val valuev = adjustmentGetFieldValue(vadj) 
		val x = Real.+ (x,valueh)
		val y = Real.+ (y,valuev)
	    in
		(x,y)
	    end

	(* auxilliary for event handling *)
	fun getMouseClickEventInfo ([Gdk.EVENT(event)],hadj,vadj) = 
	    case event of
		Gdk.EVENT_BUTTON_PRESS({button = b, ...} as r) => 
		    SOME(calcAbsoluteMousePointerPosition(#x(r),#y(r),
							  hadj,vadj),b)
	      | _ => NONE
	     
	(* auxiliary for setSelectionMenuSensitive *)
	fun getSelectionMenu bar = 
	    let
		val menu_heading_items = UnsafeValue.cast 
		    (Gtk.containerGetChildren(bar)) : Gtk.object list
		val menu_heading_selection = List.nth(menu_heading_items,1)
		val submenu = 
		    Gtk.menuItemGetFieldSubmenu(menu_heading_selection)
	    in
		(menu_heading_selection,submenu)
	    end

	(* Switches "selection" menu on/off *)
	fun setSelectionMenuSensitive (bar,sensitive) = 
	    let
		val (menu_heading_selection,submenu) = getSelectionMenu bar
		val selection_menu = hd
		    (UnsafeValue.cast 
		     (Gtk.containerGetChildren(menu_heading_selection)) 
		     : Gtk.object list)    
	    in
		(widgetSetSensitive(selection_menu,sensitive)
		 ;widgetSetSensitive(submenu,sensitive))
	    end

	(* switches the field of the Selection menu on/off *)
	fun setFieldSensitive (bar,sensitive,i)= 
	    let
		val (menu_heading_selection,submenu) = 
		    getSelectionMenu bar
		val children = UnsafeValue.cast 
		    (Gtk.containerGetChildren(submenu)) : Gtk.object list
		val field = List.nth(children,i)
	    in
		widgetSetSensitive(field,sensitive)
	    end

	(* switches the expand option on/off *)
	fun setExpandSensitive(bar,sensitive) = 
	    setFieldSensitive (bar,sensitive,0)

	(* switches the shrink option on/off *)
	fun setShrinkSensitive(bar,sensitive) = 
	    setFieldSensitive (bar,sensitive,1)   
     
	(******************** Canvas Items ***************************)

	exception MissingColor
	
	(* Gtk color System *)
	val map  = Gdk.colormapGetSystem ()
	    
	(* registers a color (specified by rgb parameters) 
                                    with the Gtk system *)
	fun allocColor (r,g,b) = 
	    let val c =  Gdk.colorNew (r,g,b)
		val _ = Gdk.colormapAllocColor (map, c, 
						false, 
						true)
	    in
		c
	    end
    
	(* function that sets the canvas size and associated scroll values *)
	fun resizeCanvas (x,y,scrolled,canvas,valueh,valuev, 
			  max_x, max_y) =  
	    let 
		val adj1 = Gtk.adjustmentNew(valueh,0.0,max_x ,
					     20.0,50.0,max_x )
		val adj2 = Gtk.adjustmentNew(valuev,0.0,max_y ,
					     20.0,50.0,max_y )
	    in
		( (* widgetSetScrollAdjustments(scrolled,adj1,adj2) *)
		 canvasSetScrollRegion(canvas,0.0,0.0,x,y))
	    end

	(* creates a Gtk group *)
	local
	    val groupType = GnomeCanvas.groupGetType ()
	in
	    fun newTag(parent,x,y) = 
		GnomeCanvas.itemCreate (parent,
					groupType,
					[("x", Gtk.REAL y),
					 ("y", Gtk.REAL y)])
	end
	(* prints text in the top left corner of a group *)
	local
	    val textType = GnomeCanvas.textGetType ()
	    val anchor = Gtk.INT (Gtk.GtkAnchorTypeToInt Gtk.ANCHOR_NORTH_WEST)
	in
	    fun print00 (str,group,color,fontname) = 
		GnomeCanvas.itemCreate (group,
					textType,
					[("text", Gtk.STRING str),
					 ("font", Gtk.STRING fontname),
					 ("fill_color_gdk", Gtk.OBJECT color),
					 ("anchor", anchor)])
	end

	(* puts a group at a specified position *)
	fun positionGroup (group,x,y) = 
	    if x=0.0 andalso y=0.0 then ()
	    else 
		(GnomeCanvas.itemSet(group,"x", Gtk.REAL x) 
		 ;GnomeCanvas.itemSet(group,"y", Gtk.REAL y))
			
        (* moves a Gtk group 
		 (arguments represent distance in characters) *)
	fun moveGroup (group,x,y,font_height,font_width) = 
	    if x=0 andalso y=0 then ()
	    else
		let
		    val rx = Real.fromInt(x * font_width)
		    val ry = Real.fromInt(y * font_height)
		    val _ = () 
		in
		    GnomeCanvas.itemMove(group,rx,ry)
		end
	  
	(* queries the boundaries (in character positions) of the object *) 
	fun getCoordinates (group,font_height,font_width) = 
	    let
		val (rx1,ry1,rx2,ry2) = 
		    GnomeCanvas.itemGetBounds group
		val x1 = (Real.trunc rx1) div font_width
		val y1 = (Real.trunc ry1) div font_height
		val x2 = (Real.trunc rx2) div font_width
		val y2 = (Real.trunc ry2) div font_height
	    in
		(x1,y1,x2,y2)
	    end
		
	(* same as above with only two return values *)
	(* We use round instead of trunc *)
	fun getPosition (group,font_height, font_width) = 
	    let
		val (rx1,ry1,_,_) = 
		    GnomeCanvas.itemGetBounds group
 		val x1 = (Real.round rx1) div font_width
		val y1 = (Real.round ry1) div font_height
	    in
		(x1,y1)
	    end

	(* moves a Gtk item (absolute parameters) *)
	fun itemMoveTo (group,rx,ry) = 
	    let
		val (rx1,ry1,_,_) = 
		    GnomeCanvas.itemGetBounds group
		val (absx,absy) = GnomeCanvas.itemI2w' (group,rx1,ry1)
		val dx = Real.- (rx, absx)
		val dy = Real.- (ry, absy)
	    in
		if absx = rx andalso absy = ry
		    then ()
		else (GnomeCanvas.itemMove(group,dx,dy))
	    end

	(* creates horizontal Line on canvas *)
	local
	    val lineType = GnomeCanvas.lineGetType ()
	    val lineStyle = 
		Gtk.INT (Gdk.GdkLineStyleToInt Gdk.LINE_ON_OFF_DASH)
	    val lineWidth = Gtk.INT 1
	    val lineColor = Gtk.OBJECT (allocColor (40000, 40000, 50000))
	in
	    fun createSepLine (group,actline,x,font_height)= 
		if actline > 0 then
		    let
			val mx = Real.trunc(x)
			val linepos = actline * font_height - (font_height div 2)
		    in
			GnomeCanvas.itemCreate
			(group,
			 lineType,
			 [("points",
			   Gtk.OBJECT (GnomeCanvas.makePoints
					   [0, linepos, mx, linepos])),
			  ("fill_color_gdk", lineColor),
			  ("line_style", lineStyle),
			  ("width_pixels", lineWidth)])  
		    end
		else uglyNULL
	end

	(* adjusts length of a separation line *)
	fun resizeSepLine(line,x) = 
	    let 
		val (rx1,ry1,rx2,ry2) = 
		    GnomeCanvas.itemGetBounds line
		val y1 = Real.trunc(Real.+(ry1,1.0))
	    in
		(GnomeCanvas.itemSet(line,
				   "points", 
				   Gtk.OBJECT (GnomeCanvas.makePoints
						   [0, y1, x, y1])))
	    end
	
	(* moves separation line below the group it belongs to *)
	fun yPosSepLine (item,group,font_height) = 
	    let
		val (_,ry1,_,_) = 
		    GnomeCanvas.itemGetBounds group
		val y = Real.trunc(ry1) - (font_height div 2)
		val (_,_,lx2,_) = 
		    GnomeCanvas.itemGetBounds item
	    in
		GnomeCanvas.itemSet(item,
				  "points", 
				  Gtk.OBJECT (GnomeCanvas.makePoints
						  [0, y, 
						   Real.trunc(lx2), 
						   y]))
	    end 
	
	(* auxiliary for arrow creation *)
	fun translate (nil,h,v,h_off,v_off) = nil
	  | translate (x1::x2::xr,h,v,h_off,v_off) = 
	    ((x1 * h) div 8 + h_off)::
	    ((x2 * v) div 8 + v_off)::translate(xr,h,v,h_off,v_off)
	  | translate _ = raise Match
     
	(* creates arrow from pointset *)
	fun createArrow(group,points,color) = 
	    GnomeCanvas.itemCreate(group,
			      GnomeCanvas.polygonGetType (),
			      [("points", 
				Gdk.OBJECT (GnomeCanvas.makePoints points)),
			       ("fill_color_gdk",
				Gtk.OBJECT(color)),
			       ("outline_color_gdk",
				Gdk.OBJECT(allocColor(0,0,0))),
			       ("width_pixels", Gdk.INT 1)])

	(* creates arrow pointing rightwards *)
	fun createArrowRight(group,color,font_height,font_width) = 
	    let
		val w = (font_width * 3) div 2
		val h = font_height  
		val points = [4,0, 4,2, 0,2, 0,6, 4,6, 4,8, 8,4]
		val points' = translate(points,w,h,0,0)
		val group' = newTag(group,0.5,0.5)
	    in
		createArrow(group',points',color)
	    end

	(* analogeous to above *)
	fun createArrowDown(group,color,font_height,font_width) = 
	    let
		val w = (font_width * 3) div 2
		val h = font_height 
		val points = [2,0, 2,4, 0,4, 4,8, 8,4, 6,4, 6,0]
		val points' = translate(points,w,h,0,0)
		val group' = newTag(group,0.5,0.5)
	    in
		createArrow(group',points',color)
	    end

	(* creates simple orange coloured rectangle *)
	fun createRectangle (group,x1,y1,x2,y2) = 
	    GnomeCanvas.itemCreate
	    ( group, 
	     GnomeCanvas.rectGetType (),
	     [("x1", Gtk.REAL x1),
	      ("y1", Gtk.REAL y1),
	      ("x2", Gtk.REAL x2),
	      ("y2", Gtk.REAL y2),
	      ("fill_color_gdk", 
	       Gtk.OBJECT(allocColor(65000,50000,50000))),
	      ("outline_color_gdk", 
	       Gtk.OBJECT (allocColor(65000,50000,50000)))]) 
(*
	val groupRef = ref Gtk.NULL

	fun printDimensions (loc : string, group) =
	    let
		val ref(oldGroup) = groupRef
		val mesg = if oldGroup = group then "old"
			   else (groupRef := group; "new")
	    in
		Print.printVal (loc, mesg, GnomeCanvas.itemGetBounds group)
	    end
*)
end
