(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Inf from "x-alice:/lib/rtt/Inf"
import structure Type from "x-alice:/lib/rtt/Type"
import structure Label from "x-alice:/lib/rtt/Label"
import structure Path from "x-alice:/lib/rtt/Path"
import structure Reflect from "x-alice:/lib/system/Reflect"
import structure UnsafeValue from "x-alice:/lib/system/UnsafeValue"

import structure Node from "Node"
import structure Settings from "Settings"

import signature NEW_NODE_HELPER from "NEW_NODE_HELPER-sig"

local 
    open Node Settings
in

structure NewNodeHelper :> NEW_NODE_HELPER = 
struct

    datatype 'a list_desc = Det of 'a list * bool (* ohne Future *)
                          | Indet of 'a list * 'a list (* mit Future *)

   (* Bestimmung und Zerlegung von "Apply"-Typen *)   

    fun isApply t = case t of Type.Apply(_,_) => true
                           | _ => false 

    fun unApply'(Type.Apply(t1,t2),li) = unApply'(Type.inspect(t1), t2::li)
      | unApply'(sth,li) = (sth, rev li)

    fun unApply sth = unApply' (sth,nil)

    (* itemToLabel *)

    fun itemToLabel i = case Inf.inspectItem i of
	Inf.FixItem(l,_) => l
      | Inf.ValItem(l,_) => l
      | Inf.TypItem(path,_) => let val str = Label.toString(Path.toLab(path))
				in Label.fromString("$"^str)
				end
      | Inf.ModItem(path,_) => let val str = Label.toString(Path.toLab(path))
			       in Label.fromString(str^"$")
			       end
      | Inf.InfItem(path,_) => let val str = Label.toString(Path.toLab(path))
			       in Label.fromString("$"^str^"$")
			       end   
      | Inf.HiddenItem(i) => itemToLabel i

    (* Tiefenfilter *)
(*
    (* queryDepth *)

    fun queryDepth (va,t,p,i,d,row,f,root) = 
	if d > !max_depth 
	    then createLimit (createValue(va,t),DEPTH_LIMIT,
			      p,i,d,root)
	else f (va,t,p,i,d,row,root)

    (* queryDepthL *)

    fun queryDepthL (va,t,p,i,d,ld,f,root) = 
	if d > !max_depth 
	    then createLimit (createValue(va,t),DEPTH_LIMIT,
			      p,i,d,root)
	else f (va,t,p,i,d,ld,root)
*)
    (* zur Behandlung von Listen *)
	
     val compList = 
	let structure UnitList = Reflect.ReflectType(type t = unit list)
	    val unitList = UnitList.x
	in #1(Type.asApply(unitList))
	end 

    fun inspectList(n,x) = inspectList'(n,x,[])
	
    and inspectList'(n,x,xs) =
	if not(Future.isDetermined x) 
	    then Indet(List.rev xs, x) 
	else
	    if List.null x 
		then Det(List.rev xs, false) 
	    else
		if n = 0 
		    then Det(List.rev xs, true) 
		else inspectList'(n-1, List.tl x, List.hd x :: xs)
		    
    fun castList value = UnsafeValue.cast value : 'a list    

(* Rows *)

    fun row2list row = case Type.inspectRow(row) of 
	Type.EmptyRow => nil
      | Type.UnknownRow => nil
      | Type.FieldRow(lab,t,row2) => 
	    (lab,t)::row2list(row2)

    fun labelvector (ll:(Label.lab * Type.typ) list) = 
	Vector.tabulate ((List.length(ll)), 
			 (fn i =>(#1( List.nth(ll,i))) ) )  

    (* Operationen auf Arrays *)

    fun copyArray' (a, b, i) = if i = Array.length(a) 
				   then ()
				       else
	                       (Array.update(b,i,Array.sub(a,i))
				; copyArray' (a,b,i+1))
    
    fun copyArray (a,b) = if Array.length(a) > Array.length(b) 
			      then raise Match 
				  else copyArray'(a,b,0)

    (* Operationen auf Strings *)
	
    fun iterTake' (str,i,a) = 
	if i >= (String.size(str)) 
	    then a
	else
	    let val test = String.sub(str,i) 
	    in if Char.equal(#" ",test)
		   then a
	       else iterTake' (str,i+1, a ^ Char.toString(test))
	    end  

    fun iterTake str = iterTake'(str,0,"")

    (* berechnet f(0,x_{0}), f(1,x_{1}), ......, f(br,x_{br}) *)
    (* wird benutzt von setItems *)

    fun appi_break' (f,br,l,i) = if i <=br
				     then (f (i,hd(l))
					   ;appi_break' (f,br,tl(l),i+1))
				 else ()
				     
    fun appi_break (f,br,l) = appi_break'(f,br,l,0)    

end (* struct *)

end
    
