(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure TextIO from "x-alice:/lib/system/TextIO"
import structure PrettyPrint from "x-alice:/lib/utility/PrettyPrint"
import structure PPType from "x-alice:/lib/rtt/PPType"
import structure PervasiveType from "x-alice:/lib/rtt/PervasiveType"
import structure PPInf from "x-alice:/lib/rtt/PPInf"
import structure UnsafeValue from "x-alice:/lib/system/UnsafeValue"
import structure Reflect from "x-alice:/lib/system/Reflect"

import structure Node from "Node"
import structure Doc from "Doc"
import structure Color from "Color"
import structure MkDrawingArea from "MkDrawingArea"
import signature DRAWING_AREA from "DRAWING_AREA-sig"
import structure GtkSupport from "GtkSupport"
import structure Settings from "Settings"

import structure Dictionaries from "Dictionaries"

import structure NewNode from "NewNode"
import structure Layout from "Layout"
import structure DrawNodes from "DrawNodes"
import structure Update from "Update"
import structure Server from "Server"

import signature WIDGET from "WIDGET-sig"

local 
open GtkSupport Node Doc Color PervasiveType

(*********** Knotensuche ***************)

    exception NodeFound of node
    exception unknown

    fun inBoundingBox (node,x,y) = 
	let
	    val xdim = get_xdim(node)
	    val ydim = get_ydim(node)
	    val _ =  () (* TextIO.print("Simple search with x=" 
					 ^ Int.toString(x)
					 ^ " and y="
					 ^ Int.toString(y)
					 ^ "\n")  *)
	in  
	    x >= 0 
	    andalso y >= 0
	    andalso x < xdim
	    andalso y < ydim
	end

    fun isInterpunct node = case getDesc(node) 
	of INTERPUNCT => true
      | _ => false

    fun interpunctMayBeSelected (Limit _ | RelNode _ | RelRefNode _ ) = true
      | interpunctMayBeSelected  _ = false

    fun justifyFound (node,SOME(n) as found) =if isInterpunct(node)
					     then if node = n 
					     	 then SOME(getParent(node))
						     else found
					    else found
      | justifyFound (node,NONE)     = NONE

    fun treeSearch ((Simple _ as node | Limit _ as node),x,y)  = 
	if inBoundingBox(node,x,y) then 
	    if not(isInterpunct node) 
		orelse (interpunctMayBeSelected node)
		orelse (getParent(node) = Empty) 
		then SOME(node)
		    else SOME(getParent(node))
	else NONE
      | treeSearch (RelRefNode _ as node,x,y) = if inBoundingBox(node,x,y) 
						then SOME(node)
						    else NONE
      | treeSearch (RelNode(r) as node,x,y) =  (case !(#counter(r)) of
			  1  =>  treeSearch(!(#content(r)),x,y)
			| _  =>  let
				     val labellength =  String.size(#rep(r))
				     val label_in_bb = x>=0
					 andalso x < labellength
					 andalso y = 0
				 in
				     if label_in_bb then SOME(node) 
					 else treeSearch(!(#content(r)),
							 x - labellength,
							 y)
				 end)
      | treeSearch (Concat(r) as node,x,y) =
	    let
		val _ = () (* TextIO.print("Concat search with x=" 
				     ^ Int.toString(x)
				     ^ " and y="
				     ^ Int.toString(y)
				     ^ "\n")  *)
	    in
		if inBoundingBox(node,x,y) 
		    then let
			     val hor_funct =
				 (fn (a,(curx,cury)) =>
				  (case treeSearch(a,curx,cury) of
				       SOME(n) => raise NodeFound(n)
				     | NONE    => let
					   val c = curx -  get_xdim(a)
					   val _ =  () (* TextIO.print("curx is "
							^ Int.toString(c)
							^ "\n") *)
						  in
					   (case a of
						Container(r) => 
						    if setsVertical(a) 
							then
					  (curx - get_l_xdim(a)
					   , cury - get_ydim(a) +1)
						    else 
					  (curx -  get_l_xdim(a) (*was xdim *)
					   ,cury)
					| Empty => (curx,cury)
					| _ => 
			     (curx - get_l_xdim(a) (* was xdim *) 
					     ,cury- get_ydim(a) +1 ))
						  end))
			     val found = (Array.foldl hor_funct (x,y)	
					  (getKids(node)); NONE)
				 handle NodeFound(n) => SOME(n)
			 in
			    justifyFound(node,found)
			 end
	    else NONE
	    end
      | treeSearch (Container(r) as node,x,y) = 
		let
		    val _ =  () (* TextIO.print("Container search with x=" 
					 ^ Int.toString(x)
					 ^ " and y="
					 ^ Int.toString(y)
					 ^ "\n")  *)
			in
		if inBoundingBox(node,x,y) 
		    then let
			     val hor_funct =
				 (fn (a,curx) =>
				  (case treeSearch(a,curx,y) of
				       SOME(n) => raise NodeFound(n)
				     | NONE    => 
					   (curx -  get_xdim(a))))
			     val ver_funct =
				 (fn (a,cury) =>
				  (case treeSearch(a,x,cury) of
				       SOME(n) => raise NodeFound(n)
					 | NONE    => 
					   (cury -  get_ydim(a))))
			     val found = (if setsVertical(node)
					      then (Array.foldl ver_funct y 
						  (getKids(node));NONE)
					  else (Array.foldl hor_funct x 
					      (getKids(node));NONE))
				 handle NodeFound(n) => SOME(n)
			 in
			      justifyFound(node,found)
			 end
		else NONE
		end
      | treeSearch _ = NONE

    fun iterate (dict,x,y,i,highest_i) = 
	if i > highest_i 
	    then NONE
	else
	    case Dictionaries.Main.lookup(Dictionaries.maindict,i) of
		NONE => iterate(dict,x,y,i+1,highest_i)
	      | SOME (node,line) =>( case treeSearch(node,x,y) 
		    of
			NONE => iterate (dict,
					 x,
					 y-get_ydim(node)-1,
					 i+1,
					 highest_i)
		      | SOME n => ( case getParent(n) of
				    RelNode(r) 
				    => if !(#counter(r)) = 1
					   then SOME n
				       else SOME (getParent(n))
                                  | _ => SOME n))
	      |_ => NONE
				   
						     
    fun search (real_x, real_y) = 
	let
	    val int_x = (Real.trunc(real_x))
	    val font_width = !Settings.fontWidth
	    val x = int_x div font_width
	    val int_y = (Real.trunc(real_y))
	    val font_height = !Settings.fontHeight
	    val y = int_y div font_height
	    val highest_i = Dictionaries.Main.getHighestIndexAssigned(Dictionaries.maindict)
	    val _ = () (* TextIO.print("searching for x:" 
			^ Int.toString(x) ^ " and y:" ^Int.toString(y)
			^ " \n") *)
	in
	   iterate (Dictionaries.maindict,x,y,0,highest_i)
	end

(*********** Ende Knotensuche ***************)

(*********** Begin  Separation Line Resize Mechanism  ***************)

fun  resizeSepLinesIterate(dict,x,i,highest_i) =
     if i > highest_i 
	 then ()
     else 
	 (case Dictionaries.Main.lookup(dict,i) of
	      NONE =>
		  resizeSepLinesIterate(dict,x,i+1,highest_i)
	    | SOME (_,line) => 
		  if line = uglyNULL 
		      then  resizeSepLinesIterate(dict,x,i+1,highest_i)
		  else
		      (resizeSepLine(line,x)
		       ;resizeSepLinesIterate(dict,x,i+1,highest_i)))

fun resizeSepLines (dict,rx) = 
     let 
	 val x = Real.trunc rx
	 val highest_i = Dictionaries.Main.getHighestIndexAssigned(dict)
     in
	 resizeSepLinesIterate(dict,x,0,highest_i)
     end

(*********** End  Separation Line Resize Mechanism  ***************)

in

structure Widget :> WIDGET =
struct

    val window = toplevelWindowNew()
    val canvas = ref uglyNULL
    val canvasroot = ref uglyNULL
    val resize = ref (fn () => ())
    val alive = ref false
    val act_line = ref 0

    fun incr_act_line dy = (TextIO.print("Widget: actline was: "
					 ^Int.toString(!act_line))
			    ;act_line := !act_line + dy
			    ; TextIO.print(" and now is "
					   ^ Int.toString(!act_line)^"\n"))

    val selection = ref NONE
    
    fun destroySelectionMarkings () = case !selection of 
	NONE => ()
      | SOME(_,rect,rect') =>( objectDestroy(rect)
			  ; objectDestroy(rect'))


    fun getSelectionNode() = case !selection of 
	NONE => Node.Empty
      | SOME(n,_,_) => n  

    fun DeleteWindow _ = (widgetHideAll(window)
		    ;Settings.max_x :=0.0
		    ;Settings.max_y :=0.0
		    ;Dictionaries.Main.dumpAll(Dictionaries.maindict)
		    ;Dictionaries.RelMan.dumpAll(Dictionaries.reldict)
		    ;act_line := 0
		    ;alive:= false)

    val (status,postType,postMode) = createStatusbar() 
	 
    val (scrolled,hadj,vadj) =  createScrollWindowDefaults(20.0,50.0,!Settings.max_x, !Settings.max_y)

    fun freezeThaw(x) = (layoutFreeze(x)
		       ; layoutThaw(x))

     fun show() = if !alive then widgetShowAll(window) else ()
    
(********************************* Resize Mechanism *******************************)


     fun canvaswidth (hadj) = let
				  val page_sh = adjustmentGetFieldPageSize(hadj)
				  val h = if (Real.< (page_sh,(!(Settings.max_x)))) 
					      then !(Settings.max_x) else page_sh
			      in
				  h
			      end

     (* invokes canvas resize *)	
     fun handleResize (scrolled,hadj,vadj,resize) = 
	 (fn _ =>  
	  Server.serve (fn () => 
			let
			    val upperh = adjustmentGetFieldUpper(hadj)
			    val valueh = adjustmentGetFieldValue(hadj)
			    val upperv = adjustmentGetFieldUpper(vadj)
			    val valuev = adjustmentGetFieldValue(vadj) 
			    val page_sv = adjustmentGetFieldPageSize(vadj)
			    val h = canvaswidth(hadj)
			    val v = if (Real.< (page_sv,(!(Settings.max_y)))) 
					then !(Settings.max_y) else page_sv
			in
			    (resize(h,v,scrolled,valueh,valuev  )
			     ; resizeSepLines(Dictionaries.maindict,
					      h)
			     ; ())
			end))
	 
(*****************************************************************************)

(**************************** Stop Button Mechnism****************************)

     (* val stopButtonActive = ref false *)

	val _ = signalConnect(stopButton,
		  "activate",
		  fn _ => (stopButtonSetActive(false)
			   ; Settings.set_width 0
			   ; Settings.set_depth 0)) (* needs to be repaired *)
	    
    
     (* fun stopButtonIsActive() = !stopButtonActive *)
		  
     (* fun stopButtonSetActive b =  
	 (GtkSupport.setSensitive(stopButton,b )
	  ; TextIO.print("Stop Button now active: "^Bool.toString(b) ^ "\n")  ) *)

     fun setStopButtonOnOff(f,n) = 
	 (Server.serve(fn() => stopButtonSetActive(true))
	  ;f n
	  ; TextIO.print("STOP_BUTTON: f n done\n")
	  ; Server.serve(fn() => stopButtonSetActive(false)))
	 

(* 
     exception stopped

     fun testIfStop() = if not(stopButtonIsActive()) then raise stopped
			else () *)

(**************************** Handler ****************************)
		    
     fun update_reinspect n = Update.reinspect(n,NewNode.createGraph,
					       NewNode.createGraphInf,!canvasroot)

     fun handleReinspect node = fn _ => ( setStopButtonOnOff(update_reinspect,node ))
     
     fun handleReinspectSelection _ = setStopButtonOnOff(update_reinspect, getSelectionNode())
  
     fun handleShrinkSelection _  = 
	 let
	 val update_shrink 
	     = fn n  => let val diff = getDepth(n) - 
	     Update.findHighestDepth n
			    in if diff >= 0 
				   then ()
			       else Update.foldDepth(n,diff-1,NewNode.createGraph,
						     NewNode.createGraphInf,!canvasroot)
			    end
	 in
	     setStopButtonOnOff(update_shrink, getSelectionNode())
	 end

     fun handleExpandSelection _  = 
	 let
	     val update_expand =  fn n 
			     => Update.foldDepth(n,1,NewNode.createGraph,
						 NewNode.createGraphInf,!canvasroot)
	 in
	 setStopButtonOnOff(update_expand, getSelectionNode())
	 end

     fun handleWidth node =  
	 let
	     val update_width = fn (n,i) => (print "starting width !!!!!\n"
					     ;Update.foldWidth(n,i,NewNode.createGraph,
							       NewNode.createGraphInf,!canvasroot))
	 in
	     fn i => fn _ => setStopButtonOnOff(update_width,(node,i))
	 end
     
     fun handleDepth node =
	 let
	     val update_depth = fn (n,i) => (print "starting depth !!!!\n"
					     ;Update.foldDepth(n,i,NewNode.createGraph,
							       NewNode.createGraphInf,!canvasroot))
	 in
	     fn i => fn _ => setStopButtonOnOff(update_depth,(node,i))
	 end

     fun handleForce node _ = 
	 let
	     val update_force =  fn n 
			     => let val b_future = case getDesc n of  
				    VALUE(r) => UnsafeValue.cast (#value(r)) 
				  | I_VALUE(r) => UnsafeValue.cast (#value(r)) 
                                  | _ => raise Match 
				in Future.await(b_future) 
				end
	 in
	     setStopButtonOnOff
	     (update_force, getSelectionNode())
	 end


(*

fun uninspect() = 
    let
	val li = Dictionaries.Main.dict2list(Dictionaries.maindict)
	val desc_li = 	rev(List.foldl 
			    (fn ((n,sep),li) => (getDesc(n))::li ) nil li)
    in
	(List.app deleteTreeNode li
	 ; desc_li)
    end

fun re_inspect() = 
    let 
	val li = uninspect()
    in
	List.app (fn d => case d of 
		   VALUE(r) => inspect (#value(r),#typ(r))
		  | I_VALUE(r) => inspectInf  (#value(r),#typ(r))
		  | _ => ()) li
    end

fun updateIterate = re_inspect
  
*)  

(*
(* dient zur Aenderung der font-Groesse *)
     fun updateIterate(i,no,diffh) = 
	 if (* i > MainDictionary.getHighestIndexAssigned(Dictionaries.dict) *)
	     i < 0 
	     then ()
	 else
	     case MainDictionary.lookup(Dictionaries.dict,i) of
		 NONE => updateIterate(i-1,no,diffh)
	       | SOME (node,line) =>	 
			    ((selectHandler "reinspect") (node,0)
			     ; GtkSupport.move(Node.getGroup(node),0.0,
					       Real.fromInt(diffh * no))

				      ; updateIterate(i-1,no+1,diffh))
	       |_ => () *)


 (* Handles ok Button in Preferences Window *)
     fun okHandler(w,
	      width_s,
	      depth_s,
	     (* font_s, *)
	      treemode_button,
	      relmode_button, 
	      tokenmode_button) = (fn _ => 
	       		   ( (* let
				val fontname = Gtk.fontSelectionGetFontName
				    (fontpicker)
			    in
				(Settings.fontname := fontname
				;Settings.font:= fontLoad(fontname)
				;Settings.fontHeight :=
				 (fontGetFieldAscent(!Settings.font)+
			   Gdk.fontGetFieldDescent(!Settings.font) )
				;Settings.fontWidth:=
				 (stringWidth(!Settings.font,"W")))
			    end
			    ;  *) Settings.max_width := 
			    spinButtonGetValueAsInt(width_s) 
			    ;Settings.max_depth := 
			    spinButtonGetValueAsInt(depth_s)
			    (* Fontgroesse *) (*
			    ;  let
				  val new_size = 
				      spinButtonGetValueAsInt(font_s)
			      in
				  if !Settings.fontSize = new_size then ()
				  else ( Settings.setFontSize(new_size)
				       ; updateIterate())
			      end *)
			    (* Debug Aid *)
			    ;if toggleButtonGetActive(relmode_button) = 
			      true
			      (* 1 *)
			      orelse 
			   toggleButtonGetActive(tokenmode_button) = 
			       true
			       then print ("Relmode-Button set\n")
				   else print ("Relmode-Button not set\n")
			    ;Settings.relmode := (
			    toggleButtonGetActive(relmode_button) = true
						  (* 1 *)
						  orelse 
			   toggleButtonGetActive(tokenmode_button) = true 
						  (* 1 *) )
			    ;Settings.tokenmode :=  
			    toggleButtonGetActive(tokenmode_button) = true
			    (* 1 *)
			    ;widgetDestroy(w)
			    ;if 
			    toggleButtonGetActive(treemode_button) = true 
			    (* 1 *)
				 then (Dictionaries.RelMan.dumpAll
				       (Dictionaries.reldict)
				       ; relnumber := 0)
			     else ()))

    
     (* Preferences Window Handler *)
     fun Preferences _ = Server.serve (fn () =>
       	   let	
           (* Width & Depth Settings *)
	   val width_lab = labelNew("Set Width Limit to...")	       
	   val width_s = createSpinButton{init =(!Settings.max_width) , 
					   lower = 0, 
					   upper = 100, 
					   inc = 1, 
					   dec = 0}
	    val depth_s = createSpinButton{init =(!Settings.max_depth) , 
					   lower = 0, 
					   upper = 100, 
					   inc = 1, 
					   dec = 0}
	    val depth_lab = labelNew("Set Depth Limit to...")
	    val table = createTable{rows = 2, cols = 4, 
				    entries = [(width_lab,0,2,0,1),
				     (width_s,2,3,0,1),
				     (depth_lab,0,2,1,2),
				     (depth_s,2,3,1,2)]}
	    val frame = createFrame("",table)
	    (* Mode Settings *)
	    val treemode_button =radioButtonNewWithLabel(uglyNULL, 
       			      "Tree Mode")
	    val group = radioButtonGroup(treemode_button)
	    val tokenmode_button = radioButtonNewWithLabel(group, 
				"Relational Mode - Token Equality")
	    val group = radioButtonGroup(tokenmode_button)
	    val relmode_button = radioButtonNewWithLabel(group, 
				"Relational Mode - Structural Equality")
	    val _ = if !Settings.tokenmode 
			then toggleButtonSetActive(tokenmode_button,true 
						       (* 1 *) )
		    else if !Settings.relmode then 
			toggleButtonSetActive(relmode_button,true 
						  (* 1 *))
			else
			toggleButtonSetActive(treemode_button,true (* 1 *))

	    val radiobox = createVBoxDefaults[treemode_button,
					      relmode_button,
					      tokenmode_button]
(*
	    val font_lab = labelNew("Set Font Size to...")	
	    val font_s = createSpinButton{init =(!Settings.fontSize) , 
					  lower = 8, 
					   upper = 50, 
					   inc = 1, 
					   dec = 0}
	    val app_table = createTable{rows = 2, cols = 4, 
				    entries = [(font_lab,0,2,0,1),
					       (font_s,2,3,0,1)]}*)

	   (* val fontpicker = Gtk.fontSelectionNew() *)

	   (*  val colorsel = Gtk.colorSelectionNew() *)

	    (* Buttonbox *)

	    val w = toplevelWindowNew()
	    val bbox = createButtonBox{buttons = 
		      [BObj("ok",[Handler("clicked",
					  (okHandler(w,
						     width_s,
						     depth_s,
						   (*  font_s, *)
						     treemode_button,
						     relmode_button,
						     tokenmode_button)   ))]),
		       BObj("apply",[]),
		       BObj("cancel",
			    [Handler("clicked",fn _ => 
				     widgetDestroy(w))])],
				       borderwidth = 20}

	    val n = createNotebook[("Width & Depth Limit Settings",frame),
				   ("Mode Settings",radiobox) (* ,
				    ("Appearance",app_table)  *) ] 

	    val vbox = createVBoxDefaults[n,bbox]
		in
		    (windowSetTitle (w, "Preferences")
		    ;windowSetPolicy(w,0,0,1)
	            ;containerAdd(w,vbox)
	            ;signalConnect (w, "delete-event", 
					fn _ => widgetDestroy(w) )
		     ;widgetShowAll(w))
	end)

	


	 (* Menu-Bar *)
     val bar = GtkSupport.createMenu
	 (BarObj[MenuObj
		 {title = "Inspector",
		  items = [EntryObj
			   (LABEL "About...",
			    [Handler("activate",
				   fn _ => Server.serve (aboutWindow) )],true),
			   EntryObj(SEP,[],true),
			   EntryObj(LABEL "Close",
				    [Handler("activate",
					     DeleteWindow)],true)],
		  sensitive = true},
		 MenuObj
		 {title = "Selection",
		  items = [EntryObj(LABEL "Expand",
				    [Handler("activate",
					     handleExpandSelection)]
				    ,true),
			   EntryObj(LABEL "Shrink",
				   [Handler("activate",
					    handleShrinkSelection)]
				    ,true),
			   EntryObj(SEP, [],true),
			   EntryObj(LABEL "Reinspect",
				    [Handler("activate",handleReinspectSelection)]
				    ,true)],
		  sensitive = true}   ,
		 MenuObj
		 {title = "Options",
		  items = [EntryObj(LABEL "Preferences...",
				    [Handler("activate",
					     Preferences)],true)],
		  sensitive = true}]) 

     
		  
	val _ = menuBarAppend(bar,stopButton)
	val _ = menuItemRightJustify(stopButton)

 
(* Sendet Typinformation eines Knotens an den Statusbar *)
     fun postT n = 
	 let  
	     val desc = Node.getDesc(n)
	     val positions_displayed = Real.trunc(canvaswidth(hadj)) div 6 
	 in
	     (case desc of
		 Node.INTERPUNCT => 0
	       |  Node.VALUE(r) => 
		     let
			 val text = PrettyPrint.toString
			     (PPType.ppTyp(#typ(r)),1000)
		     in
			 if
			     (String.size(text)) > positions_displayed 
			     then
				 postType("  " 
			      ^String.extract(text, 0,SOME( positions_displayed)) ^ " ... ")
			 else
			     postType("  " ^ text)
		     end
	       | Node.I_VALUE(r) =>
		     postType("  " 
			      ^ String.extract(PrettyPrint.toString
					       (PPInf.ppInf(#typ(r)),
						positions_displayed	),
					       0,
					       SOME( positions_displayed)) ^ " ... ")
		     ;()) handle _ => ()
	 end
   
 fun deleteNode Empty = ()
   | deleteNode (Simple(r) as node)  =   ( objectDestroy(getGroup(node))
	     ; (if not(Future.isDetermined(UnsafeValue.cast (getValue(getDesc(node)))))	
	     then case Dictionaries.Transient.iterLookup
		 (Dictionaries.transdict,fn (v,_,n) => 
		  v = getValue(getDesc(node))) 
		 of
		     SOME (n,i) => Dictionaries.Transient.delete
			 (Dictionaries.transdict,i)
		   | NONE => ()
	       else ()) handle Match => ())
     | deleteNode (RelNode(r) as node) = (deleteNode (getContent(node))
					  ; objectDestroy(getGroup(node))) 
     | deleteNode (RelRefNode(r)as node) = (objectDestroy(getGroup(node))) 
     | deleteNode (Limit(r) as node) = objectDestroy(getGroup(node))
     | deleteNode node =  ( Array.app deleteNode (getKids(node))
			   ; objectDestroy(getGroup(node)))
   

    fun deleteNodeTree node = 
	let 
	    val root_node = case getParent(node) of 
		  Empty => node
		| RelNode(r) => getParent(node)
		| _ => Empty
	    val dy = ~1 - get_ydim(root_node)
	in
	( deleteNode node
	  ;case Dictionaries.Main.lookup(Dictionaries.maindict,getIndex(node))  
	 of 
	     SOME (n,sep) => if not(sep = GtkSupport.uglyNULL) 
				 then objectDestroy(sep) 
				     else ()
	       | NONE => ()
	 ;if not(root_node = Empty) 
	      then (Dictionaries.Main.delete(Dictionaries.maindict,
					    getIndex(root_node))
		    ;Dictionaries.RelMan.delete(Dictionaries.reldict,
					    getIndex(root_node)))
	  else ()
	 ;incr_act_line(dy)
	 ;Update.iterMove(dy,getIndex(root_node)+1)
	 ;Update.setVisible(0,dy)) (* Update.setVisible ist wichtig - 
				    <> zu Widget.setVisible ! *)
	end

fun makePopup n = 
	let 
	    val w = handleWidth(n)
	    val d = handleDepth(n)
	    val r = handleReinspect(n)
	    val f = handleForce(n)
	    val reinspect_active = not(Node.getDesc(n) = Node.INTERPUNCT)
	    val force_active = (Node.isByneed n) handle _ => false
	    val delete_active = getParent(n) = Empty orelse 
		                (isRelNode(getParent(n)) andalso getParent(getParent(n)) = Empty)
	    val width_item_list = [EntryObj(LABEL("-5"),
					      [Handler("activate",w(~5))],
						       true),
				   EntryObj(LABEL("-4"),
					    [Handler("activate",w(~4))],
					    true),
				   EntryObj(LABEL("-3"),
					      [Handler("activate",w(~3))],
					         true),
				     EntryObj(LABEL("-2"),
					      [Handler("activate",w(~2))],
					      true),
				     EntryObj(LABEL("-1"),
					      [Handler("activate",w(~1))],
					      true),
				     EntryObj(SEP,[],true),
				     EntryObj(LABEL("+1"),
					      [Handler("activate",w(1))],
					      true),
				     EntryObj(LABEL("+2"),
					      [Handler("activate",w(2))],
					      true),
				     EntryObj(LABEL("+3"),
					      [Handler("activate",w(3))],
					      true),
				     EntryObj(LABEL("+4"),
					      [Handler("activate",w(4))],
						       true),
				     EntryObj(LABEL("+5"),
					      [Handler("activate",w(5))]
					      ,true),
				     EntryObj(SEP,[],true),
				     EntryObj(LABEL("+10"),
					      [Handler("activate",w(10))],
					      true) 
				     ]
		val depth_item_list = [EntryObj(LABEL("-5"),
					      [Handler("activate",d(~5))],
						       true),
				   EntryObj(LABEL("-4"),
					    [Handler("activate",d(~4))],
					    true),
				   EntryObj(LABEL("-3"),
					      [Handler("activate",d(~3))],
					         true),
				     EntryObj(LABEL("-2"),
					      [Handler("activate",d(~2))],
					      true),
				     EntryObj(LABEL("-1"),
					      [Handler("activate",d(~1))],
					      true),
				     EntryObj(SEP,[],true),
				     EntryObj(LABEL("+1"),
					      [Handler("activate",d(1))],
					      true),
				     EntryObj(LABEL("+2"),
					      [Handler("activate",d(2))],
					      true),
				     EntryObj(LABEL("+3"),
					      [Handler("activate",d(3))],
					      true),
				     EntryObj(LABEL("+4"),
					      [Handler("activate",d(4))],
						       true),
				     EntryObj(LABEL("+5"),
					      [Handler("activate",d(5))]
					      ,true),
				     EntryObj(SEP,[],true),
				     EntryObj(LABEL("+10"),
					      [Handler("activate",d(10))],
					      true) 
				     ]
	in
	case n of
	Node.RelNode _ => ()
      | Node.RelRefNode _ => ()
      | _ =>
	Server.serve (fn () => 
	       (createMenu
		(PopupObj
		 [MenuObj{title = "Explore Tree",
			  items = [MenuObj
				   {title = "width",
				    items = width_item_list,
				    sensitive = true},
				   MenuObj
				   {title = "depth",
				    items = depth_item_list,
			  sensitive = true}],
			  sensitive = true},
		  MenuObj{title = "Filter",
			  items = [],
			  sensitive = true},
		  MenuObj{title = "Actions",
			  items = [EntryObj(LABEL("reinspect"),
					    [Handler("activate",r)],
					    reinspect_active),
				  EntryObj(LABEL("force evaluation"),
					   [Handler("activate",f)],
					   force_active),
				   EntryObj(LABEL("delete tree"),
					    [Handler("activate",
					   fn _ => deleteNodeTree n)],
					    delete_active)],
			  sensitive = true}])
		;()))
	end

(* Handelt Mouseclick *)
     fun handleEvent event = Server.serve (fn () =>
     let
	 val font_width = !Settings.fontWidth
	 val font_height = !Settings.fontHeight  
	 val position = getMouseClickEventInfo(event,hadj,vadj) (* uses Gdk datatype -> GtkSupport *)
     in
	case position of 
	  SOME ((x,y),b)=> 
		let 
		    val node = search(x,y)      
		in 
		    (case node of 
			    SOME(n) => 
				let 
				    val ydim =Node.get_ydim(n) 
				    val group = Node.getGroup(n)
				    val x2 = Real.fromInt(font_width 
					    	* Node.get_xdim(n))
				    val y2 = Real.fromInt(font_height 
						  * ydim)
				    val y2' = Real.fromInt(font_height 
						  * (ydim-1))
				    val lx =Real.fromInt(font_width 
				     *  Node.get_l_xdim(n))
				    val re =createRectangle(group,
							    0.0,
							    0.0,
							    lx,
							    y2)
				    val re' = createRectangle(group,
							    0.0,
							    0.0,
							    x2,
							    y2')
				in                                             
				    (  postT n   
				    ; itemLowerToBottom(re) 
				    ; itemLowerToBottom(re') 
				    ; destroySelectionMarkings()
				    ; selection := SOME (n,re,re') 
				    ; setSelectionMenuSensitive(bar,true)
				    ; case n of
				     Node.Limit(_) => 
					 setExpandSensitive(bar,true)
				       | _ => setExpandSensitive(bar,false)
				    ; case b of
				       1 => ()
				    |  3 =>( makePopup n; ())
				    | _   => () ) 
				end
			  | NONE => ( setSelectionMenuSensitive(bar,false)
				     ; destroySelectionMarkings()
					 ; selection := NONE))
		    end
        | NONE => ()
     end)

(* Handlet Tastendruck *)
     fun handleWindowEvent event = 
	 Server.serve (fn () => handleGdkKeyPress(event,scrolled,hadj,vadj,!Settings.max_x,!Settings.max_y))

(**************************************************************************)

 fun new _ = if !alive then()
     else
	let
	    val _ = if !canvas =GtkSupport.uglyNULL
			then ()
		    else objectDestroy(!canvas)
	    structure DA  =  MkDrawingArea(val xsize = !Settings.max_x 
					   val ysize = !Settings.max_y) 
		                           : DRAWING_AREA
	in
	    (canvas := DA.canvas
	    ;canvasroot := DA.root
	    ;resize :=  (handleResize(scrolled,hadj,vadj,DA.resize))
	    ;Update.resize := !resize
	    ;containerAdd(scrolled,DA.canvas)
	    ;signalConnect(scrolled,"size_allocate",
				 fn _ => !resize())
	    ;signalConnect(hadj,"value_changed",fn _ => 
			      freezeThaw(DA.canvas))
	    ;signalConnect(vadj,"value_changed",fn _ => 
			      freezeThaw(DA.canvas)) 
	    ;signalConnect(DA.canvas,"event",handleEvent)
	    ;widgetShowAll(window)
	    ; alive :=true) 
	end

 val _ = new()

     val _ = (windowSetTitle (window, "Alice Browser V 0.2")
	      ; widgetSetUsize (window, 200, 100) 
	      ; windowSetDefaultSize(window, 500,400)
	      ;signalConnect (window, "delete-event", DeleteWindow)
	      ;setSelectionMenuSensitive (bar,false)  
	      ;containerAdd(window,createVBox[(bar,
						    false (* 0 *)
						   ,false (* 0 *),
						    0),
						  (scrolled,
						   (* Gtk.EXPAND *) true,
						   (* Gtk.FILL *) true,0),
						  (status,(*  0 *) 
						   false ,
						  (*  0 *)
						  false  ,0)])
	      ;signalConnect(window,"event",handleWindowEvent))

(**** Initialisierung ****)

     

     val path_promise = NewNode.lookupPath(NewNode.coreSign,
					   "Promise","promise")   
	 
     val path_package = NewNode.lookupPath(NewNode.packageSign,
					   "Package","package") 
	 
     val path_val_package = NewNode.lookupPath(NewNode.packageSign,
					       "Package","val_package") 

     fun init () = ( registerType(path_int, createInt)
		   ; registerType(path_string, createString)
		   ; registerType(path_char, createChar)
		   ; registerType(path_word, createWord)
		   ; registerType(path_real, createReal)
		   ; registerType(path_exn, createExn)
		   ; registerType(path_ref, createRef)
		   ; registerType(path_vec, createVector)
		   ; registerType(path_array, createArray)
                   ; registerType(path_promise, createPromise)
                   ; registerType(path_package, createPackage)  
		   ; registerType(path_val_package, createValPackage) 
 
		   ; registerColor(INT_COLOR,  allocColor(0,45000,0))
		   ; registerColor(REAL_COLOR, allocColor(0,45000,0))
		   ; registerColor(CHAR_COLOR, allocColor(45000,0,50000))     
		   ; registerColor(STR_COLOR, allocColor(45000,0,50000)) 
		   ; registerColor(WORD_COLOR, allocColor(0,43000,0))
		   ; registerColor(EXN_COLOR,  allocColor (60000,40000,0))
		   ; registerColor(REF_COLOR, allocColor(0,0,0))
		   ; registerColor(LABEL_COLOR, allocColor (0,10000,65535))
		   ; registerColor(SEP_COLOR, allocColor(0,0,0))
	           ; registerColor(EQU_COLOR, allocColor(0,0,0))
	           ; registerColor(LIMIT_COLOR, allocColor (10000,60000,10000))
	           ; registerColor(BRACK_COLOR, allocColor (0,5000,47000))
	           ; registerColor(REL_COLOR, allocColor (60000,20000,0))
	           ; registerColor(DEFAULT, allocColor(0,0,0)) 
	           
	           ; Update.incrActLine := (fn dy => incr_act_line dy) )

(**** Ende Initialisierung ****)

fun setVisible (x,y) = let
			   val w = !Settings.fontWidth
			   val h = !Settings.fontHeight
			   val rx =  Real.fromInt(w * x)
			   val ry =  Real.fromInt(h * y)
		       in
			   (if Real.> (rx,!(Settings.max_x)) 
				then Settings.max_x := rx 
			    else ()
			    ;Settings.max_y := 
				Real.+(!Settings.max_y,ry))
		       end



(********** Inspizieren **********)

    fun inspect(v,t) = 
	let
	    val va = UnsafeValue.cast v: Reflect.value
	    val i = Dictionaries.Main.
		        getHighestIndexAssigned(Dictionaries.maindict) +1
	    val root = (new()
			; Dictionaries.RelMan.update(Dictionaries.reldict,(i,[(V va,ref 0,0)]))
			; relnumber := 0
			;!canvasroot)
	    val save_settings = (!Settings.max_width,!Settings.max_depth)
	    val n = (stopButtonSetActive(true)
		     ;NewNode.newNode(va,t,i,root))
            val line = (stopButtonSetActive(false)
			;Settings.set_width(#1(save_settings))
			;Settings.set_width(#2(save_settings))
			;Settings.set_depth
			;Layout.layout(n)
			;setVisible(get_xdim(n),get_ydim(n)+1)
			;createSepLine(root,!act_line,canvaswidth(hadj),
				       Settings.getFontHeight()))
	in
	    ( DrawNodes.draw(n,0,!act_line,false)
	    ; incr_act_line(get_ydim(n) + 1)
	    ; TextIO.print ("Widget: changing actline by " 
			    ^ Int.toString (get_ydim(n)+1)
			    ^ "\n")
	    ; (!resize)()
	    ; show()
	    ; Dictionaries.Main.insertI(Dictionaries.maindict,(n,line)); ())
	end 
			   
    fun inspectInf(v,t) = 
	let
	    val va = UnsafeValue.cast v: Reflect.module
	    val i = Dictionaries.Main.
		        getHighestIndexAssigned(Dictionaries.maindict) +1
	    val root = (new();stopButtonSetActive(true)
			; Dictionaries.RelMan.update(Dictionaries.reldict,(i,[(M va,ref 0,0)]))
			; relnumber := 0
			;!canvasroot)
	    val save_settings = (!Settings.max_width,!Settings.max_depth)
	    val n = (stopButtonSetActive(true)
		     ;NewNode.newNodeInf(va,t,i,root))
            val line =(stopButtonSetActive(false) 
		       ;Settings.set_width(#1(save_settings))
		       ;Settings.set_width(#2(save_settings))
		       ;Layout.layout(n)
		       ;setVisible(get_xdim(n),get_ydim(n)+1)
		       ;createSepLine(root,!act_line,canvaswidth(hadj),
				      Settings.getFontHeight() ))
	in
	    ( DrawNodes.draw(n,0,!act_line,false)
	    ; incr_act_line(get_ydim(n) + 1)
	    ; setVisible(get_xdim(n),get_ydim(n)+1)
	    ; (!resize)()
            ; show()
	    ; stopButtonSetActive(false)
	    ; Dictionaries.Main.insertI(Dictionaries.maindict,(n,line)); ())
	end 
   
	 
end (* structure Widget end *)

end (* local end *)
