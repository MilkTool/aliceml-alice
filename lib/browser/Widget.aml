(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure TextIO from "x-alice:/lib/system/TextIO"
import structure PrettyPrint from "x-alice:/lib/utility/PrettyPrint"
import structure PPType from "x-alice:/lib/rtt/PPType"
import structure PervasiveType from "x-alice:/lib/rtt/PervasiveType"
import structure PPInf from "x-alice:/lib/rtt/PPInf"
import structure UnsafeValue from "x-alice:/lib/system/UnsafeValue"
import structure Gtk from "x-alice:/lib/gtk/Gtk"
import structure Gdk from "x-alice:/lib/gtk/Gdk"
import structure GtkCanvas from "x-alice:/lib/gtk/GtkCanvas"

import structure Node from "Node"
import structure Doc from "Doc"
import structure Color from "Color"
import structure MkDrawingArea from "MkDrawingArea"
import signature DRAWING_AREA from "DRAWING_AREA-sig"
import structure GtkSupport from "GtkSupport"
import structure Settings from "Settings"

import structure Dictionaries from "Dictionaries"

import structure NewNode from "NewNode"
import structure Layout from "Layout"
import structure DrawNodes from "DrawNodes"
import structure Update from "Update"
import structure Server from "Server"

import signature WIDGET from "WIDGET-sig"

local 
open GtkSupport Node Doc Color PervasiveType

(*********** Knotensuche ***************)

    exception NodeFound of node
    exception unknown

    fun inBoundingBox (node,x,y) = 
	let
	    val xdim = get_xdim(node)
	    val ydim = get_ydim(node)
	    val _ =  () (* TextIO.print("Simple search with x=" 
					 ^ Int.toString(x)
					 ^ " and y="
					 ^ Int.toString(y)
					 ^ "\n")  *)
	in  
	    x >= 0 
	    andalso y >= 0
	    andalso x < xdim
	    andalso y < ydim
	end

    fun isInterpunct node = case getDesc(node) 
	of INTERPUNCT => true
      | _ => false

    fun interpunctMayBeSelected (Limit _ | RelNode _ | RelRefNode _ ) = true
      | interpunctMayBeSelected  _ = false

    fun justifyFound (node,SOME(n) as found) =if isInterpunct(node)
					     then if node = n 
					     	 then SOME(getParent(node))
						     else found
					    else found
      | justifyFound (node,NONE)     = NONE

    fun treeSearch ((Simple _ as node | Limit _ as node),x,y)  = 
	if inBoundingBox(node,x,y) then 
	    if not(isInterpunct node) 
		orelse (interpunctMayBeSelected node)
		orelse (getParent(node) = Empty) 
		then SOME(node)
		    else SOME(getParent(node))
	else NONE
      | treeSearch (RelRefNode _ as node,x,y) = if inBoundingBox(node,x,y) 
						then SOME(node)
						    else NONE
      | treeSearch (RelNode(r) as node,x,y) =  (case !(#counter(r)) of
			  1  =>  treeSearch(!(#content(r)),x,y)
			| _  =>  let
				     val labellength =  String.size(#rep(r))
				     val label_in_bb = x>=0
					 andalso x < labellength
					 andalso y = 0
				 in
				     if label_in_bb then SOME(node) 
					 else treeSearch(!(#content(r)),
							 x - labellength,
							 y)
				 end)
      | treeSearch (Concat(r) as node,x,y) =
	    let
		val _ = () (* TextIO.print("Concat search with x=" 
				     ^ Int.toString(x)
				     ^ " and y="
				     ^ Int.toString(y)
				     ^ "\n")  *)
	    in
		if inBoundingBox(node,x,y) 
		    then let
			     val hor_funct =
				 (fn (a,(curx,cury)) =>
				  (case treeSearch(a,curx,cury) of
				       SOME(n) => raise NodeFound(n)
				     | NONE    => let
					   val c = curx -  get_xdim(a)
					   val _ =  () (* TextIO.print("curx is "
							^ Int.toString(c)
							^ "\n") *)
						  in
					   (case a of
						Container(r) => 
						    if setsVertical(a) 
							then
					  (curx - get_l_xdim(a)
					   , cury - get_ydim(a) +1)
						    else 
					  (curx -  get_l_xdim(a) (*was xdim *)
					   ,cury)
					| Empty => (curx,cury)
					| _ => 
			     (curx - get_l_xdim(a) (* was xdim *) 
					     ,cury- get_ydim(a) +1 ))
						  end))
			     val found = (Array.foldl hor_funct (x,y)	
					  (getKids(node)); NONE)
				 handle NodeFound(n) => SOME(n)
			 in
			    justifyFound(node,found)
			 end
	    else NONE
	    end
      | treeSearch (Container(r) as node,x,y) = 
		let
		    val _ =  () (* TextIO.print("Container search with x=" 
					 ^ Int.toString(x)
					 ^ " and y="
					 ^ Int.toString(y)
					 ^ "\n")  *)
			in
		if inBoundingBox(node,x,y) 
		    then let
			     val hor_funct =
				 (fn (a,curx) =>
				  (case treeSearch(a,curx,y) of
				       SOME(n) => raise NodeFound(n)
				     | NONE    => 
					   (curx -  get_xdim(a))))
			     val ver_funct =
				 (fn (a,cury) =>
				  (case treeSearch(a,x,cury) of
				       SOME(n) => raise NodeFound(n)
					 | NONE    => 
					   (cury -  get_ydim(a))))
			     val found = (if setsVertical(node)
					      then (Array.foldl ver_funct y 
						  (getKids(node));NONE)
					  else (Array.foldl hor_funct x 
					      (getKids(node));NONE))
				 handle NodeFound(n) => SOME(n)
			 in
			      justifyFound(node,found)
			 end
		else NONE
		end
      | treeSearch _ = NONE

    fun iterate (dict,x,y,i,highest_i) = 
	if i > highest_i 
	    then NONE
	else
	    case Dictionaries.Main.lookup(Dictionaries.maindict,i) of
		NONE => iterate(dict,x,y,i+1,highest_i)
	      | SOME (node,line) =>( case treeSearch(node,x,y) 
		    of
			NONE => iterate (dict,
					 x,
					 y-get_ydim(node)-1,
					 i+1,
					 highest_i)
		      | SOME n => ( case getParent(n) of
				    RelNode(r) 
				    => if !(#counter(r)) = 1
					   then SOME n
				       else SOME (getParent(n))
                                  | _ => SOME n))
	      |_ => NONE
				   
						     
    fun search (real_x, real_y) = 
	let
	    val int_x = (Real.trunc(real_x))
	    val font_width = !Settings.fontWidth
	    val x = int_x div font_width
	    val int_y = (Real.trunc(real_y))
	    val font_height = !Settings.fontHeight
	    val y = int_y div font_height
	    val highest_i = Dictionaries.Main.getHighestIndexAssigned(Dictionaries.maindict)
	    val _ = () (* TextIO.print("searching for x:" 
			^ Int.toString(x) ^ " and y:" ^Int.toString(y)
			^ " \n") *)
	in
	   iterate (Dictionaries.maindict,x,y,0,highest_i)
	end

(*********** Ende Knotensuche ***************)


(* "About..."-WindowHandler *)
fun about _ = Server.serve (fn () =>  
     let
	 val dialog = Gtk.dialogNew()
	 val ddialog = (fn _ =>  Gtk.widgetDestroy(dialog)) 
	 val ok = createButton(BObj("ok",[Handler("clicked",ddialog)]))
	 val l = 
		      Gtk.labelNew("Alice Browser \n"
				   ^ "Created by \n"
				   ^ "Bernadette Blum & Marvin Schiller")
     in
	( Gtk.windowSetTitle(dialog,"information")
	 ; Gtk.containerAdd((Gtk.dialogGetFieldActionArea(dialog)),
			    ok)
	 ; Gtk.containerAdd((Gtk.dialogGetFieldVbox(dialog)),l)
	 ;Gtk.widgetShowAll(dialog))
     end)  



(* Hilfsprozedur fuer setSelectionMenuSensitive *)
fun getSelectionMenu bar = 
    let
	val menu_heading_items = UnsafeValue.cast 
		(Gtk.containerChildren(bar)) : Gtk.object list
	val menu_heading_selection = List.nth(menu_heading_items,1)
	val submenu = Gtk.menuItemGetFieldSubmenu(menu_heading_selection)
    in
	(menu_heading_selection,submenu)
    end

(* Switches "selection" menu on/off *)
fun setSelectionMenuSensitive (bar,sensitive) = 
    let
	val (menu_heading_selection,submenu) = getSelectionMenu bar
	val selection_menu = hd
		(UnsafeValue.cast 
		 (Gtk.containerChildren(menu_heading_selection)) 
		 : Gtk.object list)    
    in
	(setSensitive(selection_menu,sensitive)
	 ;setSensitive(submenu,sensitive))
    end

fun setExpandSensitive (bar,sensitive)= 
    let
	val (menu_heading_selection,submenu) = getSelectionMenu bar
	val children = UnsafeValue.cast 
		(Gtk.containerChildren(submenu)) : Gtk.object list
	val expand = List.nth(children,0)
    in
	setSensitive(expand,sensitive)
    end

val selection = ref NONE
    
fun destroySelectionMarkings () = case !selection of 
    NONE => ()
  | SOME(_,rect,rect') =>( Gtk.objectDestroy(rect)
			  ; Gtk.objectDestroy(rect'))


fun getSelectionNode() = case !selection of 
    NONE => Node.Empty
  | SOME(n,_,_) => n  



fun  resizeSepLinesIterate(dict,x,i,highest_i) =
     if i > highest_i 
	 then ()
     else 
	 (case Dictionaries.Main.lookup(dict,i) of
	      NONE =>
		  resizeSepLinesIterate(dict,x,i+1,highest_i)
	    | SOME (_,line) => 
		  if line = uglyNULL 
		      then  resizeSepLinesIterate(dict,x,i+1,highest_i)
		  else

(* this can go to GtkSupport *)
		      let
			  val (rx1,ry1,rx2,ry2) = 
			      GtkCanvas.itemGetBounds(line, 0.0,
						      0.0,
						      0.0,
						      0.0)
			  val y1 = Real.trunc(Real.+(ry1,1.0))
		      in
			  (GtkCanvas.itemSet(line,
					     "points", 
					     Gdk.POINTS ([0, y1, x, y1]))
			      ;  resizeSepLinesIterate(dict,x,i+1,highest_i))
		      end
(* this can go to GtkSupport *)
)

fun resizeSepLines (dict,rx) = 
     let 
	 val x = Real.trunc rx
	 val highest_i = Dictionaries.Main.getHighestIndexAssigned(dict)
     in
	 resizeSepLinesIterate(dict,x,0,highest_i)
     end

(* invokes canvas resize *)	
fun handleResize (scrolled,hadj,vadj,resize) = (fn _ =>  Server.serve (fn () => let
	                     val page_sh = Gtk.adjustmentGetFieldPageSize(hadj)
			     val upperh = Gtk.adjustmentGetFieldUpper(hadj)
			     val valueh = Gtk.adjustmentGetFieldValue(hadj)
			     val upperv = Gtk.adjustmentGetFieldUpper(vadj)
			     val valuev = Gtk.adjustmentGetFieldValue(vadj) 
			     val page_sv = Gtk.adjustmentGetFieldPageSize(vadj)
			     val h = if (Real.< (page_sh,(!(Settings.max_x)))) 
					 then !(Settings.max_x) else page_sh 
			     val v = if (Real.< (page_sv,(!(Settings.max_y)))) 
					 then !(Settings.max_y) else page_sv
			   in
			       (resize(h,v,scrolled,valueh,valuev  )
				; resizeSepLines(Dictionaries.maindict,
							  h)
				; ())
			 end))

(* Scrolling *)
fun scrollX (x,scrolled,hadj) = 
    let
	val valueh = Gtk.adjustmentGetFieldValue(hadj)
	val pages =  Gtk.adjustmentGetFieldPageSize(hadj)
    in
	( if Real.> (Real.+(Real.+(valueh,x),pages),!Settings.max_x)
	      then  Gtk.adjustmentSetValue(hadj,Real.-(!Settings.max_x,pages))
	  else Gtk.adjustmentSetValue(hadj,Real.+(valueh,x))
	      ;())
    end

fun scrollY (y,scrolled,vadj) = 
    let
	val pages =  Gtk.adjustmentGetFieldPageSize(vadj)
	val valuev = Gtk.adjustmentGetFieldValue(vadj)
    in
	( if Real.>(Real.+(Real.+(valuev,y),pages),!Settings.max_y) 
	      then  Gtk.adjustmentSetValue(vadj,Real.-(!Settings.max_y,pages))
	  else  Gtk.adjustmentSetValue(vadj,Real.+(valuev,y))
	      ;())
    end 

(* Popup window for selection *)
 fun makePopup {node = n, widthhandler = w, depthhandler = d, 
		   reinspecthandler = r, forcehandler = f} = 
	let 
	    val reinspect_active = not(Node.getDesc(n) = Node.INTERPUNCT)
	    val force_active = (Node.isByneed n) handle _ => false 
	    val width_item_list = [EntryObj(LABEL("-5"),
					      [Handler("activate",w(~5))],
						       true),
				   EntryObj(LABEL("-4"),
					    [Handler("activate",w(~4))],
					    true),
				   EntryObj(LABEL("-3"),
					      [Handler("activate",w(~3))],
					         true),
				     EntryObj(LABEL("-2"),
					      [Handler("activate",w(~2))],
					      true),
				     EntryObj(LABEL("-1"),
					      [Handler("activate",w(~1))],
					      true),
				     EntryObj(SEP,[],true),
				     EntryObj(LABEL("+1"),
					      [Handler("activate",w(1))],
					      true),
				     EntryObj(LABEL("+2"),
					      [Handler("activate",w(2))],
					      true),
				     EntryObj(LABEL("+3"),
					      [Handler("activate",w(3))],
					      true),
				     EntryObj(LABEL("+4"),
					      [Handler("activate",w(4))],
						       true),
				     EntryObj(LABEL("+5"),
					      [Handler("activate",w(5))]
					      ,true),
				     EntryObj(SEP,[],true),
				     EntryObj(LABEL("+10"),
					      [Handler("activate",w(10))],
					      true) 
				     ]
		val depth_item_list = [EntryObj(LABEL("-5"),
					      [Handler("activate",d(~5))],
						       true),
				   EntryObj(LABEL("-4"),
					    [Handler("activate",d(~4))],
					    true),
				   EntryObj(LABEL("-3"),
					      [Handler("activate",d(~3))],
					         true),
				     EntryObj(LABEL("-2"),
					      [Handler("activate",d(~2))],
					      true),
				     EntryObj(LABEL("-1"),
					      [Handler("activate",d(~1))],
					      true),
				     EntryObj(SEP,[],true),
				     EntryObj(LABEL("+1"),
					      [Handler("activate",d(1))],
					      true),
				     EntryObj(LABEL("+2"),
					      [Handler("activate",d(2))],
					      true),
				     EntryObj(LABEL("+3"),
					      [Handler("activate",d(3))],
					      true),
				     EntryObj(LABEL("+4"),
					      [Handler("activate",d(4))],
						       true),
				     EntryObj(LABEL("+5"),
					      [Handler("activate",d(5))]
					      ,true),
				     EntryObj(SEP,[],true),
				     EntryObj(LABEL("+10"),
					      [Handler("activate",d(10))],
					      true) 
				     ]
	in
	case n of
	Node.RelNode _ => ()
      | Node.RelRefNode _ => ()
      | _ =>
	Server.serve (fn () => 
	       (createMenu
		(PopupObj
		 [MenuObj{title = "Explore Tree",
			  items = [MenuObj
				   {title = "width",
				    items = width_item_list,
				    sensitive = true},
				   MenuObj
				   {title = "depth",
				    items = depth_item_list,
			  sensitive = true}],
			  sensitive = true},
		  MenuObj{title = "Filter",
			  items = [],
			  sensitive = true},
		  MenuObj{title = "Actions",
			  items = [EntryObj(LABEL("reinspect"),
					    [Handler("activate",r)],
					    reinspect_active),
				  EntryObj(LABEL("force evaluation"),
					   [Handler("activate",f)],
					   force_active)],
			  sensitive = true}])
		;()))
	end

 fun calcAbsoluteMousePointerPosition(x,y,hadj,vadj) = 
     let
	 val valueh = Gtk.adjustmentGetFieldValue(hadj)
	 val valuev = Gtk.adjustmentGetFieldValue(vadj) 
	 val x = Real.+ (x,valueh)
	 val y = Real.+ (y,valuev)
     in
	 (x,y)
     end

in

structure Widget :> WIDGET =
struct

    val window = Gtk.windowNew Gtk.WINDOW_TOPLEVEL

    val canvas = ref GtkSupport.uglyNULL
    val canvasroot = ref GtkSupport.uglyNULL
    val resize = ref (fn () => ())
    val alive = ref false
    val act_line = ref 0

    fun incr_act_line dy = (TextIO.print("Widget: actline was: "
					 ^Int.toString(!act_line))
			    ;act_line := !act_line + dy
			    ; TextIO.print(" and now is "
					   ^ Int.toString(!act_line)^"\n"))

    fun Delete _ = (Gtk.widgetHideAll(window)
		    ;Settings.max_x :=0.0
		    ;Settings.max_y :=0.0
		    ;Dictionaries.Main.dumpAll(Dictionaries.maindict)
		    ;Dictionaries.RelMan.dumpAll(Dictionaries.reldict)
		    ;act_line := 0
		    ;alive:= false)

    val (status,postType,postMode) = createStatusbar() 
	 
    val (scrolled,hadj,vadj) =  createScrollWindowDefaults(20.0,50.0)

 fun freezeThaw(x) = (Gtk.layoutFreeze(x)
			  ; Gtk.layoutThaw(x))

     fun show() = if !alive then Gtk.widgetShowAll(window) else ()
    
     val stopButtonActive = ref false

     val stopButton = let
			  val button = Gtk.menuItemNewWithLabel("stop") 
		      in
			  (GtkSupport.setSensitive(button,false) 
			   ;Gtk.signalConnect
			   (button,
			    "activate",
			    fn _ => (stopButtonActive := false
				     ;GtkSupport.setSensitive(button,false)))
			   ;button)
		      end

     fun stopButtonIsActive() = !stopButtonActive
		  
     fun stopButtonSetActive b =  
	 (stopButtonActive := b
	  ;GtkSupport.setSensitive(stopButton,b )
	  ; TextIO.print("Stop Button now active: "^Bool.toString(b) ^ "\n")  )

     fun setStopButtonOnOff(f,n) = 
	 (Server.serve(fn() => stopButtonSetActive(true))
	  ;f n
	  ; TextIO.print("STOP_BUTTON: f n done\n")
	  ; Server.serve(fn() => stopButtonSetActive(false)))
	 

     exception stopped

     fun testIfStop() = if not(stopButtonIsActive()) then raise stopped
			else ()
		    
     fun handleReinspect node = 
	 let
	     val update_reinspect = fn (n,_) => Update.reinspect(n,NewNode.createGraph,
								 NewNode.createGraphInf,!canvasroot)
	 in
	     fn _ => ( setStopButtonOnOff(update_reinspect,(node,0)) )
	 end
     
    fun handleReinspectSelection _ = 
	let
	    val update_reinspect = 
		fn (n,_) => Update.reinspect(n,NewNode.createGraph,
					     NewNode.createGraphInf,!canvasroot)
	in
	    setStopButtonOnOff(update_reinspect, (getSelectionNode(),0))
	end
    
  
     fun handleShrinkSelection _  = 
	 let
	 val update_shrink 
	     = fn (n,_)  => let val diff = getDepth(n) - 
	     Update.findHighestDepth n
			    in if diff >= 0 
				   then ()
			       else Update.foldDepth(n,diff-1,NewNode.createGraph,
						     NewNode.createGraphInf,!canvasroot)
			    end
	 in
	     setStopButtonOnOff(update_shrink, (getSelectionNode(),0))
	 end

     fun handleExpandSelection _  = 
	 let
	     val update_expand =  fn (n,_) 
			     => Update.foldDepth(n,1,NewNode.createGraph,
						 NewNode.createGraphInf,!canvasroot)
	 in
	 setStopButtonOnOff(update_expand, (getSelectionNode(),0))
	 end

     fun handleWidth node =  
	 let
	     val update_width = fn (n,i) => (print "starting width !!!!!\n"
					     ;Update.foldWidth(n,i,NewNode.createGraph,
							       NewNode.createGraphInf,!canvasroot))
	 in
	     fn i => fn _ => setStopButtonOnOff(update_width,(node,i))
	 end
     
     fun handleDepth node =
	 let
	     val update_depth = fn (n,i) => (print "starting depth !!!!\n"
					     ;Update.foldDepth(n,i,NewNode.createGraph,
							       NewNode.createGraphInf,!canvasroot))
	 in
	     fn i => fn _ => setStopButtonOnOff(update_depth,(node,i))
	 end

     fun handleForce node _ = 
	 let
	     val update_force =  fn (n,_) 
			     => let val b_future = case getDesc n of  
				    VALUE(r) => UnsafeValue.cast (#value(r)) 
				  | I_VALUE(r) => UnsafeValue.cast (#value(r)) 
                                  | _ => raise Match 
				in Future.await(b_future) 
				end
	 in
	     setStopButtonOnOff
	     (update_force, (getSelectionNode(),0))
	 end
(*
(* dient zur Aenderung der font-Groesse *)
     fun updateIterate(i,no,diffh) = 
	 if (* i > MainDictionary.getHighestIndexAssigned(Dictionaries.dict) *)
	     i < 0 
	     then ()
	 else
	     case MainDictionary.lookup(Dictionaries.dict,i) of
		 NONE => updateIterate(i-1,no,diffh)
	       | SOME (node,line) =>	 
			    ((selectHandler "reinspect") (node,0)
			     ; GtkSupport.move(Node.getGroup(node),0.0,
					       Real.fromInt(diffh * no))

				      ; updateIterate(i-1,no+1,diffh))
	       |_ => () *)

     (* Handles ok Button in Preferences Window *)
     fun okHandler(w,
	      width_s,
	      depth_s,
	      font_s,
	      treemode_button,
	      relmode_button, 
	      tokenmode_button) = (fn _ => 
	       		   ( (* let
				val fontname = Gtk.fontSelectionGetFontName
				    (fontpicker)
			    in
				(Settings.fontname := fontname
				;Settings.font:= Gdk.fontLoad(fontname)
				;Settings.fontHeight :=
				 (Gdk.fontGetFieldAscent(!Settings.font)+
			   Gdk.fontGetFieldDescent(!Settings.font) )
				;Settings.fontWidth:=
				 (Gdk.stringWidth(!Settings.font,"W")))
			    end
			    ;  *) Settings.max_width := 
			    Gtk.spinButtonGetValueAsInt(width_s) 
			    ;Settings.max_depth := 
			    Gtk.spinButtonGetValueAsInt(depth_s)
			    (* Fontgroesse *)
			   (* ;  let
				  val new_size = 
				      Gtk.spinButtonGetValueAsInt(font_s)
			      val old_h =  !Settings.fontHeight
			      in
				  if !Settings.fontSize = new_size then ()
				  else ( changeFontSize(new_size)
				       ; updateIterate
( MainDictionary.getHighestIndexAssigned(Dictionaries.dict),
 !Settings.fontHeight - old_h,0)) 
			      end *)
			    (* Debug Aid *)
			    ;if Gtk.toggleButtonGetActive(relmode_button) = 
			      true
			      (* 1 *)
			      orelse 
			   Gtk.toggleButtonGetActive(tokenmode_button) = 
			       true
			       then print ("Relmode-Button set\n")
				   else print ("Relmode-Button not set\n")
			    ;Settings.relmode := (
			    Gtk.toggleButtonGetActive(relmode_button) = true
						  (* 1 *)
						  orelse 
			   Gtk.toggleButtonGetActive(tokenmode_button) = true 
						  (* 1 *) )
			    ;Settings.tokenmode :=  
			    Gtk.toggleButtonGetActive(tokenmode_button) = true
			    (* 1 *)
			    ;Gtk.widgetDestroy(w)
			    ;if 
			    Gtk.toggleButtonGetActive(treemode_button) = true 
			    (* 1 *)
				 then (Dictionaries.RelMan.dumpAll
				       (Dictionaries.reldict)
				       ; relnumber := 0)
			     else ()))

     (* Preferences Window Handler *)
     fun Preferences _ = Server.serve (fn () =>
       	   let	
           (* Width & Depth Settings *)
	   val width_lab = Gtk.labelNew("Set Width Limit to...")	       
	   val width_s = createSpinButton{init =(!Settings.max_width) , 
					   lower = 0, 
					   upper = 100, 
					   inc = 1, 
					   dec = 0}
	    val depth_s = createSpinButton{init =(!Settings.max_depth) , 
					   lower = 0, 
					   upper = 100, 
					   inc = 1, 
					   dec = 0}
	    val depth_lab = Gtk.labelNew("Set Depth Limit to...")
	    val table = createTable{rows = 2, cols = 4, 
				    entries = [(width_lab,0,2,0,1),
				     (width_s,2,3,0,1),
				     (depth_lab,0,2,1,2),
				     (depth_s,2,3,1,2)]}
	    val frame = createFrame("",table)
	    (* Mode Settings *)
	    val treemode_button = Gtk.radioButtonNewWithLabel(uglyNULL, 
       			      "Tree Mode")
	    val group = Gtk.radioButtonGroup(treemode_button)
	    val tokenmode_button = Gtk.radioButtonNewWithLabel(group, 
				"Relational Mode - Token Equality")
	    val group = Gtk.radioButtonGroup(tokenmode_button)
	    val relmode_button = Gtk.radioButtonNewWithLabel(group, 
				"Relational Mode - Structural Equality")
	    val _ = if !Settings.tokenmode 
			then Gtk.toggleButtonSetActive(tokenmode_button,true 
						       (* 1 *) )
		    else if !Settings.relmode then 
			Gtk.toggleButtonSetActive(relmode_button,true 
						  (* 1 *))
			else
			Gtk.toggleButtonSetActive(treemode_button,true (* 1 *))

	    val radiobox = createVBoxDefaults[treemode_button,
					      relmode_button,
					      tokenmode_button]

	    val font_lab = Gtk.labelNew("Set Font Size to...")	
	    val font_s = createSpinButton{init =(!Settings.fontSize) , 
					  lower = 8, 
					   upper = 50, 
					   inc = 1, 
					   dec = 0}
	    val app_table = createTable{rows = 2, cols = 4, 
				    entries = [(font_lab,0,2,0,1),
					       (font_s,2,3,0,1)]}

	   (* val fontpicker = Gtk.fontSelectionNew() *)

	   (*  val colorsel = Gtk.colorSelectionNew() *)

	    (* Buttonbox *)

	    val w = Gtk.windowNew Gtk.WINDOW_TOPLEVEL
	    val bbox = createButtonBox{buttons = 
		      [BObj("ok",[Handler("clicked",
					  (okHandler(w,
						     width_s,
						     depth_s,
						     font_s,
						     treemode_button,
						     relmode_button,
						     tokenmode_button)   ))]),
		       BObj("apply",[]),
		       BObj("cancel",
			    [Handler("clicked",fn _ => 
				     Gtk.widgetDestroy(w))])],
				       borderwidth = 20}

	    val n = createNotebook[("Width & Depth Limit Settings",frame),
				   ("Mode Settings",radiobox),
				   ("Appearance",app_table)  ] 

	    val vbox = createVBoxDefaults[n,bbox]
		in
		    (Gtk.windowSetTitle (w, "Preferences")
		    ;Gtk.windowSetPolicy(w,0,0,1)
	            ;Gtk.containerAdd(w,vbox)
	            ;Gtk.signalConnect (w, "delete-event", 
					fn _ => Gtk.widgetDestroy(w) )
		     ;Gtk.widgetShowAll(w))
	end)


	 (* Menu-Bar *)
     val bar = GtkSupport.createMenu
	 (BarObj[MenuObj
		 {title = "Inspector",
		  items = [EntryObj
			   (LABEL "About...",
			    [Handler("activate",
				    about)],true),
			   EntryObj(SEP,[],true),
			   EntryObj(LABEL "Close",
				    [Handler("activate",
					     Delete)],true)],
		  sensitive = true},
		 MenuObj
		 {title = "Selection",
		  items = [EntryObj(LABEL "Expand",
				    [Handler("activate",
					     handleExpandSelection)]
				    ,true),
			   EntryObj(LABEL "Shrink",
				   [Handler("activate",
					    handleShrinkSelection)]
				    ,true),
			   EntryObj(SEP, [],true),
			   EntryObj(LABEL "Reinspect",
				    [Handler("activate",handleReinspectSelection)]
				    ,true)],
		  sensitive = true}   ,
		 MenuObj
		 {title = "Options",
		  items = [EntryObj(LABEL "Preferences...",
				    [Handler("activate",
					     Preferences)],true)],
		  sensitive = true}]) 

     
		  
	val _ = Gtk.menuBarAppend(bar,stopButton)
	val _ = Gtk.menuItemRightJustify(stopButton)

 
(* Sendet Typinformation eines Knotens an den Statusbar *)
     fun postT n = 
	 let  
	     val desc = Node.getDesc(n)
	 in
	     (case desc of
		 Node.INTERPUNCT => 0
	       |  Node.VALUE(r) => let
					val text = PrettyPrint.toString
					      (PPType.ppTyp(#typ(r)),1000)
				    in
					if
					   (String.size(text)) > 50 
					    then
		     postType("  " 
			      ^String.extract(text, 0,SOME(50)))
		     else
			 postType("  " ^ text)
			 end
	       | Node.I_VALUE(r) =>
		     postType("  " 
			      ^ String.extract(PrettyPrint.toString
					       (PPInf.ppInf(#typ(r)),
						50),0,SOME(50)))
		     ;()) handle _ => ()
	 end
    
(* Handelt Mouseclick *)
     fun handleEvent [Gdk.EVENT(event)] = Server.serve (fn () =>
     let
	 val font_width = GtkSupport.fontWidth()
	 val font_height = GtkSupport.fontHeight()  
     in
	case event of
	  Gdk.GDK_BUTTON_PRESS({button = b, ...} as r) => 
		    let 
			val (x,y) = calcAbsoluteMousePointerPosition(#x(r),
								     #y(r),
								     hadj,
								     vadj)
			val node = search(x,y)      
		    in 
		       (case node of 
			    SOME(n) => 
				let 
				    val ydim =Node.get_ydim(n) 
				    val group = Node.getGroup(n)
				    val x2 = Real.fromInt(font_width 
					    	* Node.get_xdim(n))
				    val y2 = Real.fromInt(font_height 
						  * ydim)
				    val y2' = Real.fromInt(font_height 
						  * (ydim-1))
				    val lx =Real.fromInt(font_width 
				     *  Node.get_l_xdim(n))
				    val re =createRectangle(group,
							    0.0,
							    0.0,
							    lx,
							    y2)
				    val re' = createRectangle(group,
							    0.0,
							    0.0,
							    x2,
							    y2')
				in                                             
				    (  postT n   
				  ; GtkCanvas.itemLowerToBottom(re) 
				 ; GtkCanvas.itemLowerToBottom(re') 
				    ; destroySelectionMarkings()
				    ; selection := SOME (n,re,re') 
				    ; setSelectionMenuSensitive(bar,true)
				    ; case n of
				     Node.Limit(_) => 
					 setExpandSensitive(bar,true)
				       | _ => setExpandSensitive(bar,false)
				    ; case b of
				       1 => ()
				    |  3 => 
					   (makePopup({node = n,
				    widthhandler = handleWidth(n), 
				    depthhandler = handleDepth(n), 
				    reinspecthandler = handleReinspect(n),
				    forcehandler = handleForce(n)})
					    ;())
				    | _   => () ) 
				end
			  | NONE => ( setSelectionMenuSensitive(bar,false)
				     ; destroySelectionMarkings()
					 ; selection := NONE))
		    end
        | _ => ()
     end)

(* Handlet Tastendruck *)
     fun handleWindowEvent [Gdk.EVENT(event)] = 
	 Server.serve (fn () => 
		case event of  
		    Gdk.GDK_KEY_PRESS({keyval = 65361,...}) => 
			scrollX(~10.0,scrolled,hadj) 
		  | Gdk.GDK_KEY_PRESS({keyval = 65363,...}) => 
			scrollX(10.0,scrolled,hadj) 
		  | Gdk.GDK_KEY_PRESS({keyval = 65362,...}) => 
			scrollY(~10.0,scrolled,vadj)    
		  | Gdk.GDK_KEY_PRESS({keyval = 65364,...}) => 
			scrollY(10.0,scrolled,vadj)
		  | _ => () )

     

    
 fun new _ = if !alive then()
     else
	let
	    val _ = if !canvas =GtkSupport.uglyNULL
			then ()
		    else Gtk.objectDestroy(!canvas)
	    structure DA  =  MkDrawingArea(val xsize = !Settings.max_x 
					   val ysize = !Settings.max_y) 
		                           : DRAWING_AREA
	in
	    (canvas := DA.canvas
	    ;canvasroot := DA.root
	    ;resize :=  (handleResize(scrolled,hadj,vadj,DA.resize))
	    ;Update.resize := !resize
	    ;Gtk.containerAdd(scrolled,DA.canvas)
	    ;Gtk.signalConnect(scrolled,"size_allocate",
				 fn _ => !resize())
	    ;Gtk.signalConnect(hadj,"value_changed",fn _ => 
			      freezeThaw(DA.canvas))
	    ;Gtk.signalConnect(vadj,"value_changed",fn _ => 
			      freezeThaw(DA.canvas)) 
	    ;Gtk.signalConnect(DA.canvas,"event",handleEvent)
	    ;Gtk.widgetShowAll(window)
	    ; alive :=true) 
	end

 val _ = new()

     val _ = (Gtk.windowSetTitle (window, "Alice Browser V 0.2")
	      ; Gtk.widgetSetUsize (window, 200, 100) 
	      ; Gtk.windowSetDefaultSize(window, 500,400)
	      ;Gtk.signalConnect (window, "delete-event", Delete)
	      ;setSelectionMenuSensitive (bar,false)  
	      ;Gtk.containerAdd(window,createVBox[(bar,
						    false (* 0 *)
						   ,false (* 0 *),
						    0),
						  (scrolled,
						   (* Gtk.EXPAND *) true,
						   (* Gtk.FILL *) true,0),
						  (status,(*  0 *) 
						   false ,
						  (*  0 *)
						  false  ,0)])
	      ;Gtk.signalConnect(window,"event",handleWindowEvent))

(**** Initialisierung ****)

     

     val path_promise = NewNode.lookupPath(NewNode.coreSign,
					   "Promise","promise")   
	 
     val path_package = NewNode.lookupPath(NewNode.packageSign,
					   "Package","package") 
	 
     val path_val_package = NewNode.lookupPath(NewNode.packageSign,
					       "Package","val_package") 

     fun init () = ( registerType(path_int, createInt)
		   ; registerType(path_string, createString)
		   ; registerType(path_char, createChar)
		   ; registerType(path_word, createWord)
		   ; registerType(path_real, createReal)
		   ; registerType(path_exn, createExn)
		   ; registerType(path_ref, createRef)
		   ; registerType(path_vec, createVector)
		   ; registerType(path_array, createArray)
                   ; registerType(path_promise, createPromise)
                   ; registerType(path_package, createPackage)  
		   ; registerType(path_val_package, createValPackage) 
 
		   ; registerColor(INT_COLOR,  allocColor(0,45000,0))
		   ; registerColor(REAL_COLOR, allocColor(0,45000,0))
		   ; registerColor(CHAR_COLOR, allocColor(45000,0,50000))     
		   ; registerColor(STR_COLOR, allocColor(45000,0,50000)) 
		   ; registerColor(WORD_COLOR, allocColor(0,43000,0))
		   ; registerColor(EXN_COLOR,  allocColor (60000,40000,0))
		   ; registerColor(REF_COLOR, allocColor(0,0,0))
		   ; registerColor(LABEL_COLOR, allocColor (0,10000,65535))
		   ; registerColor(SEP_COLOR, allocColor(0,0,0))
	           ; registerColor(EQU_COLOR, allocColor(0,0,0))
	           ; registerColor(LIMIT_COLOR, allocColor (10000,60000,10000))
	           ; registerColor(BRACK_COLOR, allocColor (0,5000,47000))
	           ; registerColor(REL_COLOR, allocColor (60000,20000,0))
	           ; registerColor(DEFAULT, allocColor(0,0,0)) 
	           
	           ; Update.incrActLine := (fn dy => incr_act_line dy) )

(**** Ende Initialisierung ****)

(********** Inspizieren **********)
    fun inspect(v,t) = 
	let
	    val i = Dictionaries.Main.
		        getHighestIndexAssigned(Dictionaries.maindict) +1
	    val root = (new();stopButtonSetActive(true)
			; Dictionaries.RelMan.update(Dictionaries.reldict,(i,nil))
			; relnumber := 0
			;!canvasroot)
	    val n = NewNode.newNode(v,t,i,root)	
            val line = createSepLine(root,!act_line)
	in
	    ( Layout.layout(n)
	    ; DrawNodes.draw(n,0,!act_line,false)
	    ; incr_act_line(get_ydim(n) + 1)
	    ; TextIO.print ("Widget: changing actline by " 
			    ^ Int.toString (get_ydim(n)+1)
			    ^ "\n")
	    ; Layout.setVisible(get_xdim(n),get_ydim(n)+1)
	    ; (!resize)()
	    ; show()
	    ; stopButtonSetActive(false)
	    ; Dictionaries.Main.insertI(Dictionaries.maindict,(n,line)); ())
	end 
			   
    fun inspectInf(v,t) = 
	let
	    val i = Dictionaries.Main.
		        getHighestIndexAssigned(Dictionaries.maindict) +1
	    val root = (new();stopButtonSetActive(true)
			; Dictionaries.RelMan.update(Dictionaries.reldict,(i,nil))
			; relnumber := 0
			;!canvasroot)
	    val n = NewNode.newNodeInf(v,t,i,root)	
            val line = createSepLine(root,!act_line)
	in
	    ( Layout.layout(n)
	    ; DrawNodes.draw(n,0,!act_line,false)
	    ; incr_act_line(get_ydim(n) + 1)
	    ; Layout.setVisible(get_xdim(n),get_ydim(n)+1)
	    ; (!resize)()
            ; show()
	    ; stopButtonSetActive(false)
	    ; Dictionaries.Main.insertI(Dictionaries.maindict,(n,line)); ())
	end 
	 
end (* structure Widget end *)

end (* local end *)
