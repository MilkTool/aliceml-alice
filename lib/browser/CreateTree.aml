(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure TextIO from "x-alice:/lib/system/TextIO"

import structure Fixity from "x-alice:/lib/rtt/Fixity"
import structure Type from "x-alice:/lib/rtt/Type"
import structure Inf from "x-alice:/lib/rtt/Inf"
import structure PervasiveType from "x-alice:/lib/rtt/PervasiveType"
import structure Path from "x-alice:/lib/rtt/Path"
import structure Name from "x-alice:/lib/rtt/Name"
import structure PathMap from "x-alice:/lib/rtt/PathMap"
import structure Label from "x-alice:/lib/rtt/Label"
import structure Reflect from "x-alice:/lib/system/Reflect"
import structure UnsafeValue from "x-alice:/lib/system/UnsafeValue"
import structure Component from "x-alice:/lib/system/Component"
import structure ComponentManager from "x-alice:/lib/system/ComponentManager"
import structure Url from "x-alice:/lib/system/Url" 

import structure Dictionaries from "Dictionaries"
import structure Node from "Node"
import structure Doc from "Doc"
import structure Settings from "Settings"
import structure CreateTreeHelper from "CreateTreeHelper"
import structure Update from "Update"
import structure GtkSupport from "GtkSupport"

import signature CREATE_TREE from "CREATE_TREE-sig"

local
    open Node Doc Settings Dictionaries CreateTreeHelper
	
in	
    
structure CreateTree :> CREATE_TREE =
struct
    
    exception createGraph_unknownNode   

    (* Bestimmung des Pfades bei Packages und Promises *)

    val coreSign = Inf.asSig(Option.valOf 
		(Component.inf(ComponentManager.link 
		  (Url.fromString "x-alice:/lib/fundamental/Core")))) 
    val packageSign = Inf.asSig(Option.valOf 
		(Component.inf(ComponentManager.link 
		  (Url.fromString "x-alice:/lib/fundamental/Package")))) 


    (* adopted from stockhausen/lib/system/PPValue.aml *)

     fun lookupPath(sign, modLab, typLab) =
	 let val sign' = Inf.asSig(Inf.lookupMod(sign, Label.fromString modLab))
	     val typ   = Inf.lookupTyp'(sign', Label.fromString typLab)
	     val typ'  = if Type.isApply typ 
			     then #1(Type.asApply typ) 
			 else typ
	 in Type.asCon typ'
	 end

    (* newTree *)
     fun newTree (va,t,i,root) = createGraph (NONE,va,t,Empty,i,0,root)


    (* createGraph *)
     and createGraph (opt,va,t,p,i,d,root) =
	 if !relmode (* Konstruktion im Relationsmodus *)
	     andalso not(isAtomType(t)) 
	     andalso ( not(isListType t andalso null(castList(va))) )
	     then let val ind = if p = Empty then i else getAncIndex p 
		      val desc = createValue(va,t) 
		      val relman = 
			    case RelMan.lookup(reldict,ind)
			      of SOME x => x (* Relationsmanager existiert bereits *)
		               | NONE => []
		      val f = fn t: value * int ref * int
			      => isValue (#1(t)) 
			         andalso if !tokenmode (* token equality *)
					     then UnsafeValue.same(asValue(#1(t)),va)   
					 else (* structural equality *)
					     asValue(#1(t)) = va  
		      val new_relman = 
			  ( case List.find f relman of
				NONE (* Einfuegen des neuen Wertes *)
				=> RelMan.update(reldict,
						 (ind,(V va,ref 1,!relnumber)::relman))
			      | SOME (rv,co,nu) (* Wert schon vorhanden - Zaehler wird erhoeht *)
				=> co := !co + 1
			   ; valOf(RelMan.lookup(reldict,ind)) )
		      val (rva,count,number) = valOf(List.find f new_relman)
		      val str = "Ref"^Int.toString(number)
		      val node = if !count = 1 
				     then createRelNode (desc,Empty,p,i,d,count,
							 str^" as ",relman,root)
				 else createRelRefNode(desc,p,i,d,str,root) 
		  in ( if !count = 1 
			   then let val c = createUsualGraph (opt,va,t,node,0,d,root)
				in setContent (node,c)  
				end 
		       else ()
                     ; node )
		  end 
	 else createUsualGraph (opt,va,t,p,i,d,root) 
		     	    
    (* createUsualGraph *)
    and createUsualGraph (opt,va,t,p,i,d,root) = 
	if d > !max_depth (* TIEFENFILTER *)
	    then createLimit(createValue(va,t),DEPTH_LIMIT,p,i,d,root)
	else if (isSome(opt) andalso valOf(opt) > !max_width) 
                 orelse (isListType t andalso !max_width = 0)
	       (* BREITENFILTER (fuer Listen bei geschachtelter Darstellung) *)
		 then  let val desc = if isListType t then createValue(va,t)
				      else INTERPUNCT
		       in 
			   createLimit(desc,WIDTH_LIMIT,p,i,d,root)
		       end
	     else (* maximale Tiefe _nicht_ ueberschritten *)
	     let 
		 val fut = UnsafeValue.cast va
	     in if not(Future.isDetermined(fut))
		    then createFutureNode (va,t,p,i,d,root)
		else
		    (case Type.inspect t of
			 Type.Con path  (* Pfadtyp *)
			 => let val p_path = 
			 if String.equal(Label.toString(Path.toLab(path)),
					 "package")
			     then lookupPath(packageSign,"Package","package")
			 else if String.equal(Label.toString(Path.toLab(path)),
					      "val_package")
				  then lookupPath(packageSign,
						  "Package","val_package")
			      else path 
			    in newPath (va,t,p,i,d,p_path,root)
			    end
		      | Type.Arrow _  (* Funktion *)
			    => createSimple (createValue(va,t),p,i,d,"fn",
					     DEFAULT,root)
		      | Type.All(var,typ) (* Allquantor *)
			    => createUsualGraph (NONE,va,typ,p,i,d,root)
		      | Type.Exist(var,typ)  (* Existenzquantor *)
				=> createUsualGraph (NONE,va,typ,p,i,d,root)
		      | Type.Lambda(var,typ) (* Abstraktion *)
				=> raise  createGraph_unknownNode 
		      | Type.Apply(t1,t2) 
			    =>  if isListType t (* Liste *)
				    then let val new_opt = if isNone opt 
							       then SOME 2
							   else SOME (valOf(opt)+1)
					     val vv = castList va
					     val listdesc = 
						 inspectList(!max_width,vv)
					 in listdescToNode(new_opt,va,t,p,i,d,
							   listdesc,root)
					 end
				else ( case unApply (Type.inspect(t)) of 
				       (Type.Con path, ts) (* zusammengesetzter Pfadtyp *) 
				       => let val p_path = 
				                  if String.equal(Label.toString(Path.toLab(path)),
								  "promise") (* Promise *)
						      then lookupPath(coreSign,"Promise","promise") 
						  else path 
					  in 
					      newPath (va,t,p,i,d,p_path,root)
					  end 
				     | _ => raise createGraph_unknownNode ) (* unbekannt *)
		      | Type.Prod(row) => treatProd(va,t,p,i,d,row,root) 
		      (* Record *)
		      | Type.Mu(sum) => createUsualGraph (NONE,va,sum,p,i,d,root) (* Rekursion *)
		      | Type.Sum(row) => treatSum(va,t,p,i,d,row,root) 
		      (* Datentyp *) 
		      | _ => raise  createGraph_unknownNode  (* unbekannt *) )
	     end 
			 
(* spezielle Behandlung von Listen *)

   (* listdescToNode *)
    and listdescToNode (opt,va,t,p,i,d,ld,root) = 
       case ld of 
	Indet(l,f) 
	=> if !relmode (* Darstelung im Relationsmodus *)
	       then createConsList(opt,va,t,l@f,p,i,d,root)
	   else let val desc = createValue(va,t)
		    val length = List.length l
		    val na = Array.array(length+1,Empty)
		    val fva = UnsafeValue.cast f : Reflect.value
		    val inty = #2(Type.asApply(t))   
		    val cont = createContainer (desc,p,i,d,na,root)
		    val nodearray = listElemArray(l,length,inty,
						  cont,d+1,true,root)
		    val future = createFutureNode(fva,t,cont,length,d+1,root)
		in ( Array.update(na,length,future)
		    ; copyArray(nodearray,na)
		    ; cont )
		end
      | Det(l,b) 
        => if !relmode (* Darstellung im Relationsmodus *)
		then createConsList(opt,va,t,castList va,p,i,d,root)
           else
	   let val desc = createValue(va,t)
	       val length = List.length l
               val na = if b orelse !relmode 
			    then Array.array(length + 1,Empty)
			else Array.array(length,Empty)
	       val inty = #2(Type.asApply(t))   
	   in if b (* Breitenlimit ueberschritten *)
		  then let val cont = createContainer (desc,p,i,d,na,root)
			   val nodearray = listElemArray(l,length,inty,cont,
							 d,b,root)
			   val last = createLimit (INTERPUNCT,WIDTH_LIMIT,
						   cont,length,d+1,root)
		       in ( Array.update(na,length,last)
			  ; copyArray(nodearray,na)
			  ; cont )
		       end
	      else let val concat = createConcat(desc,p,i,d,
						 Array.array(3,Empty),root)
 		       val lbra = createSimple (INTERPUNCT,concat,0,d,
						"[",BRACK_COLOR,root)
		       val rbra = createSimple (INTERPUNCT,concat,2,d,
						"]",BRACK_COLOR,root)
		       val cont = createContainer (INTERPUNCT,concat,1,d,
						   na,root)
		       val nodearray = listElemArray(List.take(l,length-1),
						     length-1,inty,cont,d,b,root)
		       val last = let val inva = UnsafeValue.cast(List.last(l))
			                         : Reflect.value
				  in createGraph(NONE,inva,inty,cont,length-1,d+1,root)
				  end      	
		   in ( Array.update(na,length-1,last)
                      ; copyArray(nodearray,na)
		      ; Array.update(getKids(concat),0,lbra)
		      ; Array.update(getKids(concat),1,cont)
		      ; Array.update(getKids(concat),2,rbra)
		      ; concat )
		   end
	   end

(* lineare Darstellung im "tree mode" *)
 
     and listElemArray(list,length,listtyp,p,d,b,root) = 
	 let 
	     val na = Array.array(length,Empty)
	 in
	     (List.appi (fn (i,item) => 
			 let  val concat = createConcat(INTERPUNCT,p,i,d,
							Array.array(2,Empty),root)
			     val inva = UnsafeValue.cast(item)
				 : Reflect.value
			     val elem = createGraph(NONE,inva,listtyp,
						    concat,0,d+1,root)
			     val repr = if b then "::" else ", "
			     val sep = createSimple(INTERPUNCT,
						    concat,1,d,
						    repr,SEP_COLOR,
						    root)
			 in
			     ( Array.update(getKids(concat),0,elem)
			      ; Array.update(getKids(concat),1,sep)
			      ; Array.update(na,i,concat))
			 end) list;na)
	 end

(* geschachtelte Darstellung im Relationsmodus *)

     and createConsList (opt,va,t,list,p,i,d,root) = 
	 if null(list)
	     then createSimple(INTERPUNCT,p,i,d,
			       "nil",DEFAULT,root)
	 else 
	 let val br = valOf(opt) handle Option => ~1
	     val desc = createValue(va,t)
	     val inty = #2(Type.asApply(t))
	     val head = UnsafeValue.cast(hd(list)) : Reflect.value 
	     val tail = UnsafeValue.cast(tl(list)) : Reflect.value

	     val na = Array.array(2,Empty)
	     val contnode = createContainer(desc,p,i,d ,na,root)
	     val concnode = createConcat(INTERPUNCT,contnode,0,d,
					 Array.array(2,Empty),root)
	     val headnode = if  not(isListType(inty))
				then createGraph(NONE,head,inty,concnode,0,d,root)
			    else let val conc = createConcat(INTERPUNCT,concnode,0,d,
							     Array.array(3,Empty),root)
				     val lpar = createSimple(INTERPUNCT,conc,0,d,
							     "(",BRACK_COLOR,root)
				     val rpar = createSimple(INTERPUNCT,conc,2,d,
							     ")",BRACK_COLOR,root)
				     val hnode = createGraph(NONE,head,inty,conc,1,d,root)
				 in ( Array.update(getKids(conc),0,lpar)
				     ; Array.update(getKids(conc),1,hnode)
				     ; Array.update(getKids(conc),2,rpar)
				     ; Array.update(getKids(concnode),0,conc)
				     ; conc )
				 end       
	     val sepnode = createSimple(INTERPUNCT,concnode,1,d,
					"::",SEP_COLOR,root)
	     val tailnode = createGraph(opt,tail,t,contnode,1,d,root)
	 in ( Array.update(getKids(concnode),0,headnode)
            ; Array.update(getKids(concnode),1,sepnode)
            ; Array.update(getKids(contnode),0,concnode)
	    ; Array.update(getKids(contnode),1,tailnode)
	    ; contnode )
	 end 

                 
(* spezielle Behandlung von Records,Tupeln und Datentypen *)
                         
    (* treatProd *)
    and treatProd (va,t,p,i,d,row,root) = 
	let val upperConcat = createConcat(createValue(va,t),
					   p,i,d,Array.array(3,Empty),
					   root)
	    val (lbra,rbra) = if Type.isTupleRow(row) 
				  then ("(",")")
			      else ("{","}")
	    val (lbraNode,rbraNode) = (createSimple (INTERPUNCT,upperConcat,
						     0,d,lbra,BRACK_COLOR,
						     root),
				       createSimple (INTERPUNCT,upperConcat,
						     2,d,rbra,BRACK_COLOR,
						     root))
	    val container = createContfromRow (va,t,upperConcat,1,d,row, 
					       UnsafeValue.proj,root) 
	    val upperKids = getKids(upperConcat)
	in
	    ( Array.update(upperKids,0,lbraNode)
	     ; Array.update(upperKids,1,container)
	     ; Array.update(upperKids,2,rbraNode)
	     ; upperConcat)
	end
	
    (* treatSum *)
    and treatSum (va,t,p,i,d,row,root) = 
        let
	    val lt_list   = row2list(row)
	    val l_vector  = labelvector(lt_list)
	    val index     = UnsafeValue.tag(va,l_vector)
	    val label     = Label.toString(Vector.sub(l_vector,index))
	                    ^" "
	    val typ = #2(List.nth(lt_list,index))
	    val intyp = if Type.isApply(typ) 
                        andalso Type.isCon(#1(Type.asApply(typ))) 
		        andalso Path.equal(Type.asCon(#1(Type.asApply(typ))),
					   PervasiveType.path_strict)
			    then  #2(Type.asApply(typ))
			else typ
	    val emptyrow = case Type.inspect(intyp) of 
		Type.Prod(row') 
		=> Type.isEmptyRow(row') 
	      | _ => false
	    val upperConcat = if emptyrow 
				  then Empty 
		    else createConcat(createValue(va,t),
				      p,i,d,Array.array(4,Empty),root)
	    val (lbra,rbra) =  let val row' = Type.asProd(intyp)
			       in if Type.isTupleRow(row')
				      then ("(",")")
				   else ("{","}")
			       end
			       handle Type.Type => ("_","_")
	    val (lbraNode,rbraNode) = 
		if lbra = "_" orelse emptyrow
		    then (Empty,Empty) 
		else (createSimple(INTERPUNCT,upperConcat,1,d,lbra,BRACK_COLOR,
				   root),
		      createSimple (INTERPUNCT,upperConcat,3,d,rbra,
				    BRACK_COLOR,root))
	    val container = case Type.inspect(intyp) of 
		Type.Prod(row') 
		=> if Type.isEmptyRow(row') 
		       then Empty
		   else
		       createContfromRow (va, t, upperConcat, 2, d, row', 
					  UnsafeValue.projTagged,root)
	      | _ => let
			 val inva = UnsafeValue.projTaggedTuple(va,1,0)
			 val node = createGraph (NONE,inva,intyp,upperConcat,2,d+1,root) 
		     in 
			 node 
		     end
	    val labelnode =  createSimple (INTERPUNCT,
					   if container = Empty
					       then p else upperConcat,
					   if container = Empty
					       then i else 0,d,label,
					   LABEL_COLOR,root) 
	    val upperKids = getKids(upperConcat)
	in
	    if container = Empty 
		then labelnode 
	    else (Array.update(upperKids,0,labelnode)
		  ; Array.update(upperKids,1,lbraNode)
		  ; Array.update(upperKids,2,container)
		  ; Array.update(upperKids,3,rbraNode)
		  ; upperConcat) 
	end

    (* createContfromRow *)
    and createContfromRow (va, t, p, i, d, row, proj,root) = 
	let
	    val lt_list   = row2list(row)
	    val l_vector  = labelvector(lt_list)
	    val wlimit    = List.length(lt_list) > !max_width 
	    val l         = if wlimit then !max_width
			    else List.length(lt_list)
	    val al = if wlimit then !max_width +1 else l
	    val container = createContainer(INTERPUNCT,p,i,d,
					    Array.array(al,Empty),root)
	    val createProdC = if Type.isTupleRow(row)
				  then createProdConcatTuple
			      else createProdConcat
	    val nodes = 
		Array.tabulate(al,
			       (fn i => 
				if wlimit andalso i = !max_width
				    then createLimit (INTERPUNCT,
						      WIDTH_LIMIT,
						      container,
						      i,d,root)
				else createProdC (Label.toString
						  (#1(List.nth(lt_list,i))),
						  proj(va,l_vector,i),
						  #2(List.nth(lt_list,i)),
						  container,i,d,al,root)) )
	    val _ = copyArray(nodes,getKids(container))
	in
	    container
	end

    (* createProdConcat *)
    and createProdConcat (label,va,t,p,i,d,l,root) = 
	let 
	    val last = (i = l-1) 
	    val c_length = if last then 3 else 4
	    val concat = createConcat (INTERPUNCT,p,i,d,
				       Array.array(c_length,Empty),root)
	    val l_node = createSimple (INTERPUNCT,concat,0,d,label,
				       LABEL_COLOR,root)
	    val eq_node = createSimple (INTERPUNCT,concat,1,d," = ",
					EQU_COLOR,root)
	    val sep_node = if last 
			       then Empty
			   else createSimple (INTERPUNCT,
					      concat,3,d,", ",
					      SEP_COLOR,root)
	    val node = createGraph (NONE,va,t,concat,2,d+1,root)
	    val concat_kids = getKids(concat)
	in
	    (Array.update(concat_kids,0,l_node)
	     ; Array.update(concat_kids,1,eq_node)
	     ; Array.update(concat_kids,2,node)
	     ; if last then () 
	       else Array.update(concat_kids,3,sep_node)
	     ;concat)
	end
    
    (* createProdConcatTuple *)
    and createProdConcatTuple (label,va,t,p,i,d,l,root) = 
	let 
	    val last = (i = l-1)
	    val c_length = if last then 1 else 2
	    val concat = if last then Empty
			 else createConcat (INTERPUNCT,p,i,d,
					    Array.array(c_length,Empty),
					    root)
	    val sep_node = if last 
			       then Empty 
			   else createSimple (INTERPUNCT,concat,1,d,", ",
					      SEP_COLOR,root)
	    val node = createGraph (NONE,va,t,if last then p else concat,
				    if last then i else 0,d+1,root)
	    val concat_kids = getKids(concat)
	in
	    if last 
		then node 
	    else 
		(Array.update(concat_kids,0,node)
		 ; Array.update(concat_kids,1,sep_node)
		 ;concat)                                       
	end

(* spezielle Behandlung von Werten, deren Typ ein sog. Pfadtyp ist *) 

    (* newPath *)
    and newPath (v,t,p,i,d,path,root) =
        (case PathMap.lookup(pathTable, path) of
	   NONE 
	   => createSimple(INTERPUNCT,p,i,d,"_",DEFAULT,root)
	 | SOME create 
	   => let val doc = create (!max_width,d,v,t)
	      in  docToNode (doc,p,i,d,root) 
	      end )

    (* docToNode *) (* changed on 5.March *)
    and docToNode (doc,p,i,d,root) =
        (case doc of
         SIMPLE(r) 
	   => let val color = 
	             (case #desc(r) of 
		      INTERPUNCT => (case #rep(r) of ", " => SEP_COLOR
		                                   | " = " => EQU_COLOR
						   | ("{" | "}" | "(" | ")"
                                                          | "#[" | "]" )  
						     => BRACK_COLOR
						   | _ => LABEL_COLOR)
		    | VALUE(rr) 
		      => (case Type.inspect(#typ(rr)) of
			  Type.Con path
			  => (if Path.equal(path,PervasiveType.path_int)
				  then INT_COLOR
			      else
			       if Path.equal(path,PervasiveType.path_real)
				   then REAL_COLOR
			       else 
			        if Path.equal(path,PervasiveType.path_char)
				    then CHAR_COLOR
				else 
				 if Path.equal(path,PervasiveType.path_string)
				     then STR_COLOR
				 else
	                          if Path.equal(path,PervasiveType.path_word) 
				      then WORD_COLOR
				  else 
				   if Path.equal(path,PervasiveType.path_exn)
				       then EXN_COLOR
				   else 
				    if Path.equal(path,PervasiveType.path_ref)
					then REF_COLOR
				    else DEFAULT)
			| _ => DEFAULT) ) 
	      in createSimple (#desc(r),p,i,d,#rep(r),color,root) 
	      end  
        | CONCAT(r) => let val na = Array.array(Vector.length(#kids(r)),
						 Empty)
			   val concat = createConcat(#desc(r),p,i,d,na,
						     root)
		       in
			   (Vector.appi (fn (i,a) => 
				       Array.update(na,i,
				       docToNode(a,concat,i,d,root))) (#kids(r))
			    ; concat)
		       end
    	| CONTAINER(r) => let val na = Array.array(Vector.length(#kids(r)),
						   Empty)
			      val container = createContainer(#desc(r),p,i,d,
							      na,root)
			  in
			      (Vector.appi(fn (i,a) => 
				      Array.update(na,i,
				 docToNode(a,container,i,d,root))) (#kids(r))
			       ;container)
			  end
	| LIMIT(r) => createLimit(#desc(r),#sort(r),p,i,d,root) 
	| EMBEDDED(v,t) => createGraph (NONE,v,t,p,i,d+1,root)
	| EMBEDDED_INF(v,t) => createGraphInf (v,t,p,i,d+1,root) ) 
  	     
(* spezielle Behandlung von Futures *)
 
    (* createFutureNode *)
    and createFutureNode (va,t,p,i,d,root) = 
	let val desc = createValue(va,t)
            val fut = UnsafeValue.cast va
	    val str = if Future.isLazy fut then "byneed" else "future"
	    val simple =  createSimple (desc,p,i,d,str,DEFAULT,root)
	in ( case Transient.iterLookup  
	                   (transdict, 
			    fn (vv,_,li) 
			    => List.exists(fn n  
					   => UnsafeValue.same  
					   (getValue(getDesc(n)),va))  
			    li 
			    handle General.Match => false) of 
	      SOME ((vv,thr,li),i)   
	      => Transient.update(transdict,  
					    (i,(vv,thr,li@[simple]))) 
            | NONE  
	      => (let 
		      val id = 
			  Dictionaries.Transient.getHighestIndexAssigned(Dictionaries.transdict) +1
		      val watcher = Update.watcher(fut,va,id,createGraph,createGraphInf,root)
		  in
			(  Transient.insertI(transdict,(va,watcher,[simple])) ; ())
		  end)
          ; simple )
	end 	
  
(********* entsprechende Funktionen zur internen Darstellung von MODULEN *********)
(*********   Code analog zu newTree, createGraph und createUsualGraph    *********)

    (* newTreeInf *)
    and newTreeInf (va,t,i,root) = createGraphInf (va,t,Empty,i,0,root)

     and createGraphInf (va,t,p,i,d,root) =
	 if !relmode (* Konstruktion im Relationsmodus *)
	     then let val ind = if p = Empty then i else getAncIndex p 
		      val desc = createIValue(va,t) 
		      val relman = 
			    case RelMan.lookup(reldict,ind)
			      of SOME x => x (* Relationsmanager existiert bereits *)
		               | NONE => []
		      val f = fn t: value * int ref * int
			      => isModule (#1(t)) 
			         andalso if !tokenmode (* token equality *)
					     then UnsafeValue.same(asModule(#1(t)),va)   
					 else (* structural equality *)
					     asModule(#1(t)) = va  
		      val new_relman = 
			  ( case List.find f relman of
				NONE (* Einfuegen des neuen Wertes *)
				=> RelMan.update(reldict,
						 (ind,(M va,ref 1,!relnumber)::relman))
			      | SOME (rv,co,nu) 
				=> co := !co + 1 (* Wert schon vorhanden - Zaehler wird erhoeht *)
			   ; valOf(RelMan.lookup(reldict,ind)) )
		      val (rva,count,number) = valOf(List.find f new_relman)
		      val str = "Ref"^Int.toString(number)
		      val node = if !count = 1 
				     then createRelNode (desc,Empty,p,i,d,count,
							 str^" as ",relman,root)
				 else createRelRefNode(desc,p,i,d,str,root) 
		  in ( if !count = 1 
			   then let val c = createUsualGraphInf (va,t,node,0,d,root)
				in setContent (node,c)  
				end 
		       else ()
                     ; node )
		  end 
	 else createUsualGraphInf (va,t,p,i,d,root) 
 			         
    (* createUsualGraphInf *) 
    and createUsualGraphInf (va,t,p,i,d,root) = 
	if d > !max_depth (* TIEFENFILTER *)	  
	    then let val desc = createIValue(va,t)  
		 in createLimit(desc,DEPTH_LIMIT,p,i,d,root) 
		 end 
	else (* maximale Tiefe nicht ueberschritten *)  
	(case Inf.inspect t of  
	 Inf.Sig(s) => let val ilist = List.rev(Inf.items(s)) 
		       in treatSig (va,t,p,i,d,ilist,root) 
		       end  
       | Inf.Arrow(path,i1,i2) 
	 => createSimple (createIValue(va,t),p,i,d,"functor", 
			       DEFAULT,root) 
       | Inf.Exist(path,i1,i2) => createUsualGraphInf (va,i2,p,i,d,root) 
       | Inf.Sing(m) => let val ti = #2(Inf.asMod(m)) 
			in createUsualGraphInf (va,ti,p,i,d,root)
			end 
       | _ => createSimple (INTERPUNCT,p,i,d,"_",DEFAULT,root) ) 


    (* treatSig *)
    and treatSig (va,t,p,i,d,ilist,root) = 
	let val ilength = List.length(ilist)
	    val limited = ilength > !max_width
	    val a_length = if limited 
			       then 3 + !max_width
			   else 2 + List.length(ilist)
	    val container = 
		createContainer(createIValue(va,t),p,i,d,
				Array.array(a_length,Empty),root)
	    val s_begin = createSimple(INTERPUNCT,container,0,d,"struct",
				       DEFAULT,root)
	    val s_end = createSimple(INTERPUNCT,container,a_length-1,d,
				     "end",DEFAULT,root)
	in ( Array.update(getKids(container),0,s_begin) 
	    ; Array.update(getKids(container),a_length-1,s_end) 
	    ; if not(limited)
		  then setItems (va,ilist,container,d,ilength,root)
	      (* Erzeugung der Kindkonten *) 
	      else let val limit = createLimit(INTERPUNCT,WIDTH_LIMIT,
					       container,a_length-2,d,
					       root)
		   in ( Array.update(getKids(container),a_length-2,limit)
		       ; setItems (va,List.take(ilist,!max_width),
				   container,d,!max_width,root) )
		   end 
	       ; container ) 
	end   

    (* setItems *)
			

(* changed on 5. March *)
 and setItems (va,ilist,p,d,length,root) = 
     appi_break ((fn (i,item) => let
		                  val vv = UnsafeValue.cast va
				  val label = itemToLabel(item) 
				  val in_vv = UnsafeValue.projPoly(vv,label)
				  val node = createItemNode(in_vv,item,p,i+1,d,root)
			       in
				  Array.update(getKids(p),i+1,node)
			       end),
				  length-1,
				  ilist) 

    (* createItemNode *)
    and createItemNode (vv,item,p,i,d,root) = 
	case Inf.inspectItem item of
	Inf.FixItem(_,_) 
	=> let val fix = #2(Inf.asFixItem(item))
	       val str = case fix of
		         Fixity.NONFIX => "  nonfix" 
	               | Fixity.PREFIX(i) => "  prefix "^Int.toString(i)
		       | Fixity.POSTFIX(i) => "  postfix "^Int.toString(i)
		       | Fixity.INFIX(i,Fixity.LEFT) 
			 => "  infix "^Int.toString(i) 
		       | Fixity.INFIX(i,Fixity.RIGHT) 
			 => "  infixr "^Int.toString(i) 
		       | Fixity.INFIX(i,Fixity.NEITHER) 
			 => "  infixn "^Int.toString(i)
	   in createSimple (INTERPUNCT,p,i,d,str,DEFAULT,root) 
	   end 
      | Inf.ValItem(l,t) 
	=> let val conc = createConcat (INTERPUNCT,p,i,d,Array.array(4,Empty),
					root)
	       val s_val = createSimple (INTERPUNCT,conc,0,d,"  val ",DEFAULT,
					 root)
	       val lab = createSimple (INTERPUNCT,conc,1,d,
				       Label.toString(l),LABEL_COLOR,
				       root)
	       val equ = createSimple (INTERPUNCT,conc,2,d," = ",SEP_COLOR,
				       root)
	       val value =  createGraph (NONE,vv,t,conc,3,d+1,root)  
	   in ( Array.update(getKids(conc),0,s_val)
	       ; Array.update(getKids(conc),1,lab)
	       ; Array.update(getKids(conc),2,equ)
	       ; Array.update(getKids(conc),3,value)
	       ; Array.update(getKids(p),i,conc)
	       ; conc )
	   end
      | Inf.TypItem(path,_)
	=> let val label = Path.toLab(path)
	       val str = "  type "^Label.toString(label)
	   in createSimple (INTERPUNCT,p,i,d,str,DEFAULT,root)
	   end  (* Tiefe! *)
      | Inf.ModItem(path,inf)
	=> let val conc = createConcat (INTERPUNCT,p,i,d,
					Array.array(4,Empty),root)
	       val s_struct = createSimple (INTERPUNCT,conc,1,d,"  structure ",
					    DEFAULT,root)
	       val name = createSimple (INTERPUNCT,conc,1,d,
					Label.toString(Path.toLab(path)),
					LABEL_COLOR,root)
	       val equ = createSimple (INTERPUNCT,conc,2,d," = ",SEP_COLOR,
				       root)
	       val vv_inf = UnsafeValue.cast vv : Reflect.module
	       val value =  createGraphInf (vv_inf,inf,conc,3,d+1,root) 
	   in ( Array.update(getKids(conc),0,s_struct)
	       ; Array.update(getKids(conc),1,name)
	       ; Array.update(getKids(conc),2,equ)
	       ; Array.update(getKids(conc),3,value)
	       ; Array.update(getKids(p),i,conc)
	       ; conc )
	   end
      | Inf.InfItem(path,_)
	=> let val conc = createConcat (INTERPUNCT,p,i,d,
					Array.array(2,Empty),root)
	       val s_sig = createSimple (INTERPUNCT,conc,0,d,"  signature ",
					 DEFAULT,root)
	       val name = createSimple (INTERPUNCT,conc,1,d,
					Label.toString(Path.toLab(path)),
					LABEL_COLOR,root)
               (* Name der Signatur *)
	   in ( Array.update(getKids(conc),0,s_sig)
	       ; Array.update(getKids(conc),1,name)
	       ; Array.update(getKids(p),i,conc)
	       ; conc)
	   end
      | Inf.HiddenItem(item') 
	=> let val conc = createConcat (INTERPUNCT,p,i,d,
					Array.array(2,Empty),root)
	       val ask = createSimple (INTERPUNCT,conc,0,d,"  ? ",
				       DEFAULT,root) 
	       val h_item = createItemNode (vv,item',conc,1,d,root)
	   in ( Array.update(getKids(conc),0,ask)
	       ; Array.update(getKids(conc),1,h_item)
	       ; Array.update(getKids(p),i,conc)
	       ; conc)
	   end

end (* struct end *)
 
end (* local end *)
 
