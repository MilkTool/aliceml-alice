(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure TextIO from "x-alice:/lib/system/TextIO"
import structure Inspector from "x-alice:/lib/tools/Inspector"
import structure Gdk from "x-alice:/lib/gtk/Gdk"
import structure Gtk from "x-alice:/lib/gtk/Gtk"
import structure Settings from "Settings"
import structure GtkCanvas from "x-alice:/lib/gtk/GtkCanvas"
import structure WindowHelper from "WindowHelper"
import structure MkColorTable from "MkColorTable" 
import structure MainDictionary from "MainDictionary"
import structure ColorMap from "ColorMap"
import structure Types from "Types"
import signature SERVICES from "SERVICES-sig"


       structure Services :> SERVICES =
	   struct

	       exception MissingColor
	       type tag = Gtk.object
	       type color = Gtk.object
		  
	       fun fontHeight() = !Settings.fontHeight 
	       
	       fun fontWidth() = !Settings.fontWidth

	       fun newTag(parent,x,y) = 
		   GtkCanvas.itemNew(parent, 
				     GtkCanvas.GROUP,
				     [("x", Gtk.DOUBLE y), 
				      ("y", Gtk.DOUBLE y)])
		   
		  
		   
	       fun printXY (str,group,x,y,c,fontname) =  
		   GtkCanvas.itemNew(group, 
				     GtkCanvas.TEXT, 
				     [("text", Gtk.STRING str),
				      ("font", Gtk.STRING fontname),
				      ("x", Gtk.DOUBLE(x)), ("y", Gtk.DOUBLE(y)),
				      ("fill_color_gdk", Gtk.OBJECT(c) ),
				      ("anchor", Gtk.INT(2))]) 
		   
		
fun print00 (str,group,c,fontname) = 
    GtkCanvas.itemNew(group, 
		      GtkCanvas.TEXT, 
		      [("text", Gtk.STRING str),
		       ("font", Gtk.STRING fontname),
		       ("fill_color_gdk", 
			Gtk.OBJECT(valOf(
			ColorMap.lookup(MkColorTable.colorTable,c))) ),
		       ("anchor", Gtk.INT(2))]) 

   
	 fun move(group,x,y) = GtkCanvas.itemMove(group,x,y)

	 fun positionGroup (group,x,y) = if x=0.0 andalso y=0.0 then ()
	     else 
	     (GtkCanvas.itemSet(group,"x", Gtk.DOUBLE x) 
	      ;GtkCanvas.itemSet(group,"y", Gtk.DOUBLE y))
					      
		   (*

	 fun moveGroup (group,x,y,font) = 
		    let
			val w = fontWidth(font)
                        val h = fontHeight(font)
                        val rx = Real.fromInt(x * w)
                        val ry = Real.fromInt(y * h)
						in
	       		    positionGroup(group,rx,ry)
	   end *)
		   
	  fun moveGroup (group,x,y) = if x=0 andalso y=0 then ()
	      else
		  let
		      val w = fontWidth()
		      val h = fontHeight()
		      val rx = Real.fromInt(x * w)
		      val ry = Real.fromInt(y * h)
		      val _ = () (* TextIO.print("ITEM MOVE BY " 
				  ^ Real.toString(rx)
				  ^ "/" 
				  ^ Real.toString(ry)
				  ^ "\n") *)
		  in
		      GtkCanvas.itemMove(group,rx,ry)
		  end
	  
			     
	   fun getCoordinates group = 
	       let
		   val w = fontWidth()
		   val h = fontHeight()
		   val (rx1,ry1,rx2,ry2) = 
		       GtkCanvas.itemGetBounds(group, 0.0 , 0.0 , 0.0 , 0.0)
		   val x1 = (Real.trunc rx1) div w
		   val y1 = (Real.trunc ry1) div h
		   val x2 = (Real.trunc rx2) div w
		   val y2 = (Real.trunc ry2) div h
	       in
		   (x1,y1,x2,y2)
	       end
		   
	   fun getPosition group = 
	       let
		   val w = fontWidth()
		   val h = fontHeight()
		   val (rx1,ry1,_,_) = 
		       GtkCanvas.itemGetBounds(group, 0.0 , 0.0 , 0.0 , 0.0)
		   val x1 = (Real.trunc rx1) div w
		   val y1 = (Real.trunc ry1) div h
	       in
		   (x1,y1)
	       end

	   fun itemMoveTo (group,rx,ry) = 
	       let
		   val (rx1,ry1,_,_) = 
		       GtkCanvas.itemGetBounds(group, 0.0 , 0.0 , 
					       1000.0 , 1000.0)
		   val (absx,absy) = GtkCanvas.itemI2w(group,rx1,ry1)
		   val _ = if absy <> ry1 then TextIO.print("DIFFERENT!\n")
			   else ()
		   val dx = Real.- (rx, absx)
		   val dy = Real.- (ry, absy)
	       in
		   if absx = rx andalso absy = ry
		       then ()
		   else (GtkCanvas.itemMove(group,dx,dy)
			 ; (* TextIO.print("ITEM MOVE FROM " 
					^ Real.toString(absx)
					^ "/" 
					^ Real.toString(absy)
					^ " TO "
					^ Real.toString(rx)
					^ "/" 
					^ Real.toString(ry)
					^ "\n") *) () )
	       end

	   fun createSepLine (group,actline)= 
	       if actline > 0 
		   then
		       let
			   val mx = Real.trunc(!Settings.max_x)
			   val linepos = actline * fontHeight()
			       - (fontHeight() div 2)
			       in
				GtkCanvas.itemNew(group,   		 
						  GtkCanvas.LINE, 
						  [("points", 
				     Gdk.POINTS ([0, linepos, mx, linepos])),
						   ("fill_color_gdk", 
		  Gdk.OBJECT(MkColorTable.allocColor(40000,40000,50000)) ),
		 ("line_style",Gdk.INT(Gdk.LINE_ON_OFF_DASH)),
		 ("width_pixels", Gdk.INT 1)])  
		       end
	       else WindowHelper.uglyNULL 

	   fun resizeSepLines (dict,rx) = 
	       let
		   val x = Real.trunc rx
		   val highest_i = MainDictionary.getHighestIndexAssigned(dict)
	       in
		   resizeSepLinesIterate(dict,x,0,highest_i)
	       end

     and  resizeSepLinesIterate(dict,x,i,highest_i) =
	 if i > highest_i 
	     then ()
	 else
	     (case MainDictionary.lookup(dict,i) of
		 NONE =>
		     resizeSepLinesIterate(dict,x,i+1,highest_i)
	       | SOME (_,line) => 
		     if line = WindowHelper.uglyNULL 
			 then  resizeSepLinesIterate(dict,x,i+1,highest_i)
		     else
			 let
			     val (rx1,ry1,rx2,ry2) = 
				 GtkCanvas.itemGetBounds(line, 0.0,
					       0.0,
					       0.0,
					       0.0)
				 val y1 = Real.trunc(Real.+(ry1,1.0))
			 in
			     (GtkCanvas.itemSet(line,
					  "points", 
					    Gdk.POINTS ([0, y1, x, y1]))
			      ;  resizeSepLinesIterate(dict,x,i+1,highest_i))
			 end)

		
	   fun yPosSepLine (item,group) = 
	       let
		   val (_,ry1,_,_) = 
		       GtkCanvas.itemGetBounds(group, 0.0,
					       0.0,
					       0.0,
					       0.0)
		   val y = Real.trunc(ry1) - (fontHeight() div 2)
		   val (_,_,lx2,_) = 
				 GtkCanvas.itemGetBounds(item, 0.0,
					       0.0,
					       0.0,
					       0.0)
	       in
		   GtkCanvas.itemSet(item,
				     "points", 
				     Gdk.POINTS ([0, y, 
						  Real.trunc(lx2), 
						  y]))   
	       end 
	
	   fun yPosSepRel (item,dy) = 
	       let
		   val (_,_,lx2,_) = 
				 GtkCanvas.itemGetBounds(item, 0.0,
					       0.0,
					       0.0,
					       0.0)
		   val y = fontHeight() * dy
	       in
		   GtkCanvas.itemSet(item,
				     "points", 
				     Gdk.POINTS ([0, y, 
						  Real.trunc(lx2), 
						  y]))   
	       end 
   

	   fun translate (nil,h,v,h_off,v_off) = nil
	     | translate (x1::x2::xr,h,v,h_off,v_off) = 
	       ((x1 * h) div 8 + h_off)::
	       ((x2 * v) div 8 + v_off)::translate(xr,h,v,h_off,v_off)
	     | translate _ = raise Match

	   fun createArrow(group,points) = 
	       let
		   val color = case ColorMap.lookup(MkColorTable.colorTable,
						    Types.LIMIT_COLOR) of 
		       SOME x => x
		     | NONE   => raise MissingColor
	       in
		   GtkCanvas.itemNew(group,
				     GtkCanvas.POLYGON,
				     [("points", 
				       Gdk.POINTS points),
				      ("fill_color_gdk",
				       Gtk.OBJECT(color)),
				      ("outline_color_gdk",
		      Gdk.OBJECT(MkColorTable.allocColor(0,0,0))),
				      ("width_pixels", Gdk.INT 1)])
	       end

	       
	   fun createArrowRight(group) = let
			   val w = (fontWidth() * 3) div 2
	                   val h = fontHeight()  
			   val points = [4,0, 4,2, 0,2, 0,6, 4,6, 4,8, 8,4]
			   val points' = translate(points,w,h,0,0)
			   val group' = newTag(group,0.5,0.5)
	      in
		 createArrow(group',points')
	      end

	   fun createArrowDown(group) = let
			   val w = (fontWidth() * 3) div 2
	                   val h = fontHeight() 
			   val points = [2,0, 2,4, 0,4, 4,8, 8,4, 6,4, 6,0]
			   val points' = translate(points,w,h,0,0)
			   val group' = newTag(group,0.5,0.5)
	      in
		 createArrow(group',points')
	      end
	     

	   end
       
