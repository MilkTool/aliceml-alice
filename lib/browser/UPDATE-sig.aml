(*
 * Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Inf from "x-alice:/lib/rtt/Inf"
import structure Type from "x-alice:/lib/rtt/Type"
import structure Reflect from "x-alice:/lib/system/Reflect"

import structure Node from "Node"
import structure GtkSupport from "GtkSupport"

local
    open Node
in

signature UPDATE = 
    sig
          
        (* operations that make use of the funcionality of Widget - 
           are being filled at start of the inspector *)

	val incrActLine: (int -> unit) ref
	val resize:      (unit -> unit) ref

	(* flag for stop button *)

	val stopflag: bool ref

	(* width of the widest tree *)

	val screen_max_x: int ref

	(* is used in Widget for the "shrink" operation *)

	val findHighestDepth : node -> int
        
	(* ajustment of the width of the window *)  
  
	val setVisible : int  -> unit

        (* displacement of all "successor" trees after every update *)

	val iterMove : int * int -> unit

	(***************************************************)

	(* update watcher for FUTURES *) 

        val watcher : 
	    'a  * 
	    Reflect.value * 
	    int *
	    (int option * Reflect.value * Type.t  * node * 
	                  int * int * GtkSupport.tag -> node) * 
	    (Reflect.module * Inf.t  * node * 
	                      int * int * GtkSupport.tag -> node) *
	    GtkSupport.tag 
	    -> Thread.thread

	(* REINSPECT *)

	val reinspect :
	    node * 
	    (int option * Reflect.value * Type.t * node * 
	                  int * int * GtkSupport.tag -> node) * 
	    (Reflect.module * Inf.t * node * 
	                     int * int * GtkSupport.tag -> node) *
	    GtkSupport.tag 
	    -> unit

	(* folding of DEPTH *)

	val foldDepth : 
	    node * 
	    int * 
	    (int option * Reflect.value * Type.t * node * 
	                  int * int  * GtkSupport.tag -> node) *
	    (Reflect.module * Inf.t * node * 
	                      int * int * GtkSupport.tag -> node) *
	    GtkSupport.tag 
	    -> unit

	(* folding of WIDTH *)

	val foldWidth : 
	    node * 
	    int * 
	    (int option * Reflect.value * Type.t * node * 
	                  int * int  * GtkSupport.tag -> node) *
	    (Reflect.module * Inf.t * node * 
	                      int * int * GtkSupport.tag -> node) *
	    GtkSupport.tag 
	    -> unit
   
end

end
