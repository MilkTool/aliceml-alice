(* Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 * $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure TextIO from "x-alice:/lib/system/TextIO"
import structure Types from "Types"
import structure MainDictionary from "MainDictionary"
import structure Layout from "Layout"
import structure Helper from "Helper"
import structure WindowHelper from "WindowHelper"
import structure Settings from "Settings"
import structure DrawNodes from "DrawNodes"
import structure Services from "Services"
import signature NODE_SEARCH from "NODE_SEARCH-sig"

local
open Types Layout Helper
in

structure NodeSearch :> NODE_SEARCH =
struct

    exception NodeFound of node

    fun inBoundingBox (node,x,y) = 
	let
	    val xdim = Layout.get_xdim(node)
	    val ydim = Layout.get_ydim(node)
	    val _ = (* TextIO.print("Simple search with x=" 
					 ^ Int.toString(x)
					 ^ " and y="
					 ^ Int.toString(y)
					 ^ "\n") *) ()
	in
	    x >= 0 
	    andalso y >= 0
	    andalso x < xdim
	    andalso y < ydim
	end

    fun isInterpunct node = case getDesc(node) 
	of INTERPUNCT => true
      | _ => false

    fun interpunctMayBeSelected (Limit _ | RelNode _ | RelRefNode _ ) = true
      | interpunctMayBeSelected  _ = false

    fun justifyFound (node,SOME(n) as found) =if isInterpunct(node)
					     then if node = n 
					     	 then SOME(getParent(node))
						     else found
					    else found
      | justifyFound (node,NONE)     = NONE

    fun treeSearch ((Simple _ as node | Limit _ as node),x,y)  = 
	if inBoundingBox(node,x,y) then 
	    if not(isInterpunct node) 
		orelse (interpunctMayBeSelected node)
		orelse (getParent(node) = Empty) 
		then SOME(node)
		    else SOME(getParent(node))
	else NONE
      | treeSearch (RelRefNode _ as node,x,y) = if inBoundingBox(node,x,y) 
						then SOME(node)
						    else NONE
      | treeSearch (RelNode(r) as node,x,y) =  (case !(#counter(r)) of
			  1  =>  treeSearch(!(#content(r)),x,y)
			| _  =>  let
				     val labellength =  String.length(#rep(r))
				     val label_in_bb = x>=0
					 andalso x < labellength
					 andalso y = 0
				 in
				     if label_in_bb then SOME(node) 
					 else treeSearch(!(#content(r)),
							 x - labellength,
							 y)
				 end)
      | treeSearch (Concat(r) as node,x,y) =
	    let
		val _ = (* TextIO.print("Concat search with x=" 
				     ^ Int.toString(x)
				     ^ " and y="
				     ^ Int.toString(y)
				     ^ "\n") *) ()
	    in
		if inBoundingBox(node,x,y) 
		    then let
			     val hor_funct =
				 (fn (a,(curx,cury)) =>
				  (case treeSearch(a,curx,cury) of
				       SOME(n) => raise NodeFound(n)
				     | NONE    => let
					   val c = curx -  Layout.get_xdim(a)
					   val _ = (* TextIO.print("curx is "
						   ^ Int.toString(c)
						   ^ "\n") *) ()
						  in
					   (case a of
						Container(r) => 
						    if setsVertical(a) 
							then
					  (curx - Layout.get_l_xdim(a)
					   , cury - Layout.get_ydim(a) +1)
						    else 
					  (curx -  Layout.get_xdim(a)
					   ,cury)
					      | _ => 
						(curx - Layout.get_xdim(a)
						 ,cury))
						  end))
			     val found = (Array.foldl hor_funct (x,y)	
					  (Helper.getKids(node)); NONE)
				 handle NodeFound(n) => SOME(n)
			 in
			    justifyFound(node,found)
			 end
	    else NONE
	    end
      | treeSearch (Container(r) as node,x,y) = 
		let
		    val _ = (* TextIO.print("Container search with x=" 
					 ^ Int.toString(x)
					 ^ " and y="
					 ^ Int.toString(y)
					 ^ "\n") *) ()
			in
		if inBoundingBox(node,x,y) 
		    then let
			     val hor_funct =
				 (fn (a,curx) =>
				  (case treeSearch(a,curx,y) of
				       SOME(n) => raise NodeFound(n)
				     | NONE    => 
					   (curx -  Layout.get_xdim(a))))
			     val ver_funct =
				 (fn (a,cury) =>
				  (case treeSearch(a,x,cury) of
				       SOME(n) => raise NodeFound(n)
					 | NONE    => 
					   (cury -  Layout.get_ydim(a))))
			     val found = (if Helper.setsVertical(node)
					      then (Array.foldl ver_funct y 
						  (Helper.getKids(node));NONE)
					  else (Array.foldl hor_funct x 
					      (Helper.getKids(node));NONE))
				 handle NodeFound(n) => SOME(n)
			 in
			      justifyFound(node,found)
			 end
		else NONE
		end
      | treeSearch _ = NONE
		     
				     
    exception unknown

    fun iterate (dict,x,y,i,highest_i) = 
	if i > highest_i 
	    then NONE
	else
	    case MainDictionary.lookup(dict,i) of
		NONE => iterate(dict,x,y,i+1,highest_i)
	      | SOME node => case treeSearch(node,x,y) 
		    of
			NONE => iterate (dict,
					 x,
					 y-Layout.get_ydim(node)-1,
					 i+1,
					 highest_i)
		      | SOME n => ( case getParent(n) of
				    RelNode(r) 
				    => if !(#counter(r)) = 1
					   then SOME n
				       else SOME (getParent(n))
                                  | _ => SOME n)
				   
						     
    fun search (dict,real_x, real_y) = 
	let
	    val int_x = (Real.trunc(real_x))
	    val font_width = Services.fontWidth()
	    val x = int_x div font_width
	    val int_y = (Real.trunc(real_y))
	    val font_height = Services.fontHeight()
	    val y = int_y div font_height
	    val highest_i = MainDictionary.getHighestIndexAssigned(dict)
	    val _ = TextIO.print("searching for x:" ^ Int.toString(x) ^ " and y:" ^Int.toString(y)
				  ^ " \n")
	in
	   iterate (dict,x,y,0,highest_i)
	end

end

end (* local end *)
