(* Authors:
 *   Bernadette Blum <blum@ps.uni-sb.de>
 *   Marvin Schiller <schiller@ps.uni-sb.de>
 *
 * Copyright:
 *   Bernadette Blum, 2002
 *   Marvin Schiller, 2002
 *
 * Last Change:
 datatype intention = DRAW | SEARCH of int * int *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure TextIO from "x-alice:/lib/system/TextIO"
import structure Types from "Types"
import structure MainDictionary from "MainDictionary"
import structure Layout from "Layout"
import structure Helper from "Helper"
import structure WindowHelper from "WindowHelper"
import structure Settings from "Settings"
import structure DrawNodes from "DrawNodes"
import signature NODE_SEARCH from "NODE_SEARCH-sig"

local
open Types Layout Helper
in

structure NodeSearch :> NODE_SEARCH =
struct

    (* historic code fragment - not in use *)
    fun treeSearchSimple (node,x,y,cur_pos_x,cur_pos_y,rep) = 
	let
	        val _ = TextIO.print("visiting simple" ^ rep ^ " at cur_pos_x: " ^ Int.toString(cur_pos_x)
				     ^ " and cur_pos_y: " ^ Int.toString(cur_pos_y) ^ "\n")
		val in_bounding_box = x >= cur_pos_x 
		    andalso x < cur_pos_x + String.length(rep) 
		    andalso y = cur_pos_y
	    in
		if in_bounding_box 
		    then (cur_pos_x + String.length(rep),
			  cur_pos_y,
			  SOME(node))
		else (cur_pos_x + String.length(rep),
				       cur_pos_y,
				       NONE)
	    end

    exception unknown

    (* historic code fragment - not in use *)
    fun treeSearch (node,x,y,cur_pos_x,cur_pos_y) = case node of
	Simple(r) => treeSearchSimple (node,x,y,cur_pos_x,cur_pos_y,#rep(r))
      | RelNode(r) =>  treeSearchSimple (node,x,y,cur_pos_x,cur_pos_y,#rep(r))
      | RelRefNode(r) =>  treeSearchSimple (node,x,y,cur_pos_x,cur_pos_y,#rep(r)) 
      | Limit(r) => let
		val in_bounding_box = x = cur_pos_x 
		    andalso y = cur_pos_y
	    in
		if in_bounding_box 
		    then (cur_pos_x +1,
			  cur_pos_y,
			  SOME(node))
		else (cur_pos_x + 1,
		      cur_pos_y,
		      NONE)
		    end
      |	Concat(r) => 
		    let
			 val _ = TextIO.print("visiting concat at cur_pos_x: " ^ Int.toString(cur_pos_x)
				     ^ " and cur_pos_y: " ^ Int.toString(cur_pos_y) ^ "\n")
			 val in_bounding_box = x >= cur_pos_x 
			    andalso x < cur_pos_x + !(#width(r))
			    andalso y>= cur_pos_y 
			    andalso y < cur_pos_y+ !(#height(r))
		    in
		if in_bounding_box then
		    let val kids_list = Array.toList(#kids(r))
			val l = List.length(kids_list) - 1
			val i = ref 0
			val found = ref NONE
		    in ( while !i <= l do
			(let val li = List.take(kids_list,!i)
			     val sum_xdim = 
				 if !i = l 
				     andalso !i > 0
				     andalso setsVertical (List.nth(kids_list,
								    !i-1))
				     then 
					 let val li' = List.take(kids_list,!i-1)
					 in sum_up(li',get_xdim,get_l_xdim) +
					     get_l_xdim(List.nth(kids_list,!i-1))
					 end 
				 else sum_up(li,get_xdim,get_l_xdim)
			     val max_ydim =  max(li,get_ydim)
			     val (_,_,nodef) = treeSearch (List.nth(kids_list,!i),
							   x,
							   y,
							   cur_pos_x + sum_xdim,
							   if !i = 0 
							       then cur_pos_y 
							   else cur_pos_y + max_ydim - 1)
			 in
			     case nodef of 
				 NONE => ()
			       | SOME n => found := SOME n
			 end ; i := !i + 1)
			     ; (x+get_xdim(node),y+get_ydim(node) - 1,!found))
		    end
		else if #parent(r) = Empty 
			 then
			     (cur_pos_x+get_xdim(node),
			      cur_pos_y+get_ydim(node) - 1,NONE)
		     else
			 (cur_pos_x+get_xdim(node),
			  cur_pos_y+get_ydim(node) - 1,NONE) (* SOME (#parent(r)) *)
	    end
      | Container(r) => 
	    let
		 val _ = TextIO.print("visiting container at cur_pos_x: " ^ Int.toString(cur_pos_x)
				     ^ " and cur_pos_y: " ^ Int.toString(cur_pos_y) ^ "\n")
		val in_bounding_box = x >= cur_pos_x 
		    andalso x < cur_pos_x + !(#width(r))
		    andalso y>= cur_pos_y 
		    andalso y < cur_pos_y+ !(#height(r))
		    val _ = TextIO.print("width =" ^ Int.toString(!(#width(r))) ^"\n")
	    in
		if in_bounding_box then
		    if Array.length(#kids(r)) = 0
			then (cur_pos_x,cur_pos_y,SOME(node))
		    else (let     
			     val _ = TextIO.print("in bounding box") 
			     val hor_funct = (fn (a,(cur_x,cur_y,found)) 
					      => let
					      val _ = TextIO.print("called hor_funct with cur_x: "
								   ^ Int.toString(cur_x) 
								   ^ " and cur_y: "
								   ^  Int.toString(cur_y)
								   ^ "\n" )
						  in
					      case found of
					      NONE => treeSearch(a,x,y,cur_x,cur_y)
                                            | SOME n => let
						   val _ = TextIO.print("found at " ^ 
									Int.toString(cur_x) 
									^ " and " 
									^ Int.toString(cur_x)
									^ "\n")
						       in
						  (cur_x,cur_y,found)
						  end
				 end)
			     val ver_funct = (fn (a,(cur_x,cur_y,found)) 
					      => let
						     val _ = TextIO.print("called hor_funct with cur_x: "
								   ^ Int.toString(cur_x) 
								   ^ " and cur_y: "
								   ^  Int.toString(cur_y)
								   ^ "\n" )
						     val (x1,y1,newfound) =
							 case found of
							       NONE => treeSearch(a,x,y,cur_x,cur_y)
							     | SOME n => (cur_x,cur_y,found)
						 in
						     (x,y1+1,newfound)
					    end)
			     val funct = if setsVertical(node) 
					     then ver_funct
					 else hor_funct
			 in
			     Array.foldl funct (cur_pos_x,cur_pos_y,NONE) (#kids(r))
			 end)
       else let
	   val _ = TextIO.print("not in bounding box \n")
	       in
		   if #parent(r) = Empty 
			 then
			     (cur_pos_x+get_xdim(node),
			      cur_pos_y+get_ydim(node),NONE)
		     else
			 (cur_pos_x+get_xdim(node),
			  cur_pos_y+get_ydim(node),SOME (#parent(r)))
			 end
	    end
	| Empty => (cur_pos_x,cur_pos_y,NONE)
	| _ => raise unknown
	   

    fun iterate (dict,x,y,cur_pos_y,i,highest_i) = 
	if i > highest_i 
	      then (0,0,NONE) 
	  else
	      case MainDictionary.lookup(dict,i) of
        NONE => iterate(dict,x,y,cur_pos_y,i+1,highest_i)
      | SOME node => let val _ = TextIO.print("starting iteration with cur_pos_y: " 
					       ^Int.toString(cur_pos_y) ^ "\n")
			 val (new_x,new_y,nodefound) = 
			     DrawNodes.draw(node,0,cur_pos_y,DrawNodes.SEARCH(x,y))
		     in
			 case nodefound of
        NONE => iterate (dict,x,y,new_y+2,i+1,highest_i)
      | SOME n => (new_x,new_y,nodefound)
	    end
						     
    fun search (dict,real_x, real_y) = 
	let
	    val int_x = (Real.trunc(real_x))
	    val font_width = WindowHelper.fontWidth(!Settings.font)
	    val x = int_x div font_width
	    val int_y = (Real.trunc(real_y))
	    val font_height = WindowHelper.fontHeight(!Settings.font)
	    val y = int_y div font_height
	    val highest_i = MainDictionary.getHighestIndexAssigned(dict)
	    val _ = TextIO.print("searching for x:" ^ Int.toString(x) ^ " and y:" ^Int.toString(y)
				  ^ " \n")
	in
	    iterate (dict,x,y,0,0,highest_i)
	end

end

end (* local end *)
