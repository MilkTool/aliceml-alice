(*
 * Authors:
 *   Thorsten Brunklaus <brunklaus@ps.uni-sb.de>
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Thorsten Brunklaus and Leif Kornstaedt and Andreas Rossberg, 2000-2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(* How to start the system: C-u M-x run-sml RET stot RET --rtt-level=full *)

TextIO.print "hello, world\n"

import "x-alice:/lib/tools/Inspector"

val inspect = Inspector.inspect

inspect ({hello = "hello, world"}, 3 + 8)

val rec infiniteList = 1::infiniteList;
inspect infiniteList


(***********************************************************************
 * Futures and Concurrency
 **********************************************************************)

(*TODO*)


(***********************************************************************
 * Components
 **********************************************************************)

(*TODO*)


(***********************************************************************
 * Packages
 **********************************************************************)

(*
 * Part 1:
 * Packing and unpacking of a simple value.
 * Suspensions are kept inside the package.
 *)

val  susp  = byneed(fn() => print "Welcome to the world of packages!\n")
val  value = {a = 0, b = "Knob the dopp.", c = susp, d = [4, 0, 2, 42]}
type ty    = {a : int, b : string, c : unit, d : int list}

structure P = Package.PackVal(val x = value type t = ty)
structure X = Package.UnpackVal(val package = P.package type t = ty)

val _ = print(if #b X.x = #b value then "Yeah!\n" else raise Fail "Ouch!")

val _ = #c X.x = ()


(*
 * Part 2:
 * Packing and unpacking of a function.
 *)

fun fib 0 = 0
|   fib 1 = 1
|   fib n = fib(n-1) + fib(n-2)

structure P = Package.PackVal(val x = fib type t = int->int)
structure X = Package.UnpackVal(val package = P.package type t = int->int)

val _ = print("fib 10 = " ^ Int.toString(X.x 10) ^ "\n")


(*
 * Part 3:
 * Packing and unpacking of a polymorphic function.
 * We have to resort to modules to do that.
 * Type can be specified less general at unpacking
 * (ie. usual enrichment rules apply).
 *)

structure P         = Package.Pack(structure X = (val f = length)
				   signature S = (val f : 'a list -> int))
structure Length    = Package.Unpack(val package = P.package
				     signature S = (val f: 'a list -> int))
structure IntLength = Package.Unpack(val package = P.package
				      signature S = (val f: int list -> int))

val _  = print("length [1,2,1] = " ^ Int.toString(Length.f [1,2,1]) ^ "\n")
val _  = print("length [3,0] = " ^ Int.toString(IntLength.f [3,0]) ^ "\n")


(*
 * Part 4:
 * Packing and unpacking of an abstract type.
 * The unpacked type is compatible with the original one.
 *)

signature NUM =
    sig
	type t
	fun fromInt : int -> t
	fun toInt : t -> int
	fun add : t * t -> t
    end

structure Num :> NUM =
    struct
	type t = int
	fun toInt n   = n
	fun fromInt n = n
	val add       = op+
    end

structure P    = Package.Pack(structure X = Num
			      signature S = NUM where type t = Num.t)
structure Num' = Package.Unpack(val package = P.package
				signature S = NUM where type t = Num.t)

val n1 = Num.fromInt 2
val n2 = Num'.fromInt 53
val n3 = Num.add(n1,n2)
val _  = print("2 + 53 = " ^ Int.toString(Num'.toInt n3) ^ "\n")


(*
 * Part 5:
 * Packing of functors.
 *)

functor Hello(val who : string) =
    struct
	val _ = print("Hello " ^ who ^ "!\n")
    end

signature HELLO = fct(val who : string) -> any

structure P      = Package.Pack(structure X = Hello signature S = HELLO)
structure Hello' = Package.Unpack(val package = P.package
				  signature S = HELLO)

structure _      = Hello(val who = "World")


(*
 * Part 6:
 * Packing of signatures.
 * Signatures are first-class and can be packed.
 * We can unpack packages with statically unknown signatures.
 *)

signature T      = fct(_ : any) -> sig    type t       end
structure X :> T = fct(_ : any) => struct type t = int end

structure PM     = Package.Pack(structure X = X signature S = T)
structure PS     = Package.Pack(structure X = (signature U = T)
				signature S = (signature U))

structure Sig = Package.Unpack(val package = PS.package
			       signature S = (signature U))
structure Mod = Package.Unpack(val package = PM.package
			       signature S = Sig.U)


(***********************************************************************
 * Pickling
 **********************************************************************)

(*
 * Part 1:
 * Pickling and unpickling of a simple value.
 * Pickling suspends on futures.
 *)

val  susp  = byneed(fn() => print "Welcome to the world of pickling!\n")
val  value = {a = 0, b = "Knob the dopp.", c = susp, d = [4, 0, 2, 42]}
type ty    = {a : int, b : string, c : unit, d : int list}

val file = "value." ^ Pickle.extension
structure _ = Pickle.SaveVal(val file = file val x = value type t = ty)
structure X = Pickle.LoadVal(val file = file type t = ty)

val _ = print(if #b X.x = #b value then "Yezz!\n" else raise Fail "Ouch!")


(*
 * Part 2:
 * Pickling and unpickling of a function.
 *)

fun fib 0 = 0
|   fib 1 = 1
|   fib n = fib(n-1) + fib(n-2)

val file = "fib." ^ Pickle.extension
structure _ = Pickle.SaveVal(val file = file val x = fib type t = int->int)
structure X = Pickle.LoadVal(val file = file type t = int->int)

val _ = print("fib 10 = " ^ Int.toString(X.x 10) ^ "\n")


(*
 * Part 3:
 * Pickling and unpickling of a polymorphic function.
 * We have to resort to modules to do that.
 * Type can be specified less general at loading
 * (ie. usual enrichment rules apply).
 *)

val file = "Polymorphic." ^ Pickle.extension
structure _         = Pickle.Save(val file = file
				  structure X = (val f = length)
				  signature S = (val f : 'a list -> int))
structure Length    = Pickle.Load(val file = file
				  signature S = (val f : 'a list -> int))
structure IntLength = Pickle.Load(val file = file
				  signature S = (val f : int list -> int))

val _  = print("length [1,2,1] = " ^ Int.toString(Length.f [1,2,1]) ^ "\n")
val _  = print("length [3,0] = " ^ Int.toString(IntLength.f [3,0]) ^ "\n")


(*
 * Part 4:
 * Pickling and unpickling of an abstract type.
 * The unpickled type is compatible with the original one.
 *)

signature NUM =
    sig
	type t
	fun fromInt : int -> t
	fun toInt : t -> int
	fun add : t * t -> t
    end

structure Num :> NUM =
    struct
	type t = int
	fun toInt n   = n
	fun fromInt n = n
	val add       = op+
    end

val file = "Num." ^ Pickle.extension
structure  _   = Pickle.Save(val file = file
			     structure X = Num
			     signature S = NUM where type t = Num.t)
structure Num' = Pickle.Load(val file = file
			     signature S = NUM where type t = Num.t)

val n1 = Num.fromInt 2
val n2 = Num'.fromInt 53
val n3 = Num.add(n1,n2)
val _  = print("2 + 53 = " ^ Int.toString(Num'.toInt n3) ^ "\n")


(*
 * Part 5:
 * Pickling of functors.
 *)

val file = "Hello." ^ Pickle.extension

functor MkHello(val who : string) =
    struct
	val s = "Hello " ^ who ^ "!\n"
    end

signature MK_HELLO = fct(val who : string) -> sig val s : string end

structure _        = Pickle.Save(val file = file
				 structure X = MkHello
				 signature S = MK_HELLO)
structure MkHello' = Pickle.Load(val file = file signature S = MK_HELLO)

structure Hello    = MkHello'(val who = "World")
val       _        = print(Hello.s)


(*
 * Part 6:
 * Pickling of signatures.
 * Signatures are first-class and can be pickled.
 * We can load pickles with statically unknown signatures.
 *)

val sigfile = "Sig." ^ Pickle.extension
val modfile = "Mod." ^ Pickle.extension

signature T      = fct(_ : any) -> sig    type t       end
structure X :> T = fct(_ : any) => struct type t = int end

structure  _  = Pickle.Save(val file = modfile
structure X = X signature S = T)

structure  _  = Pickle.Save(val file = sigfile
			    structure X = (signature U = T)
			    signature S = (signature U))
structure Sig = Pickle.Load(val file = sigfile
			    signature S = (signature U))
structure Mod = Pickle.Load(val file = modfile
			    signature S = Sig.U)

(*
 * Part 7:
 * Components are pickles and vice versa!
 * Loading a component as a pickle will execute it and return the
 * component's content as a structure.
 * A structure pickle can be used as a component. It is a special case of
 * a component because its content is completely evaluated.
 * Note that unpickling an evaluated component produces new abstract
 * types! (so Url'.Url.t below is incompatible to the lib's Url.t)
 *)

val file = "Url." ^ Pickle.extension
val comp = "x-alice:/lib/utility/" ^ file

import signature URL from "x-alice:/lib/utility/URL-sig"

structure Url' = Pickle.Load(val file = comp
			     signature S = (structure Url : URL))

val _ = print(Url'.Url.toString(Url'.Url.fromString comp) ^ "\n")

structure _ = Pickle.Save(val file = file
			  structure X = Url'
			  signature S = (structure Url : URL))


(***********************************************************************
 * Constraints
 **********************************************************************)

import structure FD       from "x-alice:/lib/constraints/FD"
import structure Space    from "x-alice:/lib/constraints/Space"
import structure Search   from "x-alice:/lib/constraints/Search"
import structure Explorer from "x-alice:/lib/constraints/Explorer"

structure Photo =
    struct
	datatype person = ALICE | BERT | CHRIS | DEB | EVAN

	val nPersons = 5

	fun personIndex ALICE = 0
	  | personIndex BERT  = 1
	  | personIndex CHRIS = 2
	  | personIndex DEB   = 3
	  | personIndex EVAN  = 4

	val prefs = #[(ALICE, CHRIS),
		      (BERT, EVAN),
		      (CHRIS, DEB),
		      (CHRIS, EVAN),
		      (DEB, ALICE),
		      (DEB, EVAN),
		      (EVAN, BERT)]

	fun photo() =
	    let
		val pos as #[alice, bert, chris, deb, evan]
			= FD.rangeVec(nPersons, (1, nPersons))
		val sat = FD.range(0, Vector.length prefs)
		val ful = Vector.map
		    (fn (a, b) =>
		     let
			 val c1     = FD.bin()
			 val c2     = FD.bin()
			 val result = FD.bin()
			 val zero   = FD.fromInt 0
			 val one    = FD.fromInt 1
			 val posA   = Vector.sub(pos, personIndex a)
			 val posB   = Vector.sub(pos, personIndex b)
		     in
			 FD.Reified.sumC(#[(1, one), (1, posA), (~1, posB)],
					 FD.EQUAL, zero, c1);
			 FD.Reified.sumC(#[(1, posA), (~1, posB)],
					 FD.EQUAL, one, c2);
			 FD.Reified.sum(#[c1, c2],
					FD.EQUAL, one, result);
			 result
		     end) prefs
	    in
		FD.distinct pos;
		FD.sum(ful, FD.EQUAL, sat);
		FD.distribute(FD.NAIVE, pos);
		({alice, bert, chris, deb, evan}, ful, sat)
	    end

	fun pruner((_, _, a), (_, _, b)) = FD.lessEq(a, b);

	(* Explore the Solution(s) *)
	val _ = Explorer.exploreBest(photo, pruner)
    end

structure Money =
    struct
	fun money() =
	    let
		val digits as #[S, E, N, D, M, O, R, Y] = FD.rangeVec(8, (0,9))
		val send                                = FD.fd NONE
		val more                                = FD.fd NONE
		val money                               = FD.fd NONE
		val zero                                = FD.fromInt 0
	    in
		FD.sumC(#[(1000, S), (100, E), (10, N), (1, D)],
			FD.EQUAL, send);
		FD.sumC(#[(1000, M), (100, O), (10, R), (1, E)],
			FD.EQUAL, more);
		FD.sumC(#[(10000, M), (1000, O), (100, N), (10, E), (1, Y)],
			FD.EQUAL, money);
		FD.notequal(S, zero);
		FD.notequal(M, zero);
		FD.distinct(digits);
		FD.plus(send, more, money);
		FD.distribute(FD.FIRSTFAIL, digits);
		{S, E, N, D, M, O, R, Y}
	    end

	(* Inspect the solution *)
	val _ = Inspector.inspect(Search.searchAll money)
    end


(***********************************************************************
 * Interoperability with Oz
 **********************************************************************)

(*TODO*)
