(* Alice Snake 2.0 - WaitWindow
*
*  Authors: Benedikt Grundmann / Sebastian Germesin
*
*  $Revision$
*
*  Last updated: $Date$ by $Author$
* 
*
*)

import signature WAIT   from "WAIT-sig"

import structure Gtk    from "GtkSupport"
import structure Gdk    from "GtkSupport"

import structure Color  from "../../common/Color"

import structure Text   from "Text"


structure Wait :> WAIT =
struct

    type ready_cb = unit -> string option

    type cancel_cb = unit -> unit

    type wait_widget = {object : Gtk.object,
			insertPlayer : string * Color.color -> unit,
			removePlayer : string * Color.color -> unit}

    (* converts a Color.color into a Gdk.color *)
    fun colorToGdkColor (colormap, c) =
	let
	    val (r, g, b) = Color.rgb c
	    fun conv n = Real.round (65535.0 * n)
	    val color = Gdk.colorNew (conv r, conv g, conv b)
	in
	    Gdk.colormapAllocColor (colormap, color, false, true);
	    color
	end

    (* inserts all connected players into text widget *)
    fun playersJoined (p : wait_widget, players) = 
	                 List.app (#insertPlayer p) players
	
    (* removes one player from text widget *)
    fun playerDisconnected (p : wait_widget, name, color) = 
	                #removePlayer p (name, color)
	
    fun gameStarted _ = ()
    (* cause in server mode this signal should never appear *)


    (* builds the waiting window *)
    fun mkWaitWindow (parent, alreadyConn, readyCB, cancelCB, ticket) =
	let
	    val waiting          = Gtk.windowNew Gtk.WINDOW_TOPLEVEL
	    val dialogVBox       = Gtk.vboxNew (false, 0)
	    val connectedLabel   = Gtk.labelNew "Connected Players : "
	    val separator1       = Gtk.hseparatorNew ()
	    val separator2       = Gtk.hseparatorNew ()
	    val disconnectButton = Gtk.buttonNewWithLabel "Disconnect"
	    val startButton      = Gtk.buttonNewWithLabel "Start"
	    val buttonHBox       = Gtk.hbuttonBoxNew ()
	    val urlHBox          = Gtk.hboxNew (false, 10)
	    val urlLabel         = Gtk.labelNew "Server-URL: "
	    val serverUrl        = Gtk.entryNew ()

	    (* the textwindow where the connected player will be listed *)
	    val playerText        = Gtk.createTextWidget ()
	    val playerWindow      = 
		Gtk.scrolledWindowNew (Gtk.null, Gtk.null)

	    val colormap = Gdk.colormapGetSystem ()

	    (* [insert(name, color)] inserts one player with name and color in
	       connected-players list *)
	    fun insertPlayer (name, color) = 
		let
		    val text  = name ^ " has connected!\n"
		    val color = colorToGdkColor (colormap, color)
		in
		    Gtk.textWidgetInsert (playerText, text, color)
		end

	    (* inserts "Name: name Color: color has disconnected" 
	       in playetText *)
	    fun removePlayer (name, color) =
		let
		    val text  = name ^ " has disconnected!\n"
		    val color = colorToGdkColor (colormap, color)
		in
		    Gtk.textWidgetInsert (playerText, text, color)
		end

	    val waitWindow = {object = waiting,
			      removePlayer,
			      insertPlayer}
		
	    (* the mainQuit procedure resets also the used refs *)
	    fun mainQuit () = (Gtk.widgetDestroy waiting; cancelCB ())
		
	    (* the signal the server gives to start the game,
	     also resets the refs and destroyes the window *)
	    fun start () = 
		(Gtk.widgetDestroy waiting;
		 case readyCB () of
		     NONE          => ()
		   | SOME errorMsg => 
			   (Text.mkTextWindow (parent, "ERROR!", errorMsg);()))
	in

	    playersJoined (waitWindow, alreadyConn);
	    Gtk.widgetSetParentWindow (waiting, parent);
	    Gtk.windowSetModal (waiting, true);
	    Gtk.windowSetTitle (waiting, "Waiting...");
	    Gtk.windowSetPosition (waiting, Gtk.WIN_POS_CENTER);
	    Gtk.textViewSetEditable (playerText, false);
	    
	    (* connects the signals with procedures *)
	    Gtk.signalConnect (waiting, "delete-event", 
			       fn _ => mainQuit ());
	    Gtk.signalConnect (startButton, "clicked",
			       fn _ => start ());
	    Gtk.signalConnect (disconnectButton, "clicked", 
			       fn _ => mainQuit ());
	    
	    (* set some default configurations *)
	    Gtk.entrySetText (serverUrl, ticket);
	    Gtk.containerSetBorderWidth (waiting, 10);
	    Gtk.miscSetAlignment (connectedLabel, 0.0, 0.5);
	    Gtk.entrySetEditable (serverUrl, false);
	    Gtk.windowSetDefaultSize(waiting, 300, 400);
	    Gtk.scrolledWindowSetPolicy (playerWindow, 
					 Gtk.POLICY_NEVER, 
					 Gtk.POLICY_ALWAYS);
	    
	    (* pack everything in boxes *)
	    Gtk.boxPackStart (buttonHBox, startButton, true, true, 5);
	    Gtk.boxPackStart (buttonHBox, disconnectButton, 
			      true, true, 5);
	    
	    Gtk.boxPackStart (urlHBox, urlLabel, false, false, 5);
	    Gtk.boxPackStart (urlHBox, serverUrl, false, false, 5);
	    
	    Gtk.containerAdd (playerWindow, playerText);
	    
	    Gtk.boxPackStart (dialogVBox, urlHBox, false, false, 0);
	    Gtk.boxPackStart (dialogVBox, separator2, false, 
			      false, 5);
	    Gtk.boxPackStart (dialogVBox, connectedLabel, false, 
			      false, 5);
	    Gtk.boxPackStart (dialogVBox, playerWindow, true, 
			      true, 0);
	    Gtk.boxPackStart (dialogVBox, separator1, false, 
			      false, 5);
	    Gtk.boxPackStart (dialogVBox, buttonHBox, false, 
			      false, 5);
	    
	    (* pack everything in container and show it all *)
	    Gtk.containerAdd (waiting, dialogVBox);
	    Gtk.widgetShowAll waiting;
 
	    waitWindow
	    
	end
    
end
