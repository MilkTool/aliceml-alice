(* Alice Snake 2.0 - GUI
*
*  Authors: Benedikt Grundmann / Sebastian Germesin
*
*  $Revision$
*
*  Last updated: $Date$ by $Author$
* 
*
*)

import structure Gtk           from "x-alice:/lib/gtk/Gtk"
import structure Gdk           from "x-alice:/lib/gtk/Gdk"
import structure GtkCanvas     from "x-alice:/lib/gtk/GtkCanvas"
import functor   MkRedBlackMap from "x-alice:/lib/data/MkRedBlackMap"
import structure Config        from "x-alice:/lib/system/Config"

import signature ARENAWIDGET   from "ARENAWIDGET-sig"
import structure Protocol      from "../../common/Protocol"
import structure Color         from "../../common/Color"

(* Overview:

 Tournament starts:
       val arena = ArenaWidget.initialize

 Level starts:
       initLevel (arena, levelinfo)
 
 every Tick:
       update (arena, difflist)
       changeView (arena, (x, y))

 new Level starts:
       initLevel (arena, levelinfo)

...

*)



structure ArenaWidget :> ARENAWIDGET =
struct

    structure P = Protocol

    (* some values *)
    val cellSize      =  20
    val windowWidth   = 400
    val windowHeight  = 300
    val cellSize2     = cellSize     div 2
    val windowHeight2 = windowHeight div 2
    val windowWidth2  = windowWidth  div 2
	

    type arena_field = Gtk.object * P.field
	
    type item_cache  = (int * int * Gtk.object * P.field) list ref

    type arena_widget = 
	{
	 canvas    : Gtk.object,
	 state     : arena_field Array2.array ref,
	 itemCache : item_cache
	 }

    fun colorConv n = Real.round (65535.0 * n)
	
    local
	
	val colormap = Gdk.colormapGetSystem ()
	    
	structure CMap = MkRedBlackMap (Color)
	    
	fun conv c = 
	    let
		val (r, g, b) = Color.rgb c
		val color = Gdk.allocColor (colorConv r, 
					    colorConv g, 
					    colorConv b)
	    in
		Gdk.colormapAllocColor (colormap, color, false, true);
		color
	    end

	fun convArena (r, g, b) = 
	    let
		val color = Gdk.allocColor (colorConv r, 
					    colorConv g, 
					    colorConv b)
	    in
		Gdk.colormapAllocColor (colormap, color, false, true);
		color
	    end
	
	val map  = List.foldl (fn (c, map) =>
			       CMap.insertDisjoint (map, c, conv c)) CMap.empty
	    Color.all
	    
    in
	fun color c = CMap.lookupExistent (map, c);
	val black    = convArena (0.0, 0.0, 0.0);
	val green    = convArena (0.32, 0.66, 0.17);
	val red      = convArena (1.0, 0.0, 0.0);
	val white    = convArena (1.0, 1.0, 1.0)
	    
    end

    val backgroundColor = green

    (* some procedures to work on item_cache *)
    fun addToItemCache (r, c, object, field) ca =
	ca := (r, c, object, field) :: !ca

    fun removeFromItemCache (r, c, object, field) ca = 
	let
	    val newList = 
		List.filter (fn (v, w, x, y) => 
			     not(r = v andalso
				 c = w andalso
				 field = y)) (!ca)
	in
	    ca := newList
	end


    fun initialize () = 
        let
	    val canvas = GtkCanvas.new 1
            (* antialiasing mode: val canvas = GtkCanvas.newAa ()*)
        in
	    {
	        canvas,
	        state     = ref (Array2.array(0, 0, (Gtk.null (), P.EMPTY))),
		itemCache = ref nil
	    }
        end
	
    fun toObject ({canvas, ... } : arena_widget) : Gtk.object  = canvas
	
    fun initLevel ({canvas, state, itemCache}, 
		   {dimensions = dim} : P.level_info) =
	let
	    val (rows, cols) = dim
	    val _ = GtkCanvas.setScrollRegion (canvas, 0.0, 0.0,
					       Real.fromInt(cols * cellSize),
					       Real.fromInt(rows * cellSize))
	    val _ = Gtk.widgetSetUsize (canvas, windowWidth, windowHeight)
	    val root = GtkCanvas.root canvas
	    val _ = 
		GtkCanvas.itemNew (root, Gtk.RECTANGLE,
				   [("x1", Gtk.DOUBLE 0.0),
				    ("y1", Gtk.DOUBLE 0.0),
				    ("x2", Gtk.DOUBLE(real (cols * cellSize))),
				    ("y2", Gtk.DOUBLE(real (rows * cellSize))),
				    ("fill_color_gdk", Gtk.OBJECT green),
				    ("outline_color_gdk", Gtk.OBJECT green)])
	    val arena = Array2.array (rows, cols, (Gtk.null (), P.EMPTY))
	in
	    state     := arena;
	    itemCache := nil
	end
	

    fun insertHead (canvas, x, y, d, snakecol) =
	let
	    val (ex1, ey1, ex2, ey2) = 
		case d of
		    P.UP    => (2 * cellSize div 10,
				3 * cellSize div 10,
				5 * cellSize div 10,
				3 * cellSize div 10)
		  | P.DOWN  => (2 * cellSize div 10,
				4 * cellSize div 10,
				5 * cellSize div 10,
				4 * cellSize div 10)
		  | P.LEFT  => (3 * cellSize div 10,
				2 * cellSize div 10,
				3 * cellSize div 10,
				5 * cellSize div 10)
		  | P.RIGHT => (4 * cellSize div 10,
				2 * cellSize div 10,
				4 * cellSize div 10,
				5 * cellSize div 10)
		    
	    val tonglist = 
		case d of
		    P.UP    => [(4 * cellSize div 10),
				(1 * cellSize div 10),
				(4 * cellSize div 10),
			       (~3 * cellSize div 10)]
		  | P.DOWN  => [(4 * cellSize div 10),
				(8 * cellSize div 10),
				(4 * cellSize div 10),
			       (11 * cellSize div 10)]
		  | P.LEFT  => [(1 * cellSize div 10),
				(4 * cellSize div 10),
			       (~3 * cellSize div 10),
			        (4 * cellSize div 10)]
		  | P.RIGHT => [(8 * cellSize div 10),
				(4 * cellSize div 10),
			       (11 * cellSize div 10),
				(4 * cellSize div 10)]

	    val head = 
		GtkCanvas.itemNew (canvas, GtkCanvas.GROUP,
				   [("x", Gtk.DOUBLE (real x)),
				    ("y", Gtk.DOUBLE (real y))])

	    val ground = 
		GtkCanvas.itemNew (head, GtkCanvas.ELLIPSE,
				   [("x1", Gtk.DOUBLE 0.0),
				    ("y1", Gtk.DOUBLE 0.0),
				    ("x2", Gtk.DOUBLE (real cellSize)),
				    ("y2", Gtk.DOUBLE (real cellSize)),
				    ("fill_color_gdk", Gtk.OBJECT snakecol)])

	    val tongue = 
		GtkCanvas.itemNew (head, 
				   GtkCanvas.LINE,
				   [("points", Gtk.POINTS tonglist),
				    ("fill_color_gdk", Gtk.OBJECT red),
				    ("width_pixels",Gtk.INT(cellSize div 10))])

	    val leftEye = 
		GtkCanvas.itemNew (head,
				   GtkCanvas.RECTANGLE,
				   [("x1", Gtk.DOUBLE (real ex1)),
				    ("y1", Gtk.DOUBLE (real ey1)),
				    ("x2", Gtk.DOUBLE (real (ex1 + 1))),
				    ("y2", Gtk.DOUBLE (real (ey1 + 1))),
				    ("fill_color_gdk", Gtk.OBJECT black)])
		
	    val rightEye = 
		GtkCanvas.itemNew (head,
				   GtkCanvas.RECTANGLE,
				   [("x1", Gtk.DOUBLE (real ex2)),
				    ("y1", Gtk.DOUBLE (real ey2)),
				    ("x2", Gtk.DOUBLE (real (ex2 + 1))),
				    ("y2", Gtk.DOUBLE (real (ey2 + 1))),
				    ("fill_color_gdk", Gtk.OBJECT black)])
	in
	    head
	end
	    
    fun insertBody (canvas, x, y, snakecol) =
	let
	    val body = 
		GtkCanvas.itemNew (canvas, GtkCanvas.GROUP,
				   [("x",Gtk.DOUBLE (real x)),
				    ("y",Gtk.DOUBLE (real y))])

	    val ground = 
		GtkCanvas.itemNew (body, GtkCanvas.ELLIPSE,
				   [("x1", Gtk.DOUBLE 0.0),
				    ("y1", Gtk.DOUBLE 0.0),
				    ("x2", Gtk.DOUBLE (real cellSize)),
				    ("y2", Gtk.DOUBLE (real cellSize)),
				    ("fill_color_gdk", Gtk.OBJECT snakecol)])
		
	in
	    body
	end

    fun insertClosedGate (canvas, x, y, gatecol) = 
	let
	    val gate = 
		GtkCanvas.itemNew (canvas, GtkCanvas.GROUP,
				   [("x", Gtk.DOUBLE (real x)),
				    ("y", Gtk.DOUBLE (real y))])
		
	    val ground = 
		GtkCanvas.itemNew (gate, GtkCanvas.RECTANGLE,
				   [("x1", Gtk.DOUBLE 0.0),
				    ("y1", Gtk.DOUBLE 0.0),
				    ("x2", Gtk.DOUBLE (real cellSize)),
				    ("y2", Gtk.DOUBLE (real cellSize)),
				    ("fill_color_gdk", Gtk.OBJECT gatecol),
				    ("outline_color_gdk", Gtk.OBJECT black)])
	in
	    gate
	end

    fun insertOpenGate (canvas, x, y, gatecol) = 
	let
	    val gate = 
		GtkCanvas.itemNew (canvas, GtkCanvas.GROUP,
				   [("x", Gtk.DOUBLE (real x)),
				    ("y", Gtk.DOUBLE (real y))])
		
	    val ground = 
		GtkCanvas.itemNew (gate, GtkCanvas.RECTANGLE,
				   [("x1", Gtk.DOUBLE 0.0),
				    ("y1", Gtk.DOUBLE 0.0),
				    ("x2", Gtk.DOUBLE (real cellSize)),
				    ("y2", Gtk.DOUBLE (real cellSize)),
				    ("fill_color_gdk", Gtk.OBJECT gatecol),
				    ("outline_color_gdk", Gtk.OBJECT black)])

	    val opens = 
		GtkCanvas.itemNew (gate, GtkCanvas.RECTANGLE,
				   [("x1", Gtk.DOUBLE 3.0),
				    ("y1", Gtk.DOUBLE 3.0),
				    ("x2", Gtk.DOUBLE (real (cellSize-3))),
				    ("y2", Gtk.DOUBLE (real (cellSize-3))),
				    ("fill_color_gdk", Gtk.OBJECT black),
				    ("outline_color_gdk", Gtk.OBJECT black)])

	in
	    gate
	end

    fun insertWall (canvas, x, y) = 
	let
	    val wall = 
		GtkCanvas.itemNew (canvas, GtkCanvas.GROUP,
				   [("x", Gtk.DOUBLE (real x)),
				    ("y", Gtk.DOUBLE (real y))])
		
	    val ground = 
		GtkCanvas.itemNew (wall, GtkCanvas.RECTANGLE,
				   [("x1", Gtk.DOUBLE 0.0),
				    ("y1", Gtk.DOUBLE 0.0),
				    ("x2", Gtk.DOUBLE (real cellSize)),
				    ("y2", Gtk.DOUBLE (real cellSize)),
				    ("fill_color_gdk", Gtk.OBJECT red),
				    ("outline_color_gdk", Gtk.OBJECT black)])
		
	in
	    wall
	end

    fun insertGoodie (canvas, x, y, n) =
	(* where n is the amount of a goodie *)
	let
	    val goodie = 
		GtkCanvas.itemNew (canvas, GtkCanvas.GROUP,
				   [("x", Gtk.DOUBLE (real x)),
				    ("y", Gtk.DOUBLE (real y))])
		
	    val ground = 
		GtkCanvas.itemNew (goodie, GtkCanvas.ELLIPSE,
				   [("x1", Gtk.DOUBLE 0.0),
				    ("y1", Gtk.DOUBLE 0.0),
				    ("x2", Gtk.DOUBLE (real cellSize)),
				    ("y2", Gtk.DOUBLE (real cellSize)),
				    ("fill_color_gdk", Gtk.OBJECT red),
				    ("outline_color_gdk", Gtk.OBJECT black)])
		
	in
	    goodie
	end

    fun createNewFieldObj (r, c, field) arena canvas = 
	let
	    val x = cellSize * c
	    val y = cellSize * r
	in
	    (* place the new one *)
	    case field of
		P.EMPTY                => 
		    Array2.update (arena, r, c, (Gtk.null (), field))
	      | P.WALL                 => 
		    Array2.update (arena, r, c, 
				   (insertWall (canvas, x, y), field))
	      | P.GOODY n              => 
		    Array2.update (arena, r, c, 
				   (insertGoodie (canvas, x, y, n), field))
	      | P.GATE (col, P.CLOSED) => 
		    Array2.update (arena, r, c, 
				   (insertClosedGate (canvas, x, y, 
						      color col),
				    field))
	      | P.GATE (col, P.OPEN)   => 
		    Array2.update (arena, r, c, 
				   (insertOpenGate (canvas, x, y, 
						    color col), field))
	      | P.SNAKE_HEAD (d, col) => 
		    Array2.update (arena, r, c, 
				   (insertHead (canvas, x, y, d, color col), 
				    field))
	      | P.SNAKE_BODY col      => 
		    Array2.update (arena, r, c, 
				   (insertBody (canvas, x, y, color col), 
				    field))
	end

    fun moveFieldObjTo (obj, oldR, oldC, newR, newC, field) arena _ =
	let
	    val deltaY = Real.fromInt (cellSize * (newR - oldR))
	    val deltaX = Real.fromInt (cellSize * (newC - oldC))
	in
	    GtkCanvas.itemMove (obj, deltaX, deltaY);
	    GtkCanvas.itemShow obj;
	    Array2.update (arena, newR, newC, (obj, field))
	end


    fun changeField (object, oldField, r, c, field) cache = 
	(if object <> Gtk.null () orelse oldField <> P.EMPTY
	     then (addToItemCache (r, c, object, oldField) cache;
		   GtkCanvas.itemHide object)
	 else ();
	 case List.find (fn (_, _, _, f) => f = field) (!cache) of
	     NONE                      => createNewFieldObj (r, c, field)
	   | SOME (row, col, obj, fld) => 
		 (removeFromItemCache (row, col, obj, fld) cache;
		  moveFieldObjTo (obj, row, col, r, c, fld)))

    fun insert cache arena canvas ((r, c), field) = 
	let
	    val (rows, cols) = Array2.dimensions arena
	    val _ = assert 0 <= r andalso r < rows andalso
		0 <= c andalso c < cols
	    val (obj, f) = Array2.sub (arena, r, c)
	in
	    if f = field (* shouldn't happen normally *)
		then ()
	    else changeField (obj, f, r, c, field) cache arena canvas
	end

	
    fun arenaWidth (a:arena_widget) =
	let
	    val (_, cols) = Array2.dimensions (! ( #state a))
	in
	    cols * cellSize
	end


    fun arenaHeight (a:arena_widget) =
	let
	    val (rows, _) = Array2.dimensions (! ( #state a))
	in
	    rows * cellSize
	end


    fun changeView (a:arena_widget, (y, x)) =
	let
	    val obj = toObject a
	    val minX = 0
	    val maxX = arenaWidth a
	    val minY = 0
	    val maxY = arenaHeight a
	    val x    = x * cellSize - windowWidth2
	    val y    = y * cellSize - windowHeight2

	    val _ = GtkCanvas.scrollTo (obj, x, y)

	    val (x1, y1, x2, y2) = 
		GtkCanvas.getScrollRegion (obj, 0.0, 0.0, 0.0, 0.0)
	in
            (* gtkcanvas seems to be buggy.  On windows
               the call to scrollTo produces garbage unless
               being followed by a call to requestRedraw.
               It works perfectly well on Linux without this
               call!
             *)
            if Config.platform = Config.WIN32 then
	        GtkCanvas.requestRedraw (obj, Real.round x1, 
				        Real.round y1, 
				        Real.round x2, 
				        Real.round y2)
            else ()
	end

    fun update (a as {canvas, state = ref arena, itemCache}, difflist, pos) =
	let
            val root = GtkCanvas.root canvas
	in
            Gtk.layoutFreeze canvas;
	    List.app (insert itemCache arena root) difflist;
            (case pos of
                NONE    => ()
            |   SOME p  => changeView (a, p) );
            Gtk.layoutThaw canvas
	end 

    fun startCountDown a =
        let
            val obj         = toObject a
            val oldNumber   = ref (Gtk.null ())
            val color       = white
           
            fun changeObj new =
                (if !oldNumber <> Gtk.null () 
                    then Gtk.objectDestroy (!oldNumber)
                    else ();
                 oldNumber := new)

 
            fun display NONE =
                changeObj (Gtk.null ())
              | display (SOME n) =
                let
                    val root    = GtkCanvas.root obj
                    val num     = Int.toString n
	            val font   = 
                            "-*-*-*-*-*-*-34-*-*-*-*-*-*-*"
                    val (x, y) = GtkCanvas.getScrollOffsets 
                        (obj, 0, 0)
                    val x      = Real.fromInt (x + 200)
                    val y      = Real.fromInt (y + 150)
                    val anchor = Gtk.ANCHOR_CENTER
                    val args   = [("text", GtkCanvas.STRING num),
                                  ("font", GtkCanvas.STRING font),
                                  ("x", GtkCanvas.DOUBLE x), 
                                  ("y", GtkCanvas.DOUBLE y),
                                  ("fill_color_gdk", 
                                   GtkCanvas.OBJECT color),
                                  ("anchor", GtkCanvas.INT anchor)]
                        
                    val numObj  = GtkCanvas.itemNew (root, 
                                                 GtkCanvas.TEXT, args)
                in
                    changeObj numObj
                end
        in
            display
        end
                
end
