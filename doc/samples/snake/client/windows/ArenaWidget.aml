(* Alice Snake 2.0 - GUI
*
*  Authors: Benedikt Grundmann / Sebastian Germesin
*
*  $Revision$
*
*  Last updated: $Date$ by $Author$
* 
*
*)

import structure Gtk           from "x-alice:/lib/gtk/Gtk"
import structure Gdk           from "x-alice:/lib/gtk/Gdk"
import structure GtkCanvas     from "x-alice:/lib/gtk/GtkCanvas"
import functor   MkRedBlackMap from "x-alice:/lib/data/MkRedBlackMap"
import structure Inspector     from "x-alice:/lib/tools/Inspector"
import structure Config        from "x-alice:/lib/system/Config"

import signature ARENAWIDGET   from "ARENAWIDGET-sig"
import structure Protocol      from "../../common/Protocol"
import structure Color         from "../../common/Color"
import structure Pos           from "../../common/Pos"
import structure Arena         from "../../server/Arena"

(* Overview:

 Tournament starts:
       val arena = ArenaWidget.initialize

 Level starts:
       initLevel (arena, levelinfo)
 
 every Tick:
       update (arena, difflist)
       changeView (arena, (x, y))

 new Level starts:
       initLevel (arena, levelinfo)

...

*)


fun colorConv n = Real.round (65535.0 * n)

local

    val colormap = Gdk.colormapGetSystem ()

    structure CMap = MkRedBlackMap (Color)

    fun conv c = 
	let
	    val (r, g, b) = Color.rgb c
	    val color = Gdk.allocColor (colorConv r, colorConv g, colorConv b)
	in
	    Gdk.colormapAllocColor (colormap, color, false, true);
	    color
	end

    fun convArena (r, g, b) = 
	let
	    val color = Gdk.allocColor (colorConv r, colorConv g, colorConv b)
	in
	    Gdk.colormapAllocColor (colormap, color, false, true);
	    color
	end

    val map  = List.foldl (fn (c, map) =>
			   CMap.insertDisjoint (map, c, conv c)) CMap.empty
	Color.all
	
in
    fun color c = CMap.lookupExistent (map, c);
    val black    = convArena (0.0, 0.0, 0.0);
    val green    = convArena (0.32, 0.66, 0.17);
    val red      = convArena (1.0, 0.0, 0.0);
    val white    = convArena (1.0, 1.0, 1.0)
	
end


(* some values *)
val cellSize     =  20
val windowWidth  = 400
val windowHeight = 300

val backgroundColor = green

structure P = Protocol


structure ArenaWidget :> ARENAWIDGET =
struct

    type arena_field = Gtk.object * P.field
	
    type arena_widget = 
	{
	 canvas : Gtk.object,
	 state  : arena_field Array2.array ref
	 }

    val cellSize2     = cellSize     div 2
    val windowHeight2 = windowHeight div 2
    val windowWidth2  = windowWidth  div 2
	
    fun initialize () = 
        let
	    val canvas = GtkCanvas.new 1
            (* antialiasing mode: val canvas = GtkCanvas.newAa ()*)
        in
            Gtk.layoutFreeze canvas;
	    {
	        canvas,
	        state  = ref (Array2.array(0, 0, (Gtk.null (), P.EMPTY)))
	    }
        end
	
    fun toObject ({canvas, ... } : arena_widget) : Gtk.object  = canvas
	
    fun initLevel ({canvas, state}, {dimensions = dim} : P.level_info) =
	let
	    val (rows, cols) = dim
	    val _ = GtkCanvas.setScrollRegion (canvas, 0.0, 0.0,
					       Real.fromInt(cols * cellSize),
					       Real.fromInt(rows * cellSize))
	    val _ = Gtk.widgetSetUsize (canvas, windowWidth, windowHeight)
	    val root = GtkCanvas.root canvas
	    val _ = 
		GtkCanvas.itemNew (root, Gtk.RECTANGLE,
				   [("x1", Gtk.DOUBLE 0.0),
				    ("y1", Gtk.DOUBLE 0.0),
				    ("x2", Gtk.DOUBLE(real (cols * cellSize))),
				    ("y2", Gtk.DOUBLE(real (rows * cellSize))),
				    ("fill_color_gdk", Gtk.OBJECT green),
				    ("outline_color_gdk", Gtk.OBJECT green)])
	    val arena = Array2.array (rows, cols, (Gtk.null (), P.EMPTY))
	in
	    state  := arena
	end
	

    fun insertHead (canvas, x, y, d, snakecol) =
	let
	    val (ex1, ey1, ex2, ey2) = 
		case d of
		    P.UP    => (2 * cellSize div 10,
				3 * cellSize div 10,
				5 * cellSize div 10,
				3 * cellSize div 10)
		  | P.DOWN  => (2 * cellSize div 10,
				4 * cellSize div 10,
				5 * cellSize div 10,
				4 * cellSize div 10)
		  | P.LEFT  => (3 * cellSize div 10,
				2 * cellSize div 10,
				3 * cellSize div 10,
				5 * cellSize div 10)
		  | P.RIGHT => (4 * cellSize div 10,
				2 * cellSize div 10,
				4 * cellSize div 10,
				5 * cellSize div 10)
		    
	    val tonglist = 
		case d of
		    P.UP    => [(4 * cellSize div 10),
				(1 * cellSize div 10),
				(4 * cellSize div 10),
			       (~3 * cellSize div 10)]
		  | P.DOWN  => [(4 * cellSize div 10),
				(8 * cellSize div 10),
				(4 * cellSize div 10),
			       (11 * cellSize div 10)]
		  | P.LEFT  => [(1 * cellSize div 10),
				(4 * cellSize div 10),
			       (~3 * cellSize div 10),
			        (4 * cellSize div 10)]
		  | P.RIGHT => [(8 * cellSize div 10),
				(4 * cellSize div 10),
			       (11 * cellSize div 10),
				(4 * cellSize div 10)]

	    val head = 
		GtkCanvas.itemNew (canvas, GtkCanvas.GROUP,
				   [("x", Gtk.DOUBLE (real x)),
				    ("y", Gtk.DOUBLE (real y))])

	    val ground = 
		GtkCanvas.itemNew (head, GtkCanvas.ELLIPSE,
				   [("x1", Gtk.DOUBLE 0.0),
				    ("y1", Gtk.DOUBLE 0.0),
				    ("x2", Gtk.DOUBLE (real cellSize)),
				    ("y2", Gtk.DOUBLE (real cellSize)),
				    ("fill_color_gdk", Gtk.OBJECT snakecol)])

	    val tongue = 
		GtkCanvas.itemNew (head, 
				   GtkCanvas.LINE,
				   [("points", Gtk.POINTS tonglist),
				    ("fill_color_gdk", Gtk.OBJECT red),
				    ("width_pixels",Gtk.INT(cellSize div 10))])

	    val leftEye = 
		GtkCanvas.itemNew (head,
				   GtkCanvas.RECTANGLE,
				   [("x1", Gtk.DOUBLE (real ex1)),
				    ("y1", Gtk.DOUBLE (real ey1)),
				    ("x2", Gtk.DOUBLE (real (ex1 + 1))),
				    ("y2", Gtk.DOUBLE (real (ey1 + 1))),
				    ("fill_color_gdk", Gtk.OBJECT black)])
		
	    val rightEye = 
		GtkCanvas.itemNew (head,
				   GtkCanvas.RECTANGLE,
				   [("x1", Gtk.DOUBLE (real ex2)),
				    ("y1", Gtk.DOUBLE (real ey2)),
				    ("x2", Gtk.DOUBLE (real (ex2 + 1))),
				    ("y2", Gtk.DOUBLE (real (ey2 + 1))),
				    ("fill_color_gdk", Gtk.OBJECT black)])
	in
	    head
	end
	    
    fun insertBody (canvas, x, y, snakecol) =
	let
	    val body = 
		GtkCanvas.itemNew (canvas, GtkCanvas.GROUP,
				   [("x",Gtk.DOUBLE (real x)),
				    ("y",Gtk.DOUBLE (real y))])

	    val ground = 
		GtkCanvas.itemNew (body, GtkCanvas.ELLIPSE,
				   [("x1", Gtk.DOUBLE 0.0),
				    ("y1", Gtk.DOUBLE 0.0),
				    ("x2", Gtk.DOUBLE (real cellSize)),
				    ("y2", Gtk.DOUBLE (real cellSize)),
				    ("fill_color_gdk", Gtk.OBJECT snakecol)])
		
	in
	    body
	end

    fun insertOpenGate (canvas, x, y, gatecol) = 
	let
	    val gate = 
		GtkCanvas.itemNew (canvas, GtkCanvas.GROUP,
				   [("x", Gtk.DOUBLE (real x)),
				    ("y", Gtk.DOUBLE (real y))])
		
	    val ground = 
		GtkCanvas.itemNew (gate, GtkCanvas.RECTANGLE,
				   [("x1", Gtk.DOUBLE 0.0),
				    ("y1", Gtk.DOUBLE 0.0),
				    ("x2", Gtk.DOUBLE (real cellSize)),
				    ("y2", Gtk.DOUBLE (real cellSize)),
				    ("fill_color_gdk", Gtk.OBJECT gatecol),
				    ("outline_color_gdk", Gtk.OBJECT black)])
	in
	    gate
	end

    fun insertClosedGate (canvas, x, y, gatecol) = 
	let
	    val gate = 
		GtkCanvas.itemNew (canvas, GtkCanvas.GROUP,
				   [("x", Gtk.DOUBLE (real x)),
				    ("y", Gtk.DOUBLE (real y))])
		
	    val ground = 
		GtkCanvas.itemNew (gate, GtkCanvas.RECTANGLE,
				   [("x1", Gtk.DOUBLE 0.0),
				    ("y1", Gtk.DOUBLE 0.0),
				    ("x2", Gtk.DOUBLE (real cellSize)),
				    ("y2", Gtk.DOUBLE (real cellSize)),
				    ("fill_color_gdk", Gtk.OBJECT gatecol),
				    ("outline_color_gdk", Gtk.OBJECT black)])

	    val cross = 
		let
		    val font  = "-*-*-*-*-*-24-*-*-*-*-*-*-*-*"
		    val x = Real.fromInt cellSize2
		    val y = Real.fromInt cellSize2
		    val anchor = Gtk.ANCHOR_CENTER
		    val color = black
		in
		    GtkCanvas.itemNew (gate, GtkCanvas.TEXT,
				       [("text", GtkCanvas.STRING "X"),
					("font", GtkCanvas.STRING font),
					("x", GtkCanvas.DOUBLE x), 
					("y", GtkCanvas.DOUBLE y),
					("fill_color_gdk", 
					 GtkCanvas.OBJECT color),
					("anchor", GtkCanvas.INT anchor)])
		end
	in
	    gate
	end

    fun insertWall (canvas, x, y) = 
	let
	    val wall = 
		GtkCanvas.itemNew (canvas, GtkCanvas.GROUP,
				   [("x", Gtk.DOUBLE (real x)),
				    ("y", Gtk.DOUBLE (real y))])
		
	    val ground = 
		GtkCanvas.itemNew (wall, GtkCanvas.RECTANGLE,
				   [("x1", Gtk.DOUBLE 0.0),
				    ("y1", Gtk.DOUBLE 0.0),
				    ("x2", Gtk.DOUBLE (real cellSize)),
				    ("y2", Gtk.DOUBLE (real cellSize)),
				    ("fill_color_gdk", Gtk.OBJECT red),
				    ("outline_color_gdk", Gtk.OBJECT black)])
		
	in
	    wall
	end

    fun insertGoodie (canvas, x, y, n) =
	(* where n is the amount of a goodie *)
	let
	    val goodie = 
		GtkCanvas.itemNew (canvas, GtkCanvas.GROUP,
				   [("x", Gtk.DOUBLE (real x)),
				    ("y", Gtk.DOUBLE (real y))])
		
	    val ground = 
		GtkCanvas.itemNew (goodie, GtkCanvas.ELLIPSE,
				   [("x1", Gtk.DOUBLE 0.0),
				    ("y1", Gtk.DOUBLE 0.0),
				    ("x2", Gtk.DOUBLE (real cellSize)),
				    ("y2", Gtk.DOUBLE (real cellSize)),
				    ("fill_color_gdk", Gtk.OBJECT red),
				    ("outline_color_gdk", Gtk.OBJECT black)])
		
	in
	    goodie
	end


    fun update ({canvas, state = ref arena}, difflist) =
	let
            val can = GtkCanvas.root canvas

            fun changeField (oldObj:Gtk.object, r, c, field) =
                let
                    val x = cellSize * c
                    val y = cellSize * r
                in
                    (* destroy old object if existing *)
                    if oldObj <> Gtk.null () 
			then Gtk.objectDestroy oldObj
                    else ();
                    (* place the new one *)
                    case field of
		        P.EMPTY              => 
                            Array2.update (arena, r, c, (Gtk.null (), field))
                    |   P.WALL               => 
			    Array2.update (arena, r, c, 
					   (insertWall (can, x, y), field))
                    | P.GOODY n              => 
			    Array2.update (arena, r, c, 
					  (insertGoodie (can, x, y, n), field))
                    | P.GATE (col, P.CLOSED) => 
			    Array2.update (arena, r, c, 
					   (insertClosedGate (can, x, y, 
							      color col),
					    field))
                    | P.GATE (col, P.OPEN)   => 
			    Array2.update (arena, r, c, 
					   (insertOpenGate (can, x, y, 
							    color col), field))
                    | P.SNAKE_HEAD (d, col) => 
                        Array2.update (arena, r, c, 
                            (insertHead (can, x, y, d, color col), field))
                    | P.SNAKE_BODY col      => 
                        Array2.update (arena, r, c, 
                            (insertBody (can, x, y, color col), field))
                end

	    fun insert ((r, c), field) = 
		let
                    val (rows, cols)    = Array2.dimensions arena
                    val _   = assert 0 <= r andalso r < rows andalso
                                0 <= c andalso c < cols
		    val (obj, f) = Array2.sub(arena, r, c)
		in 
		    if f = field  (* shouldn't happen normally *)
			then () 
		    else 
                        changeField (obj, r, c, field)
		end
	in
	    List.app insert difflist
	end 
	
    fun arenaWidth (a:arena_widget) =
	let
	    val (_, cols) = Array2.dimensions (! ( #state a))
	in
	    cols * cellSize
	end


    fun arenaHeight (a:arena_widget) =
	let
	    val (rows, _) = Array2.dimensions (! ( #state a))
	in
	    rows * cellSize
	end


    fun changeView (a, (y, x)) =
	let
	    val obj = toObject a
	    val minX = 0
	    val maxX = arenaWidth a
	    val minY = 0
	    val maxY = arenaHeight a
	    val x    = x * cellSize - windowWidth2
	    val y    = y * cellSize - windowHeight2

	    val _ = GtkCanvas.scrollTo (obj, x, y)

	    val (x1, y1, x2, y2) = 
		GtkCanvas.getScrollRegion (obj, 0.0, 0.0, 0.0, 0.0)
	in
            (* gtkcanvas seems to be buggy.  On windows
               the call to scrollTo produces garbage unless
               being followed by a call to requestRedraw.
               It works perfectly well on Linux without this
               call!
             *)
            if Config.platform = Config.WIN32 then
	        GtkCanvas.requestRedraw (obj, Real.round x1, 
				        Real.round y1, 
				        Real.round x2, 
				        Real.round y2)
            else ();
            Gtk.layoutThaw obj;
	    Gtk.layoutFreeze obj

	end

    fun startCountDown a =
        let
            val obj         = toObject a
            val oldNumber   = ref (Gtk.null ())
            val color       = white
           
            fun changeObj new =
                (if !oldNumber <> Gtk.null () 
                    then Gtk.objectDestroy (!oldNumber)
                    else ();
                 oldNumber := new)

 
            fun display NONE =
                changeObj (Gtk.null ())
              | display (SOME n) =
                let
                    val root    = GtkCanvas.root obj
                    val num     = Int.toString n
	            val font   = 
                            "-*-*-*-*-*-*-34-*-*-*-*-*-*-*"
                    val (x, y) = GtkCanvas.getScrollOffsets 
                        (obj, 0, 0)
                    val x      = Real.fromInt (x + 200)
                    val y      = Real.fromInt (y + 150)
                    val anchor = Gtk.ANCHOR_CENTER
                    val args   = [("text", GtkCanvas.STRING num),
                                  ("font", GtkCanvas.STRING font),
                                  ("x", GtkCanvas.DOUBLE x), 
                                  ("y", GtkCanvas.DOUBLE y),
                                  ("fill_color_gdk", 
                                   GtkCanvas.OBJECT color),
                                  ("anchor", GtkCanvas.INT anchor)]
                        
                    val numObj  = GtkCanvas.itemNew (root, 
                                                 GtkCanvas.TEXT, args)
                in
                    changeObj numObj;
                    Gtk.layoutThaw obj;
                    Gtk.layoutFreeze obj
                end
        in
            display
        end
                
end
