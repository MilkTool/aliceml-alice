import structure Protocol   from "../common/Protocol"
import structure Config     from "../server/Config"
import structure Color      from "../common/Color"
import structure Pos        from "../common/Pos"
import structure Highscore  from "../common/Highscore"

signature GUI =
sig
type error = string

type model_initial = 
    {
     connect : string -> error option,
     (* connect to an existing server. If successful i.e
      NONE is returned the gui displays the select snake
      dialog. Otherwise it shows the error message and
      stays in the initial mode.
      *)

     startServer : Config.config -> error option
     (* start a new server and display the snake selection
      dialog (in server mode i.e. with the ability to
      start a tournament)
      *)
     }

type model_join = 
    {
     play :  string * Color.color -> error option,
     
     watch : unit -> error option
     }

type model_game = 
    {
     turn       : Protocol.direction -> unit,
     changeView : Protocol.view_hint -> unit,
     giveUp     : unit -> unit
     }
    
(* register a callback here to get notified, when some event
 is triggered by the gui.  
 *)

type  model = 
    {
     quit :  unit -> unit,
     (* user wants to quit. *)
     
     initial:    model_initial,
     join:       model_join,
     game:       model_game
     }
    
(* call these functions provided by the gui, if something
 happens to the model.
 *)
    
type gui_join = 
    {
     playersJoined : (string * Color.color) list -> unit,
     playerDisconnected : string * Color.color -> unit,
     gameStarted : unit -> unit
     }

type gui_game = 
    {
     update       : (Pos.pos * Protocol.field) list -> unit,
     updatePoints : Highscore.points list -> unit,
     gameFinished : Highscore.highscore -> unit
     }

type gui =  
    {
     reset : (string * string) option -> unit
     (* [reset NONE] reset's the gui to show the inital
      startup screen.  
      [reset (SOME (title, msg))] first shows an messagebox
      with title [title] displaying message [message] and
      reset's the gui afterwards
      *)
     
     }



val execute: model * gui Promise.promise -> unit

end