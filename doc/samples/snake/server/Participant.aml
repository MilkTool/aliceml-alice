import signature PARTICIPANT   from "PARTICIPANT-sig"
import structure Protocol      from "../common/Protocol"
import structure Color         from "../common/Color"
import structure Snake         from "Snake"
import structure MkRedBlackMap from "x-alice:/lib/data/MkRedBlackMap"

structure Participant :> PARTICIPANT =
struct
    type id = int

    type player_info = {
	       points     : int ref,
               gamePoints : int ref,
	       name       : string,
	       color      : Color.color,
	       nextDir    : Protocol.direction ref,
               gatePos    : (int * int) ref,
	       deathCount : int ref
		       }

    datatype state =
	CONNECTED
      | PLAYING  of player_info * Snake.snake
      | HALF_FINISHED of player_info * int ref
      | FINISHED of player_info * id option ref 
      | DEAD     of player_info * id option ref
      | WATCHING of id option ref
      | DISCONNECTED    (* TODO: Do we need it? *)


    type participant = (id * Protocol.client_interface * state ref)

    
    fun participant (id, interface) =
        (id, interface, ref CONNECTED)

    fun playerInfo (_, _, ref (PLAYING (st, _)))        = st
    |   playerInfo (_, _, ref (HALF_FINISHED (st, _)))  = st
    |   playerInfo (_, _, ref (FINISHED (st, _)))       = st
    |   playerInfo (_, _, ref (DEAD (st, _)))           = st
    |   playerInfo _                                    = assert false


    fun snake (_, _, ref (PLAYING (_, sn)))        = sn
    |   snake _                                    = assert false

    fun id (id, _, _) = id

    fun client_interface (_, i, _)  = i

    fun state (_, _, s) = s

    fun nameNColor p = 
        let
            val info    = playerInfo p
            val name    = #name info
            val color   = #color info
        in
            (name, color)
        end


    structure Map = MkRedBlackMap (Int)
    
    type pmap = participant Map.map
    
    (* [allParticpants p] returns all participants which 
       satisfy the predicate [p].  
     *)
    fun allParticipants p map = List.filter p ( List.map #2  (Map.toList map) )
    
    (* [allPlayers ()] returns all snakes which are 
       still playing.
     *)
    fun allPlayers p   = allParticipants 
            (fn p =>
                case !(state p) of
                    PLAYING _              => true
                |   _                      => false) p
    
    fun allHalfFinished p  = allParticipants 
            (fn p => 
                case !(state p) of 
                    HALF_FINISHED _        => true
                |   _                      => false) p


    fun allNonFinished p   = allParticipants 
            (fn p =>
                case !(state p) of
                    PLAYING _              => true
                |   HALF_FINISHED _        => true
                |   _                      => false) p


    fun allConnected p = allParticipants
            (fn p =>
                case !(state p) of
                    DISCONNECTED   => false
                |   _              => true) p

    fun allWithPoints p = allParticipants 
            (fn p =>
                case !(state p) of
                    PLAYING _              => true
                |   FINISHED _             => true
                |   HALF_FINISHED _        => true
                |   DEAD _                 => true
                |   _                      => false) p

 
end
