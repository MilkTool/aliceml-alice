(* Alice Snake 2.0 - Arena
 *
 *  Authors: Benedikt Grundmann / Sebastian Germesin
 *
 *  $Revision$
 *
 *  Last updated: $Date$ by $Author$
 * 
 *
 *)

import signature ARENA    from "ARENA-sig"
import structure Protocol from "../common/Protocol"
import structure Inspector from "x-alice:/lib/tools/Inspector"
import structure Snake    from "Snake"
import structure Pos      from "../common/Pos"
import structure Random   from "x-alice:/lib/utility/Random"

structure Arena :> ARENA =
struct

    structure P = Protocol

    type arena = P.field Array2.array (* MUTABLE *)


    type config = 
	{
	 dimensions: int * int,
	 players: int,
	 walls: int
	 (* MAGIC NUMBERs ... *)
	 }

    fun random {dimensions : int * int, players,walls} =
	let
	    val (rows,cols) = dimensions
	    val arena = Array2.array(rows,cols,P.EMPTY)
	    (* initialising an empty arena with dimensions [dimensions] *)

	    fun setLimit () = (* set a wall round the level *)
		let
		    fun horizontal r = 
			if r = rows
			    then (Array2.update(arena,rows-1,0,P.WALL);
				  Array2.update(arena,rows-1,cols-1,P.WALL))
			else (Array2.update(arena,r,0,P.WALL);
			      Array2.update(arena,r,cols-1,P.WALL);
			      horizontal(r + 1))
		    fun vertical c = 
			if c = cols 
			    then (Array2.update(arena,0,cols-1,P.WALL);
				  Array2.update(arena,rows-1,cols-1,P.WALL))
			else (Array2.update(arena,0,c,P.WALL);
			      Array2.update(arena,rows-1,c,P.WALL);
			      vertical(c + 1))
		in
		    (horizontal (0); vertical (0))
		end

	    val _ = setLimit ()

	    fun setWall   _   0 _ _ xs = xs
	      | setWall (0,_) _ _ _ xs = xs
	      | setWall (_,0) _ _ _ xs = xs
	      | setWall (r,c) n d v xs = if r >= (rows-1) orelse c >= (cols-1) then xs else
		case d of
	        P.UP     => ((Array2.update(arena,r,c,v);
			     setWall (r-1,c) (n-1) d v ((r,c)::xs)) handle Subscript => setWall (0,0) 0 d v nil)
	      | P.DOWN   => ((Array2.update(arena,r,c,v);
			     setWall (r+1,c) (n-1) d v ((r,c)::xs)) handle Subscript => setWall (0,0) 0 d v nil)
	      | P.LEFT   => ((Array2.update(arena,r,c,v);
			     setWall (r,c-1) (n-1) d v ((r,c)::xs)) handle Subscript => setWall (0,0) 0 d v nil)
	      | P.RIGHT  => ((Array2.update(arena,r,c,v);
			     setWall (r,c+1) (n-1) d v ((r,c)::xs)) handle Subscript => setWall (0,0) 0 d v nil)

	    fun setWall a b c d e = (Inspector.inspect(a,b,c,d,e);setWall a b c d e)

	    fun child 0 _ _   _     _   = ()
	      | child _ _ _   _    nil  = ()
	      | child n c 4 dlist slist =
		let
		    val d = List.nth(dlist,Random.int (List.length dlist))
		    val start = List.nth(slist,Random.int(List.length dlist)) (* letzten beiden net !! *)
		    val l = Random.int ((rows + cols) div 10)
		    val news = setWall start l d P.EMPTY nil
		    val newd = if d = P.LEFT orelse d = P.RIGHT
				   then [P.UP,P.DOWN]
			       else [P.LEFT,P.RIGHT]
		in
		    child (n-1) (c+1) 1 newd news
		end
	      | child n c v dlist slist =
		let
		    val d = List.nth(dlist,Random.int (List.length dlist))
		    val start = List.nth(slist,Random.int(List.length dlist)) (* letzten beiden net !! *)
		    val l = Random.int ((rows + cols) div 10)
		    val e = case Random.int 3 of 
			      0 => P.WALL
			    | 1 => P.EMPTY
			    | 2 => P.WALL
			    | _ => assert false
		    val news = setWall start l d e nil
		    val newd = if d = P.LEFT orelse d = P.RIGHT
				   then [P.UP,P.DOWN]
			       else [P.LEFT,P.RIGHT]
		in
		    if e = P.EMPTY
			then child (n-1) (c+1) 1 newd news
		    else child (n-1) (c+1) (v+1) newd news
		end

	    (** [child n c v dlist slist] builds a child-wall. n ist zahl der noch
	        zu machenden kinder
	        c ist die zahl der schon gemachten kinder
		v ist die zahl der bisher visible kinder
		dlist ist die liste der richtungen für child
		slist ist die liste der startpunkte für child *)

	    fun parent () =
		let
		    val d = case Random.int 4 of
			0 => P.UP
		      | 1 => P.DOWN
		      | 2 => P.LEFT
		      | 3 => P.RIGHT
		      | _ => assert false
		   
		    val newd = if d = P.LEFT orelse d = P.RIGHT
				   then [P.UP,P.DOWN]
			       else [P.LEFT,P.RIGHT]
				   
		    val len = Random.int ((rows+cols) div 10)

		    val news = setWall ((rows div 4) + Random.int (rows div 2) ,(cols div 4) + Random.int (cols div 2)) 
			               len
				       d 
				       P.WALL 
				       nil
		    val _ = Inspector.inspect(news,d,len)
		in
		    child walls 1 1 newd news
		end

 	    fun startPointTest(r,c,d)  = Array2.sub(arena,r,c) = P.EMPTY 
	    (* TODO: implementation *)

	    fun startpoints 0 xs = xs
	      | startpoints p xs = 
		let
		    val (r,c) = (Random.int rows,Random.int cols)
		    val d = 
			case Random.int 4 of
			    0 => P.UP
			  | 1 => P.DOWN
			  | 2 => P.LEFT
			  | 3 => P.RIGHT
			  | _ => assert false
		in
		    if startPointTest(r,c,d)
			then startpoints (p-1) (((r,c),d)::xs)
		    else startpoints p xs
		end

	in
	     parent ();
	     (arena,startpoints players nil)
	end

    fun placeSnakes (a,snakes) =
	let
	    val died = ref nil
	    val halffin = ref nil
	    val fin = ref nil

	    fun killSnake s = 
		let
		    val hb = (Snake.head s)::(Snake.body s)
		in
		    died := s::(!died);
		    List.app 
		        (fn (r,c) => Array2.update(a,r,c,P.EMPTY)) hb
		end

	    fun placeHead snake =
		let
		    val (r,c) = Snake.head snake
		    val color = Snake.color snake
		    val dir   = Snake.direction snake
		    val collObject = Array2.sub(a,r,c)
		    fun hitSnake s     nil     = false
		      | hitSnake s (sn::slist) = 
			let
			    val hb = (Snake.head sn)::(Snake.body sn)
			in
			    if List.exists (fn x => Snake.head s = x) hb
				then true
			    else hitSnake s slist
			end
			
		    val othersnakes = 
			    List.filter (fn x => not (snake = x)) snakes
		    val hit = hitSnake snake othersnakes
		in
		    Array2.update(a,r,c,P.SNAKE_HEAD(dir,color));
		    if hit
			then killSnake snake
		    else 
			case collObject of
			 P.EMPTY    => ()
		       | P.GOODIE n => Snake.eat (snake,n)
		       | P.WALL     => killSnake snake
		       | P.GATE col => 
			     if col = color andalso Snake.length snake = 1
				 then (fin := snake::(!fin);
				       Array2.update(a,r,c,collObject))
			     else
				 if col = color
				     then (halffin := snake::(!halffin);
					   Array2.update(a,r,c,collObject))
				 else killSnake snake
		       | P.SNAKE_HEAD(_,col) => 
				 if col <> color 
				     then killSnake snake
				 else ()
		       |     _      => killSnake snake
		end

	    fun placeBody snake =
		let
		    val color = Snake.color snake
		    val body =  Snake.body snake
		    fun stillDied s = color = Snake.color s
		    val stilldied = List.exists stillDied (!died)
		in
		    if stilldied
			then ()
		    else 
			List.app 
			    (fn(r,c) => Array2.update(a,
						      r,
						      c,
						      P.SNAKE_BODY(color)))
			         body
		end
		
	in
	    List.app placeHead snakes;
	    List.app placeBody snakes;
	    (!died,!halffin,!fin)
	end
    
    fun emptyCopy a =
        let val (rows, cols) = Array2.dimensions a
        in
            Array2.array (rows, cols, P.EMPTY)
        end

        
    fun removeSnakes (a,snakes) = 
	let
	    fun removeSnake s =
		let
		    val positions = (Snake.head s)::(Snake.body s)
		in
		  List.app (fn(r,c) => Array2.update(a,r,c,P.EMPTY)) positions
		end
	in
	    List.app (fn s => removeSnake s) snakes
	end
    (** removes all snakes *)

    fun diff (old,new) = (* TODO: schlangen auf old löschen *)
      let
	  val (rows, cols) = Array2.dimensions old       (* dimensions *)
	  fun help (r, c) xs = 
	      if c = cols
		  then xs
	      else 
		  if r = rows
		      then help (0, c + 1) xs
		  else
		      if Array2.sub (old, rows, cols) = 
			 Array2.sub (new, rows, cols)
			  then help (r + 1, c) xs
		      else help (r+1, c) (((r,c),Array2.sub(new, r, c))::xs)
      in
	  help (0,0) nil
      end

end







