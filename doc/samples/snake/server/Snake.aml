(* Alice Snake 2.0 - Snake abstract data type (impl)
 *
 *  Authors: Benedikt Grundmann / Sebastian Germesin
 *
 *  $Revision$
 *
 *  Last updated: $Date$ by $Author$
 * 
 *
 *)

import signature SNAKE      from "SNAKE-sig"
import structure Protocol   from "../common/Protocol"
import structure Pos        from "../common/Pos"
import structure Color      from "../common/Color"
import structure ImpQueue   from "ImpQueue"


structure Snake :> SNAKE =
struct

    structure P = Protocol
    structure Q = ImpQueue

    datatype snake = SN of {
        direction : P.direction ref,
        belly :     int ref,
        id :        int,
        color :     Color.color,
        body :      Pos.pos Q.queue 
    }

    type t = snake
    
    val startSize = 3

    fun snake (capacity, id, c, pos, d) = 
        let
            val q = Q.queue capacity
        in
            Q.add (q, pos);
            SN { 
                direction   = ref d, 
                belly       = ref (startSize - 1), 
                color       = c,
                id          = id,
                body        = q
            }
        end

    fun start (SN { belly, body, direction,... }, pos, dir) =
        (Q.clear body;
         Q.add (body, pos);
         assert Q.size body = 1;
         belly := (startSize - 1);
         direction := dir)

        
    fun color (SN { color = c, ... }) = c
    
    fun id    (SN { id = id, ... }) = id

    fun belly (SN { belly = ref b, ... })   = b

    fun eat (SN { belly, ... }, food)       = belly := !belly + food

    fun direction (SN { direction, ... })   = !direction

    fun move (SN {  direction = direction as ref old_dir, 
                    belly,
                    body,
                    ...
                 }, new_dir) =
        let 
            (* determine new head position:
               if requested turn is impossible (ie.e new-dir 180° old-dir)
               then do not turn at all. 
             *)
            val head    = Q.head body

            val (newHead, dir) = 
               case (old_dir, new_dir) of
                    ((P.UP, P.DOWN) |    
                     (non P.DOWN, P.UP)) =>
                    (Pos.above head, P.UP)
                |   ((P.DOWN, P.UP) |
                     (non P.UP, P.DOWN)) =>
                    (Pos.below head, P.DOWN)
                |   ((P.LEFT, P.RIGHT) |
                     (non P.RIGHT, P.LEFT)) =>
                    (Pos.left head, P.LEFT)
                |   ((P.RIGHT, P.LEFT) |
                     (non P.LEFT, P.RIGHT)) =>
                    (Pos.right head, P.RIGHT)
            
            val _   = Q.add (body, newHead);
        in
            if !belly > 0 
                then belly := !belly - 1
                else (Q.remove body; ());
            direction := dir
        end

    fun head (SN { body, ... }) = Q.head body

    fun body (SN { body, ... }) = 
        let val l = Q.fold op:: [] body
        in
            List.tl l
        end

    fun appBody f (s as SN { body = b,  ... }) = 
        let
            val n   = Q.size b - 1
            val _   = assert List.length (body s) = n
        in
            Q.fold (fn (x, i) =>
                if i >= n then i
                else (f x; i + 1)) 1 b;
            ()
        end

    fun length (SN { body, ... }) = Q.size body

    fun shrink (SN { body, ... }) = (Q.remove body; ())

end
