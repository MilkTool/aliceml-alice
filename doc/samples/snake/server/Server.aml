(* Alice Snake 2.0 - Server
*
*  Authors: Benedikt Grundmann / Sebastian Germesin
*
*  $Revision$
*
*  Last updated: $Date$ by $Author$
* 
*
*)

import structure Protocol       from "../common/Protocol"
import structure Participant    from "Participant"
import structure Remote         from "x-alice:/lib/distribution/Remote"
import structure MkHashImpMap   from "x-alice:/lib/data/MkHashImpMap"
import structure Arena          from "Arena"
import structure Pos            from "../common/Pos"
import structure Snake          from "Snake"
import structure Config         from "Config"

structure Server =
struct
    
    datatype state = 
        ST_JOIN         
        (* valid calls by a client:
            disconnect,
            play,
            watch,
         PC may also:
            startGame
         *)
    |   ST_GAME 
        (* valid calls by a client:
            disconnect,
            turn,
            changeView,
            giveUp
         *)
    |   ST_LEVEL_FINISHED 
        (* valid calls by a client:
            disconnect,
            giveUp
         *)
    |   ST_TOURNAMENT_FINISHED
        (* valid calls by a client:
            disconnect
         *)


    structure PMap      = MkHashImpMap (Int)

    val participants    = PMap.map () : Participant.participant PMap.map

    val state           = ref ST_JOIN
    val pc_id           = 0
    
    (* print a message on stderr *)
    fun log msg =
        TextIO.output (TextIO.stdErr, "Server: " ^ msg ^ "\n")
    
    fun startServer client =
        let
            structure Part  = Participant
            structure P     = Protocol
           
            (* FIXME: don't use a fixed config *)
            val config          = Config.defaultMulti   
                                
            val levels          = (ref [] : (Arena.arena * 
                                            (Pos.pos * P.direction) list ref) list ref)
            
            fun currentArena () = 
                assert not (null (!levels)) do #1 (hd (!levels))
            

            fun nextStartPos () =
                let
                    val gates   = assert not (null (!levels)) do 
                                    #2 (hd (!levels))
                in
                    case !gates of
                        []      => NONE
                    |   g :: gs => (gates := gs; SOME g)
                end
           

            (* [allParticpants p] return all participants which 
               satisfy the predicate p.  
             *)
            fun allParticipants p = List.map #2 (List.filter p 
                                    (PMap.toList participants))
            
            fun allPlayers ()   = allParticipants 
                    (fn (_, (_, ref (Part.PLAYING _))) => true
                    |   (_, _)                    => false)

            fun allConnected () = allParticipants
                    (fn (_, (_, ref Part.DISCONNECTED)) => false
                    |   (_, _)                           => true)
                
                
            val lock        = Lock.lock ()
            
	    (* RPC call.  
               - Synchronized so that there can always be
                 only one call to a given client.
               - If an exception is raised the RPC has failed
                 and the client is removed from the connection 
                 queue!
               - Does nothing if the client is already disconnected.
             *)
            fun invoke ((client, state_ref), f, a) =
                let
                    (* we use this promise as a lock *)
                    val p       = Promise.promise () 
                    val state   = Ref.exchange (state_ref, Promise.future p)
                in
                    ((case state of
                        Part.DISCONNECTED   => ()
                    |   _                   => 
                        f client a);
                    (* call was successful. state hasn't changed.
                       must fulfill the promise anyway to release
                       the lock. *)
                    Promise.fulfill (p, state))
                handle e => (
                    (* call failed! *)
                    log ("RPC failed: " ^ exnName e);
                    (* change state to disconnected *)
                    Promise.fulfill (p, Part.DISCONNECTED))
                end 
                
            (* Invoke f a on several clients simultaneously.
               Returns immediately -- without waiting for the
               calls to finish.
             *)
            fun invokeSeveral (clients, f, a) = 
                List.app (fn c => spawn (invoke (c, f, a))) clients 
               

            (* [withParticipant def (procName, id, f) returns a function which 
               when invoked applies the participant with id [id]
               on f unless that participant is disconnected.
             *)
            fun withParticipant default (procName, id, f) a =
                let val p as (_, ref st) = 
                            PMap.lookupExistent (participants, id)
                in
                    case st of 
                        Part.DISCONNECTED   => default
                    |   _                   => f (p, a)
                end handle PMap.Unknown id =>
                    raise P.Protocol (procName ^ ": unknown client " ^ 
                            Int.toString id)
            
            fun disconnect id = Lock.sync lock (
                withParticipant () ("disconnect", id, fn (part, ()) => 
                    ()
                ))


            fun play id = Lock.sync lock (
                withParticipant false ("play", id, fn (part, (name, color)) =>
                    case ! (#2 part) of
                        (non Part.CONNECTED)    =>
                        raise P.Protocol "Server: invalid call to play"

                    |   Part.CONNECTED  =>
                        case nextStartPos () of
                            SOME (pos, dir) =>
                            let
                                val playerState = {
                                        points      = ref 0,
                                        gamePoints  = ref 0,
                                        name        = name,
                                        color       = color,
                                        deathCount  = ref 0,
                                        nextDir     = ref dir
                                    }
                                val snake   = Snake.snake (color, pos, dir)
                                val players = allPlayers () 
                                fun getNameColor (_,ref (Part.PLAYING 
                                            ({ name, color, ...}, _))) = 
                                        (name, color)
                                |   getNameColor (_,_) = assert false

                            in
                                (#2 part) := Part.PLAYING (playerState, snake);
                                (* inform the other PLAYERs *)
                                invokeSeveral (players, #playersJoined, 
                                                [(name, color)]);
                                (* inform the NEW player of the other 
                                   already connected players *)
                                spawn (invoke (part, #playersJoined, 
                                        List.map getNameColor players));
                                true
                            end
                        |   NONE => false   
                            (* no unused gates left :-( *)
                ))
                
                
            fun watch id = Lock.sync lock (
                withParticipant () ("watch", id, fn (part, ()) => 
                    case ! (#2 part) of
                        (non Part.CONNECTED)    =>
                        raise P.Protocol "Server: invalid call to watch"

                    |   Part.CONNECTED  =>
                        let
                            val players = allPlayers ()
                            fun getNameColor (_,ref (Part.PLAYING 
                                        ({ name, color, ...}, _))) = 
                                    (name, color)
                            |   getNameColor (_,_) = assert false
                        in
                            (#2 part) := Part.WATCHING (ref ~1);
                            (* inform the NEW player of the other 
                               already connected players *)
                            spawn (invoke (part, #playersJoined, 
                                    List.map getNameColor players));
                            ()
                        end
                ))


            fun turn id = Lock.sync lock (
                withParticipant () ("turn", id, fn (part, dir) => 
                    case ! (#2 part) of
                        Part.PLAYING (state, _) =>
                        (#nextDir state) := dir
                    |   _                       =>
                        raise P.Protocol "Server: invalid call to turn"
                ))


            fun changeView id = Lock.sync lock (
                withParticipant () ("changeView", id, fn (part, hint) => 
                    (*TODO: implement *)
                    ()
                ))


            fun giveUp id = Lock.sync lock (
                withParticipant () ("giveUp", id, fn (part, ()) => 
                    (*TODO: implement *)
                    ()
                ))


            val tick    = Lock.sync lock (fn (oldArena, newArena) =>
                let
                    val players = allPlayers ()
                    fun movePlayer p =
                        let val snake   = Part.snake p
                            val info    = Part.playerInfo p
                        in
                            Snake.move (snake, !(#nextDir info))
                        end
                        
                    (* move all still playing snakes *)
                    val _ = List.app movePlayer players;
                    
                    (* place them on the newArena *)
                    val (deadSnakes, halffinishedSnakes, finishedSnakes) =
                        Arena.placeSnakes (newArena, 
                            List.map Part.snake players);

                    val changes = Arena.diff (oldArena, newArena)
                in
                    (* change state of participants whose snake died to DEAD. *)
                    
                    (* inform the snakes *)
                    
                    (* change state of participants whose snake 
                       finished to FINISHED *)
                     
                    (* inform the snakes *)

                    (* broadcast changes *)
                   
                    (* test wether there are any living snakes left *)

                    (* swap old & new arena *)
                    (newArena, oldArena)
                end)


            fun ticker () = 
                let
                    val arena       = currentArena ()
                    val oldArena    = Arena.emptyCopy arena
                    
                    fun loop (old, new) =
                        let val (old, new) = tick (old, new)
                        in
                            Thread.sleep (#tick config);
                            loop (old, new)
                        end
                in
                    loop (oldArena, arena) 
                end
                            
                
            val startGame = Lock.sync lock (fn () => (
                (* test wether there is any player at all... *)
                (* send startGame signal *)

                (* start tick signal sender *)
                    spawn ticker ();
                    ()
                ))


            val connect = Lock.sync lock (fn client_interface =>
                (* connect is only called by UCs. *)
                let (* determine id *)
                    val id      = PMap.size participants 
                    val uc      = (client_interface, ref Part.CONNECTED)
                in
                    (* insert into participant map *)
                    PMap.insertDisjoint (participants, id, uc);
                    (* return adapted server interface.
                       NOTE: UCs are not allowed to call startGame
                        therefore startGame = NONE
                    *)
                    {   disconnect  = disconnect id,
                        play        = play id,
                        turn        = turn id,
                        changeView  = changeView id,
                        giveUp      = giveUp id,
                        startGame   = NONE,
                        watch       = watch id
                    }
                end)
            
        (* create PC representation *)
            val pc  =   (client, ref Part.CONNECTED)
            val pc_server_interface = 
                {   disconnect  = disconnect pc_id,
                    play        = play pc_id,
                    turn        = turn pc_id,
                    changeView  = changeView pc_id,
                    giveUp      = giveUp pc_id,
                    watch       = watch pc_id,
                    startGame   = SOME startGame
                }
            (* add server to the participant map *)
            val _ = PMap.insertDisjoint (participants, pc_id, pc)

            (* offer the connect procedure to allow other clients
               (UCs) to connect
             *)
            val package = pack (val connect = connect) :> Protocol.SERVER_CONNECTOR
            val ticket  = Remote.offer package
        in
            (* return ticket and server interface *)
            (ticket, pc_server_interface)
        end
        
end
