(* Alice Snake 2.0 - Server
*
*  Authors: Benedikt Grundmann / Sebastian Germesin
*
*  $Revision$
*
*  Last updated: $Date$ by $Author$
* 
*
*)

import structure Protocol       from "../common/Protocol"
import structure Color          from "../common/Color"
import structure Pos            from "../common/Pos"

import structure Participant    from "Participant"
import structure Remote         from "x-alice:/lib/distribution/Remote"
import structure Arena          from "Arena"
import structure Random         from "x-alice:/lib/utility/Random"
import structure Snake          from "Snake"
import structure Config         from "Config"
import structure Remote         from "x-alice:/lib/distribution/Remote"
import structure Highscore      from "../common/Highscore"
import structure HighscoreIO    from "HighscoreIO"
import signature SERVER         from "SERVER-sig"
import structure MkHeap         from "../common/MkHeap"
import structure Inspector      from "x-alice:/lib/tools/Inspector"
import structure Stream         from "x-alice:/lib/data/Stream"

(*
import val dummyClient          from "DummyClient"
*)
import val log                  from "../common/Log"
import structure Ctrl           from "x-alice:/lib/utility/Ctrl"

open Ctrl

fun not_yet_implemented s =
    log ("Server", "TODO: " ^ s ^ " not yet implemented.")


fun pointsForGoodies l = l - 3  (*FIXME: do not use hardcoded initial length *)


structure Event =
struct
    type t = int * Protocol.diff option * Protocol.diff option

    fun compare ((a,_,_), (b,_,_)) = Int.compare (a, b)

    fun equal ((a,_,_), (b,_,_)) = a = b
    
    fun time (t, _, _)  = t
end

structure Events =
struct
    structure Heap  = MkHeap (Event)
    
    type t = int ref * Heap.heap
    
    fun events () = (ref 0, Heap.heap ())

    fun add ((ref time, h), offset, e1, e2 ) = 
        Heap.insert (h, (time + offset, e1, e2))
        
    fun tick (r, h) =
        let 
            fun gather (res1, res2) =
                if not (Heap.isEmpty h) andalso
                        Event.time (Heap.minimum h) = !r then
                    case Heap.minimum h before Heap.remove h of
                        (_, NONE, NONE)     => gather (res1, res2)
                    |   (_, NONE, SOME e)   => gather (res1, e :: res2)
                    |   (_, SOME e, NONE)   => gather (e :: res1, res2)
                    |   (_, SOME e1, SOME e2) => gather (e1 :: res1, e2 ::res2)
                else (res1, res2)
        in
            r := !r + 1;
            gather ([], [])
        end
end


structure Server :> SERVER =
struct
    
    datatype state = 
        ST_JOIN         
        (* valid calls by a client:
            disconnect,
            play,
            watch,
         PC may also:
            startGame
         *)
    |   ST_GAME 
        (* valid calls by a client:
            disconnect,
            turn,
            changeView,
            giveUp
         *)
    |   ST_LEVEL_FINISHED 
        (* valid calls by a client:
            disconnect,
            giveUp
         *)
    |   ST_TOURNAMENT_FINISHED
        (* valid calls by a client:
            disconnect
         *)


    structure Part      = Participant
    structure PMap      = Part.Map

    
    fun tabulateStream (n, f) =
        let
            fun lazy endless i = 
                f i :: endless (i + 1)
            fun lazy ntimes (n, i) =
                if i >= n then []
                else f i :: ntimes (n, i + 1)
        in
            case n of 
                NONE    => endless 0
            |   SOME n  => ntimes (n, 0)
        end    

    
    (** compute possibly infinite stream of levels according
        to config *)
    fun computeLevels ({    dimensions, maxPlayers=players,
                            levels = levelNum,
                            ...
                        } : Protocol.config) =
        tabulateStream (levelNum, 
                fn _ => Arena.random { dimensions, players, walls = 4 } 
                    handle e => assert false
            ) 
            

    fun startServer (client, config : Protocol.config) =
        let
            structure P     = Protocol
   
            val participants    = ref PMap.empty : Part.pmap ref 

            val state           = ref ST_JOIN
            val events          = ref (Events.events ())
            val pc_id           = 0
   
            val levels          = computeLevels config
            val startPos        = ref (List.hd levels ++ #2) 
            
            fun nextStartPos () =
                case !startPos of
                    []      => NONE
                |   g :: gs => (startPos := gs; SOME g)
           

            val lock        = Lock.lock ()
               
            fun allPossiblePlayers part = Part.allParticipants
                    (fn p =>
                        case !(Part.state p) of
                            Part.PLAYING _                      => true
                        |   Part.FINISHED _                     => true
                        |   Part.HALF_FINISHED _                => true
                        |   Part.DEAD ({deathCount,...},_)  
                            where (isNone (#lives config) orelse
                            !deathCount < valOf (#lives config))=> true
                        |   _                                   => false) part
            
            type rpc    = unit -> unit

            fun actualInvoke (p, [])       = ()
              | actualInvoke (p, r::rpcs)   =
                if Part.isConnected p then 
                    (r () handle e => Part.disconnect p;
                     actualInvoke (p, rpcs))
                else
                    (* participant is not connected --> do not process
                      rpcs to this client any more *)
                    ()

            val rpcs    = ref PMap.empty : rpc Stream.stream PMap.map ref
           
            fun startRPCHandler p =
                let
                    val (stream, l) = Stream.stream ()
                in                
                    ispawn (_file_, _line_) actualInvoke (p, l);
                    rpcs := PMap.insertDisjoint (!rpcs, Part.id p, stream)
                end 
                 
	    (* schedule an RPC call.  
             *)
            fun invoke (part, f, a) =
                let
                    (* we use this promise as a lock *)
                    val id          = Part.id part
                    val client      = Part.client_interface part
                    val rpcStream   = PMap.lookupExistent (!rpcs, id)
                in
                    if Part.isConnected part then
                        Stream.send (rpcStream, (fn () => f client a))
                    else
                        Stream.close rpcStream        
                end 
                
            (* Invoke f a on several clients simultaneously.
               Returns immediately -- without waiting for the
               calls to finish.
             *)
            fun invokeSeveral (clients, f, a) = 
                List.app (fn c => invoke (c, f, a)) clients 
               

            (* [withParticipant def (procName, id, f) returns a function which 
               when invoked applies the participant with id [id]
               on f unless that participant is disconnected.
             *)
            fun withParticipant default (procName, id, f) a =
                let val p = PMap.lookupExistent (!participants, id)
                in
                    if Part.isConnected p then
                        f (p, a)
                    else
                        default
                end handle PMap.Unknown id =>
                    raise P.Protocol (procName ^ ": unknown client " ^ 
                            Int.toString id)
            
            fun computePointsList () =
                List.map (fn p =>
                    let val (name, 
                            color)      = Part.nameNColor p
                        val info        = Part.playerInfo p
                        val points      = ! $ #points info
                        val gamePoints  = ! $ #gamePoints info
                        val livesLeft   = Option.map (fn lives => 
                                lives - !(#deathCount info)) (#lives config)
                    in
                        ({ name, color, points, gamePoints }, livesLeft)
                    end) (Part.allWithPoints (! participants) )


            fun sendPoints () =
                invokeSeveral (Part.allConnected $ ! participants , 
                    #updatePoints, computePointsList ())

                
            fun indexOf p v =
                case Vector.findi (fn (_, x) => p x) v of
                    SOME (ndx, _) => SOME ndx
                |   NONE          => NONE

                
            fun previousSnake (p, id) =
                let
                    val parts   = Vector.fromList $ Part.allPlayers p
                    val n       = Vector.length parts
                    val ndx     = 
                            case id of
                                NONE => 0
                            |   SOME id =>
                                getOpt (indexOf (fn p => Part.id p = id) parts, 
                                        1)
                in
                    if Vector.length parts = 0 then NONE
                    else SOME (Part.id $
                        Vector.sub (parts, (ndx - 1) mod Vector.length parts))
                end
            
            fun nextSnake (p, id) =
                let
                    val parts   = Vector.fromList $ Part.allPlayers p
                    val n       = Vector.length parts
                    val ndx     = 
                        case id of
                            NONE => 0 
                        |   SOME id =>
                            getOpt (indexOf (fn p => Part.id p = id) parts, 
                                    n - 1)
                 in
                    if Vector.length parts = 0 then NONE
                    else SOME (Part.id $ 
                        Vector.sub (parts, (ndx + 1) mod Vector.length parts))
                end
             
            fun kill id =
                let val part        = PMap.lookupExistent (!participants, id)
                    val playerInfo  = Part.playerInfo part
                    val (name, 
                        color)      = Part.nameNColor part
                    val points      = ! $ #points playerInfo

                    val spectators  = Part.allSpectators (!participants)
                in
                    (Part.state part) := Part.DEAD (playerInfo, ref NONE); (*FIXME*)
                    #deathCount playerInfo := !(#deathCount playerInfo) 
                                                + 1;
                    (* reset gamepoints to zero, points are not changed
                       as the snake died before entering the gate *)
                    #gamePoints playerInfo := 0;
                    
                    (* each spectator observing this snake must be notified *)
                    List.app (fn p => 
                        if Part.observes (p, id) then
                            Part.changeObserved (p, NONE)
                            (* alternatively:
                            Part.changeObserved (p, 
                                nextSnake (!participants, id))
                            *)
                        else ())  spectators

                    (*TODO: send playersFinished / dead signal? *)
                end


            fun disconnect id = Lock.sync lock (
                withParticipant () ("disconnect", id, fn (part, ()) => (
                    (case !(Part.state part) of
                        Part.PLAYING _ => kill id
                    |   _              => ());
                    Part.state part := Part.DISCONNECTED;
                    sendPoints ()
                )))


            fun play id = Lock.sync lock (
                withParticipant false ("play", id, fn (part, (name, color)) =>
                    case ! (Part.state part) of
                        (non Part.CONNECTED)    =>
                        raise P.Protocol "Server: invalid call to play"

                    |   Part.CONNECTED  =>
                        case nextStartPos () of
                            (* there is place for another player 
                                on this map ;-) *)
                            SOME (pos, dir) =>
                            let
                                val playerState = {
                                        points      = ref 0,
                                        gamePoints  = ref 0,
                                        name        = name,
                                        color       = color,
                                        deathCount  = ref 0,
                                        gatePos     = ref pos,
                                        nextDir     = ref dir
                                    }
                                val maxSize = op* (#dimensions config)
                                val snake   = Snake.snake (maxSize, id, color, pos, dir)
                            in
                                (Part.state part) := Part.PLAYING 
                                                        (playerState, snake);
                                (* inform the other PLAYERs *)
                                invokeSeveral 
                                    (Part.allConnected $ ! participants, 
                                        #playersJoined, [(name, color)]);
                                    true
                            end
                        |   NONE => false   
                            (* no unused gates left :-( *)
                ))
                
                
            fun watch id = Lock.sync lock (
                withParticipant () ("watch", id, fn (part, ()) => 
                    case ! (Part.state part) of
                        (non Part.CONNECTED)    =>
                        raise P.Protocol "Server: invalid call to watch"

                    |   Part.CONNECTED  =>
                        let
                            val players = Part.allPlayers $ ! participants
                        in
                            (Part.state part) := Part.WATCHING (ref NONE);
                            (* inform the NEW player of the other 
                               already connected players *)
                            ispawn (_file_, _line_)
                                invoke (part, #playersJoined, 
                                    List.map Part.nameNColor players)
                        end
                ))


            fun turn id = Lock.sync lock (
                withParticipant () ("turn", id, fn (part, dir) => 
                    case ! (Part.state part) of
                        Part.PLAYING (state, _) =>
                        (#nextDir state) := dir
                    |   _                       =>
                        (*
                        raise P.Protocol "Server: invalid call to turn"
                        *) ()
                ))

           
            fun changeView id = Lock.sync lock (
                withParticipant () ("changeView", id, fn (part, hint) => 
                    let
                        val parts = !participants
                        
                        val getNewId = case hint of
                                            P.PREV => nextSnake  
                                        |   P.NEXT => nextSnake
                    in
                        case ! (Part.state part) of
                                Part.WATCHING (r as ref oldId)  => 
                                    r := getNewId (parts, oldId)
                            |   Part.FINISHED (_, r as ref oldId) => 
                                    r := getNewId (parts, oldId)
                            |   Part.DEAD (_, r as ref oldId)   => 
                                    r := getNewId (parts, oldId)
                            |   _                      => ()
                    end
                ))


            fun giveUp id = Lock.sync lock (
                withParticipant () ("giveUp", id, fn (part, ()) => 
                    case ! (Part.state part) of
                        Part.PLAYING (state, _) =>
                        (kill id; 
                         (* TODO: send player finished signal *)
                         sendPoints ())
                    |   _                       => ()
                ))

           
            exception TournamentFinished

            fun finishTournament () = 
                let
                    val highscore   = HighscoreIO.load ()
                    val highscore   = Highscore.merge (highscore, 
                                        List.map #1 $ computePointsList (), 0) (*FIXME*)
                in
                    invokeSeveral
                        (Part.allConnected $ ! participants, #tournamentFinished, 
                            highscore);
                    rpcs := PMap.empty; 
                    raise TournamentFinished
                end

            
            val countDownStart  = 3

            fun countDown (n, res) =
                let
                    val p = Promise.promise ()
                    
                    fun countDown' n =
                        if n < 0 
                            then Promise.fulfill (p, res)
                            else (Thread.sleep (Time.fromMilliseconds 990);
                                  invokeSeveral
                                    (Part.allConnected $ ! participants, 
                                        #countdown, n);
                                  countDown' (n - 1))
                in
                    ispawn (_file_, _line_) countDown' n;
                    Promise.future p
                end

                
            fun startNextLevel (levels, arena, startPos) =
                let
                    val _   = events := Events.events ()
                    (* get all players who are allowed to play another level *)
                    val p   = allPossiblePlayers $ ! participants

                    (* dimensions of the new level *)
                    val dims    = Array2.dimensions arena
		    val oldArena= Arena.copy arena
		    val diffs   = Arena.toDiffList arena
                    
                    val positions =
                    (* set players state to playing and place snake *)
                    assert List.length p <= List.length startPos do
                    ListPair.map 
                        (fn (part, (pos, dir)) =>
                            let
                                val state       = Part.state part
                                val info        = Part.playerInfo part
                                val (name,color)= Part.nameNColor part
                                val id          = Part.id part
                                val maxSize     = op* (#dimensions config)
                                val snake       = Snake.snake 
                                                (maxSize, id, color, pos, dir)
                                val g           = (pos, P.GATE (color, 
                                                        P.CLOSED))
                            in
                                (#nextDir info) := dir;
                                (#gatePos info) := pos;
                                state := Part.PLAYING (info, snake);
                                Events.add (!events, Snake.belly snake + 2, 
                                                SOME g, SOME g);
                                (part, pos)
                            end
                        ) (p, startPos);
                in
		    log ("Server", "sending levelStarted");
                    invokeSeveral 
                        (Part.allConnected $ ! participants, #levelStarted,
                                { dimensions = dims });
                    
		    log ("Server", (">>>>sending initial Difflist<<<<<<", diffs));
                    invokeSeveral 
                        (Part.allConnected $ ! participants, #update, diffs);
                    
                    log ("Server", ("sending initial positions"));
                    List.app (fn (part, pos) =>
                        invoke (part, #headPosition, pos)) positions;

                    log ("Server", ("sending initial points"));
                    sendPoints ();

                    (* send countdown signals *)
                    countDown (countDownStart,
                        {levels, oldArena, ticks = 0, newArena=arena, goodies = 0})
                end
            
            
            fun finishLevel (levels) =
                (* called when no players are left *)
                let
                in
                    (* send level finished signal *)
                    invokeSeveral 
                        (Part.allConnected $ ! participants, #levelFinished, ());

                    case (levels, allPossiblePlayers $ ! participants) of
                        ( ([],_) | (_, []) )    =>      
                        (* no more levels or no more players 
                           --> tournament ended *)
                        finishTournament ()
                    |   ((arena, startPos) :: ls, _) =>
                        startNextLevel (ls, arena, startPos)
                end
                
            fun findEmptySpot (arena, nTriesLeft) =
                if nTriesLeft <= 0 then NONE
                else
                    let
                        val (rows, cols) = Array2.dimensions arena
                        val row = Random.int (rows - 2) + 1
                        val col = Random.int (cols - 2) + 1
                    in
                        if Array2.sub (arena, row, col) = P.EMPTY 
                            then SOME (row, col) 
                        else
                            findEmptySpot (arena, nTriesLeft - 1)
                    end

            fun mayPlaceGoody (arena, g) = 
                Option.app 
                    (fn (r, c) => Array2.update (arena, r, c, P.GOODY 5)) g
                
                    
            fun mayAppList f [] = ()
              | mayAppList f l  = f l

            
            val tick    = Lock.sync lock (fn {levels, oldArena, newArena, 
                                                ticks, goodies} =>
                let
                    val _       = log ("Server", "tick")
                    val players = Part.allPlayers $ ! participants

                    fun movePlayer (p, moved) =
                        let val snake   = Part.snake p
                            val info    = Part.playerInfo p
                        in
                            log ("Server", "moving player " ^ 
                                    Int.toString (Part.id p));
                            Snake.move (snake, !(#nextDir info));
			    (p, Snake.head snake) :: moved
                        end
                       
                    (* move all still playing snakes *)
                    val newHeadPos = List.foldl movePlayer [] players 
                    
                    (* place them on the newArena *)
                    val { dead = deadSnakes, grown = grownSnakes, 
                          finished = finishedSnakes } = 
                            Arena.placeSnakes (newArena, 
                                         List.map Part.snake players) 

                    val pointsChanged   = ref false

                    (* open gates if necessary *)
                    val gates   =   List.foldl (fn (sn, res) =>
                        let val part    = PMap.lookupExistent 
                                                (!participants, Snake.id sn)
                            val info    = Part.playerInfo part
                            val pos     = !(#gatePos info)
                            val color   = #color info
                            val len     = Snake.length sn + Snake.belly sn
                        in
                            (* adjust gamePoints *)
                            #gamePoints info := pointsForGoodies len;
                            pointsChanged := true;
                            
                            (* open gate? *)
                            if len >= #gateTreshold config then
                                (* Note: gate might already be open, but we
                                   do not bother to keep track and update 
                                   anyway.
                                 *)
                                let val gate    = P.GATE (color, P.OPEN)
                                    val (r, c)  = pos 
                                in
                                    Array2.update (newArena, r, c, gate);
                                    (pos, gate) :: res
                                end
                            else res
                        end) [] grownSnakes;
                    
                    (* handle events *)
                    val (diffNew, diffOld)  = Events.tick (!events)
                    val _       = List.app (fn ((r,c), p) => 
                                    Array2.update (newArena, r, c, p)) diffNew

                    (* all grown snakes have eaten a goody. *)
                    val goodies     = goodies - List.length grownSnakes
                    val _           = assert goodies >= 0

                    (* shall we place another goody? *)
                    val (goodiePos, goodies) = 
                            if goodies < #goodie config andalso 
                                    Random.real 1.0 <= #goodieProb config 
                                then case findEmptySpot (newArena, 3) of
                                        NONE    =>  (NONE, goodies)
                                    |   spot    =>  (spot, goodies + 1)
                                else (NONE, goodies)

                    val _   = mayPlaceGoody (newArena, goodiePos)

                    val _   = log ("Server", ("calculating differences", oldArena, newArena))
                    val changes = Arena.diff (oldArena, newArena)
                    val _   = log ("Server", ("differences", changes))
                    val _   = mayPlaceGoody (oldArena, goodiePos)

                    val _   = List.app (fn ((r,c), g) => 
                                Array2.update (oldArena, r, c, g)) gates

                    val _   = List.app (fn ((r, c), p) =>
                                    Array2.update (oldArena, r, c, p)) diffOld
                   
                    (* estimated amount of time this game is running now *) 
                    val time        = Time.fromMilliseconds (ticks * 
                                        Time.toMilliseconds (#tick config))
                    val timeout     = #timeout config
                    (* amount of time left. *)
                    val timeLeft    = Time.fromSeconds (Int.max (0, 
                            Time.toSeconds (Time.- (timeout, time))))
                in
                    (* broadcast differences *)
                    log ("Server", "broadcasting differences");
                    invokeSeveral 
                        (Part.allConnected $ ! participants, #update, changes);
                    
                    (* change state of participants whose snake died to DEAD. *)
                    log ("Server", "check for dead snakes");
                    
                    List.map (fn sn =>
                        let val part        = PMap.lookupExistent 
                                                (!participants, Snake.id sn)        
                        in
                            kill (Snake.id sn);
                            pointsChanged := true;

                            (* build list of names and colors of dead snakes *)
                            Part.nameNColor part
                        end) deadSnakes ++
        
                    (* inform the snakes, if any corpses are around *)
                    mayAppList (fn deads => invokeSeveral
                        (Part.allConnected $ ! participants, #playersDied, deads));
                
		    (* inform snake about their new head positions *)
		    List.app (fn (part, pos) =>
                                let 
                                    val id  = Part.id part
                                    val spects  = Part.allParticipants 
                                        (fn p => Part.observes (p, id)) 
                                                (!participants)
                                in
                                    (* inform the player himself and all 
                                       spectators observing him *)
                                    invokeSeveral (part :: spects, 
                                        #headPosition, pos)
                                end) newHeadPos;
 
                    (* change state of participants whose snakes are 
                       finished to HALF_FINISHED, as soon as their
                       snake has entered the gate completely we change
                       it to FINISHED *)
                    log ("Server", "check for finished snakes");
                    List.map (fn sn =>
                        let val id          = Snake.id sn
                            val part        = PMap.lookupExistent 
                                                (!participants, id)
                            val playerInfo  = Part.playerInfo part
                            val length      = Snake.length sn - 1
                            val body        = Snake.body sn
                            val (name, 
                                 color)     = Part.nameNColor part
                            
                            fun addPlaceBodyEvent t =
                                List.app (fn p =>
                                    Events.add (!events, t, 
                                        SOME (p, P.SNAKE_BODY color), 
                                        NONE))
                                    (List.take (body, length - t + 1))
                        in
                            Part.state part := Part.HALF_FINISHED 
                                        (playerInfo, ref length);
                                        
                            (* take the points made this game home *)
                            #points playerInfo := !(#points playerInfo) + 
                                    !(#gamePoints playerInfo);
                            pointsChanged := true;
 
                            (* reset the gamePoints *)
                            #gamePoints playerInfo := 0;
                            
                            (* schedule animation of snake going into the gate *)
                            for (1, length, addPlaceBodyEvent);
                            
                            (name, color) 
                        end) finishedSnakes ++
                        
                    (* inform the snakes *)
                    mayAppList (fn namesNColors =>
                        invokeSeveral
                            (Part.allConnected $ ! participants, 
                                #playersFinished, namesNColors));
                    
                    (* send updated points list if necessary *)
                    if !pointsChanged then
                        sendPoints ()
                    else ();

                    (* check for completely finished participants 
                     *)
                    log ("Server", "check for completely finished snakes");
                    List.app (fn part =>
                        case !(Part.state part) of
                            Part.HALF_FINISHED (info, ref 0) =>
                                Part.state part := Part.FINISHED (info, ref NONE) 
                                    (*FIXME: find snake to watch *)
                        |   Part.HALF_FINISHED (info, n) => n := !n - 1
                        |   _           => assert false
                    ) (Part.allHalfFinished $ ! participants);
                    
                        
                    (* send tick signal *)
                    log ("Server", "send tick signal");
                    invokeSeveral 
                        (Part.allConnected $ ! participants, #tick, 
                            timeLeft);
  
                    (* test wether there are any living snakes left *)
                    case Part.allNonFinished (!participants) of
                        []  => 
                        (* no more players left --> finish *)
                        finishLevel levels
                    |   _   => 
                        (* timeout expired ? *)
                        if Time.fromSeconds 0 = timeLeft then
                            (* timeout expired --> finish *)
                            finishLevel levels
                        else
                            (* players and time left continue *)
                            {levels, oldArena = newArena, 
                                newArena = oldArena,
                                ticks = ticks + 1, goodies }
                end)


            fun ticker () = 
                let
		    val (arena, pos)  = assert not (null levels) do
			                  List.hd levels

                    fun loop state =
                        let 
                            val state = tick $ Future.await state
                        in
                            Thread.sleep (#tick config);
                            loop state
                        end
        
                    val state = startNextLevel 
			    (List.tl levels, arena, pos)
		in
                    loop state 
                end handle  TournamentFinished  => ()

                
            val startGame = Lock.sync lock (fn () => (
                (* test wether there is any player at all... *)
                if !state = ST_JOIN then state := ST_GAME
                else raise P.Protocol "game already started";
                
                (* send startTournament signal *)
                invokeSeveral
                    (Part.allConnected $ ! participants, #tournamentStarted, ());
                
                (* start tick signal sender *)
                ispawn (_file_, _line_) ticker ()
                ))


            val connect = Lock.sync lock (fn client_interface =>
                (* connect is only called by UCs. *)
                let (* are we still in join mode ? *)
                    val _       =   if !state = ST_JOIN then ()
                                    else raise P.Protocol "game already running"

                    (* determine id *)
                    val id      = PMap.size $ ! participants 
                    val uc      = Part.participant (id, client_interface)
                in
                    (* insert into participant map *)
                    participants := PMap.insertDisjoint (!participants, id, uc);
                    (* start RPC handler and register it *)
                    startRPCHandler uc;

                    (* inform the NEW player of the other 
                       already connected players *)
                    ispawn (_file_, _line_) 
                        invoke (uc, #playersJoined, 
                                List.map Part.nameNColor (Part.allPlayers $ ! participants));
                    (* return adapted server interface.
                       NOTE: UCs are not allowed to call startGame
                        therefore startGame = NONE
                    *)
                    (config, {
                        disconnect  = Remote.proxy (disconnect id),
                        play        = Remote.proxy (play id),
                        turn        = Remote.proxy (turn id),
                        changeView  = Remote.proxy (changeView id),
                        giveUp      = Remote.proxy (giveUp id),
                        startGame   = NONE,
                        watch       = Remote.proxy (watch id)
                    })
              end)
            
        (* create PC representation *)
            val pc  =   Part.participant (pc_id, client)
            val pc_server_interface = 
                {   disconnect  = Remote.proxy (disconnect pc_id),
                    play        = Remote.proxy (play pc_id),
                    turn        = Remote.proxy (turn pc_id),
                    changeView  = Remote.proxy (changeView pc_id),
                    giveUp      = Remote.proxy (giveUp pc_id),
                    watch       = Remote.proxy (watch pc_id),
                    startGame   = SOME (Remote.proxy startGame)
                }
            (* add server to the participant map *)
            val _ = participants := 
                PMap.insertDisjoint (!participants, pc_id, pc)

            (* offer the connect procedure to allow other clients
               (UCs) to connect
             *)
            val package = pack (val connect = Remote.proxy connect) :> Protocol.SERVER_CONNECTOR
            val ticket  = Remote.offer package
        in
	    startRPCHandler pc;

            (* return ticket and server interface *)
            (ticket, pc_server_interface)
        end
        
end

(*

fun test () =
    let
        val (ticket, server) = Server.startServer 
                    (dummyClient, 
                { Config.defaultSingle where tick = Time.fromSeconds 3 } )
    in
        #play server ("bene", Color.fromString "yellow");    
        valOf (#startGame server) ();
        (ticket, server)
    end
    
*)
