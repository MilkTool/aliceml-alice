(* Alice Snake 2.0 - Server
*
*  Authors: Benedikt Grundmann / Sebastian Germesin
*
*  $Revision$
*
*  Last updated: $Date$ by $Author$
* 
*
*)

import structure Protocol       from "../common/Protocol"
import structure Color          from "../common/Color"
import structure Pos            from "../common/Pos"

import structure Participant    from "Participant"
import structure Remote         from "x-alice:/lib/distribution/Remote"
import structure MkHashImpMap   from "x-alice:/lib/data/MkHashImpMap"
import structure Arena          from "Arena"
import structure Snake          from "Snake"
import structure Config         from "Config"
import structure Remote         from "x-alice:/lib/distribution/Remote"
import structure Highscore      from "../common/Highscore"
import signature SERVER         from "SERVER-sig"
import val dummyClient          from "DummyClient"
import val log                  from "../common/Log"
import structure Ctrl           from "x-alice:/lib/utility/Ctrl"

open Ctrl

fun not_yet_implemented s =
    log ("Server", "TODO: " ^ s ^ " not yet implemented.")


structure Server :> SERVER =
struct
    
    datatype state = 
        ST_JOIN         
        (* valid calls by a client:
            disconnect,
            play,
            watch,
         PC may also:
            startGame
         *)
    |   ST_GAME 
        (* valid calls by a client:
            disconnect,
            turn,
            changeView,
            giveUp
         *)
    |   ST_LEVEL_FINISHED 
        (* valid calls by a client:
            disconnect,
            giveUp
         *)
    |   ST_TOURNAMENT_FINISHED
        (* valid calls by a client:
            disconnect
         *)


    structure PMap      = MkHashImpMap (Int)

    
    fun tabulateStream (n, f) =
        let
            fun lazy endless i = 
                f i :: endless (i + 1)
            fun lazy ntimes (n, i) =
                if i >= n then []
                else f i :: ntimes (n, i + 1)
        in
            case n of 
                NONE    => endless 0
            |   SOME n  => ntimes (n, 0)
        end    

    
    (** compute possibly infinite stream of levels according
        to config *)
    fun computeLevels ({    dimensions, maxPlayers=players,
                            levels = levelNum,
                            ...
                        } : Protocol.config) =
        tabulateStream (levelNum, 
                fn _ => Arena.random { dimensions, players, walls = 4 } handle e => assert false
            ) 
            

    fun startServer (client, config : Protocol.config) =
        let
            structure Part  = Participant
            structure P     = Protocol
   
            val participants    = PMap.map () : Participant.participant PMap.map

            val state           = ref ST_JOIN
            val pc_id           = 0
   
            val levels          = computeLevels config
            val startPos        = ref (List.hd levels ++ #2) 
            
            fun nextStartPos () =
                case !startPos of
                    []      => NONE
                |   g :: gs => (startPos := gs; SOME g)
           

            (* [allParticpants p] return all participants which 
               satisfy the predicate p.  
             *)
            fun allParticipants p = List.map #2 (List.filter p 
                                    (PMap.toList participants))
            
            (* [allPlayers ()] returns all snakes which are either
               still playing or have entered a gate but are not yet
               completely inside it.
             *)
            fun allPlayers ()   = allParticipants 
                    (fn (_, p) =>
                        case !(Part.state p) of
                            Part.PLAYING _              => true
                        |   Part.FINISHED (_, _, false) => true
                        |   _                           => false)


            fun allConnected () = allParticipants
                    (fn (_, p) =>
                        case !(Part.state p) of
                            Part.DISCONNECTED   => false
                        |   _                   => true)


            fun allPossiblePlayers () = allParticipants
                    (fn (_, p) =>
                        case !(Part.state p) of
                            Part.PLAYING _      => true
                        |   Part.FINISHED _     => true
                        |   Part.DEAD _         => true
                        |   _                   => false)


            val lock        = Lock.lock ()
            
	    (* RPC call.  
               - Synchronized so that there can always be
                 only one call to a given client.
               - If an exception is raised the RPC has failed
                 and the client is removed from the connection 
                 queue!
               - Does nothing if the client is already disconnected.
             *)
            fun invoke (part, f, a) =
                let
                    (* we use this promise as a lock *)
                    val p       = Promise.promise () 
                    val id      = Part.id part
                    val _       = 
                        log ("Server", ("invoke: aquiring lock on", id))
                    val state   = Ref.exchange (Part.state part, 
                                                    Promise.future p)
                    val client  = Part.client_interface part
                in
                    ((case state of
                        Part.DISCONNECTED   => 
                            log ("Server", ("invoke: disconnected", id))
                    |   _                   => 
                        (log ("Server", ("invoke: calling", id));
                         f client a;
                         log ("Server", ("invoke: called", id))));
                    (* call was successful. state hasn't changed.
                       must fulfill the promise anyway to release
                       the lock. *)
                    log ("Server", ("releasing lock on", id));
                    Promise.fulfill (p, state));
                    log ("Server", ("lock released on", id))
                handle e => (
                    (* call failed! *)
                    log ("Server", "RPC failed: " ^ exnName e);
                    (* change state to disconnected *)
                    Promise.fulfill (p, Part.DISCONNECTED))
                end 
                
            (* Invoke f a on several clients simultaneously.
               Returns immediately -- without waiting for the
               calls to finish.
             *)
            fun invokeSeveral loc (clients, f, a) = 
                List.app (fn c => ispawn loc invoke (c, f, a)) 
                    clients 
               

            (* [withParticipant def (procName, id, f) returns a function which 
               when invoked applies the participant with id [id]
               on f unless that participant is disconnected.
             *)
            fun withParticipant default (procName, id, f) a =
                let val p = PMap.lookupExistent (participants, id)
                in
                    case !(Part.state p) of 
                        Part.DISCONNECTED   => default
                    |   _                   => f (p, a)
                end handle PMap.Unknown id =>
                    raise P.Protocol (procName ^ ": unknown client " ^ 
                            Int.toString id)
            

            fun disconnect id = Lock.sync lock (
                withParticipant () ("disconnect", id, fn (part, ()) =>
                    () 
                ))


            fun play id = Lock.sync lock (
                withParticipant false ("play", id, fn (part, (name, color)) =>
                    case ! (Part.state part) of
                        (non Part.CONNECTED)    =>
                        raise P.Protocol "Server: invalid call to play"

                    |   Part.CONNECTED  =>
                        case nextStartPos () of
                            SOME (pos, dir) =>
                            let
                                val playerState = {
                                        points      = ref 0,
                                        gamePoints  = ref 0,
                                        name        = name,
                                        color       = color,
                                        deathCount  = ref 0,
                                        nextDir     = ref dir
                                    }
                                val snake   = Snake.snake (id, color, pos, dir)
                                val players = allPlayers () 
                            in
                                (Part.state part) := Part.PLAYING 
                                                        (playerState, snake);
                                (* inform the other PLAYERs *)
                                invokeSeveral (_file_, _line_) 
                                    (players, #playersJoined, [(name, color)]);
                                (* inform the NEW player of the other 
                                   already connected players *)
                                ispawn (_file_, _line_) 
                                    invoke (part, #playersJoined, 
                                        List.map Part.nameNColor players);
                                true
                            end
                        |   NONE => false   
                            (* no unused gates left :-( *)
                ))
                
                
            fun watch id = Lock.sync lock (
                withParticipant () ("watch", id, fn (part, ()) => 
                    case ! (Part.state part) of
                        (non Part.CONNECTED)    =>
                        raise P.Protocol "Server: invalid call to watch"

                    |   Part.CONNECTED  =>
                        let
                            val players = allPlayers ()
                        in
                            (Part.state part) := Part.WATCHING (ref ~1);
                            (* inform the NEW player of the other 
                               already connected players *)
                            ispawn (_file_, _line_)
                                invoke (part, #playersJoined, 
                                    List.map Part.nameNColor players)
                        end
                ))


            fun turn id = Lock.sync lock (
                withParticipant () ("turn", id, fn (part, dir) => 
                    case ! (Part.state part) of
                        Part.PLAYING (state, _) =>
                        (#nextDir state) := dir
                    |   _                       =>
                        raise P.Protocol "Server: invalid call to turn"
                ))


            fun changeView id = Lock.sync lock (
                withParticipant () ("changeView", id, fn (part, hint) => 
                    not_yet_implemented ("changeView")
                ))


            fun giveUp id = Lock.sync lock (
                withParticipant () ("giveUp", id, fn (part, ()) => 
                    not_yet_implemented ("giveUp")
                ))

           
            exception TournamentFinished

            fun finishTournament () = (
                (* compute highscore *)
                not_yet_implemented ("highscore");
                (*TODO: compute it ;-) *)
                invokeSeveral (_file_, _line_)
                    (allConnected (), #tournamentFinished, Highscore.empty);
                raise TournamentFinished
            )

           
            fun startNextLevel (levels, oldArena, newArena, startPos) =
                let
                    (* get all players who can play another level *)
                    val p   = allPossiblePlayers ()

                    (* dimensions of the new level *)
                    val dims    = Array2.dimensions newArena
                in
                    (* set players state to playing and place snake *)
                    assert List.length p <= List.length startPos do
                    ListPair.app 
                        (fn (part, (pos, dir)) =>
                            let
                                val state       = Part.state part
                                val info        = Part.playerInfo part
                                val (name,color)= Part.nameNColor part
                                val id          = Part.id part
                                val snake       = Snake.snake 
                                                    (id, color, pos, dir)
                            in
                                (#nextDir info) := dir;
                                state := Part.PLAYING (info, snake)
                            end
                        ) (p, startPos);
                    invokeSeveral (_file_, _line_) 
                        (allConnected (), #levelStarted,{ dimensions = dims });
                    invokeSeveral (_file_, _line_) (allConnected (), #update, 
                        Arena.toDiffList newArena);
                    (levels, oldArena, newArena)
                end
            
            
            fun finishLevel (levels, oldArena, newArena) =
                (* called when no players are left *)
                let
                    val _   = assert null (allPlayers ())
                in
                    (* send level finished signal *)
                    invokeSeveral (_file_, _line_) 
                        (allConnected (), #levelFinished, ());
                    
                    case levels of
                        []  =>      (* no more levels -- tournament ended *)
                        finishTournament ()
                    |   (arena, startPos) :: ls =>
                        startNextLevel (ls, newArena, arena, startPos)
                end
                
                
            val tick    = Lock.sync lock (fn (levels, oldArena, newArena) =>
                let
                    val _       = log ("Server", "tick")
                    val players = allPlayers ()

                    fun movePlayer p =
                        let val snake   = Part.snake p
                            val info    = Part.playerInfo p
                        in
                            log ("Server", "moving player " ^ Int.toString (Part.id p));
                            Snake.move (snake, !(#nextDir info))
                        end
                        
                    (* move all still playing snakes *)
                    val _ = List.app movePlayer players handle e => assert false
                    
                    (* place them on the newArena *)
                    val (deadSnakes, halfFinishedSnakes, finishedSnakes) =
                        Arena.placeSnakes (newArena, 
                            List.map Part.snake players) handle e => assert false

                    val _   = log ("Server", ("calculating differences", oldArena, newArena))
                    val changes = Arena.diff (oldArena, newArena)
                    val _   = log ("Server", ("differences", changes))
                in
                    (* broadcast differences *)
                    log ("Server", "broadcasting differences");
                    invokeSeveral (_file_, _line_) 
                        (allConnected (), #update, changes);
                    
                    (* change state of participants whose snake died to DEAD. *)
                    log ("Server", "check for dead snakes");
                    List.app (fn sn =>
                        let val part        = PMap.lookupExistent 
                                                (participants, Snake.id sn)        
                            val playerInfo  = Part.playerInfo part
                        in
                            (Part.state part) := Part.DEAD (playerInfo, ref ~1) (*FIXME*)
                        end) deadSnakes;
                            
                    (* inform the snakes *)
                    (* TODO *)
                    
                    (* change state of participants whose snake 
                       finished to FINISHED *)
                    log ("Server", "check for finished snakes");
                    List.app (fn sn =>
                        let val id          = Snake.id sn
                            val part        = PMap.lookupExistent 
                                                (participants, id)
                            val playerInfo  = Part.playerInfo part
                        in
                            (* as long as this snake is not YET
                               completely in the gate, the player must
                               watch himself.
                             *)
                            (Part.state part) := Part.FINISHED (playerInfo, 
                                                    ref id, false)
                        end) halfFinishedSnakes;
                        
                    (* inform the snakes *)
                    (* TODO *)
                    
                    (* change state of participants whose snake 
                       are completely finished from FINISHED 
                       (_, ownId, false) to (_, otherId, true) *)
                    log ("Server", "check for completely finished snakes");
                    List.app (fn sn =>
                        let val id          = Snake.id sn
                            val part        = PMap.lookupExistent 
                                                (participants, id)
                        in
                            case !(Part.state part) of
                                Part.FINISHED (info, ref ownId, false) 
                                        where (id = ownId) =>
                                (Part.state part) := Part.FINISHED (info, 
                                                        ref ~1, true) 
                                (* FIXME *)
                            |   _           =>
                                assert false
                        end) halfFinishedSnakes;
                        
                    (* send tick signal *)
                    log ("Server", "send tick signal");
                    invokeSeveral 
                        (_file_, _line_) (allConnected (), #tick, NONE);
  
                    (* test wether there are any living snakes left *)
                    case allPlayers () of
                        []  => (
                        log ("Server", "no more players left");
                        finishLevel (levels, newArena, oldArena))
                    |   _   => ( 
                        (* swap old & new arena *)
                        log ("Server", "players left --> play next round");
                        (levels, newArena, oldArena))
                end)


            fun ticker () = 
                let
                    val arena       = assert not (List.null levels) do 
                                        List.hd levels ++ #1
                    val oldArena    = Arena.emptyCopy arena

                    fun loop (levels, old, new) =
                        let 
                            val _   = invokeSeveral (_file_, _line_)
                                (allConnected (), #update, 
                                            Arena.toDiffList new)
                            val (levels, old, new) = tick (levels, old, new)
                        in
                            Thread.sleep (#tick config);
                            loop (levels, old, new)
                        end
                in
                    loop (List.tl levels, oldArena, arena) 
                end handle  TournamentFinished  => ()

                
            val startGame = Lock.sync lock (fn () => (
                (* test wether there is any player at all... *)
                if !state = ST_JOIN then state := ST_GAME
                else raise P.Protocol "game already started";
                
                (* send startTournament signal *)
                invokeSeveral (_file_, _line_)
                    (allConnected (), #tournamentStarted, ());
                
                (* start tick signal sender *)
                ispawn (_file_, _line_) ticker ()
                ))


            val connect = Lock.sync lock (fn client_interface =>
                (* connect is only called by UCs. *)
                let (* are we still in join mode ? *)
                    val _       =   if !state = ST_JOIN then ()
                                    else raise P.Protocol "game already running"

                    (* determine id *)
                    val id      = PMap.size participants 
                    val uc      = Part.participant (id, client_interface)
                in
                    (* insert into participant map *)
                    PMap.insertDisjoint (participants, id, uc);
                    (* return adapted server interface.
                       NOTE: UCs are not allowed to call startGame
                        therefore startGame = NONE
                    *)
                    (config, {
                        disconnect  = Remote.proxy (disconnect id),
                        play        = Remote.proxy (play id),
                        turn        = Remote.proxy (turn id),
                        changeView  = Remote.proxy (changeView id),
                        giveUp      = Remote.proxy (giveUp id),
                        startGame   = NONE,
                        watch       = Remote.proxy (watch id)
                    })
                end)
            
        (* create PC representation *)
            val pc  =   Part.participant (pc_id, client)
            val pc_server_interface = 
                {   disconnect  = Remote.proxy (disconnect pc_id),
                    play        = Remote.proxy (play pc_id),
                    turn        = Remote.proxy (turn pc_id),
                    changeView  = Remote.proxy (changeView pc_id),
                    giveUp      = Remote.proxy (giveUp pc_id),
                    watch       = Remote.proxy (watch pc_id),
                    startGame   = SOME (Remote.proxy startGame)
                }
            (* add server to the participant map *)
            val _ = PMap.insertDisjoint (participants, pc_id, pc)

            (* offer the connect procedure to allow other clients
               (UCs) to connect
             *)
            val package = pack (val connect = Remote.proxy connect) :> Protocol.SERVER_CONNECTOR
            val ticket  = Remote.offer package
        in
            (* return ticket and server interface *)
            (ticket, pc_server_interface)
        end
        
end


fun test () =
    let
        val (ticket, server) = Server.startServer 
                    (dummyClient, 
                { Config.defaultSingle where tick = Time.fromSeconds 3 } )
    in
        #play server ("bene", Color.fromString "yellow");    
        valOf (#startGame server) ();
        (ticket, server)
    end
    
