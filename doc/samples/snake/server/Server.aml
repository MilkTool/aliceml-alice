import structure DynArray       from "DynArray"
import structure Ctrl           from "x-alice:/lib/utility/Ctrl"
import structure Random         from "x-alice:/lib/utility/Random"
import structure Remote         from "x-alice:/lib/distribution/Remote"
import structure ReadWriteLock  from "ReadWriteLock"
import structure Color          from "../common/Color"
import structure Protocol       from "../common/Protocol"
import structure Snake          from "Snake"
import structure Channel        from "Channel"
import structure Util           from "Util"
import structure PState         from "PState"
import structure Arena          from "Arena"
import structure Inspector      from "x-alice:/lib/tools/Inspector"
import structure HighscoreIO    from "HighscoreIO"
import structure Highscore      from "../common/Highscore"
import structure Print          from "x-alice:/lib/system/Print"

val printVal = Print.printVal

(* overview:

         Locking:  There is basically one datastructure the participant 
           map, which must be protected!  This map is only modified by:
           connect, play and tick (and startServer but this procedure is
           executed before any other and thus does not need to locked)
 *)

structure Server =
struct
    structure P         = Protocol
    structure RWLock    = ReadWriteLock
    
    open Ctrl

    (* a not yet done Remote Procedure Calls *)
    type rpc = unit -> unit

    (* collection of all events which might happen to a participant
       in between two ticks. 
     *)
    type event = {
        newDir  :       Protocol.direction option ref,
        giveUp :        bool ref,
        changedView :   Protocol.view_hint option ref,

        disconnected :  bool ref
        (* happens only once, after that we remove this participant *)
    }
 
    (** We store the following informations about every participant:
            - what he wants to do next (event)
            - his current state
            - delayed RPCs (this server calling functions on the client)
            - the interface
      *)
    datatype pdesc = PDESC of {
        event       : event,
        state       : PState.pstate,
        interface   : P.client_interface,
        rpcs        : rpc Channel.channel
    }


    fun initialEvent () = {
            newDir          = ref NONE,
            giveUp          = ref false,
            disconnected    = ref false,
            changedView     = ref NONE
        }

    (**
       messages to be used with the Protocol.exception:
      *)
    val unknownClientMsg    = "Unknown / Disconnected client."
    val gameStartedMsg      = "Game already started.  Maybe next time."

    
    exception ServerDisconnected 
    (* raised when the player controlling the server disconnected.
       the tournament is then finished.
     *)
    
    val pcId = 0
 
    (** compute possibly infinite stream of levels according
        to config *)
    fun computeLevels ({    dimensions, maxPlayers=players,
                            levels = levelNum,
                            ...
                        } : Protocol.config) =
        Util.tabulateStream (levelNum, 
                fn _ => Arena.random { dimensions, players, walls = 4 } ) 


    (**
       [startServer ()] starts the server.
     *)

    fun startServer (pClient, config : Protocol.config) =
        let
            val partDescs       = DynArray.array (0, 
                    lazy (raise P.Protocol unknownClientMsg) ) : pdesc DynArray.array
           
            fun mapFiltered f =
                DynArray.foldl (fn (desc, res) => 
                                case f desc of
                                    NONE    => res
                                |   SOME d  => d :: res) [] partDescs
            
            fun mapPred p f = 
                mapFiltered (fn (pdesc as PDESC d) => 
                        if p $ #state d then 
                            SOME (f pdesc) 
                        else NONE) 

            
            fun mapPlayers f = mapPred PState.isPlayer f
            
            fun mapPlayed f  = mapPred PState.played f

            val lock            = RWLock.lock ()

            (* true when game has started and no more connections are possible
             *)
            val gameStarted = ref false

             
            (* number of connected players. 
             *)
            val playerNum       = ref 0

            val goodies         = ref 0

            (**
              [actualInvoke (event, chan)]
              processes outstanding RPCs on channel [chan].
             *)
            fun actualInvoke (event : event, chan) =
                let
                    val rpc     = Channel.receive chan

                    val _       = rpc () handle e =>
                        ((* client has raised an exception,
                            this shouldn't happen therefore
                            remove it! *)
                         (* by notifying tick that this client
                            is disconnected. *)
                        #disconnected event := true;
                        (* and destroying this channel. *)
                        Channel.destroy chan)
                 in
                    (* only continue if client has NOT raised
                       an exception
                     *)
                    if not ( ! $ #disconnected event) then
                        (* process next rpc *)
                        actualInvoke (event, chan)
                    else ()
                end 
                    
                 
	    (* schedule an RPC call.  
             *)
            fun invoke (PDESC desc, f, a) = 
                (* we do not need to worry about closed channels here,
                   Channel.send on a closed channel does nothing *)
                Channel.send (#rpcs desc, (fn () => f (#interface desc) a))

                
            (* Invoke f a on several clients simultaneously.
             *)
            fun invokeSeveral (clients, f, a) = 
                List.app (fn c => invoke (c, f, a)) clients 
               
            
            fun synchronize partDescs =
                let
                    val syncStepTime    = 10

                    fun isSynced partDescs =
                        DynArray.all (fn PDESC pd => 
                            !(#disconnected $ #event pd) orelse
                                Channel.length (#rpcs pd) = 0) partDescs

                    fun killSlowClients partDescs =
                        DynArray.appi (fn (id, PDESC pd) =>
                            let val chan    = #rpcs pd 
                                val ev      = #event pd
                            in
                                if Channel.length chan > 0 then
                                    (#disconnected ev := true;
                                     Channel.destroy chan)
                                else ()
                            end)  partDescs

                    fun loop (pds, syncs) =
                        if isSynced pds then syncs
                        else if syncs * syncStepTime > Time.toMilliseconds
                                (#tick config) * 4 then
                            syncs before killSlowClients pds
                        else (Thread.sleep $ Time.fromMilliseconds 10;
                              loop (pds, syncs + 1) )
                    
                    val steps   = loop (partDescs, 0)
                in
                    if steps > 0 then
                        TextIO.output (TextIO.stdErr, 
                            Int.toString (syncStepTime * steps) ^ "\n")
                    else ()
                end
                    
            fun invokeOnAll (f, a) =
                DynArray.app (fn c => invoke (c, f, a)) partDescs
            
            fun invokeOnAllBut (id, f, a) =
                DynArray.app (fn (c as PDESC pdesc) => 
                    if PState.id (#state pdesc) = id then ()
                    else invoke (c, f, a)) partDescs

            
            fun computePoints () = 
                mapPlayed (fn (PDESC pd) => 
                        PState.points (#state pd, #lives config)) 

            (* for each participant send tick signal *)
            fun sendTick (pointsChanged, diffs, time) =
                let
                    val points = 
                        if pointsChanged 
                            then SOME $ computePoints ()
                            else NONE
                in
                    DynArray.app (fn pd =>
                        let
                            fun getPos (PDESC pd) =
                                case PState.position $ #state pd of
                                    FST p           => SOME p
                                |   SND NONE        => NONE
                                |   SND (SOME id)   => getPos (
                                        DynArray.sub (partDescs, id))
                        in
                           invoke (pd, #tick, (points, diffs, getPos pd, time)) 
                        end) partDescs
                end

            (**
              tick handler:
                - process all events registered in event map
                - move snakes
                - ...
             *)

            val tick        = RWLock.syncWrite lock (fn (arena, ticks) =>
                let
                    val disconns        = ref [] : (string * Color.color) list ref
                    val quitters        = ref [] : (string * Color.color) list ref
                    val dead            = ref [] 
                    val snakes          = ref []
                    val snakesInGate    = ref []

                    val pointsChanged   = ref false 
                    (* wether we have to include the points in 
                       the call to update? *)
                   
                    fun cancelGame (PDESC pdesc) =
                        (assert PState.played (#state pdesc);
                         pointsChanged := true;
                         PState.giveUp (#state pdesc))
                        
                    fun actualDisconnect (disconns, p as PDESC pdesc) =
                        let
                            val nc  = PState.nameNColor (#state pdesc)
                        in
                            disconns := nc :: !disconns;
                            if PState.played (#state pdesc) then
                                cancelGame p
                            else ();
                            
                            if PState.id (#state pdesc) = pcId then 
                                (* priviliged client has disconnected! 
                                   abort the game.
                                 *)
                                (print "server disconnected!\n";
                                raise ServerDisconnected)
                            else ()
                        end

                    fun giveUp (p as PDESC pdesc) =
                        let
                            val nc  = PState.nameNColor $ #state pdesc
                        in
                            quitters := nc :: !quitters;
                            cancelGame p;
                            ()
                        end

                    fun nextId (lastId, d) = 
                        let
                            fun playing (PDESC p) =
                                PState.isPlaying $ #state p
                            val max = DynArray.length partDescs
                        in
                            case lastId of
                                NONE    => 
                                (case DynArray.find playing partDescs of
                                    NONE            => NONE
                                |   SOME (PDESC pd) => 
                                    SOME (PState.id $ #state pd) )
                            |   SOME id => nextId' (id, (id + d) mod max, d)
                        end

                    and nextId' (last, c, d) =
                        if c = last 
                            then NONE
                            else let 
                                    val PDESC p = DynArray.sub (partDescs, c)
                                    val state   = #state p
                                    val max     = DynArray.length partDescs
                                 in
                                    if PState.isPlaying state 
                                        then SOME $ PState.id state
                                        else nextId' (last, (c + d) mod max, d)
                                 end
                        
                                
                    (* process events:
                        turn, changeView, giveUp
                     *)
                    fun processUserEvent (part, ev: event, 
                                    quitters, dead, snakes, snakesInGate) =
                        let
                            val PDESC pd    = part
                            val state       = #state pd
                        in
                            if ! $ #giveUp ev then 
                                giveUp part 
                            else if PState.hasEnteredGate state then
                                (* user can not do anything but giving up 
                                   right now... *)
                                snakesInGate := PState.snake state 
                                    :: ! snakesInGate
                            else if PState.isPlaying state then
                                let
                                    val snake   = PState.snake state
                                in case ! $ #newDir ev of
                                    NONE        => 
                                    snakes := (snake, 
                                        Snake.direction snake) :: !snakes
                                |   SOME d      => 
                                    (snakes := (snake, d) :: !snakes;
                                     #newDir ev := NONE)
                                end
                            else if PState.isObserver state then
                                case ! $ #changedView ev of
                                    NONE    => ()
                                |   SOME P.NEXT =>
                                    (PState.changeObserved (state, 
                                        nextId (PState.observed state, 1) );
                                     #changedView ev := NONE)
                                |   SOME P.PREV =>
                                    (PState.changeObserved (state,
                                        nextId (PState.observed state, ~1) );
                                     #changedView ev := NONE)
                            else ()
                        end 
                    
                    (* estimated amount of time this game is running now *) 
                    val time        = Time.fromMilliseconds (ticks * 
                                        Time.toMilliseconds (#tick config))
                    val timeout     = #timeout config
                    (* amount of time left. *)
                    val timeLeft    = Time.fromSeconds (Int.max (0, 
                            Time.toSeconds (Time.- (timeout, time))))
                
                    (* traverse event map :
                        - remove disconnected clients
                        - forall other clients process 
                            turn , changeView, giveUp
                     *)
                    val _ = DynArray.appi (fn (id, PDESC pdesc) =>
                        let val ev      = #event pdesc
                            val part    = DynArray.sub (partDescs, id)
                        in
                            if ! $ #disconnected ev then 
                                actualDisconnect (disconns, part)
                            else 
                                processUserEvent (part, ev, quitters,
                                    dead, snakes, snakesInGate)
                        end) partDescs;
                   
                    (* move all snakes *)
                    val (res as { dead, grown, gateEntered, finished }) = 
                            Arena.moveSnakes (arena, !snakes, !snakesInGate)
                in 
                    (* shall we place a goody ? *)
                    if !goodies < #goodie config andalso 
                                Random.real 1.0 <= #goodieProb config 
                        then if Arena.placeGoody (arena, 3) 
                                then goodies := !goodies + 1
                                else ()
                        else ();
                            
                    (* register dead snakes *) 
                    List.foldl (fn (deadSnake, namesNColors) =>
                        let val id          = Snake.id deadSnake
                            val PDESC pd    = DynArray.sub (partDescs, id)
                            val state       = #state pd
                        in
                            PState.die (state, #lives config);
                            pointsChanged := true;
                            PState.nameNColor state :: namesNColors
                        end) [] dead ++ 
                    (fn names => invokeOnAll (#playersDied, names));
                    
                    (* register grown snakes *)
                    List.app (fn grownSnake =>
                        let val id          = Snake.id grownSnake
                            val PDESC pd    = DynArray.sub (partDescs, id)
                            val state       = #state pd
                        in
                            PState.adjustPoints state;
                            pointsChanged := true;
                            (* snake has eaten a goodie *)
                            goodies := !goodies - 1;

                            if PState.canEnterGate (state, #gateTreshold config) then
                                let val pos     = PState.gatePos state 
                                in
                                    Arena.openGate (arena, pos)
                                end
                            else ()
                        end) grown;

                    (* register snakes which entered a gate *)
                    List.app (fn snakeInGate =>
                        let val id          = Snake.id snakeInGate
                            val PDESC pd    = DynArray.sub (partDescs, id)
                            val state       = #state pd
                        in
                            PState.enterGate state;  
                            pointsChanged := true
                        end) gateEntered;
                   
                    (* register snakes which have finished this level *)
                    List.app (fn finishedSnake =>
                        let val id          = Snake.id finishedSnake
                            val PDESC pd    = DynArray.sub (partDescs, id)
                            val state       = #state pd
                        in
                            PState.finish state;
                            pointsChanged := true
                        end) finished;

                    sendTick (!pointsChanged, Arena.commit arena, timeLeft);

                    (* are there still some snakes left on the arena ? *)
                    List.length (!snakes) + List.length (!snakesInGate) 
                        - List.length dead - List.length finished > 0
                end)
            
            (**
              [startMainLoop ()] starts the main game loop, which just 
              executes all levels one after another.
             *)
              
            fun finishTournament () =
                let
                    val highscore = HighscoreIO.load ()
                    val highscore = Highscore.merge (highscore,
                                        computePoints (), 0)
                in
                    gameStarted := false;
                    invokeOnAll (#tournamentFinished, highscore)
                end
                
            fun startMainLoop config =
                let
                    fun mainLoop [] = finishTournament ()
                      | mainLoop (l::ls) =
                        (if executeLevel l then
                            mainLoop ls
                         else 
                            finishTournament () )
                in
                    if !gameStarted 
                        then raise P.Protocol gameStartedMsg
                        else ();

                    gameStarted := true;
                   
                    (* let the games begin ... ;-) *)
                    invokeOnAll (#tournamentStarted, ());

                    ispawn (_file_, _line_) mainLoop (computeLevels config)
                end

            and startLevel (arena, startPos) =
                let
                    (* all players who are allowed to play another level *)
                    val players     = mapPlayers id
                    val dims        = #dimensions config 
                    val levelInfo   = {
                            dimensions = dims
                        }
                in
                    (* reset number of goodies *)
                    goodies := 0;
                    
                    (* no more players left? *)
                    if null players 
                        then false
                        else (
                            ListPair.app (fn (player as PDESC pd, (pos, dir)) =>
                                let
                                    val state       = #state pd
                                    val (_,color)   = PState.nameNColor state
                                in
                                    (* place gate *)
                                    Arena.placeGate (arena, pos, color);
                                    (* setup state of snake *)
                                    PState.startLevel (state, op* dims, pos, dir)
                                end) (players, startPos);
            
                            invokeOnAll (#levelStarted, levelInfo);
                            (* send initial diff list *)
                            let
                                val diffs   = Arena.commit arena
                                val pts     = NONE
                                val time    = #timeout config
                            in
                                ListPair.app (fn (p as PDESC pd, (pos, _)) =>
                                    let
                                        val state       = #state pd
                                    in
                                        invoke (p, #tick, 
                                            (pts, diffs, SOME pos, time) )
                                    end) (players, startPos)
                            end;
                            countdown 3)
                end

            and countdown n =
                let
                    val p   = Promise.promise ()
                    
                    fun loop n =
                        if n < 0 
                            then Promise.fulfill (p, true)
                            else (Thread.sleep (Time.fromMilliseconds 990);
                                  invokeOnAll (#countdown, n);
                                  loop (n - 1) )
                in
                    ispawn (_file_, _line_) loop n;
                    Promise.future p
                end
                
            and finishLevel (arena) =
                ()

            and executeLevel (arena, startPos) =
                let
                    fun ticker (level, ticks) =
                        (* if level not yet done *)
                        if tick (level, ticks)
                            then 
                                (* sleep some tick and execute next ticks *)
                                (Thread.sleep $ #tick config;
                                 synchronize partDescs;
                                 ticker (level, ticks + 1))
                            else ()
                in
                    if startLevel (arena, startPos) then
                        (ticker (arena, 0);
                         finishLevel (arena);
                         true)
                        handle ServerDisconnected => false
                    else false
              end

            (**
               [startGame] can only be called by the priviliged client
               (i.e the one that started the server)
             *)
            val startGame = RWLock.syncWrite lock (fn () => startMainLoop config)


            (**
               all commands below just register appropriate information
               in the appropriate event.  The actual "work" is then done 
               at the start of the next tick loop.
               
               The next two functions capture the common behavior.
             *)
            
            fun updateEvent1 (id, f) = RWLock.sync lock (fn a =>
                let
                    val PDESC pdesc = DynArray.sub (partDescs, id)
                    val ev          = #event pdesc
                in
                    (* we await ev here to make sure that
                       Protocol exception is raised as early
                       as possible
                     *)
                    f (id, Future.await ev, a)
                end)
                
            fun updateEvent0 (id, f) = RWLock.sync lock (fn () =>
                let
                    val PDESC pdesc = DynArray.sub (partDescs, id)
                    val ev          = #event pdesc
                in
                    f (id, Future.await ev)
                end)
                
            fun turn id = updateEvent1 (id, fn (id, ev, dir) => 
                #newDir ev := SOME dir)

            fun changeView id = updateEvent1 (id, fn (id, ev, chv) =>
                #changedView ev := SOME chv)

            fun disconnect id = updateEvent0 (id, fn (id, ev) =>
                #disconnected ev := true)

            fun giveUp id = updateEvent0 (id, fn (id, ev) =>
                #giveUp ev := true)

            (**
              [play (name, color)] is called by the client when he has
              selected name and color of his snake and wants to play.
             *)
            fun play id = RWLock.syncWrite lock (fn (name, color) =>
                let
                    val PDESC pdesc         = DynArray.sub (partDescs, id)
                    val ev                  = #event pdesc
                    val state               = #state pdesc
                    val maxLen              = op* (#dimensions config)
                in
                    if !(#disconnected ev )
                        then raise P.Protocol unknownClientMsg
                        else ();
                    if !gameStarted 
                        then raise P.Protocol gameStartedMsg
                        else ();
                    if not (PState.isConnected state)
                        then raise P.Protocol "already a player / spectator"
                        else ();

                    (* is there a location left on the map? *)
                    if !playerNum < #maxPlayers config 
                        then ((* yes got another player *)
                              playerNum := !playerNum + 1;
                              PState.play (state, maxLen, name, color);
                              (* inform the others *)
                              invokeOnAllBut (id, #playersJoined, [(name, color)]); 
                              true)
                        else false 
                end)

            
            (**
              [watch ()] is called by the client when he just wants
              to watch a game.
             *)
            fun watch id = RWLock.syncWrite lock (fn () =>
                let
                    val PDESC pdesc         = DynArray.sub (partDescs, id)
                    val ev                  = #event pdesc
                    val state               = #state pdesc
                in
                    if ! (#disconnected ev )
                        then raise P.Protocol unknownClientMsg
                        else ();
                    if !gameStarted 
                        then raise P.Protocol gameStartedMsg
                        else ();
                    if not (PState.isConnected state)
                        then raise P.Protocol "already a player / spectator"
                        else ();
                    
                    PState.watch state
                end)
             
            (**
              [createParticipant clientInterface] creates a new entry
              in the participant map [partDescs]. The caller is responsible
              for the locking!
             *)
            fun createParticipant interface =
                let
                    (* do not allow connections to a running game *)
                    val _   = if !gameStarted 
                                then raise P.Protocol gameStartedMsg
                                else ()

                    (* determine new id *)
                    val id          = DynArray.length partDescs
                    val event       = initialEvent ()
                    val state       = PState.pstate id
                    val chan        = Channel.channel ()
                    val pd          = PDESC {
                        event,
                        interface,
                        rpcs = chan,
                        state
                    }
                in
                    (* setup participant desc *)
                    DynArray.resize (partDescs, id + 1, pd);

                    (* start rpc handler *)
                    ispawn (_file_, _line_) actualInvoke (event, chan);
                    pd
                end


            (**
              connect handler: 
                - create new entry in participant map
             *)
            val connect     = RWLock.syncWrite lock (fn interface =>
                let
                    val (allPlayers, allPlayersLook)   = ListPair.unzip $ 
                        mapPlayers (fn (pdesc as PDESC p) => 
                            (pdesc, PState.nameNColor $ #state p) )

                    val pdesc as PDESC p    = createParticipant interface
                    val id                  = PState.id $ #state p
                in
                    (* inform this client of the already connected clients *)
                    invoke (pdesc, #playersJoined, allPlayersLook);
                    
                    (* return proxied server interface.
                       NOTE: UCs are not allowed to call startGame
                        therefore startGame = NONE
                    *)
                    (config, {
                        disconnect  = Remote.proxy (disconnect id),
                        play        = Remote.proxy (play id),
                        turn        = Remote.proxy (turn id),
                        changeView  = Remote.proxy (changeView id),
                        giveUp      = Remote.proxy (giveUp id),
                        startGame   = NONE,
                        watch       = Remote.proxy (watch id)
                    })
                end)
                
            (**
              here we actually create the priviliged client.  It's the
              first one we add therefore it's id is always 0!
             *)
            val _       = createParticipant pClient
            
            (* allow other clients to connect *)
            val package = pack (val connect = Remote.proxy connect) :> 
                            P.SERVER_CONNECTOR

            val ticket  = Remote.offer package
           

            val pcServerInterface = 
                {   disconnect  = Remote.proxy (disconnect pcId),
                    play        = Remote.proxy (play pcId),
                    turn        = Remote.proxy (turn pcId),
                    changeView  = Remote.proxy (changeView pcId),
                    giveUp      = Remote.proxy (giveUp pcId),
                    watch       = Remote.proxy (watch pcId),
                    startGame   = SOME (Remote.proxy startGame)
                }
        in
            (* return ticket and the server interface to 
               the priviliged client *) 
            (ticket, pcServerInterface)
        end
end
