val validmarker = 0
val trailmarker1 = 1
val trailmarker2 = 2
val trailmarker3 = 3

val markE  = (nil, [trailmarker1, trailmarker2, trailmarker3])
val markSE = ([trailmarker1], [trailmarker2, trailmarker3])
val markSW = ([trailmarker2], [trailmarker1, trailmarker3])
val markW  = ([trailmarker1,trailmarker2], [trailmarker3])
val markNW = ([trailmarker3], [trailmarker1, trailmarker2])
val markNE = ([trailmarker3,trailmarker1], [trailmarker2])

val foodmarker = 4

val todo = loop (flip 123 ifyes nop)
val lost = loop (flip 124 ifyes nop)

local
(* set the vector in the current field *)
(* last operation is setting the valid marker *)
fun doMark (pos, neg) =
    (List.foldl (fn (m, r) => mark m ++ r) nop pos) ++
    (List.foldl (fn (m, r) => unmark m ++ r) nop neg) ++
    mark validmarker
    
(* generate a mark for the _opposite_ direction *)
fun markWithState 0 = doMark markW
  | markWithState 1 = doMark markNW
  | markWithState 2 = doMark markNE
  | markWithState 3 = doMark markE
  | markWithState 4 = doMark markSE
  | markWithState 5 = doMark markSW
  | markWithState _ = raise Match

fun turnHome'(e,se,sw,w,nw,ne) =
    sense2 here (marker trailmarker1) ifyes (
      sense2 here (marker trailmarker2) ifyes (
        w ()
      ) ifnot (
        sense2 here (marker trailmarker3) ifyes (
          ne ()
        ) ifnot (
          se ()
        )
      )
    ) ifnot (
      sense2 here (marker trailmarker2) ifyes (
        sw ()
      ) ifnot (
        sense2 here (marker trailmarker3) ifyes (
          nw ()
        ) ifnot (
          e ()
        )
      )
    )

val turns = (fn _ => nop, fn _ => turn right,
             fn _ => turn right ++ turn right,
             fn _ => turn right ++ turn right ++ turn right,
             fn _ => turn left ++ turn left,
             fn _ => turn left)

fun cycleTurns 0 t = t
  | cycleTurns n (a,b,c,d,e,f) = cycleTurns (n-1) (f,a,b,c,d,e)

fun turnHome n = turnHome' (cycleTurns n turns)

fun turnTo 0 n = (#1 (cycleTurns n turns))()
  | turnTo 1 n = (#2 (cycleTurns n turns))()
  | turnTo 2 n = (#3 (cycleTurns n turns))()
  | turnTo 3 n = (#4 (cycleTurns n turns))()
  | turnTo 4 n = (#5 (cycleTurns n turns))()
  | turnTo 5 n = (#6 (cycleTurns n turns))()
  | turnTo _ _       = raise Match

(* if we are on a vector, turn to the indicated direction *)
(* if we are not, set a mark looking opposite to our direction *)

in
fun direct() =
    sense2 here (marker validmarker) ifyes (
      switch (List.tabulate(6,turnHome))
    ) ifnot (
      switch (List.tabulate(6,markWithState))
    )

fun head n =
    switch (List.tabulate(6,turnTo n))
end

fun domove otherwise evadeaction =
    letlabel (fn exit =>
    letlabel (fn evade =>
	sense ahead foehome ifyes (goto evade) ++
	(* avoid trap *)
	sense leftahead foe ifyes (
	    sense rightahead foe ifyes (goto evade)
	) ++
	move ifyes (goto exit) ++
	label evade ++
	evadeaction ++
	label exit
    ))


fun gohome goaction homeaction =
let
    val direct = direct()
    val turn_left = turn left
in
    loopx (fn break =>
	sense here home ifyes (
	    homeaction ++
	    break
	) ++
	direct ++
	letlabel (fn tryagain =>
	    label tryagain ++
	    domove otherwise (
		turn_left ++
		goto tryagain
	    )
	) ++
	goaction
    )
end

(* val fetch_food = *)
(*     loop ( *)
(* 	turnto (marker foodmarker) ifnot ( *)
(* 	    turnto food ifnot nop *)
(* 	) ++ *)
(* 	domove otherwise nop *)
(*     ) *)


val deliver_food =
    gohome (mark foodmarker)
           (drop ++ lost)

(* Pioneer, build straight streets *)
(* should only be some ants on the edge of the hill *)
fun pioneer explorer =
    let
        val direct1 = direct()
    in
        loopx (fn break =>
                  direct1 ++
                  domove otherwise explorer
              )
    end

fun myturnto tl1 tl2 tr1 tr2 c ifyes b =
	letlabel (fn l1 =>
	letlabel (fn l2 => 
	    sensen [
		on(ahead, c) nop
	    ,
		on(leftahead, c) tl1
	    ,
		on(rightahead, c) tr1
	    ] otherwise (goto l2) ++
	    label l1 ++ b ++
	    label l2
	))
  | myturnto tl1 tl2 tr1 tr2 c ifnot b =
	    sensen [
		on(ahead, c) nop
	    ,
		on(leftahead, c) tl2
	    ,
		on(rightahead, c) tr2
	    ] otherwise b

(* Explorer, run around wildly and seek food *)
fun explorer (probTurn) collector =
    let
        val direct1 = direct()
        val turn1 = turn left
        val turn2 = turn left
        val tl1 = turn left
        val tl2 = turn left
        val tr1 = turn right
        val tr2 = turn right
        val ttf = myturnto tl1 tl2 tr1 tr2 food ifyes collector
    in
        loopx (fn break =>
                  direct1 ++
                  ttf ++
                  flip probTurn ifyes turn1 ++             
                  domove otherwise turn2
              )
    end

(* Collector, follow streets with food marker and bring food home *)
fun collector explorer =
    domove otherwise explorer ++
    pick ifnot explorer ++
    deliver_food

val ant =
    proc "pioneer" (pioneer (goto "explorer")) ++
    proc "explorer" (explorer 15 (goto "collector")) ++
    proc "collector" (collector (goto "explorer"))
