import structure Ant from "Ant"
import structure Instructions from "Instructions"

structure World =
  struct

  type cell = {rocky : bool,
               ant : Ant.ant option,
               food : int,
               redMarkers : bool vector,
               blackMarkers : bool vector,
               redHill : bool,
               blackHill : bool}
  val emptyCell = {rocky = false,
                   ant = NONE,
                   food = 0,
                   redMarkers = #[false,false,false,false,false,false],
                   blackMarkers = #[false,false,false,false,false,false],
                   redHill = false,
                   blackHill = false}

  (* world = x_size * cell array *)
  type world = int * cell array

  (* Managing the world *)

  fun newWorld(x_size, y_size) = (x_size, Array.array(x_size*y_size,emptyCell))
  fun sizeOfTheWorld(xs, cells) = (xs, Array.length cells div xs)

  fun getCellAt((xs, cells):world, (x,y)) =
      Array.sub(cells, xs*x+y)
  fun setCellAt((xs, cells):world, (x,y), cell) =
      Array.update(cells, xs*x+y, cell)
  fun existsCell((_, cells):world, f) =
      Array.exists f cells
  fun findCell((_, cells):world, f) =
      Array.find f cells
  fun findCoords((xs, cells):world, f) =
      let val (i,_) = valOf (Array.findi (fn (_,x) => f x) cells)
      in (i mod xs, i-(i mod xs)) end

  fun even x = x mod 2 = 0
  fun adjacentCell((x,y), Ant.E) = (x+1, y)
    | adjacentCell((x,y), Ant.SE) =
      if even y then (x,y+1) else (x+1,y+1)
    | adjacentCell((x,y), Ant.SW) =
      if even y then (x-1,y+1) else (x,y+1)
    | adjacentCell((x,y), Ant.W) = (x-1,y)
    | adjacentCell((x,y), Ant.NW) =
      if even y then (x-1,y-1) else (x,y-1)
    | adjacentCell((x,y), Ant.NE) =
      if even y then (x,y-1) else (x+1,y-1)

  (* Cartography *)
  fun rocky(world, pos) = #rocky (getCellAt(world, pos))

  (* Ant manipulation in the world*)
  fun someAntIsAt(world, pos) = #ant (getCellAt(world, pos)) <> NONE
  fun antAt(world, pos) = valOf (#ant (getCellAt(world, pos)))
  fun setAntAt(world, pos, a : Ant.ant) =
      setCellAt(world, pos,
                {(getCellAt(world, pos)) where ant=SOME a})
  fun clearAntAt(world, pos) =
      setCellAt(world, pos,
                {(getCellAt(world, pos)) where ant=NONE})

  fun antIsAlive(world, id) = existsCell(world,
                                         fn c => case #ant c of
                                                     NONE   => false
                                                   | SOME a => #id a = id)
  fun findAnt(world, id) = findCoords(world,
                                      fn c => case #ant c of
                                                  NONE   => false
                                                | SOME a => #id a = id)
  val killAntAt = clearAntAt

  (* Food manipulation in the world *)
  fun foodAt(world, pos) = #food (getCellAt(world, pos))
  fun setFoodAt(world, pos, f) = 
      setCellAt(world, pos,
                {(getCellAt(world, pos)) where food=f})
  fun anthillAt(world, pos, Ant.Red) =
      #redHill (getCellAt(world, pos))
    | anthillAt(world, pos, Ant.Black) =
      #blackHill (getCellAt(world, pos))

  (* Geometry *)
  local open Instructions open Ant
  in
  fun turn(Left, d) =
      (case d of E => NE | SE => E | SW => SE | W => SW | NW => W | NE => NW)
    | turn(Right, d) =
      (case d of E => SE | SE => SW | SW => W | W => NW | NW => NE | NE => E)
  end

  fun sensedCell(pos, dir, Instructions.Here) = pos
    | sensedCell(pos, dir, Instructions.Ahead) = adjacentCell(pos, dir)
    | sensedCell(pos, dir, Instructions.LeftAhead) =
      adjacentCell(pos, turn(Instructions.Left, dir))
    | sensedCell(pos, dir, Instructions.RightAhead) =
      adjacentCell(pos, turn(Instructions.Right, dir))
    

  (* Biology *)
  fun setState(world, pos, ant, s) =
      setAntAt(world, pos, {ant where state=s})
  fun setResting(world, pos, ant, r) =
      setAntAt(world, pos, {ant where resting=r})
  fun setDirection(world, pos, ant, d) =
      setAntAt(world, pos, {ant where direction=d})
  fun setHasFood(world, pos, ant, h) =
      setAntAt(world, pos, {ant where hasFood=h})

  (* Chemistry *)
  fun changeMarkerAt(world, pos, Ant.Red, marker, flag) =
      let
          val newMarkers = Vector.update(#redMarkers (getCellAt(world, pos)),
                                         marker, flag)
      in
          setCellAt(world, pos,
                    {(getCellAt(world, pos)) where redMarkers=newMarkers})
      end
    | changeMarkerAt(world, pos, Ant.Black, marker, flag) =
      let
          val newMarkers = Vector.update(#blackMarkers (getCellAt(world, pos)),
                                         marker, flag)
      in
          setCellAt(world, pos,
                    {(getCellAt(world, pos)) where blackMarkers=newMarkers})
      end

  fun setMarkerAt(w,p,c,m) = changeMarkerAt(w,p,c,m,true)
  fun clearMarkerAt(w,p,c,m) = changeMarkerAt(w,p,c,m,false)

  fun checkMarkerAt(world, pos, Ant.Red, marker) =
      Vector.sub(#redMarkers (getCellAt(world,pos)), marker)
    | checkMarkerAt(world, pos, Ant.Black, marker) =
      Vector.sub(#blackMarkers (getCellAt(world,pos)), marker)
  fun checkAnyMarkerAt(world, pos, Ant.Red) =
      Vector.exists (fn x => x)
                    (#redMarkers (getCellAt(world,pos)))
    | checkAnyMarkerAt(world, pos, Ant.Black) =
      Vector.exists (fn x => x)
                    (#blackMarkers (getCellAt(world,pos)))

  (* Phenomenology *)
  local
      open Instructions
  in
  fun cellMatches(world, pos, Friend,         color) =
      someAntIsAt(world,pos) andalso #color(antAt(world,pos))=color
    | cellMatches(world, pos, Foe,            color) =
      someAntIsAt(world,pos) andalso #color(antAt(world,pos))<>color
    | cellMatches(world, pos, FriendWithFood, color) =
      someAntIsAt(world,pos)
      andalso #color(antAt(world,pos))=color
      andalso #hasFood(antAt(world,pos))
    | cellMatches(world, pos, FoeWithFood,    color) =
      someAntIsAt(world,pos)
      andalso #color(antAt(world,pos))<>color
      andalso #hasFood(antAt(world,pos))
    | cellMatches(world, pos, Food,           color) =
      foodAt(world,pos) > 0
    | cellMatches(world, pos, Rock,           _    ) = rocky(world,pos)
    | cellMatches(world, pos, Marker m,       color) =
      checkMarkerAt(world, pos, color, m)
    | cellMatches(world, pos, FoeMarker,      color) =
      checkAnyMarkerAt(world, pos, Ant.otherColor color)
    | cellMatches(world, pos, Home,           color) =
      anthillAt(world, pos, color)
    | cellMatches(world, pos, FoeHome,        color) =
      anthillAt(world, pos, Ant.otherColor color)
  end

  (* Martial Arts *)
  fun adjacentAnts(world, pos, c) =
      foldl (fn (d,n) => let val cel = adjacentCell(pos, d) in
                             if someAntIsAt(world, cel) andalso
                                #color(antAt(world, cel)) = c
                             then n+1 else n
                         end) 0 Ant.directions
  fun checkForSurroundedAntAt(world, pos) =
      if someAntIsAt(world, pos) then
          let val a = antAt(world, pos) in
              if adjacentAnts(world,pos, Ant.otherColor(#color a)) >= 5 then
                  (killAntAt(world, pos);
                   setFoodAt(world, pos,
                             foodAt(world, pos) + 3 +
                             (if #hasFood a then 1 else 0)))
              else ()
          end
      else ()
  fun checkForSurroundedAnts(world, pos) =
      (checkForSurroundedAntAt(world, pos);
       app (fn d => checkForSurroundedAntAt(world, adjacentCell(pos, d)))
       Ant.directions)

  end
