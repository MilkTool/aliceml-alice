import signature ANTE from "ANTE-sig"
import structure Instructions from "Instructions"
import functor MkRedBlackMap from "x-alice:/lib/data/MkRedBlackMap"
import structure UnsafeValue from "x-alice:/lib/system/UnsafeValue"

structure Ante : ANTE =
struct
    exception Debug of string

    open Promise

    type marker		= int
    datatype side	= left | right
    datatype dir	= here | ahead | leftahead | rightahead
    datatype condition	= friend | foe | friendwithfood | foewithfood |
			  food | rock | marker of marker | foemarker |
			  home | foehome

    type label		= string
    datatype yesno	= ifyes | ifnot
    datatype otherwise	= otherwise
    datatype instr	= Fail | Concat of instr * instr |
 			  Scope of label -> instr |
			  Goto of label | Label of label * instr |
			  Mark of marker * instr | Unmark of marker * instr |
			  Turn of side * instr | Move of instr * instr |
			  Pick of instr * instr | Drop of instr |
			  Sense of dir * condition * instr * instr |
			  Flip of int * instr * instr
    type state		= int
    type stmt		= state -> int * (instr -> instr)
    type 'a branch	= 'a * stmt


  (* New turn labels *)

    val labcount = ref 0

    fun newlabel s =
	"_" ^ s ^ "-" ^ Int.toString (!labcount) before (labcount := !labcount+1)

  (* Primitives *)

    exception Malformed of string

    fun expandlabel st l = l ^ "$" ^ Int.toString st

    val fail		= fn st => (0, fn k => Fail)
    fun goto l		= fn st => (0, fn k => Goto (expandlabel st l))
    val nop		= fn st => (1, id)

    fun label l		= fn st => (1, fn k => Label(expandlabel st l, k))
    fun mark m		= fn st => (1, fn k => Mark(m, k))
    fun unmark m	= fn st => (1, fn k => Unmark(m, k))
    val drop		= fn st => (1, fn k => Drop k)

    fun turn s =
	let
	    val l = newlabel "turn"
	in
	    fn st =>
	    let
		val st' = (st + (case s of left => 5 | right => 1)) mod 6
	    in
		(1, fn k => Turn(s, Concat(Goto (expandlabel st' l),
					   Label (expandlabel st l, k))))
	    end
	end

    fun letlabel (f : label -> stmt) =
	fn st =>
	let
	    val (n,_) = f "dummy" st
	in
	    (n, fn k => Scope (fn l => #2 (f (expandlabel st l) st) k))
	end

    infixr ++
    fun b1 ++ b2 =
	fn st =>
	let
	    val (n1,f1) = b1 st
	    val (n2,f2) = b2 st
	in
	    case n1
	     of 0 => (n2, fn k => Concat(f1 k, f2 k))
	      | 1 => (n2, fn k => f1 (f2 k))
	      | _ => (n2, fn k => Scope (fn l => Concat(f1 (Goto l), Label(l, f2 k))))
	end

    fun join g b1 b2 =
	fn st =>
	let
	    val (n1,f1) = b1 st
	    val (n2,f2) = b2 st
	in
	    (n1+n2, fn k => g (f1 k, f2 k))
	end

    fun move2 ifyes b1 ifnot b2		= join Move b1 b2
      | move2 ifnot b1 ifyes b2		= join Move b2 b1
      | move2 _     _  _     _		= raise Malformed "move"

    fun pick2 ifyes b1 ifnot b2		= join Pick b1 b2
      | pick2 ifnot b1 ifyes b2		= join Pick b2 b1
      | pick2 _     _  _     _		= raise Malformed "pick"

    fun sense2 d c ifyes b1 ifnot b2	= join (fn (i1,i2) => Sense(d,c,i1,i2)) b1 b2
      | sense2 d c ifnot b1 ifyes b2	= join (fn (i1,i2) => Sense(d,c,i1,i2)) b2 b1
      | sense2 _ _ _     _  _     _	= raise Malformed "sense"

    fun flip2 n ifyes b1 ifnot b2	= join (fn (i1,i2) => Flip(n,i1,i2)) b1 b2
      | flip2 n ifnot b1 ifyes b2	= join (fn (i1,i2) => Flip(n,i1,i2)) b2 b1
      | flip2 n _     _  _     _	= raise Malformed "flip"

    fun negate ifnot = ifyes
      | negate ifyes = ifnot

    fun move yesno b			= move2 yesno b (negate yesno) nop
    fun pick yesno b			= pick2 yesno b (negate yesno) nop
    fun sense d c yesno b		= sense2 d c yesno b (negate yesno) nop
    fun flip i yesno b			= flip2 i yesno b (negate yesno) nop

    fun switch (bs : stmt list) =
	let
	    val l = newlabel "switch"
	in
	    fn st =>
	    let
		val fs = List.map (fn b => #2 (b st)) bs
	    in
		(1, switch' l 0 fs)
	    end
	end
    and switch' l st   []    k = Label(expandlabel 6 l, k)
      | switch' l st (f::fs) k = Concat(Label(expandlabel st l,
					      f (Goto(expandlabel 6 l))),
					switch' l (st+1) fs k)

  (* Combinators *)

    fun on x y = (x,y)

    fun flipn bs		= flipn' (List.length bs) bs
    and flipn' _ []		= nop
      | flipn' _ [b]		= b
      | flipn' _ [b1,b2]	= flip2 2 ifyes b1 ifnot b2
      | flipn' n (b::bs)	= flip2 n ifyes b ifnot (flipn' (n-1) bs)

    fun sensen [] otherwise b	= b
      | sensen (((d,c),b')::bs) otherwise b =
	    sense2 d c ifyes b' ifnot (sensen bs otherwise b)

    fun loop b = letlabel (fn l => label l ++ b ++ goto l)

    fun loopx f =
	letlabel (fn l1 =>
	letlabel (fn l2 =>
	label l1 ++ f (goto l2) ++ goto l1 ++ label l2))

    fun times 0 b = nop
      | times n b = b ++ times (n-1) b

    fun timesi n f = timesi' n n f
    and timesi' size 1 f = f (size-1)
      | timesi' size n f = f (size-n) ++ timesi' size (n-1) f

    fun repeat n b = loopx (fn break => flip2 n ifnot b ifyes break)

    fun try f otherwise b =
	letlabel (fn l1 =>
	letlabel (fn l2 =>
	f (goto l1) ++ goto l2 ++ label l1 ++ b ++ label l2))

    fun proc l b = label l ++ b


  (* Complex abstractions *)

    fun turnto c ifyes b =
	letlabel (fn l1 =>
	letlabel (fn l2 => 
	    sensen [
		on(ahead, c) nop
	    ,
		on(leftahead, c) (turn left)
	    ,
		on(rightahead, c) (turn right)
	    ] otherwise (goto l2) ++
	    label l1 ++ b ++
	    label l2
	))
      | turnto c ifnot b =
	    sensen [
		on(ahead, c) nop
	    ,
		on(leftahead, c) (turn left)
	    ,
		on(rightahead, c) (turn right)
	    ] otherwise b
	

  (* Compilation *)

    structure I = Instructions
    structure E = MkRedBlackMap String

    fun mkLabel j = "$" ^ Int.toString j

    fun traverse j n e a i =
	case i
	 of Fail =>
	    (n, [I.Flip(1,n,n,a)], n+1, e)
	  | Concat(i1,i2) =>
	    let
		val (s1,l1,n1,e1) = traverse j n e a i1
		val (s2,l2,n2,e2) = traverse j n1 e1 a i2
	    in
		(s1, l1@l2, n2, e2)
	    end
	  | Scope f =>
	    (j := !j+1; traverse j n e a (f (mkLabel (!j))))
	  | Goto l =>
	    (case E.lookup (e,l)
	     of SOME (p,b) => (future p, [], n, e)
	      | NONE =>
		let
		    val p = promise ()
		in
		    (future p, [], n, E.insert (e,l,(p,false)))
		end
	    )
	  | Label(l,i') =>
	    let
		val p = case E.lookup (e,l)
			 of SOME (p,true) => raise Malformed ("label " ^ l)
			  | SOME (p,false) => p
			  | NONE => promise ()
		val e = E.insert(e,l,(p,true))
		val result as (s',l',n',e') = traverse j n e a i'
	    in
		if UnsafeValue.same (s', future p)
		then (fulfill(p, n); (n, I.Flip(1,n,n,a)::l', n'+1, e'))
		else (fulfill(p, s'); result)
	    end
	  | Mark(m,i') =>
	    let
		val (s',l',n',e') = traverse j (n+1) e a i'
	    in
		(n, I.Mark(m,s',a)::l', n', e')
	    end
	  | Unmark(m,i') =>
	    let
		val (s',l',n',e') = traverse j (n+1) e a i'
	    in
		(n, I.Unmark(m,s',a)::l', n', e')
	    end
	  | Turn(t,i') =>
	    let
		val (s',l',n',e') = traverse j (n+1) e a i'
		val t' = case t of left => I.Left | right => I.Right
	    in
		(n, I.Turn(t',s',a)::l', n', e')
	    end
	  | Move(i1,i2) =>
	    let
		val (s1,l1,n1,e1) = traverse j (n+1) e a i1
		val (s2,l2,n2,e2) = traverse j n1 e1 a i2
	    in
		(n, I.Move(s1,s2,a)::l1@l2, n2, e2)
	    end
	  | Pick(i1,i2) =>
	    let
		val (s1,l1,n1,e1) = traverse j (n+1) e a i1
		val (s2,l2,n2,e2) = traverse j n1 e1 a i2
	    in
		(n, I.PickUp(s1,s2,a)::l1@l2, n2, e2)
	    end
	  | Drop(i') =>
	    let
		val (s',l',n',e') = traverse j (n+1) e a i'
	    in
		(n, I.Drop(s',a)::l', n', e')
	    end
	  | Sense(d,c,i1,i2) =>
	    let
		val (s1,l1,n1,e1) = traverse j (n+1) e a i1
		val (s2,l2,n2,e2) = traverse j n1 e1 a i2
		val d' = case d of here => I.Here
				 | ahead => I.Ahead
				 | leftahead => I.LeftAhead
				 | rightahead => I.RightAhead
		val c' = case c of friend => I.Friend
				 | foe => I.Foe
				 | friendwithfood => I.FriendWithFood
				 | foewithfood => I.FoeWithFood
				 | food => I.Food
				 | rock => I.Rock
				 | marker m => I.Marker m
				 | foemarker => I.FoeMarker
				 | home => I.Home
				 | foehome => I.FoeHome
	    in
		(n, I.Sense(d',s1,s2,c',a)::l1@l2, n2, e2)
	    end
	  | Flip(y,i1,i2) =>
	    let
		val (s1,l1,n1,e1) = traverse j (n+1) e a i1
		val (s2,l2,n2,e2) = traverse j n1 e1 a i2
	    in
		(n, I.Flip(y,s1,s2,a)::l1@l2, n2, e2)
	    end

    fun compile (b : stmt) =
	let
	    val instr = Concat(#2 (b 0) Fail,
			Concat(#2 (b 1) Fail,
			Concat(#2 (b 2) Fail,
			Concat(#2 (b 3) Fail,
			Concat(#2 (b 4) Fail,
			Concat(#2 (b 5) Fail,Fail))))))
	    val (_,l,n,e) = traverse (ref 0) 0 E.empty () instr
	in
	    assert n <= 10_000 do
	    E.appi (fn (l,(p,_)) =>
			if Future.isDetermined (future p) then ()
			else raise Malformed ("goto " ^ l)) e;
	    Vector.fromList l
	end
end



(*
    fun continue k (Cont)		= k
      | continue k (Fail)		= Fail
      | continue k (Goto l)		= Goto l
      | continue k (Label(l,k'))	= Label(l, continue k k')
      | continue k (Mark(m,k'))		= Mark(m, continue k k')
      | continue k (Unmark(m,k'))	= Unmark(m, continue k k')
      | continue k (Turn(s,k'))		= Turn(s, continue k k')
      | continue k (Move(k1,k2))	= Move(continue k k1, continue k k2)
      | continue k (Pick(k1,k2))	= Pick(continue k k1, continue k k2)
      | continue k (Drop k')		= Drop(continue k k')
      | continue k (Sense(d,c,k1,k2))	= Sense(d, c, continue k k1,
						      continue k k2)
      | continue k (Flip(n,k1,k2))	= Flip(n,continue k k1, continue k k2)
*)
