(* ADG 1.0 - Alice Dependence Graph
*
*  Author: Sebastian Germesin
*
*  $Revision$
*
*  Last updated: $Date$ by $Author$
* 
*
*)

import structure Tree from "Tree"

structure Depend =
struct

fun isEndOfHeader s = 
    (String.isSubstring "structure" s orelse
     String.isSubstring "signature" s orelse
     String.isSubstring "functor"   s orelse
     String.isSubstring "val"       s orelse
     String.isSubstring "fun"       s) andalso
    (not (String.isSubstring "import " s))


fun getPath' (str, i) = if i > String.size str 
			then assert false (* wrong string *)
			else if String.sub (str, i) = #"\"" 
			     then i
			     else getPath' (str, i + 1)

fun getPath (instr, nil)     = 
                if TextIO.endOfStream instr
		then ""
		else getPath (instr, explode (valOf (TextIO.inputLine instr)))
  | getPath (instr, x::xs) = 
               if x = #"\"" 
	       then implode (List.take (xs, getPath' (implode xs, 0)))
	       else getPath (instr, xs)

fun getImports (instr, xs : string list) = 
    if TextIO.endOfStream instr
    then (TextIO.closeIn instr; xs)
    else 
	let
	    val l = valOf (TextIO.inputLine instr)
	in
	    if isEndOfHeader l
	    then (TextIO.closeIn instr; xs)
	    else if Tree.isImport l
	         then let
		         val p = getPath (instr, explode l)
		      in 
		         if p = "" 
			 then getImports (instr, xs)
			 else getImports (instr, p::xs)
		      end
	         else getImports (instr, xs)
	end

fun searchForFile (d, f) = 
    let
	val _ = TextIO.output (TextIO.stdOut, "search for file: " ^
					      d ^ "/" ^ f ^ "\n");
	val dirStr = OS.FileSys.openDir d
	fun search' s = 
	    let
		val file = OS.FileSys.readDir s
	    in
		if Option.isNone file 
		then (OS.FileSys.closeDir dirStr;
		      TextIO.output (TextIO.stdErr, "\tcould not find file!\n");
		      NONE)
		else if String.isSubstring f (valOf file) andalso 
			String.isSuffix ".aml" (valOf file)
		     then (TextIO.output (TextIO.stdOut, "\tfound file: " ^
							 d ^ "/" ^ (valOf file) ^ "\n");
			   SOME (d ^ "/" ^ (valOf file)))
	             else search' dirStr
	    end
    in
	search' dirStr
    end


fun tree' (p, switch, regex, outStr, parent) =
    let
	val path = if OS.Path.isAbsolute p
		   then OS.Path.dir p
		   else OS.Path.mkCanonical 
			  (OS.Path.dir ((OS.FileSys.getDir ()) ^ "\\" ^ p));
	val file = OS.Path.file p
	val instr = TextIO.openIn p
	val imp = rev (getImports (instr, nil))

	fun tree'' im = 
	    if (switch andalso Tree.isRegExImport (regex, im)) orelse
	       (not (switch orelse (Tree.isRegExImport (regex, im))))
	    then 
		if Tree.isLibImport im 
		then let
			val (title, _) = Tree.insertNode 
					     (OS.Path.mkCanonical im, 
					      [("color", "green")])
		    in
			if parent <> "" 
			then Tree.insertEdge (parent, title, [])
			else  ()
		    end
		else if Tree.isUnsafeImport im
	        then let
		        val (title, _) = Tree.insertNode 
					     (OS.Path.mkCanonical im, 
					      [("color", "yellow")])
		    in 
		        if parent <> "" 
			then Tree.insertEdge (parent, title, [])
			else  ()
		    end
		else let
			val path'  = OS.Path.mkCanonical (path ^ "/" ^ im ^ 
							  ".aml")
			val path'' = OS.Path.mkCanonical (path ^ "/" ^ im)
			val (title, mult)  = Tree.insertNode 
						 (path'', [("color", 
							    if parent = ""
							    then ("red")
							    else ("blue"))])
		    in
			if not mult
			then (if parent <> "" 
			      then Tree.insertEdge (parent, title, [])
			      else  ();
			      tree' (path', switch, regex, outStr, title)
			      handle IO.Io _ => 
				     let
				    val x = searchForFile (OS.Path.dir path'',
					     		   OS.Path.file path'')
				     in
					 if Option.isNone x
					 then ()
					 else tree' (valOf x, switch, regex, 
						     outStr, title)
				     end)
			else Tree.insertEdge (parent, title, []) 
		    end
	    else ()
    in
        List.app tree'' imp
    end

fun tree (inFile, switch, regex, outStr, parent) = 
    let
	val (title, _) = Tree.insertNode (parent, [("color", "red")])
    in
	tree' (inFile, switch, regex, outStr, title);
	(!Tree.nodes, !Tree.edges)
    end

end
