(* ADG 1.0 - Alice Dependence Graph
*
*  Author: Sebastian Germesin
*
*  $Revision$
*
*  Last updated: $Date$ by $Author$
* 
*
*)

(* FIXME: test if it is really an import => ignore comments *)
fun isImport s = String.isSubstring "import" s 

fun isLibImport p = String.isSubstring "x-alice:" p

fun getPath' (str, i) = if String.sub (str, i) = #"\"" 
			then i
			else getPath' (str, i + 1)

fun getPath nil     = ""
  | getPath (x::xs) = 
               if x = #"\"" 
	       then implode (List.take (xs, getPath' (implode xs, 0)))
	       else getPath xs

(* TODO: funzt das auch in der Lib? -> NEIN, s. Array2.aml*)
fun getImports (instr, xs : string list) = 
    if TextIO.endOfStream instr 
    then (TextIO.closeIn instr; xs)
    else 
	let
	    val l = valOf (TextIO.inputLine instr)
	in
	    if isImport l
	    then let
		    val p = getPath (explode l)
		in 
		    if p = "" 
		    then getImports (instr, xs)
		    else getImports (instr, (getPath (explode l))::xs)
		end
	    else getImports (instr, xs)
	end

fun searchForFile (d, f) = 
    let
	val dirStr = OS.FileSys.openDir d
	fun search' s = 
	    let
		val file = OS.FileSys.readDir s
	    in
		if Option.isNone file 
		then (OS.FileSys.closeDir dirStr;
		      print "could not find file... :-(\n";
		      NONE)
		else if String.isSubstring f (valOf file) andalso 
			String.isSuffix ".aml" (valOf file)
		     then SOME (d ^ "/" ^ (valOf file))
	             else search' dirStr
	    end
    in
	search' dirStr
    end

(* its a (string * string * string * (string * string) list) list storing 
   (title, path, filename, atributes list) *)
val nodes = ref nil
(* its a (string * string * (string * string) list) list storing 
   (source(title), target(title), attributes list) *)
val edges = ref nil

fun insertNode (pathNfile, attrList) = 
    let
	val path     = OS.Path.dir pathNfile
	val filename = OS.Path.file pathNfile
	val title    = pathNfile
	val path' = if String.size path >= 20 andalso not (isImport path)
		    then ("..." ^ 
			  (implode (rev (List.take (rev (explode path), 
						    List.length (explode path)
						    - 3)))))
		    else path
    in
	if not (List.exists (fn (t, _, _, _) => t = title) (!nodes))
	then nodes := (title, path', filename, attrList) :: !nodes
	else ();
	title
    end

fun insertEdge (source, target, attrList, b) = 
    if b orelse (not (List.exists (fn (s, t, _) => s = source andalso 
						   t = target) (!edges)))
    then edges := (source, target, attrList) :: !edges
    else ()
    


fun buildTree (p, outStr, parent, b) =
    let
	val path = if OS.Path.isAbsolute p
		   then OS.Path.dir p
		   else OS.Path.mkCanonical 
			  (OS.Path.dir ((OS.FileSys.getDir ()) ^ "\\" ^ p));
	val file = OS.Path.file p
	val instr = TextIO.openIn p
	val imp = rev (getImports (instr, nil))

	fun buildTree' im = 
	    if isLibImport im 
	    then let
		    val title = insertNode 
				    (OS.Path.mkCanonical im, 
				     [("color", "green")])
		in
		    if parent <> "" 
		    then insertEdge (parent, title, [], b)
		    else  ()
                end
	    else  
		let
		    val path' = OS.Path.mkCanonical (path ^ "/" ^ im ^ ".aml")
		    val path'' = OS.Path.mkCanonical (path ^ "/" ^ im)
		    val title = insertNode 
				    (path'', [("color", if parent = ""
							then ("red")
							else ("blue"))])
		in
		    if parent <> "" 
		    then insertEdge (parent, title, [], b)
		    else  ();
		    buildTree (path', outStr, title, b)
		    handle IO.Io _ => 
			   let
			       val x = searchForFile (OS.Path.dir path'',
						      OS.Path.file path'')
			   in
			       if Option.isNone x
			       then ()
			       else buildTree (valOf x, outStr, title, b)
			   end
		end
    in
        List.app buildTree' imp
    end

fun build (p, outStr, b) = 
    let
	val path = if OS.Path.isAbsolute p
		   then OS.Path.dir p
		   else OS.Path.mkCanonical 
			  (OS.Path.dir ((OS.FileSys.getDir ()) ^ "\\" ^ p))
	val file = OS.Path.file p
	val title = insertNode (OS.Path.mkCanonical (path ^ "/" ^ file),
				[("color", "red")]);
    in
	buildTree (p, outStr, title, b)
    end

fun writeFile stream =
    let
	fun node (t, p, f, a) =
	    (TextIO.output (stream, 
			    "node: { title: \"" ^ t ^ "\" label: \"" ^ p ^ 
			    "\\n" ^ f ^ "\" "); 
	     List.app (fn (a, b) => TextIO.output (stream, a ^ ": " ^ 
							   b ^ " ")) a;
	     TextIO.output (stream, "}\n"))

	fun edge (s, t, a)    =
	    (TextIO.output (stream, 
			    "edge: { source: \"" ^ s ^ "\" target: \"" ^ 
			    t ^ "\" "); 
	     List.app (fn (a, b) => TextIO.output (stream, a ^ ": " ^ 
							   b ^ " ")) a;
	     TextIO.output (stream, "}\n"))
    in
	List.app node (!nodes);
	TextIO.output (stream, "\n\n");
	List.app edge (!edges);
	print "\n\ndone.\n"
    end

val head = 
    "// Alice Dependence Graph           //\n" ^ 
    "//                                  //\n" ^ 
    "// Author: Sebastian Germesin       //\n" ^ 
    "//                                  //\n" ^
    "// eMail: germi@ps.uni-sb.de        //\n" ^ 
    "//                                  //\n" ^
    "//////////////////////////////////////\n" ^
    "//\n" ^ 
    "//\n" ^ 
    "// written in GDL (Graph Description Language)" ^
    "// Annotations:\n" ^
    "//\n" ^ 
    "// for looking the graph:\n" ^
    "//     use http://www.absint.com/aisee/download/index_de.htm\n" ^
    "//\n" ^
    "// red box   with black border  = main file\n" ^
    "// green box with black border  = built files\n" ^
    "// blue box  with black border  = alice-lib files\n\n\n" ^
    "graph: {title: \"Alice Dependence Graph\"\n" ^
    "        layoutalgorithm  : tree\n" ^
    "        node.textcolor   : black\n" ^
    "        node.fontname    : \"helvB08\"\n" ^ 
    "        node.height      : 28\n" ^
    "        node.borderwidth : 2\n" ^
    "        edge.color       : 31\n" ^
    "        splines          : yes\n" ^
    "        portsharing      : yes\n\n\n\n"

val usage = "\nusage: \nalicerun depend <input_filename> " ^ 
	    "[<output_filename>] [<mutliple_edges>]\n\n"

fun start (inFile, outFile, b) = 
    let
	val output = TextIO.openOut (outFile ^ ".adg")
    in 
	TextIO.output (TextIO.stdOut, "input  file: " ^ inFile ^ "\n");
	TextIO.output (TextIO.stdOut, "output file: " ^ outFile ^ ".adg\n");
	TextIO.output (output, head);
	build (inFile, output, b);
	writeFile output;
	TextIO.output (output, "\n}");
	TextIO.closeOut output;
	OS.Process.exit OS.Process.success
    end


val _  = case CommandLine.arguments () of
	         []     => TextIO.output (TextIO.stdErr, usage)
	       | [x]    => start (x, "output", false) 
	       | [x, y] => start (x, y, false)
	       | [x, y, z] => start (x, y, valOf (Bool.fromString z)
				            handle Option => false)
	       |   _    => TextIO.output (TextIO.stdErr, usage)
			    

