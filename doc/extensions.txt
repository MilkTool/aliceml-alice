Core language:

+ binary literals
+ longids as context-free syntax
- allow with type instead of withtype?

- var annotations in types?
- curried fn? (grammar overhead)
+ more liberal syntax in fun
+ more liberal datatype declaration syntax
+ punning in record expressions
- record update
+ vector constants and patterns
- list and vector comprehensions
+ generalized rec
+ pattern guards
+ alternative patterns
+ negated patterns
+ generalized layered patterns
+ with patterns
- matches in valbinds? (val SOME x = exp1 | x = exp2)
+ rec expressions derived form
* nonlinear patterns? (better not, requires structural equality)

* heavier overloaded literals (allow 4*3.3 and 0wx3f<<6)
* overloaded vector expressions and patterns (poly vector or mono vectors)
* make real an eqtype
* polymorphic records
+ open datatypes, turning exceptions into derived forms
* existiential types in datatypes
* specs as decs (semantics?)

Module language:

- local around fundecs and sigdecs
+ parenthesized structure and signature expressions
+ more liberal type specification syntax
+ more liberal datatype specification syntax
+ withtype derived form in signatures
- open with structure expressions?
+ fixity specs

+ where for structures
+ structure synonyms
* singleton signatures / open in signatures (DF)
* hiding
* signature composition
* signature subtraction
* parameterized signatures

* higher-order functors (functors in structures and signatures)
* longids as path expressions
* functor and top signatures
* first-class structures/functors (how??)
