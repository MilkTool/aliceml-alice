<?php include("macros.php3"); ?>
<?php heading("A Short Tour of Alice", "A Short Tour of Alice") ?>


<?php section("overview", "overview") ?>

<P>This page is meant as a short introduction to the Alice language and system
and its features:</P>

<UL>
  <LI><A href="#sml">Standard ML compatibility</A></LI>
  <LI><A href="#interactive">Interactive use</A>: evaluating declarations and
  browsing results</LI>
  <LI><A href="#laziness">Laziness</A>: transparent lazy evaluation on demand</LI>
  <LI><A href="#concurrency">Concurrency</A>: threads and data-flow
  synchronistation</LI>
  <LI><A href="#promises">Promises</A>: </LI>
  <LI><A href="#components">Components</A>: platform independence and
  lazy dynamic linking</LI>
  <LI><A href="#packages">Packages</A>: dynamic typing and first-class modules</LI>
  <LI><A href="#pickling">Pickling</A>: platform independent persistence</LI>
  <LI><A href="#distribution">Distribution</A>: </LI>
  <LI><A href="#constraints">Constraint Programming</A>: </LI>
  <LI><A href="#interop">Interoperability</A>: working hand in hand with Oz
  programs</LI>
</UL>


<?php section("sml", "standard ML") ?>

<P>Alice ML is an extension of the
<A href="http://cm.bell-labs.com/cm/cs/what/smlnj/sml.html">Standard ML</A> language (SML).
Most of the examples shown here assume a working knowledge of functional
programming in general and SML in particular. There are numerous
books and tutorials available for SML.</P>

<P>Online Material:</P>

<UL>
  <LI><A href="http://www-2.cs.cmu.edu/People/rwh/introsml/">Programming in
  Standard ML</A>, by Robert Harper, CMU</LI>
  <LI><A href="http://www.dcs.ed.ac.uk/home/stg/NOTES/">Programming in Standard
  ML '97: An Online Tutorial</A>, by Stephen Gilmore, University of
  Edinburgh</LI>
</UL>

<P>Paper Books:</P>

<UL>
  <LI><A href="http://www.cl.cam.ac.uk/users/lcp/MLbook/">ML for the Working
  Programmer</A> (2nd edition), by Larry Paulson. Cambridge University
  Press</LI>
  <LI><A href="http://www-db.stanford.edu/~ullman/emlp.html">Elements of ML
  Programming</A> (ML'97 edition), by Jeffrey Ullmann. Prentice-Hall</LI>
</UL>

<P>The definition of the language and its library can be found here:</P>

<UL>
  <LI><A href="http://mitpress.mit.edu/book-home.tcl?isbn=0-262-63181-4">The
  Definition of Standard ML</A> (Revised), by Robin Milner, Mads Tofte,
  Robert Harper, Dave MacQueen. The MIT Press</LI>
  <LI><A href="http://SML.sourceforge.net/Basis/">The Standard ML
  Basis Library</A> (Preliminary), by John Reppy and Emden Gansner.</LI>
</UL>

<P>For a more comprehensive literature list, see the
<A href="http://www.smlnj.org/doc/literature.html#tutorials">bibliography</A>
on the SML/NJ site.</P>


<?php section("interactive", "interactive toplevel") ?>

<P>Alice ML is an extension of Standard ML, and the Alice
<A href="interactive.html">interactive toplevel</A>
functions very similar to the interactive prompts known from other SML
systems where you can type in expressions and declarations to evaluate them.
Input is terminated with a semicolon. For example, you might simply perform a
simple calculation:</P>

<PRE class=code>
- 4+5;
<I>val it : int = 9</I></PRE>

<P>The expression is evaluated and the result <TT>9</TT> printed along with
its inferred type <TT>int</TT>. Anonymous expressions get the name <TT>it</TT>,
so that you can refer to them in consecutive inputs:</P>

<PRE class=code>
- 2*it;
<I>val it : int = 18</I></PRE>

<P>We can also try the one-line Hello World program:</P>

<PRE class=code>
- print "Hello world!\n";
<I>Hello world!
val it : unit = ()</I></PRE>

<P>In the rest of this tour we will present program fragments in their pure
form, without showing the interpreter prompt or the semicolon terminating the
interactive input. For example, the last interaction will be displayed simply
as</P>

<PRE class=code>
print "Hello world!\n"
<I>Hello world!
val it : unit = ()</I></PRE>

<P>Entering a function declaration is more interesting. For example,
the factority function:<P>

<PRE class=code>
fun fac 0 = 1
  | fac n = n * fac (n-1)
<I>val fac : int -> int = fn</I></PRE>

<P>This time, the result has a more complex type: it is a function from
integers to integers. We can apply that function:</P>

<PRE class=code>
fac 50
<I>val it : int = 30414093201713378043612608166064768844377641568960512000000000000</I></PRE>

<P>For more complex values, the static output of the result is often
insufficient. The Alice system includes the <A
href="library/inspector.html"><EM>Inspector</EM></A> for browsing arbitrary data
structures interactively:</P>

<PRE class=code>
inspect (List.tabulate (10, fn i => (i, i*i, i*i*i)))
<I>val it : unit = ()</I></PRE>

<P>An Inspector window will pop up displaying the table of the first hundred
square and cubic numbers:</P>

<P align=center><IMG src="inspector-1.jpg" border=0 alt="Alice Inspector"></P>

<P>When you inspect additional values, they will be displayed in the same
Inspector window. The inspector can be used to browse arbitrary data
structures:</P>

<PRE class=code>
val r = ref 56
<I>val r : int ref = ref 56</I>
inspect (3 + 8, SOME Math.pi, {hello = "hello, world"}, r, [true, 4 < 3])
<I>val it : unit = ()</I></PRE>

<P align=center><IMG src="inspector-2.jpg" border=0 alt="Alice Inspector"></P>

<P class=note><EM>Note:</EM> If the size of the inspected data structure
exceeds certain configurable limits, parts of the output will be hidden. Those
parts are represented by arrows, which can be interactively unfolded if
desired.</P>

<P>The Inspector concurrently watches the data structures it shows. If they
change, it will notice it and update its display. For example, if you re-assign
a reference the Inspector window will be updated automatically:</P>

<PRE class=code>
r := 33033
<I>val it : unit = ()</I></PRE>

<P align=center><IMG src="inspector-3.jpg" border=0 alt="Alice Inspector"></P>

<!--
<PRE class=code>
val rec infiniteList = 1::infiniteList
<I>val infiniteList : int list =
   [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...]</I>
inspect infiniteList
<I>val it : unit = ()</I></PRE>

<PRE class=code>
inspect (Future.alarm (Time.fromMilliseconds 2000))
<I>val it : unit = ()</I></PRE>
-->


<?php section("laziness", "laziness") ?>

<P>While Standard ML is a fully eager (strict) language, Alice ML provides
support for optional lazy evaluation. Any expression can be evaluated lazily by
preceeding it with the <TT>lazy</TT> keyword:</P>

<PRE class=code>
val x = lazy 4+5
<I>val x : int = lazy</I></PRE>

<P>Lazy suspensions are represented by the <TT>lazy</TT> keyword in the
interpreter's output, as shown above. The value of <TT>x</TT> will not be
computed before it is actually required. For example,</P>

<PRE class=code>
(x,x)
<I>val it : int * int = (lazy, lazy)</I>
x
<I>val it : int = lazy</I>
x > 10
<I>val it : bool = false</I>
x
<I>val it : int = 9</I></PRE>

<P>Tupling is parametric in its components and does not trigger <TT>x</TT>. The
comparison operator <TT>></TT> is strict in its arguments, however, and hence
forces evaluation of <TT>x</TT>. Likewise, pattern matching, arithmetic
operations, comparison (<TT>op=</TT>) or similar operations can force a
value.</P>

<P>As a simple example of a lazy function, consider a generator for lazy
streams of numbers:</P>

<PRE class=code>
fun enum n = lazy n :: enum (n+1)
<I>val enum : int -> int list = fn</I>
val ns = enum 0
<I>val ns : int list = lazy</I>
List.nth (ns,5)
<I>val it : int = 5</I>
ns
<I>val it : int list = 0 :: 1 :: 2 :: 3 :: 4 :: 5 :: lazy</I></PRE>

<P>In this example, requesting the 5th element of the list forced partial
evaluation of the list, up to that element.</P>

<P>We can define a lazy variant of the <TT>map</TT> function:</P>

<PRE class=code>
fun mapy f xs = lazy (case xs of nil    => nil
                               | x::xs' => f x :: mapy f xs')
<I>val mapy : ('a -> 'b) -> 'a list -> 'b list = fn</I></PRE>

<P>Note that the <TT>case</TT> expression must be nested inside the
<TT>lazy</TT> expression - otherwise applying <TT>mapy</TT> would trigger
evaluation of the head of the list, to perform the necessary pattern matching.
Function declarations support syntactic sugar that allows expressing the same
definition more elegantly:</P>

<PRE class=code>
fun lazy mapz f nil     = nil
  |      mapz f (x::xs) = f x :: mapz f xs
<I>val mapz : ('a -> 'b) -> 'a list -> 'b list = fn</I></PRE>

<P>This derived form is defined such that both definitions of <TT>mapy</TT> are
equivalent. Let us apply <TT>mapy</TT> to the stream of natural numbers
to calculate their factorities lazily:</P>

<PRE class=code>
val facs = mapz fac (enum 0)
<I>val facs : int list = lazy</I>
List.take (facs,7)
<I>val it : int list = [1, 1, 2, 6, 24, 120, 720]</I>
facs
<I>val it : int list = 1 :: 1 :: 2 :: 6 :: 24 :: 120 :: 720 :: lazy</I></PRE>

<DIV class=note>
<P><EM>Note:</EM> The Inspector observes when lazy suspensions are triggered. If you
evaluate</P>

<PRE class=code>
inspect facs
<I>val it : unit = ()</I>
List.nth (facs,13)
<I></I></PRE>

<P>it will automatically update its window to reflect the substitution of the
lazy tail of <TT>facs</TT> by a (partial) list.</P>
</DIV>

<P>Here is a lazy version of the <TT>zip</TT> function:</P>

<PRE class=code>
fun lazy zipz (x::xs, y::ys) = (x,y) :: zipz (xs,ys)
  |      zipz       _        = nil
<I>val zipz : 'a list * 'b list -> ('a * 'b) list = fn</I></PRE>

<P>It is possible to calculate the stream of Fibonacci numbers using
<TT>mapz</TT> and <TT>zipz</TT>:</P>

<PRE class=code>
val rec fibs = 1 :: 1 :: (lazy mapz op+ (zipz (fibs, tl fibs)))
<I>val it : int list = 1 :: 1 :: lazy</I>
List.nth (fibs, 10)
<I>val it : int = 89</I>
fibs
<I>val it : int list =
   1 :: 1 :: 2 :: 3 :: 5 :: 8 :: 13 :: 21 :: 34 :: 55 :: 89 :: lazy</I></PRE>

<P>For more practical applications of laziness, see the standard literature
on lazy functional programming. Last but not least, note that Alice ML allows
laziness to be combined freely with side effects:</P>

<PRE class=code>
val n = lazy (print "Huhu!\n"; 13)
<I>val n : int = lazy</I>
n+1
<I>Huhu!
val it : int = 14</I></PRE>


<?php section("concurrency", "concurrency") ?>

<PRE class=code>
fun fib (0 | 1) = 1
  | fib n       = fib (n-1) + fib (n-2)
</PRE>

<PRE class=code>
spawn fib 30
</PRE>

<PRE class=code>
inspect (List.tabulate (30, fn i => spawn fib i))
</PRE>


<PRE class=code>
inspect f;
</PRE>

<PRE class=code>
Future.await f handle e => (Inspector.inspect e; 1);
</PRE>



<?php section("promises", "promises") ?>


<PRE class=code>
(* Promises and Futures *)

open Promise

signature PORT =
sig
    type 'a port

    val new: unit -> 'a port * 'a list
    val send: 'a port * 'a -> unit
    val close: 'a port -> unit
end
</PRE>

<PRE class=code>
structure Port :> PORT =
struct
    type 'a port = 'a list promise ref

    fun new () =
	let
	    val p = promise()
	in
	    (ref p, future p)
	end

    fun send (r, x) =
	let
	    val p' = promise()
	    val p = Ref.exchange (r, p')
	in
	    fulfill(p, x::future p')
	end

    fun close r = fulfill(!r, nil)
end
</PRE>

<PRE class=code>
val (p: int Port.port, xs) = Port.new ()

Inspector.inspect xs;

Port.send (p, 17);

Port.send (p, 7);
</PRE>


<PRE class=code>
inspect (Future.concur (fn () => Future.alarm (Time.fromMilliseconds 6000)));
</PRE>


<?php section("components", "components") ?>

<PRE class=code>
alicec MY_COMPONENT-sig.aml
alicec MyComponent.aml</PRE>

<PRE class=code>
import "/home/kornstae/stockhausen/doc/samples/MyComponent"
</PRE>

<PRE class=code>
import structure MyComponent from "/home/kornstae/stockhausen/doc/samples/MyComponent"
</PRE>

<PRE class=code>
Inspector.inspect (MyComponent.fak 7);
</PRE>


<?php section("packages", "packages") ?>

<PRE class=code>
(*
 * Packing and unpacking of a simple value.
 *)

structure PackVal   = Package.PackVal
structure UnpackVal = Package.UnpackVal

val  value = { a = 0,     b = "hello",   c = [4, 0, 2, 42] }
type ty    = { a : int,   b : string,    c : int list      }

structure P = PackVal(val x = value type t = ty)

Inspector.inspect P.package;

structure X = UnpackVal(val package = P.package type t = ty)
val value' = X.x

Inspector.inspect value';

structure X = UnpackVal(val package = P.package type t = int)
val value' = X.x
</PRE>


<PRE class=code>
(*
 * Packing and unpacking of a polymorphic function (via modules).
 * Type can be more specific at unpacking.
 *)

structure P          = Package.Pack(structure X = (val f = length)
				    signature S = (val f : 'a list -> int))

structure Length     = Package.Unpack(val package = P.package
				      signature S = (val f: 'a list -> int))
structure IntLength  = Package.Unpack(val package = P.package
				       signature S = (val f: int list -> int))
structure RealLength = Package.Unpack(val package = P.package
				      signature S = (val f: real list -> int))

structure _ =
    Package.Unpack(val package = P.package
		   signature S = (val f: real option -> int))   (* Mismatch *)

val _ = print("length [1,2,1] = " ^ Int.toString(Length.f [1,2,1]) ^ "\n")
val _ = print("length [3,0] = " ^ Int.toString(IntLength.f [3,0]) ^ "\n")

val _ = print("length [1,2,1] = " ^ Int.toString(RealLength.f [1,2,1]) ^ "\n")
</PRE>


<PRE class=code>
(*
 * Packing a datatype.
 *)

signature I =
sig
    datatype t = A | B of int
    val x: t
end

structure Y =
struct
    datatype t = A | B of int
    val x = B 5
end

structure P = Package.Pack(structure X = Y
			   signature S = I)

datatype t = A | B of int

structure Z = Package.Unpack(val package = P.package
			     signature S = sig val x: t end)

Inspector.inspect Z.x;
</PRE>


<?php section("pickling", "pickling") ?>

<PRE class=code>
(*
 * Pickling and unpickling of an abstract type.
 * The unpickled type is compatible with the original one.
 *)

signature NUM =
    sig
	type t
	fun fromInt : int -> t
	fun toInt : t -> int
	fun add : t * t -> t
    end

structure Num :> NUM =
    struct
	type t = int
	fun toInt n   = n
	fun fromInt n = n
	val add       = op+
    end

val file = "Num." ^ Pickle.extension
structure  _ = Pickle.Save(val file = file
			   structure X = Num
			   signature S = NUM where type t = Num.t)

structure Num' = Pickle.Load(val file = file
			     signature S = NUM where type t = Num.t)
structure Num'' = Pickle.Load(val file = file
			      signature S = NUM)

Num'.add(Num'.fromInt 1, Num.fromInt 2);

Num''.add(Num''.fromInt 1, Num.fromInt 2); (* error *)
</PRE>

<PRE class=code>
(*
 * Pickling of functors.
 *)

val file = "Hello." ^ Pickle.extension

functor MkHello(val who : string) =
    struct
	val s = "Hello " ^ who ^ "!\n"
    end

signature MK_HELLO = fct(val who : string) -> sig val s : string end

structure _        = Pickle.Save(val file = file
				 structure X = MkHello
				 signature S = MK_HELLO)
structure MkHello' = Pickle.Load(val file = file signature S = MK_HELLO)

structure Hello    = MkHello'(val who = "World")
val       _        = print(Hello.s)
</PRE>


<PRE class=code>
(*
 * Pickling of signatures.
 * Signatures are first-class and can be pickled.
 * We can load pickles with statically unknown signatures.
 *)

val sigfile = "Sig." ^ Pickle.extension
val modfile = "Mod." ^ Pickle.extension

signature T      = fct(_ : any) -> sig    type t       end
structure X :> T = fct(_ : any) => struct type t = int end

structure  _  = Pickle.Save(val file = modfile
structure X = X signature S = T)

structure  _  = Pickle.Save(val file = sigfile
			    structure X = (signature U = T)
			    signature S = (signature U))
structure Sig = Pickle.Load(val file = sigfile
			    signature S = (signature U))
structure Mod = Pickle.Load(val file = modfile
			    signature S = Sig.U)
</PRE>

<PRE class=code>
(*
 * Components are pickles and vice versa!
 *
 * Loading a component as a pickle will execute it and return the
 * component's content as a structure.
 * A structure pickle can be used as a component. It is a special case of
 * a component because its content is completely evaluated.
 * Note that unpickling an evaluated component produces new abstract
 * types! (so Url'.Url.t below is incompatible to the lib's Url.t)
 *)

val file = "Url." ^ Pickle.extension
val comp = "x-alice:/lib/system/" ^ file

import signature URL from "x-alice:/lib/system/URL-sig"

structure Url' = Pickle.Load(val file = comp
			     signature S = (structure Url : URL))

val _ = print(Url'.Url.toString(Url'.Url.fromString comp) ^ "\n")

structure _ = Pickle.Save(val file = file
			  structure X = Url'
			  signature S = (structure Url : URL))

import "/home/kornstae/stockhausen/doc/samples/Url"
</PRE>


<?php section("distribution", "distribution") ?>


<?php section("constraints", "constraints") ?>

<P>Alice ML provides full support for state-of-the-art constraint programming
technology. Constraint-based problem solving is a technique for solving hard
combinatorial problems that can be stated as variables ranging over a finite
domain of non-negative integers, or sets thereof. Problems in this class range
from puzzles to real world applications as diverse as scheduling, ware house
allocation, configuration and placement.</P>

<P>Let us take a first look at programming with <I>finite domain</I>
constraints. A finite domain (FD) is a set of natural (non-negative integer)
numbers. An FD <I>constraint</I> is a formula in predicate logic, containing
variables ranging over the natural numbers. In particular, a domain constraint
is a constraint that restricts the domain of a particular variable. A
<I>finite domain problem</I> is a finite set of quantifier-free constraints
that contains a domain constraint for every variable occurring in it. A
<I>solution</I> is a variable assignment that satisfies every constraint of the
problem.</P>

<P>Let us create some finite domain variables. We use the <A
href="library/linear.html"><TT>Linear</TT></A> library for linear
constraints:</P>

<PRE class=code>
open Linear
<I>### loaded signature from x-alice:/lib/constraints/Linear
...</I></PRE>

<P>To create a vector of constraint variables <I>x</I>,<I>y</I>,<I>z</I>, the
<TT>vec</TT> function can be used:</P>

<PRE class=code>
val #[x,y,z] = vec (3, [1`#10])
<I>val x : term = fd (val)
val y : term = fd (val)
val z : term = fd (val)</I></PRE>

<P>The arguments to <TT>vec</TT> specify the number of constraint variables
(the size of the vector) and the initial domain {1,...,10} of each of these
variable. Every constraint variable must be created specifying such a domain
constraint. Constraint variables can be investigated using the Inspector:</P>

<PRE class=code>
inspect {x,y,z}
<I>val it : unit = ()</I></PRE>

<P align=center><IMG src="inspector-fd-1.jpg" border=0 alt="Alice Inspector"></P>

<P>For each variable, the Inspector shows the current set of values that still
might form a solution. The set of values still considered for a variable is
called its domain. Since we have not yet posted any constraints, the domains
are given by the initial domain constraints on the variables. The set of all
constraint variables and their domains is called the <I>constraint
store</I>.</P>

<P>The solution set can be restricted by posting constraints. For example, we
can require that 2<I>x</I> = <I>y</I>:</P>

<PRE class=code>
post (`2 `* x `= y)
<I>val it : unit = ()</I></PRE>

<P class=note><EM>Note:</EM> Be aware of the backquotes prefixing numbers and
operators in the constraint formula - <TT>`*</TT> and <TT>`=</TT> are infix
functions, while the backquote preceeding the literal <TT>2</TT> is an ordinary
nonfix function.</P>

<P>The posted constraint will exclude certain values from the solution set.
This is reflected by shrinking the domains of the respective constraint
variables. After posting the above constraint, the Inspector recognizes that
the domains of the displayed constraint variables have changed and updates its
display accordingly:</P>

<P align=center><IMG src="inspector-fd-2.jpg" border=0 alt="Alice Inspector"></P>

<P>Adding a constraint can affect the domain of variables that do not even
occur in its formula, because information will be <I>propagated</I> in the
constraint store so that additional information can be inferred in combination
with other posted constraints:</P>

<PRE class=code>
post (z `< x)
<I>val it : unit = ()</I></PRE>

<P align=center><IMG src="inspector-fd-3.jpg" border=0 alt="Alice Inspector"></P>

<PRE class=code>
post (y `< `7)
<I>val it : unit = ()</I></PRE>

<P align=center><IMG src="inspector-fd-4.jpg" border=0 alt="Alice Inspector"></P>

<P>The information encapsulated in the constraint store grows monotonically. A
variable is determined if its domain is reduced to a singleton set. A solution
is found when all variables are determined.</P>

<PRE class=code>
post (z `<> `1)
<I>val it : unit = ()</I></PRE>

<P align=center><IMG src="inspector-fd-5.jpg" border=0 alt="Alice Inspector"></P>

<P>Constraint propagation is not a complete solution method. It may happen that
a problem has a unique solution and that constraint propagation does not find
it. In those cases it is necessary to combine constraint propagation with
search. Alice hence also provides support for powerful, user-definable search
techniques. For a more thorough introduction to constraint programming, we
refer to the Oz <A href="http://www.mozart-oz.org/documentation/fdt/">Finite
Domain Constraint Programming Tutorial</A>. All constraint programming
functionality from Oz is available in Alice.</P>

<P>As a simple example of a complete program solving a finite domain problem,
consider the <I>Send More Money</I> problem. It consists in finding distinct
digits for the letters <TT>S</TT>, <TT>E</TT>, <TT>N</TT>, <TT>D</TT>,
<TT>M</TT>, <TT>O</TT>, <TT>R</TT>, <TT>Y</TT> such that <TT>S</TT> and
<TT>M</TT> are different from zero (no leading zeros) and the equation

<PRE class=code>
SEND + MORE = MONEY</PRE>

<P>is satisfied. The unique solution of the problem is <TT>9567 + 1085 =
10652</TT>.</P>

<P>Using Alice, the problem can be solved as follows. First, we have to define
a so-called <I>script</I> that encodes the problem:</P>

<PRE class=code>
fun money () =
let
    val v as #[S,E,N,D,M,O,R,Y] = vec (8, [0`#9])
in
    distinct v; 
    post (S `<> `0); 
    post (M `<> `0); 
    post (`1000`*S `+ `100`*E `+ `10`*N `+ D `+
	  `1000`*M `+ `100`*O `+ `10`*R `+ E `=
          `10000`*M `+ `1000`*O `+ `100`*N `+ `10`*E `+ Y ); 
    distribute (FD.FIRSTFAIL, v); 
    {S,E,N,D,M,O,R,Y}
end
<I>val money :
   unit -> {D : term, E : term, M : term, N : term, O : term, R : term, S : term, Y : term} = fn</I></PRE>

<P>The Send More Money problem cannot be solved using constraint propagation
alone. Search is required to reduce the problem space until constraint
propagation is able to determine the solution. The <TT>distribute</TT> function
in the script specifies the <I>distribution strategy</I> used when the problem
space has to be split for search. See the Mozart <A
href="http://www.mozart-oz.org/documentation/fdt/">Constraint Programming
Tutorial</A> for more detail.</P>

<P>To perform the actual search and obtain all solutions to the problem,
predefined search engines can be used:</P>

<PRE class=code>
Search.searchAll money
<I>val it :
   {D : term, E : term, M : term, N : term, O : term, R : term, S : term, Y : term} list =
   [{Y = fd (val), S = fd (val), R = fd (val), O = fd (val), N = fd (val),
     M = fd (val), E = fd (val), D = fd (val)}]</I></PRE>

<P>Using the inspector, we can easily look at the solution:</P>

<PRE class=code>
inspect it
<I>val it : unit = ()</I></PRE>

<P align=center><IMG src="inspector-fd-6.jpg" border=0 alt="Alice Inspector"></P>

<P>An alternative way to obtain the solutions is by interactively exploring the
search tree induced by the script using the <A
href="library/explorer.html"><EM>Explorer</EM></A>:</P>

<PRE class=code>
Explorer.exploreAll money
<I>val it : unit = ()</I></PRE>

<P align=center><IMG src="explorer.jpg" border=0 alt="Alice Explorer"></P>

<P>Clicking on the only solution node in the tree (the green one) will open an
Inspector window displaying the variable assignment of the solution.</P>


<?php section("interop", "interoperability") ?>


<?php footing() ?>
