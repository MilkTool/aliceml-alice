<?php include("macros.php3"); ?>
<?php heading("A Short Tour of Alice", "A Short Tour of Alice") ?>


<?php section("overview", "overview") ?>

<P>This page is meant as a short introduction to the Alice language and system
and its features:</P>

<UL>
  <LI><A href="#sml">Standard ML compatibility</A></LI>
  <LI><A href="#interactive">Interactive use</A>: evaluating declarations and
  browsing results</LI>
  <LI><A href="#laziness">Laziness</A>: transparent lazy evaluation on demand</LI>
  <LI><A href="#concurrency">Concurrency</A>: threads and data-flow
  synchronistation</LI>
  <LI><A href="#promises">Promises</A>: </LI>
  <LI><A href="#components">Components</A>: platform independence and
  lazy dynamic linking</LI>
  <LI><A href="#packages">Packages</A>: dynamic typing and first-class modules</LI>
  <LI><A href="#pickling">Pickling</A>: platform independent persistence</LI>
  <LI><A href="#distribution">Distribution</A>: </LI>
  <LI><A href="#constraints">Constraint Programming</A>: </LI>
  <LI><A href="#interop">Interoperability</A>: working hand in hand with Oz
  programs</LI>
</UL>


<?php section("sml", "standard ML") ?>

<P>Alice ML is an extension of the
<A href="http://cm.bell-labs.com/cm/cs/what/smlnj/sml.html">Standard ML</A> language (SML).
Most of the examples shown here assume a working knowledge of functional
programming in general and SML in particular. There are numerous
books and tutorials available for SML.</P>

<P>Online Material:</P>

<UL>
  <LI><A href="http://www-2.cs.cmu.edu/People/rwh/introsml/">Programming in
  Standard ML</A>, by Robert Harper, CMU</LI>
  <LI><A href="http://www.dcs.ed.ac.uk/home/stg/NOTES/">Programming in Standard
  ML '97: An Online Tutorial</A>, by Stephen Gilmore, University of
  Edinburgh</LI>
</UL>

<P>Paper Books:</P>

<UL>
  <LI><A href="http://www.cl.cam.ac.uk/users/lcp/MLbook/">ML for the Working
  Programmer</A> (2nd edition), by Larry Paulson. Cambridge University
  Press</LI>
  <LI><A href="http://www-db.stanford.edu/~ullman/emlp.html">Elements of ML
  Programming</A> (ML'97 edition), by Jeffrey Ullmann. Prentice-Hall</LI>
</UL>

<P>The definition of the language and its library can be found here:</P>

<UL>
  <LI><A href="http://mitpress.mit.edu/book-home.tcl?isbn=0-262-63181-4">The
  Definition of Standard ML</A> (Revised), by Robin Milner, Mads Tofte,
  Robert Harper, Dave MacQueen. The MIT Press</LI>
  <LI><A href="http://SML.sourceforge.net/Basis/">The Standard ML
  Basis Library</A> (Preliminary), by John Reppy and Emden Gansner.</LI>
</UL>

<P>For a more comprehensive literature list, see the
<A href="http://www.smlnj.org/doc/literature.html#tutorials">bibliography</A>
on the SML/NJ site.</P>


<?php section("interactive", "interactive toplevel") ?>

<P>Alice ML is an extension of Standard ML, and the Alice
<A href="interactive.html">interactive toplevel</A>
functions very similar to the interactive prompts known from other SML
systems where you can type in expressions and declarations to evaluate them.
Input is terminated with a semicolon. For example, you might simply perform a
simple calculation:</P>

<PRE class=code>
- 4+5;
<I>val it : int = 9</I></PRE>

<P>The expression is evaluated and the result <TT>9</TT> printed along with
its inferred type <TT>int</TT>. Anonymous expressions get the name <TT>it</TT>,
so that you can refer to them in consecutive inputs:</P>

<PRE class=code>
- 2*it;
<I>val it : int = 18</I></PRE>

<P>We can also try the one-line Hello World program:</P>

<PRE class=code>
- print "Hello world!\n";
<I>Hello world!
val it : unit = ()</I></PRE>

<P>In the rest of this tour we will present program fragments in their pure
form, without showing the interpreter prompt or the semicolon terminating the
interactive input. For example, the last interaction will be displayed simply
as</P>

<PRE class=code>
print "Hello world!\n"
<I>Hello world!
val it : unit = ()</I></PRE>

<P>Entering a function declaration is more interesting. For example,
the factority function:<P>

<PRE class=code>
fun fac 0 = 1
  | fac n = n * fac (n-1)
<I>val fac : int -> int = fn</I></PRE>

<P>This time, the result has a more complex type: it is a function from
integers to integers. We can apply that function:</P>

<PRE class=code>
fac 50
<I>val it : int = 30414093201713378043612608166064768844377641568960512000000000000</I></PRE>

<P>For more complex values, the static output of the result is often
insufficient. The Alice system includes the <A
href="library/inspector.html"><EM>Inspector</EM></A> for browsing arbitrary data
structures interactively:</P>

<PRE class=code>
inspect (List.tabulate (10, fn i => (i, i*i, i*i*i)))
<I>val it : unit = ()</I></PRE>

<P>An Inspector window will pop up displaying the table of the first hundred
square and cubic numbers:</P>

<P align=center><IMG src="inspector-1.jpg" border=0 alt="Alice Inspector"></P>

<P>When you inspect additional values, they will be displayed in the same
Inspector window. The inspector can be used to browse arbitrary data
structures:</P>

<PRE class=code>
val r = ref 56
<I>val r : int ref = ref 56</I>
inspect (3 + 8, SOME Math.pi, {hello = "hello, world"}, r, [true, 4 < 3])
<I>val it : unit = ()</I></PRE>

<P align=center><IMG src="inspector-2.jpg" border=0 alt="Alice Inspector"></P>

<P class=note><EM>Note:</EM> If the size of the inspected data structure
exceeds certain configurable limits, parts of the output will be hidden. Those
parts are represented by arrows, which can be interactively unfolded if
desired.</P>

<P>The Inspector concurrently watches the data structures it shows. If they
change, it will notice it and update its display. For example, if you re-assign
a reference the Inspector window will be updated automatically:</P>

<PRE class=code>
r := 33033
<I>val it : unit = ()</I></PRE>

<P align=center><IMG src="inspector-3.jpg" border=0 alt="Alice Inspector"></P>

<!--
<PRE class=code>
val rec infiniteList = 1::infiniteList
<I>val infiniteList : int list =
   [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...]</I>
inspect infiniteList
<I>val it : unit = ()</I></PRE>

<PRE class=code>
inspect (Future.alarm (Time.fromMilliseconds 2000))
<I>val it : unit = ()</I></PRE>
-->


<?php section("laziness", "laziness") ?>

<P>While Standard ML is a fully eager (strict) language, Alice ML provides
support for optional lazy evaluation. Any expression can be evaluated lazily by
preceeding it with the <TT>lazy</TT> keyword:</P>

<PRE class=code>
val x = lazy 4+5
<I>val x : int = lazy</I></PRE>

<P>Lazy suspensions are represented by the <TT>lazy</TT> keyword in the
interpreter's output, as shown above. The value of <TT>x</TT> will not be
computed before it is actually required. For example,</P>

<PRE class=code>
(x,x)
<I>val it : int * int = (lazy, lazy)</I>
x
<I>val it : int = lazy</I>
x > 10
<I>val it : bool = false</I>
x
<I>val it : int = 9</I></PRE>

<P>Tupling is parametric in its components and does not trigger <TT>x</TT>. The
comparison operator <TT>></TT> is strict in its arguments, however, and hence
forces evaluation of <TT>x</TT>. Likewise, pattern matching, arithmetic
operations, comparison (<TT>op=</TT>) or similar operations can force a
value.</P>

<P>As a simple example of a lazy function, consider a generator for lazy
streams of numbers:</P>

<PRE class=code>
fun enum n = lazy n :: enum (n+1)
<I>val enum : int -> int list = fn</I>
val ns = enum 0
<I>val ns : int list = lazy</I>
List.nth (ns,5)
<I>val it : int = 5</I>
ns
<I>val it : int list = 0 :: 1 :: 2 :: 3 :: 4 :: 5 :: lazy</I></PRE>

<P>In this example, requesting the 5th element of the list forced partial
evaluation of the list, up to that element.</P>

<P>We can define a lazy variant of the <TT>map</TT> function:</P>

<PRE class=code>
fun mapz f xs = lazy (case xs of nil    => nil
                               | x::xs' => f x :: mapz f xs')
<I>val mapz : ('a -> 'b) -> 'a list -> 'b list = fn</I></PRE>

<P>Note that the <TT>case</TT> expression must be nested inside the
<TT>lazy</TT> expression - otherwise applying <TT>mapz</TT> would trigger
evaluation of the head of the list, to perform the necessary pattern matching.
Function declarations support syntactic sugar that allows expressing the same
definition more elegantly:</P>

<PRE class=code>
fun lazy mapz f nil     = nil
  |      mapz f (x::xs) = f x :: mapz f xs
<I>val mapz : ('a -> 'b) -> 'a list -> 'b list = fn</I></PRE>

<P>This derived form is defined such that both definitions of <TT>mapz</TT> are
equivalent. Let us apply <TT>mapz</TT> to the stream of natural numbers
to calculate their factorities lazily:</P>

<PRE class=code>
val facs = mapz fac (enum 0)
<I>val facs : int list = lazy</I>
List.take (facs,7)
<I>val it : int list = [1, 1, 2, 6, 24, 120, 720]</I>
facs
<I>val it : int list = 1 :: 1 :: 2 :: 6 :: 24 :: 120 :: 720 :: lazy</I></PRE>

<DIV class=note>
<P><EM>Note:</EM> The Inspector observes when lazy suspensions are triggered. If you
evaluate</P>

<PRE class=code>
inspect facs
<I>val it : unit = ()</I>
List.nth (facs,13)
<I></I></PRE>

<P>it will automatically update its window to reflect the substitution of the
lazy tail of <TT>facs</TT> by a (partial) list.</P>
</DIV>

<P>Here is a lazy version of the <TT>zip</TT> function:</P>

<PRE class=code>
fun lazy zipz (x::xs, y::ys) = (x,y) :: zipz (xs,ys)
  |      zipz       _        = nil
<I>val zipz : 'a list * 'b list -> ('a * 'b) list = fn</I></PRE>

<P>It is possible to calculate the stream of Fibonacci numbers using
<TT>mapz</TT> and <TT>zipz</TT>:</P>

<PRE class=code>
val rec fibs = 1 :: 1 :: (lazy mapz op+ (zipz (fibs, tl fibs)))
<I>val it : int list = 1 :: 1 :: lazy</I>
List.nth (fibs, 10)
<I>val it : int = 89</I>
fibs
<I>val it : int list =
   1 :: 1 :: 2 :: 3 :: 5 :: 8 :: 13 :: 21 :: 34 :: 55 :: 89 :: lazy</I></PRE>

<P>For more practical applications of laziness, see the standard literature
on lazy functional programming. Last but not least, note that Alice ML allows
laziness to be combined freely with side effects:</P>

<PRE class=code>
val n = lazy (print "Huhu!\n"; 13)
<I>val n : int = lazy</I>
n+1
<I>Huhu!
val it : int = 14</I></PRE>


<?php section("concurrency", "concurrency") ?>

<P>Alice extends SML with support for concurrency. Concurrency is light-weight:
the system can handle tens or hundreds of thousands of concurrent threads.
Concurrent programming in Alice is uniformly based on the model of
<EM>futures</EM>.</P>

<P>A concurrent thread can be initiated by means of the <TT>spawn</TT>
expression:</P>

<PRE class=code>
spawn 45*68
<I>val it : int = future</I></PRE>

<P>In this example the value 45*68 is computed in a new thread. The result of
the <TT>spawn</TT> expression is a <EM>future</EM>, a place-holder for the
result of the concurrent computation. Once the result becomes available, the
future will be globally replaced by the result. We say that threads are
functional, in the sense that they have a result. That semantics becomes more
obvious if we look at a thread that does not terminate immediately. For that
purpose, let us define the naive version of the Fibonacci function, which has
exponential complexity:</P>

<PRE class=code>
fun fib (0 | 1) = 1
  | fib n       = fib (n-1) + fib (n-2)
<I>val fib : int -> int = fn</I></PRE>

<P>On an ordinary desktop PC, computing <TT>fib 35</TT> will take quite some
time. We perform that computation concurrently:</P>

<PRE class=code>
val n = spawn fib 35
<I>val n : int = future</I></PRE>

<P>We get back a future, that we can look at using the Inspector:</P>

<PRE class=code>
inspect n
<I>val it : unit = ()</I></PRE>

<P align=center><IMG src="inspector-conc-1.jpg" border=0 alt="Alice Inspector"></P>

<P>At first, the Inspector will display the value as a future, as shown above.
Once the computation of the result finishes and the thread terminates, that
future gets replaced by the thread's result. The Inspector will update its
display accordingly:</P>

<P align=center><IMG src="inspector-conc-2.jpg" border=0 alt="Alice Inspector"></P>

<P>The situation becomes more interesting if we start several threads at
once:</P>

<PRE class=code>
inspect (List.tabulate (10, fn i => spawn fib (i+25)))
<I>val it : unit = ()</I></PRE>

<P>The individual entries from the small table we build are calculated
concurrently and become available individually. At some point in time the
Inspector window might display the following:</P>

<P align=center><IMG src="inspector-conc-3.jpg" border=0 alt="Alice Inspector"></P>

<P>Futures can be passed around like ordinary values. Once an operation
actually <EM>requests</EM> the value the future stands for, the corresponding
thread will block until the future vanishes. This is known as <EM>data-flow
synchronisation</EM> and is a powerful mechanism for high-level concurrent
programming. As a trivial example, consider the following pair of concurrent
producer and consumer that are connected through a message stream:</P>

<PRE class=code>
fun produce 0 = []
  | produce n = spawn (Thread.sleep (Time.fromSeconds 2); n :: produce (n-1))
<I>val produce : int -> int list = fn</I>
fun consume (n::ns) = (print (Int.toString n ^ "\n"); consume ns)
  | consume   nil   = ()
<I>val consume : int list -> 'a = fn</I>
spawn consume (produce 5)
<I>val it : unit = future
5
4
3
2
1</I></PRE>

<!-- TODO: Reference? -->

<P>What happens if a concurrent computation fails, e.g. by raising an exception?
In that case the future will be <EM>failed</EM>. A failed future carries an
exception indicating the cause of the failure. A failed future does not cause
failure of a client by itself. Only when a client actually requests the failed
future, the failure exception will be re-raised at the point of request:</P>

<PRE class=code>
spawn (raise Domain)
<I>val it : 'a = future</I>
[it]
<I>val it : 'a list = [raise]</I>
hd it + 1
<I>uncaught exception Domain</I></PRE>

<P>In the second output, the interpreter uses the keyword <TT>raise</TT> to
indicate a failed future.</P>

<P>See the <A href="futures.html">manual page</A> on futures for a detailed
discussion of concurrency, futures, and failure.</P>



<?php section("promises", "promises") ?>


<PRE class=code>
(* Promises and Futures *)

open Promise

signature PORT =
sig
    type 'a port

    val new: unit -> 'a port * 'a list
    val send: 'a port * 'a -> unit
    val close: 'a port -> unit
end
</PRE>

<PRE class=code>
structure Port :> PORT =
struct
    type 'a port = 'a list promise ref

    fun new () =
	let
	    val p = promise()
	in
	    (ref p, future p)
	end

    fun send (r, x) =
	let
	    val p' = promise()
	    val p = Ref.exchange (r, p')
	in
	    fulfill(p, x::future p')
	end

    fun close r = fulfill(!r, nil)
end
</PRE>

<PRE class=code>
val (p: int Port.port, xs) = Port.new ()

Inspector.inspect xs;

Port.send (p, 17);

Port.send (p, 7);
</PRE>


<?php section("packages", "packages") ?>

<P>Its powerful static type system is one of the major pros of ML. However,
there are programming tasks where it is not possible to perform all typing
statically. For example, consider exchange of data structures between separate
processes. To accompony such tasks of <EM>open programming</EM>, Alice
complements its static type system with a controlled form of dynamic
typing.</P>

<P>Alice provides the type <TT>package</TT> of dynamically typed values. A
<EM>package</EM> essentially is a pair of a (higher-order) module and its
signature. Packages are created using the <TT>pack</TT> expression:</P>

<PRE class=code>
val p = pack Word8 :> WORD
<I>val p : package = package{|...|}</I></PRE>

<P>This example injects the module <TT>Word8</TT> into a package. The signature
constraint (the part following the <TT>:></TT>) is part of the pack expression.
It specifies the package's signature. The packaged module must of course match
that signature statically.<P>

<!--
<P>Using the Inspector, we can look inside the package:</P>
-->

<P>The package <TT>p</TT> may be passed to some client, which may unpack it as
follows:</P>

<PRE class=code>
structure Word' = unpack p : WORD
<I>structure Word' : WORD</I></PRE>

<P>The <TT>unpack</TT> expression also requires a signature being specified.
Unpacking involves a dynamic type check: to evaluate the expression, the
package signature is matched against the specified target signature. If
matching succeeds, the packaged module is returned. Otherwise, an exception is
raised:</P>

<PRE class=code>
structure List' = unpack p : LIST
<I>uncaught exception Mismatch</I></PRE>

<P>If unpacking succeeds, the client may use the <TT>Word'</TT> structure as
usual. The static signature of <TT>Word'</TT> is determined by the target
signature specified with <TT>unpack</TT>.</P>

<P>Since modules can contain arbitrary values, any value can be wrapped up as
packages. In particular, values can be given polymorphic type in packages:</P>

<PRE class=code>
val p = pack (val x = length) :> (val x : 'a list -> int)
<I>val p : package = package{|...|}</I></PRE>

<P class=note>This example uses some <A href="modules.html#sugar">syntactic
sugar</A> of Alice ML, which allows replacing <TT>struct</TT>...<TT>end</TT>
and <TT>sig</TT>...<TT>end</TT> by <TT>(</TT>...<TT>)</TT>.</P>

<P>Unpacking may specify a more restrictive target signature:</P>

<PRE class=code>
structure IntLength = unpack p : (val x : int list -> int)
<I>structure IntLength : sig val x : int list -> int end</I>
structure RealLength = unpack p : (val x : real list -> int)
<I>structure RealLength : sig val x : real list -> int end</I></PRE>

<P>The whole range of SML signature matching rules applies, so a package may
have more components than required by the target signature, may have more
general value types, or more specific type components, etc. Using packages
hence is quite robust with respect to extensions.</P>

<P>See the respective <A href="packages.html">manual page</A> for a more
detailed look at the semantics of packages. Packages are the basis of several
other features of Alice, in particular <A href="#pickling">pickling</A> and <A
href="#distribution">distribution</A>.</P>


<?php section("pickling", "pickling") ?>

<PRE class=code>
(*
 * Pickling and unpickling of an abstract type.
 * The unpickled type is compatible with the original one.
 *)

signature NUM =
    sig
	type t
	fun fromInt : int -> t
	fun toInt : t -> int
	fun add : t * t -> t
    end

structure Num :> NUM =
    struct
	type t = int
	fun toInt n   = n
	fun fromInt n = n
	val add       = op+
    end

val file = "Num." ^ Pickle.extension
structure  _ = Pickle.Save(val file = file
			   structure X = Num
			   signature S = NUM where type t = Num.t)

structure Num' = Pickle.Load(val file = file
			     signature S = NUM where type t = Num.t)
structure Num'' = Pickle.Load(val file = file
			      signature S = NUM)

Num'.add(Num'.fromInt 1, Num.fromInt 2);

Num''.add(Num''.fromInt 1, Num.fromInt 2); (* error *)
</PRE>

<PRE class=code>
(*
 * Pickling of functors.
 *)

val file = "Hello." ^ Pickle.extension

functor MkHello(val who : string) =
    struct
	val s = "Hello " ^ who ^ "!\n"
    end

signature MK_HELLO = fct(val who : string) -> sig val s : string end

structure _        = Pickle.Save(val file = file
				 structure X = MkHello
				 signature S = MK_HELLO)
structure MkHello' = Pickle.Load(val file = file signature S = MK_HELLO)

structure Hello    = MkHello'(val who = "World")
val       _        = print(Hello.s)
</PRE>


<PRE class=code>
(*
 * Pickling of signatures.
 * Signatures are first-class and can be pickled.
 * We can load pickles with statically unknown signatures.
 *)

val sigfile = "Sig." ^ Pickle.extension
val modfile = "Mod." ^ Pickle.extension

signature T      = fct(_ : any) -> sig    type t       end
structure X :> T = fct(_ : any) => struct type t = int end

structure  _  = Pickle.Save(val file = modfile
structure X = X signature S = T)

structure  _  = Pickle.Save(val file = sigfile
			    structure X = (signature U = T)
			    signature S = (signature U))
structure Sig = Pickle.Load(val file = sigfile
			    signature S = (signature U))
structure Mod = Pickle.Load(val file = modfile
			    signature S = Sig.U)
</PRE>


<?php section("components", "components") ?>

<PRE class=code>
alicec MY_COMPONENT-sig.aml
alicec MyComponent.aml</PRE>

<PRE class=code>
import "/home/kornstae/stockhausen/doc/samples/MyComponent"
</PRE>

<PRE class=code>
import structure MyComponent from "/home/kornstae/stockhausen/doc/samples/MyComponent"
</PRE>

<PRE class=code>
Inspector.inspect (MyComponent.fak 7);
</PRE>

<PRE class=code>
(*
 * Components are pickles and vice versa!
 *
 * Loading a component as a pickle will execute it and return the
 * component's content as a structure.
 * A structure pickle can be used as a component. It is a special case of
 * a component because its content is completely evaluated.
 * Note that unpickling an evaluated component produces new abstract
 * types! (so Url'.Url.t below is incompatible to the lib's Url.t)
 *)

val file = "Url." ^ Pickle.extension
val comp = "x-alice:/lib/system/" ^ file

import signature URL from "x-alice:/lib/system/URL-sig"

structure Url' = Pickle.Load(val file = comp
			     signature S = (structure Url : URL))

val _ = print(Url'.Url.toString(Url'.Url.fromString comp) ^ "\n")

structure _ = Pickle.Save(val file = file
			  structure X = Url'
			  signature S = (structure Url : URL))

import "/home/kornstae/stockhausen/doc/samples/Url"
</PRE>


<?php section("distribution", "distribution") ?>



<?php section("constraints", "constraints") ?>

<P>Alice ML provides full support for state-of-the-art constraint programming
technology. Constraint-based problem solving is a technique for solving hard
combinatorial problems that can be stated as variables ranging over a finite
domain of non-negative integers, or sets thereof. Problems in this class range
from puzzles to real world applications as diverse as scheduling, ware house
allocation, configuration and placement.</P>

<P>Let us take a first look at programming with <I>finite domain</I>
constraints. A finite domain (FD) is a set of natural (non-negative integer)
numbers. An FD <I>constraint</I> is a formula in predicate logic, containing
variables ranging over the natural numbers. In particular, a domain constraint
is a constraint that restricts the domain of a particular variable. A
<I>finite domain problem</I> is a finite set of quantifier-free constraints
that contains a domain constraint for every variable occurring in it. A
<I>solution</I> is a variable assignment that satisfies every constraint of the
problem.</P>

<P>Let us create some finite domain variables. We use the <A
href="library/linear.html"><TT>Linear</TT></A> library for linear
constraints:</P>

<PRE class=code>
open Linear
<I>### loaded signature from x-alice:/lib/constraints/Linear
...</I></PRE>

<P>To create a vector of constraint variables <I>x</I>,<I>y</I>,<I>z</I>, the
<TT>vec</TT> function can be used:</P>

<PRE class=code>
val #[x,y,z] = vec (3, [1`#10])
<I>val x : term = fd (val)
val y : term = fd (val)
val z : term = fd (val)</I></PRE>

<P>The arguments to <TT>vec</TT> specify the number of constraint variables
(the size of the vector) and the initial domain {1,...,10} of each of these
variable. Every constraint variable must be created specifying such a domain
constraint. Constraint variables can be investigated using the Inspector:</P>

<PRE class=code>
inspect {x,y,z}
<I>val it : unit = ()</I></PRE>

<P align=center><IMG src="inspector-fd-1.jpg" border=0 alt="Alice Inspector"></P>

<P>For each variable, the Inspector shows the current set of values that still
might form a solution. The set of values still considered for a variable is
called its domain. Since we have not yet posted any constraints, the domains
are given by the initial domain constraints on the variables. The set of all
constraint variables and their domains is called the <I>constraint
store</I>.</P>

<P>The solution set can be restricted by posting constraints. For example, we
can require that 2<I>x</I> = <I>y</I>:</P>

<PRE class=code>
post (`2 `* x `= y)
<I>val it : unit = ()</I></PRE>

<P class=note><EM>Note:</EM> Be aware of the backquotes prefixing numbers and
operators in the constraint formula - <TT>`*</TT> and <TT>`=</TT> are infix
functions, while the backquote preceeding the literal <TT>2</TT> is an ordinary
nonfix function.</P>

<P>The posted constraint will exclude certain values from the solution set.
This is reflected by shrinking the domains of the respective constraint
variables. After posting the above constraint, the Inspector recognizes that
the domains of the displayed constraint variables have changed and updates its
display accordingly:</P>

<P align=center><IMG src="inspector-fd-2.jpg" border=0 alt="Alice Inspector"></P>

<P>Adding a constraint can affect the domain of variables that do not even
occur in its formula, because information will be <I>propagated</I> in the
constraint store so that additional information can be inferred in combination
with other posted constraints:</P>

<PRE class=code>
post (z `< x)
<I>val it : unit = ()</I></PRE>

<P align=center><IMG src="inspector-fd-3.jpg" border=0 alt="Alice Inspector"></P>

<PRE class=code>
post (y `< `7)
<I>val it : unit = ()</I></PRE>

<P align=center><IMG src="inspector-fd-4.jpg" border=0 alt="Alice Inspector"></P>

<P>The information encapsulated in the constraint store grows monotonically. A
variable is determined if its domain is reduced to a singleton set. A solution
is found when all variables are determined.</P>

<PRE class=code>
post (z `<> `1)
<I>val it : unit = ()</I></PRE>

<P align=center><IMG src="inspector-fd-5.jpg" border=0 alt="Alice Inspector"></P>

<P>Constraint propagation is not a complete solution method. It may happen that
a problem has a unique solution and that constraint propagation does not find
it. In those cases it is necessary to combine constraint propagation with
search. Alice hence also provides support for powerful, user-definable search
techniques. For a more thorough introduction to constraint programming, we
refer to the Oz <A href="http://www.mozart-oz.org/documentation/fdt/">Finite
Domain Constraint Programming Tutorial</A>. All constraint programming
functionality from Oz is available in Alice.</P>

<P>As a simple example of a complete program solving a finite domain problem,
consider the <I>Send More Money</I> problem. It consists in finding distinct
digits for the letters <TT>S</TT>, <TT>E</TT>, <TT>N</TT>, <TT>D</TT>,
<TT>M</TT>, <TT>O</TT>, <TT>R</TT>, <TT>Y</TT> such that <TT>S</TT> and
<TT>M</TT> are different from zero (no leading zeros) and the equation

<PRE class=code>
SEND + MORE = MONEY</PRE>

<P>is satisfied. The unique solution of the problem is <TT>9567 + 1085 =
10652</TT>.</P>

<P>Using Alice, the problem can be solved as follows. First, we have to define
a so-called <I>script</I> that encodes the problem:</P>

<PRE class=code>
fun money () =
let
    val v as #[S,E,N,D,M,O,R,Y] = vec (8, [0`#9])
in
    distinct v; 
    post (S `<> `0); 
    post (M `<> `0); 
    post (`1000`*S `+ `100`*E `+ `10`*N `+ D `+
	  `1000`*M `+ `100`*O `+ `10`*R `+ E `=
          `10000`*M `+ `1000`*O `+ `100`*N `+ `10`*E `+ Y ); 
    distribute (FD.FIRSTFAIL, v); 
    {S,E,N,D,M,O,R,Y}
end
<I>val money :
   unit -> {D : term, E : term, M : term, N : term, O : term, R : term, S : term, Y : term} = fn</I></PRE>

<P>The Send More Money problem cannot be solved using constraint propagation
alone. Search is required to reduce the problem space until constraint
propagation is able to determine the solution. The <TT>distribute</TT> function
in the script specifies the <I>distribution strategy</I> used when the problem
space has to be split for search. See the Mozart <A
href="http://www.mozart-oz.org/documentation/fdt/">Constraint Programming
Tutorial</A> for more detail.</P>

<P>To perform the actual search and obtain all solutions to the problem,
predefined search engines can be used:</P>

<PRE class=code>
Search.searchAll money
<I>val it :
   {D : term, E : term, M : term, N : term, O : term, R : term, S : term, Y : term} list =
   [{Y = fd (val), S = fd (val), R = fd (val), O = fd (val), N = fd (val),
     M = fd (val), E = fd (val), D = fd (val)}]</I></PRE>

<P>Using the inspector, we can easily look at the solution:</P>

<PRE class=code>
inspect it
<I>val it : unit = ()</I></PRE>

<P align=center><IMG src="inspector-fd-6.jpg" border=0 alt="Alice Inspector"></P>

<P>An alternative way to obtain the solutions is by interactively exploring the
search tree induced by the script using the <A
href="library/explorer.html"><EM>Explorer</EM></A>:</P>

<PRE class=code>
Explorer.exploreAll money
<I>val it : unit = ()</I></PRE>

<P align=center><IMG src="explorer.jpg" border=0 alt="Alice Explorer"></P>

<P>Clicking on the only solution node in the tree (the green diamond) will open
an Inspector window displaying the variable assignment of the solution.</P>


<?php section("interop", "interoperability") ?>

<P>The Alice compiler generates Oz pickled functors (<TT>.ozf</TT> files). The
Alice virtual machine is essentially a slightly beefed-up version of the Mozart
VM. As such, it can also run ordinary Oz applications.</P>

<P>More importantly, it is easily possible to create mixed Alice/Oz
applications. Oz code can import Alice functors as if they were Oz functors.
Alice can import Oz functors, if given an additional signature description file,
which specifies the types of the entities imported.</P>

<P>The possibility to mix Alice and Oz provides a smooth migration path for Oz
projects that want to use Alice. It also allows escaping the statically typed
world of ML for arbitrary subsystems, where that may be desirable. See the <A
href="interop.html">manual page</A> on interoperability for more detail.</P>


<?php footing() ?>
