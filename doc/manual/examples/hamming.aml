open Hole

fun nth (x::_, 0) = x
  | nth (_::xr, i) = nth (xr, i - 1)

fun map (f, xs) =
    byneed (fn () =>
	    case xs of
		x::xr => f x::map (f, xr)
	      | nil => raise Match)

fun merge (xs, ys) =
    byneed (fn () =>
	    case (xs, ys) of
		(x::xr, y::yr) =>
		    if x = y then x::merge (xr, yr)
		    else if x < y then x::merge (xr, ys)
		    else y::merge (xs, yr)
	      | (_, _) => raise Match)

val hamming =
    let
	val rest = hole ()
	val hamming = 1::rest
    in
	fill (rest, merge (map (fn i => 2 * i, hamming),
			   merge (map (fn i => 3 * i, hamming),
				  map (fn i => 5 * i, hamming))));
	hamming
    end

val _ = Tools.print (List.nth (hamming, 1500))
val _ = OS.Process.exit OS.Process.success
