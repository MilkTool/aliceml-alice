<?php include("macros.php3"); ?>
<?php heading("The Store structure", "The <TT>Store</TT> structure") ?>

<?php section("synopsis", "synopsis") ?>

  <PRE>
    signature STORE
    structure Store : STORE
  </PRE>

  <P>
    The <TT>Store</TT> structure provides an interface to the Alice
    store that holds all data at runtime. 
  </P>

  <P>
    <B>Note:</B>
    This is a low-level module that should be used with care. Some of its
    functionality can compromise abstractions to a certain extent. For
    example, it is not encouraged to apply <TT>deepWait</TT> to values
    that contain instances of abstract types.
  </P>

<?php section("import", "import") ?>

  <PRE>
    import signature STORE from "x-alice:/lib/data/STORE-sig"
    import structure Store from "x-alice:/lib/data/Store"</PRE>

<?php section("interface", "interface") ?>

  <PRE>
signature STORE =
  sig
      val same      : 'a * 'a -> bool
      val equiv     : 'a * 'a -> bool
      val minimize  : 'a -> 'a

      val futures   : 'a -> {total : int, concurrent : int, byneed : int}
      val deepWait  : 'a -> {total : int, concurrent : int, byneed : int}

      val size      : 'a -> {nodes : int, words : int}
      val sizeQuiet : 'a -> {nodes : int, words : int}

      val collect   : int -> unit
  end
  </PRE>

<?php section("description", "description") ?>


  <DL>

    <DT>
      <TT>same (<I>x</I>, <I>y</I>)</TT>
    </DT>
    <DD>
      <P>Tests whether <TT><I>x</I></TT> and <TT><I>y</I></TT> are physically
      equal, i.e. represented by the same object in the store.
      </P>
    </DD>

    <DT>
      <TT>equiv (<I>x</I>, <I>y</I>)</TT>
    </DT>
    <DD>
      <P>Tests whether <TT><I>x</I></TT> and <TT><I>y</I></TT> represent equal
      infinite trees, i.e. whether their respective graphs in the
      store are structurally equivalent. For example,
      </P>
      <PRE>
      equiv (rec x => 1::x, rec x => 1::1::x)          = true
      equiv (rec x => 1::x, 1::(rec x => 1::x))        = true
      equiv (rec x => (ref 1)::x, rec x => (ref 1)::x) = false
      let val r = ref 1 in equiv (rec x => r::x, rec x => r::x) end = true</PRE>
      <P><I>Note:</I> This function may internally apply <TT>minimize</TT>
      to its arguments to detect equivalence.</P>
    </DD>

    <DT>
      <TT>minimize <I>x</I></TT>
    </DT>
    <DD>
      <P>Minimizes the store representation of <TT><I>x</I></TT> by computing
      the minimal representation for <TT><I>x</I></TT> that is structurally
      equivalent to the original.
      </P>
    </DD>

    <DT>
      <TT>futures <I>x</I></TT>
    </DT>
    <DD>
      <P>Computes the number of futures appearing in the representation
      of <TT><I>x</I></TT>. For function values, this includes futures appearing
      in the respective closure, as well as any internal futures used in
      code representations (to represent not-yet-compiled code fragments,
      for example).
      </P>
    </DD>

    <DT>
      <TT>deepWait <I>x</I></TT>
    </DT>
    <DD>
      <P>Requests all futures in the representation of <TT><I>x</I></TT> until
      none remain. Returns the number of futures requested.
      Note that for function values, this may force compilation of all
      not-yet-compiled code fragments.
      </P>
    </DD>

    <DT>
      <TT>size <I>x</I></TT> <BR>
      <TT>sizeQuiet <I>x</I></TT>
    </DT>
    <DD>
      <P>Computes the number and total size of store nodes used to
      represent <TT><I>x</I></TT>. While <TT>size</TT> is hyper-strict, i.e. it
      requests all futures in <TT><I>x</I></TT>, <TT>sizeQuiet</TT> does not
      request any futures but
      includes the sizes of closures associated with lazy futures. Note that
      the size of function values includes their respective closure and code
      representation. Due to just-in-time compilation, the size of the latter
      can vary over time. Ignoring concurrent interference, the following
      equivalence holds:
      </P>
      <PRE>
      size <I>x</I> = (deepWait <I>x</I>; sizeQuiet <I>x</I>)</PRE>
    </DD>

    <DT>
      <TT>collect <I>gen</I></TT>
    </DT>
    <DD>
      <P>Triggers a garbage collection up to generation <I>gen</I> (if
      the system features a generational garbage collector).
      </P>
    </DD>

  </DL>

<?php footing() ?>
