<?php include("macros.php3"); ?>
<?php heading("The FD structure", "The <TT>FD</TT> structure"); ?>

<?php section("synopsis", "synopsis"); ?>

  <PRE>
    signature FD
    structure FD : FD</PRE>

  <P>
    The <TT>FD</TT> structure provides access to finite domain variables
    and propagators.
  </P>
  <P>
    Finite domain variables are variables whose values are integers.
  </P>
  <P>
    If a propagator is invoked, it tries to narrow the domains of the
    variables it is posted on. The amount of narrowing of domains
    depends on the operational semantics of the propagator.
    There are two main schemes for the operational semantics of a propagator.
    Domain propagation means that the propagator narrows the domains
    such that all values are discarded, which are not contained in a
    solution of the modeled constraint. But due to efficiency reasons,
    most propagators provide only interval propagation,
    i. e. only the bounds of domains are narrowed.
    Even faster to perform, but even less strict is value propagation, 
    which is performed only when one of the variables is determined.
    Some propagators take a "consistency level" argument to determine 
    the desired mode of operation.
  </P>
  <P>
    A propagator ceases to exist if all the variables
    it is posted on are determined. In the following sections,
    only exceptions from this rule are mentioned,
    i. e. if the propagator ceases to exist earlier.
    For example, <TT>FD.lessEq(x, y)</TT> ceases
    to exist if the current upper bound
    of <I>x</I> is smaller than or equal to the current lower bound of <I>y</I>.
  </P>

  <P>See also:
    <A href="fs.html"><TT>FS</TT></A>,
    <A href="linear.html"><TT>Linear</TT></A>
  </P>

<?php section("import", "import"); ?>

  <PRE>
    import signature FD from "x-alice:/lib/gecode/FD-sig"
    import structure FD from "x-alice:/lib/gecode/FD"</PRE>

<?php section("interface", "interface"); ?>

  <PRE>
signature FD =
sig
    type space
    type intvar
    type boolvar

    exception NotAssigned
		       
    type domain = (int*int) vector
    exception InvalidDomain
    (* Exception thrown by all domain tells *)
    (* if something that is no proper domain is used *)

    val domainFromList : int list -> domain

    (* Allocation of finite domain variables *)
    val intvar :  space * domain -> intvar
    val intvarVec :  space * int * domain -> intvar vector
    val range :  space * (int * int) -> intvar
    val rangeVec :  space * int * (int * int) -> intvar vector

    (* Allocation of boolean (0/1) finite domain variables *)
    val boolvar :  space -> boolvar
    val boolvarVec :  space * int -> boolvar vector

    (* Constraining an intvar to a boolvar *)

    val intvar2boolvar : space * intvar -> boolvar

    (* Value assignment *)

    datatype avalsel = AVAL_MIN | AVAL_MED | AVAL_MAX

    val assign : space * intvar vector * avalsel -> unit

    (* Domain constraints *)
    val dom :  space * intvar * (int * int) vector -> unit


    (* debugging *)
    (*val varStamp : intvar -> int*)

    (* *********** *)
    (* PROPAGATORS *)
    (* *********** *)

    (* Relations *)

    datatype relation =
	     EQ (* Equality         == *)
	   | NQ (* Disequality      != *)
	   | LQ (* Less or equal    <= *)
	   | LE (* Less             <  *)
	   | GQ (* Greater or equal >= *)
	   | GR (* Greater          >  *)
	     
    datatype conlevel = 
	     BND | DEF | DOM | VAL

    val rel  :  space * intvar * relation * intvar -> unit
    val relI :  space * intvar * relation * int -> unit

    val equal  : space * intvar * intvar * conlevel -> unit
    val equalV : space * intvar vector * conlevel -> unit

    (* Distinct constraints *)
    val distinct : space * intvar vector * conlevel -> unit
    val distinctOffset : space * (int * intvar) vector *
			 conlevel -> unit

    (* Counting constraints *)
    val countII : space * intvar vector * relation *
		  int * relation * int -> unit
    val countVI : space * intvar vector * relation *
		 intvar * relation * int -> unit
    val countIV : space * intvar vector * relation *
		  int * relation * intvar -> unit
    val countVV : space * intvar vector * relation *
		 intvar * relation * intvar -> unit

    (* Access constraints *)
    val element : space * intvar vector * intvar *
		 intvar -> unit
    val elementI : space * int vector * intvar *
		  intvar -> unit
    val lex : space * intvar vector * relation *
	     intvar vector -> unit
			       
    (* Boolean constraints *)			     
    val nega  : space * boolvar * boolvar -> unit
    val conj  : space * boolvar * boolvar * boolvar -> unit
    val disj  : space * boolvar * boolvar * boolvar -> unit
    val impl  : space * boolvar * boolvar * boolvar -> unit
    val equi  : space * boolvar * boolvar * boolvar -> unit
    val exor  : space * boolvar * boolvar * boolvar -> unit
    val conjV : space * boolvar vector * boolvar -> unit
    val disjV : space * boolvar vector * boolvar -> unit

    (* Linear equations *)
    val linear : space * (int * intvar) vector * relation *
		 int * conlevel -> unit

    (* Arithmetic constraints *)					
    val min : space * intvar vector * intvar -> unit
    val max : space * intvar vector * intvar -> unit
    val abs : space * intvar * intvar * conlevel -> unit
    val mult: space * intvar * intvar * intvar -> unit
(*    val power: space * intvar * intvar * intvar -> unit*)

    structure Reified :
	sig
	    val intvar : space * domain * boolvar -> intvar
	    val intvarVec : space * int * domain * boolvar ->
			    intvar vector
	    val dom : space * intvar * (int * int) vector *
		      boolvar -> unit
	    val rel : space * intvar * relation * intvar *
		      boolvar -> unit
	    val relI : space * intvar * relation * int *
		       boolvar -> unit
(*	    val equal : space * intvar * intvar *
			boolvar * conlevel -> unit*)
	    val linear : space * (int * intvar) vector * relation *
			 int * boolvar * conlevel -> unit
	end

    structure Reflect :
	sig
	    val min : space * intvar -> int
	    val max : space * intvar -> int
            val med : space * intvar -> int
	    val value : space * intvar -> int (* NotAssigned *)
	    val boolVal : space * boolvar -> bool (* NotAssigned *)
	    val boolvar2intvar : boolvar -> intvar
(*	    val mid : space * intvar -> int *)
(*	    val nextLarger : space * fd * int -> int *)
(*	    val nextSmaller : space * fd * int -> int *)
	    val size : space * intvar -> int
	    val dom : space * intvar -> domain
            val assigned : space * intvar -> bool
            val range : space * intvar -> bool
(*	    val domList : fd -> int list *)
(*	    val nbSusps : fd -> int *)
(*	    val eq : fd * fd -> bool (* token eq *) *)
	end
						  
    (* Branching strategies *)

    datatype b_var_sel =
	     B_DEGREE_MAX
	   | B_DEGREE_MIN
	   | B_MAX_MAX
	   | B_MAX_MIN
	   | B_MIN_MAX
	   | B_MIN_MIN
	   | B_NONE
	   | B_SIZE_MAX
	   | B_SIZE_MIN
	     
    datatype b_val_sel =
	     B_MAX
	   | B_MED
	   | B_MIN
	   | B_SPLIT_MAX
	   | B_SPLIT_MIN
	   | B_VAL

    val branch : space * intvar vector * b_var_sel *
		 b_val_sel -> unit

end</PRE>

<?php section("description", "description"); ?>

  <DL>
       <DT
      <TT>type space</TT>
    </DT>
    <DD>
      <P>The type of the first class comutational space. Usually equal to <TT>SPACE.space</TT>.
    </P></DD>

    <DT
      <TT>type intvar</TT> 
    </DT>
    <DD>
      <P>The type of finite domain variables.
    </P></DD>

    <DT
      <TT>type boolvar</TT> 
    </DT>
    <DD>
      <P>The type of boolean constraint variables.
      Fundamentally, they are FD variables constrained to the 0-1 domain.
    </P></DD>


    <DT>
      <TT>exception NotAssigned</TT>
    </DT>
    <DD>
      <P>is raised when a reflection operation intended for determined values only is performed 
      on a variable in a space where its domain is not yet narrowed to a single value.
    </P></DD>


    <DT>
      <TT>type domain = (int*int) vector</TT>
    </DT>
    <DD>
      <P>The type of domain descriptions. 
      Used to define variable bounds at variable creation or later, in value declaration, and reflection.
      It is an ordered, non-overlapping, non-contingous vector of ordered integer pairs. 
      For example the set of all primes between 1 and 10 is #[(2,3),(5,5),(7,7)] <BR>
      Observe that #[(1,2),(3,4)] is an invalid domain: contigous ranges, use #[(1,4)] instead <BR>
      #[(1,3),(3,4)] is even more so.<BR>
      #[(3,2)] is also invalid, the range is ill-defined.<BR>
      #[(4,5),(1,2)] is nonconformant in pair ordering, #[(1,2),(4,5)] is fine.
    </P></DD>

    <DT>
      <TT>exception InvalidDomain</TT>
    </DT>
    <DD>
      <P>Exception thrown by all variable creation and domain tell operations
      on receipt of a domain description not conforming to the above rules.
    </P></DD>

    <DT>
      <TT>domainFromList <I>l</I></TT>
    </DT>
    <DD>
      <P>Returns a valid domain description containing the same integers as <I>l</I> does.
    </P></DD>

    <DT>
      <TT>intvar (<I>s, d</I>)</TT>
    </DT>
    <DD>
      <P>Returns a fresh FD variable valid in <I>s</I> and all its descendents 
      not originating from a child created earlier than the introduction of the variable.<BR>
      The fresh variable is already constrained to be in <I>d</I>.
    </P></DD>

    <DT>
      <TT>intvarVec (<I>s, n, d</I>)</TT>
    </DT>
    <DD>
      <P>Returns <I>n<\I> FD variables freshly created in <I>s</I>.
      They are already constrained to be in <I>d</I>.
    </P></DD>

    <DT>
      <TT>range (<I>s, (min, max)</I>)</TT>
    </DT>
    <DD>
      <P>Returns an FD variable freshly created in <I>s</I>.
      It is already constrained to be between <I>min</I> and <I>max</I>, inclusive.
    </P></DD>

    <DT>
      <TT>rangeVec (<I>s, n, (min, max)</I>)</TT>
    </DT>
    <DD>
      <P>Returns <I>n<\I> FD variables freshly created in <I>s</I>.
      They are already constrained to be between <I>min</I> and <I>max</I>, inclusive.
    </P></DD>

    <DT>
      <TT>boolvar <I>s</I></TT>
    </DT>
    <DD>
      <P>Returns an FD variable freshly created in <I>s</I>.
      It is already constrained to be either 0 or 1.
    </P></DD>

    <DT>
      <TT>boolvarVec (<I>s, n</I>)</TT>
    </DT>
    <DD>
      <P>Returns <I>n<\I> FD variables freshly created in <I>s</I>.
      They are already constrained to be either 0 or 1.
    </P></DD>

    <DT>
      <TT>intvar2boolvar (<I>s, x</I>)</TT>
    </DT>
    <DD>
      <P> Constrains <I>x</I> to the (0,1) range, 
      and returns a reference to it as a boolvar.
    </P></DD>

    <DT>
      <TT>datatype avalsel</TT>
    </DT>
    <DD>
      <P>Type to identify a value assignments strategy.<BR>
      <TT>AVAL_MIN</TT>: Pick the smallest possible value.<BR>
      <TT>AVAL_MAX</TT>: Pick the largest possible value.<BR>
      <TT>AVAL_MED</TT>: Pick the median of the available values.
    </P></DD>

    <DT>
      <TT>assign (<I>s, v, strategy</I>)</TT>
    </DT>
    <DD>
      <P> Determines all elements of <I>v</I> in <I>s</I> 
      following the <I>strategy</I> provided.
    </P></DD>

    <DT>
      <TT>dom (<I>s, x, (min,max)</I>)</TT>
    </DT>
    <DD>
      <P> Constrains <I>x</I> in <I>s</I> 
      to the range <I>(min,max)</I>.
    </P></DD>

    <DT>
      <TT>datatype relation</TT>
    </DT>
    <DD>
      <P>Type to identify an arithmetic relation in constraints.<BR>
      <TT>EQ</TT>: Equal.<BR>
      <TT>NQ</TT>: Not equal.<BR>
      <TT>LQ</TT>: Less or equal.<BR>
      <TT>LE</TT>: Less.<BR>
      <TT>GQ</TT>: Greater or equal.<BR>
      <TT>GE</TT>: Greater.
    </P></DD>

    <DT>
      <TT>datatype conlevel</TT>
    </DT>
    <DD>
      <P>Type to identify the eagerness of propagation. 
      When the required level is not implemented for a propagator,
      the closest, stricter version is used.<BR>
      <TT>DOM</TT>: Domain Proagatin. Strictest.<BR>      
      <TT>BND</TT>: Bounds Propagation.<BR>
      <TT>VAL</TT>: Value Propagation. Most loose. <BR>
      <BR>
      <TT>DEF</TT>: The default for the propagator.<BR>      
    </P></DD>

    <DT>
      <TT>rel (<I>s, x, relation, y</I>)</TT>
    </DT>
    <DD>
      <P> Creates a propagator to constrain <I>x</I> and <I>y</I> in <I>s</I> 
      to be in the given <I>relation</I>.
    </P></DD>

    <DT>
      <TT>relI (<I>s, x, relation, n</I>)</TT>
    </DT>
    <DD>
      <P> Constrains <I>x</I> in <I>s</I> 
      to be in the given <I>relation</I> with <I>n</I>.
    </P></DD>

    <DT>
      <TT>equal (<I>s, x, y, level</I>)</TT>
    </DT>
    <DD>
      <P> Creates a propagator to constrain <I>x</I> and <I>y</I> in <I>s</I> 
      to be equal. As gecode currently uses a propagator to enforce this, 
      a performance increase might be achieved by 
      eliminating the need for this constraint with smarter modeling.
    </P></DD>

    <DT>
      <TT>equalV (<I>s, v, level</I>)</TT>
    </DT>
    <DD>
      <P> Creates a propagator to constrain <I>x</I> and <I>y</I> in <I>s</I> 
      to be equal.
    </P></DD>


  </DL>

<?php footing() ?>
