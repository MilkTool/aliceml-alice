Almost all Stockhausen extensions to SML'97 are conservative. There remain some
minor syntactic incompatibilies to SML'97 however. All of them are quite
pathological, caught on compile time, and can easily be fixed in an SML
compatible way.



ADDITIONAL RESERVED WORDS

The following are reserved words in Stockhausen and may not be used as
identifiers:

	con    non    when    withfun    withval



OPEN AND INFIX

Open pulls in infix status. Opening a structure that
(1) contains infix declarations, and
(2) has not been constrained by a signature
will change the infix environment, while in SML it wouldn't.

Example:

	structure S =
	  struct
	    infix ++
	    fun l1++l2 = l1 @ l2
	  end

	open S

	val l = ++([1],[2])		(* Error in Stockhausen *)

Fixes:
(1) Use appropriate signature constraints (always a good idea anyway):

	signature SIG =
	  sig
	    val ++ : 'a list * 'a list -> 'a list
	  end

	structure S: SIG =
	  struct
	    infix ++
	    fun l1++l2 = l1 @ l2
	  end

	open S

	val l = ++([1],[2])

(2) Or insert op on every use of such identifiers:

	val l = op++([1],[2])



LEFT-HAND-SIDES OF RECURSIVE VALUE BINDINGS

Recursive value bindings do not remove constructor status on the identifiers
bound. You cannot bind functions to an identifier that was a constructor
previously.

Examples:

	val rec NONE = fn x => x
	fun NONE x = x

This is legal in SML'97 (though it was not in SML'90 and SML/NJ for example
does not allow it either). In Stockhausen it produces a type clash
(due to the extended val rec).

Fix:
    Rename your function, this is perverse anyway.
