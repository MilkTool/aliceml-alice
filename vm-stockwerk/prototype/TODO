Stockwerk:
-- static linker
-- replace OuptutPickle after bootstrapping by generic Pickle.save
-- rename Pickle.oz to PrimPickle.oz (what is the relation to UnsafeComponent?)
-- proxies
-- non-blocking I/O (Pickle, UnsafeIO, UnsafeSocket, UnsafeComponent)
-- component manager and spaces in path names => %20
-- globalize constructors
-- what code annotations do we need for the JITter?

Extended Basis Library:
-- Future.byneed and Future.concur suspend on their argument
-- raised exceptions should always be evaluated
   (Thread.raiseIn, Hole.fail, Raise instruction)
-- yield should always operate on the current thread
-- document that pickling of a stateful data structure requires
   it to be locked until the pickling operation is finished (else
   concurrent modifications can cause an inconsistent data structure
   to be made persistent)

Library:
-- add to signature PICKLE:
      val pickleToFun: (Word8Vector.vector -> unit) -> package -> unit
      val unpickleFromFun: (unit -> Word8Vector.vector) -> package
   The Mozart backend can implement the first one by only calling the
   function once.

Mozart:
-- Ozcar-Bug: wenn man ein 'unleash' macht und dabei eine
   Exception geworfen wird, haelt der Debugger nicht im
   Exception Handler (und zeigt sogar eine Selektion von
   <N:VoidRegister>!).  Beispiel: ozd -E Main.ozf test/General,
   steppen bis {ReadFile ...}, dann 'next'.
