Stockwerk:
-- replace OuptutPickle after bootstrapping by generic Pickle.save
-- rename Pickle.oz to PrimPickle.oz (what is the relation to UnsafeComponent?)
-- proxies
-- non-blocking I/O (Pickle, UnsafeIO, UnsafeSocket, UnsafeComponent)
-- globalize constructors
-- what code annotations do we need for the JITter?

Extended Basis Library:
-- Future.byneed and Future.concur suspend on their argument
-- raised exceptions should always be evaluated
   (Thread.raiseIn, Hole.fail, Raise instruction)
-- yield should always operate on the current thread

Alice Library:
-- document that pickling of a stateful data structure requires
   it to be locked until the pickling operation is finished (else
   concurrent modifications can cause an inconsistent data structure
   to be made persistent)
-- add to signature PICKLE:
      val pickleToFun: (Word8Vector.vector -> unit) -> package -> unit
      val unpickleFromFun: (unit -> Word8Vector.vector) -> package
   The Mozart backend can implement the first one by only calling the
   function once.

Alice Compiler:
-- bug in type inference for open records: see linker/Link.aml
-- ValuePropagationPhase: unless we make isToplevel more powerful,
   we can remove it entirely (is taken over by JITter)
-- AbstractCodeGrammar should have idRef = ... | Immediate of value,
   can remove PutConst then

JITter:
-- two working modes: compile a function, or compile a closure
   (the latter can make much stronger assumptions and thus, optimizations)
-- compiling a closure assumes that the function in the closure is
   referenced exactly once in the heap (and that reference is in the closure)

Mozart:
-- Ozcar-Bug: wenn man ein 'unleash' macht und dabei eine
   Exception geworfen wird, haelt der Debugger nicht im
   Exception Handler (und zeigt sogar eine Selektion von
   <N:VoidRegister>!).  Beispiel: ozd -E Main.ozf test/General,
   steppen bis {ReadFile ...}, dann 'next'.
