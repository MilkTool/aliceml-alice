Stockwerk:
-- replace OuptutPickle after bootstrapping by generic Pickle.save
-- rename Pickle.oz to PrimPickle.oz (what is the relation to UnsafeComponent?)
-- proxies
-- non-blocking I/O (Pickle, UnsafeIO, UnsafeSocket, UnsafeComponent)
-- globalize constructors
-- what code annotations do we need for the JITter?
-- alicedep uses .ozf, change to .stc

Extended Basis Library:
-- Future.byneed and Future.concur suspend on their argument
-- raised exceptions should always be evaluated
   (Thread.raiseIn, Hole.fail, Raise instruction)
-- yield should always operate on the current thread

Alice Library:
-- document that pickling of a stateful data structure requires
   it to be locked until the pickling operation is finished (else
   concurrent modifications can cause an inconsistent data structure
   to be made persistent)
-- add to signature PICKLE:
      val pickleToFun: (Word8Vector.vector -> unit) -> package -> unit
      val unpickleFromFun: (unit -> Word8Vector.vector) -> package
   The Mozart backend can implement the first one by only calling the
   function once.

Inspector:
-- wenn Fontgroesse veraendert wird, wird die Selection nicht angepasst;
   ausserdem wird alles unmappt, was schon gemappt war
-- wenn "explore tree->depth->depth + 10" gewaehlt wird, muss die
   Selection erhalten bleiben

Alice Compiler:
-- wir finden innerhalb eines Try ein Kill einer Variablen, die im
   korrespondierenden Handler noch benutzt wird
   (DerivedForms:rewriteTy, longtycon as G.SHORTLong)
-- es wird Code generiert der Form: `L.30 := L.29; Return L.30'
-- und Code der Form: `L.1 := (G.2, L.0); (_, _) := L.1; Kill L.1'
-- es sheint Shareds zu geben, die nur einmal benutzt werden
   (DerivedForms:rewriteTy, siehe handle, EndTry/Shared720398)
-- omit kills before return instructions
-- join adjacent kills
-- bug in type inference for open records: see linker/Link.aml
-- ValuePropagationPhase: unless we make isToplevel more powerful,
   we can remove it entirely (is taken over by JITter)
-- AbstractCodeGrammar should have idRef = ... | Immediate of value,
   can remove PutConst then

JITter:
-- two working modes: compile a function, or compile a closure
   (the latter can make much stronger assumptions and thus, optimizations)
-- compiling a closure assumes that the function in the closure is
   referenced exactly once in the heap (and that reference is in the closure)

Mozart:
-- Ozcar-Bug: wenn man ein 'unleash' macht und dabei eine
   Exception geworfen wird, haelt der Debugger nicht im
   Exception Handler (und zeigt sogar eine Selektion von
   <N:VoidRegister>!).  Beispiel: ozd -E Main.ozf test/General,
   steppen bis {ReadFile ...}, dann 'next'.
