import structure MkHashImpMap from "x-alice:/lib/data/MkHashImpMap"
import structure Gtk from "x-alice:/lib/gtk/Gtk"
import structure Gdk from "x-alice:/lib/gtk/Gdk"
import structure PangoEnums from "x-alice:/lib/gtk/PangoEnums"
import structure Core from "x-alice:/lib/gtk/Core"
import structure FileDialog from "FileDialog"

structure Buffer =
   struct
      structure BufferMap = MkHashImpMap(Int)

      datatype undo = INSERT of (int * int)
                    | DELETE of (int * int)

      type tags = {err : Gtk.object,
                   std : Gtk.object,
                   log : Gtk.object,
                   plain : Gtk.object,
                   error : Gtk.object,
                   comment : Gtk.object,
                   string : Gtk.object,
                   reserved : Gtk.object}

      type buffer = {id: int,
                     file: string option ref,
                     fileLabel: Gtk.object,
                     view: Gtk.object,
                     buf: Gtk.object,
                     tags: tags,
                     undo: undo list ref,
                     lastSearchPos: int ref}

      val bufferMap : buffer BufferMap.map = BufferMap.map()

      val cmap   = Gdk.colormapGetSystem ()
      val textColor = Gdk.colorNew(0xf0f0, 0x2020, 0xa0a0)
      val reservedColor = textColor
      val black = Gdk.colorNew(0, 0, 0)
      val red = Gdk.colorNew(65535, 0, 0)
      val commentColor = red
      val blue = Gdk.colorNew(0, 0, 65535)
      val stringColor = blue
      val plainColor = black
      val white = Gdk.colorNew(65535, 65535, 65535)
      val _ = Gdk.colormapAllocColor(cmap, black, false, true)
      val _ = Gdk.colormapAllocColor(cmap, white, false, true)
      val _ = Gdk.colormapAllocColor(cmap, textColor, false, true)
              
      fun makeTags buf =
          let
              val error = Gtk.textBufferCreateTag(buf, "error", "foreground-gdk", Gtk.OBJECT textColor)
              val string = Gtk.textBufferCreateTag(buf, "string", "foreground-gdk", Gtk.OBJECT stringColor)
              val comment = Gtk.textBufferCreateTag(buf, "comment", "foreground-gdk", Gtk.OBJECT commentColor)
              val plain = Gtk.textBufferCreateTag(buf, "plain", "foreground-gdk", Gtk.OBJECT plainColor)
              val reserved = Gtk.textBufferCreateTag(buf, "reserved", "foreground-gdk", Gtk.OBJECT reservedColor)
          in
          {err = Gtk.textBufferCreateTag(buf, "err", "foreground-gdk", Gtk.OBJECT textColor),
           log = Gtk.textBufferCreateTag(buf, "log", "style", Gtk.INT (PangoEnums.PangoStyleToInt PangoEnums.STYLE_ITALIC)),
           std = Gtk.textBufferCreateTag(buf, "std", "foreground-gdk", Gtk.OBJECT black),
           error=error,string=string,comment=comment,plain=plain,reserved=reserved}
          end

      fun shortName s =
          let
              fun lastSlash i j = if j=size s then i
                                  else if String.sub(s,j)= #"/" then lastSlash j (j+1)
                                  else lastSlash i (j+1)
          in
              String.extract(s,1 + lastSlash ~1 0, NONE)
          end

      (* Cursor *)
      fun getCursorIter buf =
          let
              val cursor = Gtk.textBufferGetInsert buf
              val iter = Gtk.textIterNew()
          in
              Gtk.textBufferGetIterAtMark(buf, iter, cursor);
              iter
          end

      fun selectRange(buf, startiter, enditer) =
	  (Gtk.textBufferMoveMarkByName(buf, "insert", startiter);
	   Gtk.textBufferMoveMarkByName(buf, "selection_bound", enditer))

      fun modifiedChanged id _ =
          let
              val {fileLabel,file,buf,...} = BufferMap.lookupExistent(bufferMap, id)
              val fileName = shortName (Option.getOpt(!file, "New file "^Int.toString id))
          in
              if Gtk.textBufferGetModified buf then
                  Gtk.labelSetText(fileLabel, fileName^"*")
              else
                  Gtk.labelSetText(fileLabel, fileName)
          end

      fun deleteRange id (obj, [Gtk.OBJECT iter1, Gtk.OBJECT iter2]) = ()
(*          let
              val {undo,...} = BufferMap.lookupExistent(bufferMap, id)
              val del_start = 0 (*Gtk.textIterGetOffset iter1*)
              val del_end = 0 (*Gtk.textIterGetOffset iter2*)
          in
              print ("delete "^
                     Int.toString del_start^" "^
                     Int.toString del_end^"\n");
              undo := DELETE(del_start, del_end) :: (!undo)
          end*)
        | deleteRange _ _ = print "Gtk is crazy"

      fun insertText id (buf,[Gtk.OBJECT iter, _, Gtk.INT length]) =
          let
              val {undo,...} = BufferMap.lookupExistent(bufferMap, id)
              val cursor = getCursorIter buf
              val newOff = Gtk.textIterGetOffset cursor
              val oldOff = newOff - length
          in
              undo := INSERT(oldOff, newOff) :: (!undo)
          end
        | insertText _ _ = print "Gtk is crazy"

      fun buffer {notebook,id,file,loadFile} =
          let
              val fileName = Option.getOpt(file, "New file "^Int.toString id)
              val scrolledwindow2_xa = Gtk.adjustmentNew(0.0,0.0,0.0,1.0,0.0,0.0)
              val scrolledwindow2_ya = Gtk.adjustmentNew(0.0,0.0,0.0,1.0,0.0,0.0)
              val scrolledwindow2 = Gtk.scrolledWindowNew(scrolledwindow2_xa,scrolledwindow2_ya)
              val _ = Gtk.scrolledWindowSetShadowType(scrolledwindow2,Gtk.SHADOW_NONE)
              val _ = Gtk.widgetShow scrolledwindow2
                      
              val newSource = Gtk.textViewNew()
              val _ = Gtk.widgetShow newSource
              val _ = Gtk.textViewSetEditable(newSource,true)
              val _ = Gtk.textViewSetJustification(newSource,Gtk.JUSTIFY_LEFT)
              val _ = Gtk.textViewSetWrapMode(newSource,Gtk.WRAP_NONE)
              val _ = Gtk.textViewSetCursorVisible(newSource,true)
              val _ = Gtk.textViewSetPixelsAboveLines(newSource,0)
              val _ = Gtk.textViewSetPixelsBelowLines(newSource,0)
              val _ = Gtk.textViewSetPixelsInsideWrap(newSource,0)
              val _ = Gtk.textViewSetLeftMargin(newSource,0)
              val _ = Gtk.textViewSetRightMargin(newSource,0)
              val _ = Gtk.textViewSetIndent(newSource,0)
              val buf = Gtk.textViewGetBuffer newSource
              val _ = Gtk.containerAdd(scrolledwindow2,newSource)
              val label1 = Gtk.labelNew (shortName fileName)
              val _ = Gtk.widgetShow label1
	      val _ = Gtk.notebookAppendPage(notebook, scrolledwindow2, label1)
              val page = Gtk.notebookPageNum(notebook, scrolledwindow2)
              val _ = Gtk.notebookSetCurrentPage(notebook, page)

              val ret = {id=id,file=ref file,
                         fileLabel=label1,
                         view=newSource,buf=buf,
                         tags=makeTags buf,
                         undo=ref nil,
                         lastSearchPos=ref 0}
              val _ = Gtk.signalConnect(buf, "modified-changed", modifiedChanged id)
              val _ = Gtk.signalConnect(buf, "delete-range", deleteRange id)
              val _ = Gtk.signalConnect(buf, "insert-text", insertText id)
          in
              if loadFile then
              case file of NONE => ()
                         | SOME f =>
                           let
                               val fileD = TextIO.openIn f
                               val text = TextIO.inputAll fileD
                               val text = Core.latin1ToUtf8 text
                           in
                               Gtk.textBufferSetText(buf, text, ~1);
                               Gtk.textBufferSetModified(buf, false)
                           end handle Io => FileDialog.message "IO error. Could not open file."
              else ();
              BufferMap.insertDisjoint(bufferMap, id, ret);
              ret
          end

      fun close id =
          let
              val {file,buf,...} = BufferMap.lookupExistent(bufferMap, id)
              val modified = Gtk.textBufferGetModified buf
          in
              if modified then
                  false
              else
                  (BufferMap.removeExistent(bufferMap, id);
                   true)
          end

      fun save id =
          let
              val {id,file,buf,...} = BufferMap.lookupExistent(bufferMap, id)
              val modified = Gtk.textBufferGetModified buf
          in
              case !file of NONE => false
                          | SOME f =>
                            (if modified then
                                 let
                                     val file = TextIO.openOut f
                                     val startiter = Gtk.textIterNew()
                                     val _ = Gtk.textBufferGetStartIter(buf,startiter)
                                     val enditer = Gtk.textIterNew()
                                     val _ = Gtk.textBufferGetEndIter(buf,enditer)
                                     val str = Gtk.textBufferGetText(buf, startiter, enditer, false)
                                     val str = Core.utf8ToLatin1 str
                                 in 
                                     TextIO.output(file, str);
                                     TextIO.closeOut file;
                                     Gtk.textBufferSetModified(buf, false)
                                 end handle Io => FileDialog.message "IO Error. Could not save file."
                             else ();
                             true)
          end

      fun saveAs (id, fileName) =
          let
              val {id,file,fileLabel,buf,...} = BufferMap.lookupExistent(bufferMap, id)
          in
              file := SOME fileName;
              Gtk.labelSetText(fileLabel, shortName fileName);
              Gtk.textBufferSetModified(buf, true);
              save id;
              ()
          end

      fun match iter back txt i caseSensitive =
          if (if caseSensitive then
                  Gtk.textIterGetChar iter = ord (String.sub(txt,i))
              else
                  let
                      val c = Gtk.textIterGetChar iter
                      val c = if c<=Char.maxOrd then
                                  ord (Char.toLower (chr c))
                              else c
                  in
                      c = ord (Char.toLower (String.sub(txt,i)))
                  end)
          then if i=String.size txt - 1 then 
                   (Gtk.textIterSetOffset(iter,back);
                    true)
               else if Gtk.textIterForwardChar iter 
               then match iter back txt (i+1) caseSensitive
               else (Gtk.textIterSetOffset(iter,back);
                     false)
          else (Gtk.textIterSetOffset(iter,back);
                false)

      fun find' iter off txt caseSensitive =
          (match iter off txt 0 caseSensitive orelse
           (Gtk.textIterForwardChar iter andalso
            find' iter (off+1) txt caseSensitive))

      fun find id txt caseSensitive =
          let
              val {view,buf,lastSearchPos,...} = BufferMap.lookupExistent(bufferMap, id)
              val iter = getCursorIter buf
              val off = Gtk.textIterGetOffset iter
              val off = if (off = (!lastSearchPos)) andalso Gtk.textIterForwardChar iter
                        then off + 1
                        else off
          in
              if find' iter off txt caseSensitive then
                  let
                      val iter' = Gtk.textIterCopy iter
                  in
                      Gtk.textIterForwardChars(iter',size txt);
                      lastSearchPos := Gtk.textIterGetOffset iter;
                      selectRange(buf,iter,iter');
                      Gtk.textViewScrollToMark(view,
                                               Gtk.textBufferGetInsert buf,
                                               0.0,false,0.0,0.0)
                  end
              else ()
          end
   end
