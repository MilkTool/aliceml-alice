import structure Stream from "x-alice:/lib/data/Stream"
import structure AliceIdeGUI from "AliceIdeGUI"
import structure Gtk from "x-alice:/lib/gtk/Gtk"
import structure Gdk from "x-alice:/lib/gtk/Gdk"
import structure Key from "x-alice:/lib/gtk/Key"
import structure OutputWriters from "OutputWriters"
import structure Evaluator from "Evaluator"
import structure Inspector from "x-alice:/lib/tools/Inspector"
import functor MkHashImpMap from "x-alice:/lib/data/MkHashImpMap"

structure AliceIde =
    struct
	(* Stream redirection *)

	val (stdin, stdInText) = Stream.stream ()
	val reader = TextPrimIO.openVectorListRd stdInText
	val progStdIn = TextIO.StreamIO.mkInstream (reader, "")
	val _ = TextIO.setInstream (TextIO.stdIn, progStdIn)

	val (stdOutText, writer) = TextPrimIO.openVectorListWr ()
	val progStdOut = TextIO.StreamIO.mkOutstream (writer, IO.LINE_BUF)
	val _ = TextIO.setOutstream (TextIO.stdOut, progStdOut)

	val (stdErrText, writer) = TextPrimIO.openVectorListWr ()
	val progStdErr = TextIO.StreamIO.mkOutstream (writer, IO.NO_BUF)
	val _ = TextIO.setOutstream (TextIO.stdErr, progStdErr)

	val (outText, writer) = TextPrimIO.openVectorListWr ()
	val compilerOut = TextIO.StreamIO.mkOutstream (writer, IO.LINE_BUF)
	val _ = Evaluator.setOutStream compilerOut

	val (inText, writer) = TextPrimIO.openVectorListWr ()
	val compilerIn = TextIO.StreamIO.mkOutstream (writer, IO.LINE_BUF)

	val (errText, writer) = TextPrimIO.openVectorListWr ()
	val compilerErr = TextIO.StreamIO.mkOutstream (writer, IO.LINE_BUF)
	val _ = Evaluator.setErrStream compilerErr

	val (traceText, writer) = TextPrimIO.openVectorListWr ()
	val compilerTrace = TextIO.StreamIO.mkOutstream (writer, IO.LINE_BUF)
	val _ = Evaluator.setTraceStream compilerTrace

        (* Buffers *)

        val curtextview = ref AliceIdeGUI.scratchpad
        val clipboard = Gtk.clipboardGet(Gdk.atomIntern("CLIPBOARD", false))

        val numberOfPages = ref 0
        val currentPage = ref 0

        fun eval "" = ()
	  | eval text =
	    let
		val dummySignal = Promise.future (Promise.promise ())
		val text = if String.sub (text, String.size text - 1) = #"\n"
			   then text else text ^ "\n"
	    in
		TextIO.StreamIO.output (compilerIn, text);
		Evaluator.eval (text, dummySignal)
	    end

        fun feedFile() =
            let
                val buf = Gtk.textViewGetBuffer (!curtextview)
                val startiter = Gtk.textIterNew()
                val _ = Gtk.textBufferGetStartIter(buf,startiter)
                val enditer = Gtk.textIterNew()
                val _ = Gtk.textBufferGetEndIter(buf,enditer)
                val str = Gtk.textBufferGetText(buf, startiter, enditer, false)
            in
                Gtk.textIterFree startiter;
                Gtk.textIterFree enditer;
                eval str
            end

        fun feedSelection() =
            let
                val buf = Gtk.textViewGetBuffer (!curtextview)
                val startiter = Gtk.textIterNew()
                val enditer = Gtk.textIterNew()
                val sel = Gtk.textBufferGetSelectionBounds(buf,
                                                           startiter,enditer)
            in
                if sel
                then eval (Gtk.textBufferGetText(buf, startiter, enditer, false))
                else ();
                Gtk.textIterFree startiter;
                Gtk.textIterFree enditer
            end
                
        fun feedLine() =
            let
                val buf = Gtk.textViewGetBuffer (!curtextview)
                val cursor = Gtk.textBufferGetInsert(buf)
                val startiter = Gtk.textIterNew()
                val _ = Gtk.textBufferGetIterAtMark(buf,startiter,cursor)
                val enditer = Gtk.textIterCopy(startiter)
                val _ = Gtk.textIterSetLineOffset(startiter, 0)
                val _ = Gtk.textIterForwardToLineEnd(enditer)
                val str = Gtk.textBufferGetText(buf, startiter, enditer, false)
            in
                Gtk.textIterFree startiter;
                Gtk.textIterFree enditer;
                eval str
            end


        fun findNextEOL iter next =
            if next iter then
                let
                    val c = chr (Gtk.textIterGetChar iter)
                in
                    if c = #"\n" then ()
                    else if Char.isSpace c then findNextEOL iter next
                    else findEOP iter next
                end
            else ()
        and findEOP iter next =
            let
                val c = Gtk.textIterGetChar iter
            in
                if c=0 then ()
                else
                    if c=ord #"\n" then
                        findNextEOL iter next
                    else if next iter then
                        findEOP iter next
                    else ()
            end

        fun findNonWS iter next =
            let
                val c = Gtk.textIterGetChar iter
            in
                if c=0 then ()
                else if Char.isSpace (chr c) then
                    (next iter; findNonWS iter next)
                else ()
            end

        fun EOLsBeforeNonWS acc iter next =
            let
                val c = Gtk.textIterGetChar iter
            in
                if c=0 then acc
                else if Char.isSpace (chr c) then
                    (next iter;
                     EOLsBeforeNonWS (acc + (if c = ord #"\n" then 1 else 0)) iter next)
                else acc
            end

        fun paragraphIters(buf) =
            let
                val cursor = Gtk.textBufferGetInsert(buf)
                val startiter = Gtk.textIterNew()
                val _ = Gtk.textBufferGetIterAtMark(buf,startiter,cursor)
                val c = Gtk.textIterGetChar startiter
                val _ = if c = ord #"\n" orelse c=0 then
                            Gtk.textIterBackwardChar startiter else false
                val enditer = Gtk.textIterCopy(startiter)
                val _ = findEOP startiter Gtk.textIterBackwardChar
                val _ = findEOP enditer Gtk.textIterForwardChar
                val _ = findNonWS startiter Gtk.textIterForwardChar
                val _ = findNonWS enditer Gtk.textIterBackwardChar
                val _ = Gtk.textIterForwardChar enditer (* end is exclusive! *)
            in
                (startiter, enditer)
            end

        fun feedParagraph() =
            let
                val buf = Gtk.textViewGetBuffer (!curtextview)
                val (startiter, enditer) = paragraphIters(buf)
                val str = Gtk.textBufferGetText(buf, startiter, enditer, false)
            in
                Gtk.textIterFree startiter;
                Gtk.textIterFree enditer;
                eval (str^"\n")
            end

        fun feedParagraphNewline() =
            let
                val buf = Gtk.textViewGetBuffer (!curtextview)
                val (startiter, enditer) = paragraphIters(buf)
                val str = Gtk.textBufferGetText(buf, startiter, enditer, false)
                val _ = Gtk.textBufferPlaceCursor(buf, enditer)
            in
                case EOLsBeforeNonWS 0 enditer Gtk.textIterForwardChar of
                    0 => Gtk.textBufferInsertAtCursor(buf, "\n\n", 2)
                  | 2 => Gtk.textBufferInsertAtCursor(buf, "\n\n", 2)
                  | _ => Gtk.textBufferPlaceCursor(buf, enditer);
                Gtk.textIterFree startiter;
                Gtk.textIterFree enditer;
                eval (str^"\n")
            end
            
        fun copy() =
            let
                val buf = Gtk.textViewGetBuffer (!curtextview)
            in
                Gtk.textBufferCopyClipboard(buf, clipboard)
            end

        fun paste() =
            let
                val buf = Gtk.textViewGetBuffer (!curtextview)
            in
                Gtk.textBufferPasteClipboard(buf, clipboard,
                                             Gtk.NULL, true)
            end

        fun cut() =
            let
                val buf = Gtk.textViewGetBuffer (!curtextview)
            in
                Gtk.textBufferCutClipboard(buf, clipboard, true)
            end

        fun delete() =
            let
                val buf = Gtk.textViewGetBuffer (!curtextview)
            in
                ignore (Gtk.textBufferDeleteSelection(buf, true, true))
            end

        fun new() =
            let
                val scrolledwindow2_xa = Gtk.adjustmentNew(0.0,0.0,0.0,1.0,0.0,0.0)
                val scrolledwindow2_ya = Gtk.adjustmentNew(0.0,0.0,0.0,1.0,0.0,0.0)
                val scrolledwindow2 = Gtk.scrolledWindowNew(scrolledwindow2_xa,scrolledwindow2_ya)
                val _ = Gtk.scrolledWindowSetShadowType(scrolledwindow2,Gtk.SHADOW_NONE)
                val _ = Gtk.widgetShow scrolledwindow2

                val newSource = Gtk.textViewNew()
                val _ = Gtk.widgetShow newSource
                val _ = Gtk.textViewSetEditable(newSource,true)
                val _ = Gtk.textViewSetJustification(newSource,Gtk.JUSTIFY_LEFT)
                val _ = Gtk.textViewSetWrapMode(newSource,Gtk.WRAP_NONE)
                val _ = Gtk.textViewSetCursorVisible(newSource,true)
                val _ = Gtk.textViewSetPixelsAboveLines(newSource,0)
                val _ = Gtk.textViewSetPixelsBelowLines(newSource,0)
                val _ = Gtk.textViewSetPixelsInsideWrap(newSource,0)
                val _ = Gtk.textViewSetLeftMargin(newSource,0)
                val _ = Gtk.textViewSetRightMargin(newSource,0)
                val _ = Gtk.textViewSetIndent(newSource,0)
                val buf = Gtk.textViewGetBuffer newSource
                val _ = Gtk.textBufferSetText(buf,"",~1)
                val _ = Gtk.containerAdd(scrolledwindow2,newSource)
                val label1 = Gtk.labelNew("New File"^Int.toString (!numberOfPages))
                val _ = Gtk.widgetShow label1
                val _ = Gtk.notebookAppendPage(AliceIdeGUI.notebook1,
                                               scrolledwindow2, label1)
            in
                numberOfPages := (!numberOfPages) + 1
            end

        fun switchPage(cur,view) = (currentPage := cur; curtextview := view)

        fun close () = if !currentPage=0 then ()
                       else (Gtk.notebookRemovePage(AliceIdeGUI.notebook1, !currentPage);
                             currentPage := Gtk.notebookGetCurrentPage AliceIdeGUI.notebook1)
        fun init () =
            let
                val buf = Gtk.textViewGetBuffer AliceIdeGUI.scratchpad
            in
	        OutputWriters.makeWriters {inStream = inText,
					   outStream = outText,
					   errStream = errText,
					   traceStream = traceText,
					   stdOutStream = stdOutText,
					   stdErrStream = stdErrText};
                Gtk.windowAddAccelGroup(AliceIdeGUI.mainwidget,
                                        AliceIdeGUI.Helpers.accelGroup);
                Gtk.widgetAddAccelerator(AliceIdeGUI.paragraphnewline, "activate",
                                         AliceIdeGUI.Helpers.accelGroup,
                                         Key.keyvalToInt Key.K_Return,
                                         Gdk.CONTROL_MASK, Gtk.ACCEL_LOCKED)
            end

    end
