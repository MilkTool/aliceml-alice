(*
 * Author:
 *   Guido Tack <tack@ps.uni-sb.de>
 *
 * Copyright:
 *   Guido Tack, 2003
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Gtk          from "x-alice:/lib/gtk/Gtk"
import structure Gdk          from "x-alice:/lib/gtk/Gdk"
import structure GnomeCanvas from "x-alice:/lib/gtk/GnomeCanvas"

import structure Types        from "Types"
import structure Defaults     from "Defaults"
import structure TreeNode     from "TreeNode"
import structure VisualNode   from "VisualNode"
import structure GtkNode      from "GtkNodes"
import structure ExplorerNode from "ExplorerNode"
import structure ExplorerSearch from "ExplorerSearch"
import structure OptionsWindow from "OptionsWindow"

structure EventHandler =
  struct

  open Types

  fun nodeEvent state serve event =
      case (!state) of
	  SOME(state as ({canvas={canvas=canvas,...},tree=tree,
			  currentNode=currentNode,
			  inspect=inspect,
                          curInspAction=curInspAction,
			  scale=scale,...}:
			 Types.explorer_state)) =>
	  (case event of
	       (_, [Gdk.EVENT event]) =>
	       serve (fn () =>
			 case event of
			     Gdk.EVENT_BUTTON_PRESS {x=x,y=y,...} =>
			     let
				 val (findX, depth) = GtkNode.findByXY(canvas,!scale,
									    x,y)
				 val t = !tree
				 val n = TreeNode.findByX t (depth, 0, findX)
				 val (x,y) = TreeNode.getCenter n
			     in
                                 case ExplorerNode.curNodeStatus n of
                                     Types.FAILED => ()
                                   | _ => 
				     (currentNode := SOME n;
(*                                      let
                                          val N({offset=ref offset, oldOffset=ref oldOffset,
                                                 groupOffset=ref groupOffset, dirty=ref dirty,
                                                 ...}, ref mom, ref ch) = n
                                      in
                                          print ("offset: "^Int.toString offset^"\n");
                                          print "oldOffset: ";
                                          (case oldOffset of NONE => print "NONE"
                                                           | SOME off => print ("SOME "^Int.toString off^"\n"));
                                          print ("groupOffset: "^Int.toString groupOffset^"\n");
                                          print ("dirty: "^(if dirty then "true" else "false")^"\n");
                                          print ("mom: "^(case mom of SOME _ => "SOME" | _ => "NONE")^"\n");
                                          print ("ch: "^Int.toString (Vector.length(ch))^"\n")
                                      end;*)
				      GtkNode.drawShadow state x y n)
			     end
                           | Gdk.EVENT_2BUTTON_PRESS {x=x,y=y,...} =>
			     let
				 val (findX, depth) = GtkNode.findByXY(canvas,!scale,
									    x,y)
				 val t = !tree
				 val n = TreeNode.findByX t (depth, 0, findX)
				 val (x,y) = TreeNode.getCenter n
			     in
                                 case ExplorerNode.curNodeStatus n of
                                     Types.FAILED => ()
                                   | _ => 
				     (currentNode := SOME n;
				      GtkNode.drawShadow state x y n);
                                     List.app (fn (i,s) => if s= !curInspAction then
                                                               i (ExplorerNode.recomputeSpace n)
                                                           else ()) (!inspect)
			     end
			   | _ => ())
	     | _ => ())
	| _ => ()

  val itr = Real.fromInt

  fun destroyMainWindow (mainWindow as ref (SOME {window=window,...})
			 : explorer_state option ref) =
      (Gtk.widgetDestroy window;
       mainWindow:=NONE)
    | destroyMainWindow _ = ()

  fun setBBox (ref (SOME ({canvas={canvas=canvas,...}, ...}: explorer_state)))
	      (minx, maxx, depth) =
      let
	  val xMin   = Real.round((itr (minx-TreeNode.horSpaceI))* (TreeNode.defScale))
	  val xMax   = Real.round((itr (maxx+TreeNode.horSpaceI))* (TreeNode.defScale))
	  val xDim   = abs xMin + (abs xMax)
	  val yDim   = Real.round((itr((depth+2)*TreeNode.verSpaceI) *
				   TreeNode.defScale))
      in
	  GnomeCanvas.setScrollRegion(canvas, itr xMin, 0.0,
				      itr xMax, Real.fromInt yDim);
          GnomeCanvas.requestRedraw(canvas, xMin, 0, xMax, yDim)
      end
    | setBBox _ _ = ()

  fun refresh serve cmw state =
      case !state of
          (SOME (rstate as {canvas={canvas=canvas,...},
                            tree=ref tree,
                            scale=ref scale,
			    currentNode=ref cn,...}
		 : explorer_state)) =>
          let
	      val shape = TreeNode.layoutNode tree
	      val (minx, maxx, depth) = TreeNode.getBBox shape
          in
              setBBox state (minx, maxx, depth);
              Gtk.layoutFreeze canvas;
	      VisualNode.adjust rstate tree 0 0 TreeNode.verSpaceI 0;
	      (case cn of NONE => ()
		        | SOME cn =>
		          let
			      val (x,y) = TreeNode.getCenter cn
		          in
			      GtkNode.drawShadow rstate x y cn
		          end);
              Gtk.layoutThaw canvas;
              GnomeCanvas.setPixelsPerUnit(canvas,scale*Defaults.floatScaleBase)
          end
        | NONE =>(state := !(cmw serve);
		  refresh serve cmw state)

  fun exitHandler serve cmw state _ = (serve (fn () => destroyMainWindow state))
  fun nodeHideHandler serve cmw state _ = (serve (fn () =>
						 (VisualNode.toggleHide state;
						  refresh serve cmw state)))
  fun nodeUnhideHandler serve cmw state _ = (serve (fn () =>
						   (VisualNode.unhideAll state;
						    refresh serve cmw state)))
  fun hideFailedHandler serve cmw state _ = (serve (fn () =>
						   (VisualNode.hideFailed state;
						    refresh serve cmw state)))

  fun exploreOneHandler serve refresh state _ = (serve (fn () =>
                                                       case !state of
                                                           SOME {currentNode=ref (SOME cn),...} =>
                                                           ExplorerSearch.search serve state refresh 1 (SOME cn)
                                                         | _ => ()))
  fun exploreAllHandler serve refresh state _ = (serve (fn () =>
                                                           case !state of
                                                               SOME {currentNode=ref (SOME cn),...} =>
                                                               ExplorerSearch.search serve state refresh 0 (SOME cn)
                                                             | _ => ()))

  fun exploreNHandler serve refresh state _ = (serve (fn () =>
                                                           case !state of
                                                               SOME {currentNode=ref (SOME cn),breakAfter=ref breakAfter,...} =>
                                                               ExplorerSearch.search serve state refresh breakAfter (SOME cn)
                                                             | _ => ()))
                                                
  fun resetHandler serve refresh state _ = (serve (fn () =>
                                                      case !state of
                                                          SOME {rootSpace=ref (SOME rs),...} =>
                                                          ExplorerSearch.initSearch serve state refresh rs
                                                        | _ => ()))

  fun selectInspectionAction serve (state : explorer_state option ref) event = 
      (serve (fn () =>
                 case !state of
                     SOME {curInspAction=curInspAction,...} =>
                     (case event of (obj, _) =>
                                    if (Gtk.checkMenuItemGetFieldActive obj)=1 then
                                        let
                                            val label = Gtk.binGetChild obj
                                        in
                                            curInspAction := Gtk.labelGetText label
                                        end
                                    else
                                        ())
                   | _ => ()))

  fun viewOptionsHandler mw serve state _ =
      let
          val configure = OptionsWindow.newOptionsWindow mw serve state
      in
          Gtk.widgetShowAll configure
      end

  fun debugHandler serve state _ = (serve (fn () =>
                                              case !state of
                                                  SOME {debug=debug,...} =>
                                                  Types.setDebug state (not (!debug))
                                                | NONE => ()))

  end