(*
 * Author:
 *   Guido Tack <tack@ps.uni-sb.de>
 *
 * Copyright:
 *   Guido Tack, 2003
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Core  from "x-alice:/lib/gtk/Core"
import structure Space from "x-alice:/lib/gecode/Space"

structure Types =
  struct

  datatype status = FAILED | SOLVED | CHOICE | UNKNOWN
  type node_info = {offset : int ref,
		    oldOffset : int option ref,
		    groupOffset : int ref,
		    status : status ref,
                    openChildren : int ref,
		    hidden : bool ref,
		    dirty  : bool ref,
		    hasSolBelow : bool ref,
		    shape : (int * int) list ref,
		    vNode : Core.object option ref,
		    space : Space.space option ref,
		    alternative : int,
		    connection : Core.object option ref}
		   
  datatype tree = N of node_info * tree option ref * tree vector ref

  type explorer_state = {canvas : {canvas : Core.object,
                                   rootGroup : Core.object ref,
			           actionGroup : Core.object ref,
			           shadowGroup : Core.object ref,
                                   actionHandler : int ref},
			 tree : tree ref,
                         rootSpace : Space.space option ref,
			 inspect : ((Space.space -> unit) * string) list ref,
                         curInspAction : string ref,
			 currentNode : tree option ref,
                         refreshAfter : int ref,
                         breakAfter : int ref,
                         hideFailed : bool ref,
                         debug : bool ref,
			 window : Core.object,
			 menu : {inspectionActions : Core.object ref},
                         status : {choice : int ref,
                                   failed : int ref,
                                   solved : int ref,
                                   contextId : int ref},
                         cancelSearch : bool ref,
			 scale : real ref}

  fun setTree (ref (SOME ({tree=tree,...}: explorer_state))) newTree =
      tree:=newTree
    | setTree _ _ = ()

  fun debug (ref (SOME ({debug=debug,...}: explorer_state))) = !debug
    | debug _ = false

  fun setDebug (ref (SOME ({debug=debug,...}: explorer_state))) flag =
      debug:=flag
    | setDebug _ _ = ()

  (* Status accessors *)
  fun getSearchState (ref (SOME ({status={choice,failed,solved,...},...}:
                                 explorer_state))) =
      (!choice,!failed,!solved)
  fun resetSearchState (ref (SOME ({status={choice,failed,solved,...},...}:
                                   explorer_state))) =
      (choice := 0; failed := 0; solved := 0)

  fun addChoice (ref (SOME ({status={choice,...},...}:
                            explorer_state))) =
      (choice := (!choice) + 1)

  fun addFailed (ref (SOME ({status={failed,...},...}:
                            explorer_state))) =
      (failed := (!failed) + 1)

  fun addSolved (ref (SOME ({status={solved,...},...}:
                            explorer_state))) =
      (solved := (!solved) + 1)

  fun cancelSearch (ref (SOME ({cancelSearch=cs,...}:
                               explorer_state))) =
      if !cs then (cs := false; true) else false

  fun setCancelSearch (ref (SOME ({cancelSearch=cs,...}:
                               explorer_state))) =
      cs := true
    | setCancelSearch _ = ()

  fun resetCancelSearch (ref (SOME ({cancelSearch=cs,...}:
                               explorer_state))) =
      cs := false
    | resetCancelSearch _ = ()

  end
