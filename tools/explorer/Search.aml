(*
 * Author:
 *   Guido Tack <tack@ps.uni-sb.de>
 *
 * Copyright:
 *   Guido Tack, 2003
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure TreeNode     from "TreeNode"
import structure Types        from "Types"
import structure ExplorerNode from "ExplorerNode"

structure Search =
struct
    open TreeNode

    fun explore (node, callBack) =
        let
            fun dfe node =
                case ExplorerNode.noOfChildren node of
                    0 => (case ExplorerNode.nodeStatus node of
                              Types.SOLVED => callBack()
                            | _ => ())
                  | 2 =>
                    let val left = ExplorerNode.getLeftChild node
                    in if ExplorerNode.isUnknown left 
                          orelse ExplorerNode.hasOpenChildren left then
                           dfe left else ();
                    let val right = ExplorerNode.getRightChild node
                    in if ExplorerNode.isUnknown right 
                          orelse ExplorerNode.hasOpenChildren right then
                           dfe right else ()
                    end
                    end
                  | _ => raise Empty
        in
            dfe node
        end

(*
    fun bab (space, constrain) =
	let
	    fun babe fs bs best =
		case fs of
		    nil =>
		    (case bs of nil => best
			      | b::br => (constrain(b, valOf best);
					  babe [b] br best))
		  | f::fr =>
		    case Space.status f of
			Space.FAILED => (Space.discard f;
					 babe fr bs best)
		      | Space.SOLVED => babe nil (fr@bs) (SOME f)
		      | Space.BRANCH =>
			let
			    val c = Space.clone f
			in
			    Space.commit(f, 1);
			    Space.commit(c, 2);
			    babe (f::c::fr) bs best
			end
	in
	    babe [Space.clone space] nil NONE
	end
*)
end
