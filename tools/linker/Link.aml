(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Signature          from "x-alice:/lib/system/Signature"
import structure FromEqHashKey      from "x-alice:/lib/utility/HASH_KEY-sig"
import structure MkHashImpMap       from "x-alice:/lib/utility/MkHashImpMap"
import structure MkDepthFirstSearch from "x-alice:/lib/utility/MkDepthFirstSearch"
import structure Url                from "x-alice:/lib/utility/Url"
import structure Label              from "x-alice:/lib/rtt/Label"
import signature LINK               from "LINK-sig"
import structure MyComponent        from "MyComponent"

structure Link :> LINK =
    struct
	datatype boundary =
	    INCLUDE of string
	  | EXCLUDE of string

	exception Empty
	exception Mismatch of Url.t * Url.t
	exception Conflict of Url.t
	exception Cyclic

	structure UrlHashKey = FromEqHashKey(Url)
	structure UrlMap = MkHashImpMap(UrlHashKey)

	fun signMatches (SOME s1, SOME s2) = Signature.matches (s1, s2)
	  | signMatches (_, _) = true

	fun signIntersect (sign1, sign2) = SOME sign1   (*--** *)

	fun isExcluded (url, boundary) =
	    isExcluded' (Url.toString url, boundary, 0, Vector.length boundary)
	and isExcluded' (s, boundary, i, n) =
	    if i = n then true
	    else
		case Vector.sub (boundary, i) of
		    INCLUDE s' => if String.isPrefix s' s then false
				  else isExcluded' (s, boundary, i + 1, n)
		  | EXCLUDE s' => if String.isPrefix s' s then true
				  else isExcluded' (s, boundary, i + 1, n)

	fun collect boundary root =
	    let
		val componentMap = UrlMap.new ()
		val includeMap = UrlMap.new ()
		val excludeMap = UrlMap.new ()

		fun collect' (url, parent, expectedSign) =
		    if UrlMap.member (componentMap, url) then
			let
			    val component =
				UrlMap.lookupExistent (componentMap, url)
			    val actualSign = MyComponent.sign component
			in
			    if signMatches (actualSign, expectedSign) then ()
			    else raise Mismatch (url, parent)
			end
		    else if UrlMap.member (excludeMap, url) then
			let
			    val sign' = UrlMap.lookupExistent (excludeMap, url)
			in
			    case signIntersect (expectedSign, sign') of
				SOME sign'' =>
				    UrlMap.insert (excludeMap, url, sign'')
			      | NONE => raise Conflict url
			end
		    else if isExcluded (url, boundary) then
			UrlMap.insert (excludeMap, url, expectedSign)
		    else
			let
			    val component = MyComponent.load url
			    val actualSign = MyComponent.sign component
			    val _ = if signMatches (actualSign, expectedSign)
				    then () else raise Mismatch (url, parent)
			    val component' =
				if url = root then component
				else MyComponent.stripImportSigns component
			    val _ =
				UrlMap.insert (componentMap, url, component')
			    val resolve = Url.resolve url
			    val importUrls =
				Vector.map
				(fn (label, s, sign) =>
				    let
					val url' = resolve (Url.fromString s)
				    in
					collect' (url', url, sign); url'
				    end) (MyComponent.imports component)
			in
			    UrlMap.insert (includeMap, url, importUrls)
			end
	    in
		collect' (root, Url.empty, NONE);
		if UrlMap.isEmpty includeMap then raise Empty else ();
		{componentMap, includeMap, excludeMap}
	    end

	structure DepthFirstSearch =
	    MkDepthFirstSearch(structure Key = UrlHashKey
			       structure Map = UrlMap)

	fun sort (includeMap, excludeMap) =
	    let
		val graph = UrlMap.new ()
	    in
		UrlMap.appi (fn (url, urls) =>
				UrlMap.insert (graph, url, Vector.toList urls))
			    includeMap;
		UrlMap.appi (fn (url, _) => UrlMap.insert (graph, url, nil))
			    excludeMap;
		List.map (fn urls =>
			     case urls of
				 [url] => url
			       | _ => raise Cyclic)
			 (DepthFirstSearch.search graph)
	    end

	fun rewrite rewrites s =
	    rewrite' (s, rewrites, 0, Vector.length rewrites)
	and rewrite' (s, rewrites, i, n) =
	    if i = n then s
	    else
		let
		    val (fro, to) = Vector.sub (rewrites, i)
		in
		    if String.isPrefix fro s then
			to ^ String.extract (s, String.size fro, NONE)
		    else rewrite' (s, rewrites, i + 1, n)
		end

	fun build (root, order, componentMap, includeMap, excludeMap,
		   rewrite) =
	    let
		fun getComponent url =
		    UrlMap.lookupExistent (componentMap, url)
		val excludes =
		    Vector.fromList (UrlMap.foldi (fn (url, _, rest) =>
						      url::rest)
						  nil excludeMap)
		val includes =
		    Vector.fromList (UrlMap.foldi (fn (url, _, rest) =>
						      url::rest)
						  nil excludeMap)
		val urlToIndexMap = UrlMap.new ()
		val _ =
		    Vector.appi (fn (i, url) =>
				    UrlMap.insert (urlToIndexMap, url,
						   (true, i)))
				(includes, 0, NONE)
		val _ =
		    Vector.appi (fn (i, url) =>
				    UrlMap.insert (urlToIndexMap, url,
						   (false, i)))
				(excludes, 0, NONE)
		val imports =
		    Vector.mapi (fn (i, url) =>
				    (Label.fromInt i,
				     rewrite (Url.toString url),
				     UrlMap.lookupExistent (excludeMap, url)))
				(excludes, 0, NONE)
		val bodies =
		    Vector.map (fn url => MyComponent.body (getComponent url))
			       includes
		fun body #[(_, str)] = str   (*--** UNFINISHED *)
		val sign = MyComponent.sign (getComponent root)
	    in
		MyComponent.new {imports, body, sign}
	    end

	fun link {root, boundary, rewrite = rewrites} =
	    let
		val {componentMap, includeMap, excludeMap} =
		    collect boundary root
		val order = sort (includeMap, excludeMap)
	    in
		build (root, order, componentMap, includeMap, excludeMap,
		       rewrite rewrites)
	    end
    end
