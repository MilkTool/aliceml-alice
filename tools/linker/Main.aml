(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure TextIO      from "../lib/system/TextIO"
import structure OS          from "../lib/system/OS"
import structure CommandLine from "../lib/system/CommandLine"
import structure Url         from "../lib/utility/Url"
import structure MyComponent from "MyComponent"
import structure Link        from "Link"

signature MAIN =
    sig
	val main: string list -> OS.Process.status
    end

structure Main :> MAIN =
    struct
	exception Syntax

	val root: string option ref = ref NONE
	val outputFile: string option ref = ref NONE
	val boundary: Link.boundary list ref = ref nil
	val rewrite: (string * string) list ref = ref nil

	fun error s =
	    (TextIO.output (TextIO.stdErr, "alicelink: " ^ s);
	     OS.Process.failure)

	fun usage s =
	    (TextIO.output
	     (TextIO.stdErr,
	      "alicelink: " ^ s ^ "\n" ^
	      "Usage: alicelink <options> <root url> -o <output file>\n" ^
	      "Options:\n" ^
	      "--include PREFIX,...,PREFIX\n" ^
	      "--exclude PREFIX,...,PREFIX\n" ^
	      "--rewrite FROM=TO,...,FROM=TO\n");
	     OS.Process.failure)

	fun start (root, outputFile) =
	    let
		val component =
		    Link.link {root = Url.fromString root,
			       boundary = Vector.fromList (!boundary),
			       rewrite = Vector.fromList (!rewrite)}
	    in
		MyComponent.save (outputFile, component);
		OS.Process.success
	    end
	    handle Link.Empty =>
		       error "root component has been excluded\n"
		 | Link.Mismatch (url, url') =>
		       error ("signature of component\n" ^
			      "   " ^ Url.toString url ^ "\n" ^
			      "does not fulfill requirements of component\n" ^
			      "   " ^ Url.toString url' ^ "\n")
		 | Link.Conflict url =>
		       error ("excluded component\n" ^
			      "   " ^ Url.toString url ^ "\n" ^
			      "imported multiply " ^
			      "with incompatible signatures\n")
		 | Link.Cyclic urls =>
		       error ("import cycle detected:\n" ^
			      String.concat (List.map
					     (fn url =>
						 "   " ^ Url.toString url ^
						 "\n") urls))

	fun csl s = String.tokens (fn c => c = #",") s

	fun fet s = fet' (s, 0, String.size s)
	and fet' (s, i, n) =
	    if i = n then raise Syntax
	    else if String.sub (s, i) = #"=" then
		(String.substring (s, 0, i), String.extract (s, i + 1, NONE))
	    else fet' (s, i + 1, n)

	fun main ("--include"::includes::rest) =
	    (boundary := (!boundary @ List.map Link.INCLUDE (csl includes));
	     main rest)
	  | main ("--exclude"::excludes::rest) =
	    (boundary := (!boundary @ List.map Link.EXCLUDE (csl excludes));
	     main rest)
	  | main ("--rewrite"::rules::rest) =
	    ((rewrite := (!rewrite @ List.map fet (csl rules)); main rest)
	     handle Syntax => usage "illegal rewrite rule syntax")
	  | main ("-o"::name::rest) =
	    (case !outputFile of
		 NONE => (outputFile := SOME name; main rest)
	       | SOME _ => usage "only one output file name may be given")
	  | main (name::rest) =
	    (case !root of
		 NONE => (root := SOME name; main rest)
	       | SOME _ => usage "only one root component may be given")
	  | main nil =
	    (case (!root, !outputFile) of
		 (SOME root, SOME outputFile) => start (root, outputFile)
	       | (NONE, _) => usage "missing root component"
	       | (_, NONE) => usage "no output file name given")
    end

val _ = OS.Process.exit (Main.main (CommandLine.arguments ()))
