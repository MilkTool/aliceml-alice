import signature JACKE from "JACKE-sig"
import structure AbsSyn from "AbsSyn"
import structure BoolVector from "container"
import structure LrParserEng from "../../yacc/bootstrap/LrParser"

structure Jacke :> JACKE =
    struct

	open AbsSyn

	(* Jacke needs this error-function *)
	fun parseError pos = raise Error (Int.toString pos)

	fun pError (e, po) =
	    raise Error ("Parse Error in file " ^ (!errorFile)
			 ^ "\nin line(s) " ^ posToString po ^ ": " ^ e ^ "\n")
		
	(* makeVector : bool array -> BoolVector.vector
	 * converts array to Vector
	 *)
	fun makeVector c = (BoolVector.tabulate (257, (fn x => Array.sub(c,x))))
	
	
	(* used by: stringToExp
	 * shrink : char list * char list -> char list, takes (char list, nil),
	 * combines several chars to one (if possible)
	 * and returns the new char list
	 * Example: shrink([#"\\",#"1",#"2",#"3",#"3"], []) = [#"\123",#"3"]
	 *                                                  = [#"{",   #"3"]
	 *)
	fun shrink (nil, xs, po) = rev xs
	  | shrink (#"\\"::cs, xs, po) = shrink (escape (cs, xs, po))
	  | shrink (c::cs, xs, po) = shrink (cs, c::xs, po)
    
    
	(* escape takes (char list, char list)
	 * reads an escaped char from the first list,
	 * attaches it to the second list
	 * and returns the pair
	 *)
	and escape (#"a"::cs, xs, po)  = (cs, #"\007"::xs, po)
	  | escape (#"b"::cs, xs, po)  = (cs, #"\008"::xs, po)
	  | escape (#"t"::cs, xs, po)  = (cs, #"\009"::xs, po) 
	  | escape (#"n"::cs, xs, po)  = (cs, #"\010"::xs, po)
	  | escape (#"v"::cs, xs, po)  = (cs, #"\011"::xs, po)
	  | escape (#"f"::cs, xs, po)  = (cs, #"\012"::xs, po)
	  | escape (#"r"::cs, xs, po)  = (cs, #"\013"::xs, po)
	  | escape (#"\""::cs, xs, po) = (cs, #"\""::xs, po)
	  | escape (#"\\"::cs, xs, po) = (cs, #"\\"::xs, po)
	  | escape (#"^"::cs, xs, po)  = escape2 (cs, xs, po)
	  | escape (c::cs, xs, po)     =
	    if Char.isDigit c then escape3 (c::cs, xs, po)
	    else if Char.isSpace c then escape4 (cs, xs, po)
		 else pError ( "bad escape character \\"
			      ^ (Char.toString c), po)
	  | escape ( _ , _ , po)       = pError ("bad escape character \\", po)
			     
			     
	(* escape2 scans for chars from #"\^@" to #"\^_"
	 *)
	and escape2 (c::cs, xs, po) =
	    let 
		val range = Char.ord c 
	    in
		if range>63 andalso range<96
		    then (cs, Char.chr(range-64) ::xs, po)
		else pError ("bad escape character \\^" ^ (Char.toString c), po)
	    end
	  | escape2 ( _   , _ , po)   = pError ("bad escape character \\^", po)
    
    
	(* escape3 scans for chars like #"\123"
	 *)
	and escape3 (a::b::c::cs, xs, po) =
	    let
		val zero = Char.ord #"0"
		val a_ = Char.ord a - zero
		val b_ = 
		    if Char.isDigit b then Char.ord b - zero
		    else pError ("bad escape character \\"
				 ^ (implode [a,b,c]), po)
		val c_ =
		    if Char.isDigit c then Char.ord c - zero
		    else pError ("bad escape character \\"
				 ^ (implode [a,b,c]), po)
		val num = 100*a_+10*b_+c_
	    in 
		if num < 256 then (cs, Char.chr(num)::xs, po)
		else pError ("bad escape character \\" ^ (implode [a,b,c]), po)
	    end
	  | escape3 (cs, xs, po) =
	    pError ("bad escape character \\" ^ implode cs, po)
    
    
	(* escape4 scans for end of a gap like #" \n \\"
	 *)
	and escape4 (#"\\"::cs, xs, po) = (cs, xs, po)
	  | escape4 (c::cs, xs, po) =
	    if Char.isSpace c then escape4 (cs, xs, po)
	    else pError ("bad character in gap: " ^ Char.toString c, po)
	  | escape4 ( _   , _ , po) = pError ("bad gap", po)


	(* wildcard : unit -> BoolVector.vector
	 * returns a vector filled with true, except for 'eof'
	 *)
	fun wildcard ( ) =
	    let
		val c = Array.array (257, true)
	    in
		Array.update (c, 256, false);
		makeVector c
	    end
    
    
	(* used by: stringToExp
	 * oneChar : char -> AbsSyn.regexp
	 * returns CHARS, a vector filled with false except for ord char
	 *)
	fun oneChar (c, p) =
	    let
		val arr = Array.array (257, false)
	    in
		(Array.update(arr,Char.ord c, true);
		 CHARS (makeVector arr, 0, p) )
	    end


	(* stringToExp string * position -> regexp
	 * returns the regexp representing the string
	 *)
	fun stringToExp (s, po) =
	    let
		val xs = shrink (explode
				 (String.substring(s, 1, String.size s - 2)),
				 nil, po)
		fun first nil = (nil, EPS)
		  | first (c::cs) = (cs, oneChar (c, po) )
		fun fold (nil , a) = a
		  | fold (c::cs, a) = fold (cs, CAT(a, oneChar (c, po), po))
	    in
		fold (first xs)
	    end
    
		    
	(* makeRep : regexp * int * int -> regexp
	 * returns a regexp representing the given regexp repeated n to m times
	 *)
	fun makeRep (r, n, m, p) =
	    let
		val i = m-n
		fun concat 0 = AbsSyn.EPS
		  | concat 1 = r
		  | concat y = AbsSyn.CAT (concat (y-1), r, p)
		val t = concat n
		fun alt (0, dat) = dat 
		  | alt (1, AbsSyn.EPS) = AbsSyn.ALT (AbsSyn.EPS, r, p) 
		  | alt (x, dat) =
		    if x < 0 then pError ("bad repetition", p)
		    else alt (x-1, AbsSyn.CAT (dat, AbsSyn.ALT (r, AbsSyn.EPS,
								p), p))
	    in
		alt (i, t)
	    end


	(* makeArray : string * bool -> bool array
	 * returns an array with all fields (except the char ords of the string)
	 * set to the bool value
	 * example: makeArray ("A-Z -", true) =
	 *            false for A,B,...,Z,' ','-' and true for the rest
	 *)
	fun makeArray (s, b, po) =
	    let
		val nb = not b
		val c = Array.array (257, b)
		val cl = shrink (explode (String.substring (s, 1,
							    String.size s - 2)),
				 nil, po)
		fun insert (a::(#"-")::b::ys, x) =
		    (insertSequence (a, b, nb, x); insert (ys,x) )
		  | insert (a::ys, x) = (Array.update(x,Char.ord a,nb);
					 insert (ys, x) )
		  | insert (nil,   x) = x
	    in
		Array.update (c, 256, false);
		insert (cl, c)
	    end
    
    
	(* insertSequence : char * char * bool * bool array -> unit
	 * updates the array x from a to b with bool value t
	 *)
	and insertSequence (a,b,t,x) = 
	    let
		val i = ref (Char.ord a)
		val j = Char.ord b
	    in
		while !i<=j do
		    (Array.update(x,!i,t);
		     i:= !i + 1 )
	    end


	(* addEof : lrule list -> lrule list -> lrule list
	 * adds "eof" to each lrule in the list
	 *)
	fun addEof [] ys = rev ys
	  | addEof ((LRULE (reg, act, pos)) :: lrl) ys =
	    addEof lrl (LRULE (CAT(reg, REGID ("eof", (~1, ~1)), pos),
			       act, pos) :: ys)


	type intint = int * int
	type stringintint = string * int * int
	type intintint = int * int * int
	type realintint = real * int * int

        token
	    REGEXP of intint
	  | LEXER of intint
	  | RCASE of intint
	  | OF of intint
	  | AND of intint
	  | MLKEY of stringintint
	  | EQ of intint
	  | LPAR of intint
	  | RPAR of intint
	  | TIMES of intint
	  | PLUS of intint
	  | QMARK of intint
	  | DRARROW of intint
	  | BAR of intint
	  | CARAT of intint
	  | LBRACK of intint
	  | RBRACK of intint
	  | COMMA of intint
	  | LBRACE of intint
	  | RBRACE of intint
	  | WILDCARD of intint
	  | MLOP of stringintint
	  | NUM of intintint
	  | REAL of realintint
	  | STRING of stringintint
	  | ID of stringintint
	  | MLTOK of stringintint
	  | EOF of intint

	assocl DRARROW
	assocl BAR

	fun tokToString (s, _, _) = s

	fun tokToInt (i, _, _) = i
	 
	fun tokToReal (r, _, _) = r

        rule start = e1 as program       => (e1)

	and program =
	    e1 as explist, e2 as lexdec' => (SML (EXP (e1, (e1left, e1right)),
						  (e1left, e1right)) :: e2)
	  | e1 as explist                => ([SML (EXP (e1, (e1left, e1right)),
						   (e1left, e1right))])

	and lexdec' =
	    e1 as lexdec, e2 as lexdec' => (e1 :: e2)
	  | e1 as lexdec                => ([e1])

	and lexdec =
	    e1 as REGEXP, e2 as regbind => (REG (e2, (e1left, e2right)))
	  | e1 as LEXER, e2 as lexbind  => (LEX (e2, (e1left, e2right)))
	  | e1 as MLKEY, e2 as explist  =>
		(SML (EXP (ATEXP (tokToString e1, (e1left, e1right)) :: e2,
			   (e1left, e2right)), (e1left, e2right)))

	and regbind =
	    e1 as ID, EQ, e2 as regexp'', AND, e3 as regbind =>
		(REGBIND (tokToString e1, e2, (e1left, e2right)) :: e3)
	  | e1 as ID, EQ, e2 as regexp'' =>
		([REGBIND (tokToString e1, e2, (e1left, e2right))])

	and lexbind =
	    e1 as ID, EQ, e2 as lmatch, AND, e3 as lexbind =>
		(LEXBIND (tokToString e1, LMATCH (e2, (e2left, e2right)),
			  (e1left, e2right))
		 :: e3)
	  | e1 as ID, EQ, e2 as lmatch =>
		([LEXBIND (tokToString e1,
			   LMATCH (e2, (e2left, e2right)), (e1left, e2right) )])

	and lmatch =
	    e1 as lrule, BAR, e2 as lmatch => (e1 :: e2)
	  | e1 as lrule	                   => ([e1])     prec DRARROW

	and lrule =
	    e1 as regexp'', DRARROW, LPAR, e2 as explist, e3 as lexdec', RPAR =>
		(LRULE (e1, PAREXP (SML (EXP (e2, (e2left, e2right)),
					 (e2left, e2right)) :: e3,
				    (e2left, e3right)),	(e1left, e3right)))
	  | e1 as regexp'', DRARROW, LPAR, e2 as explist, RPAR =>		
		(LRULE (e1, PAREXP ([(SML (EXP (e2, (e2left, e2right)),
					   (e2left, e2right)))],
				    (e2left, e2right)), (e1left, e2right)))

	and regexp'' =
	    e1 as regexp', BAR, e2 as regexp'' =>
		(ALT (e1, e2, (e1left, e2right)))
	  | e1 as regexp'                      => (e1)

	and regexp' =
	    e1 as regexp1                => (e1)
	  | e1 as regexp1, e2 as regexp' => (CAT (e1, e2, (e1left, e2right)))



	and regexp1 =
	    LPAR, e1 as regexp'', RPAR => (e1)
	  | e1 as WILDCARD => (CHARS (wildcard (), 0, (e1left, e1right)))
	  | LBRACK, e1 as STRING, RBRACK =>
		(CHARS (makeVector (makeArray (tokToString e1, false,
					       (e1left, e1right))),
			0, (e1left, e1right)))
	  | LBRACK, CARAT, e1 as STRING, RBRACK =>
		(CHARS (makeVector (makeArray (tokToString e1, true,
					       (e1left, e1right))),
			0, (e1left, e1right)))
	  | e1 as STRING => (stringToExp (tokToString e1, (e1left, e1right)))
	  | e1 as ID => (REGID (tokToString e1, (e1left, e1right)))
	  | e1 as regexp1, e2 as TIMES => (CLOSURE (e1, (e1left, e2right)))
	  | e1 as regexp1, e2 as PLUS =>
		(CAT (e1, CLOSURE (e1, (e1left, e2right)), (e1left, e2right)))
	  | e1 as regexp1, e2 as QMARK => (ALT (EPS, e1, (e1left, e2right)))
	  | e1 as regexp1, LBRACE, e2 as NUM, RBRACE =>
		(makeRep (e1, tokToInt e2, tokToInt e2, (e1left, e2right)))
	  | e1 as regexp1, LBRACE, e2 as NUM, COMMA, e3 as NUM, RBRACE =>
		(makeRep (e1, tokToInt e2, tokToInt e3, (e1left, e3right)))

	and explist =
	    e1 as caseexp, e2 as explist => (e1 :: e2)
	  | skip                         => ([])

	and explist' =
	    e1 as atexp' => ([e1])
	  | e1 as atexp', e2 as explist' => (e1 :: e2)

	and caseexp =
	    e1 as RCASE, e2 as explist', OF, e3 as lmatch =>
		(REGCASE (e2, LMATCH (addEof e3 [], (e3left, e3right)),
			  (e1left, e3right)))
	  | e1 as atexp => (e1)

	and atexp =
	    e1 as atexp' => (e1)
	  | e1 as OF     => (ATEXP ("of", (e1left, e1right)))

	and atexp' =
	    e1 as AND       => (ATEXP ("and", (e1left, e1right)))
	  | e1 as EQ        => (ATEXP ("=", (e1left, e1right)))
	  | e1 as TIMES     => (ATEXP ("*", (e1left, e1right)))
	  | e1 as PLUS      => (ATEXP ("+", (e1left, e1right)))
	  | e1 as QMARK     => (ATEXP ("?", (e1left, e1right)))
	  | e1 as DRARROW   => (ATEXP ("=>", (e1left, e1right)))
	  | e1 as BAR       => (ATEXP ("|", (e1left, e1right)))
	  | e1 as CARAT     => (ATEXP ("^", (e1left, e1right)))
	  | e1 as LBRACK    => (ATEXP ("[", (e1left, e1right)))
	  | e1 as RBRACK    => (ATEXP ("]", (e1left, e1right)))
	  | e1 as COMMA     => (ATEXP (",", (e1left, e1right)))
	  | e1 as LBRACE    => (ATEXP ("{", (e1left, e1right)))
	  | e1 as RBRACE    => (ATEXP ("}", (e1left, e1right)))
	  | LPAR, e1 as program, RPAR => (PAREXP (e1, (e1left, e1right)))
	  | e1 as WILDCARD  => (ATEXP ("_", (e1left, e1right)))
	  | e1 as MLOP      => (ATEXP (tokToString e1, (e1left, e1right)))
	  | e1 as NUM       => (ATEXP (Int.toString (tokToInt e1),
				       (e1left, e1right)))
	  | e1 as REAL      => (ATEXP (Real.toString (tokToReal e1),
				       (e1left, e1right)))
	  | e1 as STRING    => (ATEXP (tokToString e1, (e1left, e1right)))
	  | e1 as ID        => (ATEXP (tokToString e1, (e1left, e1right)))
	  | e1 as MLTOK     => (ATEXP (tokToString e1, (e1left, e1right)))
		

	parser eval = start
	
    end
