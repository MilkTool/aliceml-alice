- structure of jacke (preliminary)

jackeParser.sml -> AbsSyn.sml (via Lexer & Parser)


- nicht funktionierende Beispiele:
1. ueberdecken von regeln

let rule A = ... bla ...
in let rule A = ...blub ...
       parser p1 = A
   in ... end
   let parser p2 = A
   in ... end
end

p1, p2 zwei verschiedene parser !


Notes by BG (while trying to figure out how this all works):
=============================================================

Internally we use Token.TOKEN values which in turn contain both the
locations and SValue.svalue which is a datatype generated by aliceyacc
containing (tokens & rule markers) + semantic values (i.e closures).

So we have to wrap the tokens returned by the user supplied lexer.
This is done by the (generated) function toInternalToken which essentially
wraps every token T a (where a is the value associated with the token)
into SValue.T (fn () => a).

Things actually are a little more complicated cause we wrap the whole
thing again (twice!!) using the higher order procedure mkGet which calls
it's first argument the first time it is called and the second every
other time.

Why do we do that?  As briefly mentioned above those internal tokens
actually encode -- at least partially -- the current state of the parser.
And at the beginning we need a certain this-is-the-start-of-the-first-rule
token and not the first real token!  But we also want the locations of
the first token as we don't know how to generate dummy values of that
type as the parser is polymorphic in the location type.  Therefore we
actually call the lexer the first time when the parser and lexer are
combined store the returned token and use the returned locations in the
this-is-the-start token.  mkGet is then used to generate a lexer function
which actually represents a stream of values like this:

this-is-start-token, actual-first-lexer-token, wrapped-lexer...

Notice that aliceyacc currently handles EOF implicitely that is if the end of
the input has not be reached by the time the main has been handled and syntax
error is signaled likewise if EOF is reached before a rule has been handled
completely.  So you don't really need an EOF token or something like that.


