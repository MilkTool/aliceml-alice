(*
 * Authors:
 *   Guido Tack <tack@ps.uni-sb.de>
 *
 * Copyright:
 *   Guido Tack, 2005
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Stream from "x-alice:/lib/data/Stream"
import structure Gui from "Gui"
import structure Gtk from "x-alice:/lib/gtk/Gtk"
import structure Gdk from "x-alice:/lib/gtk/Gdk"
import structure OutputWriters from "OutputWriters"
import structure Evaluator from "Evaluator"
import structure Buffer from "Buffer"
import structure Config from "Config"
import structure FileDialog from "FileDialog"
import structure SearchDialog from "SearchDialog"
import structure Core from "x-alice:/lib/gtk/Core"
import structure Inspector from "x-alice:/lib/tools/Inspector"
import structure BufferHighlight from "BufferHighlight"

structure GuiMain =
    struct
        (* Buffers *)

        val clipboard = Gtk.clipboardGet(Gdk.atomIntern("CLIPBOARD", false))
        datatype active_view = COMPILER | STDSTREAMS | BUFFER of Gtk.object
        val curtextview = ref COMPILER

        val numberOfPages = ref 0
        val currentPage = ref ~1

        val pages = ref nil
        fun removePage i =
            let
                val (pre,post) = List.split(!pages, i+1)
                val (pre,p) = case List.split(pre,i) of
                                  (pre, [p]) => (pre,p)
                                | _ => raise Match
                                             (* to make compiler happy *)
            in
                (pages := (List.take(pre,i)@post));
                p
            end
        fun addPage p = pages := (!pages)@[p]
        fun getPage i = List.nth (!pages, i)
        fun getCurrentPage () =
            case !currentPage of ~1 => NONE
                               | i => SOME (getPage i)
	fun findPage id = Option.map #1 (List.findi (fn (_,i) => i=id) (!pages))

        (* Evaluation *)

        val evalSignal = ref NONE

        fun eval echo "" = ()
	  | eval echo text =
            case (!evalSignal) of NONE =>
	    let
                val signalP = Promise.promise()
		val signal = Promise.future signalP
		val text = if String.sub (text, String.size text - 1) = #"\n"
			   then text else text ^ "\n"
                fun find(i ,str) =
                    if i=String.size str then ""
                    else if Char.isSpace (String.sub(str,i)) then
                        find(i+1, str)
                    else String.extract(str, i, NONE)
	    in
                evalSignal := SOME signalP;
		if echo then TextIO.StreamIO.output (OutputWriters.compilerIn, find(0,text))
                else ();
		spawn (Evaluator.eval (text, signal);
                       evalSignal := NONE)
	    end
                                | SOME _ =>
                                  FileDialog.message "Still evaluating."

        fun feedFile() =
            case (!curtextview) of BUFFER view =>
            let
                val buf = Gtk.textViewGetBuffer view
                val startiter = Gtk.textIterNew()
                val _ = Gtk.textBufferGetStartIter(buf,startiter)
                val enditer = Gtk.textIterNew()
                val _ = Gtk.textBufferGetEndIter(buf,enditer)
                val str = Gtk.textBufferGetText(buf, startiter, enditer, false)
                val str = Core.utf8ToLatin1 str
            in
                eval true str
            end
                                 | _ => ()

        fun addNewlines(n, str) =
            (String.tabulate(n,fn _ => #"\n")) ^ str

        fun feedSelection() =
            case (!curtextview) of BUFFER view =>
            let
                val buf = Gtk.textViewGetBuffer view
                val startiter = Gtk.textIterNew()
                val enditer = Gtk.textIterNew()
                val sel = Gtk.textBufferGetSelectionBounds(buf,
                                                           startiter,enditer)
                val startline = 1 + Gtk.textIterGetLine startiter
            in
                if sel
                then eval true (addNewlines(startline,
                                       Core.utf8ToLatin1
                                           (Gtk.textBufferGetText(buf, startiter, enditer, false))))
                else ()
            end
                                 | _ => ()
    
        fun feedLine() =
            case (!curtextview) of BUFFER view =>
            let
                val buf = Gtk.textViewGetBuffer view
                val startiter = Buffer.getCursorIter buf
                val startline = 1 + Gtk.textIterGetLine startiter
                val enditer = Gtk.textIterCopy(startiter)
                val _ = Gtk.textIterSetLineOffset(startiter, 0)
                val _ = Gtk.textIterForwardToLineEnd(enditer)
                val str = addNewlines(startline,
                                      Core.utf8ToLatin1
                                          (Gtk.textBufferGetText(buf, startiter, enditer, false)))
            in
                eval true str
            end
                                 | _ => ()

        fun findNextEOL iter next =
            if next iter then
                let
                    val c = chr (Gtk.textIterGetChar iter)
                in
                    if c = #"\n" then ()
                    else if Char.isSpace c then findNextEOL iter next
                    else findEOP iter next
                end
            else ()
        and findEOP iter next =
            let
                val c = Gtk.textIterGetChar iter
            in
                if c=0 then ()
                else
                    if c=ord #"\n" then
                        findNextEOL iter next
                    else if next iter then
                        findEOP iter next
                    else ()
            end

        fun findNonWS iter next =
            let
                val c = Gtk.textIterGetChar iter
            in
                if c=0 then ()
                else if Char.isSpace (chr c) then
                    (next iter; findNonWS iter next)
                else ()
            end

        fun eolBeforeNonWS acc iter next =
            let
                val c = Gtk.textIterGetChar iter
            in
                if c=0 then acc
                else if Char.isSpace (chr c) then
                    (next iter;
                     eolBeforeNonWS (acc + (if c = ord #"\n" then 1 else 0)) iter next)
                else acc
            end

        fun paragraphIters(buf) =
            let
                val startiter = Buffer.getCursorIter buf
                val c = Gtk.textIterGetChar startiter
                val _ = if c = ord #"\n" orelse c=0 then
                            Gtk.textIterBackwardChar startiter else false
                val enditer = Gtk.textIterCopy(startiter)
                val _ = findEOP startiter Gtk.textIterBackwardChar
                val _ = findEOP enditer Gtk.textIterForwardChar
                val _ = findNonWS startiter Gtk.textIterForwardChar
                val _ = findNonWS enditer Gtk.textIterBackwardChar
                val _ = Gtk.textIterForwardChar enditer (* end is exclusive! *)
            in
                (startiter, enditer)
            end

        fun feedParagraph() =
            case (!curtextview) of BUFFER view =>
            let
                val buf = Gtk.textViewGetBuffer view
                val (startiter, enditer) = paragraphIters(buf)
                val startline = Gtk.textIterGetLine startiter
                val str = addNewlines(startline,
                                      Core.utf8ToLatin1
                                          (Gtk.textBufferGetText(buf, startiter, enditer, false)))
            in
                eval true (str^"\n")
            end
                                 | _ => ()

        fun compile () =
            case getCurrentPage() of NONE => ()
                                   | SOME id =>
            let
                val file = Buffer.getFileName id
            in
                case file of
                    NONE => ()
                  | SOME f => Evaluator.compile f
            end
            
        fun undo() =
            case getCurrentPage() of NONE => ()
                                   | SOME id => Buffer.undo id

        fun getCurBuf () =
            let
                val view = case (!curtextview) of
                               BUFFER view => view
                             | COMPILER => Gui.compilerout
                             | STDSTREAMS => Gui.progout
            in
                Gtk.textViewGetBuffer view
            end
                                             
        fun copy() = Gtk.textBufferCopyClipboard(getCurBuf(), clipboard)

        fun paste() =
            let
		val txt = Gtk.clipboardWaitForText clipboard
		val buf = getCurBuf()
		val _ =
		    Gtk.textBufferInsertInteractiveAtCursor(buf,txt,~1,true)
	    in
		()
	    end

        fun cut() =
            Gtk.textBufferCutClipboard(getCurBuf(), clipboard, true)

        fun delete() =
            ignore (Gtk.textBufferDeleteSelection(getCurBuf(), true, true))

        fun syntax() =
            case (!curtextview) of BUFFER view =>
            let
                val buf = Gtk.textViewGetBuffer view
                val startiter = Gtk.textIterNew()
                val _ = Gtk.textBufferGetStartIter(buf,startiter)
                val enditer = Gtk.textIterNew()
                val _ = Gtk.textBufferGetEndIter(buf,enditer)
            in
                BufferHighlight.highlight(buf, startiter, enditer, true)
            end
                                 | _ => ()

        fun search() =
            case getCurrentPage() of NONE => ()
                                   | SOME id => SearchDialog.search id

	fun gotoLine() =
            case getCurrentPage() of NONE => ()
                                   | SOME id => SearchDialog.gotoLine id

	fun bufferMenus activate =
	    app (fn w => Gtk.widgetSetSensitive(w,activate))
	    [Gui.save1,Gui.save_as1,Gui.go_to_line,
	     Gui.undo,Gui.find,Gui.find_and_replace,
	     Gui.syntax_colouring,Gui.feedline,Gui.feedparagraph,
	     Gui.feedselection,Gui.feedfile]

        fun changeFocus view _ =
	    let
		val _ = curtextview := view
		val _ = case view of
		    BUFFER _ => bufferMenus true
		  | _ => bufferMenus false
		val _ = case getCurrentPage() of
		    NONE => Gtk.widgetSetSensitive(Gui.compilefile,false)
		  | SOME id =>
			Option.app (fn _ => Gtk.widgetSetSensitive(Gui.compilefile,true))
			(Buffer.getFileName id)
					  
	    in ()
	    end

        fun markSet (buf,_) =
            let
                val cursor = Gtk.textBufferGetInsert buf
                val iter = Gtk.textIterNew()
                val _ = Gtk.textBufferGetIterAtMark(buf,iter,cursor)
            in
                Stream.send(OutputWriters.rowCol,
                            (1 + Gtk.textIterGetLine iter,
                             Gtk.textIterGetLineOffset iter))
            end

        fun switchPage notebook =
            let
                val curPage = Gtk.notebookGetCurrentPage notebook
                val scrWin = Gtk.notebookGetNthPage(notebook, curPage)
                val textView = Gtk.binGetChild scrWin
            in
		currentPage := curPage;
		case !curtextview of
		    BUFFER _ => (curtextview := BUFFER textView;
				 Option.app SearchDialog.reconnect (getCurrentPage()))
		  | _ => ()                
            end

        fun checkNotebookSize() =
            let
		 val rq1 = Gdk.rectangleNew(0,0,0,0)
		 val _ = Gtk.textViewGetVisibleRect(Gui.compilerout,rq1)
		 val rq2 = Gdk.rectangleNew(0,0,0,0)
		 val _ = Gtk.textViewGetVisibleRect(Gui.progout,rq2)

		 (* Hack alert: The scrollbar between the two panes *)
		 (* seems to be about 18 pixels high...*)
		 val h1 = Gdk.rectangleGetFieldHeight rq1 + 18
		 val h2 = Gdk.rectangleGetFieldHeight rq2
		 val ratio = Real.fromInt h1 / Real.fromInt (h1+h2)
	     in
		 if Gtk.notebookGetNPages Gui.notebook1 > 0
		     then if Gtk.panedGetPosition Gui.vpaned1 = 1 then
			 let
			     val newPos = Real.fromInt (h1+h2-Config.editorHeight) * ratio
			 in
			     Gtk.panedSetPosition(Gui.vpaned2,Real.round newPos);
			     Gtk.panedSetPosition(Gui.vpaned1,Config.editorHeight)
			 end
			  else ()
		 else
		     let
			 val editorHeight = Gtk.panedGetPosition Gui.vpaned1
			 val newHeight = editorHeight+h1+h2
			 val newPos = Real.fromInt newHeight * ratio
		     in
			 Gtk.panedSetPosition(Gui.vpaned1,1);
			 Gtk.panedSetPosition(Gui.vpaned2,Real.round newPos);
			 Gtk.widgetGrabFocus Gui.compilerout
		     end
	     end

        fun new' file =
            let
                val {buf,view,...} = Buffer.buffer {notebook=Gui.notebook1,
                                                    id=(!numberOfPages),
                                                    file=file,
                                                    loadFile=false}
            in
                Gtk.widgetGrabFocus (view);
                Gtk.signalConnect(buf, "mark-set", markSet);
                Gtk.signalConnect(view, "focus-in-event", changeFocus (BUFFER view));
                markSet (buf, nil);
                addPage(!numberOfPages);
                numberOfPages := (!numberOfPages) + 1;
		switchPage Gui.notebook1;
                changeFocus (BUFFER view) ();
                checkNotebookSize()
            end
        fun new() = new' NONE

        fun openGivenFile f =
                let
                    val {buf,view,...} = Buffer.buffer {notebook=Gui.notebook1,
                                                        id=(!numberOfPages),
                                                        file=SOME f,
                                                        loadFile=true}
                in
                    Gtk.widgetGrabFocus (view);
                    Gtk.signalConnect(buf, "mark-set", markSet);
                    Gtk.signalConnect(view, "focus-in-event", changeFocus (BUFFER view));
                    markSet (buf, nil);
                    addPage(!numberOfPages);
                    numberOfPages := (!numberOfPages) + 1;
		    switchPage Gui.notebook1;
		    changeFocus (BUFFER view) ();
                    checkNotebookSize()
                end

         fun openFile () =
            case FileDialog.openFile "Open file" of
                NONE => ()
              | SOME f => openGivenFile f
                                 
        fun saveFileAs () =
            case getCurrentPage() of NONE => ()
                                   | SOME id =>
            case FileDialog.openFile "Save file" of
                NONE => ()
              | SOME f => Buffer.saveAs (id, f)

        fun saveFile () =
            case getCurrentPage() of NONE => ()
                                   | SOME id =>
                                     if Buffer.save id then ()
                                     else saveFileAs()

        fun reallyClose p =
            (removePage p;
             Gtk.notebookRemovePage(Gui.notebook1, p);
             currentPage := Gtk.notebookGetCurrentPage Gui.notebook1)

        fun close () = 
	     case getCurrentPage() of NONE => ()
	     			    | SOME id =>
            (if Buffer.close id then
                 reallyClose (!currentPage)
             else FileDialog.modifiedWarning
                      "File modified. Discard changes and close anyway, or cancel?"
                      reallyClose (!currentPage);
             checkNotebookSize())

        fun interruptEval() =
            case (!evalSignal) of
                NONE => ()
              | SOME s => Promise.fulfill(s,Evaluator.INTERRUPT)
        fun backgroundEval() =
            case (!evalSignal) of
                NONE => ()
              | SOME s => Promise.fulfill(s,Evaluator.STOP)

        fun jumpToError (file, row, col, row', col') _ =
            case getCurrentPage() of NONE => ()
                                   | SOME id =>
            let
                val (buf,id) =
		    case file of
			NONE => (SOME (Buffer.getBuffer id), id)
		      | SOME f => Buffer.getBufferByName f
	    in
		case buf of
		    NONE => ()
		  | SOME buf =>
	    let
                val lineCount = Gtk.textBufferGetLineCount buf
                val startiter = Gtk.textIterNew()
                val _ = Gtk.textBufferGetStartIter(buf, startiter)
                val enditer = Gtk.textIterCopy startiter
            in
                if row <= lineCount andalso
                   row' <= lineCount
                then
                    (Gtk.textIterSetLine(startiter, row-1);
                     Gtk.textIterSetLine(enditer, row'-1);
                     if col <= Gtk.textIterGetCharsInLine startiter andalso
                        col' <= Gtk.textIterGetCharsInLine enditer then
                         (Gtk.textIterSetLineOffset(startiter, col);
                          Gtk.textIterSetLineOffset(enditer, col');
                          Buffer.selectRange(buf, startiter, enditer);
			  Gtk.notebookSetCurrentPage(Gui.notebook1,
						     valOf (findPage id));
                          Gtk.widgetGrabFocus (Buffer.getView id))
                     else ())
                else ()
            end
	    end

        fun findErrorStart' (iter, tag) =
            if Gtk.textIterHasTag(iter, tag) then
                (Gtk.textIterBackwardChar iter; findErrorStart' (iter, tag))
            else
                ignore (Gtk.textIterForwardChar iter)
		
        fun findErrorStart (iter, tag) =
            if Gtk.textIterHasTag(iter, tag) then
		findErrorStart'(iter,tag)
            else
                if Gtk.textIterBackwardChar iter then findErrorStart(iter, tag)
		else ()

        fun parseErrorCoords s =
            let
                val (file, error) =
                    case String.tokens (fn #":" => true | _ => false) s of
                        [s1,s2] => (NONE, s1)
                      | [s1,s2,s3] => (SOME s1, s2)
                      | _ => raise Match (* make compiler happy *)
                val (s11,s12,s21,s22) =
                    case
                    String.tokens (fn #"-" => true
                                    | #"." => true
                                    | _ => false) error
                    of [s11,s12,s21,s22] => (s11,s12,s21,s22)
                     | _ => raise Match (* make compiler happy *)
                val s11 = Int.fromString s11
                val s12 = Int.fromString s12
                val s21 = Int.fromString s21
                val s22 = Int.fromString s22
            in
                if isNone s11 orelse isNone s12 orelse
                   isNone s21 orelse isNone s22 then
                    NONE
                else
                    SOME (file, valOf s11, valOf s12, valOf s21, valOf s22)
            end handle Match => NONE

        fun populatePopup (view, [Gtk.OBJECT menu]) =
            let
                val separator= Gtk.menuItemNew()
                val showError = Gtk.menuItemNewWithMnemonic("Jump to error location")
                val buf = Gtk.textViewGetBuffer view
                val cursor = Gtk.textBufferGetInsert(buf)
                val iter = Gtk.textIterNew()
                val _ = Gtk.textBufferGetIterAtMark(buf,iter,cursor)
                val errorTag =
                    Gtk.textTagTableLookup(Gtk.textBufferGetTagTable buf,
                                           "error")
                val onErrorLine = Gtk.textIterHasTag(iter, errorTag)
            in
                Gtk.widgetSetSensitive(showError,
                                       onErrorLine);
                if onErrorLine then
                    let
                        val _ = findErrorStart (iter, errorTag)
                        val iter2 = Gtk.textIterCopy iter
                        val _ = Gtk.textIterForwardLine iter2
                        val str = Core.utf8ToLatin1 (Gtk.textIterGetText(iter, iter2))
                        val coords = parseErrorCoords str
                    in
                        case coords of NONE => Gtk.widgetSetSensitive(showError,
                                                                      false)

                                     | SOME coords =>
                                       (Gtk.signalConnect(showError, "activate", jumpToError coords);
                                        ())
                    end
                else ();
                Gtk.widgetShow separator;
                Gtk.widgetShow showError;
                Gtk.containerAdd(menu, separator);
                Gtk.containerAdd(menu, showError)
            end
          | populatePopup _ = print "Gtk is crazy\n"

	fun jumpToLastError () =
	    let
		val buf = Gtk.textViewGetBuffer Gui.compilerout
		val iter = Gtk.textIterNew();
		val _ = Gtk.textBufferGetEndIter(buf, iter)
                val errorTag =
                    Gtk.textTagTableLookup(Gtk.textBufferGetTagTable buf,
                                           "error")
		val _ = findErrorStart (iter, errorTag)
		val iter2 = Gtk.textIterCopy iter
		val _ = Gtk.textIterForwardLine iter2
		val str = Core.utf8ToLatin1 (Gtk.textIterGetText(iter, iter2))
		val coords = parseErrorCoords str
	    in
		case coords of
		    NONE => ()
		  | SOME coords => jumpToError coords ()
	    end

	val forwardHistory = OutputWriters.historyNext
	val backwardHistory = OutputWriters.historyPrev

        fun init () =
            (Gtk.signalConnect(Gui.compilerout, "populate-popup", populatePopup);
             Gtk.signalConnect(Gui.compilerout, "focus-in-event",
                               changeFocus COMPILER);
             Gtk.signalConnect(Gui.progout, "focus-in-event",
                               changeFocus STDSTREAMS);
	     OutputWriters.makeWriters (eval false);
             Gtk.widgetGrabFocus (Gui.compilerout)
             )                      

        fun quit () = if List.all Buffer.close (!pages) then
                          OS.Process.exit OS.Process.success
                      else FileDialog.modifiedWarning
                               "There are modified files. Discard changes and quit anyway or cancel?"
                               OS.Process.exit OS.Process.success
    end
