import structure Stream from "x-alice:/lib/data/Stream"
import structure Gui from "Gui"
import structure Gtk from "x-alice:/lib/gtk/Gtk"
import structure Gdk from "x-alice:/lib/gtk/Gdk"
import structure Key from "x-alice:/lib/gtk/Key"
import structure OutputWriters from "OutputWriters"
import structure Evaluator from "Evaluator"
import structure Buffer from "Buffer"
import structure FileDialog from "FileDialog"
import structure SearchDialog from "SearchDialog"
import structure Core from "x-alice:/lib/gtk/Core"
(*import structure Inspector from "x-alice:/lib/tools/Inspector"*)
import structure BufferHighlight from "BufferHighlight"

structure GuiMain =
    struct
	(* Stream redirection *)

	val (stdin, stdInText) = Stream.stream ()
	val reader = TextPrimIO.openVectorListRd stdInText
	val progStdIn = TextIO.StreamIO.mkInstream (reader, "")
	val _ = TextIO.setInstream (TextIO.stdIn, progStdIn)

	val (stdOutText, writer) = TextPrimIO.openVectorListWr ()
	val progStdOut = TextIO.StreamIO.mkOutstream (writer, IO.LINE_BUF)
	val _ = TextIO.setOutstream (TextIO.stdOut, progStdOut)

	val (stdErrText, writer) = TextPrimIO.openVectorListWr ()
	val progStdErr = TextIO.StreamIO.mkOutstream (writer, IO.NO_BUF)
	val _ = TextIO.setOutstream (TextIO.stdErr, progStdErr)

	val (outText, writer) = TextPrimIO.openVectorListWr ()
	val compilerOut = TextIO.StreamIO.mkOutstream (writer, IO.LINE_BUF)
	val _ = Evaluator.setOutStream compilerOut

	val (inText, writer) = TextPrimIO.openVectorListWr ()
	val compilerIn = TextIO.StreamIO.mkOutstream (writer, IO.LINE_BUF)

	val (errText, writer) = TextPrimIO.openVectorListWr ()
	val compilerErr = TextIO.StreamIO.mkOutstream (writer, IO.LINE_BUF)
	val _ = Evaluator.setErrStream compilerErr

	val (traceText, writer) = TextPrimIO.openVectorListWr ()
	val compilerTrace = TextIO.StreamIO.mkOutstream (writer, IO.LINE_BUF)
	val _ = Evaluator.setTraceStream compilerTrace

        val (rowCol, rowColStream) = Stream.stream ()

        (* Buffers *)

        val clipboard = Gtk.clipboardGet(Gdk.atomIntern("CLIPBOARD", false))
        datatype active_view = COMPILER | STDSTREAMS | BUFFER of Gtk.object
        val curtextview = ref COMPILER

        val numberOfPages = ref 0
        val currentPage = ref ~1

        val pages = ref nil
        fun removePage i =
            let
                val (pre,post) = List.split(!pages, i+1)
                val (pre,p) = case List.split(pre,i) of
                                  (pre, [p]) => (pre,p)
                                | _ => raise Match
                                             (* to make compiler happy *)
            in
                (pages := (List.take(pre,i)@post));
                p
            end
        fun addPage p = pages := (!pages)@[p]
        fun getPage i = List.nth (!pages, i)
        fun getCurrentPage () =
            case !currentPage of ~1 => NONE
                               | i => SOME (getPage i)

        (* Evaluation *)

        val evalSignal = ref NONE

        fun eval echo "" = ()
	  | eval echo text =
            case (!evalSignal) of NONE =>
	    let
                val signalP = Promise.promise()
		val signal = Promise.future signalP
		val text = if String.sub (text, String.size text - 1) = #"\n"
			   then text else text ^ "\n"
                fun find(i ,str) =
                    if i=String.size str then ""
                    else if Char.isSpace (String.sub(str,i)) then
                        find(i+1, str)
                    else String.extract(str, i, NONE)
	    in
                evalSignal := SOME signalP;
		if echo then TextIO.StreamIO.output (compilerIn, find(0,text))
                else ();
		spawn (Evaluator.eval (text, signal);
                       evalSignal := NONE)
	    end
                                | SOME _ =>
                                  FileDialog.message "Still evaluating."

        fun feedFile() =
            case (!curtextview) of BUFFER view =>
            let
                val buf = Gtk.textViewGetBuffer view
                val startiter = Gtk.textIterNew()
                val _ = Gtk.textBufferGetStartIter(buf,startiter)
                val enditer = Gtk.textIterNew()
                val _ = Gtk.textBufferGetEndIter(buf,enditer)
                val str = Gtk.textBufferGetText(buf, startiter, enditer, false)
                val str = Core.utf8ToLatin1 str
            in
                eval true str
            end
                                 | _ => ()

        fun addNewlines(n, str) =
            (String.tabulate(n,fn _ => #"\n")) ^ str

        fun feedSelection() =
            case (!curtextview) of BUFFER view =>
            let
                val buf = Gtk.textViewGetBuffer view
                val startiter = Gtk.textIterNew()
                val enditer = Gtk.textIterNew()
                val sel = Gtk.textBufferGetSelectionBounds(buf,
                                                           startiter,enditer)
                val startline = 1 + Gtk.textIterGetLine startiter
            in
                if sel
                then eval true (addNewlines(startline,
                                       Core.utf8ToLatin1
                                           (Gtk.textBufferGetText(buf, startiter, enditer, false))))
                else ()
            end
                                 | _ => ()
    
        fun feedLine() =
            case (!curtextview) of BUFFER view =>
            let
                val buf = Gtk.textViewGetBuffer view
                val startiter = Buffer.getCursorIter buf
                val startline = 1 + Gtk.textIterGetLine startiter
                val enditer = Gtk.textIterCopy(startiter)
                val _ = Gtk.textIterSetLineOffset(startiter, 0)
                val _ = Gtk.textIterForwardToLineEnd(enditer)
                val str = addNewlines(startline,
                                      Core.utf8ToLatin1
                                          (Gtk.textBufferGetText(buf, startiter, enditer, false)))
            in
                eval true str
            end
                                 | _ => ()

        fun findNextEOL iter next =
            if next iter then
                let
                    val c = chr (Gtk.textIterGetChar iter)
                in
                    if c = #"\n" then ()
                    else if Char.isSpace c then findNextEOL iter next
                    else findEOP iter next
                end
            else ()
        and findEOP iter next =
            let
                val c = Gtk.textIterGetChar iter
            in
                if c=0 then ()
                else
                    if c=ord #"\n" then
                        findNextEOL iter next
                    else if next iter then
                        findEOP iter next
                    else ()
            end

        fun findNonWS iter next =
            let
                val c = Gtk.textIterGetChar iter
            in
                if c=0 then ()
                else if Char.isSpace (chr c) then
                    (next iter; findNonWS iter next)
                else ()
            end

        fun eolBeforeNonWS acc iter next =
            let
                val c = Gtk.textIterGetChar iter
            in
                if c=0 then acc
                else if Char.isSpace (chr c) then
                    (next iter;
                     eolBeforeNonWS (acc + (if c = ord #"\n" then 1 else 0)) iter next)
                else acc
            end

        fun paragraphIters(buf) =
            let
                val startiter = Buffer.getCursorIter buf
                val c = Gtk.textIterGetChar startiter
                val _ = if c = ord #"\n" orelse c=0 then
                            Gtk.textIterBackwardChar startiter else false
                val enditer = Gtk.textIterCopy(startiter)
                val _ = findEOP startiter Gtk.textIterBackwardChar
                val _ = findEOP enditer Gtk.textIterForwardChar
                val _ = findNonWS startiter Gtk.textIterForwardChar
                val _ = findNonWS enditer Gtk.textIterBackwardChar
                val _ = Gtk.textIterForwardChar enditer (* end is exclusive! *)
            in
                (startiter, enditer)
            end

        fun feedParagraph() =
            case (!curtextview) of BUFFER view =>
            let
                val buf = Gtk.textViewGetBuffer view
                val (startiter, enditer) = paragraphIters(buf)
                val startline = 1 + Gtk.textIterGetLine startiter
                val str = addNewlines(startline,
                                      Core.utf8ToLatin1
                                          (Gtk.textBufferGetText(buf, startiter, enditer, false)))
            in
                eval true (str^"\n")
            end
                                 | _ => ()

        fun compile () =
            case getCurrentPage() of NONE => ()
                                   | SOME id =>
            let
                val file = Buffer.getFileName id
            in
                case file of
                    NONE => ()
                  | SOME f => Evaluator.compile f
            end
            
        fun undo() =
            case getCurrentPage() of NONE => ()
                                   | SOME id => Buffer.undo id

        fun getCurBuf () =
            let
                val view = case (!curtextview) of
                               BUFFER view => view
                             | COMPILER => Gui.compilerout
                             | STDSTREAMS => Gui.progout
            in
                Gtk.textViewGetBuffer view
            end
                                             
        fun copy() = Gtk.textBufferCopyClipboard(getCurBuf(), clipboard)

        fun paste() =
            Gtk.textBufferPasteClipboard(getCurBuf(), clipboard,
                                         Gtk.NULL, true)

        fun cut() =
            Gtk.textBufferCutClipboard(getCurBuf(), clipboard, true)

        fun delete() =
            ignore (Gtk.textBufferDeleteSelection(getCurBuf(), true, true))

        fun syntax() =
            case (!curtextview) of BUFFER view =>
            let
                val buf = Gtk.textViewGetBuffer view
                val startiter = Gtk.textIterNew()
                val _ = Gtk.textBufferGetStartIter(buf,startiter)
                val enditer = Gtk.textIterNew()
                val _ = Gtk.textBufferGetEndIter(buf,enditer)
            in
                Gtk.textBufferRemoveAllTags(buf, startiter, enditer);
                BufferHighlight.highlight(buf, startiter, enditer)
            end
                                 | _ => ()

        fun search() =
            case getCurrentPage() of NONE => ()
                                   | SOME id => SearchDialog.search id

        fun changeFocus view _ = curtextview := view
        fun markSet (buf,_) =
            let
                val cursor = Gtk.textBufferGetInsert buf
                val iter = Gtk.textIterNew()
                val _ = Gtk.textBufferGetIterAtMark(buf,iter,cursor)
            in
                Stream.send(rowCol,
                            (1 + Gtk.textIterGetLine iter,
                             Gtk.textIterGetLineOffset iter))
            end

        fun switchPage(cur,view) =
            (currentPage := cur;
             case !curtextview of
                 BUFFER _ => (curtextview := BUFFER view;
                              Option.app SearchDialog.reconnect (getCurrentPage()))
               | _ => ())

        fun checkNotebookSize() =
            (if Gtk.notebookGetNPages Gui.notebook1 > 0
             then Gtk.panedSetPosition(Gui.vpaned1,500)
             else (Gtk.panedSetPosition(Gui.vpaned1,1);
                   Gtk.widgetGrabFocus Gui.compilerout))

        fun new' file =
            let
                val {buf,view,...} = Buffer.buffer {notebook=Gui.notebook1,
                                                    id=(!numberOfPages),
                                                    file=file,
                                                    loadFile=false}
            in
                curtextview := BUFFER view;
                Gtk.widgetGrabFocus (view);
                Gtk.signalConnect(buf, "mark-set", markSet);
                Gtk.signalConnect(view, "focus-in-event", changeFocus (BUFFER view));
                markSet (buf, nil);
                addPage(!numberOfPages);
                numberOfPages := (!numberOfPages) + 1;
                checkNotebookSize()
            end
        fun new() = new' NONE

        fun openFile () =
            case FileDialog.openFile "Open file" of
                NONE => ()
              | SOME f =>
                let
                    val {buf,view,...} = Buffer.buffer {notebook=Gui.notebook1,
                                                        id=(!numberOfPages),
                                                        file=SOME f,
                                                        loadFile=true}
                in
                    curtextview := BUFFER view;
                    Gtk.widgetGrabFocus (view);
                    Gtk.signalConnect(buf, "mark-set", markSet);
                    Gtk.signalConnect(view, "focus-in-event", changeFocus (BUFFER view));
                    markSet (buf, nil);
                    addPage(!numberOfPages);
                    numberOfPages := (!numberOfPages) + 1;
                    checkNotebookSize()
                end
                                  
        fun saveFileAs () =
            case getCurrentPage() of NONE => ()
                                   | SOME id =>
            case FileDialog.openFile "Save file" of
                NONE => ()
              | SOME f => Buffer.saveAs (id, f)

        fun saveFile () =
            case getCurrentPage() of NONE => ()
                                   | SOME id =>
                                     if Buffer.save id then ()
                                     else saveFileAs()

        fun reallyClose p =
            (removePage p;
             Gtk.notebookRemovePage(Gui.notebook1, p);
             currentPage := Gtk.notebookGetCurrentPage Gui.notebook1)

        fun close () = 
            (if Buffer.close (getPage(!currentPage)) then
                 reallyClose (!currentPage)
             else FileDialog.modifiedWarning
                      "File modified. Discard changes and close anyway, or cancel?"
                      reallyClose (!currentPage);
             checkNotebookSize())

        fun breakEval() =
            case (!evalSignal) of
                NONE => ()
              | SOME s => Promise.fulfill(s,Evaluator.INTERRUPT)
        fun stopEval() =
            case (!evalSignal) of
                NONE => ()
              | SOME s => Promise.fulfill(s,Evaluator.STOP)

        fun jumpToError (row, col, row', col') _ =
            case getCurrentPage() of NONE => ()
                                   | SOME id =>
            let
                val buf = Buffer.getBuffer id
                val lineCount = Gtk.textBufferGetLineCount buf
                val startiter = Gtk.textIterNew()
                val _ = Gtk.textBufferGetStartIter(buf, startiter)
                val enditer = Gtk.textIterCopy startiter
            in
                if row <= lineCount andalso
                   row' <= lineCount
                then
                    (Gtk.textIterSetLine(startiter, row-1);
                     Gtk.textIterSetLine(enditer, row'-1);
                     if col <= Gtk.textIterGetCharsInLine startiter andalso
                        col' <= Gtk.textIterGetCharsInLine enditer then
                         (Gtk.textIterSetLineOffset(startiter, col);
                          Gtk.textIterSetLineOffset(enditer, col');
                          Buffer.selectRange(buf, startiter, enditer);
                          Gtk.widgetGrabFocus (Buffer.getView id))
                     else ())
                else ()
            end

        fun findErrorStart iter tag =
            if Gtk.textIterHasTag(iter, tag) then
                (Gtk.textIterBackwardChar iter; findErrorStart iter tag)
            else
                Gtk.textIterForwardChar iter

        fun parseErrorCoords s =
            let
                val (s11,s12,s21,s22) =
                    case
                    String.tokens (fn #":" => true
                                    | #"-" => true
                                    | #"." => true
                                    | _ => false) s
                    of (s11::s12::s21::s22::_) => (s11,s12,s21,s22)
                     | _ => raise Match (* make compiler happy *)
                val s11 = Int.fromString s11
                val s12 = Int.fromString s12
                val s21 = Int.fromString s21
                val s22 = Int.fromString s22
            in
                if isNone s11 orelse isNone s12 orelse
                   isNone s21 orelse isNone s22 then
                    NONE
                else
                    SOME (valOf s11, valOf s12, valOf s21, valOf s22)
            end handle Match => NONE

        fun populatePopup (view, [Gtk.OBJECT menu]) =
            let
                val separator= Gtk.menuItemNew()
                val showError = Gtk.menuItemNewWithMnemonic("Jump to error location")
                val buf = Gtk.textViewGetBuffer view
                val cursor = Gtk.textBufferGetInsert(buf)
                val iter = Gtk.textIterNew()
                val _ = Gtk.textBufferGetIterAtMark(buf,iter,cursor)
                val errorTag =
                    Gtk.textTagTableLookup(Gtk.textBufferGetTagTable buf,
                                           "error")
                val onErrorLine = Gtk.textIterHasTag(iter, errorTag)
            in
                Gtk.widgetSetSensitive(showError,
                                       onErrorLine);
                if onErrorLine then
                    let
                        val _ = findErrorStart iter errorTag
                        val iter2 = Gtk.textIterCopy iter
                        val _ = Gtk.textIterForwardLine iter2
                        val str = Core.utf8ToLatin1 (Gtk.textIterGetText(iter, iter2))
                        val coords = parseErrorCoords str
                    in
                        case coords of NONE => Gtk.widgetSetSensitive(showError,
                                                                      false)

                                     | SOME coords =>
                                       (Gtk.signalConnect(showError, "activate", jumpToError coords);
                                        ())
                    end
                else ();
                Gtk.widgetShow separator;
                Gtk.widgetShow showError;
                Gtk.containerAdd(menu, separator);
                Gtk.containerAdd(menu, showError)
            end
          | populatePopup _ = print "Gtk is crazy\n"

        fun init () =
            (Gtk.signalConnect(Gui.compilerout, "populate-popup", populatePopup);
             Gtk.signalConnect(Gui.compilerout, "focus-in-event",
                               changeFocus COMPILER);
             Gtk.signalConnect(Gui.progout, "focus-in-event",
                               changeFocus STDSTREAMS);
	     OutputWriters.makeWriters {inStream = inText,
					outStream = outText,
					errStream = errText,
					traceStream = traceText,
					stdOutStream = stdOutText,
					stdErrStream = stdErrText,
                                        stdInStream = stdin,
                                        rowColStream = rowColStream,
                                        eval=eval false};
             Gtk.windowAddAccelGroup(Gui.mainwidget,
                                     Gui.Helpers.accelGroup);
             Gtk.widgetAddAccelerator(Gui.undo, "activate",
                                      Gui.Helpers.accelGroup,
                                      Key.keyvalToInt Key.K_Z,
                                      Gdk.CONTROL_MASK, Gtk.ACCEL_LOCKED);
             Gtk.widgetAddAccelerator(Gui.feedparagraph, "activate",
                                      Gui.Helpers.accelGroup,
                                      Key.keyvalToInt Key.K_Return,
                                      Gdk.CONTROL_MASK, Gtk.ACCEL_LOCKED);
             Gtk.widgetGrabFocus (Gui.compilerout)
             )                      

        fun quit () = if List.all Buffer.close (!pages) then
                          OS.Process.exit OS.Process.success
                      else FileDialog.modifiedWarning
                               "There are modified files. Discard changes and quit anyway or cancel?"
                               OS.Process.exit OS.Process.success
    end
