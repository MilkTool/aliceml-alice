(*
 * Authors:
 *   Guido Tack <tack@ps.uni-sb.de>
 *
 * Copyright:
 *   Guido Tack, 2005
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Stream from "x-alice:/lib/data/Stream"
import structure Gui from "Gui"
import structure Gtk from "x-alice:/lib/gtk/Gtk"
import structure Gdk from "x-alice:/lib/gtk/Gdk"
import structure OutputWriters from "OutputWriters"
import structure Evaluator from "Evaluator"
import structure Buffer from "Buffer"
import structure Config from "Config"
import structure History from "History"
import structure FileDialog from "FileDialog"
import structure SearchDialog from "SearchDialog"
import structure BufferHighlight from "BufferHighlight"
import structure Preferences from "Preferences"

structure GuiMain =
    struct
        (* Buffers *)

        val clipboard = Gtk.clipboardGet(Gdk.atomIntern("CLIPBOARD", false))
        datatype active_view = COMPILER | STDSTREAMS | BUFFER of Gtk.object
        val curtextview = ref COMPILER

        val numberOfPages = ref 0
        val currentPage = ref ~1

        val pages = ref nil
        fun removePage i =
            let
                val (pre,post) = List.split(!pages, i+1)
                val (pre,p) = case List.split(pre,i) of
                                  (pre, [p]) => (pre,p)
                                | _ => raise Match
                                             (* to make compiler happy *)
            in
                (pages := (List.take(pre,i)@post));
                p
            end
        fun addPage p = pages := (!pages)@[p]
        fun getPage i = List.nth (!pages, i)
        fun getCurrentPage () =
            case !currentPage of ~1 => NONE
                               | i => SOME (getPage i)
	fun findPage id = Option.map #1 (List.findi (fn (_,i) => i=id) (!pages))

        (* Evaluation *)

        val evalSignal = ref NONE

        fun eval echo "" = ()
	  | eval echo text =
            case (!evalSignal) of NONE =>
	    let
                val signalP = Promise.promise()
		val signal = Promise.future signalP
		val text = if String.sub (text, String.size text - 1) = #"\n"
			   then text else text ^ "\n"
                fun find(i ,str) =
                    if i=String.size str then "\n"
                    else if Char.isSpace (String.sub(str,i)) then
                        find(i+1, str)
                    else String.extract(str, i, NONE)
	    in
                evalSignal := SOME signalP;
		if echo then TextIO.StreamIO.output (OutputWriters.compilerIn, find(0,text))
                else ();
		spawn (Evaluator.eval (text, signal);
                       evalSignal := NONE)
	    end
                                | SOME _ =>
                                  FileDialog.message "Still evaluating."

        fun feedFile() =
            case (!curtextview) of BUFFER view =>
            let
                val buf = Gtk.textViewGetBuffer view
		val str = Lock.sync Gtk.lock
		    (fn () => let
		     val startiter = Gtk.textIterNew()
		     val _ = Gtk.textBufferGetStartIter(buf,startiter)
		     val enditer = Gtk.textIterNew()
		     val _ = Gtk.textBufferGetEndIter(buf,enditer)
		     in Gtk.textBufferGetText(buf, startiter, enditer, false)
		     end) ()
                val str = Gtk.utf8ToLatin1 str
            in
                eval true str
            end
                                 | _ => ()

        fun addSpace(line, col, str) =
            String.tabulate(line-1, fn _ => #"\n") ^
	    String.tabulate(col, fn _ => #" ") ^ str

        fun feedSelection() =
            case (!curtextview) of BUFFER view =>
            let
                val buf = Gtk.textViewGetBuffer view

		val (sel, txt, line, col) =
		    Lock.sync Gtk.lock
		    (fn () =>
		     let
		     val startiter = Gtk.textIterNew()
		     val enditer = Gtk.textIterNew()
		     in
			 (Gtk.textBufferGetSelectionBounds(buf,
                                                           startiter,enditer),
			  Gtk.textBufferGetText(buf, startiter, enditer, false),
			  Buffer.getLine startiter,
			  Buffer.getColumn startiter)
		     end) ()
            in
                if sel
                then eval true (addSpace(line, col,
					 Gtk.utf8ToLatin1 txt))
                else ()
            end
           | _ => ()

        fun feedLine() =
            case (!curtextview) of BUFFER view =>
            let
                val buf = Gtk.textViewGetBuffer view
		    
		val (startline, str) = Lock.sync Gtk.lock
		    (fn () =>
		     let
			 val startiter = Buffer.getCursorIter buf
			 val enditer = Gtk.textIterCopy(startiter)
		     in
			 Gtk.textIterSetLineOffset(startiter, 0);
			 Gtk.textIterForwardToLineEnd(enditer);
			 (Buffer.getLine startiter,
			  Gtk.textBufferGetText(buf,
						startiter, enditer, false))
		     end) ()
                val str = addSpace(startline, 0,
                                   Gtk.utf8ToLatin1 str)
            in
                eval true str
            end
                                 | _ => ()

        fun findNextEOL iter next =
            if next iter then
                let
                    val c = chr (Gtk.textIterGetChar iter)
                in
                    if c = #"\n" then ()
                    else if Char.isSpace c then findNextEOL iter next
                    else findEOP iter next
                end
            else ()
        and findEOP iter next =
            let
                val c = Gtk.textIterGetChar iter
            in
                if c=0 then ()
                else
                    if c=ord #"\n" then
                        findNextEOL iter next
                    else if next iter then
                        findEOP iter next
                    else ()
            end

        fun findNonWS iter next =
            let
                val c = Gtk.textIterGetChar iter
            in
                if c=0 then ()
                else if Char.isSpace (chr c) then
                    (next iter; findNonWS iter next)
                else ()
            end

        fun eolBeforeNonWS acc iter next =
            let
                val c = Gtk.textIterGetChar iter
            in
                if c=0 then acc
                else if Char.isSpace (chr c) then
                    (next iter;
                     eolBeforeNonWS (acc + (if c = ord #"\n" then 1 else 0)) iter next)
                else acc
            end

        fun paragraphIters(buf) =
            let
                val startiter = Buffer.getCursorIter buf
                val c = Gtk.textIterGetChar startiter
                val _ = if c = ord #"\n" orelse c=0 then
                            Gtk.textIterBackwardChar startiter else false
                val enditer = Gtk.textIterCopy(startiter)
                val _ = findEOP startiter Gtk.textIterBackwardChar
                val _ = findEOP enditer Gtk.textIterForwardChar
                val _ = findNonWS startiter Gtk.textIterForwardChar
                val _ = findNonWS enditer Gtk.textIterBackwardChar
                val _ = Gtk.textIterForwardChar enditer (* end is exclusive! *)
		val _ = Gtk.textIterSetLineOffset(startiter, 0)
            in
                (startiter, enditer)
            end

        fun feedRegion() =
            case (!curtextview) of BUFFER view =>
            let
                val buf = Gtk.textViewGetBuffer view

		val (str, line, col) = Lock.sync Gtk.lock
		    (fn () =>
		     let
		     val startiter = Gtk.textIterNew()
		     val enditer = Gtk.textIterNew()
		     val (startiter, enditer) = 
			 if Gtk.textBufferGetSelectionBounds(buf, startiter, enditer)
			     then (startiter, enditer)
			 else let val (start,endd) = paragraphIters(buf)
			      in Buffer.selectRange(buf, start, endd);
				  (start,endd)
			      end
		     in
			 (Gtk.textBufferGetText(buf, startiter, enditer, false),
			  Buffer.getLine startiter,
			  Buffer.getColumn startiter)
		     end) ()

                val str = addSpace(line, col, Gtk.utf8ToLatin1 str)
            in
                eval true (str^"\n")
            end
            | _ => ()
            
        fun undo() =
            case getCurrentPage() of NONE => ()
                                   | SOME id => Buffer.undo id

        fun getCurBuf () =
            let
                val view = case (!curtextview) of
                               BUFFER view => view
                             | COMPILER => Gui.compilerout
                             | STDSTREAMS => Gui.progout
            in
                Gtk.textViewGetBuffer view
            end
                                             
        fun copy() = Gtk.textBufferCopyClipboard(getCurBuf(), clipboard)

        fun paste() =
            let
		val txt = Gtk.clipboardWaitForText clipboard
		val buf = getCurBuf()
		val _ =
		    Gtk.textBufferInsertInteractiveAtCursor(buf,txt,~1,true)
	    in
		()
	    end

        fun cut() =
            Gtk.textBufferCutClipboard(getCurBuf(), clipboard, true)

        fun delete() =
            ignore (Gtk.textBufferDeleteSelection(getCurBuf(), true, true))

        fun syntax() =
            case (!curtextview) of BUFFER view =>
                BufferHighlight.highlightAll(Gtk.textViewGetBuffer view, ref false)
              | _ => ()

        fun search() =
            case getCurrentPage() of NONE => ()
                                   | SOME id => SearchDialog.search id

	fun searchAgain arg =
            case getCurrentPage() of NONE => ()
                                   | SOME id => SearchDialog.searchAgain(id, arg)

        fun replaceSearch() =
            case getCurrentPage() of NONE => ()
                                   | SOME id => SearchDialog.replace id

	fun gotoLine() =
            case getCurrentPage() of NONE => ()
                                   | SOME id => SearchDialog.gotoLine id

	fun bufferMenus activate =
	    (app (fn w => Gtk.widgetSetSensitive(w,activate))
	     [Gui.save1,Gui.save_as1,Gui.go_to_line,
	      Gui.undo,Gui.find,Gui.replace,Gui.find_again,
	      Gui.feedregion,Gui.feedfile,Gui.syntax_colouring,
	      Gui.compilefile,Gui.indent_region, Gui.outdent_region];
	     app (fn w => Gtk.widgetSetSensitive(w,not activate))
	     [Gui.back_in_history,Gui.forward_in_history])

        fun changeFocus view _ =
	    let
		val _ = curtextview := view
		val _ = case getCurrentPage() of
		    NONE =>
			Gtk.widgetSetSensitive(Gui.compilefile,false)
		  | SOME id =>
			(Option.app (fn _ => Gtk.widgetSetSensitive(Gui.compilefile,true))
			 (Buffer.getFileName id);
			 Gtk.checkMenuItemSetActive(Gui.syntax_colouring,
					     Buffer.getSyntaxHighlighting id))
		val _ = case view of
		    BUFFER _ => bufferMenus true
		  | _ => bufferMenus false
	    in ()
	    end

        fun markSet (buf,_) =
            let
                val cursor = Gtk.textBufferGetInsert buf
		val (line, col) = Lock.sync Gtk.lock
		    (fn () =>
		     let
			 val iter = Gtk.textIterNew()
			 val _ = Gtk.textBufferGetIterAtMark(buf,iter,cursor)
		     in
			 (Buffer.getLine iter, Buffer.getColumn iter)
		     end) ()
            in
                Stream.send(OutputWriters.rowCol, (line, col))
            end

	val notebookSwitchEventIdP = Promise.promise()
	val notebookSwitchEventId = Promise.future notebookSwitchEventIdP
        fun switchPage notebook =
            let
                val curPage = Gtk.notebookGetCurrentPage notebook
                val scrWin = Gtk.notebookGetNthPage(notebook, curPage)
                val textView = Gtk.binGetChild scrWin
            in
		currentPage := curPage;
		case !curtextview of
		    BUFFER _ => (curtextview := BUFFER textView;
				 Option.app SearchDialog.reconnect (getCurrentPage()))
		  | _ => ()                
            end

        fun checkNotebookSize() =
            let
		 val rq1 = Gdk.rectangleNew(0,0,0,0)
		 val _ = Gtk.textViewGetVisibleRect(Gui.compilerout,rq1)
		 val rq2 = Gdk.rectangleNew(0,0,0,0)
		 val _ = Gtk.textViewGetVisibleRect(Gui.progout,rq2)

		 val buf = Gtk.textViewGetBuffer Gui.compilerout
		 val progBuf = Gtk.textViewGetBuffer Gui.progout

		 (* Hack alert: The scrollbar between the two panes *)
		 (* seems to be about 18 pixels high...*)
		 val h1 = Gdk.rectangleGetFieldHeight rq1 + 18
		 val h2 = Gdk.rectangleGetFieldHeight rq2
		 val ratio = Real.fromInt h1 / Real.fromInt (h1+h2)
	     in
		 if Gtk.notebookGetNPages Gui.notebook1 > 0
		     then (if Gtk.panedGetPosition Gui.vpaned1 = 1 then
			   let
			       val newPos = Real.fromInt (h1+h2-Config.editorHeight) * ratio
			   in
			       Gtk.panedSetPosition(Gui.vpaned2,Real.round newPos);
			       Gtk.panedSetPosition(Gui.vpaned1,Config.editorHeight)
			   end
			   else ();
			   Gtk.widgetSetSensitive(Gui.switch_to_editor, true))
		 else
		     let
			 val editorHeight = Gtk.panedGetPosition Gui.vpaned1
			 val newHeight = editorHeight+h1+h2
			 val newPos = Real.fromInt newHeight * ratio
		     in
			 Gtk.panedSetPosition(Gui.vpaned1,1);
			 Gtk.panedSetPosition(Gui.vpaned2,Real.round newPos);
			 Gtk.widgetGrabFocus Gui.compilerout;
			 Gtk.widgetSetSensitive(Gui.switch_to_editor, false)
		     end;
		 (* Hack alert: scroll to end mark seems to have no effect if
		  * performed immediately... so wait for a moment... *)
		 spawn (
		     await(Future.alarm(Time.fromMilliseconds(Int.toLarge 300)));
		     Gtk.textViewScrollToMark(Gui.compilerout,
					      Gtk.textBufferGetInsert buf,
					      0.0, false, 0.0, 0.0);
		     Gtk.textViewScrollToMark(Gui.progout,
					      Gtk.textBufferGetInsert progBuf,
					      0.0, false, 0.0, 0.0)
		 );
		 ()
	     end

        fun new' file =
            let
		val _ = Gtk.signalHandlerBlock(Gui.notebook1,
						notebookSwitchEventId)
                val {buf,view,...} = Buffer.buffer {notebook=Gui.notebook1,
                                                    id=(!numberOfPages),
                                                    file=file,
                                                    loadFile=false}
            in
                Gtk.widgetGrabFocus (view);
                Gtk.signalConnect(buf, "mark-set", markSet);
                Gtk.signalConnect(view, "focus-in-event", changeFocus (BUFFER view));
                markSet (buf, nil);
                addPage(!numberOfPages);
                numberOfPages := (!numberOfPages) + 1;
		switchPage Gui.notebook1;
		Gtk.signalHandlerUnblock(Gui.notebook1,
					  notebookSwitchEventId);
                changeFocus (BUFFER view) ();
                checkNotebookSize()
            end
        fun new() = new' NONE

        fun openGivenFile f =
                let
		    val _ = Gtk.signalHandlerBlock(Gui.notebook1,
						    notebookSwitchEventId)
                    val {buf,view,highlight,...} =
                        Buffer.buffer {notebook=Gui.notebook1, loadFile=true,
                                       id=(!numberOfPages), file=SOME f}
                in
                    Gtk.signalConnect(buf, "mark-set", markSet);
                    Gtk.signalConnect(view, "focus-in-event", changeFocus (BUFFER view));
                    Gtk.widgetGrabFocus (view);
                    markSet (buf, nil);
                    addPage(!numberOfPages);
                    numberOfPages := (!numberOfPages) + 1;
		    switchPage Gui.notebook1;
		    Gtk.signalHandlerUnblock(Gui.notebook1,
					      notebookSwitchEventId);
		    Promise.fulfill(!highlight, SOME 0);
                    checkNotebookSize()
                end

	fun openFile () =
	    let
		val file =
		    case getCurrentPage() of
			NONE => ""
		      | SOME id =>
			    OS.Path.getParent
			    (Option.getOpt(Buffer.getFileName id,""))^"/"
	    in
		case FileDialog.openFile("Open file", file) of
		    NONE => ()
		  | SOME f => openGivenFile f
	    end
       
        fun saveFileAs () =
            case getCurrentPage() of NONE => ()
                                   | SOME id =>
		let
		    val file =
			Option.getOpt(Buffer.getFileName id,"")
		in
		    case FileDialog.openFile("Save file",file) of
			NONE => ()
		      | SOME f => Buffer.saveAs (id, f)
		end

        fun saveFile () =
            case getCurrentPage() of NONE => ()
                                   | SOME id =>
                                     if Buffer.save id then ()
                                     else saveFileAs()

        fun compile () =
            case getCurrentPage() of NONE => ()
                                   | SOME id =>
            let
                val _ = saveFile ()
		val file = Buffer.getFileName id
            in
                case file of
                    NONE => ()
                  | SOME f => Evaluator.compile f
            end

        fun reallyClose p =
            (removePage p;
             Gtk.notebookRemovePage(Gui.notebook1, p);
             currentPage := Gtk.notebookGetCurrentPage Gui.notebook1)

        fun close () = 
	     case getCurrentPage() of NONE => ()
	     			    | SOME id =>
            (if Buffer.close id then
                 reallyClose (!currentPage)
             else FileDialog.modifiedWarning
		 ("File modified.", "Discard changes and close anyway, or cancel?",
		  reallyClose, !currentPage);
             checkNotebookSize())

        fun interruptEval() =
            case (!evalSignal) of
                NONE => ()
              | SOME s => Promise.fulfill(s,Evaluator.INTERRUPT)
        fun backgroundEval() =
            case (!evalSignal) of
                NONE => ()
              | SOME s => Promise.fulfill(s,Evaluator.STOP)

        fun jumpToError (file, row, col, row', col') _ =
            case getCurrentPage() of NONE => ()
                                   | SOME id =>
            let
                val (buf,id) =
		    case file of
			NONE => (SOME (Buffer.getBuffer id), id)
		      | SOME f =>
	        Buffer.getBufferByName
		(OS.Path.mkAbsolute {path=f,relativeTo=OS.FileSys.getDir()})
	    in
		case buf of
		    NONE => ()
		  | SOME buf =>
	    Lock.sync Gtk.lock
	    (fn () =>
	    let
                val lineCount = Gtk.textBufferGetLineCount buf
                val startiter = Gtk.textIterNew()
                val _ = Gtk.textBufferGetStartIter(buf, startiter)
                val enditer = Gtk.textIterCopy startiter

		exception Off
		fun moveOffset(startiter, 0, pos) = ()
		  | moveOffset(startiter, n, pos) =
		    let
			val c = Gtk.textIterGetChar startiter
		    in
			if c = Char.ord #"\n" then
			    raise Off
			else if c = Char.ord #"\t" then
			    let
				val tabjump = 8 - pos mod 8
			    in
				Gtk.textIterForwardChar startiter;
				moveOffset(startiter, n-tabjump, pos+tabjump)
			    end
			else
			    (Gtk.textIterForwardChar startiter;
			     moveOffset(startiter, n-1, pos+1))
		    end
            in
                if row <= lineCount andalso
                   row' <= lineCount
                then
                    (Gtk.textIterSetLine(startiter, row-1);
                     Gtk.textIterSetLine(enditer, row'-1);
                     moveOffset(startiter, col, 0);
                     moveOffset(enditer, col', 0);
                     Buffer.selectRange(buf, enditer, startiter);
		     Buffer.scrollToCursor id;
		     Gtk.notebookSetCurrentPage(Gui.notebook1,
						valOf (findPage id));
                     Gtk.widgetGrabFocus (Buffer.getView id))
                    handle Off => ()
                else ()
            end) ()
	    end

        fun findErrorStart' (iter, tag) =
            if Gtk.textIterHasTag(iter, tag) then
                (Gtk.textIterBackwardChar iter; findErrorStart' (iter, tag))
            else
                ignore (Gtk.textIterForwardChar iter)
		
        fun findErrorStart (iter, tag) =
            if Gtk.textIterHasTag(iter, tag) then
		findErrorStart'(iter,tag)
            else
                if Gtk.textIterBackwardChar iter then findErrorStart(iter, tag)
		else ()

        fun parseErrorCoords s =
            let
                val (file, error) =
                    case String.tokens (fn #":" => true | _ => false) s of
                        [s1,s2] => (NONE, s1)
                      | (s1::s2::s3::_) => (SOME s1, s2)
		      | _ => raise Match (* make compiler happy *)
                val (s11,s12,s21,s22) =
                    case
                    String.tokens (fn #"-" => true
                                    | #"." => true
                                    | _ => false) error
                    of [s11,s12,s21,s22] => (s11,s12,s21,s22)
                     | _ => raise Match (* make compiler happy *)
                val s11 = Int.fromString s11
                val s12 = Int.fromString s12
                val s21 = Int.fromString s21
                val s22 = Int.fromString s22
            in
                if isNone s11 orelse isNone s12 orelse
                   isNone s21 orelse isNone s22 then
                    NONE
                else
                    SOME (file, valOf s11, valOf s12, valOf s21, valOf s22)
            end handle Match => NONE

        fun populatePopup (view, [Gtk.OBJECT menu]) =
            let
                val separator= Gtk.menuItemNew()
                val showError = Gtk.menuItemNewWithMnemonic("Jump to error location")
                val buf = Gtk.textViewGetBuffer view
                val cursor = Gtk.textBufferGetInsert(buf)
	    in
		Lock.sync Gtk.lock
		(fn () =>
		 let
		     val iter = Gtk.textIterNew()
		     val _ = Gtk.textBufferGetIterAtMark(buf,iter,cursor)
		     val errorTag =
			 Gtk.textTagTableLookup(Gtk.textBufferGetTagTable buf,
						"error")
		     val onErrorLine = Gtk.textIterHasTag(iter, errorTag)
		 in
		     Gtk.widgetSetSensitive(showError,
					    onErrorLine);
		     if onErrorLine then
			 let
			     val _ = findErrorStart (iter, errorTag)
			     val iter2 = Gtk.textIterCopy iter
			     val _ = Gtk.textIterForwardLine iter2
			     val str = Gtk.utf8ToLatin1 (Gtk.textIterGetText(iter, iter2))
			     val coords = parseErrorCoords str
			 in
			     case coords of NONE => Gtk.widgetSetSensitive(showError,
									   false)
				 
			   | SOME coords =>
				 (Gtk.signalConnect(showError, "activate", jumpToError coords);
				  ())
			 end
		     else ()
		 end) ();
                Gtk.widgetShow separator;
                Gtk.widgetShow showError;
                Gtk.containerAdd(menu, separator);
                Gtk.containerAdd(menu, showError)
            end
          | populatePopup _ = TextIO.output(TextIO.stdErr, "** Gtk is crazy: popup\n")

	fun jumpToLastError () =
	    Lock.sync Gtk.lock
	    (fn () =>
	     let
		 val buf = Gtk.textViewGetBuffer Gui.compilerout
		 val iter = Gtk.textIterNew();
		 val _ = Gtk.textBufferGetEndIter(buf, iter)
		 val errorTag =
		     Gtk.textTagTableLookup(Gtk.textBufferGetTagTable buf,
					    "error")
		 val _ = findErrorStart (iter, errorTag)
		 val iter2 = Gtk.textIterCopy iter
		 val _ = Gtk.textIterForwardLine iter2
		 val str = Gtk.utf8ToLatin1 (Gtk.textIterGetText(iter, iter2))
		 val coords = parseErrorCoords str
	     in
		 case coords of
		     NONE => ()
		   | SOME coords => jumpToError coords ()
	     end) ()

	fun indentSelection indent =
	    case getCurrentPage() of NONE => ()
	  | SOME id => Buffer.indentSelection(id, indent)

	fun reset () = Evaluator.reset()
	    
	val forwardHistory = OutputWriters.historyNext
	val backwardHistory = OutputWriters.historyPrev

	fun switchTo 0 =
	    (case getCurrentPage() of
		 NONE => ()
	       | SOME id => Gtk.widgetGrabFocus (Buffer.getView id))
	  | switchTo 1 =
		Gtk.widgetGrabFocus Gui.compilerout
	  | switchTo 2 =
		Gtk.widgetGrabFocus Gui.progout
	  | switchTo _ = ()

	fun activateSyntax () =
	    case getCurrentPage() of
		NONE => ()
	      | SOME id =>
		    Buffer.setSyntaxHighlighting
		    (id, Gtk.checkMenuItemGetActive Gui.syntax_colouring)

	fun doQuit () = (Config.saveHistory (History.get(),
					     Buffer.getFileNames());
			 OS.Process.exit OS.Process.success)
        fun quit () = if Buffer.haveModified ()
			  then
			      FileDialog.modifiedWarning
			      ("There are modified files.",
			       "Discard changes and quit anyway or cancel?",
			       doQuit, () )
		      else doQuit ()

        fun init notebookSwitchEventId =
            (Gtk.signalConnect(Gui.compilerout, "populate-popup", populatePopup);
             Gtk.signalConnect(Gui.compilerout, "focus-in-event",
                               changeFocus COMPILER);
             Gtk.signalConnect(Gui.progout, "focus-in-event",
                               changeFocus STDSTREAMS);
	     Promise.fulfill(notebookSwitchEventIdP, notebookSwitchEventId);
	     OutputWriters.makeWriters (eval false);
	     History.set (Config.loadHistory());
	     Gtk.textViewSetEditable(Gui.compilerout, false);
	     Gtk.windowSetDefaultSize(Gui.mainwidget,
				      Config.sizeX,Config.sizeY);
	     Gtk.widgetShowAll Gui.mainwidget;
             Gtk.widgetGrabFocus (Gui.compilerout);
	     OS.Process.atExit quit)                      

	fun initDone () =
	    (Gtk.textViewSetEditable(Gui.compilerout, true);
	     Gtk.widgetSetSensitive(Gui.feed1, true);
	     app openGivenFile (Config.loadOpenFiles ()))

	fun preferences () = 
	    Preferences.showDialog()
    end
