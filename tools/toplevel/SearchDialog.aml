(*
 * Authors:
 *   Guido Tack <tack@ps.uni-sb.de>
 *
 * Copyright:
 *   Guido Tack, 2005
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Gtk from "x-alice:/lib/gtk/Gtk"
import structure Buffer from "Buffer"
import structure Gui from "Gui"

structure SearchDialog =
    struct
	val searchDialog = Gui.searchDialog

	val _ = Gtk.dialogSetDefaultResponse(searchDialog,
					     ~5)

        fun closeCallback _ = (Gtk.windowSetModal(searchDialog, false);
			       Gtk.widgetUnmap searchDialog)
        val _ = Gtk.signalConnect(searchDialog, "delete-event", closeCallback)
        val _ = Gtk.signalConnect(Gui.search_cancel_button, "clicked", closeCallback)

	val isReplace = ref false

        val searchSignal = ref NONE
        val replaceSignal = ref NONE

	fun doReplace(id, replaceString) arg =
	    (Buffer.replace(id, replaceString);
	     doSearch id arg)
        and doSearch id _ =
            let
                val txt = Gtk.entryGetText Gui.searchString
                val replacetxt = Gtk.entryGetText Gui.replaceString
                val caseSensitive =
		    Gtk.toggleButtonGetActive Gui.search_case_sensitive
            in
		if txt = "" then ()
		else let
		    val found = Buffer.find (id, txt, caseSensitive)
		in
		    if found andalso !isReplace then
			(Gtk.windowSetModal(searchDialog, true);
			 Option.app (fn s => Gtk.signalDisconnect(Gui.search_replace_button, s))
			 (!replaceSignal);
			 replaceSignal :=
                             SOME (Gtk.signalConnect(Gui.search_replace_button,
						     "clicked",
						     doReplace(id, replacetxt)));
			 Gtk.widgetSetSensitive(Gui.search_replace_button,true))
		    else
			(Gtk.windowSetModal(searchDialog, false);
			 Gtk.widgetSetSensitive(Gui.search_replace_button,false))
		end
            end
                
        fun reconnect id =
            case !searchSignal of
                NONE => (searchSignal := SOME (Gtk.signalConnect(Gui.search_ok_button, "clicked", doSearch id)))
              | SOME s => (searchSignal := SOME (Gtk.signalConnect(Gui.search_ok_button, "clicked", doSearch id));
                           Gtk.signalDisconnect(Gui.search_ok_button, s))

        fun search id =
            (reconnect id;
             case Buffer.getSelection id of
                 NONE => ()
               | SOME s => Gtk.entrySetText(Gui.searchString, s);
	     Gtk.widgetSetSensitive(Gui.replaceString,false);
	     Gtk.widgetSetSensitive(Gui.label29,false);
	     Gtk.widgetSetSensitive(Gui.search_replace_button,false);
	     isReplace := false;
	     Gtk.windowSetModal(searchDialog, false);
             Gtk.widgetShowAll searchDialog;
             Gtk.widgetMap searchDialog)

	fun searchAgain(id, arg) = 
            (reconnect id;
             case Buffer.getSelection id of
                 NONE => ()
               | SOME s => Gtk.entrySetText(Gui.searchString, s);
	     doSearch id arg)

        fun replace id =
            (reconnect id;
             case Buffer.getSelection id of
                 NONE => ()
               | SOME s => Gtk.entrySetText(Gui.searchString, s);
	     Gtk.widgetSetSensitive(Gui.replaceString,true);
	     Gtk.widgetSetSensitive(Gui.label29,true);
	     Gtk.widgetSetSensitive(Gui.search_replace_button,false);
	     isReplace := true;
	     Gtk.windowSetModal(searchDialog, false);
             Gtk.widgetShowAll searchDialog;
             Gtk.widgetMap searchDialog)

	fun gotoLine id =
            let
                val dia = Gtk.dialogNew()
                val ok = Gtk.dialogAddButton(dia, "Ok",0)
                val vbox = Gtk.dialogGetFieldVbox dia

		val _ = Gtk.dialogSetHasSeparator(dia,false)
		val hbox1 = Gtk.hboxNew(false,0)
		val label1 = Gtk.labelNew("Go to line: ")
		val entry1 = Gtk.entryNew()
		val _ = Gtk.entrySetActivatesDefault(entry1, true)
		val _ = Gtk.boxPackStart(hbox1,label1,false,false,0)
		val _ = Gtk.boxPackStart(hbox1,entry1,true,true,0)
                val _ = Gtk.containerAdd(vbox, hbox1)
            in
                Gtk.windowSetTitle(dia, "Go to Line");
		Gtk.dialogSetDefaultResponse(dia, 0);
                (*Gtk.windowSetKeepAbove (modifiedDia, true); Gtk 2.4 *)
                Gtk.windowSetPosition (dia, Gtk.WIN_POS_MOUSE);
                Gtk.widgetShowAll dia;
                if Gtk.dialogRun dia = 0 then
		    (case Int.fromString (Gtk.entryGetText entry1) of
			 NONE => ()
		       | SOME line =>
			     let
				 val buf = Buffer.getBuffer id
				 val iter = Gtk.textIterNew()
				 val _ = Gtk.textBufferGetIterAtLine(buf,iter,line-1)
			     in
				 Gtk.textBufferPlaceCursor(buf, iter);
				 Buffer.scrollToCursor id
			     end)
                else ();
                Gtk.widgetDestroy dia
            end
    end
