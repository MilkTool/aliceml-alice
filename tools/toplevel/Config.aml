(*
 * Authors:
 *   Guido Tack <tack@ps.uni-sb.de>
 *
 * Copyright:
 *   Guido Tack, 2005
 *
 * Last Change:
 *   $Date$ by $Author$
 *   $Revision$
 *
 *)

import structure Gtk from "x-alice:/lib/gtk/Gtk"
import structure Gdk from "x-alice:/lib/gtk/Gdk"
import structure PangoEnums from "x-alice:/lib/gtk/PangoEnums"
import structure FileDialog from "FileDialog"

signature USER_CONFIG =
   sig
      val reservedColor : (int * int * int)
      val errorColor : (int * int * int)
      val stringColor : (int * int * int)
      val plainColor : (int * int * int)
      val commentColor : (int * int * int)
      val historySize : int
      val stdFontName : string
   end

structure Config =
   struct

      fun createConfigDir () =
	  let
	      val cDir = OS.FileSys.getApplicationConfigDir "Toplevel"
	      val cApp = OS.Path.getParent cDir
	      val cAppDir = (OS.FileSys.openDir cApp; false)
		  handle OS.SysErr _ => true
	  in
	      if cAppDir then
		  (OS.FileSys.mkDir cApp;
		   OS.FileSys.mkDir cDir)
	      else
		  let
		      val cDirDir = (OS.FileSys.openDir cDir; false)
			  handle OS.SysErr _ => true
		  in
		      if cDirDir then
			  OS.FileSys.mkDir cDir
		      else ()
		  end;
	      cDir
	  end

      val editorHeight = 500

      val sizeX = 750
      val sizeY = 800

      val historySize = ref 100

      val cmap   = Gdk.colormapGetSystem ()
      val ugly = Gdk.colorNew(0xf0f0, 0x2020, 0xa0a0)
      val black = Gdk.colorNew(0, 0, 0)
      val red = Gdk.colorNew(0xffff, 0, 0)
      val orange = Gdk.colorNew(0xffff, 0x8000, 0)
      val blue = Gdk.colorNew(0, 0, 0xe000)
      val green = Gdk.colorNew(0, 0x8000, 0)
      val white = Gdk.colorNew(0xffff, 0xffff, 0xffff)

      val reservedColor = ref blue
      val errorColor = ref red
      val stringColor = ref orange
      val plainColor = ref black
      val commentColor = ref green

      val _ = Gdk.colormapAllocColor(cmap, black, false, true)
      val _ = Gdk.colormapAllocColor(cmap, white, false, true)
      val _ = Gdk.colormapAllocColor(cmap, ugly, false, true)
      val _ = Gdk.colormapAllocColor(cmap, red, false, true)
      val _ = Gdk.colormapAllocColor(cmap, orange, false, true)
      val _ = Gdk.colormapAllocColor(cmap, green, false, true)
      val _ = Gdk.colormapAllocColor(cmap, blue, false, true)

      val stdFontName = ref "Courier 11"
      val stdFont = ref (Gtk.pangoFontDescriptionFromString (!stdFontName))

      type tags = {err : Gtk.object,
                   log : Gtk.object,
                   plain : Gtk.object,
                   comment : Gtk.object,
                   string : Gtk.object,
                   reserved : Gtk.object,
		   bold : Gtk.object,
                   noedit : Gtk.object}

      fun makeTags buf =
          let
              val err = Gtk.textBufferCreateTag(buf, "error", "foreground-gdk", Gtk.OBJECT (!errorColor))
              val log = Gtk.textBufferCreateTag(buf, "log", "style", Gtk.INT (PangoEnums.PangoStyleToInt PangoEnums.STYLE_ITALIC))
              val plain = Gtk.textBufferCreateTag(buf, "plain", "foreground-gdk", Gtk.OBJECT (!plainColor))

              val comment = Gtk.textBufferCreateTag(buf, "comment", "foreground-gdk", Gtk.OBJECT (!commentColor))
              val string = Gtk.textBufferCreateTag(buf, "string", "foreground-gdk", Gtk.OBJECT (!stringColor))
              val reserved = Gtk.textBufferCreateTag(buf, "reserved", "foreground-gdk", Gtk.OBJECT (!reservedColor))

              val noedit = Gtk.textBufferCreateTag(buf, "noedit", "editable", Gtk.BOOL false)
              val bold = Gtk.textBufferCreateTag(buf, "bold", "weight", Gtk.INT (PangoEnums.PangoWeightToInt PangoEnums.WEIGHT_BOLD))
          in
              {err, log, plain, comment, string, reserved, bold, noedit} : tags
          end

      fun changeColor (tag, color) =
	  Gtk.objectSetObject(tag, "foreground-gdk", color)


      fun getRgbColor color =
	  (Gdk.colorGetFieldRed color,
	   Gdk.colorGetFieldGreen color,
	   Gdk.colorGetFieldBlue color)

      fun mkRgbColor (r,g,b) =
	  let val c = Gdk.colorNew(r,g,b)
	  in
	      Gdk.colormapAllocColor(cmap, c, false, true);
	      c
	  end

      fun changeColors buf =
	  let
	      val tt = Gtk.textBufferGetTagTable buf
	      val plain = Gtk.textTagTableLookup(tt, "plain")
	      val error = Gtk.textTagTableLookup(tt, "error")
	      val string = Gtk.textTagTableLookup(tt, "string")
	      val reserved = Gtk.textTagTableLookup(tt, "reserved")
	      val comment = Gtk.textTagTableLookup(tt, "comment")
	  in
	      changeColor(plain, !plainColor);
	      changeColor(error, !errorColor);
	      changeColor(string, !stringColor);
	      changeColor(reserved, !reservedColor);
	      changeColor(comment, !commentColor)
	  end

      fun init() =
	  let
	      val cDir = OS.FileSys.getApplicationConfigDir "Toplevel"
	      val p = Pickle.load (cDir^"/Configuration."^Pickle.extension)
	      structure C = unpack p : USER_CONFIG
	  in
	      stdFontName := C.stdFontName;
	      stdFont := Gtk.pangoFontDescriptionFromString (!stdFontName);

	      plainColor := mkRgbColor C.plainColor;
	      errorColor := mkRgbColor C.errorColor;
	      stringColor := mkRgbColor C.stringColor;
	      reservedColor := mkRgbColor C.reservedColor;
	      commentColor := mkRgbColor C.commentColor;

	      historySize := C.historySize
	  end handle (OS.SysErr _ | IO.Io _ | Package.Mismatch _) => ()

      fun save() =
	  let
	      val cDir = createConfigDir ()
	      structure C = 
	      struct
		  val reservedColor = getRgbColor (!reservedColor)
		  val errorColor = getRgbColor (!errorColor)
		  val stringColor = getRgbColor (!stringColor)
		  val plainColor = getRgbColor (!plainColor)
		  val commentColor = getRgbColor (!commentColor)
		  val historySize = !historySize
		  val stdFontName = !stdFontName
	      end
	  in
	      Pickle.save(cDir^"/Configuration."^Pickle.extension,
			  pack C : USER_CONFIG)
	  end handle (OS.SysErr _ | IO.Io _) =>
	      FileDialog.message
	      "Could not save configuration data."

     (* History management *)
      fun loadHistory() =
	  let
	      val cDir = OS.FileSys.getApplicationConfigDir "Toplevel"
	      val p = Pickle.load (cDir^"/History."^Pickle.extension)
	      structure C = unpack p : (val history : string list)
	  in
	      {prev=C.history, current="", next=[]}
	  end handle (IO.Io _ | OS.SysErr _ | Package.Mismatch _) =>
	      {prev=[], current="",next=[]}

      fun saveHistory ({prev,current,next}, openFiles) =
	  let
	      val cDir = createConfigDir ()
	      val prev =
		  case next of nil   => rev prev
		             | n::nr => rev (prev@nr)
	      val prev =
		  if List.length prev <= !historySize then rev prev
		  else rev (List.take (prev, !historySize))
	      structure C = struct
				val history = prev
				val openFiles = openFiles
			    end
	  in
	      Pickle.save(cDir^"/History."^Pickle.extension,
			  pack C : (val history : string list
				    val openFiles : string list))
	  end

     (* Restore open files *)
      fun loadOpenFiles() =
	  let
	      val cDir = OS.FileSys.getApplicationConfigDir "Toplevel"
	      val p = Pickle.load (cDir^"/History."^Pickle.extension)
	      structure C = unpack p : (val openFiles : string list)
	  in
	      C.openFiles
	  end handle (IO.Io _ | OS.SysErr _ | Package.Mismatch _) => nil

   end
