(*
 * Authors:
 *   Guido Tack <tack@ps.uni-sb.de>
 *
 * Copyright:
 *   Guido Tack, 2004
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Parser from "Parser"
import structure CodeEmitter from "CodeEmitter"

signature MAIN =
  sig
      val main : string list -> OS.Process.status
  end

structure Main :> MAIN =
  struct

      val gladeFile: string option ref = ref NONE
      val outputFile: string option ref = ref NONE
      val signalsOutputFile : string option ref = ref NONE

      fun start(gladeFile, outputFile, signalsOutputFile) =
	  let
	      val doc = CodeEmitter.newBuffered(outputFile)
	      val sigDoc = CodeEmitter.newBuffered(signalsOutputFile)
	  in
	      (Parser.parse(gladeFile, doc, sigDoc);
	       CodeEmitter.close doc;
	       CodeEmitter.close sigDoc;
	       OS.Process.success)
	      handle Parser.ParseError s => 
		     (CodeEmitter.close doc;
		      TextIO.output(TextIO.stdErr,
				    "alice-glade Error: "^s^"\n");
		      OS.Process.failure)
	  end

      fun stripSuffix suf s = if String.isSuffix suf s then
				  String.substring(s,0,
						   (String.size s)-
						   (String.size suf)-1)
			      else s

      fun getOutputName gladeFile = stripSuffix "glade" gladeFile
      fun getSignalsOutputName gladeFile = 
	  (stripSuffix "glade" gladeFile)^"Signals"
      fun getSignalsOutputName2 outputFile = 
	  (stripSuffix "aml" outputFile)^"Signals"


      fun usage (SOME s, status) =
	  (TextIO.output (TextIO.stdErr, "alice-glade: " ^ s ^ "\n");
	   usage (NONE, status))
	| usage (NONE, status) =
	  (TextIO.output
	       (TextIO.stdErr,
		"Usage: alice-glade [<option> ...] <glade file>\n\n\
	 \Options:\n\
	 \-?, -h, --help, --usage\n\
	 \    Display this message.\n\
	 \-o FILE, --output FILE\n\
	 \    Specify the output file name (mandatory).\n");
	       status)

      fun help () = usage(NONE, OS.Process.success)
      fun usageError s = usage (SOME s, OS.Process.failure)

      fun main (("-h"|"-?"|"--help"|"--usage")::_) = help ()
	| main (("-o"|"--output")::name::rest) =
	  (case !outputFile of
	       NONE => (outputFile := SOME name; main rest)
	     | SOME _ => usageError "only one output file name may be given")
	| main (("-os"|"--output-signals")::name::rest) =
	  (case !signalsOutputFile of
	       NONE => (signalsOutputFile := SOME name; main rest)
	     | SOME _ => usageError "only one signals output file name may be given")
	| main (name::rest) =
	  (case !gladeFile of
	       NONE => (gladeFile := SOME name; main rest)
	     | SOME _ => usageError "only one glade file may be given")	  
	| main nil =
	  (case (!gladeFile, !outputFile, !signalsOutputFile) of
		 (SOME gladeFile, SOME outputFile,
		  SOME signalsOutputFile) =>
		 start (gladeFile, outputFile, signalsOutputFile)
	       | (SOME gladeFile,
		  NONE, NONE) => start (gladeFile,
					getOutputName gladeFile,
					getSignalsOutputName gladeFile)
	       | (SOME _, _, SOME _) =>
		 usageError "signals output file without output file!"
	       | (SOME gladeFile, SOME outputFile,
		  NONE) => start (gladeFile,
				  outputFile,
				  getSignalsOutputName2 outputFile)
	       | (NONE, _, _) => usageError "no glade file given")
  end

val _ = OS.Process.exit (Main.main (CommandLine.arguments ()))
