(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2000-2003
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure UnsafeValue           from "../../lib/system/UnsafeValue"
import structure Component             from "../../lib/system/Component"
import signature COMPONENT_MANAGER
    from "../../lib/system/COMPONENT_MANAGER-sig"
import signature SWITCHES              from "../infrastructure/SWITCHES-sig"
import structure Target                from "../infrastructure/Target"
import signature BACKEND_SPECIFIC
    from "../infrastructure/BACKEND_SPECIFIC-sig"
import structure MkTracingPhase        from "../infrastructure/MkTracingPhase"
import structure StampMap              from "../common/StampMap"
import structure Value                 from "Value"
import structure MkAbstractCodeGrammar from "MkAbstractCodeGrammar"
import structure MkCodeGenPhase        from "MkCodeGenPhase"

functor MkBackendSeam(structure ComponentManager: COMPONENT_MANAGER
		      structure Switches: SWITCHES): BACKEND_SPECIFIC =
    let
	structure AbstractCodeGrammar = MkAbstractCodeGrammar(Value)
	structure CodeGenPhase = 
	    MkCodeGenPhase(structure AbstractCodeGrammar = AbstractCodeGrammar
			   structure Switches = Switches)

	type value = AbstractCodeGrammar.value

	structure ThePhase =
	    struct
		structure C = CodeGenPhase.C
		structure I = CodeGenPhase.I
		structure O = Target

		fun translate x =
		    let
			val (context, (value, exportDesc)) =
			    CodeGenPhase.translate x
			val component: Component.t = UnsafeValue.cast value
			fun eval url =
			    let
				(* Extend environment first, so that
				 * background evaluation for toplevel works. *)
				(*--** Strictly speaking, there is a race
				 * condition: if eval is immediately bg'ed AND
				 * subsequent compilation reaches seam backend
				 * phase BEFORE the Vector.map below has
				 * completed, then it might encounter unbound
				 * globalIds. But obviously, that is infinitely
				 * unlikely to happen. 8-P *)
				val exports =
				    Vector.map (fn (stamp, label) =>
					let
					    val p = Promise.promise ()
					in
					    StampMap.insert (context, stamp,
							     Promise.future p);
					    (p, label)
					end) exportDesc
				val str =
				    ComponentManager.eval (url, component)
			    in
				Vector.app
				    (fn (p, label) =>
					Promise.fulfill (p,
							 UnsafeValue.projPoly
							     (str, label)))
				    exports;
				str
			    end
		    in
			(context, Target.COMPONENT
				  {component = fn () => component, eval})
		    end
	    end
	structure TracingPhase =
	    MkTracingPhase(structure Phase = ThePhase
			   structure Switches = Switches
			   val name = "Code Generation")
    in
	struct
	    open TracingPhase
	    structure O = Target
	    val isCross = false
	end
    end
