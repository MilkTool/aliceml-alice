(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2000-2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Crash                 from "../infrastructure/Crash"
import structure Stamp                 from "../common/Stamp"
import structure StampMap              from "../common/StampMap"
import structure FlatGrammar           from "../backend-common/FlatGrammar"
import signature ABSTRACT_CODE_GRAMMAR from "ABSTRACT_CODE_GRAMMAR-sig"
import signature ENVIRONMENT           from "ENVIRONMENT-sig"

functor MkEnvironment(AbstractCodeGrammar: ABSTRACT_CODE_GRAMMAR):
    ENVIRONMENT =
    struct
	structure AbstractCodeGrammar = AbstractCodeGrammar

	type scope = AbstractCodeGrammar.idRef StampMap.t
	type ids = FlatGrammar.id list
	type index = int

	type entry = {scope: scope,
		      localIndex: index,
		      globalIndex: index,
		      globalIds: ids,
		      isSpecialize: bool}

	type t = {filename: string,
		  context: AbstractCodeGrammar.value StampMap.t,
		  stack: entry list ref,
		  scope: scope ref,
		  localIndex: index ref,
		  globalIndex: index ref,
		  globalIds: ids ref,
		  isSpecialize: bool ref,
		  shared: AbstractCodeGrammar.instr StampMap.t}

	fun startTop (filename, context) =
	    {filename = filename, context = context,
	     stack = ref nil, scope = ref (StampMap.new ()),
	     localIndex = ref 0, globalIndex = ref 0, globalIds = ref nil,
	     isSpecialize = ref false, shared = StampMap.new ()}

	fun endTop ({stack = ref nil, localIndex = ref localIndex,
		     globalIds = ref nil, ...}: t) =
	    localIndex
	  | endTop _ = raise Crash.Crash "MkEnvironment.endTop"

	fun startFn ({stack, scope, localIndex,
		      globalIndex, globalIds, isSpecialize, ...}: t,
		     isSpecialize') =
	    let
		val entry = {scope = !scope,
			     localIndex = !localIndex,
			     globalIndex = !globalIndex,
			     globalIds = !globalIds,
			     isSpecialize = !isSpecialize}
	    in
		stack := entry::(!stack);
		scope := StampMap.new ();
		localIndex := 0;
		globalIndex := 0; globalIds := nil;
		isSpecialize := isSpecialize'
	    end

	fun startClose env = startFn (env, false)

	fun startSpecialize env = startFn (env, true)

	fun endFn ({stack, scope, localIndex,
		    globalIndex, globalIds, isSpecialize, ...}: t) =
	    let
		val result =
		    (Vector.fromList (List.rev (!globalIds)),
		     !localIndex)
		val {scope = scope',
		     localIndex = localIndex',
		     globalIndex = globalIndex',
		     globalIds = globalIds',
		     isSpecialize = isSpecialize'} = List.hd (!stack)
	    in
		stack := List.tl (!stack); scope := scope';
		localIndex := localIndex';
		globalIndex := globalIndex'; globalIds := globalIds';
		isSpecialize := isSpecialize';
		result
	    end

	fun filename ({filename, ...}: t) = filename

	fun declare ({scope, localIndex, ...}: t,
		     FlatGrammar.Id (_, stamp, _)) =
	    case StampMap.lookup (!scope, stamp) of
		SOME (AbstractCodeGrammar.Local id) => id
	      | SOME (AbstractCodeGrammar.Immediate _ |
		      AbstractCodeGrammar.Global _ |
		      AbstractCodeGrammar.Toplevel _) =>
		    raise Crash.Crash "MkEnvironment.declare"
	      | NONE =>
		    let
			val id = !localIndex
		    in
			localIndex := id + 1;
			StampMap.insertDisjoint
			    (!scope, stamp, AbstractCodeGrammar.Local id);
			id
		    end

	fun fresh ({localIndex, ...}: t) =
	    let
		val id = !localIndex
	    in
		localIndex := id + 1; id
	    end

	fun lookup ({context, scope,
		     globalIndex, globalIds, isSpecialize, ...}: t,
		    id as FlatGrammar.Id (_, stamp, _)) =
	    case StampMap.lookup (context, stamp) of
		SOME value => AbstractCodeGrammar.Immediate value
	      | NONE =>
	    case StampMap.lookup (!scope, stamp) of
		SOME idRef => idRef
	      | NONE =>
		    let
			val i = !globalIndex
			val idRef =
			    if !isSpecialize
			    then AbstractCodeGrammar.Toplevel i
			    else AbstractCodeGrammar.Global i
		    in
			globalIds := id::(!globalIds);
			globalIndex := i + 1;
			StampMap.insertDisjoint (!scope, stamp, idRef);
			idRef
		    end

	fun lookupStamp ({scope, shared, ...}: t, stamp) =
	    StampMap.lookup (!scope, stamp)

	fun lookupShared ({shared, ...}: t, stamp) =
	    StampMap.lookup (shared, stamp)

	fun declareShared ({shared, ...}: t, stamp, instr) =
	    StampMap.insertDisjoint (shared, stamp, instr)
    end
