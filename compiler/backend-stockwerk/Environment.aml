(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2000-2002
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Crash         from "../infrastructure/Crash"
import structure Stamp         from "../common/Stamp"
import structure StampMap      from "../common/StampMap"
import structure FlatGrammar   from "../backend-common/FlatGrammar"
import structure PickleGrammar from "PickleGrammar"
import signature ENVIRONMENT   from "ENVIRONMENT-sig"

structure Environment :> ENVIRONMENT =
    struct
	type scope = PickleGrammar.idRef StampMap.t
	type globals = FlatGrammar.id list
	type index = int

	type t = {filename: string,
		  stack: (scope * index * index * globals) list ref,
		  scope: scope ref,
		  localIndex: index ref,
		  globalIndex: index ref,
		  globals: globals ref,
		  shared: PickleGrammar.instr StampMap.t}

	fun new filename =
	    {filename = filename,
	     stack = ref nil, scope = ref (StampMap.new ()),
	     localIndex = ref 0, globalIndex = ref 0, globals = ref nil,
	     shared = StampMap.new ()}

	fun filename ({filename, ...}: t) = filename

	fun startFn ({stack, scope, localIndex, globalIndex, globals,
		      ...}: t) =
	    (stack := (!scope, !localIndex, !globalIndex, !globals)::(!stack);
	     scope := StampMap.new ();
	     localIndex := 0;
	     globalIndex := 0;
	     globals := nil)

	fun endFn ({stack, scope, localIndex, globalIndex, globals, ...}: t) =
	    case !stack of
		(scope', localIndex', globalIndex', globals')::rest =>
		    (Vector.fromList (List.rev (!globals)), !localIndex)
		    before (scope := scope';
			    localIndex := localIndex';
			    globalIndex := globalIndex';
			    globals := globals';
			    stack := rest)
	      | nil => raise Crash.Crash "Environment.endFn"

	fun declare ({scope, localIndex, ...}: t,
		     FlatGrammar.Id (_, stamp, _)) =
	    case StampMap.lookup (!scope, stamp) of
		SOME (PickleGrammar.Local i) => i
	      | SOME (PickleGrammar.Global _) =>
		    raise Crash.Crash "Environment.declare"
	      | NONE =>
			let
			    val i = !localIndex
			in
			    localIndex := i + 1;
			    StampMap.insertDisjoint (!scope, stamp,
						     PickleGrammar.Local i);
			    i
			end

	fun fresh ({localIndex, ...}: t) =
	    let
		val i = !localIndex
	    in
		localIndex := i + 1;
		i
	    end

	fun lookup ({scope, globalIndex, globals, ...}: t,
		    id as FlatGrammar.Id (_, stamp, _)) =
	    case StampMap.lookup (!scope, stamp) of
		SOME idRef => idRef
	      | NONE =>
		    let
			val i = !globalIndex
			val idRef = PickleGrammar.Global i
		    in
			globals := id::(!globals);
			globalIndex := i + 1;
			StampMap.insertDisjoint (!scope, stamp, idRef);
			idRef
		    end

	fun lookupStamp ({scope, shared, ...}: t, stamp) =
	    StampMap.lookup (!scope, stamp)

	fun lookupShared ({shared, ...}: t, stamp) =
	    StampMap.lookup (shared, stamp)

	fun declareShared ({shared, ...}: t, stamp, instr) =
	    StampMap.insertDisjoint (shared, stamp, instr)
    end
