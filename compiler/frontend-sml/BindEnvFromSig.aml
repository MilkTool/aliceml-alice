(*
 * Author:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Assert        from "../../lib/utility/Assert"
import structure Crash         from "../infrastructure/Crash"
import structure Source        from "../infrastructure/Source"
import structure Stamp         from "../common/Stamp"
import structure Name          from "../../lib/rtt/Name"
import structure Label         from "../../lib/rtt/Label"
import structure Fixity        from "../../lib/rtt/Fixity"
import structure Path          from "../../lib/rtt/Path"
import structure PathMap       from "../../lib/rtt/PathMap"
import structure Type          from "../../lib/rtt/Type"
import structure Inf           from "../../lib/rtt/Inf"
import structure PervasiveType from "../../lib/rtt/PervasiveType"
import structure VId
       structure TyCon
       structure SigId
       structure StrId         from "Ids"
import structure Infix         from "Infix"
import structure BindEnv       from "BindEnv"
import signature BIND_ENV_FROM_SIG from "BIND_ENV_FROM_SIG-sig"


structure BindEnvFromSig :> BIND_ENV_FROM_SIG =
struct

    open BindEnv

    type sign = Inf.sign


    (*
     * Fixity modes not available in SML are converted as follows:
     * - non-associative infix -> left-associative infix
     * - prefix  -> nonfix
     * - postfix -> nonfix
     *)

    fun assocFromAssoc(Fixity.LEFT)	= Infix.LEFT
      | assocFromAssoc(Fixity.RIGHT)	= Infix.RIGHT
      | assocFromAssoc(Fixity.NEITHER)	= Infix.LEFT

    fun infFromFix(Fixity.NONFIX)	= NONE
      | infFromFix(Fixity.PREFIX n)	= NONE
      | infFromFix(Fixity.POSTFIX n)	= NONE
      | infFromFix(Fixity.INFIX(n,a))	= SOME(assocFromAssoc a, n)

    fun vidFromLabel a   = VId.fromString(Label.toString a)
    fun tyconFromLabel a = TyCon.fromString(Label.toString a)
    fun stridFromLabel a = StrId.fromString(Label.toString a)
    fun sigidFromLabel a = SigId.fromString(Label.toString a)

    fun idStatusFromTyp t =
	if Type.isAll t then idStatusFromTyp(#2(Type.asAll t)) else
	let
	    val (t', t2)  = Type.asApply t
	    val (t'',t1)  = Type.asApply t'
	    val (t11,t12) = Type.asArrow t1
	in
(*ASSERT    assert Type.equals(t'', PervasiveType.typ_conarrow) =>*)
	    if not(Type.equals(t'', PervasiveType.typ_conarrow))
	    then raise Assert.failure else
	    idStatusFromTyp'(t12, t2)
	end
	handle Type.Type =>
	    raise Crash.Crash "BindEnvFromSig: strange constructor field"

    and idStatusFromTyp'(t1,t2) =
	if Type.isApply' t1 then
	    idStatusFromTyp'(#1(Type.asApply' t1), t2)
	else if Type.isSum' t1 then
	    T(arityFromNatTyp t2)
	else if Type.equals(t1, PervasiveType.typ_ref) then
	    R
	else if Type.isCon' t1 andalso #2(Type.asCon' t1) = Type.OPEN then
	    C(arityFromNatTyp t2)
	else
	    raise Type.Type

    and arityFromNatTyp t =
	if Type.isApply t then
	    1 + arityFromNatTyp(#1(Type.asApply t))
	else 0


    fun envFromTyp(I,E,s,t) =
	if Type.equals(t, PervasiveType.typ_ref) then
	    let
		(*UNFINISHED: constructor currently gets the same name
		 * as the tycon, because we have no way of knowing its
		 * real name. HACK, ref is still broken... *)
		val  E     = new()
		val  z     = Stamp.new()
		val  z'    = Stamp.new()
		val  name  = Label.toString(Path.toLab(#3(Type.asCon t)))
		val  name' = "'" ^ name
		val  vid   = VId.fromString name
		val  vid'  = VId.fromString name'
	    in
		insertVal(E, vid', (I,z',V)) ;
		insertVal(E, vid, (I,z,R)) ;
		E
	    end
	else
	    envFromTyp'(I,E,s,t)

    and envFromTyp'(I,E,s,t) =
	if      Type.isSum t    then envFromRow(I, E,s, Type.asSum t)
	else if Type.isLambda t then envFromTyp(I, E,s, #2(Type.asLambda t))
	else if Type.isMu t     then envFromTyp(I, E,s, Type.asMu t)
	else new()

    and envFromRow(I,E,s,r) =
	let
	    val E' = new()

	    fun loop r =
		if Type.isEmptyRow r then () else
		let
		    val (a,ts) = Type.headRow r
		    val  name  = Label.toString a
		    val  name' = "'" ^ name
		    val  vid   = VId.fromString name
		    val  vid'  = VId.fromString name'
		    val value  = Option.valOf(lookupScopeVal(E, vid))
		    val value' = Option.valOf(lookupScopeVal(E, vid'))
		    (* UNFINISHED: check that the constructor actually
		     * constructs the type in question.
		     * What if the constructors are actually hidden
		     * by following members???
		     *)
		in
		    insertVal(E', vid', value');
		    insertVal(E', vid, value);
		    loop(Type.tailRow r)
		end
	in
	    ( loop r ; E' )
	    handle Option.Option => new()
	end


    fun explodePath p =
	if Path.isDot p then
	    let val (p',l,n) = Path.asDot p
	    in explodePath'(p', [], sigidFromLabel l) end
	else
	    (p, [], sigidFromLabel(Path.toLab p))
    and explodePath'(p, strids, sigid) =
	if Path.isDot p then
	    let val (p',l,n) = Path.asDot p
	    in explodePath'(p', stridFromLabel l :: strids, sigid) end
	else
	    (p, strids, sigid)

    fun selectSig(PLAIN E, [l])   = #3(valOf(lookupSig(E, sigidFromLabel l)))
      | selectSig(PLAIN E, l::ls) =
	selectSig(#3(valOf(lookupStr(E, stridFromLabel l))), ls)
      | selectSig _               = raise Crash.Crash "BindEnvFromSig.selectSig"

    fun envfnFromInf(I,j) = envfnFromInf'(I, PathMap.new(), j)
    and envfnFromInf'(I,pm,j) =
	if Inf.isTop j then
	    EMPTY
	else if Inf.isCon j then
	    let
		val (k,p)             = Inf.asCon j
		val (p',strids,sigid) = explodePath p
		val  z                = case PathMap.lookup(pm,p')
					  of SOME z => z
					   | NONE   => Stamp.new()
	    in
		ABSTR(z,strids,sigid,[])
	    end
	else if Inf.isSig j then
	    PLAIN(envFromSig'(I, pm, Stamp.new(), Inf.asSig j))
	else if Inf.isArrow j then
	    let
		val (p,j1,j2) = Inf.asArrow j
		val  z        = Stamp.new()
	    in
		PathMap.insert(pm,p,z);
		PARAM(z, envfnFromInf'(I,pm,j2))
	    end
	else if Inf.isLambda j then
	    let
		val (p,j1,j2) = Inf.asLambda j
		val  z        = Stamp.new()
	    in
		PathMap.insert(pm,p,z);
		PARAM(z, envfnFromInf'(I,pm,j2))
	    end
	else if Inf.isApply j then
	    let
		val (j1,_,j2) = Inf.asApply j
		val  F1       = envfnFromInf'(I,pm,j1)
		val  F2       = envfnFromInf'(I,pm,j2)
	    in
		apply(F1,F2)
	    end
	else
	    raise Crash.Crash "BindEnvFromSig.envFromInf: unknown interface"

    and envFromSig (I,s)    = envFromSig'(I, PathMap.new(), Stamp.new(), s)
    and envFromSig'(I,pm,z,s) =
	let
	    val E     = new()
	    val items = Inf.items s
	in
	    insertSelf E;
	    List.app (insertValItem(E,I,s)) items;
	    List.app (insertItem(E,I,pm,z,s)) items;
	    E
	end

    and insertValItem (E,I,s) item =
	if Inf.isValItem item then
	    let
		val (l,t,d) = Inf.asValItem item
		val  name   = Label.toString l
		val  vid    = vidFromLabel l
		val  x      = Stamp.new()
	    in
		if String.sub(name,0) = #"'" then
		    insertVal(E, vid, (I,x,V))
		else
		let
		    (* UNFINISHED: again we have a hiding problem here:
		     * What if the item is not actually connected to the
		     * constructor field of the same name, because it hides it?
		     *)
		    val l' = Label.fromString("'" ^ name)
		    val is = idStatusFromTyp(Inf.lookupVal(s,l'))
			     handle Inf.Lookup => V
		in
		    insertVal(E, vid, (I,x,is))
		end
	    end
	else
	    ()

    and insertItem (E,I,pm,z,s) item =
	if Inf.isFixItem item then
	    let
		val (l,f) = Inf.asFixItem item
		val  is   = infFromFix f
	    in
		insertInf(E, vidFromLabel l, (I,is))
	    end
	else if Inf.isTypItem item then
	    let
		val (l,k,d) = Inf.asTypItem item
		val  x      = Stamp.new()
		val  E'     = case d
				of NONE   => new()
				 | SOME t => envFromTyp(I,E,s,t)
	    in
		insertTy(E, tyconFromLabel l, (I,x,E'))
	    end
	else if Inf.isModItem item then
	    let
		val (l,j,_) = Inf.asModItem item
		val  F      = envfnFromInf'(I,pm,j)
		val  x      = case F of PLAIN E' => Option.valOf(lookupSelf E')
				      | _        => Stamp.new()
	    in
		insertStr(E, stridFromLabel l, (I,x,F))
	    end
	else if Inf.isInfItem item then
	    let
		val (l,k,jo) = Inf.asInfItem item
		val  p       = Inf.pathInf(s,l)
		val  F       = envfnFromInf'(I, pm, Inf.lookupInf(s,l))
		val  x       = Stamp.new()
	    in
		PathMap.insert(pm,p,z);
		insertSig(E, sigidFromLabel l, (I,x,F))
	    end
	else
	     ()

end
