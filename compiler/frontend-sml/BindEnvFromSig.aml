(*
 * Author:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Assert        from "../../lib/utility/Assert"
import structure Crash         from "../infrastructure/Crash"
import structure Source        from "../infrastructure/Source"
import structure Stamp         from "../common/Stamp"
import structure Name          from "../../lib/rtt/Name"
import structure Label         from "../../lib/rtt/Label"
import structure Fixity        from "../../lib/rtt/Fixity"
import structure Path          from "../../lib/rtt/Path"
import structure PathMap       from "../../lib/rtt/PathMap"
import structure Type          from "../../lib/rtt/Type"
import structure Inf           from "../../lib/rtt/Inf"
import structure PervasiveType from "../../lib/rtt/PervasiveType"
import structure VId
       structure TyCon
       structure SigId
       structure StrId         from "Ids"
import structure Infix         from "Infix"
import structure BindEnv       from "BindEnv"
import signature BIND_ENV_FROM_SIG from "BIND_ENV_FROM_SIG-sig"


(*
 * This module is a hack. The main problem we have is to reconstruct
 * identifier status for values. These are our heuristics for deriving the
 * identifier status is for value identifier id with type !a1..an.t:
 *
 * - if there is a type d = mu\a1..\an.[id:<!>t',r] and t = t'->d a1..an,
 *   then is = T(k,d) for suitable k
 * - if there is a value 'id with type !a1..an.conarrow(<!>t1->t2) and t=t1->t2,
 *   then is = C k for suitable k
 * - if there is a type id = Ref and t = 'a->Ref 'a, then is = R
 * - otherwise, is = V
 *
 * This is merely an approximation that may, in pathological cases, assign
 * non-value status to values. This can happen when converting interfaces
 * that have been inferred from components containing obscur forms of hiding.
 * Here is an example:
 *
 *   functor F(X : sig type t val C : int -> t end) = X
 *   datatype t = C of int
 *   structure X = F(datatype t = datatype t)
 *   open X
 *
 * This can actually lead to the wrong semantics (consider F wrapping
 * the argument function C with some side-effect, this would not be
 * executed in the importing component). Note however that such examples are
 * pretty contrived and can only appear for toplevel entities or structures
 * not constrained by a signature - both are discouraged anyway.
 *
 * Still it's very unfortunate, but there are only two ways of avoiding it:
 * - put identifier status into signatures
 *   (conceptionally it's purely syntactic and does not belong there -
 *    OTOH fixity is there already...)
 * - delete the possibility to match values with constructors
 *   (serious departure from SML that actually would break the compiler)
 * So I hate both... Hopefully we have a better solution one day in the context
 * of a general views framework.
 *)

structure BindEnvFromSig :> BIND_ENV_FROM_SIG =
struct

    open BindEnv

    type sign = Inf.sign


    (*
     * Fixity modes not available in SML are converted as follows:
     * - non-associative infix -> left-associative infix
     * - prefix  -> nonfix
     * - postfix -> nonfix
     *)

    fun assocFromAssoc(Fixity.LEFT)	= Infix.LEFT
      | assocFromAssoc(Fixity.RIGHT)	= Infix.RIGHT
      | assocFromAssoc(Fixity.NEITHER)	= Infix.LEFT

    fun infFromFix(Fixity.NONFIX)	= NONE
      | infFromFix(Fixity.PREFIX n)	= NONE
      | infFromFix(Fixity.POSTFIX n)	= NONE
      | infFromFix(Fixity.INFIX(n,a))	= SOME(assocFromAssoc a, n)

    fun vidFromLabel a   = VId.fromString(Label.toString a)
    fun tyconFromLabel a = TyCon.fromString(Label.toString a)
    fun stridFromLabel a = StrId.fromString(Label.toString a)
    fun sigidFromLabel a = SigId.fromString(Label.toString a)


    fun unstrict t =
	if not(Type.isApply t) then t else
	let
	    val (t1,t2) = Type.asApply t
	in
	    if not(Type.equal(t1, PervasiveType.typ_strict))
	    then t
	    else t2
	end

    fun unapp t = unapp'(t, [])
    and unapp'(t, ts) =
	if not(Type.isApply t) then (t,ts) else
	let
	    val (t1,t2) = Type.asApply t
	in
	    unapp'(t1, t2::ts)
	end


    fun arityFromTyp t =
	if not(Type.isApply t) then UNARY else
	let
	    val (t1,t2) = Type.asApply t
	in
	    if Type.equal(t1, PervasiveType.typ_strict) then
		if Type.isTuple t2 andalso Vector.length(Type.asTuple t2) = 0
		then NULLARY
		else NARY
	    else UNARY
	end


    fun envFromTyp(I,E,s,t,tycon) =
	if Type.equal(t, PervasiveType.typ_ref) then
	    let
		(* Constructor needs to have the same name as the tycon,
		 * because we have no way of knowing its real name. *)
		val E'      = new()
		val name    = TyCon.toString tycon
		val l       = Label.fromString name
		val t'      = Type.instance(Inf.lookupVal(s,l))
		val (t1,t2) = Type.asArrow t'
		val (t3,t4) = Type.asApply t2
		val vid     = VId.fromString name
	    in
		if Type.isUnknown t1 andalso Type.equal(t1,t4)
				     andalso Type.equal(t3, t)
		then insertVal(E', vid, (I, Stamp.new(), R))
		else ();
		E'
	    end handle (Inf.Lookup | Type.Type) => new()
	else
	    envFromTyp'(I,E,s,t,t,tycon,0)

    and envFromTyp'(I,E,s,t,t0,tycon,k) =
	if      Type.isSum t then envFromRow(I, E,s, Type.asSum t, t0, tycon, k)
	else if Type.isLambda t then envFromTyp'(I, E,s, #2(Type.asLambda t),
							t0, tycon, k+1)
	else if Type.isMu t  then envFromTyp'(I, E,s, Type.asMu t, t0, tycon, k)
	else new()

    and envFromRow(I,E,s,r,t0,tycon,k) =
	let
	    val E' = new()

	    fun loop r =
		if Type.isEmptyRow r then () else
		let
		    val (l,t')  = Type.hdRow r
		    val  is     = T(arityFromTyp t', tycon, k)
		    val  t''    = Type.instance(Inf.lookupVal(s,l))
		    val (t1,t2) = if Type.isArrow t''
				  then Type.asArrow t''
				  else (Type.tuple #[], t'')
		    val (t3,ts) = unapp t2
		    val  vid    = VId.fromString(Label.toString l)
		in
		    if not(List.all Type.isUnknown ts) then raise Type.Type else
		    Type.unify(t0, t3);
		    Type.unify(t1, unstrict t');
		    insertVal(E', vid, (I, Stamp.new(), is));
		    loop(Type.tlRow r)
		end
	in
	    ( loop r ; E' )
	    handle (**)e as (Inf.Lookup | Type.Type | Type.Unify _) => new()
	end


    fun explodePath p =
	if Path.isDot p then
	    let val (p',l) = Path.asDot p
	    in explodePath'(p', [], sigidFromLabel l) end
	else
	    (p, [], sigidFromLabel(Path.toLab p))
    and explodePath'(p, strids, sigid) =
	if Path.isDot p then
	    let val (p',l) = Path.asDot p
	    in explodePath'(p', stridFromLabel l :: strids, sigid) end
	else
	    (p, strids, sigid)

    fun selectSig(PLAIN E, [l])   = #3(valOf(lookupSig(E, sigidFromLabel l)))
      | selectSig(PLAIN E, l::ls) =
	selectSig(#3(valOf(lookupStr(E, stridFromLabel l))), ls)
      | selectSig _               = raise Crash.Crash "BindEnvFromSig.selectSig"

    fun envfnFromInf(I,j) = envfnFromInf'(I, PathMap.new(), j)
    and envfnFromInf'(I,pm,j) =
	if Inf.isTop' j then
	    EMPTY
	else if Inf.isAbs' j then
	    let
		val  p                = Inf.asAbs' j
		val (p',strids,sigid) = explodePath p
		val  z                = case PathMap.lookup(pm,p')
					  of SOME z => z
					   | NONE   => Stamp.new()
	    in
		ABSTR(z,strids,sigid,[])
	    end
	else if Inf.isSig' j then
	    PLAIN(envFromSig'(I, pm, Stamp.new(), Inf.asSig' j))
	else if Inf.isArrow' j then
	    let
		val (p,j1,j2) = Inf.asArrow' j
		val  z        = Stamp.new()
		val  zo       = PathMap.lookup(pm,p)
	    in
		PathMap.insert(pm,p,z);
		PARAM(z, envfnFromInf'(I,pm,j2))
		before
		(case zo of NONE => () | SOME z' => PathMap.insert(pm,p,z'))
	    end
	else if Inf.isLambda j then
	    let
		val (p,j1,j2) = Inf.asLambda j
		val  z        = Stamp.new()
		val  zo       = PathMap.lookup(pm,p)
	    in
		PathMap.insert(pm,p,z);
		PARAM(z, envfnFromInf'(I,pm,j2))
		before
		(case zo of NONE => () | SOME z' => PathMap.insert(pm,p,z'))
	    end
	else if Inf.isApply j then
	    let
		val (j1,(_,j2)) = Inf.asApply j
		val  F1         = envfnFromInf'(I,pm,j1)
		val  F2         = envfnFromInf'(I,pm,j2)
	    in
		apply(F1,F2)
	    end
	else
	    raise Crash.Crash "BindEnvFromSig.envFromInf: unknown interface"

    and envFromSig (I,s)    = envFromSig'(I, PathMap.new(), Stamp.new(), s)
    and envFromSig'(I,pm,z,s) =
	let
	    val E     = new()
	    val items = Inf.items s
	in
	    insertSelf E;
	    (* Insert values first, as they may be overwritten by type
	     * items (datatypes). *)
	    List.app (insertValItem(E,I,s)) items;
	    List.app (insertItem(E,I,pm,z,s)) items;
	    E
	end

    and insertValItem (E,I,s) item =
	if Inf.isValItem item then
	    let
		val (l,t) = Inf.asValItem item
		val  name = Label.toString l
		val  vid  = vidFromLabel l
		val  x    = Stamp.new()
		val  is   = if String.sub(name,0) = #"'" then V else
			    let
				val l' = Label.fromString("'" ^ name)
				val t' = Type.instance(Inf.lookupVal(s,l'))
				val (t1,t2) = Type.asApply t'
				val (t11',t12') = Type.asArrow t2
				val (t11, t12)  = if Type.isArrow t
						  then Type.asArrow t
						  else (Type.tuple #[], t)
			    in
				(* t1 = conarrow *)
				Type.unify(t11, unstrict t11');
				Type.unify(t12, t12);
				C(arityFromTyp t11')
			    end
			    handle (Inf.Lookup | Type.Unify _) => V
	    in
		insertDisjointVal(E, vid, (I,x,is))
	    end
	else
	    ()

    and insertItem (E,I,pm,z,s) item =
	if Inf.isFixItem item then
	    let
		val (l,f) = Inf.asFixItem item
		val  is   = infFromFix f
	    in
		insertInf(E, vidFromLabel l, (I,is))
	    end
	else if Inf.isTypItem item then
	    let
		val (p,k) = Inf.asTypItem item
		val  l    = Path.toLab p
		val  x    = Stamp.new()
		val  E'   = if not(Type.isSingKind k)
			    then new()
			    else envFromTyp(I,E,s, Type.asSingKind k,
					    TyCon.fromString(Label.toString l))
	    in
		insertDisjointTy(E, tyconFromLabel l, (I,x,E'));
		appiVals (fn(vid,x) => insertVal(E, vid, x)) E'
	    end
	else if Inf.isModItem item then
	    let
		val (p,j) = Inf.asModItem item
		val  l    = Path.toLab p
		val  F    = envfnFromInf'(I,pm,j)
		val  x    = case F of PLAIN E' => Option.valOf(lookupSelf E')
				    | _        => Stamp.new()
	    in
		insertDisjointStr(E, stridFromLabel l, (I,x,F))
	    end
	else if Inf.isInfItem item then
	    let
		val (p,k) = Inf.asInfItem item
		val  l    = Path.toLab p
		val  F    = envfnFromInf'(I, pm, Inf.lookupInf'(s,l))
		val  x    = Stamp.new()
	    in
		PathMap.insert(pm,p,z);
		insertDisjointSig(E, sigidFromLabel l, (I,x,F))
	    end
	else
	     ()

end
