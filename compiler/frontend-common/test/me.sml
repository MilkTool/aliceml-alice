(* src # 0 ../../lib/bootstrap/Bootstrap.aus *)
(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 1999
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(* Hardwired *)

__prebound Prebound

datatype bool   = datatype Prebound.bool
type     int    = Prebound.int
type     word   = Prebound.word
type     real   = Prebound.real
type     string = Prebound.string
type     char   = Prebound.char
type  'a vector = 'a Prebound.vector
datatype list   = datatype Prebound.list
datatype ref    = datatype Prebound.ref
datatype exn    = datatype Prebound.exn

exception Match = Prebound.Match
exception Bind  = Prebound.Bind


(* Toplevel *)

infix  7  * / div mod
infix  6  + - ^
infixr 5  :: @
infix  4  = <> > >= < <=
infix  3  := o
infix  0  before

(*--** __primitive val use : string -> unit = "use" *)

__primitive val op=  : ''a * ''a -> bool = "="
__primitive val op<> : ''a * ''a -> bool = "<>"


(* Overloaded Identifiers *)

__primitive val op~ :	int -> int = "~"

__primitive val op+ :	int * int -> int = "+"
__primitive val op- :	int * int -> int = "-"
__primitive val op* :	int * int -> int = "*"
__primitive val op div:	int * int -> int = "div"
__primitive val op mod:	int * int -> int = "mod"

__primitive val op< :	int * int -> bool = "<"
__primitive val op> :	int * int -> bool = ">"
__primitive val op<= :	int * int -> bool = "<="
__primitive val op>= :	int * int -> bool = ">="


(* General *)

structure General =
  struct

    type unit = {}
    type exn  = exn

    exception Bind = Bind
    __primitive constructor Chr: exn = "General.Chr"
    __primitive constructor Div: exn = "General.Div"
    __primitive constructor Domain: exn = "General.Domain"
    __primitive constructor Fail of string: exn = "General.Fail"
    exception Match = Match
    __primitive constructor Overflow: exn = "General.Overflow"
    __primitive constructor Size: exn = "General.Size"
    __primitive constructor Span: exn = "General.Span"
    __primitive constructor Subscript: exn = "General.Subscript"

    datatype order = LESS | EQUAL | GREATER

    fun !(ref v) = v

    __primitive val op:= : 'a ref * 'a -> unit = ":="

    fun (f o g) a  = f(g a)
    fun a before b = a
    fun ignore a   = ()

  end

open General


(* Option *)

structure Option =
  struct

    datatype 'a option = NONE | SOME of 'a

    __primitive constructor Option: exn = "Option.Option"

    fun getOpt(SOME v, _) = v
      | getOpt(NONE,   a) = a

    fun isSome(SOME v) = true
      | isSome NONE    = false

    fun valOf(SOME v) = v
      | valOf NONE    = raise Option

    fun filter f a = if f a then SOME a else NONE

    fun join NONE    = NONE
      | join(SOME v) = v

    fun map f  NONE    = NONE
      | map f (SOME v) = SOME(f v)

    fun mapPartial f  NONE    = NONE
      | mapPartial f (SOME v) = f v

    fun compose (f,g) a =
	case g a
	  of NONE   => NONE
	   | SOME v => SOME(f v)

    fun composePartial (f,g) a =
	case g a
	  of NONE   => NONE
	   | SOME v => f v

  end

datatype option = datatype Option.option


(* Bool *)

structure Bool =
  struct

    datatype bool = datatype bool

    fun not true  = false
      | not false = true

    fun toString true  = "true"  : string
      | toString false = "false" : string

  end

val not = Bool.not


(* List *)

structure List =
  struct

    datatype list = datatype list

    __primitive constructor Empty: exn = "List.Empty"

    fun null [] = true
      | null _  = false

    fun length xs =
	let fun length'(nil,   n) = n
	      | length'(y::ys, n) = length'(ys,n+1)
	in length'(xs,0) end

    fun   nil   @ ys = ys
      | (x::xs) @ ys = x :: xs @ ys

    fun hd(x::xs) = x
      | hd  _     = raise Empty

    fun tl(x::xs) = xs
      | tl  _     = raise Empty

    fun last(x::nil) = x
      | last(x::xs)  = last xs
      | last  nil    = raise Empty

    fun getItem(x::xs) = SOME(x,xs)
      | getItem  nil   = NONE

    fun nth(l,i) =
	let fun nth'(x::xs, 0) = x
	      | nth'(x::xs, j) = nth'(xs, j-1)
	      | nth'(nil,   j) = raise Subscript
	in if i >= 0 then nth'(l,i) else raise Subscript end

    fun rev l =
	let fun rev'( nil,  ys) = ys
	      | rev'(x::xs, ys) = rev'(xs, x::ys)
	in rev'(l,nil) end

    fun take(l,i) =
	let fun take'(x::xs, 0, ys) = rev ys
	      | take'(x::xs, j, ys) = take'(xs, j-1, x::ys)
	      | take'(nil,   j, ys) = raise Subscript
	in if i >= 0 then take'(l,i,nil) else raise Subscript end

    fun drop(l,i) =
	let fun drop'(xs,    0) = xs
	      | drop'(x::xs, j) = drop'(xs, j-1)
	      | drop'(nil,   j) = raise Subscript
	in if i >= 0 then drop'(l,i) else raise Subscript end

    fun concat  nil   = nil
      | concat(l::ls) = l @ concat ls

    fun revAppend( nil,  ys) = ys
      | revAppend(x::xs, ys) = revAppend(xs, x::ys)

    fun app f   nil   = ()
      | app f (x::xs) = (f x ; app f xs)

    fun map f   nil   = nil
      | map f (x::xs) = f x :: map f xs

    fun mapPartial f   nil   = nil
      | mapPartial f (x::xs) =
	let val yo = f x
	    val ys = mapPartial f xs
	in case yo of NONE => ys | SOME y => y::ys end

    fun find f   nil   = NONE
      | find f (x::xs) = if f x then SOME x else find f xs

    fun filter f   nil   = nil
      | filter f (x::xs) =
	let val b  = f x
	    val ys = filter f xs
	in if b then x::ys else ys end

    fun partition f l =
	let fun partition'( nil,  pos, neg) = (rev pos, rev neg)
	      | partition'(x::xs, pos, neg) =
		if f x then partition'(xs, x::pos, neg)
		       else partition'(xs, pos, x::neg)
	in partition'(l,nil,nil) end

    fun foldl f b   nil   = b
      | foldl f b (x::xs) = foldl f (f(x,b)) xs

    fun foldr f b   nil   = b
      | foldr f b (x::xs) = f(x, foldr f b xs)

    fun exists f   nil   = false
      | exists f (x::xs) = f x orelse exists f xs

    fun all f   nil   = true
      | all f (x::xs) = f x andalso all f xs

    fun tabulate(n, f) =
	let fun tabulate'(i,l) = if i = n then rev l
					  else tabulate'(i+1, f i :: l)
	in if n >= 0 then tabulate'(0, nil) else raise Size end

  end


(* ListPair *)

structure ListPair =
  struct

    fun zip(l1, l2) =
	let fun zip'( nil,    _,   l) = List.rev l
	      | zip'(  _,    nil,  l) = List.rev l
	      | zip'(x::xs, y::ys, l) = zip'(xs, ys, (x,y)::l)
	in zip'(l1, l2, nil) end

    fun unzip l =
	let fun unzip'(    nil,   l1, l2) = (List.rev l1, List.rev l2)
	      | unzip'((x,y)::l', l1, l2) = unzip'(l', x::l1, y::l2)
	in unzip'(l, nil, nil) end

    fun map f ( nil,    _  ) = nil
      | map f (  _,    nil ) = nil
      | map f (x::xs, y::ys) = f(x,y) :: map f (xs,ys)

    fun app f ( nil,    _  ) = ()
      | app f (  _,    nil ) = ()
      | app f (x::xs, y::ys) = (f(x,y) ; app f (xs,ys))

    fun foldl f c ( nil,    _  ) = c
      | foldl f c (  _,    nil ) = c
      | foldl f c (x::xs, y::ys) = f(x, y, foldl f c (xs,ys))

    fun foldr f c ( nil,    _  ) = c
      | foldr f c (  _,    nil ) = c
      | foldr f c (x::xs, y::ys) = foldr f (f(x,y,c)) (xs,ys)

    fun exists f ( nil,    _  ) = false
      | exists f (  _,    nil ) = false
      | exists f (x::xs, y::ys) = f(x,y) orelse exists f (xs,ys)

    fun all f ( nil,    _  ) = true
      | all f (  _,    nil ) = true
      | all f (x::xs, y::ys) = f(x,y) andalso all f (xs,ys)

  end


(* Char *)

structure Char =
    struct
	type char = char

	__primitive val <= : char * char -> bool = "Char.<="

	__primitive val ord : char -> int = "Char.ord"
	__primitive val chr : int -> char = "Char.chr"

	__primitive val isAlphaNum : char -> bool = "Char.isAlphaNum"
	__primitive val isDigit :    char -> bool = "Char.isDigit"
	__primitive val isHexDigit : char -> bool = "Char.isHexDigit"
	__primitive val isSpace :    char -> bool = "Char.isSpace"
	__primitive val toLower :    char -> char = "Char.toLower"

	__primitive val toCString :  char -> string = "Char.toCString"
    end


(* String *)

structure String =
    struct
	type string = string

	__primitive val op^ : string * string -> string = "String.^"
	__primitive val str : char -> string = "String.str"
	__primitive val size : string -> int = "String.size"
	__primitive val substring : string * int * int -> string =
							"String.substring"
	__primitive val sub : string * int -> char = "String.sub"
	__primitive val explode : string -> char list = "String.explode"

	fun extract (s, i, NONE) = substring (s, i, size s - i)
	  | extract (s, i, SOME j) = substring (s, i, j)

	fun concat l = List.foldr (fn (s, rest) => s ^ rest) "" l

	fun toCString s =
	    List.foldr (fn (c, rest) => Char.toCString c ^ rest) "" (explode s)

	fun implode l = concat (List.map str l)

	fun map f s = implode (List.map f (explode s))

	__primitive val compare : string * string -> order = "String.compare"

	fun s < t = compare (s, t) = LESS

	local
	    fun token (c::cr, f) =
		if f c then
		    let
			val (cs, rest) = token (cr, f)
		    in
			(c::cs, rest)
		    end
		else (nil, cr)
	      | token (nil, _) = (nil, nil)

	    fun tokens' (c::cr, f) =
		if f c then tokens' (cr, f)
		else
		    let
			val (cs, rest) = token (cr, f)
		    in
			implode (c::cs)::tokens' (rest, f)
		    end
	      | tokens' (nil, _) = nil
	in
	    fun tokens f s = tokens' (explode s, f)
	end
    end


(* StringCvt *)

signature STRING_CVT =
    sig
	datatype radix = BIN | OCT | DEC | HEX

	type ('a, 'b) reader = 'b -> ('a * 'b) option

	type cs

	val dropl: (char -> bool) -> (char, 'a) reader -> 'a -> 'a

	val skipWS: (char, 'a) reader -> 'a -> 'a

	val scanString:
	    ((char, cs) reader -> ('a, cs) reader) -> string -> 'a option
    end

structure StringCvt :> STRING_CVT =
    struct
	datatype radix = BIN | OCT | DEC | HEX

	type ('a, 'b) reader = 'b -> ('a * 'b) option

	type cs = int

	fun dropl p getc =
	    let
		fun h src =
		    case getc src of
			NONE => src
		      | SOME (c, rest) => if p c then h rest else src
	    in
		h
	    end

	fun skipWS getc = dropl Char.isSpace getc

	fun scanString scan s =
	    let
		val len = String.size s
		fun getc i =
		    if i < len then SOME (String.sub (s, i), i + 1)
		    else NONE
	    in
		case scan getc 0 of
		    NONE => NONE
		  | SOME (res, _) => SOME res
	    end
    end


(* Int *)

local

structure Int =
    struct
	type int = int

	open StringCvt

	val op+ = op+

	fun decval c = Char.ord c - Char.ord #"0"
	fun hexval c =
	    if Char.ord #"0" <= Char.ord c andalso Char.ord c <= Char.ord #"9"
	    then Char.ord c - Char.ord #"0"
	    else (Char.ord c - Char.ord #"A" + 10) mod 32
	fun skipWSget getc source = getc (dropl Char.isSpace getc source)

	fun isBinDigit #"0" = true
	  | isBinDigit #"1" = true
	  | isBinDigit _ = false

	fun isOctDigit c = Char.ord c >= Char.ord #"0" andalso
			   Char.ord c <= Char.ord #"7"

	fun scan radix getc source =
	    let
		val (isDigit, factor) =
		    case radix of
			BIN => (isBinDigit,       2)
		      | OCT => (isOctDigit,       8)
		      | DEC => (Char.isDigit,    10)
		      | HEX => (Char.isHexDigit, 16)
		fun dig1 sgn NONE = NONE
		  | dig1 sgn (SOME (c, rest)) =
		    let
			fun digr res src =
			    case getc src of
				NONE => SOME (sgn * res, src)
			      | SOME (c', rest') =>
				    if isDigit c' then
					digr (factor * res + hexval c') rest'
				    else
					SOME (sgn * res, src)
		    in
			if isDigit c then digr (hexval c) rest else NONE
		    end
		fun getdigs sgn after0 inp =
		    case dig1 sgn inp of
			NONE => SOME (0, after0)
		      | res => res
		fun hexopt sgn NONE = NONE
		  | hexopt sgn (SOME (#"0", after0)) =
		    if radix <> HEX then getdigs sgn after0 (getc after0)
		    else
			(case getc after0 of
			     NONE => SOME(0, after0)
			   | SOME ((#"x" | #"X"), rest) =>
				 getdigs sgn after0 (getc rest)
			   | inp => getdigs sgn after0 inp)
		  | hexopt sgn inp = dig1 sgn inp
		fun sign NONE = NONE
		  | sign (SOME (#"~", rest)) = hexopt ~1 (getc rest)
		  | sign (SOME (#"-", rest)) = hexopt ~1 (getc rest)
		  | sign (SOME (#"+", rest)) = hexopt 1 (getc rest)
		  | sign inp = hexopt  1 inp
	    in
		sign (skipWSget getc source)
	    end

	__primitive val compare: int * int -> order = "Int.compare"

	__primitive val toString : int -> string = "Int.toString"

	val op>= = op>=
	val op< = op<

	val fromString = scanString (scan DEC)   (*--** crashes *)

	fun min (i, j) = if i > j then j else i
	fun max (i, j) = if i < j then j else i

	fun fromInt i   = i
	fun fromLarge i = i
	fun toLarge i   = i
    end

structure LargeInt = Int

in

signature INTEGER =
    sig
	type int

	val + : int * int -> int
	val >= : int * int -> bool
	val < : int * int -> bool

	val scan:
	    StringCvt.radix -> (char, 'a) StringCvt.reader -> 'a ->
	    (int * 'a) option

	val compare: int * int -> order

	val toString: int -> string

	val fromString: string -> int option

	val min: int * int -> int
	val max: int * int -> int

	val fromInt: Int.int -> int
	val fromLarge: LargeInt.int -> int
	val toLarge: int -> LargeInt.int
    end

structure Int :> INTEGER where type int = int = Int
structure LargeInt :> INTEGER where type int = LargeInt.int = LargeInt

end (* local *)


(* Real *)

structure Real =
    struct
	type real = real

	fun scan(r: (char,'a) StringCvt.reader) = scan r   (*--** *)
	fun toString(x: real) = ""   (*--** *)
	fun fromString(s: string) = NONE (*--** *)
	fun compare(x: real, y:real) = EQUAL (*--** *)
	fun trunc(x: real) = 0 (*--** *)
	fun (x: real) < (y: real) = false (*--** *)
    end

structure LargeReal = Real


(* Array *)

structure Array =
    struct
	__eqtype 'a array

	__primitive val array : int * 'a -> 'a array = "Array.array"
	__primitive val fromList : 'a list -> 'a array = "Array.fromList"
	__primitive val length : 'a array -> int = "Array.length"
	__primitive val sub : 'a array * int -> 'a = "Array.sub"
	__primitive val update : 'a array * int * 'a -> unit = "Array.update"

	fun copy {src, si, len, dst, di} =
	    let
		val bound =
		    case len of
			NONE => length src
		      | SOME n => si + n
		val offset = di - si
		fun copy' i =
		    if i < bound then
			(update (dst, i + offset, sub (src, i));
			 copy' (i + 1))
		    else ()
	    in
		copy' si
	    end

	fun foldl f z a =
	    let
		val n = length a
		fun foldl' (i, z') =
		    if i < n then foldl' (i + 1, f (sub (a, i), z'))
		    else z'
	    in
		foldl' (0, z)
	    end

	fun app f a =
	    let
		val n = length a
		fun app' i =
		    if i < n then (f (sub (a, i)); app' (i + 1))
		    else ()
	    in
		app' 0
	    end
    end

type array = Array.array


(* Vector *)

structure Vector =
    struct
	type 'a vector = 'a vector

	__primitive val fromList : 'a list -> 'a vector = "Vector.fromList"
	__primitive val sub : 'a vector * int -> 'a = "Vector.sub"

	fun tabulate (n, f) = fromList (List.tabulate (n, f))
    end

val vector = Vector.fromList


(* More members exported to toplevel *)

val getOpt = Option.getOpt
val isSome = Option.isSome
val valOf = Option.valOf

val null = List.null
val hd = List.hd
val tl = List.tl
val length = List.length
val rev = List.rev
val op@ = List.@
val app = List.app
val map = List.map
val foldr = List.foldr
val foldl = List.foldl

val ord = Char.ord
val chr = Char.chr

val str = String.str
val size = String.size
val concat = String.concat
val explode = String.explode
val implode = String.implode
val substring = String.substring
val op^ = String.^
(* src # 1 ../../lib/bootstrap/Word.aus *)
(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 1999
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure Word =
    struct
	type word = word

	local
	    __primitive val fromInt' : int * int -> word = "Word.fromInt'"
	in
	    fun fromInt x = fromInt' (31, x)
	    fun fromLargeInt x = fromInt' (31, x)
	end

	__primitive val toInt : word -> int = "Word.toInt"
	__primitive val toLargeInt : word -> LargeInt.int = "Word.toInt"
	__primitive val toIntX : word -> int = "Word.toIntX"
	__primitive val op+ : word * word -> word = "Word.+"
	__primitive val op- : word * word -> word = "Word.-"
	__primitive val op* : word * word -> word = "Word.*"
	__primitive val op mod : word * word -> word = "Word.mod"
	__primitive val orb : word * word -> word = "Word.orb"
	__primitive val xorb : word * word -> word = "Word.xorb"
	__primitive val andb : word * word -> word = "Word.andb"
	__primitive val notb : word * word -> word = "Word.notb"
	__primitive val op<< : word * word -> word = "Word.<<"
	__primitive val op>> : word * word -> word = "Word.>>"
	__primitive val op~>> : word * word -> word = "Word.~>>"
	__primitive val toString : word -> string = "Word.toString"

	val op>= = op>=

	fun fromLargeWord w = w
	fun toLargeWord w = w

	local
	    open StringCvt
	    fun skipWSget getc source = getc (dropl Char.isSpace getc source)

	    (* Below, 48 = Char.ord #"0" and 55 = Char.ord #"A" - 10. *)
	    fun decval c = fromInt (Char.ord c) - fromInt 48;
	    fun hexval c =
		if Char.ord #"0" <= Char.ord c
		andalso Char.ord c <= Char.ord #"9" then
		    fromInt (Char.ord c) - fromInt 48
		else
		    (fromInt (Char.ord c) - fromInt 55) mod (fromInt 32);
	in
	    fun scan radix getc source =
		let open StringCvt
		    val source = skipWS getc source
		    val (isDigit, factor) =
			case radix of
			    BIN => (fn c => (Char.ord #"0" <= Char.ord c
				    andalso Char.ord c <= Char.ord #"1"),  2)
			  | OCT => (fn c => (Char.ord #"0" <= Char.ord c
				    andalso Char.ord c <= Char.ord #"7"),  8)
			  | DEC => (Char.isDigit,                          10)
			  | HEX => (Char.isHexDigit,                       16)
		    fun dig1 NONE              = NONE
		      | dig1 (SOME (c1, src1)) =
			let fun digr res src =
			    case getc src of
				NONE           => SOME (res, src)
			      | SOME (c, rest) =>
				    if isDigit c then
					digr (fromInt factor * res + hexval c)
					rest
				    else SOME (res, src)
			in
			    if isDigit c1 then digr (hexval c1) src1
			    else NONE
			end
		    fun getdigs after0 src =
			case dig1 (getc src) of
			    NONE => SOME(fromInt 0, after0)
			  | res  => res
		    fun hexprefix after0 src =
			if radix <> HEX then getdigs after0 src
			else
			    case getc src of
				SOME(#"x", rest) => getdigs after0 rest
			      | SOME(#"X", rest) => getdigs after0 rest
			      | SOME _           => getdigs after0 src
			      | NONE => SOME(fromInt 0, after0)
		in
		    case getc source of
			SOME(#"0", after0) =>
			    (case getc after0 of
				 SOME(#"w", src2) => hexprefix after0 src2
			       | SOME _           => hexprefix after0 after0
			       | NONE             => SOME(fromInt 0, after0))
		      | SOME _ => dig1 (getc source)
		      | NONE   => NONE
		end
	end
    end

structure LargeWord = Word
(* src # 2 ../../lib/bootstrap/TextIO.aus *)
(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 1999
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure TextIO =
    struct
	type instream
	type outstream

	__primitive val stdIn : instream = "TextIO.stdIn"
	__primitive val openIn : string -> instream = "TextIO.openIn"
	__primitive val inputAll : instream -> string = "TextIO.inputAll"
	__primitive val inputLine : instream -> string = "TextIO.inputLine"
	__primitive val closeIn : instream -> unit = "TextIO.closeIn"

	__primitive val stdOut : outstream = "TextIO.stdOut"
	__primitive val stdErr : outstream = "TextIO.stdErr"
	__primitive val openOut : string -> outstream = "TextIO.openOut"
	__primitive val output : outstream * string -> unit = "TextIO.output"
	__primitive val output1 : outstream * char -> unit = "TextIO.output1"
	__primitive val flushOut : outstream -> unit = "TextIO.flushOut"
	__primitive val closeOut : outstream -> unit = "TextIO.closeOut"

	__primitive val print : string -> unit = "TextIO.print"
    end

val print = TextIO.print
(* src # 3 ../../lib/bootstrap/Unix.aus *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2000
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature UNIX =
    sig
	type proc

	val execute: string * string list -> proc
	val streamsOf: proc -> TextIO.instream * TextIO.outstream
    end

structure Unix :> UNIX =
    struct
	type proc = TextIO.instream * TextIO.outstream

	__primitive val execute: string * string list -> proc = "Unix.execute"

	fun streamsOf (ins, outs) = (ins, outs)
    end
(* src # 4 ../../lib/bootstrap/ml-yacc/base.sig *)
(* ML-Yacc Parser Generator (c) 1989 Andrew W. Appel, David R. Tarditi 
 *
 * $Log$
 * Revision 1.6  2000-04-05 12:42:09  rossberg
 *
 * - Improved error messages given on signature mismatch.
 * - Improved handling of abbreviations (and can bootstrap again).
 *
 * Revision 1.3  1999/11/15 12:21:54  rossberg
 * Reverted to original state because we can deal with sharing now.
 *
 * Revision 1.2  1999/11/02 15:52:03  rossberg
 * Replaced sharing constraints by where constraints. I marked the original
 * code with (*SHAR ...*).
 *
 * Revision 1.1  1999/10/04 09:44:08  kornstae
 * Moved ML-YACC files here from distribution
 *    to give them a unique location for bootstrapping.
 *
 * Revision 1.1.1.1  1997/01/14 01:38:04  george
 *   Version 109.24
 *
 * Revision 1.1.1.1  1996/01/31  16:01:42  george
 * Version 109
 * 
 *)

(* base.sig: Base signature file for SML-Yacc.  This file contains signatures
   that must be loaded before any of the files produced by ML-Yacc are loaded
*)

(* STREAM: signature for a lazy stream.*)

signature STREAM =
 sig type 'xa stream
     val streamify : (unit -> '_a) -> '_a stream
     val cons : '_a * '_a stream -> '_a stream
     val get : '_a stream -> '_a * '_a stream
 end

(* LR_TABLE: signature for an LR Table.

   The list of actions and gotos passed to mkLrTable must be ordered by state
   number. The values for state 0 are the first in the list, the values for
    state 1 are next, etc.
*)

signature LR_TABLE =
    sig
        datatype ('a,'b) pairlist = EMPTY | PAIR of 'a * 'b * ('a,'b) pairlist
	datatype state = STATE of int
	datatype term = T of int
	datatype nonterm = NT of int
	datatype action = SHIFT of state
			| REDUCE of int
			| ACCEPT
			| ERROR
	type table
	
	val numStates : table -> int
	val numRules : table -> int
	val describeActions : table -> state ->
				(term,action) pairlist * action
	val describeGoto : table -> state -> (nonterm,state) pairlist
	val action : table -> state * term -> action
	val goto : table -> state * nonterm -> state
	val initialState : table -> state
	exception Goto of state * nonterm

	val mkLrTable : {actions : ((term,action) pairlist * action) array,
			 gotos : (nonterm,state) pairlist array,
			 numStates : int, numRules : int,
			 initialState : state} -> table
    end

(* TOKEN: signature revealing the internal structure of a token. This signature
   TOKEN distinct from the signature {parser name}_TOKENS produced by ML-Yacc.
   The {parser name}_TOKENS structures contain some types and functions to
    construct tokens from values and positions.

   The representation of token was very carefully chosen here to allow the
   polymorphic parser to work without knowing the types of semantic values
   or line numbers.

   This has had an impact on the TOKENS structure produced by SML-Yacc, which
   is a structure parameter to lexer functors.  We would like to have some
   type 'a token which functions to construct tokens would create.  A
   constructor function for a integer token might be

	  INT: int * 'a * 'a -> 'a token.
 
   This is not possible because we need to have tokens with the representation
   given below for the polymorphic parser.

   Thus our constructur functions for tokens have the form:

	  INT: int * 'a * 'a -> (svalue,'a) token

   This in turn has had an impact on the signature that lexers for SML-Yacc
   must match and the types that a user must declare in the user declarations
   section of lexers.
*)

signature TOKEN =
    sig
	structure LrTable : LR_TABLE
        datatype ('a,'b) token = TOKEN of LrTable.term * ('a * 'b * 'b)
	val sameToken : ('a,'b) token * ('a,'b) token -> bool
    end

(* LR_PARSER: signature for a polymorphic LR parser *)

signature LR_PARSER =
    sig
	structure Stream: STREAM
	structure LrTable : LR_TABLE
	structure Token : TOKEN
	sharing LrTable = Token.LrTable

	exception ParseError

	val parse : {table : LrTable.table,
		     lexer : ('_b,'_c) Token.token Stream.stream,
		     arg: 'arg,
		     saction : int *
			       '_c *
				(LrTable.state * ('_b * '_c * '_c)) list * 
				'arg ->
				     LrTable.nonterm *
				     ('_b * '_c * '_c) *
				     ((LrTable.state *('_b * '_c * '_c)) list),
		     void : '_b,
		     ec : { is_keyword : LrTable.term -> bool,
			    noShift : LrTable.term -> bool,
			    preferred_change : (LrTable.term list * LrTable.term list) list,
			    errtermvalue : LrTable.term -> '_b,
			    showTerminal : LrTable.term -> string,
			    terms: LrTable.term list,
			    error : string * '_c * '_c -> unit
			   },
		     lookahead : int  (* max amount of lookahead used in *)
				      (* error correction *)
			} -> '_b *
			     (('_b,'_c) Token.token Stream.stream)
    end

(* LEXER: a signature that most lexers produced for use with SML-Yacc's
   output will match.  The user is responsible for declaring type token,
   type pos, and type svalue in the UserDeclarations section of a lexer.

   Note that type token is abstract in the lexer.  This allows SML-Yacc to
   create a TOKENS signature for use with lexers produced by ML-Lex that
   treats the type token abstractly.  Lexers that are functors parametrized by
   a Tokens structure matching a TOKENS signature cannot examine the structure
   of tokens.
*)

signature LEXER =
   sig
       structure UserDeclarations :
	   sig
	        type ('a,'b) token
		type pos
		type svalue
	   end
	val makeLexer : (int -> string) -> unit -> 
         (UserDeclarations.svalue,UserDeclarations.pos) UserDeclarations.token
   end

(* ARG_LEXER: the %arg option of ML-Lex allows users to produce lexers which
   also take an argument before yielding a function from unit to a token
*)

signature ARG_LEXER =
   sig
       structure UserDeclarations :
	   sig
	        type ('a,'b) token
		type pos
		type svalue
		type arg
	   end
	val makeLexer : (int -> string) -> UserDeclarations.arg -> unit -> 
         (UserDeclarations.svalue,UserDeclarations.pos) UserDeclarations.token
   end

(* PARSER_DATA: the signature of ParserData structures in {parser name}LrValsFun
   produced by  SML-Yacc.  All such structures match this signature.  

   The {parser name}LrValsFun produces a structure which contains all the values
   except for the lexer needed to call the polymorphic parser mentioned
   before.

*)

signature PARSER_DATA =
   sig
        (* the type of line numbers *)

	type pos

	(* the type of semantic values *)

	type svalue

         (* the type of the user-supplied argument to the parser *)
 	type arg
 
	(* the intended type of the result of the parser.  This value is
	   produced by applying extract from the structure Actions to the
	   final semantic value resultiing from a parse.
	 *)

	type result

	structure LrTable : LR_TABLE
	structure Token : TOKEN
	sharing Token.LrTable = LrTable

	(* structure Actions contains the functions which mantain the
	   semantic values stack in the parser.  Void is used to provide
	   a default value for the semantic stack.
	 *)

	structure Actions : 
	  sig
	      val actions : int * pos *
		   (LrTable.state * (svalue * pos * pos)) list * arg->
		         LrTable.nonterm * (svalue * pos * pos) *
			 ((LrTable.state *(svalue * pos * pos)) list)
	      val void : svalue
	      val extract : svalue -> result
	  end

	(* structure EC contains information used to improve error
	   recovery in an error-correcting parser *)

	structure EC :
	   sig
	     val is_keyword : LrTable.term -> bool
	     val noShift : LrTable.term -> bool
 	     val preferred_change : (LrTable.term list * LrTable.term list) list
	     val errtermvalue : LrTable.term -> svalue
	     val showTerminal : LrTable.term -> string
	     val terms: LrTable.term list
	   end

	(* table is the LR table for the parser *)

	val table : LrTable.table
    end

(* signature PARSER is the signature that most user parsers created by 
   SML-Yacc will match.
*)

signature PARSER =
    sig
        structure Token : TOKEN
	structure Stream : STREAM
	exception ParseError

	(* type pos is the type of line numbers *)

	type pos

	(* type result is the type of the result from the parser *)

	type result

         (* the type of the user-supplied argument to the parser *)
 	type arg
	
	(* type svalue is the type of semantic values for the semantic value
	   stack
	 *)

	type svalue

	(* val makeLexer is used to create a stream of tokens for the parser *)

	val makeLexer : (int -> string) ->
			 (svalue,pos) Token.token Stream.stream

	(* val parse takes a stream of tokens and a function to print
	   errors and returns a value of type result and a stream containing
	   the unused tokens
	 *)

	val parse : int * ((svalue,pos) Token.token Stream.stream) *
		    (string * pos * pos -> unit) * arg ->
				result * (svalue,pos) Token.token Stream.stream

	val sameToken : (svalue,pos) Token.token * (svalue,pos) Token.token ->
				bool
     end

(* signature ARG_PARSER is the signature that will be matched by parsers whose
    lexer takes an additional argument.
*)

signature ARG_PARSER = 
    sig
        structure Token : TOKEN
	structure Stream : STREAM
	exception ParseError

	type arg
	type lexarg
	type pos
	type result
	type svalue

	val makeLexer : (int -> string) -> lexarg ->
			 (svalue,pos) Token.token Stream.stream
	val parse : int * ((svalue,pos) Token.token Stream.stream) *
		    (string * pos * pos -> unit) * arg ->
				result * (svalue,pos) Token.token Stream.stream

	val sameToken : (svalue,pos) Token.token * (svalue,pos) Token.token ->
				bool
     end

(* src # 5 ../../lib/bootstrap/ml-yacc/join.sml *)
(* ML-Yacc Parser Generator (c) 1989 Andrew W. Appel, David R. Tarditi 
 *
 * $Log$
 * Revision 1.6  2000-04-05 12:42:09  rossberg
 *
 * - Improved error messages given on signature mismatch.
 * - Improved handling of abbreviations (and can bootstrap again).
 *
 * Revision 1.5  2000/03/30 13:37:26  rossberg
 *
 * Switched arguments in Join functors because sharing broke with our move to
 * structural datatypes. :-(
 *
 * Revision 1.4  1999/11/15 12:21:54  rossberg
 * Reverted to original state because we can deal with sharing now.
 *
 * Revision 1.3  1999/11/02 16:09:35  rossberg
 * Ups.
 *
 * Revision 1.2  1999/11/02 15:52:03  rossberg
 * Replaced sharing constraints by where constraints. I marked the original
 * code with (*SHAR ...*).
 *
 * Revision 1.1  1999/10/04 09:44:08  kornstae
 * Moved ML-YACC files here from distribution
 *    to give them a unique location for bootstrapping.
 *
 * Revision 1.1.1.1  1997/01/14 01:38:04  george
 *   Version 109.24
 *
 * Revision 1.1.1.1  1996/01/31  16:01:42  george
 * Version 109
 * 
 *)

(* functor Join creates a user parser by putting together a Lexer structure,
   an LrValues structure, and a polymorphic parser structure.  Note that
   the Lexer and LrValues structure must share the type pos (i.e. the type
   of line numbers), the type svalues for semantic values, and the type
   of tokens.
*)

functor Join(structure ParserData: PARSER_DATA
	     structure Lex : LEXER
	     structure LrParser : LR_PARSER
	     sharing ParserData.LrTable = LrParser.LrTable
	     sharing ParserData.Token = LrParser.Token
	     sharing type Lex.UserDeclarations.svalue = ParserData.svalue
	     sharing type Lex.UserDeclarations.pos = ParserData.pos
	     sharing type Lex.UserDeclarations.token = ParserData.Token.token
)
		 : PARSER =
struct
    structure Token = ParserData.Token
    structure Stream = LrParser.Stream
 
    exception ParseError = LrParser.ParseError

    type arg = ParserData.arg
    type pos = ParserData.pos
    type result = ParserData.result
    type svalue = ParserData.svalue
    val makeLexer = LrParser.Stream.streamify o Lex.makeLexer
    val parse = fn (lookahead,lexer,error,arg) =>
	(fn (a,b) => (ParserData.Actions.extract a,b))
     (LrParser.parse {table = ParserData.table,
	        lexer=lexer,
		lookahead=lookahead,
		saction = ParserData.Actions.actions,
		arg=arg,
		void= ParserData.Actions.void,
	        ec = {is_keyword = ParserData.EC.is_keyword,
		      noShift = ParserData.EC.noShift,
		      preferred_change = ParserData.EC.preferred_change,
		      errtermvalue = ParserData.EC.errtermvalue,
		      error=error,
		      showTerminal = ParserData.EC.showTerminal,
		      terms = ParserData.EC.terms}}
      )
     val sameToken = Token.sameToken
end

(* functor JoinWithArg creates a variant of the parser structure produced 
   above.  In this case, the makeLexer take an additional argument before
   yielding a value of type unit -> (svalue,pos) token
 *)

functor JoinWithArg(structure ParserData: PARSER_DATA
	     structure Lex : ARG_LEXER
	     structure LrParser : LR_PARSER
	     sharing ParserData.LrTable = LrParser.LrTable
	     sharing ParserData.Token = LrParser.Token
	     sharing type Lex.UserDeclarations.svalue = ParserData.svalue
	     sharing type Lex.UserDeclarations.pos = ParserData.pos
	     sharing type Lex.UserDeclarations.token = ParserData.Token.token
)
		 : ARG_PARSER  =
struct
    structure Token = ParserData.Token
    structure Stream = LrParser.Stream

    exception ParseError = LrParser.ParseError

    type arg = ParserData.arg
    type lexarg = Lex.UserDeclarations.arg
    type pos = ParserData.pos
    type result = ParserData.result
    type svalue = ParserData.svalue

    val makeLexer = fn s => fn arg =>
		 LrParser.Stream.streamify (Lex.makeLexer s arg)
    val parse = fn (lookahead,lexer,error,arg) =>
	(fn (a,b) => (ParserData.Actions.extract a,b))
     (LrParser.parse {table = ParserData.table,
	        lexer=lexer,
		lookahead=lookahead,
		saction = ParserData.Actions.actions,
		arg=arg,
		void= ParserData.Actions.void,
	        ec = {is_keyword = ParserData.EC.is_keyword,
		      noShift = ParserData.EC.noShift,
		      preferred_change = ParserData.EC.preferred_change,
		      errtermvalue = ParserData.EC.errtermvalue,
		      error=error,
		      showTerminal = ParserData.EC.showTerminal,
		      terms = ParserData.EC.terms}}
      )
    val sameToken = Token.sameToken
end;
(* src # 6 ../../lib/bootstrap/ml-yacc/lrtable.sml *)
(* ML-Yacc Parser Generator (c) 1989 Andrew W. Appel, David R. Tarditi 
 *
 * $Log$
 * Revision 1.6  2000-04-05 12:42:09  rossberg
 *
 * - Improved error messages given on signature mismatch.
 * - Improved handling of abbreviations (and can bootstrap again).
 *
 * Revision 1.1  1999/10/04 09:44:08  kornstae
 * Moved ML-YACC files here from distribution
 *    to give them a unique location for bootstrapping.
 *
 * Revision 1.1.1.1  1997/01/14 01:38:04  george
 *   Version 109.24
 *
 * Revision 1.1.1.1  1996/01/31  16:01:42  george
 * Version 109
 * 
 *)

structure LrTable : LR_TABLE = 
    struct
	open Array List
	infix 9 sub
	datatype ('a,'b) pairlist = EMPTY
				  | PAIR of 'a * 'b * ('a,'b) pairlist
	datatype term = T of int
	datatype nonterm = NT of int
	datatype state = STATE of int
	datatype action = SHIFT of state
			| REDUCE of int (* rulenum from grammar *)
			| ACCEPT
			| ERROR
	exception Goto of state * nonterm
	type table = {states: int, rules : int,initialState: state,
		      action: ((term,action) pairlist * action) array,
		      goto :  (nonterm,state) pairlist array}
	val numStates = fn ({states,...} : table) => states
	val numRules = fn ({rules,...} : table) => rules
	val describeActions =
	   fn ({action,...} : table) => 
	           fn (STATE s) => action sub s
	val describeGoto =
	   fn ({goto,...} : table) =>
	           fn (STATE s) => goto sub s
	fun findTerm (T term,row,default) =
	    let fun find (PAIR (T key,data,r)) =
		       if key < term then find r
		       else if key=term then data
		       else default
		   | find EMPTY = default
	    in find row
	    end
	fun findNonterm (NT nt,row) =
	    let fun find (PAIR (NT key,data,r)) =
		       if key < nt then find r
		       else if key=nt then SOME data
		       else NONE
		   | find EMPTY = NONE
	    in find row
	    end
	val action = fn ({action,...} : table) =>
		fn (STATE state,term) =>
		  let val (row,default) = action sub state
		  in findTerm(term,row,default)
		  end
	val goto = fn ({goto,...} : table) =>
			fn (a as (STATE state,nonterm)) =>
			  case findNonterm(nonterm,goto sub state)
			  of SOME state => state
			   | NONE => raise (Goto a)
	val initialState = fn ({initialState,...} : table) => initialState
	val mkLrTable = fn {actions,gotos,initialState,numStates,numRules} =>
	     ({action=actions,goto=gotos,
	       states=numStates,
	       rules=numRules,
               initialState=initialState} : table)
end;
(* src # 7 ../../lib/bootstrap/ml-yacc/stream.sml *)
(* ML-Yacc Parser Generator (c) 1989 Andrew W. Appel, David R. Tarditi 
 *
 * $Log$
 * Revision 1.6  2000-04-05 12:42:09  rossberg
 *
 * - Improved error messages given on signature mismatch.
 * - Improved handling of abbreviations (and can bootstrap again).
 *
 * Revision 1.1  1999/10/04 09:44:08  kornstae
 * Moved ML-YACC files here from distribution
 *    to give them a unique location for bootstrapping.
 *
 * Revision 1.2  1997/08/26 19:18:55  jhr
 *   Replaced used of "abstraction" with ":>".
 *
# Revision 1.1.1.1  1997/01/14  01:38:04  george
#   Version 109.24
#
 * Revision 1.1.1.1  1996/01/31  16:01:43  george
 * Version 109
 * 
 *)

(* Stream: a structure implementing a lazy stream.  The signature STREAM
   is found in base.sig *)

structure Stream :> STREAM =
struct
   datatype 'a str = EVAL of 'a * 'a str ref | UNEVAL of (unit->'a)

   type 'a stream = 'a str ref

   fun get(ref(EVAL t)) = t
     | get(s as ref(UNEVAL f)) = 
	    let val t = (f(), ref(UNEVAL f)) in s := EVAL t; t end

   fun streamify f = ref(UNEVAL f)
   fun cons(a,s) = ref(EVAL(a,s))

end;
(* src # 8 ../../lib/bootstrap/ml-yacc/parser2.sml *)
(* ML-Yacc Parser Generator (c) 1989 Andrew W. Appel, David R. Tarditi 
 *
 * $Log$
 * Revision 1.6  2000-04-05 12:42:09  rossberg
 *
 * - Improved error messages given on signature mismatch.
 * - Improved handling of abbreviations (and can bootstrap again).
 *
 * Revision 1.1  1999/10/04 09:44:08  kornstae
 * Moved ML-YACC files here from distribution
 *    to give them a unique location for bootstrapping.
 *
 * Revision 1.2  1997/08/26 19:18:54  jhr
 *   Replaced used of "abstraction" with ":>".
 *
# Revision 1.1.1.1  1997/01/14  01:38:04  george
#   Version 109.24
#
 * Revision 1.3  1996/10/03  03:36:58  jhr
 * Qualified identifiers that are no-longer top-level (quot, rem, min, max).
 *
 * Revision 1.2  1996/02/26  15:02:29  george
 *    print no longer overloaded.
 *    use of makestring has been removed and replaced with Int.toString ..
 *    use of IO replaced with TextIO
 *
 * Revision 1.1.1.1  1996/01/31  16:01:42  george
 * Version 109
 * 
 *)

(* parser.sml:  This is a parser driver for LR tables with an error-recovery
   routine added to it.  The routine used is described in detail in this
   article:

	'A Practical Method for LR and LL Syntactic Error Diagnosis and
	 Recovery', by M. Burke and G. Fisher, ACM Transactions on
	 Programming Langauges and Systems, Vol. 9, No. 2, April 1987,
	 pp. 164-197.

    This program is an implementation is the partial, deferred method discussed
    in the article.  The algorithm and data structures used in the program
    are described below.  

    This program assumes that all semantic actions are delayed.  A semantic
    action should produce a function from unit -> value instead of producing the
    normal value.  The parser returns the semantic value on the top of the
    stack when accept is encountered.  The user can deconstruct this value
    and apply the unit -> value function in it to get the answer.

    It also assumes that the lexer is a lazy stream.

    Data Structures:
    ----------------
	
	* The parser:

	   The state stack has the type

		 (state * (semantic value * line # * line #)) list

	   The parser keeps a queue of (state stack * lexer pair).  A lexer pair
	 consists of a terminal * value pair and a lexer.  This allows the 
	 parser to reconstruct the states for terminals to the left of a
	 syntax error, and attempt to make error corrections there.

	   The queue consists of a pair of lists (x,y).  New additions to
	 the queue are cons'ed onto y.  The first element of x is the top
	 of the queue.  If x is nil, then y is reversed and used
	 in place of x.

    Algorithm:
    ----------

	* The steady-state parser:  

	    This parser keeps the length of the queue of state stacks at
	a steady state by always removing an element from the front when
	another element is placed on the end.

	    It has these arguments:

	   stack: current stack
	   queue: value of the queue
	   lexPair ((terminal,value),lex stream)

	When SHIFT is encountered, the state to shift to and the value are
	are pushed onto the state stack.  The state stack and lexPair are
	placed on the queue.  The front element of the queue is removed.

	When REDUCTION is encountered, the rule is applied to the current
	stack to yield a triple (nonterm,value,new stack).  A new
	stack is formed by adding (goto(top state of stack,nonterm),value)
	to the stack.

	When ACCEPT is encountered, the top value from the stack and the
	lexer are returned.

	When an ERROR is encountered, fixError is called.  FixError
	takes the arguments to the parser, fixes the error if possible and
        returns a new set of arguments.

	* The distance-parser:

	This parser includes an additional argument distance.  It pushes
	elements on the queue until it has parsed distance tokens, or an
	ACCEPT or ERROR occurs.  It returns a stack, lexer, the number of
	tokens left unparsed, a queue, and an action option.
*)

signature FIFO = 
  sig type 'a queue
      val empty : 'a queue
      exception Empty
      val get : 'a queue -> 'a * 'a queue
      val put : 'a * 'a queue -> 'a queue
  end

(* drt (12/15/89) -- the functor should be used in development work, but
   it wastes space in the release version.

functor ParserGen(structure LrTable : LR_TABLE
		  structure Stream : STREAM) : LR_PARSER =
*)

structure LrParser :> LR_PARSER =
   struct
      structure LrTable = LrTable
      structure Stream = Stream

      structure Token : TOKEN =
	struct
	    structure LrTable = LrTable
	    datatype ('a,'b) token = TOKEN of LrTable.term * ('a * 'b * 'b)
	    val sameToken = fn (TOKEN(t,_),TOKEN(t',_)) => t=t'
        end

      open LrTable
      open Token

      val DEBUG1 = false
      val DEBUG2 = false
      exception ParseError
      exception ParseImpossible of int

      structure Fifo :> FIFO =
        struct
	  type 'a queue = ('a list * 'a list)
	  val empty = (nil,nil)
	  exception Empty
	  fun get(a::x, y) = (a, (x,y))
	    | get(nil, nil) = raise Empty
	    | get(nil, y) = get(rev y, nil)
 	  fun put(a,(x,y)) = (x,a::y)
        end

      type ('a,'b) elem = (state * ('a * 'b * 'b))
      type ('a,'b) stack = ('a,'b) elem list
      type ('a,'b) lexv = ('a,'b) token
      type ('a,'b) lexpair = ('a,'b) lexv * (('a,'b) lexv Stream.stream)
      type ('a,'b) distanceParse =
		 ('a,'b) lexpair *
		 ('a,'b) stack * 
		 (('a,'b) stack * ('a,'b) lexpair) Fifo.queue *
		 int ->
		   ('a,'b) lexpair *
		   ('a,'b) stack * 
		   (('a,'b) stack * ('a,'b) lexpair) Fifo.queue *
		   int *
		   action option

      type ('a,'b) ecRecord =
	 {is_keyword : term -> bool,
          preferred_change : (term list * term list) list,
	  error : string * 'b * 'b -> unit,
	  errtermvalue : term -> 'a,
	  terms : term list,
	  showTerminal : term -> string,
	  noShift : term -> bool}

      local 
	 val print = fn s => TextIO.output(TextIO.stdOut,s)
	 val println = fn s => (print s; print "\n")
	 val showState = fn (STATE s) => "STATE " ^ (Int.toString s)
      in
        fun printStack(stack: ('a,'b) stack, n: int) =
         case stack
           of (state,_) :: rest =>
                 (print("\t" ^ Int.toString n ^ ": ");
                  println(showState state);
                  printStack(rest, n+1))
            | nil => ()
                
        fun prAction showTerminal
		 (stack as (state,_) :: _, next as (TOKEN (term,_),_), action) =
             (println "Parse: state stack:";
              printStack(stack, 0);
              print("       state="
                         ^ showState state	
                         ^ " next="
                         ^ showTerminal term
                         ^ " action="
                        );
              case action
                of SHIFT state => println ("SHIFT " ^ (showState state))
                 | REDUCE i => println ("REDUCE " ^ (Int.toString i))
                 | ERROR => println "ERROR"
		 | ACCEPT => println "ACCEPT")
        | prAction _ (_,_,action) = ()
     end

    (* ssParse: parser which maintains the queue of (state * lexvalues) in a
	steady-state.  It takes a table, showTerminal function, saction
	function, and fixError function.  It parses until an ACCEPT is
	encountered, or an exception is raised.  When an error is encountered,
	fixError is called with the arguments of parseStep (lexv,stack,and
	queue).  It returns the lexv, and a new stack and queue adjusted so
	that the lexv can be parsed *)
	
    val ssParse =
      fn (table,showTerminal,saction,fixError,arg) =>
	let val prAction = prAction showTerminal
	    val action = LrTable.action table
	    val goto = LrTable.goto table
	    fun parseStep(args as
			 (lexPair as (TOKEN (terminal, value as (_,leftPos,_)),
				      lexer
				      ),
			  stack as (state,_) :: _,
			  queue)) =
	      let val nextAction = action (state,terminal)
	          val _ = if DEBUG1 then prAction(stack,lexPair,nextAction)
			  else ()
	      in case nextAction
		 of SHIFT s =>
		  let val newStack = (s,value) :: stack
		      val newLexPair = Stream.get lexer
		      val (_,newQueue) =Fifo.get(Fifo.put((newStack,newLexPair),
							    queue))
		  in parseStep(newLexPair,(s,value)::stack,newQueue)
		  end
		 | REDUCE i =>
		     (case saction(i,leftPos,stack,arg)
		      of (nonterm,value,stack as (state,_) :: _) =>
		          parseStep(lexPair,(goto(state,nonterm),value)::stack,
				    queue)
		       | _ => raise (ParseImpossible 197))
		 | ERROR => parseStep(fixError args)
		 | ACCEPT => 
			(case stack
			 of (_,(topvalue,_,_)) :: _ =>
				let val (token,restLexer) = lexPair
				in (topvalue,Stream.cons(token,restLexer))
				end
			  | _ => raise (ParseImpossible 202))
	      end
	    | parseStep _ = raise (ParseImpossible 204)
	in parseStep
	end

    (*  distanceParse: parse until n tokens are shifted, or accept or
	error are encountered.  Takes a table, showTerminal function, and
	semantic action function.  Returns a parser which takes a lexPair
	(lex result * lexer), a state stack, a queue, and a distance
	(must be > 0) to parse.  The parser returns a new lex-value, a stack
	with the nth token shifted on top, a queue, a distance, and action
	option. *)

    val distanceParse =
      fn (table,showTerminal,saction,arg) =>
	let val prAction = prAction showTerminal
	    val action = LrTable.action table
	    val goto = LrTable.goto table
	    fun parseStep(lexPair,stack,queue,0) = (lexPair,stack,queue,0,NONE)
	      | parseStep(lexPair as (TOKEN (terminal, value as (_,leftPos,_)),
				      lexer
				     ),
			  stack as (state,_) :: _,
			  queue,distance) =
	      let val nextAction = action(state,terminal)
	          val _ = if DEBUG1 then prAction(stack,lexPair,nextAction)
			  else ()
	      in case nextAction
		 of SHIFT s =>
		  let val newStack = (s,value) :: stack
		      val newLexPair = Stream.get lexer
		  in parseStep(newLexPair,(s,value)::stack,
			       Fifo.put((newStack,newLexPair),queue),distance-1)
		  end
		 | REDUCE i =>
		    (case saction(i,leftPos,stack,arg)
		      of (nonterm,value,stack as (state,_) :: _) =>
		         parseStep(lexPair,(goto(state,nonterm),value)::stack,
				 queue,distance)
		      | _ => raise (ParseImpossible 240))
		 | ERROR => (lexPair,stack,queue,distance,SOME nextAction)
		 | ACCEPT => (lexPair,stack,queue,distance,SOME nextAction)
	      end
	   | parseStep _ = raise (ParseImpossible 242)
	in parseStep : ('_a,'_b) distanceParse 
	end

(* mkFixError: function to create fixError function which adjusts parser state
   so that parse may continue in the presence of an error *)

fun mkFixError({is_keyword,terms,errtermvalue,
	      preferred_change,noShift,
	      showTerminal,error,...} : ('_a,'_b) ecRecord,
	     distanceParse : ('_a,'_b) distanceParse,
	     minAdvance,maxAdvance) 

            (lexv as (TOKEN (term,value as (_,leftPos,_)),_),stack,queue) =
    let val _ = if DEBUG2 then
			error("syntax error found at " ^ (showTerminal term),
			      leftPos,leftPos)
		else ()

        fun tokAt(t,p) = TOKEN(t,(errtermvalue t,p,p))

	val minDelta = 3

	(* pull all the state * lexv elements from the queue *)

	val stateList = 
	   let fun f q = let val (elem,newQueue) = Fifo.get q
			 in elem :: (f newQueue)
			 end handle Fifo.Empty => nil
	   in f queue
	   end

	(* now number elements of stateList, giving distance from
	   error token *)

	val (_, numStateList) =
	      List.foldr (fn (a,(num,r)) => (num+1,(a,num)::r)) (0, []) stateList

	(* Represent the set of potential changes as a linked list.

	   Values of datatype Change hold information about a potential change.

	   oper = oper to be applied
	   pos = the # of the element in stateList that would be altered.
	   distance = the number of tokens beyond the error token which the
	     change allows us to parse.
	   new = new terminal * value pair at that point
	   orig = original terminal * value pair at the point being changed.
	 *)

	datatype ('a,'b) change = CHANGE of
	   {pos : int, distance : int, leftPos: 'b, rightPos: 'b,
	    new : ('a,'b) lexv list, orig : ('a,'b) lexv list}


         val showTerms = concat o map (fn TOKEN(t,_) => " " ^ showTerminal t)

	 val printChange = fn c =>
	  let val CHANGE {distance,new,orig,pos,...} = c
	  in (print ("{distance= " ^ (Int.toString distance));
	      print (",orig ="); print(showTerms orig);
	      print (",new ="); print(showTerms new);
	      print (",pos= " ^ (Int.toString pos));
	      print "}\n")
	  end

	val printChangeList = app printChange

(* parse: given a lexPair, a stack, and the distance from the error
   token, return the distance past the error token that we are able to parse.*)

	fun parse (lexPair,stack,queuePos : int) =
	    case distanceParse(lexPair,stack,Fifo.empty,queuePos+maxAdvance+1)
             of (_,_,_,distance,SOME ACCEPT) => 
		        if maxAdvance-distance-1 >= 0 
			    then maxAdvance 
			    else maxAdvance-distance-1
	      | (_,_,_,distance,_) => maxAdvance - distance - 1

(* catList: concatenate results of scanning list *)

	fun catList l f = List.foldr (fn(a,r)=> f a @ r) [] l

        fun keywordsDelta new = if List.exists (fn(TOKEN(t,_))=>is_keyword t) new
	               then minDelta else 0

        fun tryChange{lex,stack,pos,leftPos,rightPos,orig,new} =
	     let val lex' = List.foldr (fn (t',p)=>(t',Stream.cons p)) lex new
		 val distance = parse(lex',stack,pos+length new-length orig)
	      in if distance >= minAdvance + keywordsDelta new 
		   then [CHANGE{pos=pos,leftPos=leftPos,rightPos=rightPos,
				distance=distance,orig=orig,new=new}] 
		   else []
	     end


(* tryDelete: Try to delete n terminals.
              Return single-element [success] or nil.
	      Do not delete unshiftable terminals. *)


    fun tryDelete n ((stack,lexPair as (TOKEN(term,(_,l,r)),_)),qPos) =
	let fun del(0,accum,left,right,lexPair) =
	          tryChange{lex=lexPair,stack=stack,
			    pos=qPos,leftPos=left,rightPos=right,
			    orig=rev accum, new=[]}
	      | del(n,accum,left,right,(tok as TOKEN(term,(_,_,r)),lexer)) =
		   if noShift term then []
		   else del(n-1,tok::accum,left,r,Stream.get lexer)
         in del(n,[],l,r,lexPair)
        end

(* tryInsert: try to insert tokens before the current terminal;
       return a list of the successes  *)

        fun tryInsert((stack,lexPair as (TOKEN(_,(_,l,_)),_)),queuePos) =
	       catList terms (fn t =>
		 tryChange{lex=lexPair,stack=stack,
			   pos=queuePos,orig=[],new=[tokAt(t,l)],
			   leftPos=l,rightPos=l})
			      
(* trySubst: try to substitute tokens for the current terminal;
       return a list of the successes  *)

        fun trySubst ((stack,lexPair as (orig as TOKEN (term,(_,l,r)),lexer)),
		      queuePos) =
	      if noShift term then []
	      else
		  catList terms (fn t =>
		      tryChange{lex=Stream.get lexer,stack=stack,
				pos=queuePos,
				leftPos=l,rightPos=r,orig=[orig],
				new=[tokAt(t,r)]})

     (* do_delete(toks,lexPair) tries to delete tokens "toks" from "lexPair".
         If it succeeds, returns SOME(toks',l,r,lp), where
	     toks' is the actual tokens (with positions and values) deleted,
	     (l,r) are the (leftmost,rightmost) position of toks', 
	     lp is what remains of the stream after deletion 
     *)
        fun do_delete(nil,lp as (TOKEN(_,(_,l,_)),_)) = SOME(nil,l,l,lp)
          | do_delete([t],(tok as TOKEN(t',(_,l,r)),lp')) =
	       if t=t'
		   then SOME([tok],l,r,Stream.get lp')
                   else NONE
          | do_delete(t::rest,(tok as TOKEN(t',(_,l,r)),lp')) =
	       if t=t'
		   then case do_delete(rest,Stream.get lp')
                         of SOME(deleted,l',r',lp'') =>
			       SOME(tok::deleted,l,r',lp'')
			  | NONE => NONE
		   else NONE
			     
        fun tryPreferred((stack,lexPair),queuePos) =
	    catList preferred_change (fn (delete,insert) =>
	       if List.exists noShift delete then [] (* should give warning at
						 parser-generation time *)
               else case do_delete(delete,lexPair)
                     of SOME(deleted,l,r,lp) => 
			    tryChange{lex=lp,stack=stack,pos=queuePos,
				      leftPos=l,rightPos=r,orig=deleted,
				      new=map (fn t=>(tokAt(t,r))) insert}
		      | NONE => [])

	val changes = catList numStateList tryPreferred @
	                catList numStateList tryInsert @
			  catList numStateList trySubst @
			    catList numStateList (tryDelete 1) @
			      catList numStateList (tryDelete 2) @
			        catList numStateList (tryDelete 3)

	val findMaxDist = fn l => 
	  foldr (fn (CHANGE {distance,...},high) => Int.max(distance,high)) 0 l

(* maxDist: max distance past error taken that we could parse *)

	val maxDist = findMaxDist changes

(* remove changes which did not parse maxDist tokens past the error token *)

        val changes = catList changes 
	      (fn(c as CHANGE{distance,...}) => 
		  if distance=maxDist then [c] else [])

      in case changes 
	  of (l as change :: _) =>
	      let fun print_msg (CHANGE {new,orig,leftPos,rightPos,...}) =
		  let val s = 
		      case (orig,new)
			  of (_::_,[]) => "deleting " ^ (showTerms orig)
	                   | ([],_::_) => "inserting " ^ (showTerms new)
			   | _ => "replacing " ^ (showTerms orig) ^
				 " with " ^ (showTerms new)
		  in error ("syntax error: " ^ s,leftPos,rightPos)
		  end
		   
		  val _ = 
		      (if length l > 1 andalso DEBUG2 then
			   (print "multiple fixes possible; could fix it by:\n";
			    app print_msg l;
			    print "chosen correction:\n")
		       else ();
		       print_msg change)

		  (* findNth: find nth queue entry from the error
		   entry.  Returns the Nth queue entry and the  portion of
		   the queue from the beginning to the nth-1 entry.  The
		   error entry is at the end of the queue.

		   Examples:

		   queue = a b c d e
		   findNth 0 = (e,a b c d)
		   findNth 1 =  (d,a b c)
		   *)

		  val findNth = fn n =>
		      let fun f (h::t,0) = (h,rev t)
			    | f (h::t,n) = f(t,n-1)
			    | f (nil,_) = let exception FindNth
					  in raise FindNth
					  end
		      in f (rev stateList,n)
		      end
		
		  val CHANGE {pos,orig,new,...} = change
		  val (last,queueFront) = findNth pos
		  val (stack,lexPair) = last

		  val lp1 = foldl(fn (_,(_,r)) => Stream.get r) lexPair orig
		  val lp2 = foldr(fn(t,r)=>(t,Stream.cons r)) lp1 new

		  val restQueue = 
		      Fifo.put((stack,lp2),
			       foldl Fifo.put Fifo.empty queueFront)

		  val (lexPair,stack,queue,_,_) =
		      distanceParse(lp2,stack,restQueue,pos)

	      in (lexPair,stack,queue)
	      end
	| nil => (error("syntax error found at " ^ (showTerminal term),
			leftPos,leftPos); raise ParseError)
    end

   val parse = fn {arg,table,lexer,saction,void,lookahead,
		   ec=ec as {showTerminal,...} : ('_a,'_b) ecRecord} =>
	let val distance = 15   (* defer distance tokens *)
	    val minAdvance = 1  (* must parse at least 1 token past error *)
	    val maxAdvance = Int.max(lookahead,0)(* max distance for parse check *)
	    val lexPair = Stream.get lexer
	    val (TOKEN (_,(_,leftPos,_)),_) = lexPair
	    val startStack = [(initialState table,(void,leftPos,leftPos))]
	    val startQueue = Fifo.put((startStack,lexPair),Fifo.empty)
	    val distanceParse = distanceParse(table,showTerminal,saction,arg)
	    val fixError = mkFixError(ec,distanceParse,minAdvance,maxAdvance)
	    val ssParse = ssParse(table,showTerminal,saction,fixError,arg)
	    fun loop (lexPair,stack,queue,_,SOME ACCEPT) =
		   ssParse(lexPair,stack,queue)
	      | loop (lexPair,stack,queue,0,_) = ssParse(lexPair,stack,queue)
	      | loop (lexPair,stack,queue,distance,SOME ERROR) =
		 let val (lexPair,stack,queue) = fixError(lexPair,stack,queue)
		 in loop (distanceParse(lexPair,stack,queue,distance))
		 end
	      | loop _ = let exception ParseInternal
			 in raise ParseInternal
			 end
	in loop (distanceParse(lexPair,startStack,startQueue,distance))
	end
 end;

(* drt (12/15/89) -- needed only when the code above is functorized

structure LrParser = ParserGen(structure LrTable=LrTable
			     structure Stream=Stream);
*)
(* src # 9 ../error/SOURCE.sig *)
(*
 * A source file.
 *)


signature SOURCE =
  sig

    type source
    type pos	= int * int
    type region	= pos * pos
    type t	= source

    val fromString:	string -> source
    val toString:	source -> string

    val nowhere:	region
    val over:		region * region -> region
    val between:	region * region -> region

    val regionToString:	region -> string

  end
(* src # 10 ../error/Source.sml *)
(*
 * A source file
 *)


structure Source :> SOURCE =
  struct

    type source	= string
    type pos	= int * int
    type region	= pos * pos
    type t	= source

    val nowhere = ((0,0),(0,0))

    fun fromString s = s
    fun toString s   = s

    fun over(reg1: region, reg2: region)	= (#1 reg1, #2 reg2)
    fun between(reg1: region, reg2: region)	= (#2 reg1, #1 reg2)

    fun posToString(lin,col) =
	Int.toString lin ^ "." ^ Int.toString col

    fun regionToString(region as (pos1,pos2)) =
	if region = nowhere then
	    "(unknown position)"
	else
	    posToString pos1 ^ "-" ^ posToString pos2

  end
(* src # 11 ../error/CRASH.sig *)
(*
 * Handling of internal inconsistencies.
 *)

signature CRASH =
  sig
    exception Crash of string
  end
(* src # 12 ../error/Crash.sml *)
(*
 * Handling of internal inconsistencies.
 *)

structure Crash :> CRASH =
  struct
    exception Crash of string
  end
(* src # 13 ../error/ERROR.sig *)
(*
 * Error handling.
 *)


signature ERROR =
  sig

    (* Import *)

    type region = Source.region


    (* Export *)

    exception Error of region * string

    val error :	region * string -> 'a
    val warn :	region * string -> unit

  end
(* src # 14 ../error/Error.sml *)
(*
 * Error handling.
 *)


structure Error :> ERROR =
  struct

    (* Import *)

    type region = Source.region


    (* Export *)

    exception Error of region * string

    fun print(reg, s) =
        TextIO.output(TextIO.stdErr,
		      Source.regionToString reg ^ ": " ^ s ^ "\n")

    fun error(reg, message) = ( print(reg,message) ; raise Error(reg,message) )
    fun warn (reg, message) =   print(reg, "warning: " ^ message)

  end
(* src # 15 ../misc/Assert.sml *)
(* This is a hack for SML/NJ until we are bootstrapped. Use
	Assert.assert(exp)
   for assertions and
	raise Assert.failure
   for definite failures.

   In Stockhausen assert will be a toplevel builtin (probably a keyword).
   Its type will be bool -> 'a (delivering a NoGood on return). Definite
   failures can then be written as
	assert false
   (very similar to O'Caml).

   Another design would be to have a derived form
	assert exp of pat => exp
   which is a derived form for
	case exp of pat => exp | _ => raise Assert(_)
   and an additional derived form
	assert exp => exp
   which expands to
	assert exp of true => exp
   (very much like if expands to case). But how could definite failure fit
   into this?
*)

structure Assert =
  struct

    exception Assert of string * int * int	(* (file, line, column) *)

    val failure = Assert("?", 0, 0)

    fun assert true  = ()
      | assert false = raise failure

  end
(* src # 16 ../misc/HASH_KEY.sig *)
signature HASH_KEY =
  sig
    eqtype t
    val hash :  t -> int
  end
(* src # 17 ../misc/StringHashKey.sml *)
structure StringHashKey : HASH_KEY =
  struct

    type t = string

    open Word
    infix << >> andb xorb

    fun hash s =	(* hashpjw [Aho/Sethi/Ullman "Compilers"] *)
	let
	    val n = String.size s

	    fun iter(i,h) =
		if i = n then h else
		let
		    val c  = fromInt(Char.ord(String.sub(s,i)))
		    val h' = (h << 0w4) + c
		    val g  = h' andb 0wxf00000
		in
		    iter(Int.+(i,1), h' xorb g xorb (g >> 0w16))
		end
	in
	    toInt(iter(0,0w0))
	end
    
  end
(* src # 18 ../misc/Wide.sml *)
(* Fake Wide{Char,String} structures, coz they are missing in SML/NJ *)

structure WideChar   = Char
structure WideString = String
(* src # 19 ../misc/MISC.sig *)
(*
 * Stuff that should be in the standard structures.
 *)

signature MISC =
  sig

    val General_swap :	'a ref * 'a ref -> unit

    val Option_isNone :	'a option -> bool
    val Option_app :	('a -> unit) -> 'a option -> unit
    val Option_fold :	('a * 'b -> 'b) -> 'b -> 'a option -> 'b

    val List_appr :	('a -> unit) -> 'a list -> unit
    val List_foldli :	(int * 'a * 'b -> 'b) -> 'b -> 'a list -> 'b
    val List_foldri :	(int * 'a * 'b -> 'b) -> 'b -> 'a list -> 'b
    val List_mapi :	(int * 'a -> 'b) -> 'a list -> 'b list
    val List_appi :	(int * 'a -> unit) -> 'a list -> unit

    val ListPair_find :	('a * 'b -> bool) -> 'a list * 'b list -> ('a * 'b) option

    val Array_all :	('a -> bool) -> 'a array -> bool
    val Array_exists :	('a -> bool) -> 'a array -> bool

    val Char_toWide :		Char.char -> WideChar.char
    val Char_fromWide :		WideChar.char -> Char.char	(* Chr *)

    val String_toWide :		String.string -> WideString.string
    val String_fromWide :	WideString.string -> String.string (* Chr *)

  end
(* src # 20 ../misc/Misc.sml *)
(*
 * Stuff that should be in the standard structures.
 *)

structure Misc :> MISC =
  struct

    fun General_swap(r1 as ref x1, r2 as ref x2) =
	( r1 := x2 ; r2 := x1 )

    fun Option_isNone NONE		= true
      | Option_isNone  _		= false

    fun Option_app f  NONE		= ()
      | Option_app f (SOME x)		= f x

    fun Option_fold f b  NONE		= b
      | Option_fold f b (SOME a)	= f(a,b)


    fun List_appr f  nil		= ()
      | List_appr f (x::xs)		= ( List_appr f xs ; f x )

    fun List_foldli f z xs =
	let
	    fun foldli' (x::xr, z, i) =
		foldli' (xr, f (i, x, z), i + 1)
	      | foldli' (nil, z, _) = z
	in
	    foldli' (xs, z, 0)
	end

    fun List_foldri f z xs =
	let
	    fun foldri' (x::xr, z, i) =
		f (i, x, foldri' (xr, z, i + 1))
	      | foldri' (nil, z, _) = z
	in
	    foldri' (xs, z, 0)
	end

    fun List_mapi f xs =
	let
	    fun mapi' (x::xr, i) = f (i, x)::mapi' (xr, i + 1)
	      | mapi' (nil, _) = nil
	in
	    mapi' (xs, 0)
	end

    fun List_appi f xs =
	let
	    fun appi' (x::xr, i) = (f (i, x); appi' (xr, i + 1))
	      | appi' (nil, _) = ()
	in
	    appi' (xs, 0)
	end


    fun ListPair_find f (nil,_)		= NONE
      | ListPair_find f (_,nil)		= NONE
      | ListPair_find f (x::xs, y::ys)	= if f(x,y) then SOME(x,y)
						    else ListPair_find f (xs,ys)


    fun Array_all p a			= let val size   = Array.length a
					      fun iter i =
						  if i = size then true
				  		  else p(Array.sub(a,i))
							andalso iter(i+1)
					  in iter 0 end

    fun Array_exists p a		= let val size   = Array.length a
					      fun iter i =
						  if i = size then false
				  		  else p(Array.sub(a,i))
							orelse iter(i+1)
					  in iter 0 end

    val Char_toWide	= WideChar.chr o Char.ord
    val Char_fromWide	= Char.chr o WideChar.ord
    val String_toWide	= WideString.implode o List.map Char_toWide o String.explode
    val String_fromWide	= String.implode o List.map Char_fromWide o WideString.explode

  end
(* src # 21 ../misc/IMP_SET.sig *)
signature IMP_SET =
  sig

    eqtype item
    type set
    type t = set

    exception Delete    of item
    exception Collision of item

    val new :		unit -> set
    val clone :		set -> set

    val delete :	set * item -> unit
    val deleteExistent:	set * item -> unit		(* Delete *)
    val deleteWith :	(item -> unit) -> set * item -> unit

    val insert :	set * item -> unit
    val insertDisjoint:	set * item -> unit		(* Collision *)
    val insertWith :	(item -> unit) -> set * item -> unit

    val union :		set * set  -> unit
    val unionDisjoint :	set * set  -> unit		(* Collision *)
    val unionWith :	(item -> unit) -> set * set  -> unit

    val member :	set * item -> bool
    val size :		set -> int
    val isEmpty :	set -> bool

    val app :		(item -> unit) -> set -> unit
    val fold :		(item * 'a -> 'a) -> 'a -> set -> 'a

  end
(* src # 22 ../misc/MakeHashImpSet.sml *)
functor MakeHashImpSet(Item: HASH_KEY) :> IMP_SET where type item = Item.t =
  struct

    type item = Item.t
    type set  = item list array ref * int ref
    type t    = set

    exception Delete    of item
    exception Collision of item


    val initialSize		= 19

    fun new()			= (ref(Array.array(initialSize,[])), ref 0)

    fun size(_, ref n)		= n
    fun isEmpty(_, ref n)	= n = 0

    fun app f (ref t, _)	= Array.app (List.app f) t
    fun fold f a (ref t, _)	= Array.foldl(fn(ks,a) => List.foldl f a ks) a t


    fun clone(ref t, ref n)	= let val t' = Array.array(Array.length t, [])
				  in
				      Array.copy{src=t, dst=t', si=0, di=0,
						 len=NONE} ;
				      (ref t', ref n)
				  end


    fun hash(t,k)		= Item.hash k mod Array.length t

    fun member((ref t,_), k)	= let val ks = Array.sub(t, hash(t,k)) in
				      List.exists (fn k' => k = k') ks
				  end


    exception Delete'

    fun delete'( [],   k')	= raise Delete'
      | delete'(k::ks, k')	= if k = k' then ks
					    else k :: delete'(ks,k')

    fun deleteWith f (s,k)	= let val (ref t,n) = s
				      val i   = hash(t,k)
				      val ks  = Array.sub(t,i)
				      val ks' = delete'(ks,k) before n := !n-1
						handle Delete' =>
						       (f k ; ks)
				  in
				      Array.update(t,i,ks')
				  end

    val delete			= deleteWith ignore
    val deleteExistent		= deleteWith(fn k => raise Delete k)


    fun reinsert t k		= let val i = hash(t,k) in
				      Array.update(t, i, k::Array.sub(t,i))
				  end

    fun resize(r as ref t,ref n)= if 3 * n < 2 * Array.length t then () else
				  let
				      val t'= Array.array(2*Array.length t-1,[])
				  in
				      Array.app(List.app (reinsert t')) t ;
				      r := t'
				  end

    fun insertWith f (s,k)	= let val _  = resize s
				      val (ref t,n) = s
				      val i  = hash(t,k)
				      val ks = Array.sub(t,i)
				  in
				      if List.exists (fn k' => k = k') ks
				      then f k
				      else ( Array.update(t, i, k::ks)
					   ; n := !n+1 )
				  end

    val insert			= insertWith ignore
    val insertDisjoint		= insertWith(fn k => raise Collision k)

    fun union(s1,s2)		= app (fn k => insert(s1,k)) s2
    fun unionDisjoint(s1,s2)	= app (fn k => insertDisjoint(s1,k)) s2
    fun unionWith f (s1,s2)	= app (fn k => insertWith f (s1,k)) s2

  end
(* src # 23 ../misc/IMP_MAP.sig *)
signature IMP_MAP =
  sig

    eqtype key
    type 'a map
    type 'a t = 'a map

    exception Delete    of key
    exception Collision of key
    exception Lookup    of key

    val new :		unit -> 'a map
    val clone :		'a map -> 'a map

    val delete :	'a map * key -> unit
    val deleteExistent:	'a map * key -> unit		(* Delete *)
    val deleteWith :	(key -> unit) -> 'a map * key -> unit

    val insert :	'a map * key * 'a -> unit
    val insertDisjoint:	'a map * key * 'a -> unit	(* Collision *)
    val insertWith :	('a * 'a -> 'a) -> 'a map * key * 'a -> unit
    val insertWithi :	(key * 'a * 'a -> 'a) -> 'a map * key * 'a -> unit

    val union :		'a map * 'a map -> unit
    val unionDisjoint :	'a map * 'a map -> unit		(* Collision *)
    val unionWith :	('a * 'a -> 'a) -> 'a map * 'a map -> unit
    val unionWithi :	(key * 'a * 'a -> 'a) -> 'a map * 'a map -> unit

    val lookup :	'a map * key -> 'a option
    val lookupExistent:	'a map * key -> 'a		(* Lookup *)

    val member :	'a map * key -> bool
    val size :		'a map -> int
    val isEmpty :	'a map -> bool

    val app :		('a -> unit) -> 'a map -> unit
    val fold :		('a * 'b -> 'b) -> 'b -> 'a map -> 'b
    val appi :		(key * 'a -> unit) -> 'a map -> unit
    val foldi :		(key * 'a * 'b -> 'b) -> 'b -> 'a map -> 'b

  end
(* src # 24 ../misc/MakeHashImpMap.sml *)
functor MakeHashImpMap(Key: HASH_KEY) :> IMP_MAP where type key = Key.t =
  struct

    type key    = Key.t
    type 'a map = (key * 'a) list array ref * int ref
    type 'a t   = 'a map

    exception Delete    of key
    exception Collision of key
    exception Lookup    of key


    val initialSize		= 19

    fun new()			= (ref(Array.array(initialSize,[])), ref 0)

    fun size(_, ref n)		= n
    fun isEmpty(_, ref n)	= n = 0

    fun appi f (ref t, _)	= Array.app (List.app f) t
    fun foldi f b (ref t, _)	= let fun f'((k,a),b) = f(k,a,b) in
				      Array.foldl (fn(kas,b) =>
							List.foldl f' b kas
						  ) b t
				  end
    fun app f			= appi(fn(k,a) => f a)
    fun fold f			= foldi(fn(k,a,b) => f(a,b))


    fun clone(ref t, ref n)	= let val t' = Array.array(Array.length t, [])
				  in
				      Array.copy{src=t, dst=t', si=0, di=0,
						 len=NONE} ;
				      (ref t', ref n)
				  end


    fun hash(t,k)		= Key.hash k mod Array.length t
    fun isEntryFor k (k',_)	= k = k'

    fun member((ref t,_), k)	= let val kas = Array.sub(t, hash(t,k)) in
				    List.exists (isEntryFor k) kas
				  end

    fun lookup((ref t,_), k)	= let val kas = Array.sub(t, hash(t,k)) in
				    Option.map #2 (List.find (isEntryFor k) kas)
				  end

    fun lookupExistent((ref t,_), k)
    				= let val kas = Array.sub(t, hash(t,k)) in
				    case List.find (isEntryFor k) kas
				      of NONE      => raise Lookup k
				       | SOME(k,a) => a
				  end

    exception Delete'

    fun delete'(  [],    k)	= raise Delete'
      | delete'(ka::kas, k)	= if #1 ka = k then kas : (key * 'a) list
					       else ka :: delete'(kas,k)

    fun deleteWith f (m,k)	= let val (ref t,n) = m
				      val i    = hash(t,k)
				      val kas  = Array.sub(t,i)
				      val kas' = delete'(kas,k) before n := !n-1
						 handle Delete' => (f k ; kas)
				  in
				      Array.update(t, i, kas')
				  end

    fun delete x		= deleteWith ignore x
    fun deleteExistent x	= deleteWith(fn k => raise Delete k) x


    fun reinsert t (ka as(k,_))	= let val i = hash(t,k) in
				      Array.update(t, i, ka::Array.sub(t,i))
				  end

    fun resize(r as ref t,ref n)= if 3 * n < 2 * Array.length t then () else
				  let
				      val t'= Array.array(2*Array.length t-1,[])
				  in
				      Array.app(List.app (reinsert t')) t ;
				      r := t'
				  end

    fun insertWithi f (m,k,a)	= let val _  = resize m
				      val (ref t,n) = m
				      val i    = hash(t,k)
				      val kas  = Array.sub(t,i)
				      val kas' =
					case List.find (isEntryFor k) kas
					  of NONE =>
						(k,a)::kas before n := !n+1
					   | SOME(k,a') =>
						(k, f(k,a',a))::delete'(kas,k)
				  in
				      Array.update(t, i, kas')
				  end

    fun insertWith f		= insertWithi(fn(k,a1,a2) => f(a1,a2))
    fun insert x		= insertWithi #3 x
    fun insertDisjoint x	= insertWithi(fn(k,_,_) => raise Collision k) x


    fun union' insert (m1,m2)	= appi (fn(k,a) => insert(m1,k,a)) m2
    fun union x			= union' insert x
    fun unionDisjoint x		= union' insertDisjoint x
    fun unionWith f		= union'(insertWith f)
    fun unionWithi f		= union'(insertWithi f)

  end
(* src # 25 ../misc/SCOPED_IMP_SET.sig *)
(*
 * A stateful scoped map (a stateful stack of stateful maps).
 *)

signature SCOPED_IMP_SET =
  sig

    type item
    type set
    type t = set

    exception Delete    of item
    exception Collision of item

    val new :			unit -> set

    val clone :			set -> set
    val cloneScope :		set -> set

    val insertScope :		set -> unit
    val inheritScope :		set * set -> unit
    val deleteScope :		set -> unit
    val splitScope :		set -> set

    val mergeScope :		set -> unit
    val mergeDisjointScope :	set -> unit			(* Collision *)
    val mergeScopeWith :	(item -> unit) -> set -> unit

    val delete :		set * item -> unit
    val deleteExistent :	set * item -> unit		(* Delete *)
    val deleteWith :		(item -> unit) -> set * item -> unit

    val insert :		set * item -> unit
    val insertDisjoint :	set * item -> unit		(* Collision *)
    val insertWith :		(item -> unit) -> set * item -> unit

    val union :			set * set  -> unit
    val unionDisjoint :		set * set  -> unit		(* Collision *)
    val unionWith :		(item -> unit) -> set * set -> unit

    val member :		set * item -> bool
    val memberScope :		set * item -> bool

    val size :			set -> int
    val sizeScope :		set -> int

    val isEmpty :		set -> bool
    val isEmptyScope :		set -> bool

    val app :			(item -> unit) -> set -> unit
    val appScope :		(item -> unit) -> set -> unit

    val fold :			(item * 'a -> 'a) -> 'a -> set -> 'a
    val foldScope :		(item * 'a -> 'a) -> 'a -> set -> 'a

  end
(* src # 26 ../misc/MakeScopedImpSet.sml *)
functor MakeScopedImpSet(ImpSet: IMP_SET) :>
  SCOPED_IMP_SET where type item = ImpSet.item =
  struct

    type item = ImpSet.item
    type set  = ImpSet.t list ref
    type t    = set

    exception Delete    = ImpSet.Delete
    exception Collision = ImpSet.Collision


    val scopeSize = 19

    fun new()			= ref[ImpSet.new()]
    fun clone(ref ss)		= ref(List.map ImpSet.clone ss)
    fun cloneScope(ref ss)	= ref[ImpSet.clone(List.hd ss)]
    fun insertScope r		= r := ImpSet.new() :: !r
    fun deleteScope r		= r := List.tl(!r)
    fun splitScope(r as ref ss)	= ( deleteScope r ; ref[List.hd ss] )
    fun inheritScope(r,r')	= r := List.hd(!(splitScope r')) :: !r

    fun mergeScope' unionSet (r as ref ss)
				= let val ss' = List.tl ss in
				      unionSet(List.hd ss', List.hd ss) ;
				      r := ss'
				  end

    fun mergeScope r		= mergeScope' ImpSet.union r
    fun mergeDisjointScope r	= mergeScope' ImpSet.unionDisjoint r
    fun mergeScopeWith f	= mergeScope'(ImpSet.unionWith f)


    fun member'( [],   i)	= false
      | member'(s::ss, i)	= ImpSet.member(s,i) orelse member'(ss,i)

    fun member(ref ss, i)	= member'(ss,i)

    fun memberScope(ref ss, i)	= ImpSet.member(List.hd ss, i)

    fun isEmptyScope(ref ss)	= ImpSet.isEmpty(List.hd ss)
    fun isEmpty(ref ss)		= List.all ImpSet.isEmpty ss

    fun sizeScope(ref ss)	= ImpSet.size(List.hd ss)
    fun size(ref ss)		= List.foldl (fn(s,n) => n + ImpSet.size s) 0 ss

    fun appScope f (ref ss)	= ImpSet.app f (List.hd ss)
    fun app f (ref ss)		= List.app (ImpSet.app f) (List.rev ss)
    fun foldScope f a (ref ss)	= ImpSet.fold f a (List.hd ss)
    fun fold f a (ref ss)	= List.foldr (fn(s,a') => ImpSet.fold f a' s)
					     a ss

    fun delete(ref ss, i)		= ImpSet.delete(List.hd ss, i)
    fun deleteExistent(ref ss, i)	= ImpSet.deleteExistent(List.hd ss, i)
    fun deleteWith f (ref ss, i)	= ImpSet.deleteWith f (List.hd ss, i)

    fun insert(ref ss, i)		= ImpSet.insert(List.hd ss, i)
    fun insertDisjoint(ref ss, i)	= ImpSet.insertDisjoint(List.hd ss, i)
    fun insertWith f (ref ss, i)	= ImpSet.insertWith f (List.hd ss, i)

    fun union' setUnion (ref ss1, ref ss2)
				= let val s1 = List.hd ss1 in
				      List.app (fn s2 => setUnion(s1,s2)) ss2
				  end

    fun union x			= union' ImpSet.union x
    fun unionDisjoint x		= union' ImpSet.unionDisjoint x
    fun unionWith f		= union'(ImpSet.unionWith f)

  end
(* src # 27 ../misc/MakeHashScopedImpSet.sml *)
functor MakeHashScopedImpSet(Item: HASH_KEY) =
	MakeScopedImpSet(MakeHashImpSet(Item))
(* src # 28 ../misc/SCOPED_IMP_MAP.sig *)
 (*
 * A stateful scoped map (a stateful stack of stateful maps).
 *)

signature SCOPED_IMP_MAP =
  sig

    type key
    type 'a map
    type 'a t = 'a map

    exception Delete    of key
    exception Collision of key
    exception Lookup    of key

    val new :			unit -> 'a map

    val clone :			'a map -> 'a map
    val cloneScope :		'a map -> 'a map

    val insertScope :		'a map -> unit
    val deleteScope :		'a map -> unit
    val inheritScope :		'a map * 'a map -> unit
    val splitScope :		'a map -> 'a map

    val mergeScope :		'a map -> unit
    val mergeDisjointScope :	'a map -> unit			(* Collision *)
    val mergeScopeWith :	('a * 'a -> 'a) -> 'a map -> unit
    val mergeScopeWithi :	(key * 'a * 'a -> 'a) -> 'a map -> unit

    val delete :		'a map * key -> unit
    val deleteExistent :	'a map * key -> unit		(* Delete *)
    val deleteWith :		(key -> unit) -> 'a map * key -> unit

    val insert :		'a map * key * 'a -> unit
    val insertDisjoint :	'a map * key * 'a -> unit	(* Collision *)
    val insertWith :		('a * 'a -> 'a) -> 'a map * key * 'a -> unit
    val insertWithi :		(key * 'a * 'a -> 'a) -> 'a map * key * 'a
									 -> unit
    val union :			'a map * 'a map -> unit
    val unionDisjoint :		'a map * 'a map -> unit		(* Collision *)
    val unionWith :		('a * 'a -> 'a) -> 'a map * 'a map -> unit
    val unionWithi :		(key * 'a * 'a -> 'a) -> 'a map * 'a map -> unit

    val lookup :		'a map * key -> 'a option
    val lookupScope :		'a map * key -> 'a option
    val lookupExistent :	'a map * key -> 'a		(* Lookup *)
    val lookupExistentScope :	'a map * key -> 'a		(* Lookup *)

    val member :		'a map * key -> bool
    val memberScope :		'a map * key -> bool

    val size :			'a map -> int
    val sizeScope :		'a map -> int

    val isEmpty :		'a map -> bool
    val isEmptyScope :		'a map -> bool

    val app :			('a -> unit) -> 'a map -> unit
    val appScope :		('a -> unit) -> 'a map -> unit
    val appi :			(key * 'a -> unit) -> 'a map -> unit
    val appiScope :		(key * 'a -> unit) -> 'a map -> unit

    val fold :			('a * 'b -> 'b) -> 'b -> 'a map -> 'b
    val foldScope :		('a * 'b -> 'b) -> 'b -> 'a map -> 'b
    val foldi :			(key * 'a * 'b -> 'b) -> 'b -> 'a map -> 'b
    val foldiScope :		(key * 'a * 'b -> 'b) -> 'b -> 'a map -> 'b

  end
(* src # 29 ../misc/MakeScopedImpMap.sml *)
functor MakeScopedImpMap(ImpMap: IMP_MAP) :>
  SCOPED_IMP_MAP where type key = ImpMap.key =
  struct

    type key    = ImpMap.key
    type 'a map = 'a ImpMap.t list ref
    type 'a t   = 'a map

    exception Delete    = ImpMap.Delete
    exception Collision = ImpMap.Collision
    exception Lookup    = ImpMap.Lookup


    fun new()			= ref[ImpMap.new()]
    fun clone(ref ms)		= ref(List.map ImpMap.clone ms)
    fun cloneScope(ref ms)	= ref[ImpMap.clone(List.hd ms)]
    fun insertScope r		= r := ImpMap.new() :: !r
    fun deleteScope r		= r := List.tl(!r)
    fun splitScope(r as ref ms)	= ( deleteScope r ; ref[List.hd ms] )
    fun inheritScope(r,r')	= r := List.hd(!(splitScope r')) :: !r

    fun mergeScope' unionMap (r as ref ms)
				= let val ms' = List.tl ms in
				      unionMap(List.hd ms', List.hd ms) ;
				      r := ms'
				  end

    fun mergeScope r		= mergeScope' ImpMap.union r
    fun mergeDisjointScope r	= mergeScope' ImpMap.unionDisjoint r
    fun mergeScopeWith f	= mergeScope'(ImpMap.unionWith f)
    fun mergeScopeWithi f	= mergeScope'(ImpMap.unionWithi f)


    fun lookup'( [],   k)	= raise Lookup k
      | lookup'([m],   k)	= ImpMap.lookupExistent(m,k)
      | lookup'(m::ms, k)	= case ImpMap.lookup(m,k)
				    of NONE   => lookup'(ms,k)
				     | SOME a => a

    fun lookup(ref ms, k)		= SOME(lookup'(ms,k))
					  handle Lookup _ => NONE
    fun lookupExistent(ref ms, k)	= lookup'(ms,k)
    fun lookupScope(ref ms, k)		= ImpMap.lookup(List.hd ms, k)
    fun lookupExistentScope(ref ms, k)	= ImpMap.lookupExistent(List.hd ms, k)

    fun member(ref ms, k)	= ( lookup'(ms, k) ; true )
				  handle Lookup _ => false
    fun memberScope(ref ms, k)	= ImpMap.member(List.hd ms, k)

    fun isEmptyScope(ref ms)	= ImpMap.isEmpty(List.hd ms)
    fun isEmpty(ref ms)		= List.all ImpMap.isEmpty ms

    fun sizeScope(ref ms)	= ImpMap.size(List.hd ms)
    fun size(ref ms)		= List.foldl (fn(m,n) => n + ImpMap.size m) 0 ms

    fun appScope f (ref ms)	= ImpMap.app f (List.hd ms)
    fun app f (ref ms)		= List.app (ImpMap.app f) (List.rev ms)
    fun foldScope f b (ref ms)	= ImpMap.fold f b (List.hd ms)
    fun fold f b (ref ms)	= List.foldr (fn(m,b') => ImpMap.fold f b' m)
					     b ms
    fun appiScope f (ref ms)	= ImpMap.appi f (List.hd ms)
    fun appi f (ref ms)		= List.app (ImpMap.appi f) (List.rev ms)
    fun foldiScope f b (ref ms)	= ImpMap.foldi f b (List.hd ms)
    fun foldi f b (ref ms)	= List.foldr (fn(m,b') => ImpMap.foldi f b' m)
					     b ms

    fun delete(ref ms, k)		= ImpMap.delete(List.hd ms, k)
    fun deleteExistent(ref ms, k)	= ImpMap.deleteExistent(List.hd ms, k)
    fun deleteWith f (ref ms, k)	= ImpMap.deleteWith f (List.hd ms, k)

    fun insert(ref ms, k, a)		= ImpMap.insert(List.hd ms, k, a)
    fun insertDisjoint(ref ms, k, a)	= ImpMap.insertDisjoint(List.hd ms, k,a)
    fun insertWith f (ref ms, k, a)	= ImpMap.insertWith f (List.hd ms, k, a)
    fun insertWithi f (ref ms, k, a)	= ImpMap.insertWithi f (List.hd ms, k,a)

    fun union' mapUnion (ref ms1, ref ms2)
				= let val m = List.hd ms1 in
				      List.app (fn m' => mapUnion(m,m')) ms2
				  end

    fun union x			= union' ImpMap.union x
    fun unionDisjoint x		= union' ImpMap.unionDisjoint x
    fun unionWith f		= union'(ImpMap.unionWith f)
    fun unionWithi f		= union'(ImpMap.unionWithi f)

  end
(* src # 30 ../misc/MakeHashScopedImpMap.sml *)
functor MakeHashScopedImpMap(Key: HASH_KEY) =
	MakeScopedImpMap(MakeHashImpMap(Key))
(* src # 31 ../misc/STAMP.sig *)
(*
 * Stamp generator.
 *)


signature STAMP =
  sig

    eqtype stamp
    type t = stamp

    val new :		unit -> stamp
    val toString :	stamp -> string

    val reset :		unit -> unit

    val compare :	stamp * stamp -> order
    val hash :		stamp -> int

  end
(*DEBUG where type stamp = int*)
(* src # 32 ../misc/MakeStamp.sml *)
(*
 * Stamp generator.
 *)


functor MakeStamp() : (*DEBUG :>*) STAMP =
  struct

    type stamp = int
    type t     = stamp

    val r = ref 0

    fun reset()  =  r := 0
    fun new()    = (r := !r + 1; !r)

    val toString = Int.toString
    val compare  = Int.compare

    fun hash n   = n

  end
(* src # 33 ../misc/PRETTY_PRINT.sig *)
(*
 * A generic pretty printer.
 *
 * Based on:
 *    Philip Wadler. "A prettier printer"
 *    http://cm.bell-labs.com/cm/cs/who/wadler/
 * and Christian Lindig's port to OCaml.
 *
 * The semantics has been extended to allow 4 different kinds of
 * groups (`boxes'), 2 modes of nesting, and varying break representations.
 * This is no more easily described by an algebra though, and the `below'
 * combinator looses optimality.
 *)

signature PRETTY_PRINT =
  sig

    eqtype doc

    val empty :		doc			(* empty document *)
    val break :		doc			(* space or line break *)
    val ebreak :	doc			(* empty or line break *)
    val text :		string -> doc		(* raw text *)

    val ^^ :		doc * doc -> doc	(* concatenation *)
    val ^/^ :		doc * doc -> doc	(* concatenation with break *)

    val hbox :		doc -> doc		(* horizontal box *)
    val vbox :		doc -> doc		(* vertical box *)
    val fbox :		doc -> doc		(* fill box (h and v) *)
    val abox :		doc -> doc		(* auto box (h or v) *)

    val nest :		int -> doc -> doc	(* indentation by k char's *)
    val below :		doc -> doc		(* keep current indentation *)

    val isEmpty :	doc -> bool

    val toString :	doc * int -> string
    val output :	TextIO.outstream * doc * int -> unit

  end
(* src # 34 ../misc/PrettyPrint.sml *)
(*
 * A generic pretty printer.
 *
 * Based on:
 *    Philip Wadler. "A prettier printer"
 *    http://cm.bell-labs.com/cm/cs/who/wadler/
 * and Christian Lindig's port to OCaml.
 *
 * The semantics has been extended to allow 4 different kinds of
 * groups (`boxes'), 2 modes of nesting, and varying break representations.
 * This is no more easily described by an algebra though, and the `below'
 * combinator looses optimality.
 *)

structure PrettyPrint :> PRETTY_PRINT =
  struct

    (* Types *)

    datatype mode = H | V | F | A

    datatype doc =
	  EMPTY
	| BREAK of string
	| TEXT  of string
	| CONS  of doc * doc
	| BOX   of mode * doc
	| NEST  of int * doc
	| BELOW of doc

    datatype prim =
	  PTEXT of string
	| PLINE of int


    (* Interface operators *)

    infixr ^^ ^/^

    val empty	= EMPTY
    val break	= BREAK " "
    val ebreak	= BREAK ""
    val text	= TEXT

    fun x ^^ EMPTY	= x
      | EMPTY ^^ y	= y
      | x ^^ y		= CONS(x, y)

    fun x ^/^ EMPTY	= x
      | EMPTY ^/^ y	= y
      | x ^/^ y		= CONS(x, CONS(break, y))

    fun below EMPTY	= EMPTY
      | below x		= BELOW x

    fun hbox EMPTY	= EMPTY
      | hbox x		= BOX(H, x)

    fun vbox EMPTY	= EMPTY
      | vbox x		= BOX(V, x)

    fun fbox EMPTY	= EMPTY
      | fbox x		= BOX(F, x)

    fun abox EMPTY	= EMPTY
      | abox x		= BOX(A, x)

    fun nest k EMPTY	= EMPTY
      | nest k x	= NEST(k, x)


    fun isEmpty EMPTY	= true
      | isEmpty _	= false


    (* Check whether the first line of a document fits into remaining characters *)

    (* We abuse the mode A (which can never occur in the lists passed to
     * fits) to flag breaks which occur inside swallowed vboxes.
     *)

    fun fits(w, z) =
	w >= 0 andalso
	case z
	  of []			=> true
	   | (i,m,EMPTY)::z	=> fits(w, z)
	   | (i,m,CONS(x,y))::z	=> fits(w, (i,m,x)::(i,m,y)::z)
	   | (i,m,TEXT s)::z	=> fits(w - String.size s, z)
	   | (i,H,BREAK s)::z	=> fits(w - String.size s, z)
	   | (i,A,BREAK s)::z	=> false
	   | (i,m,BREAK s)::z	=> true
	   | (i,m,BOX(V,x))::z	=> fits(w, (i,A,x)::z)
	   | (i,m,BOX(n,x))::z	=> fits(w, (i,H,x)::z)
	   | (i,m,NEST(j,x))::z	=> fits(w, (i,m,x)::z)
	   | (i,m,BELOW x)::z	=> fits(w, (i,m,x)::z)


    (* Layout *)

    fun best(w, k, z, a) =
	case z
	  of []			=> List.rev a
	   | (i,m,EMPTY)::z	=> best(w, k, z, a)
	   | (i,m,CONS(x,y))::z	=> best(w, k, (i,m,x)::(i,m,y)::z, a)
	   | (i,m,TEXT s)::z	=> best(w, k + String.size s, z, PTEXT(s)::a)
	   | (i,H,BREAK s)::z	=> horizontal(w, k, s, z, a)
	   | (i,V,BREAK s)::z	=> vertical(w, i, z, a)
	   | (i,F,BREAK s)::z	=> if fits(w - k - String.size s, z)
				   then horizontal(w, k, s, z, a)
				   else vertical(w, i, z, a)
	   | (i,A,BREAK s)::z	=> raise Fail "PrettyPrint.best"
	   | (i,m,BOX(A,x))::z	=> if fits(w - k, (i,H,x)::z)
				   then best(w, k, (i,H,x)::z, a)
				   else best(w, k, (i,V,x)::z, a)
	   | (i,m,BOX(n,x))::z	=> best(w, k, (i,n,x)::z, a)
	   | (i,m,NEST(j,x))::z	=> best(w, k, (i+j,m,x)::z, a)
	   | (i,m,BELOW x)::z	=> best(w, k, (k,m,x)::z, a)

    and horizontal(w, k, s, z, a) =
	    best(w, k + String.size s, z, PTEXT(s)::a)

    and vertical(w, i, z, a) =
	    best(w, i, z, PLINE(i)::a)


    fun layout(doc, w) = best(w, 0, [(0,V,doc)], [])



    (* Convert a document *)

    fun primToString(PTEXT s) = s
      | primToString(PLINE i) = 
	    String.implode(#"\n" :: List.tabulate(i, fn _ => #" "))

    val toString = String.concat o List.map primToString o layout



    (* Output a document directly (is MUCH faster!) *)

    fun loop 0 f = ()
      | loop n f = ( f() ; loop (n-1) f )

    fun outputPrim os (PTEXT s) = TextIO.output(os, s)
      | outputPrim os (PLINE i) =
	    ( TextIO.output1(os, #"\n")
	    ; loop i (fn() => TextIO.output1(os, #" "))
	    )

    fun output(os, doc, w) = List.app (outputPrim os) (layout(doc, w))

  end
(* src # 35 ../misc/PP_MISC.sig *)
(*
 * Miscellaneous pretty printing helpers
 *)

signature PP_MISC =
  sig

    type doc = PrettyPrint.doc

    val nest:		doc -> doc

    val quote:		doc -> doc
    val paren:		doc -> doc
    val brace:		doc -> doc
    val brack:		doc -> doc

    val ppCommaList:	('a -> doc) -> 'a list -> doc
    val ppStarList:	('a -> doc) -> 'a list -> doc
    val ppSeq:		('a -> doc) -> 'a list -> doc
    val ppSeqPrec:	(int -> 'a -> doc) -> int -> 'a list -> doc

    val par:		doc list -> doc
    val textpar:	string list -> doc
    val indent:		doc -> doc

  end
(* src # 36 ../misc/PPMisc.sml *)
(*
 * Miscellaneous pretty printing helpers
 *)

structure PPMisc :> PP_MISC =
  struct

    (* Import *)

    open PrettyPrint

    infixr ^^ ^/^


    (* Some PP combinators *)

    val nest = nest 3

    fun quote doc  = text "`" ^^ doc ^^ text "'"
    fun paren doc  = text "(" ^^ fbox(below doc) ^^ text ")"
    fun brace doc  = text "{" ^^ fbox(below doc) ^^ text "}"
    fun brack doc  = text "[" ^^ fbox(below doc) ^^ text "]"

    fun indent doc = nest(break ^^ below doc) ^^ break
    val par        = fbox o List.foldr (fn(doc',doc) => doc' ^/^ doc) empty
    val textpar    = fbox o List.foldr (fn(s,doc) => text s ^/^ doc) empty

    fun ppCommaList ppX   []    = empty
      | ppCommaList ppX   [x]   = ppX x
      | ppCommaList ppX (x::xs) = ppX x ^^ text "," ^^ break ^^
				  ppCommaList ppX xs

    fun ppStarList ppX   []     = empty
      | ppStarList ppX   [x]    = ppX x
      | ppStarList ppX (x::xs)  = hbox(ppX x ^^ break ^^ text "*") ^^ break ^^
				  ppStarList ppX xs

    fun ppSeqPrec ppXPrec n []  = empty
      | ppSeqPrec ppXPrec n [x] = ppXPrec n x
      | ppSeqPrec ppXPrec n  xs = paren(ppCommaList (ppXPrec 0) xs)

    fun ppSeq ppX = ppSeqPrec (fn _ => ppX) 0

  end
(* src # 37 ../misc/URL.sig *)
(*
 * Authors:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2000
 *   Andreas Rossberg, 2000
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature URL =
    sig
	eqtype url
	type t = url

	type scheme = string option
	type authority = string option
	type device = char option
	type path = string list
	type query = string option
	type fragment = string option

	exception Malformed

	val empty: url
	val fromString: string -> url              (* Malformed *)
	val toString: url -> string
	val isAbsolute: url -> bool
	val resolve: url -> url -> url
	val compare: url * url -> order
	val hash: url -> int

	(* Accessing URL Constituents *)

	val getScheme: url -> scheme
	val getAuthority: url -> authority
	val getDevice: url -> device
	val isAbsolutePath: url -> bool
	val getPath: url -> path
	val getQuery: url -> query
	val getFragment: url -> fragment

	val setScheme: url * scheme -> url         (* Malformed *)
	val setAuthority: url * authority -> url   (* Malformed *)
	val setDevice: url * device -> url         (* Malformed *)
	val makeAbsolutePath: url -> url
	val makeRelativePath: url -> url
	val setPath: url * path -> url
	val setQuery: url * query -> url           (* Malformed *)
	val setFragment: url * fragment -> url
    end
(* src # 38 ../misc/Url.sml *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2000
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(*
 * Parts of this have been adapted from Mozart's URL module
 * which has been written Denys Duchier and Christian Schulte.
 *)

structure Url :> URL =
    struct
	type scheme = string option
	type authority = string option
	type device = char option
	type path = string list
	type query = string option
	type fragment = string option

	type url = {scheme: scheme,
		    authority: authority,
		    device: device,
		    absolute: bool,
		    path: path,
		    query: query,
		    fragment: fragment}
	type t = url

	exception Malformed
	exception Crash of string   (*--** *)

	(*
	 * Split a string at the 1st occurrence of a separator character.
	 * Return a tuple (prefix, sep, suffix).  The argument function
	 * has to return true iff a given character is a separator.
	 * If the input is exhausted without finding a separator character,
	 * the prefix contains the whole string, the suffix is nil, and
	 * NONE is returned as separator.
	 *)

	fun split f cs =
	    let
		fun split' (c::cr, f, prefix) =
		    if f c then (List.rev prefix, SOME c, cr)
		    else split' (cr, f, c::prefix)
		  | split' (nil, _, _) = (cs, NONE, nil)
	    in
		split' (cs, f, nil)
	    end

	(*
	 * Decode/encode a path component using '%xx' escapes.
	 *)

	local
	    fun hexval c =
		let
		    val i = Char.ord c
		in
		    if Char.ord #"0" <= i andalso i <= Char.ord #"9"
		    then i - Char.ord #"0"
		    else if Char.ord #"A" <= i andalso i <= Char.ord #"F"
		    then i - Char.ord #"A" + 10
		    else if Char.ord #"a" <= i andalso i <= Char.ord #"f"
		    then i - Char.ord #"a" + 10
		    else raise Malformed
		end
	in
	    fun decode (#"%"::c1::c2::rest) =
		Char.chr (hexval c1 * 16 + hexval c2)::decode rest
	      | decode (#"%"::_) = raise Malformed
	      | decode (c::rest) = c::decode rest
	      | decode nil = nil
	end

	fun isPathChar #";" = true   (*--** should not be *)
	  | isPathChar (#"-" | #"_" | #"." | #"!") = true
	  | isPathChar (#"~" | #"*" | #"'" | #"(") = true
	  | isPathChar (#")" | #":" | #"@" | #"&") = true
	  | isPathChar (#"=" | #"+" | #"$" | #",") = true
	  | isPathChar c = Char.isAlphaNum c

	local
	    val hex = #[#"0", #"1", #"2", #"3", #"4", #"5", #"6", #"7",
			#"8", #"9", #"A", #"B", #"C", #"D", #"E", #"F"]

	    fun encode' (c1::cr, f) =
		if f c1 then c1::encode' (cr, f)
		else
		    let
			(*--** does not work for unicode characters *)
			val i = Char.ord c1
			val h1 = Vector.sub (hex, i div 16)
			val h2 = Vector.sub (hex, i mod 16)
		    in
			#"%"::h1::h2::encode' (cr, f)
		    end
	      | encode' (nil, _) = nil
	in
	    fun encode f s = String.implode (encode' (String.explode s, f))
	end

	(*
	 * A path is represented by a sequence of strings.
	 * Normalizing a path is the process of eliminating occurrences
	 * of path components "." and ".." by interpreting them relative
	 * to the stack of path components.  A leading "." may not be
	 * thrown out because ./foo and foo should be treated differently:
	 * the first one is really an absolute path, whereas the second
	 * one is relative.
	 *)

	local
	    fun normalizePath' (["."], nil) = nil
	      | normalizePath' (["."], stack) = List.rev (""::stack)
	      | normalizePath' ("."::rest, stack) =
		normalizePath' (rest, stack)
	      | normalizePath' ([".."], nil) = [".."]
	      | normalizePath' ([".."], _::stack) = List.rev (""::stack)
	      | normalizePath' (".."::rest, nil) =
		".."::normalizePath' (rest, nil)
	      | normalizePath' (".."::rest, _::stack) =
		normalizePath' (rest, stack)
	      | normalizePath' (s::rest, stack) =
		normalizePath' (rest, s::stack)
	      | normalizePath' (nil, stack) = List.rev stack
	in
	    fun normalizePath ("."::rest) = "."::normalizePath' (rest, nil)
	      | normalizePath s = normalizePath' (s, nil)
	end

	fun toLower cs = String.implode (List.map Char.toLower cs)

	fun toDevice c =
	    if
		Char.ord c >= Char.ord #"a" andalso Char.ord c <= Char.ord #"z"
		orelse
		Char.ord c >= Char.ord #"A" andalso Char.ord c <= Char.ord #"Z"
	    then Char.toLower c
	    else raise Malformed

	fun isStart (#"/" | #"\\" | #":" | #"?" | #"#") = true
	  | isStart _ = false

	fun isPath (#"/" | #"\\" | #"?" | #"#") = true
	  | isPath _ = false

	fun isQuery #"#" = true
	  | isQuery _ = false

	(* Accessing URL Constituents *)

	fun getScheme ({scheme, ...}: url) = scheme
	fun getAuthority ({authority, ...}: url) = authority
	fun getDevice ({device, ...}: url) = device
	fun isAbsolutePath ({absolute, ...}: url) = absolute
	fun getPath ({path, ...}: url) = path
	fun getQuery ({query, ...}: url) = query
	fun getFragment ({fragment, ...}: url) = fragment

	fun setScheme ({scheme = _, authority, device, absolute, path,
			query, fragment}: url, scheme) =
	    (if isSome scheme then
		 case split isStart (String.explode (valOf scheme)) of
		     (_, NONE, _) => ()
		   | (_, SOME _, _) => raise Malformed
	     else ();
	     {scheme = scheme, authority = authority, device = device,
	      absolute = absolute, path = path, query = query,
	      fragment = fragment})

	fun setAuthority ({scheme, authority = _, device, absolute, path,
			   query, fragment}: url, authority) =
	    (if isSome authority then
		 case split isStart (String.explode (valOf authority)) of
		     (_, NONE, _) => ()
		   | (_, SOME _, _) => raise Malformed
	     else ();
	     {scheme = scheme, authority = authority, device = device,
	      absolute = absolute, path = path, query = query,
	      fragment = fragment})

	fun setDevice ({scheme, authority, device = _, absolute, path,
			query, fragment}: url, device) =
	    {scheme = scheme, authority = authority,
	     device = Option.map toDevice device,
	     absolute = absolute, path = path, query = query,
	     fragment = fragment}

	fun makeAbsolutePath ({scheme, authority, device, absolute = _, path,
			       query, fragment}: url) =
	    {scheme = scheme, authority = authority, device = device,
	     absolute = true, path = path, query = query,
	     fragment = fragment}

	fun makeRelativePath ({scheme, authority, device, absolute = _, path,
			       query, fragment}: url) =
	    {scheme = scheme, authority = authority, device = device,
	     absolute = false, path = path, query = query,
	     fragment = fragment}

	fun setPath ({scheme, authority, device, absolute, path = _,
		      query, fragment}: url, path) =
	    {scheme = scheme, authority = authority, device = device,
	     absolute = absolute, path = path, query = query,
	     fragment = fragment}

	fun setQuery ({scheme, authority, device, absolute, path,
		       query = _, fragment}: url, query) =
	    (if isSome query then
		 case split isQuery (String.explode (valOf query)) of
		     (_, NONE, _) => ()
		   | (_, SOME _, _) => raise Malformed
	     else ();
	     {scheme = scheme, authority = authority, device = device,
	      absolute = absolute, path = path, query = query,
	      fragment = fragment})

	fun setFragment ({scheme, authority, device, absolute, path,
			  query, fragment = _}: url, fragment) =
	    {scheme = scheme, authority = authority, device = device,
	     absolute = absolute, path = path, query = query,
	     fragment = fragment}

	val empty =
	    {scheme = NONE, authority = NONE, device = NONE,
	     absolute = false, path = nil, query = NONE, fragment = NONE}

	(*
	 * This parser traverses the string only once and uses character
	 * sets to recognize the crucial characters that determine the
	 * breaking points in a url.
	 *
	 * This parser is a state machine, with 6 states, each of which is
	 * implemented by a procedure:
	 *
	 * parseStart		the initial state: what is at the front of the
	 *			url is disambiguated by the 1st separator we
	 *			find or the eos
	 * parseAuthority	entered when we encounter the // thing
	 * parsePathDev		recognize a device or the next path component
	 * parsePath		recognize the next path component
	 * parseQuery		after `?'
	 * parseFragment	after `#'
	 *)

	(*--** when we have the {url where absolute = true} syntax,
	 * this should be rewritten to not use state for simplicity
	 *)

	fun fromString s =
	    let
		val scheme: string option ref = ref NONE
		val authority: string option ref = ref NONE
		val device: char option ref = ref NONE
		val absolute = ref false
		val path: string list ref = ref nil
		val query: string option ref = ref NONE
		val fragment: string option ref = ref NONE

		fun pushPath s = path := String.implode (decode s)::(!path)

		fun parseStart cs =
		    case split isStart cs of
			(prefix, NONE, _) =>
			    (* hit the end without finding a separator *)
			    pushPath prefix
		      | ([c], SOME #":", suffix) =>
			    (* found the device separator *)
			    (device := SOME (toDevice c);
			     case suffix of
				 (#"/" | #"\\")::rest =>
				     (absolute := true; parsePath rest)
			       | _::_ => parsePathDev suffix
			       | nil => ())
		      | (prefix, SOME #":", suffix) =>
			    (* found the scheme separator *)
			    (scheme := SOME (toLower prefix);
			     (* check for //authority *)
			     case suffix of
				 (#"/" | #"\\")::(#"/" | #"\\")::rest =>
				     parseAuthority rest
			       | (#"/" | #"\\")::rest =>
				     (absolute := true; parsePath rest)
			       | _ => parsePathDev suffix)
		      | (nil, SOME (#"/" | #"\\"), (#"/" | #"\\")::rest) =>
			    (* found //authority at start *)
			    parseAuthority rest
		      | (nil, SOME (#"/" | #"\\"), suffix) =>
			    (* found absolute path at start *)
			    (absolute := true; parsePath suffix)
		      | (prefix, SOME (#"/" | #"\\"), suffix) =>
			    (pushPath prefix; parsePath suffix)
		      | (prefix, SOME #"?", suffix) =>
			    (case prefix of
				 _::_ => pushPath prefix
			       | nil => ();
			     parseQuery suffix)
		      | (prefix, SOME #"#", suffix) =>
			    (case prefix of
				 _::_ => pushPath prefix
			       | nil => ();
			     parseFragment suffix)
		      | (_, SOME _, _) =>
			    raise Crash "Url.fromString parseStart"
		and parseAuthority cs =
		    let
			val (prefix, sep, suffix) = split isPath cs
		    in
			authority := SOME (toLower prefix);
			case sep of
			    NONE => ()
			  | SOME (#"/" | #"\\") =>
				(absolute := true; parsePath suffix)
			  | SOME #"?" => parseQuery suffix
			  | SOME #"#" => parseFragment suffix
			  | SOME _ =>
				raise Crash "Url.fromString parseAuthority"
		    end
		and parsePathDev (c::(#":")::cr) =
		    (device := SOME (toDevice c); parsePath cr)
		  | parsePathDev cs = parsePath cs
		and parsePath cs =
		    let
			val (prefix, sep, suffix) = split isPath cs
		    in
			pushPath prefix;
			case sep of
			    NONE => ()
			  | SOME (#"/" | #"\\") => parsePath suffix
			  | SOME #"?" => parseQuery suffix
			  | SOME #"#" => parseFragment suffix
			  | SOME _ =>
				raise Crash "Url.fromString parsePath"
		    end
		and parseQuery cs =
		    let
			val (prefix, sep, suffix) = split isQuery cs
		    in
			query := SOME (String.implode prefix);
			case sep of
			    NONE => ()
			  | SOME #"#" => parseFragment suffix
			  | SOME _ =>
				raise Crash "Url.fromString parseQuery"
		    end
		and parseFragment cs = fragment := SOME (String.implode cs)
	    in
		parseStart (String.explode s);
		{scheme = !scheme,
		 authority = !authority,
		 device = !device,
		 absolute = !absolute,
		 path = normalizePath (List.rev (!path)),
		 query = !query,
		 fragment = !fragment}
	    end

	fun slashit nil = nil
	  | slashit (ss as "/"::_) = ss
	  | slashit ss = "/"::ss

	fun toString {scheme, authority, device, absolute, path,
		      query, fragment} =
	    let
		val l = if isSome fragment then ["#", valOf fragment] else nil
		val l = if isSome query then "?"::valOf query::l else l
		val l =
		    List.foldr (fn (s, rest) =>
				encode isPathChar s::slashit rest) nil path @ l
		val l = if absolute then slashit l else l
		val l =
		    if isSome device then String.str (valOf device)::":"::l
		    else l
		val l =
		    if isSome authority then
			"/"::"/"::valOf authority::slashit l
		    else l
		val l = if isSome scheme then valOf scheme::":"::l else l
	    in
		String.concat l
	    end

	fun isAbsolute ({scheme, device, absolute, path, ...}: url) =
	    isSome scheme orelse isSome device orelse absolute orelse
	    (case path of
		 ("." | "..")::_ => true
	       | ""::_ => false
	       | s::_ => String.sub (s, 0) = #"~"
	       | nil => false)

	exception Done of url

	(*--** use {rel where scheme = scheme} instead of setScheme *)

	fun atLast (nil, ss2) = ss2
	  | atLast (ss1, ss2) = List.revAppend (List.tl (List.rev ss1), ss2)

	fun resolve _ (rel as {scheme = SOME _, ...}) = rel
	  | resolve (base as {scheme, authority, device, ...}: url) rel =
	    let
		val rel =
		    if isSome scheme then setScheme (rel, scheme)
		    else rel
		val _ = if isSome (#authority rel) then raise Done rel else ()
		val rel =
		    if isSome authority then setAuthority (rel, authority)
		    else rel
		val _ = if isSome (#device rel) then raise Done rel else ()
		val rel =
		    if isSome device then setDevice (rel, device)
		    else rel
		val _ = if #absolute rel then raise Done rel else ()
		val rel =
		    if #absolute base then makeAbsolutePath rel
		    else rel
		val basePath = #path base
		val relPath =
		    case #path rel of
			nil => [""]
		      | (path as _::_) => path
	    in
		setPath (rel, normalizePath (atLast (basePath, relPath)))
	    end
	    handle Done url => url

	(*--**
	 * Check whether there may be cases where
	 *    URL.fromString s1 <> URL.fromString s2
	 * but
	 *    URL.compare (URL.fromString s1, URL.fromString s2) = EQUAL
	 * This must not happen!
	 *)

	fun compare (url1, url2) =
	    String.compare (toString url1, toString url2)

	fun hash url = StringHashKey.hash (toString url)
    end
(* src # 39 ../top/PHASE.sig *)
signature CONTEXT =
  sig
    type t
    (* val initial: unit -> t *)
    val clone:   t    -> t
  end

signature REPRESENTATION =
  sig
    type t
  end

signature PHASE =
  sig
    structure C: CONTEXT
    structure I: REPRESENTATION
    structure O: REPRESENTATION

    val translate: C.t -> I.t -> O.t   (* [Error.Error] *)
  end

signature PHASE_ERROR =
  sig
    type error		(* a datatype of possible errors *)
    type warning	(* a datatype of possible warnings *)

    val error:	Error.region * error -> 'a	(* format and print error *)
    val warn:	Error.region * warning -> unit	(* format and print warning *)
  end
(* src # 40 ../top/TARGET.sig *)
signature TARGET =
  sig
    structure C: CONTEXT

    type t

    val apply: C.t -> t -> unit
    val save: C.t -> string -> t -> unit
  end
(* src # 41 ../top/EmptyContext.sml *)
structure EmptyContext :> CONTEXT where type t = unit =
  struct
    type t = unit

    fun initial() = ()
    fun clone()   = ()
  end
(* src # 42 ../top/ENGINE.sig *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2000
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature CODE =
    sig
	type t

	val externalize: TextIO.outstream * t -> unit
    end

signature ENGINE =
    sig
	type t
	type code
	type value

	exception Format of string

	val start: unit -> t
	val stop: t -> unit

	val buildFunctor: t -> code -> value   (* Format *)
	val saveValue: t -> string -> value -> unit   (* Format *)

	val valueToString: value -> string
    end
(* src # 43 ../top/MakeEngine.sml *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2000
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

functor MakeEngine(val cmd: string
		   val args: string list
		   structure Code: CODE) :> ENGINE where type code = Code.t =
    struct
	type t = Unix.proc option ref
	type code = Code.t
	type value = int

	exception Format of string

	val valueToString = Int.toString

	fun start () = ref (SOME (Unix.execute (cmd, args)))

	fun instream proc = #1 (Unix.streamsOf (valOf (!proc)))
	fun outstream proc = #2 (Unix.streamsOf (valOf (!proc)))

	fun stop proc =
	    (TextIO.closeOut (outstream proc);
	     proc := NONE)

	datatype arg =
	    CODE of Code.t
	  | VALUE of value
	  | STRING of string

	fun sendCommand (proc, command, args) =
	    let
		val q = outstream proc
	    in
		TextIO.output (q, "Command: " ^ command ^ "\n");
		List.app (fn arg =>
			  (TextIO.output (q, "Argument: ");
			   case arg of
			       CODE code =>
				   Code.externalize (q, code)
			     | VALUE value =>
				   TextIO.output (q, valueToString value)
			     | STRING string =>
				   TextIO.output (q, string);
			   TextIO.output1 (q, #"\n"))) args;
		TextIO.output1 (q, #"\n");
		TextIO.flushOut q
	    end

	local
	    fun split (#":"::cs) = (nil, cs)
	      | split (c::cs) =
		let
		    val (name, value) = split cs
		in
		    (c::name, value)
		end
	      | split nil = raise Format "split: colon expected"
	in
	    fun parseResult proc =
		case TextIO.inputLine (instream proc) of
		    "\n" => nil
		  | s =>
			let
			    val (name, value) = split (String.explode s)
			in
			    (String.implode name, String.implode value)::
			    parseResult proc
			end
	end

	fun buildFunctor proc code =
	    (sendCommand (proc, "buildFunctor", [CODE code]);
	     case parseResult proc of
		    [("Result", s)] => valOf (Int.fromString s)
		  | _ => raise Format "buildFunctor: result expected")

	fun saveValue proc filename value =
	    (sendCommand (proc, "saveValue", [STRING filename, VALUE value]);
	     case parseResult proc of
		 [("Result", _)] => ()
	       | _ => raise Format "saveValue: result expected")
    end
(* src # 44 ../common/Stamp.sml *)
structure Stamp = MakeStamp()
(* src # 45 ../common/StampSet.sml *)
structure StampSet = MakeHashImpSet(Stamp)
(* src # 46 ../common/StampMap.sml *)
structure StampMap = MakeHashImpMap(Stamp)
(* src # 47 ../common/NAME.sig *)
signature NAME =
  sig

    datatype name = ExId of string | InId
    type t        = name

    val compare :	name * name -> order
    val hash :		name -> int
    val toString :	name -> string

  end
(* src # 48 ../common/Name.sml *)
structure Name :> NAME =
  struct

    datatype name = ExId of string | InId
    type     t    = name

    fun compare(ExId s1, ExId s2)	= String.compare(s1,s2)
      | compare(ExId _,  InId)		= GREATER
      | compare(InId,    ExId _)	= LESS
      | compare(InId,    InId)		= EQUAL

    fun hash(ExId s)			= StringHashKey.hash s
      | hash InId			= 0

    fun toString(ExId s)		= s
      | toString InId			= "?"

  end
(* src # 49 ../common/LABEL.sig *)
signature LABEL =
  sig

    eqtype lab					(* [lab,l] *)
    type t = lab


    (* Operations *)

    val fromString :	string -> lab
    val fromInt :	int    -> lab
    val fromName :	Name.t -> lab
    val toName :	lab    -> Name.t
    val toString :	lab    -> string
    val toInt :		lab    -> int option

    val compare :	lab * lab -> order
    val hash :		lab -> int

  end
(* src # 50 ../common/Label.sml *)
structure Label :> LABEL =
  struct

    datatype lab = NUM of int | ALPHA of string		(* [lab,l] *)

    type t   = lab


    (* Conversions *)

    fun fromInt n		= NUM n
    fun fromString s		= case Int.fromString s
				    of SOME n => NUM n
				     | NONE   => ALPHA s

    fun fromName(Name.ExId s)	= ALPHA s
      | fromName(Name.InId)	= ALPHA ""

    fun toName(ALPHA "")	= Name.InId
      | toName(ALPHA s)		= Name.ExId s
      | toName(NUM n)		= Name.ExId(Int.toString n)

    fun toString(NUM n)		= Int.toString n
      | toString(ALPHA s)	= s

    fun toInt(NUM n)		= SOME n
      | toInt(ALPHA s)		= NONE


    (* Ordering and hashing *)

    fun compare(NUM n1,   NUM n2)	= Int.compare(n1,n2)
      | compare(ALPHA s1, ALPHA s2)	= String.compare(s1,s2)
      | compare(NUM n1,   ALPHA s2)	= LESS
      | compare(ALPHA s1, NUM n2)	= GREATER

    fun hash(NUM n)			= n
      | hash(ALPHA s)			= StringHashKey.hash s

  end
(* src # 51 ../common/PATH.sig *)
(* Since SML allows multiple definitions of the same id in a structure,
   labels are not enough for paths. So we added an index. *)

signature PATH =
  sig

  (* Types *)

    type lab   = Label.t
    type name  = Name.t
    type url   = Url.t

    eqtype path
    type t = path

  (* Operations *)

    val invent :	unit -> path
    val fromLab :	lab  -> path
    val fromUrl :	url  -> path
    val toLab :		path -> lab
    val path :		path * lab * int -> path

    val compare :	path * path -> order
    val hash :		path -> int

    val isDot :		path -> bool
    val asDot :		path -> path * lab * int

    val strengthen :	path * (path * lab * int) -> unit

    val clone :		path -> path
    val instance :	('rea * path -> path option) -> 'rea * path -> path

  end
(* src # 52 ../common/Path.sml *)
(* Notes:
 * - Paths are shared, i.e. each path has to be unique.
 * - Since SML allows multiple definitions of the same id in a structure,
 *   labels are not enough for paths. So we added an index.
 *)

structure PathPrivate =
  struct

  (* Types *)

    type lab   = Label.t
    type name  = Name.t
    type url   = Url.t

    datatype path' =
	  PLAIN of name
	| URL   of url
	| DOT   of path * lab * int

    withtype path = path' ref
    type t = path


  (* Creation and projection *)

    fun invent()		= ref(PLAIN(Name.InId))
    fun fromLab l		= ref(PLAIN(Label.toName l))
    fun fromUrl url		= ref(URL url)
    fun path pln		= ref(DOT pln)

    fun toLab(ref(PLAIN n))	= Label.fromName n
      | toLab _			= raise Crash.Crash "Path.toLab"

    fun isDot(ref(DOT _))	= true
      | isDot _			= false

    fun asDot(ref(DOT pln))	= pln
      | asDot _			= raise Crash.Crash "Path.asDot"


  (* Ordering and hashing *)

    fun idx(PLAIN _)		= 0
      | idx(URL _)		= 1
      | idx(DOT _)		= 2

    fun compare(p1 as ref p1', p2 as ref p2')	= if p1 = p2 then EQUAL
						  else compare'(p1', p2')
    and compare'(PLAIN(x1),     PLAIN(x2))	= Name.compare(x1,x2)
      | compare'(URL(u1),       URL(u2))	= Url.compare(u1,u2)
      | compare'(DOT(p1,l1,n1), DOT(p2,l2,n2))	= (case compare(p1,p2)
						     of r as (LESS|GREATER) => r
						      | EQUAL =>
						   case Label.compare(l1,l2)
						     of r as (LESS|GREATER) => r
						      | EQUAL =>
						   Int.compare(n1,n2))
      | compare'(p1,            p2)		= Int.compare(idx p1, idx p2)

    fun hash(ref(PLAIN x))	= Name.hash x
      | hash(ref(URL u))	= Url.hash u
      | hash(ref(DOT(p,l,n)))	= Label.hash l


  (* Strengthening *)

    (* Strengthening has to be used carefully, as it results in a new
     * hash value, thereby invalidating eventual hash maps and sets! *)

    fun strengthen(p1, (p as ref(PLAIN _),l,n)) = p := DOT(p1,l,n)
      | strengthen _                            = ()


  (* Cloning *)

    fun instance lookup (rea, p) =
	let
	    fun clone p1 =
		case lookup(rea, p1)
		 of SOME p2 => p2
		  | NONE    =>
		case !p1
		 of p' as PLAIN _ => ref p'
		  | p' as URL _   => p1
		  | DOT(p,l,n)    => ref(DOT(clone p, l, n))
	in
	    clone p
	end

    fun clone p = instance (fn _ => NONE) ((), p)

  end


structure Path : (*DEBUG :>*) PATH = PathPrivate
(* src # 53 ../common/PathSet.sml *)
structure PathSet = MakeHashImpSet(Path)
(* src # 54 ../common/PathMap.sml *)
structure PathMap = MakeHashImpMap(Path)
(* src # 55 ../common/TYPE.sig *)
signature TYPE =
  sig

  (* Types *)

    datatype sort = OPEN | CLOSED
    datatype kind = STAR | ARROW of kind * kind		(* [kappa,k] *)

    type lab  = Label.t					(* [lab,l] *)
    type path = Path.t					(* [pi,p] *)
    type con  = kind * sort * path			(* [chi,c] *)

    type row						(* [rho,r] *)
    type var						(* [alpha,a] *)
    type typ						(* [tau,t] *)
    type t = typ

    type path_rea = path PathMap.t
    type typ_rea  = typ PathMap.t


  (* Injections *)

    val unknown :	kind      -> typ
    val inArrow :	typ * typ -> typ
    val inTuple :	typ list  -> typ
    val inProd :	row       -> typ
    val inSum :		row       -> typ
    val inVar :		var       -> typ
    val inCon :		con       -> typ
    val inAll :		var * typ -> typ
    val inExist :	var * typ -> typ
    val inLambda :	var * typ -> typ
    val inApply :	typ * typ -> typ
    val inMu :		typ       -> typ
    val inAbbrev :	typ * typ -> typ

    val var :		kind -> var

  (* Inquiries *)

    val isUnknown :	typ -> bool
    val isArrow :	typ -> bool
    val isTuple :	typ -> bool
    val isProd :	typ -> bool
    val isSum :		typ -> bool
    val isVar :		typ -> bool
    val isCon :		typ -> bool
    val isAll :		typ -> bool
    val isExist :	typ -> bool
    val isLambda :	typ -> bool
    val isApply :	typ -> bool
    val isMu :		typ -> bool
    val isAbbrev :	typ -> bool

  (* Projections *)

    exception Type

    val asArrow :	typ -> typ * typ		(* Type *)
    val asTuple :	typ -> typ list			(* Type *)
    val asProd :	typ -> row			(* Type *)
    val asSum :		typ -> row			(* Type *)
    val asVar :		typ -> var			(* Type *)
    val asCon :		typ -> con			(* Type *)
    val asAll :		typ -> var * typ		(* Type *)
    val asExist :	typ -> var * typ		(* Type *)
    val asLambda :	typ -> var * typ		(* Type *)
    val asApply :	typ -> typ * typ		(* Type *)
    val asMu :		typ -> typ			(* Type *)
    val asAbbrev : 	typ -> typ * typ		(* Type *)

  (* Complex extractions *)

    val kind :		typ -> kind
    val kindVar :	var -> kind

    val path :		typ -> path			(* Type *)
    val pathCon :	con -> path

    val paths :		typ -> PathSet.t

  (* Operations on rows *)

    exception Row

    val unknownRow :	unit -> row
    val emptyRow :	unit -> row
    val extendRow :	lab * typ list * row -> row	(* Row *)

    val openRowType :	typ -> unit			(* Row *)

    val isEmptyRow :	row -> bool
    val isUnknownRow :	row -> bool
    val headRow :	row -> lab * typ list		(* Row *)
    val tailRow :	row -> row			(* Row *)

  (* Copying and instantiation *)

    val instance :	typ -> typ
    val skolem :	typ -> typ
    val clone :		typ -> typ

    type clone_state
    val cloneStart :	unit -> clone_state
    val cloneCont :	clone_state -> typ -> typ
    val cloneFinish :	clone_state -> unit

    val realise :	typ_rea  * typ -> unit
    val realisePath :	path_rea * typ -> unit

  (* Unification and closure *)

    exception Unify of typ * typ
    exception UnifyList of int * typ * typ
    exception Intersect

    val unify :		typ * typ -> unit		(* Unify *)
    val unifyList :	typ list  -> unit		(* UnifyList *)
    val intersect :	typ * typ -> unit
    val close :		typ -> typ
    val isClosed :	typ -> bool

  (* Comparison *)

    val equals :	typ * typ -> bool
    val matches :	typ * typ -> bool

  (* Level management *)

    exception Lift of var

    val lift :		typ  -> unit			(* Lift *)
    val enterLevel :	unit -> unit
    val exitLevel :	unit -> unit
    val resetLevel :	unit -> unit

  end
(* src # 56 ../common/Type.sml *)
(*******************************************************************************
On Type Functions:

We evaluate type application lazily. Reduction is triggered on demand, i.e. by
unification or by inspection. Not all applications can be reduced (in
particular applications to abstract type constructors) so we deal with some
sort of head normal form.

We don't normally do eta-reduction, since it is expensive. During unification
eta reduction is not needed since lambdas may only show up there under very
restrictive circumstances anyway (see below). Eta-reduction is still needed
however for equals, to equate eta-convertible type functions. It's done on
demand.

On Sharing:

For efficiency reasons, we try to maximise sharing of type structures. This
reduces space cost and speeds up comparison and unification, as a simple
reference comparison often suffices. Not only unification but even the equality
test (used by module type checking) merges types silently whenever possible.

There are several cases where we have to clone a type:

* Type functions before reduction of type application.
* Type schemes (types with toplevel quantifiers) on instantiation.
* All sorts of types on signature instantiation.

For the first two it would be sufficient to only clone subgraphs containing the
variables bound by the lambdas/quantifiers; for the third we only would need to
clone subgraphs containing signature-local constructors. But since minimizing
cloning is difficult in the presence of cycles (we have recursive types) and
the pay-off is unclear, we currently don't do it.

It is very important to maintain sharing between subgraphs of different type
terms on signature instantiation. Not doing this can lead to a quadratic blowup
of type terms during module type checking, particularly desastrous in the
presence of structural datatypes. Therefor we need a special-and-ugly interface
for cloning a sequence of related types.

On Recursive Types:

Stockhausen makes datatypes structural sum types. This is a problem since
SML has non-uniform recursive datatypes. So in fact we not only get recursive
types but recursive type functions. It is not obvious whether type checking
remains decidable in the general case (in our current scheme with lazy
application unification might fail to terminate).

To stay on the safe side we treat recursive type functions specially:
applications to such functions are never reduced. That is, there is no implicit
unrolling of recursive types, mu is completely structural. For two recursive
types to be compatible they must therefor be constructed from equal type
functions. As a consequence, List(Int) and IntList will not be compatible in
the following example:

	List a  = Nil | Cons(a, List a)
	IntList = Nil | Cons(Int, IntList)

Maybe this can be made a bit more permissive, but in general it seems
impossible to have non-uniform datatypes as well as arbitrary recursive types.

It is also unclear to me whether some sort of hash-consing can be applied to
recursive types or even recursive type functions.

On Type Abbreviations:

We try to maintain type abbreviations to generate more user friendly output.
This is managed through a special node ABBREV, which refers to the original
type term as well as to the reduced/substituted one.

*******************************************************************************)

structure TypePrivate =
  struct

  (* Types *)

    datatype sort = OPEN | CLOSED
    datatype kind = STAR | ARROW of kind * kind		(* [kappa,k] *)

    type lab  = Label.t					(* [lab,l] *)
    type path = Path.t					(* [pi,p] *)
    type con  = kind * sort * path			(* [chi,c] *)

    datatype typ' =					(* [tau',t'] *)
	  HOLE   of kind * int	(* variable for inference *)
	| LINK   of typ		(* forward (needed for unification) *)
	| MARK   of typ'	(* for traversal *)
	| FUN    of typ * typ	(* arrow type *)
	| TUPLE  of typ list	(* tuple *)
	| PROD   of row		(* record *)
	| SUM    of row		(* sum type (datatype) *)
	| VAR    of kind * int	(* bound variable or skolem types *)
	| CON    of con		(* constructor (of arbitrary kind) *)
	| ALL    of var * typ	(* universal quantification *)
	| EXIST  of var * typ	(* existential quantification *)
	| LAMBDA of var * typ	(* abstraction (type function) *)
	| APPLY  of typ * typ	(* application *)
	| MU     of typ		(* recursive type barrier *)
	| ABBREV of typ * typ	(* abbreviations *)

    and row =						(* [rho,r] *)
	  NIL
	| RHO   of int ref * row
	| FIELD of lab * typ list * row

    withtype typ = typ' ref				(* [tau,t] *)
    and      var = typ' ref				(* [alpha,a] *)

    type t = typ

    type path_rea = path PathMap.t
    type typ_rea  = typ PathMap.t

    (*
     * We establish the following invariants:
     * - rows are sorted by label, rho variables appear as head only
     * - types are always in head normal form
     * - sequential quantifiers are ordered such that the bound variables
     *   appear in depth-first leftmost traversal order inside the body
     *)


(*DEBUG*)
    fun pr(FUN _)	= "ARROW"
      | pr(TUPLE _)	= "TUPLE"
      | pr(PROD _)	= "PROD"
      | pr(SUM _)	= "SUM"
      | pr(CON _)	= "CON"
      | pr(VAR _)	= "VAR"
      | pr(ALL _)	= "ALL"
      | pr(EXIST _)	= "EXIST"
      | pr(LAMBDA _)	= "LAMBDA"
      | pr(APPLY _)	= "APPLY"
      | pr(MU _)	= "MU"
      | pr(LINK _)	= "LINK"
      | pr(MARK _)	= "MARK"
      | pr(HOLE _)	= "HOLE"
      | pr(ABBREV _)	= "ABBREV"


  (* Level management *)

    val globalLevel	= 0
    val level		= ref(globalLevel+1)

    fun enterLevel()	= level := !level+1
    fun exitLevel()	= level := !level-1
    fun resetLevel()	= level := 1


  (* Follow a path of links (performing path compression on the fly) *)

    fun follow(ref(LINK t))	= follow t
      | follow t		= t

(*DEBUG
    fun follow'(ref(LINK t))	= follow' t
      | follow' t		= t

    fun follow(t as ref(LINK u))= let val v = follow' u in t := LINK v ; v end
      | follow t		= t
*)


  (* Kind inference *)

    fun rangeKind(ARROW(k1,k2))	= k2
      | rangeKind  _		= raise Crash.Crash "Type.rangeKind: \
						    \kind mismatch"

    fun kind(ref t')		= kind' t'

    and kind'(LINK t | MU t)	= kind t
      | kind'(ABBREV(_,t))	= kind t
      | kind'(HOLE(k,_))	= k
      | kind'(VAR(k,_))		= k
      | kind'(CON(k,_,_))	= k
      | kind'(LAMBDA(a,t))	= ARROW(kind a, kind t)
      | kind'(APPLY(t1,t2))	= rangeKind(kind t1)
      | kind'(MARK t')		= kind' t'
      | kind' _			= STAR

    val kindVar			= kind


  (* Type graph traversal *)

    fun app1'(( HOLE _
	      | VAR _
	      | CON _ ), f)		= ()
      | app1'(( LINK t
	      | MU t
	      | ALL(_,t)
	      | EXIST(_,t)
	      | LAMBDA(_,t)), f)	= f t
      | app1'(( FUN(t1,t2)
	      | APPLY(t1,t2)
	      | ABBREV(t1,t2)), f)	= ( f t1 ; f t2 )
      | app1'(( TUPLE ts ), f)		= List.app f ts
      | app1'(( PROD r
	      | SUM r ), f)		= appRow(r,f)
      | app1'(( MARK _ ), f)		= raise Crash.Crash "Type.app: MARK"

    and appRow(FIELD(_,ts,r), f)	= ( List.app f ts ; appRow(r,f) )
      | appRow(RHO(_,r), f)		= appRow(r,f)
      | appRow(NIL, f)			= ()


    fun foldl1'(( HOLE _
		| VAR _
		| CON _ ), f, a)	= a
      | foldl1'(( LINK t
		| MU t
		| ALL(_,t)
		| EXIST(_,t)
		| LAMBDA(_,t)), f, a)	= f(t,a)
      | foldl1'(( FUN(t1,t2)
		| APPLY(t1,t2)
		| ABBREV(t1,t2)), f, a)	= f(t2, f(t1,a))
      | foldl1'(( TUPLE ts ), f, a)	= List.foldl f a ts
      | foldl1'(( PROD r
		| SUM r ), f, a)	= foldlRow(r,f,a)
      | foldl1'(( MARK _ ), f, a)	= raise Crash.Crash "Type.foldl: MARK"

    and foldlRow(FIELD(_,ts,r), f, a)	= foldlRow(r, f, List.foldl f a ts)
      | foldlRow(RHO(_,r), f, a)	= foldlRow(r, f, a)
      | foldlRow(NIL, f, a)		= a


    fun unmark(t as ref(MARK t')) 	=
(*ASSERT				  assert t' of non MARK _ => *)
( case t' of MARK _ => raise Assert.failure | _ =>
					  ( t := t' ; app1'(t', unmark) )
)
      | unmark _	            	= ()


    fun app f t =
	let
	    fun app(ref(MARK _)) = ()
	      | app t =
		let
		    val _  = f t
		    val t' = !t
		    val _  = t := MARK t'
		in
		    app1'(t',app)
		end
	in
	    app t before unmark t handle e => ( unmark t ; raise e )
	end

    fun foldl f a t =
	let
	    fun fold(ref(MARK _), a) = a
	      | fold(t, a) =
		let
		    val a' = f(t,a)
		    val t' = !t
		    val _  = t := MARK t'
		in
		    foldl1'(t',fold,a')
		end
	in
	    fold(t,a) before unmark t handle e => ( unmark t ; raise e )
	end


  (* Cloning *)

    fun clone t =
	let
	    (* We want to be able to handle recursive types, so we have to
	     * implement graph copying here.
	     *)

	    val trail = ref []

	    fun dup'(t1 as ref t1') =
		let
		    val _   = trail := (t1,t1') :: !trail
		    val t2  = ref(MARK t1')
		    val _   = t1 := LINK t2
		in
		    t2
		end

	    fun dup(t1 as ref t1') =
		let
		    val _   = trail := (t1,t1') :: !trail
		    val t2  = ref(MARK t1')
		    val _   = t1 := LINK t2
		    val t2' = MARK(clone' t1')
		    val _   = t2 := t2'
		in
		    t2
		end

	    and clone t1 =
		let val t11 = follow t1 in
		    case !t11 of (MARK _ | VAR _ | HOLE _) => t11
			       | t11'                      => dup t11
		end

	    and clone'(FUN(t1,t2))	= FUN(clone t1, clone t2)
	      | clone'(TUPLE ts)	= TUPLE(List.map clone ts)
	      | clone'(PROD r)		= PROD(cloneRow r)
	      | clone'(SUM r)		= SUM(cloneRow r)
	      | clone'(CON c)		= CON c
	      | clone'(ALL(a,t))	= ALL(dup' a, clone t)
	      | clone'(EXIST(a,t))	= EXIST(dup' a, clone t)
	      | clone'(LAMBDA(a,t))	= LAMBDA(dup' a, clone t)
	      | clone'(APPLY(t1,t2))	= APPLY(clone t1, clone t2)
	      | clone'(MU t)		= MU(clone t)
	      | clone'(ABBREV(t1,t2))	= ABBREV(clone t1, clone t2)
	      | clone' _		= raise Crash.Crash "Type.clone"

	    and cloneRow(FIELD(l,ts,r))	= FIELD(l,List.map clone ts, cloneRow r)
	      | cloneRow(RHO(n,r))	= RHO(ref(!n), cloneRow r)
	      | cloneRow(NIL)		= NIL

	    val t2 = clone t
	in
	    List.app op:= (!trail) ;
	    unmark t2 ;
	    t2
	end


  (* Continuous cloning *)

    type clone_state = { trail: (typ * typ') list ref, typs: typ list ref }

    fun cloneStart() = {trail = ref [], typs = ref []}
    fun cloneFinish{trail,typs} = 
	( List.app op:= (!trail)
	; List.app unmark (!typs)
	)

    fun cloneCont {trail,typs} t =
	let
	    fun dup'(t1 as ref t1') =
		let
		    val _   = trail := (t1,t1') :: !trail
		    val t2  = ref(MARK t1')
		    val _   = t1 := LINK t2
		in
		    t2
		end

	    fun dup(t1 as ref t1') =
		let
		    val _   = trail := (t1,t1') :: !trail
		    val t2  = ref(MARK t1')
		    val _   = t1 := LINK t2
		    val t2' = MARK(clone' t1')
		    val _   = t2 := t2'
		in
		    t2
		end

	    and clone t1 =
		let val t11 = follow t1 in
		    case !t11 of (MARK _ | VAR _ | HOLE _) => t11
			       | t11'                      => dup t11
		end

	    and clone'(FUN(t1,t2))	= FUN(clone t1, clone t2)
	      | clone'(TUPLE ts)	= TUPLE(List.map clone ts)
	      | clone'(PROD r)		= PROD(cloneRow r)
	      | clone'(SUM r)		= SUM(cloneRow r)
	      | clone'(CON c)		= CON c
	      | clone'(ALL(a,t))	= ALL(dup' a, clone t)
	      | clone'(EXIST(a,t))	= EXIST(dup' a, clone t)
	      | clone'(LAMBDA(a,t))	= LAMBDA(dup' a, clone t)
	      | clone'(APPLY(t1,t2))	= APPLY(clone t1, clone t2)
	      | clone'(MU t)		= MU(clone t)
	      | clone'(ABBREV(t1,t2))	= ABBREV(clone t1, clone t2)
	      | clone' _		= raise Crash.Crash "Type.clone"

	    and cloneRow(FIELD(l,ts,r))	= FIELD(l,List.map clone ts, cloneRow r)
	      | cloneRow(RHO(n,r))	= RHO(ref(!n), cloneRow r)
	      | cloneRow(NIL)		= NIL

	    val t2 = clone t
	in
	    typs := t2 :: !typs ;
	    t2
	end


  (* Occur check (not used by unification) *)

    exception Occurs

    fun occurs(t1,t2) =
	let
	    fun occurs t = if t1 = t then raise Occurs else ()
	in
	    ( app occurs t2 ; false ) handle Occurs => true
	end


  (* Reduction to head normal form *)

    (*UNFINISHED: avoid multiple cloning of curried lambdas somehow *)

    fun reduce(t as ref(APPLY(t1,t2))) =
	let
	    fun reduceApply(t1 as ref(LAMBDA(a,_)), to) =
		( t := HOLE(kind a, !level)
		; case !(clone t1)
		    of LAMBDA(a,t11) =>
			( a := LINK t2
			; t := (case to
				  of NONE   => LINK t11
				   | SOME t => ABBREV(ref(APPLY(t,t2)), t11) )
			; reduce t
			)
		    | _ => raise Crash.Crash "Type.reduceApply"
		)
	      | reduceApply(ref(LINK t11), to) =
		    reduceApply(follow t11, to)

	      | reduceApply(ref(ABBREV(t11,t12)), to) =
		    reduceApply(follow t12, SOME(Option.getOpt(to,t11)))
	      (*
	      | reduceApply(ref(MU t11), to) =
		    reduceApply(follow t11, to)
	      *)
	      | reduceApply _ = ()
	in
	    reduceApply(t1, NONE)
	end

      | reduce(ref(LINK t | ABBREV(_,t))) = reduce t

      | reduce _ = ()


    (*
     * We don't normally do eta-reduction, since it is expensive.
     * During unification we curently allow no lambdas anyway.
     * Eta-reduction is still needed however for equals, to equate
     * eta-convertible type functions. It's done on demand.
     *)

    fun reduceEta(t as ref(LAMBDA _)) =
	let
	    fun reduceLambda(ref(LAMBDA(a,t1)), vs) =
		reduceLambda(t1, a::vs)

	      | reduceLambda(ref(APPLY(t1,t2)), a::vs) =
		let
		    val t2' = follow t2
		    val a'  = follow a
		in
		    if t2' = a' andalso not(occurs(a',t1)) then
			reduceLambda(t1, vs)
		    else
			()
		end

	      | reduceLambda(t1, []) =
		    ( t := LINK t1 ; reduceEta t1 )

	      | reduceLambda(ref(LINK t1), vs) =
		    reduceLambda(t1, vs)

	      | reduceLambda(ref(ABBREV(t1,t2)), vs) =
		    reduceLambda(t2, vs)

	      | reduceLambda _ = ()
	in
	    reduceLambda(t, [])
	end

      | reduceEta(ref(LINK t)) = reduceEta t

      | reduceEta _ = ()


  (* Creation and injections *)

    fun unknown' k	= HOLE(k, !level)
    fun unknown k	= ref(unknown' k)

    fun inArrow tt	= ref(FUN tt)
    fun inTuple ts	= ref(TUPLE ts)
    fun inProd r	= ref(PROD r)
    fun inSum r		= ref(SUM r)
    fun inVar a		= a
    fun inCon c		= ref(CON c)
    fun inAll at	= ref(ALL at)
    fun inExist at	= ref(EXIST at)
    fun inLambda at	= ref(LAMBDA at)
    fun inApply(t1,t2)	= let val t = ref(APPLY(t1,t2)) in reduce t ; t end
    fun inMu t		= ref(MU t)
    fun inAbbrev(t1,t2)	= ref(ABBREV(t1,t2))

    fun var k		= ref(VAR(k, !level))


  (* Projections and extractions *)

    exception Type

    fun asType(ref(LINK t))		= asType t
      | asType(ref(ABBREV(_,t)))	= asType t
      | asType(ref t')			= t'

    fun isUnknown t	= case asType t of HOLE _   => true | _ => false
    fun isArrow t	= case asType t of FUN _    => true | _ => false
    fun isTuple t	= case asType t of TUPLE _  => true | _ => false
    fun isProd t	= case asType t of PROD _   => true | _ => false
    fun isSum t		= case asType t of SUM _    => true | _ => false
    fun isVar t		= case asType t of VAR _    => true | _ => false
    fun isCon t		= case asType t of CON _    => true | _ => false
    fun isAll t		= case asType t of ALL _    => true | _ => false
    fun isExist t	= case asType t of EXIST _  => true | _ => false
    fun isLambda t	= case asType t of LAMBDA _ => true | _ => false
    fun isApply t	= case asType t of APPLY _  => true | _ => false
    fun isMu t		= case asType t of MU _     => true | _ => false

    fun asArrow t	= case asType t of FUN tt    => tt | _ => raise Type
    fun asTuple t	= case asType t of TUPLE ts  => ts | _ => raise Type
    fun asProd t	= case asType t of PROD r    => r  | _ => raise Type
    fun asSum t		= case asType t of SUM r     => r  | _ => raise Type
    fun asVar t		= case asType t of VAR _     => t  | _ => raise Type
    fun asCon t		= case asType t of CON c     => c  | _ => raise Type
    fun asAll t		= case asType t of ALL at    => at | _ => raise Type
    fun asExist t	= case asType t of EXIST at  => at | _ => raise Type
    fun asLambda t	= case asType t of LAMBDA at => at | _ => raise Type
    fun asApply t	= case asType t of APPLY tt  => tt | _ => raise Type
    fun asMu t		= case asType t of MU t      => t  | _ => raise Type

    fun isAbbrev t	= case !(follow t) of ABBREV _  => true | _ => false
    fun asAbbrev t	= case !(follow t) of ABBREV tt => tt | _ => raise Type

    fun pathCon(_,_,p)	= p
    fun path t		= pathCon(asCon t)

(*
    fun holes t = foldl (fn(t as ref(HOLE _), a) => t::a | (t,a) => a) t
    fun paths t = foldl (fn(t as ref(CON c), a) => pathCon(c)::a | (t,a) => a) t
*)

    fun paths t =
    	let
	    val s = PathSet.new()
	in
	    app (fn(ref(CON c)) => PathSet.insert(s, pathCon c) | _ => ()) t ;
	    s
	end


    exception Unclosed

    fun checkClosedRow(RHO _)		= raise Unclosed
      | checkClosedRow _		= ()

    fun checkClosed'(HOLE _)		= raise Unclosed
      | checkClosed'(PROD r | SUM r)	= checkClosedRow r
      | checkClosed' _			= ()

    fun isClosed t =
	( app (fn t as ref t' => checkClosed' t'
	handle Unclosed =>
(*DEBUG*)
	( print(case !t of HOLE _ => "Hummm...\n" | _ => "Haehh?\n")
	; t := CON(STAR,CLOSED,Path.fromLab(Label.fromString "'_ouch"))
	; raise Unclosed
	)
	) t ; true )
(*	( app (fn ref t' => checkClosed' t') t ; true )*)
	handle Unclosed => false


  (* Instantiation *)

    (* Instantiate universally quantified types, skolemise
     * existentially qualified types. If there is any quantification,
     * then we have to copy the type.
     * Skolemisation does it the other way round (needed for checking rank 2
     * signature applications and existential types).
     *)

    (*ASSUME that no quantifiers appear under abbreviations
   	(this might break with higher-order polymorphism!) *)

    fun instance'(ref(ALL(a,t)))	= ( a := unknown'(kind a); instance' t )
      | instance'(ref(EXIST(a,t)))	= instance' t
      | instance' t			= t

    fun instance(t as ref(ALL _| EXIST _))	= instance'(clone t)
      | instance(ref(LINK t))			= instance t
      | instance t				= t

    fun skolem'(ref(ALL(a,t)))		= skolem' t
      | skolem'(ref(EXIST(a,t)))	= ( a := unknown' STAR ; skolem' t )
      | skolem' t			= t

    fun skolem(t as ref(ALL _| EXIST _))	= skolem'(clone t)
      | skolem(ref(LINK t))			= skolem t
      | skolem t				= t



  (* Operations on rows *)

    exception Row

    fun unknownRow()	= RHO(ref(!level), NIL)
    fun emptyRow()	= NIL

    fun extendRow(l,ts, NIL)      = FIELD(l,ts,NIL)
      | extendRow(l,ts, RHO(n,r)) = RHO(n, extendRow(l,ts,r))
      | extendRow(l1,ts1, r1 as FIELD(l2,ts2,r2)) =
	case Label.compare(l1,l2)
	  of EQUAL   => raise Row
	   | LESS    => FIELD(l1, ts1, r1)
	   | GREATER => FIELD(l2, ts2, extendRow(l1,ts1,r2))

    fun tupToRow ts =
	let
	    fun loop(n,  []  ) = NIL
	      | loop(n, t::ts) = FIELD(Label.fromInt n, [t], loop(n+1,ts))
	in
	    loop(1,ts)
	end

    fun openRow(r as RHO _)		= r
      | openRow r			= RHO(ref(!level), r)

    fun openRowType(ref(LINK t))	= openRowType t
      | openRowType(t as ref(PROD r))	= t := PROD(openRow r)
      | openRowType(t as ref(SUM r))	= t := SUM(openRow r)
      | openRowType _			= raise Row


    fun isEmptyRow(NIL | RHO _)		= true
      | isEmptyRow _			= false

    fun isUnknownRow(RHO _)		= true
      | isUnknownRow _			= false

    fun headRow(FIELD(l,ts,r))		= (l,ts)
      | headRow(RHO(_,r))		= headRow r
      | headRow(NIL)			= raise Row

    fun tailRow(FIELD(l,ts,r))		= r
      | tailRow(RHO(n,r))		= RHO(n, tailRow r)
      | tailRow(NIL)			= raise Row


  (* Closure *)

    fun close t =
    	let
	    fun close(a as ref(HOLE(k,n)), f) =
		if n > !level then
		    ( a := VAR(k,n) ; fn t => f(inAll(a,t)) )
		else f

	      | close(a as ref(VAR(k,n)), f) =
		(* UNFINISHED: rethink this *)
		(* We have to quantify over VARs as well.
		 * The reason is that there may be several types being
		 * closed that share parts of their graphs.
		 * Note that this means we have to take care to choose
		 * a unique upper level when we use VAR for skolem types.
		 *)
		if n > !level then
		    fn t => f(inAll(a,t))
		else f

	      | close(ref(ALL(a,t) | EXIST(a,t) | LAMBDA(a,t)), f) =
		( a := MARK(!a) ; f )	(* bit of a hack... *)

	      | close(t as ref(PROD r), f) = ( t := PROD(closeRow r) ; f )
	      | close(t as ref(SUM r), f)  = ( t := SUM(closeRow r) ; f )

	      | close(_, f) = f

	    and closeRow(r as RHO(n,r')) = if !n > !level then r' else r
	      | closeRow r               = r
	in
	    foldl close (fn t => t) t t
	end


  (* Lifting a type to the current level *)

    exception Lift of var

    fun lift t =
	let
	    fun lift(t as ref(t' as HOLE(k,n))) =
		    if n > !level then t := HOLE(k,!level) else ()
	      | lift(t as ref(VAR(k,n))) =
		    if n > !level then raise Lift t else ()
	      | lift(ref(PROD r | SUM r)) = liftRow r
	      | lift(ref(LAMBDA(a,_) | ALL(a,_) | EXIST(a,_))) =
(*ASSERT	    assert isVar a =>*)
if not(isVar a) then raise Assert.failure else
		    a := VAR(kindVar a, globalLevel)
	      | lift t = ()
	in
	    app lift t
	end

    and liftRow(RHO(n,r))	= if !n > !level then n := !level else ()
      | liftRow _		= ()


  (* Unification *)

    exception Unify of typ * typ


    fun liftAndCheck(n,t1,t2) =
	let
	    fun lift(t as ref(t' as HOLE(k,n'))) =
		    t := MARK(if n' <= n then t' else HOLE(k,n))
	      | lift(ref(MARK _)) = ()
	      | lift(t as ref(t' as (PROD r | SUM r))) =
		    ( liftRow r ; t := MARK t' ; app1'(t', lift) )
	      | lift(t as ref t') = ( t := MARK t' ; app1'(t', lift) )

	    and liftRow(RHO(n',r)) = if !n' > n then n' := n else ()
	      | liftRow _          = ()

	    fun check(t as ref t') =
		if t1 = t then
		    ( unmark t2 ; raise Unify(t1,t2) )
		else case t'
		  of HOLE(k,n') => t := MARK(if n' <= n then t' else HOLE(k,n))
		   | MARK _     => ()
		   | MU _       => ( t := MARK t' ; app1'(t', lift) )
		   | _          => ( t := MARK t' ; app1'(t', check) )
	in
	    check t2 ; unmark t2
	end


    fun unify(t1,t2) =
	let
	    val trail = ref []

	    fun unify(t1,t2) =
		let
		    val t1 as ref t1' = follow t1
		    val t2 as ref t2' = follow t2

		    fun recur f x =
			( t1 := LINK t2
			; trail := (t1,t1') :: !trail
			; f x
			)

		    fun recurBinder(a1 as ref a1', a2, t1, t2) =
			( a1 := LINK a2
			; trail := (a1,a1') :: !trail
			; recur unify (t1,t2)
			)
		in
		    if t1 = t2 then () else
		    case (t1',t2')
		      of (HOLE(k1,n1), HOLE(k2,n2)) =>
(*ASSERT		 assert k1 = k2 =>*)
if k1 <> k2 then raise Assert.failure else
			 if n1 < n2 then t2 := LINK t1
				    else t1 := LINK t2

		       | (HOLE(k1,n), _) =>
(*ASSERT		 assert k1 = kind' t2' =>*)
if k1 <> kind' t2' then raise Assert.failure else
			 ( liftAndCheck(n,t1,t2) ; t1 := LINK t2 )

		       | (_, HOLE(k2,n)) =>
(*ASSERT		 assert kind' t1' = k2 =>*)
if kind' t1' <> k2 then raise Assert.failure else
			 ( liftAndCheck(n,t2,t1) ; t2 := LINK t1 )

		       | (MU(t11), MU(t21)) =>
			 recur unify (t11,t21)
		       (*
		       | (MU(t11), _) =>
			 ( t2 := MU(ref t2') ; unify(t1,t2) )

		       | (_, MU(t21)) =>
			 ( t1 := MU(ref t1') ; unify(t1,t2) )
		       *)
		       | (FUN(tt1), FUN(tt2)) =>
			 recur unifyPair (tt1,tt2)

		       | (TUPLE(ts1), TUPLE(ts2)) =>
			 recur (ListPair.app unify) (ts1,ts2)

		       | (TUPLE(ts), PROD(r)) =>
			 recur unifyRow (t1, t2, tupToRow ts, r, PROD)

		       | (PROD(r), TUPLE(ts)) =>
			 recur unifyRow (t1, t2, r, tupToRow ts, PROD)

		       | (PROD(r1), PROD(r2)) =>
			 recur unifyRow (t1, t2, r1, r2, PROD)

		       | (SUM(r1), SUM(r2)) =>
			 recur unifyRow (t1, t2, r1, r2, SUM)

		       | (CON(_,_,p1), CON(_,_,p2)) =>
			 if p1 = p2 then t1 := LINK t2
				    else raise Unify(t1,t2)

		       | (APPLY(tt1), APPLY(tt2)) =>
			 (* Note that we do not allow general lambdas during
			  * unification, so application is considered to be
			  * in normal form. *)
			 recur unifyPair (tt1,tt2)

		       | (LAMBDA(a1,t11), LAMBDA(a2,t21)) =>
			 (* The only place lambdas might occur during
			  * unification is below mu. The type functions
			  * must be equal in that case. *)
			 recurBinder(a1, a2, t11, t21)

		       | (ALL(a1,t11), ALL(a2,t21)) =>
			 raise Crash.Crash "Type.unify: universal quantifier"

		       | (EXIST(a1,t11), EXIST(a2,t21)) =>
			 raise Crash.Crash "Type.unify: existential quantifier"

		       | (ABBREV(t11,t12), _) =>
			 unify (t12,t2)

		       | (_, ABBREV(t21,t22)) =>
			 unify (t1,t22)

		       | _ => raise Unify(t1,t2)
		end

	    and unifyPair((t11,t12), (t21,t22)) =
		( unify(t11,t21) ; unify(t12,t22) )

	    and unifyRow(t1, t2, r1, r2, PRODorSUM) =
		let
(*DEBUG
val timer = Timer.startRealTimer()
*)
		    fun loop(RHO(n1,r1), _,  RHO(n2,r2), _ ) =
			    RHO(ref(Int.min(!n1, !n2)), loop(r1,true, r2,true))
		      | loop(RHO(_,r1), _, r2, _) =
			    loop(r1, true, r2, false)
		      | loop(r1, _, RHO(_,r2), _) =
			    loop(r1, false, r2, true)
		      | loop(NIL, _, NIL, _) =
			    NIL
		      | loop(NIL, true, FIELD(l,ts,r2'), b2) =
			    FIELD(l,ts, loop(NIL, true, r2', b2))
		      | loop(FIELD(l,ts,r1'), b1, NIL, true) =
			    FIELD(l,ts, loop(r1', b1, NIL, true))
		      | loop(r1 as FIELD(l1,ts1,r1'), b1,
			     r2 as FIELD(l2,ts2,r2'), b2) =
			(case Label.compare(l1,l2)
			   of EQUAL   => ( ListPair.app unify (ts1,ts2)
					 ; FIELD(l1,ts1, loop(r1',b1, r2',b2)) )
			    | LESS    => if not b2 then raise Unify(t1,t2) else
					 FIELD(l1,ts1, loop(r1',b1, r2,b2))
			    | GREATER => if not b1 then raise Unify(t1,t2) else
					 FIELD(l2,ts2, loop(r1,b1, r2',b2))
			)
		      | loop _ = raise Unify(t1,t2)
		in
		    t2 := PRODorSUM(loop(r1, false, r2, false))
(*DEBUG*)
(*before let val ms = LargeInt.toInt(Time.toMilliseconds(Timer.checkRealTimer timer)) in
print("Row unification took "^Int.toString ms^"ms\n")
before ignore(TextIO.inputLine(TextIO.stdIn))
end*)
		end
	in
	    unify(t1,t2)
	    handle Unify tt => ( List.app op:= (!trail) ; raise Unify tt )
	end


  (* Unification of lists *)

    exception UnifyList of int * typ * typ

    fun unifyList  []    = ()
      | unifyList(t::ts) = 
	let
	    fun loop(n,   []   ) = ()
	      | loop(n, t'::ts') =
	        ( unify(t,t')
		  handle Unify(t1,t2) => raise UnifyList(n,t1,t2)
		; loop(n+1, ts')
		)
	in
	    loop(0,ts)
	end


  (* Matching *)

    fun matches(t1,t2) =
	let
	    val t1' = instance t1
	    val t2' = skolem t2
	in
	    ( unify(t1',t2') ; true ) handle Unify _ => false
	end


  (* Comparison *)

    (* To maximise sharing, links are kept after comparison iff the
     * types are equal. If the types are not equal, all updates are
     * undone. This could be optimized by keeping equal subtrees.
     *)

    fun equals(t1,t2) =
	let
	    val trail = ref []

	    fun equals(t1,t2) =
		let
		    val t1 as ref t1' = follow t1
		    val t2 as ref t2' = follow t2

		    fun recur p x =
			( t1 := LINK t2
			; trail := (t1,!t1) :: !trail
			; p x
			)

		    fun recurBinder(a1 as ref a1', a2, t1, t2) =
			( a1 := LINK a2
			; trail := (a1,a1') :: !trail
			; recur equals (t1,t2)
			)
		in
		    t1 = t2 orelse
		    case (t1',t2')
		      of (MU(t11), MU(t21)) =>
			 recur equals (t11,t21)
		       (*
		       | (MU(t11), _) =>
			 recur equals (t11,t2)

		       | (_, MU(t21)) =>
			 recur equals (t1,t21)
		       *)
		       | (FUN(tt1), FUN(tt2)) =>
			 recur equalsPair (tt1,tt2)

		       | (TUPLE(ts1), TUPLE(ts2)) =>
			 recur (ListPair.all equals) (ts1,ts2)

		       | ( (TUPLE(ts), PROD(r))
			 | (PROD(r),   TUPLE(ts)) ) =>
			 recur equalsRow (r, tupToRow ts)

		       | ( (PROD(r1), PROD(r2))
			 | (SUM(r1),  SUM(r2)) ) =>
			 recur equalsRow (r1,r2)

		       | (CON(_,_,p1), CON(_,_,p2)) =>
			 p1 = p2

		       | (APPLY(tt1), APPLY(tt2)) =>
			 recur equalsPair (tt1,tt2)

		       | ( (LAMBDA _, _) | (_, LAMBDA _) ) =>
			 ( reduceEta t1
			 ; reduceEta t2
			 ; case (!t1,!t2)
			     of (LAMBDA(a1,t11), LAMBDA(a2,t21)) =>
				recurBinder(a1, a2, t11, t21)
			      | ( (LAMBDA _, _) | (_, LAMBDA _) ) => false
			      | _ => equals(t1,t2)
			 )
		       | ( (ALL(a1,t11),   ALL(a2,t21))
			 | (EXIST(a1,t11), EXIST(a2,t21)) ) =>
			 recurBinder(a1, a2, t11, t21)

		       | (ABBREV(t11,t12), _) =>
			 equals (t12,t2)

		       | (_, ABBREV(t21,t22)) =>
			 equals (t1,t22)

		       | _ => false
		end

	    and equalsPair((t11,t12), (t21,t22)) =
		equals(t11,t21) andalso equals (t12,t22)

(*DEBUG
and equalsRow rr =
let
val timer = Timer.startRealTimer()
fun f() = ()
*)
	    and equalsRow(NIL,              NIL)              = true
	      | equalsRow(RHO(_,r1),        RHO(_,r2))        = equalsRow(r1,r2)
	      | equalsRow(FIELD(l1,ts1,r1), FIELD(l2,ts2,r2)) =
		l1 = l2 andalso ListPair.all equals (ts1,ts2)
			andalso equalsRow(r1,r2)
	      | equalsRow _ = false
(*in
equalsRow rr
before let val ms = LargeInt.toInt(Time.toMilliseconds(Timer.checkRealTimer timer)) in
print("Row equality took "^Int.toString ms^"ms\n")
before ignore(TextIO.inputLine(TextIO.stdIn))
end
end
*)
	in
	    equals(t1,t2) orelse ( List.app op:= (!trail) ; false )
	end


  (* Realisation *)

    fun realisePath(rea, t) =
	let
	    fun subst(t1 as ref(CON(k,s,p))) =
		( case PathMap.lookup(rea, p)
		    of SOME p' => t1 := CON(k,s,p')
		     | NONE    => ()
		)
	      | subst t1 = ()
	in
	    app subst t
	end

    (*
     * Realisations need not be idempotent (fully expanded). Would be nice
     * to have this property because it would make substitution more efficient,
     * but full expansion is difficult to achieve for the intersect function).
     *)

    fun realise(rea, t) =
	let
	    val apps = ref[]

	    fun subst(t1 as ref(CON(k,s,p))) =
		(case PathMap.lookup(rea, p)
		   of SOME t2 => t1 := LINK t2		(* expand *)
					(*UNFINISHED: do we have to clone t2? *)
		    | NONE    => ()
		)
	      | subst(t1 as ref(APPLY _)) = apps := t1::(!apps)
	      | subst t1 = ()
	in
	    app subst t ; List.app reduce (!apps)
	end


  (* Intersection *)

    exception Intersect

    fun intersect(t1,t2) = ()
    (* UNFINISHED *)

  end


structure Type : (*DEBUG :>*) TYPE = TypePrivate
(* src # 57 ../common/PP_PATH.sig *)
signature PP_PATH =
  sig

    type doc  = PrettyPrint.doc
    type path = Path.t

    val ppPath : path -> doc

  end
(* src # 58 ../common/PPPath.sml *)
structure PPPath :> PP_PATH =
  struct

    (* Import *)

    open PathPrivate
    open PrettyPrint
    open PPMisc

    infixr ^^ ^/^


    fun ppName n		= text(Name.toString n)
    fun ppLab l			= text(Label.toString l)

    fun ppHiddenLab(0,l)	= ppLab l
      | ppHiddenLab(i,l)	= text "?" ^^ ppHiddenLab(i-1, l)

    fun ppPath(ref(PLAIN n))	= ppName n
      | ppPath(ref(URL _))	= raise Crash.Crash "PPPath.ppPath: URL path"
      | ppPath(ref(DOT(p,l,i)))	= (case !p of URL _ => text ""
					    | _     => ppPath p ^^ text ".")
				  ^^ ppHiddenLab(i, l)

  end
(* src # 59 ../common/PP_TYPE.sig *)
signature PP_TYPE =
  sig

    type doc  = PrettyPrint.doc
    type typ  = Type.typ
    type kind = Type.kind

    val ppTyp :		typ -> doc
    val ppKind :	kind -> doc

  end
(* src # 60 ../common/PPType.sml *)
structure PPType :> PP_TYPE =
  struct

    (* Import *)

    open TypePrivate
    open PrettyPrint
    open PPMisc

    infixr ^^ ^/^


    (* Helpers *)

    fun uncurry(ref(APPLY(t1,t2)))	= let val (t,ts) = uncurry t1
					  in (t,ts@[t2]) end
      | uncurry(ref(ABBREV(t1,t2)))	= uncurry t1
      | uncurry t			= (t,[])

    fun parenPrec p (p',doc) =
	if p > p' then
	    paren doc
	else
	    doc


    (* Simple objects *)

    fun ppLab l		= text(Label.toString l)
    fun ppCon (k,_,p)	= PPPath.ppPath p

    fun varToString(isBound, n) =
	let
	    fun rep(0,c) = c
	      | rep(n,c) = c ^ rep(n-1,c)

	    val c = String.str(Char.chr(Char.ord #"a" + n mod 26))
	in
	    (if isBound then "'" else "'_") ^ rep(n div 26, c)
	end


    (* Kinds *)

    (* Precedence:
     *	0 : arrow (ty1 -> ty2)
     *	1 : star
     *)

    fun ppKind k = fbox(below(ppKindPrec 0 k))

    and ppKindPrec p  STAR		= text "*"
      | ppKindPrec p (ARROW(k1,k2))	= 
	let
	    val doc = ppKindPrec 1 k1 ^/^ text "->" ^/^ ppKindPrec 0 k2
	in
	    parenPrec p (0, doc)
	end


    (* Types *)

    (* Precedence:
     *  0 : sums (con of ty1 | ... | con of tyn), kind annotation (ty : kind)
     *	1 : binders (LAMBDA ty1 . ty2)
     *	2 : function arrow (ty1 -> ty2)
     *	3 : tuple (ty1 * ... * tyn)
     *	4 : constructed type (tyseq tycon)
     *)

    fun ppTyp t =
	let
	    val trail = ref []
	    val a     = ref 0

	    fun makeVar(isBound, t as ref t') =
		let
		    val k = kindVar t
		    val s = varToString(isBound, !a before a := !a+1)
		    val c = (k, CLOSED, Path.fromLab(Label.fromString s))
		    val _ = t := CON c
		    val _ = if isBound then () else trail := (t,t')::(!trail)
		in
		    t'
		end

	    fun ppTyp t = fbox(below(ppTypPrec 0 t))

	    and ppTypPrec p (t as ref(HOLE(k,n))) =
		let
		    val t'  = makeVar(false, t)
		    val doc = ppTypPrec' p (!t)
		in
		    if k = STAR then
			doc
(*DEBUG*)
^^ text("_" ^ Int.toString n)
		    else
			parenPrec p (0, doc ^/^ text ":" ^/^ ppKind k)

		end

	      | ppTypPrec p (t as ref(MU t1 | MARK(MU t1))) =
(*DEBUG*)
((*print("[pp " ^ pr(!t) ^ "]");*)
(*		if occurs(t,t1) then
*)		    let
(*val _=print"recursive\n"
*)			val t'  = makeVar(true, t)
			val doc = (case t' of MARK _ => text "!MU"
					    | _      => text "MU") ^/^
				  abox(
					hbox(
					    ppTyp t ^/^
					    text "."
					) ^^
					below(break ^^
					    ppTypPrec 1 t1
					)
				  )
			val _   = t := t'
		    in
			parenPrec p (1, fbox(below(nest(doc))))
		    end
(*		else
(*(print"not recursive\n";*)
		    ppTypPrec p t1
*))

	      | ppTypPrec p (t as ref(APPLY _)) =
	        ( reduce t ;
(*print("[pp APPLY]");*)
		  if isApply t then ppTypPrec' p (!t)
			       else ppTypPrec p t
		)

	      | ppTypPrec p (ref t') = ppTypPrec' p t'
(*(*DEBUG*)
	      | ppTypPrec p (t as ref t') =
let
val _=print("[pp " ^ pr t' ^ "]")
(*val _=TextIO.inputLine TextIO.stdIn*)
in
	if foldl1'(t', fn(t1,b) => b orelse occursIllegally(t,t1), false) then
		    let
(*DEBUG*)
val _=print"RECURSIVE!\n"
			val a'  = makeVar(true, t)
			val doc = text "MU" ^/^
				    abox(
					hbox(
					    ppTyp t ^/^
					    text "."
					) ^^
					below(break ^^
					    ppTypPrec' 1 t'
					)
				    )
			val _   = t := a'
		    in
			parenPrec p (1, fbox(below(nest(doc))))
		    end
		else
		    ppTypPrec' p t'
end
*)

	    and ppTypPrec' p (LINK t) =
(*DEBUG
text "@" ^^*)
		    ppTypPrec p t

	      | ppTypPrec' p (ABBREV(t1,t2)) =
		    ppTypPrec p t1

	      | ppTypPrec' p (MARK t') =
		    text "!" ^^ ppTypPrec' p t'

	      | ppTypPrec' p (FUN(t1,t2)) =
		let
		    val doc = ppTypPrec 3 t1 ^/^ text "->" ^/^ ppTypPrec 2 t2
		in
		    parenPrec p (2, doc)
		end

	      | ppTypPrec' p (TUPLE [] | PROD NIL) =
		    text "unit"

	      | ppTypPrec' p (TUPLE ts) =
		let
		    val doc = ppStarList (ppTypPrec 4) ts
		in
		    parenPrec p (3, fbox(below(nest doc)))
		end

	      | ppTypPrec' p (PROD r) =
		    brace(fbox(below(ppProd r)))

	      | ppTypPrec' p (SUM r) =
		    paren(fbox(below(ppSum r)))

	      | ppTypPrec' p (VAR(k,n)) =
		if k = STAR then
		    text "'?"
(*DEBUG*)
^^ text("[" ^ Int.toString n ^ "]")
		else
		    paren (text "'?" ^/^ text ":" ^/^ ppKind k)

	      | ppTypPrec' p (CON c) =
		    ppCon c

	      | ppTypPrec' p (ALL(a,t)) =
		let
		    val doc = ppBinder("ALL",a,t)
		in
		    parenPrec p (1, fbox(below doc))
		end

	      | ppTypPrec' p (EXIST(a,t)) =
		let
		    val doc = ppBinder("EX",a,t)
		in
		    parenPrec p (1, fbox(below doc))
		end

	      | ppTypPrec' p (LAMBDA(a,t)) =
		let
		    val doc = ppBinder("FN",a,t)
		in
		    parenPrec p (1, fbox(below doc))
		end

	      | ppTypPrec' p (t' as APPLY _) =
		let
		    val (t,ts) = uncurry(ref t')
		in
		    fbox(nest(ppSeqPrec ppTypPrec 4 ts ^/^ ppTypPrec 5 t))
		end

	      | ppTypPrec' p (HOLE _) =
		    raise Crash.Crash "PPType.ppTyp: bypassed HOLE"

	      | ppTypPrec' p (MU _) =
		    raise Crash.Crash "PPType.ppTyp: bypassed MU"


	    and ppProd NIL		= empty
	      | ppProd(RHO _)		= text "..."
	      | ppProd(FIELD(l,ts,NIL))	= ppField(l,ts)
	      | ppProd(FIELD(l,ts,r))	= ppField(l,ts) ^^ text "," ^/^ ppProd r

	    and ppSum NIL		= empty
	      | ppSum(RHO _)		= text "..."
	      | ppSum(FIELD(l,ts,NIL))	= ppField(l,ts)
	      | ppSum(FIELD(l,ts,r))	= ppField(l,ts) ^/^ text "|" ^/^ ppSum r

	    and ppField(l,[]) = ppLab l
	      | ppField(l,ts) =
		    abox(
			hbox(
			    ppLab l ^/^
			    text ":"
			) ^^
			below(break ^^
			    ppCommaList ppTyp ts
			)
		    )

	    and ppBinder(s,a,t) =
		let
		    val a' = makeVar(true, a)
		in
		    abox(
			hbox(
			    text s ^/^
			    ppTyp a ^/^
(*DEBUG*)
(*text"(" ^^ ppTypPrec' 0 a' ^^ text")" ^/^*)
			    text "."
			) ^^
			nest(break ^^
			    ppTyp t
			)
		    )
		    before a := a'
		end
	in
	    ppTyp t before List.app op:= (!trail)
	end

  end
(* src # 61 ../common/INTERMEDIATE_GRAMMAR.sig *)
signature INTERMEDIATE_GRAMMAR =
  sig

    (* Generic *)

    type lab_info
    type id_info
    type longid_info
    type exp_info
    type pat_info
    type 'a field_info
    type match_info
    type dec_info

    type sign

    (* Literals *)

    datatype lit =
	  WordLit   of LargeWord.word		(* modulo arithmetic *)
	| IntLit    of LargeInt.int		(* integer arithmetic *)
	| CharLit   of WideChar.char		(* character *)
	| StringLit of WideString.string	(* character string *)
(*	| RealLit   of LargeReal.real		(* floating point *)
UNFINISHED: obsolete after bootstrapping:
*)	| RealLit   of string			(* floating point *)

    (* Identifiers *)

    datatype lab    = Lab     of lab_info * Label.t
    datatype id     = Id      of id_info * Stamp.t * Name.t
    datatype longid = ShortId of longid_info * id
		    | LongId  of longid_info * longid * lab

    (* Expressions *)

    datatype exp =
	  LitExp    of exp_info * lit			(* literal *)
	| PrimExp   of exp_info * string		(* primitive value *)
	| NewExp    of exp_info * bool			(* new constructor *)
				(* bool : is n-ary *)
	| VarExp    of exp_info * longid		(* variable *)
	| TagExp    of exp_info * lab * bool		(* sum injector *)
				(* bool : is n-ary *)
	| ConExp    of exp_info * longid * bool		(* constructor *)
				(* bool : is n-ary *)
	| RefExp    of exp_info				(* reference *)
	| TupExp    of exp_info * exp list		(* tuple *)
	| RowExp    of exp_info * exp field list	(* record / module *)
			(* all labels distinct *)
	| SelExp    of exp_info * lab			(* field selector *)
	| VecExp    of exp_info * exp list		(* vector *)
	| FunExp    of exp_info * match list		(* function / functor *)
	| AppExp    of exp_info * exp * exp		(* application *)
	| AdjExp    of exp_info * exp * exp		(* record adjunction *)
	| UpExp     of exp_info * exp			(* up cast *)
	| AndExp    of exp_info * exp * exp		(* conjunction *)
	| OrExp     of exp_info * exp * exp		(* disjunction *)
	| IfExp     of exp_info * exp * exp * exp	(* conditional *)
	| WhileExp  of exp_info * exp * exp		(* conditional loop *)
	| SeqExp    of exp_info * exp list		(* sequential *)
	| CaseExp   of exp_info * exp * match list	(* case switch *)
	| RaiseExp  of exp_info * exp			(* exception raise *)
	| HandleExp of exp_info * exp * match list	(* exception handler *)
	| LetExp    of exp_info * dec list * exp	(* local binding *)

    and 'a field = Field of 'a field_info * lab * 'a

    and match    = Match of match_info * pat * exp

    (* Patterns (always linear) *)

    and pat =
	  WildPat   of pat_info				(* wildcard *)
	| LitPat    of pat_info * lit			(* literal *)
	| VarPat    of pat_info * id			(* variable *)
	| TagPat    of pat_info * lab * bool		(* sum injector *)
			(* bool : is n-ary, appears only fully applied *)
	| ConPat    of pat_info * longid * bool		(* constructed *)
			(* bool : is n-ary, appears only fully applied *)
	| RefPat    of pat_info				(* reference *)
	| TupPat    of pat_info * pat list		(* tuple *)
	| RowPat    of pat_info * pat field list	(* record *)
			(* all labels distinct *)
	| VecPat    of pat_info * pat list		(* vector *)
	| AppPat    of pat_info * pat * pat		(* construction *)
			(* first must be ConPat or RefPat *)
	| AsPat     of pat_info * pat * pat		(* conjunction *)
	| AltPat    of pat_info * pat list		(* disjunction *)
			(* all patterns bind same ids *)
	| NegPat    of pat_info * pat			(* negation *)
	| GuardPat  of pat_info * pat * exp		(* guard *)
	| WithPat   of pat_info * pat * dec list	(* local bindings *)

    (* Declarations *)

    and dec =
	  ValDec    of dec_info * pat * exp		(* value / module *)
	  		(* if inside RecDec, then
			 * (1) pat may not contain AltPat, NegPat, GuardPat,
			 *     WithPat
			 * (2) exp may only contain LitExp, VarExp, ConExp,
			 *     RefExp, TupExp, RowExp, VecExp, FunExp, AppExp
			 * (3) AppExps may only contain ConExp or RefExp
			 *     as first argument
			 * (4) if an VarPat on the LHS structurally corresponds
			 *     to an VarExp on the RHS then the RHS id may not
			 *     be bound on the LHS *)
	| RecDec    of dec_info * dec list		(* recursion *)

    (* Components *)

    type comp = (id * sign * Url.t) list * (exp * sign)
    type t = comp


    (* Operations *)

    val stamp :		id	-> Stamp.t
    val name :		id	-> Name.t
    val lab :		lab	-> Label.t

    val infoLab :	lab	-> lab_info
    val infoId :	id	-> id_info
    val infoLongid :	longid	-> longid_info
    val infoExp :	exp	-> exp_info
    val infoField :	'a field -> 'a field_info
    val infoMatch :	match	-> match_info
    val infoPat :	pat	-> pat_info
    val infoDec :	dec	-> dec_info

  end
(* src # 62 ../common/MakeIntermediateGrammar.sml *)
functor MakeIntermediateGrammar(type lab_info
				type id_info
				type longid_info
				type exp_info
				type pat_info
				type 'a field_info
				type match_info
				type dec_info
				type sign) : INTERMEDIATE_GRAMMAR =
  struct

    (* Generic *)

    type lab_info	= lab_info
    type id_info	= id_info
    type longid_info	= longid_info
    type exp_info	= exp_info
    type pat_info	= pat_info
    type 'a field_info	= 'a field_info
    type match_info	= match_info
    type dec_info	= dec_info

    type sign		= sign

    (* Literals *)

    datatype lit =
	  WordLit   of LargeWord.word		(* modulo arithmetic *)
	| IntLit    of LargeInt.int		(* integer arithmetic *)
	| CharLit   of WideChar.char		(* character *)
	| StringLit of WideString.string	(* character string *)
(*	| RealLit   of LargeReal.real		(* floating point *)
UNFINISHED: obsolete after bootstrapping:
*)	| RealLit   of string			(* floating point *)

    (* Identifiers *)

    datatype lab    = Lab     of lab_info * Label.t
    datatype id     = Id      of id_info * Stamp.t * Name.t
    datatype longid = ShortId of longid_info * id
		    | LongId  of longid_info * longid * lab

    (* Expressions *)

    datatype exp =
	  LitExp    of exp_info * lit			(* literal *)
	| PrimExp   of exp_info * string		(* primitive value *)
	| NewExp    of exp_info * bool			(* new constructor *)
				(* bool : is n-ary *)
	| VarExp    of exp_info * longid		(* variable *)
	| TagExp    of exp_info * lab * bool		(* sum injector *)
	| ConExp    of exp_info * longid * bool		(* constructor *)
				(* bool : is n-ary *)
	| RefExp    of exp_info				(* reference *)
	| TupExp    of exp_info * exp list		(* tuple *)
	| RowExp    of exp_info * exp field list	(* record / module *)
			(* all labels distinct *)
	| SelExp    of exp_info * lab			(* field selector *)
	| VecExp    of exp_info * exp list		(* vector *)
	| FunExp    of exp_info * match list		(* function / functor *)
	| AppExp    of exp_info * exp * exp		(* application *)
	| AdjExp    of exp_info * exp * exp		(* record adjunction *)
	| UpExp     of exp_info * exp			(* up cast *)
	| AndExp    of exp_info * exp * exp		(* conjunction *)
	| OrExp     of exp_info * exp * exp		(* disjunction *)
	| IfExp     of exp_info * exp * exp * exp	(* conditional *)
	| WhileExp  of exp_info * exp * exp		(* conditional loop *)
	| SeqExp    of exp_info * exp list		(* sequential *)
	| CaseExp   of exp_info * exp * match list	(* case switch *)
	| RaiseExp  of exp_info * exp			(* exception raise *)
	| HandleExp of exp_info * exp * match list	(* exception handler *)
	| LetExp    of exp_info * dec list * exp	(* local binding *)

    and 'a field = Field of 'a field_info * lab * 'a

    and match    = Match of match_info * pat * exp

    (* Patterns (always linear) *)

    and pat =
	  WildPat   of pat_info				(* wildcard *)
	| LitPat    of pat_info * lit			(* literal *)
	| VarPat    of pat_info * id			(* variable *)
	| TagPat    of pat_info * lab * bool		(* sum injector *)
			(* bool : is n-ary, appears only fully applied *)
	| ConPat    of pat_info * longid * bool		(* constructed *)
			(* bool : is n-ary, appears only fully applied *)
	| RefPat    of pat_info				(* reference *)
	| TupPat    of pat_info * pat list		(* tuple *)
	| RowPat    of pat_info * pat field list	(* record *)
			(* all labels distinct *)
	| VecPat    of pat_info * pat list		(* vector *)
	| AppPat    of pat_info * pat * pat		(* construction *)
			(* first must be ConPat or RefPat *)
	| AsPat     of pat_info * pat * pat		(* conjunction *)
	| AltPat    of pat_info * pat list		(* disjunction *)
			(* all patterns bind same ids *)
	| NegPat    of pat_info * pat			(* negation *)
	| GuardPat  of pat_info * pat * exp		(* guard *)
	| WithPat   of pat_info * pat * dec list	(* local bindings *)

    (* Declarations *)

    and dec =
	  ValDec    of dec_info * pat * exp		(* value / module *)
	  		(* if inside RecDec, then
			 * (1) pat may not contain AltPat, NegPat, GuardPat,
			 *     WithPat
			 * (2) exp may only contain LitExp, VarExp, ConExp,
			 *     RefExp, TupExp, RowExp, VecExp, FunExp, AppExp
			 * (3) AppExps may only contain ConExp or RefExp
			 *     as first argument
			 * (4) if an VarPat on the LHS structurally corresponds
			 *     to an VarExp on the RHS then the RHS id may not
			 *     be bound on the LHS *)
	| RecDec    of dec_info * dec list		(* recursion *)

    (* Components *)

    type comp = (id * sign * Url.t) list * (exp * sign)
    type t = comp


    (* Projections *)

    fun stamp(Id(_,x,_))		= x
    fun name(Id(_,_,n))			= n
    fun lab(Lab(_,a))			= a

    fun infoLab(Lab(i,_))		= i
    fun infoId(Id(i,_,_))		= i
    fun infoLongid(ShortId(i,_))	= i
      | infoLongid(LongId(i,_,_))	= i

    fun infoExp(LitExp(i,_))		= i
      | infoExp(PrimExp(i,_))		= i
      | infoExp(NewExp(i,_))		= i
      | infoExp(VarExp(i,_))		= i
      | infoExp(TagExp(i,_,_))		= i
      | infoExp(ConExp(i,_,_))		= i
      | infoExp(RefExp(i))		= i
      | infoExp(TupExp(i,_))		= i
      | infoExp(RowExp(i,_))		= i
      | infoExp(SelExp(i,_))		= i
      | infoExp(VecExp(i,_))		= i
      | infoExp(FunExp(i,_))		= i
      | infoExp(AppExp(i,_,_))		= i
      | infoExp(AdjExp(i,_,_))		= i
      | infoExp(UpExp(i,_))		= i
      | infoExp(AndExp(i,_,_))		= i
      | infoExp(OrExp(i,_,_))		= i
      | infoExp(IfExp(i,_,_,_))		= i
      | infoExp(WhileExp(i,_,_))	= i
      | infoExp(SeqExp(i,_))		= i
      | infoExp(CaseExp(i,_,_))		= i
      | infoExp(RaiseExp(i,_))		= i
      | infoExp(HandleExp(i,_,_))	= i
      | infoExp(LetExp(i,_,_))		= i

    fun infoField(Field(i,_,_))		= i
    fun infoMatch(Match(i,_,_))		= i

    fun infoPat(WildPat(i))		= i
      | infoPat(LitPat(i,_))		= i
      | infoPat(VarPat(i,_))		= i
      | infoPat(TagPat(i,_,_))		= i
      | infoPat(ConPat(i,_,_))		= i
      | infoPat(RefPat(i))		= i
      | infoPat(TupPat(i,_))		= i
      | infoPat(RowPat(i,_))		= i
      | infoPat(VecPat(i,_))		= i
      | infoPat(AppPat(i,_,_))		= i
      | infoPat(AsPat(i,_,_))		= i
      | infoPat(AltPat(i,_))		= i
      | infoPat(NegPat(i,_))		= i
      | infoPat(GuardPat(i,_,_))	= i
      | infoPat(WithPat(i,_,_))		= i

    fun infoDec(ValDec(i,_,_))		= i
      | infoDec(RecDec(i,_))		= i

  end
(* src # 63 ../common/IntermediateGrammar.sml *)
structure IntermediateInfo =
  struct
    type lab_info	= { region: Source.region }
    type id_info	= { region: Source.region }
    type longid_info	= { region: Source.region }
    type exp_info	= { region: Source.region, typ: Type.t }
    type pat_info	= { region: Source.region, typ: Type.t }
    type 'a field_info	= { region: Source.region }
    type match_info	= { region: Source.region }
    type dec_info	= { region: Source.region }
  end

structure IntermediateGrammar = MakeIntermediateGrammar(open IntermediateInfo
							type sign = unit)
(* src # 64 ../common/PREBOUND.sig *)
signature PREBOUND =
  sig

    type name  = Name.t
    type stamp = Stamp.t
    type path  = Path.t

    val valname_false :		name
    val valname_true :		name
    val valname_nil :		name
    val valname_cons :		name
    val valname_ref :		name
    val valname_match :		name
    val valname_bind :		name

    val typname_bool :		name
    val typname_int :		name
    val typname_word :		name
    val typname_real :		name
    val typname_string :	name
    val typname_char :		name
    val typname_list :		name
    val typname_vec :		name
    val typname_ref :		name
    val typname_exn :		name

    val valstamp_false :	stamp
    val valstamp_true :		stamp
    val valstamp_nil :		stamp
    val valstamp_cons :		stamp
    val valstamp_ref :		stamp
    val valstamp_match :	stamp
    val valstamp_bind :		stamp

    val typstamp_bool :		stamp
    val typstamp_int :		stamp
    val typstamp_word :		stamp
    val typstamp_real :		stamp
    val typstamp_string :	stamp
    val typstamp_char :		stamp
    val typstamp_list :		stamp
    val typstamp_vec :		stamp
    val typstamp_ref :		stamp
    val typstamp_exn :		stamp

    val valpath_false :		path
    val valpath_true :		path
    val valpath_nil :		path
    val valpath_cons :		path
    val valpath_ref :		path
    val valpath_match :		path
    val valpath_bind :		path

    val typpath_bool :		path
    val typpath_int :		path
    val typpath_word :		path
    val typpath_real :		path
    val typpath_string :	path
    val typpath_char :		path
    val typpath_list :		path
    val typpath_vec :		path
    val typpath_ref :		path
    val typpath_exn :		path

  end
(* src # 65 ../common/MakePrebound.sml *)
functor MakePrebound(val valid_false :	string
		     val valid_true :	string
		     val valid_nil :	string
		     val valid_cons :	string
		     val valid_ref :	string
		     val valid_match :	string
		     val valid_bind :	string
		     val typid_bool :	string
		     val typid_int :	string
		     val typid_word :	string
		     val typid_real :	string
		     val typid_string :	string
		     val typid_char :	string
		     val typid_list :	string
		     val typid_vec :	string
		     val typid_ref :	string
		     val typid_exn :	string
		    ) :> PREBOUND =
  struct

    type name  = Name.t
    type stamp = Stamp.t
    type path  = Path.t

    val valname_false	= Name.ExId valid_false
    val valname_true	= Name.ExId valid_true
    val valname_nil	= Name.ExId valid_nil
    val valname_cons	= Name.ExId valid_cons
    val valname_ref	= Name.ExId valid_ref
    val valname_match	= Name.ExId valid_match
    val valname_bind	= Name.ExId valid_bind

    val typname_bool	= Name.ExId typid_bool
    val typname_int	= Name.ExId typid_int
    val typname_word	= Name.ExId typid_word
    val typname_real	= Name.ExId typid_real
    val typname_string	= Name.ExId typid_string
    val typname_char	= Name.ExId typid_char
    val typname_list	= Name.ExId typid_list
    val typname_vec	= Name.ExId typid_vec
    val typname_ref	= Name.ExId typid_ref
    val typname_exn	= Name.ExId typid_exn

    val valstamp_false	= Stamp.new()
    val valstamp_true	= Stamp.new()
    val valstamp_nil	= Stamp.new()
    val valstamp_cons	= Stamp.new()
    val valstamp_ref	= Stamp.new()
    val valstamp_match	= Stamp.new()
    val valstamp_bind	= Stamp.new()

    val typstamp_bool	= Stamp.new()
    val typstamp_int	= Stamp.new()
    val typstamp_word	= Stamp.new()
    val typstamp_real	= Stamp.new()
    val typstamp_string	= Stamp.new()
    val typstamp_char	= Stamp.new()
    val typstamp_list	= Stamp.new()
    val typstamp_vec	= Stamp.new()
    val typstamp_ref	= Stamp.new()
    val typstamp_exn	= Stamp.new()

    val valpath_false	= Path.fromLab(Label.fromName valname_false)
    val valpath_true	= Path.fromLab(Label.fromName valname_true)
    val valpath_nil	= Path.fromLab(Label.fromName valname_nil)
    val valpath_cons	= Path.fromLab(Label.fromName valname_cons)
    val valpath_ref	= Path.fromLab(Label.fromName valname_ref)
    val valpath_match	= Path.fromLab(Label.fromName valname_match)
    val valpath_bind	= Path.fromLab(Label.fromName valname_bind)

    val typpath_int	= Path.fromLab(Label.fromName typname_int)
    val typpath_word	= Path.fromLab(Label.fromName typname_word)
    val typpath_char	= Path.fromLab(Label.fromName typname_char)
    val typpath_string	= Path.fromLab(Label.fromName typname_string)
    val typpath_real	= Path.fromLab(Label.fromName typname_real)
    val typpath_bool	= Path.fromLab(Label.fromName typname_bool)
    val typpath_exn	= Path.fromLab(Label.fromName typname_exn)
    val typpath_ref	= Path.fromLab(Label.fromName typname_ref)
    val typpath_vec	= Path.fromLab(Label.fromName typname_vec)
    val typpath_list	= Path.fromLab(Label.fromName typname_list)

  end
(* src # 66 ../common/Prebound.sml *)
structure Prebound = MakePrebound(val valid_false	= "false"
				  val valid_true	= "true"
				  val valid_nil		= "nil"
				  val valid_cons	= "::"
				  val valid_ref		= "ref"
				  val valid_match	= "Match"
				  val valid_bind	= "Bind"

				  val typid_bool	= "bool"
				  val typid_int		= "int"
				  val typid_word	= "word"
				  val typid_real	= "real"
				  val typid_string	= "string"
				  val typid_char	= "char"
				  val typid_list	= "list"
				  val typid_vec		= "vector"
				  val typid_ref		= "ref"
				  val typid_exn		= "exn"
				 )
(* src # 67 ../common/PREBOUND_TYPE.sig *)
signature PREBOUND_TYPE =
  sig

    type path = Path.t
    type con  = Type.con
    type typ  = Type.typ

    val path_bool :		path (* = Prebound.typpath_bool *)
    val path_int :		path (* = Prebound.typpath_int *)
    val path_word :		path (* = Prebound.typpath_word *)
    val path_real :		path (* = Prebound.typpath_real *)
    val path_string :		path (* = Prebound.typpath_string *)
    val path_char :		path (* = Prebound.typpath_char *)
    val path_list :		path (* = Prebound.typpath_list *)
    val path_vec :		path (* = Prebound.typpath_vec *)
    val path_ref :		path (* = Prebound.typpath_ref *)
    val path_exn :		path (* = Prebound.typpath_exn *)

    val con_int :		con
    val con_word :		con
    val con_real :		con
    val con_string :		con
    val con_char :		con
    val con_vec :		con
    val con_ref :		con
    val con_exn :		con

    val typ_unit :		typ
    val typ_bool :		typ
    val typ_int :		typ
    val typ_word :		typ
    val typ_real :		typ
    val typ_string :		typ
    val typ_char :		typ
    val typ_list :		typ
    val typ_vec :		typ
    val typ_ref :		typ
    val typ_exn :		typ

  end
(* src # 68 ../common/PreboundType.sml *)
structure PreboundType :> PREBOUND_TYPE =
  struct

    type path		= Path.t
    type con		= Type.con
    type typ		= Type.typ

    datatype kind	= datatype Type.kind
    datatype sort	= datatype Type.sort

    val path_bool	= Prebound.typpath_bool
    val path_int	= Prebound.typpath_int
    val path_word	= Prebound.typpath_word
    val path_real	= Prebound.typpath_real
    val path_string	= Prebound.typpath_string
    val path_char	= Prebound.typpath_char
    val path_list	= Prebound.typpath_list
    val path_vec	= Prebound.typpath_vec
    val path_ref	= Prebound.typpath_ref
    val path_exn	= Prebound.typpath_exn

    val con_bool	= (STAR, CLOSED, path_bool)
    val con_word	= (STAR, CLOSED, path_word)
    val con_int		= (STAR, CLOSED, path_int)
    val con_char	= (STAR, CLOSED, path_char)
    val con_string	= (STAR, CLOSED, path_string)
    val con_real	= (STAR, CLOSED, path_real)
    val con_exn		= (STAR, CLOSED, path_exn)
    val con_list	= (ARROW(STAR,STAR), CLOSED, path_list)
    val con_vec		= (ARROW(STAR,STAR), CLOSED, path_vec)
    val con_ref		= (ARROW(STAR,STAR), CLOSED, path_ref)

    val lab_false	= Label.fromName(Prebound.valname_false)
    val lab_true	= Label.fromName(Prebound.valname_true)
    val lab_nil		= Label.fromName(Prebound.valname_nil)
    val lab_cons	= Label.fromName(Prebound.valname_cons)

    val typ_list	= Type.unknown(ARROW(STAR,STAR))
    val var_list	= Type.var STAR
    val typ_var		= Type.inVar var_list
    val typ_cons	= Type.inTuple [typ_var, Type.inApply(typ_list,typ_var)]

    val row_unit	= Type.emptyRow()
    val row_bool	= Type.extendRow(lab_false, [],
			  Type.extendRow(lab_true, [], Type.emptyRow()))
    val row_list	= Type.extendRow(lab_cons, [typ_cons],
			  Type.extendRow(lab_nil, [], Type.emptyRow()))

    val typ_unit	= Type.inProd row_unit
    val typ_int		= Type.inCon con_int
    val typ_word	= Type.inCon con_word
    val typ_char	= Type.inCon con_char
    val typ_string	= Type.inCon con_string
    val typ_real	= Type.inCon con_real
    val typ_bool	= Type.inAbbrev(Type.inCon con_bool,
					Type.inMu(Type.inSum row_bool))
    val typ_exn		= Type.inCon con_exn
    val typ_ref		= Type.inCon con_ref
    val typ_vec		= Type.inCon con_vec
    val _		= Type.unify(typ_list,
			    Type.inAbbrev(Type.inCon con_list,
				Type.inMu(Type.inLambda(var_list,
							Type.inSum row_list))))
  end
(* src # 69 ../frontend-common/StringMap.sml *)
structure StringMap = MakeHashImpMap(StringHashKey)
(* src # 70 ../frontend-common/FIXITY.sig *)
signature FIXITY =
  sig

    datatype assoc = LEFT | RIGHT | NEITHER	(* [a] *)

    datatype fix = NONFIX			(* [q] *)
		 | PREFIX  of int
		 | POSTFIX of int
		 | INFIX   of int * assoc

    type t = fix

  end
(* src # 71 ../frontend-common/Fixity.sml *)
structure Fixity :> FIXITY =
  struct

    datatype assoc = LEFT | RIGHT | NEITHER	(* [a] *)

    datatype fix = NONFIX			(* [q] *)
		 | PREFIX  of int
		 | POSTFIX of int
		 | INFIX   of int * assoc

    type t = fix

  end
(* src # 72 ../frontend-common/INF.sig *)
signature INF =
  sig

  (* Types *)

    type lab   = Label.t
    type name  = Name.t
    type stamp = Stamp.t
    type path  = Path.t
    type typ   = Type.t
    type tkind = Type.kind
    type fix   = Fixity.t

    datatype val_sort = VALUE | CONSTRUCTOR		(* [w] *)
    datatype typ_sort = datatype Type.sort		(* [w] *)

    type kind						(* [kappa,k] *)
    type con = kind * path				(* [chi,c]   *)
    type sign						(* [sigma,s] *)
    type item
    type inf						(* [jota,j] *)
    type t = inf

  (* Realisations *)

    type val_rea = path PathMap.t
    type typ_rea = typ  PathMap.t
    type mod_rea = path PathMap.t
    type inf_rea = inf  PathMap.t

    type rea	 = { val_rea : val_rea
		   , typ_rea : typ_rea
		   , mod_rea : mod_rea
		   , inf_rea : inf_rea
		   }

  (* Injections *)

    val inTop :		unit		 -> inf
    val inCon :		con		 -> inf
    val inSig :		sign		 -> inf
    val inArrow :	path * inf * inf -> inf
    val inLambda :	path * inf * inf -> inf
    val inApply :	inf * path * inf -> inf
    val inAbbrev :	inf * inf        -> inf

  (* Inquiries *)

    val isTop :		inf -> bool
    val isCon :		inf -> bool
    val isSig :		inf -> bool
    val isArrow :	inf -> bool
    val isLambda :	inf -> bool
    val isApply :	inf -> bool
    val isAbbrev :	inf -> bool

  (* Projections *)

    exception Interface

    val asCon :		inf -> con			(* Interface *)
    val asSig :		inf -> sign			(* Interface *)
    val asArrow :	inf -> path * inf * inf		(* Interface *)
    val asLambda :	inf -> path * inf * inf		(* Interface *)
    val asApply :	inf -> inf * path * inf		(* Interface *)
    val asAbbrev :	inf -> inf * inf		(* Interface *)

  (* Cloning etc. *)

    val clone :		inf -> inf
    val instance :	inf -> inf
    val singleton :	inf -> inf
    val realise :	rea  * inf -> unit
    val strengthen :	path * inf -> unit
    val strengthenSig :	path * sign -> unit

  (* Kinds *)

    exception Kind

    val inGround :	unit -> kind
    val inDependent :	path * inf * kind -> kind

    val isGround :	kind -> bool
    val isDependent :	kind -> bool
    val asDependent :	kind -> path * inf * kind	(* Kind *)

    val kind :		inf -> kind

  (* Signature construction *)

    val empty :		unit -> sign

    val newVal :	sign * lab -> path
    val newTyp :	sign * lab -> path
    val newMod :	sign * lab -> path
    val newInf :	sign * lab -> path
    val newFix :	sign * lab -> path

    val extendVal :	sign * path *  typ  * val_sort * path option -> unit
    val extendTyp :	sign * path * tkind * typ_sort * typ  option -> unit
    val extendMod :	sign * path *  inf  * path option -> unit
    val extendInf :	sign * path *  kind * inf  option -> unit
    val extendFix :	sign * path * fix -> unit

  (* Signature inspection *)

    val items :		sign -> item list

    exception Item

    val isValItem :	item -> bool
    val isTypItem :	item -> bool
    val isModItem :	item -> bool
    val isInfItem :	item -> bool
    val isFixItem :	item -> bool

    val asValItem :	item -> lab * typ * val_sort * path option  (* Item *)
    val asTypItem :	item -> lab * tkind * typ_sort * typ option (* Item *)
    val asModItem :	item -> lab * inf * path option		(* Item *)
    val asInfItem :	item -> lab * kind * inf option		(* Item *)
    val asFixItem :	item -> lab * fix			(* Item *)

  (* Signature lookup *)

    exception Lookup

    val lookupVal :	sign * lab -> typ		(* Lookup *)
    val lookupTyp :	sign * lab -> typ		(* Lookup *)
    val lookupMod :	sign * lab -> inf		(* Lookup *)
    val lookupInf :	sign * lab -> inf		(* Lookup *)
    val lookupFix :	sign * lab -> fix		(* Lookup *)

    val lookupVal' :	sign * lab * int -> typ		(* Lookup *)
    val lookupTyp' :	sign * lab * int -> typ		(* Lookup *)
    val lookupMod' :	sign * lab * int -> inf		(* Lookup *)
    val lookupInf' :	sign * lab * int -> inf		(* Lookup *)
    val lookupFix' :	sign * lab * int -> fix		(* Lookup *)

    val lookupValSort :	sign * lab -> val_sort		(* Lookup *)
    val lookupTypSort :	sign * lab -> typ_sort		(* Lookup *)
    val lookupValPath :	sign * lab -> path		(* Lookup *)
    val lookupModPath :	sign * lab -> path		(* Lookup *)

  (* Closure check *)

    exception Unclosed of lab * int * typ

    val close :		sign -> unit			(* Unclosed *)

  (* Matching and intersection *)

    datatype mismatch =
	  MissingVal      of lab
	| MissingTyp      of lab
	| MissingMod      of lab
	| MissingInf      of lab
	| MissingFix      of lab
	| ManifestVal     of lab * path option * path
	| ManifestTyp     of lab * typ option * typ
	| ManifestMod     of lab * path option * path
	| ManifestInf     of lab * mismatch option
	| MismatchVal     of lab * typ * typ
	| MismatchTyp     of lab * tkind * tkind
	| MismatchMod     of lab * mismatch
	| MismatchInf     of lab * mismatch
	| MismatchFix     of lab * fix * fix
	| MismatchValSort of lab * val_sort * val_sort
	| MismatchTypSort of lab * typ_sort * typ_sort
	| MismatchDom     of mismatch
	| MismatchRan     of mismatch
	| Incompatible    of inf * inf
	| IncompatibleArg of path * path

    exception Mismatch of mismatch

    val match :		inf * inf -> rea		(* Mismatch *)
    val intersect :	inf * inf -> inf		(* Mismatch *)
    val equaliseKind :	kind * kind -> unit		(* Mismatch *)

  end
(* src # 73 ../frontend-common/Inf.sml *)
(* Interfaces contain state. This means that they must be instantiated
   at each occurance. *)

structure InfPrivate =
  struct

  (* Types *)

    type lab	= Label.t
    type name	= Name.t
    type stamp	= Stamp.t
    type path	= Path.t
    type typ	= Type.t
    type tkind	= Type.kind
    type fix    = Fixity.t

    datatype val_sort = VALUE | CONSTRUCTOR		(* [w] *)
    datatype typ_sort = datatype Type.sort		(* [w] *)

    type id	= path * lab * int			(* [x] *)
    type 'a def	= 'a option				(* [d] *)


    (* A map for signatures *)

    datatype space = VAL' | TYP' | MOD' | INF' | FIX'

    structure Map = MakeHashImpMap(struct type t = space * lab
					  fun hash(_,l) = Label.hash l end)


    datatype inf' =
	  TOP					(* top *)
	| CON    of con				(* interface constructor *)
	| SIG    of sign			(* signature *)
	| FUN    of path * inf * inf		(* arrow (functor) *)
	| LAMBDA of path * inf * inf		(* abstraction (dep. function)*)
	| APPLY  of inf * path * inf		(* application *)
	| LINK   of inf				(* forward (for substitution) *)
	| ABBREV of inf * inf			(* abbreviations *)

    and item' =
	  VAL of id *  typ  * val_sort * path def	(* value *)
	| TYP of id * tkind * typ_sort * typ def	(* type *)
	| MOD of id *  inf  * path def			(* module *)
	| INF of id *  kind * inf def			(* interface *)
	| FIX of id *  fix				(* fixity *)

    and kind' =						(* [kappa,k] *)
	  GROUND					(* ordinary interface *)
	| DEP of path * inf * kind			(* dependent *)

    withtype inf  = inf' ref				(* [jota,j] *)
    and      kind = kind' ref				(* [kappa,k] *)
    and      con  = kind' ref * path			(* [chi,c] *)
    and      item = item' ref				(* [item] *)
    and      sign = item' ref list ref * item' ref list Map.t	(* [sigma,s] *)

    type t = inf


  (* Realisations *)

    type val_rea = path PathMap.t
    type typ_rea = typ  PathMap.t
    type mod_rea = path PathMap.t
    type inf_rea = inf  PathMap.t

    type rea	 = { val_rea : val_rea
		   , typ_rea : typ_rea
		   , mod_rea : mod_rea
		   , inf_rea : inf_rea
		   }

    fun emptyRea() = { val_rea = PathMap.new()
		     , typ_rea = PathMap.new()
		     , mod_rea = PathMap.new()
		     , inf_rea = PathMap.new()
		     } : rea


  (* Simple accessors *)

    fun idPath(p,l,n)		= p
    fun idLab(p,l,n)		= l
    fun idIndex(p,l,n)		= n

    fun itemId(ref item')	= itemId' item'
    and itemId'(VAL(x,_,_,_))	= x
      | itemId'(TYP(x,_,_,_))	= x
      | itemId'(MOD(x,_,_))	= x
      | itemId'(INF(x,_,_))	= x
      | itemId'(FIX(x,_))	= x

    fun itemPath  item		= idPath(itemId item)
    fun itemLab   item		= idLab(itemId item)
    fun itemIndex item		= idIndex(itemId item)

    fun itemSpace(ref item')	= itemSpace' item'
    and itemSpace'(VAL _)	= VAL'
      | itemSpace'(TYP _)	= TYP'
      | itemSpace'(MOD _)	= MOD'
      | itemSpace'(INF _)	= INF'
      | itemSpace'(FIX _)	= FIX'


  (* Follow a path of links (performing path compression on the fly) *)

    fun follow(ref(LINK j))	= follow j
      | follow j		= j

(*DEBUG
    fun follow'(ref(LINK j))	= follow' j
      | follow' j		= j

    fun follow(j as ref(LINK k))= let val l = follow' k in j := LINK l ; l end
      | follow j		= j
*)


  (* Signature construction *)

    fun empty()			= (ref [], Map.new())

    fun newItem(s, l)		= Path.fromLab l
    val newVal			= newItem
    val newTyp			= newItem
    val newMod			= newItem
    val newInf			= newItem
    val newFix			= newItem

    fun hideId (p,l,n)		= (p,l,n+1)
    fun hide item		= item := hide'(!item)
    and hide'(VAL(x,t,w,d))	= VAL(hideId x, t, w, d)
      | hide'(TYP(x,k,w,d))	= TYP(hideId x, k, w, d)
      | hide'(MOD(x,j,d))	= MOD(hideId x, j, d)
      | hide'(INF(x,k,d))	= INF(hideId x, k, d)
      | hide'(FIX(x,q))		= FIX(hideId x, q)

    fun extend((itemsr,map), space, p, makeItem') =
	let
	    val l    = Path.toLab p
	    val item = ref(makeItem'(p,l,0))
	in
	    itemsr := item :: !itemsr ;
	    Map.insertWith (fn(items,_) => (List.app hide items ; item::items))
			   (map, (space,l), [item])
	end

    fun extendVal(s,p,t,w,d)	= extend(s, VAL', p, fn x => VAL(x,t,w,d))
    fun extendTyp(s,p,k,w,d)	= extend(s, TYP', p, fn x => TYP(x,k,w,d))
    fun extendMod(s,p,j,d)	= extend(s, MOD', p, fn x => MOD(x,j,d))
    fun extendInf(s,p,k,d)	= extend(s, INF', p, fn x => INF(x,k,d))
    fun extendFix(s,p,q)	= extend(s, FIX', p, fn x => FIX(x,q))


  (* Signature inspection *)

    exception Item

    fun items(ref items, _) = List.filter (fn item => itemIndex item = 0) items

    fun isValItem(ref(VAL _))		= true
      | isValItem _			= false
    fun isTypItem(ref(TYP _))		= true
      | isTypItem _			= false
    fun isModItem(ref(MOD _))		= true
      | isModItem _			= false
    fun isInfItem(ref(INF _))		= true
      | isInfItem _			= false
    fun isFixItem(ref(FIX _))		= true
      | isFixItem _			= false

    fun asValItem(ref(VAL(x,t,s,d)))	= (idLab x, t, s, d)
      | asValItem _			= raise Item
    fun asTypItem(ref(TYP(x,k,s,d)))	= (idLab x, k, s, d)
      | asTypItem _			= raise Item
    fun asModItem(ref(MOD(x,j,d)))	= (idLab x, j, d)
      | asModItem _			= raise Item
    fun asInfItem(ref(INF(x,k,d)))	= (idLab x, k, d)
      | asInfItem _			= raise Item
    fun asFixItem(ref(FIX(x,q)))	= (idLab x, q)
      | asFixItem _			= raise Item


  (* Signature lookup *)

    fun selectVal'(VAL(x, t, w, d))	= t
      | selectVal' _			= raise Crash.Crash "Inf.selectVal'"

    fun selectVal(VAL(x, t, w, SOME p))	= p
      | selectVal(VAL(x, t, w, NONE))	= idPath x
      | selectVal _			= raise Crash.Crash "Inf.selectVal"

    fun selectTyp(TYP(x, k, w, SOME t))	= t
      | selectTyp(TYP(x, k, w, NONE))	= Type.inCon(k, w, idPath x)
      | selectTyp _			= raise Crash.Crash "Inf.selectTyp"

    fun selectMod'(MOD(x, j, d))	= j
      | selectMod' _			= raise Crash.Crash "Inf.selectMod'"

    fun selectMod(MOD(x, j, SOME p))	= p
      | selectMod(MOD(x, j, NONE))	= idPath x
      | selectMod _			= raise Crash.Crash "Inf.selectMod"

    fun selectInf(INF(x, k, SOME j))	= j
      | selectInf(INF(x, k, NONE))	= ref(CON(k, idPath x))	(* inCon *)
      | selectInf _			= raise Crash.Crash "Inf.selectInf"

    fun selectFix(FIX(x, f))		= f
      | selectFix _			= raise Crash.Crash "Inf.selectFix"

    fun selectValSort(VAL(x, t, w, d))	= w
      | selectValSort _			= raise Crash.Crash "Inf.selectValSort"

    fun selectTypSort(TYP(x, k, w, d))	= w
      | selectTypSort _			= raise Crash.Crash "Inf.selectTypSort"


    exception Lookup

    fun lookup space ((_,m), l) =
	case Map.lookup(m, (space,l))
	  of SOME(item::items) => !item
	   | _                 => raise Lookup

    fun lookup' space ((_,m), l, n) =
	case Map.lookup(m, (space,l))
	  of SOME(item::items) =>
		!(Option.valOf(List.find (fn item => itemIndex item = n) items))
	   | _ => raise Lookup

    fun lookupVal args	= (selectVal' o lookup VAL') args
    fun lookupTyp args	= (selectTyp  o lookup TYP') args
    fun lookupMod args	= (selectMod' o lookup MOD') args
    fun lookupInf args	= (selectInf  o lookup INF') args
    fun lookupFix args	= (selectFix  o lookup FIX') args

    fun lookupVal' args	= (selectVal' o lookup' VAL') args
    fun lookupTyp' args	= (selectTyp  o lookup' TYP') args
    fun lookupMod' args	= (selectMod' o lookup' MOD') args
    fun lookupInf' args	= (selectInf  o lookup' INF') args
    fun lookupFix' args	= (selectFix  o lookup' FIX') args

    fun lookupValSort args = (selectValSort o lookup VAL') args
    fun lookupTypSort args = (selectTypSort o lookup TYP') args

    fun lookupValPath args = (selectVal o lookup VAL') args
    fun lookupModPath args = (selectMod o lookup MOD') args


  (* Closure check *)

    exception Unclosed of lab * int * typ

    fun close (ref items,_) = ()(*List.app closeItem items*)

    and closeItem(ref(VAL((p,l,n), t, w, d))) =
	if Type.isClosed t then () else
	    raise Unclosed(l,n,t)
      | closeItem _ = ()
	(* ASSUME that nested structures are always closed *)


  (* Reduction to head normal form *)

    (*UNFINISHED: avoid multiple cloning of curried lambdas somehow *)

    fun reduce(j as ref(APPLY(j1,p,j2))) =
	let
	    fun reduceApply(j1 as ref(LAMBDA _), jo) =
		( case !(instance j1)
		    of LAMBDA(p1, j11, j12) =>
			(*UNFINISHED: do realisation *)
			(*Path.replace(p1, p)*)
			( j := LINK j12
			; reduce j
			)
		    | _ => raise Crash.Crash "Inf.reduceApply"
		)
	      | reduceApply(ref(LINK j11), jo) =
		    reduceApply(follow j11, jo)

	      | reduceApply(ref(ABBREV(j11,j12)), jo) =
		    reduceApply(follow j12, SOME(Option.getOpt(jo,j11)))

	      | reduceApply _ = ()
	in
	    reduceApply(j1, NONE)
	end

      | reduce(ref(LINK j | ABBREV(_,j))) = reduce j

      | reduce _ = ()


  (* Realisation *)

    (* Applied realisations have to be complete:
     *
     *   Whenever there is a p in Dom(#mod_rea rea), then rea must also
     *   contain substitutions for all subitems of module p.
     *
     * This way we avoid substitutions inside paths (which would require
     * passing around a suitable environment), because if there is a
     * substitution for a subpath then there also is a substitution for
     * the complete path.
     *
     * Realisations need not be idempotent (fully expanded). Would be nice
     * to have this property because it would make substitution more efficient,
     * but full expansion is difficult to achieve for the intersect function).
     *)

    and realise (rea: rea, j as ref j')	= j := realise'(rea, j')

    and realise'(rea, LINK j)		= realise'(rea, !j)
      | realise'(rea, TOP)		= TOP
      | realise'(rea, CON c)		= realiseCon(rea, c)
      | realise'(rea, j' as SIG s)	= ( realiseSig(rea, s)
					  ; j'
					  )
      | realise'(rea, j' as (FUN(_,j1,j2) | LAMBDA(_,j1,j2) | ABBREV(j1,j2))) =
					  ( realise(rea, j1)
					  ; realise(rea, j2)
					  ; j'
					  )
      | realise'(rea, APPLY(j1,p,j2))	= ( realise(rea, j1)
					  ; realise(rea, j2)
					  (* UNFINISHED: do reduction *)
					  ; APPLY(j1, realisePath(#mod_rea rea,
								  p), j2)
					  )

    and realiseKind (rea, ref k')	= realiseKind'(rea, k')
    and realiseKind'(rea, GROUND)	= ()
      | realiseKind'(rea, DEP(_,j,k))	= ( realise(rea, j)
					  ; realiseKind(rea, k)
					  )

    and realiseSig(rea, (ref items, _))	=
	    List.app (fn item => realiseItem(rea, item)) items

    and realiseItem(rea, item as ref(VAL(x, t, w, d))) =
	( realiseTyp(rea, t) ; item := VAL(x, t, w, realiseValDef(rea, d)))
      | realiseItem(rea, ref(TYP(x, k, w, d))) =
	  realiseTypDef(rea, d)
      | realiseItem(rea, item as ref(MOD(x, j, d))) =
	( realise(rea, j) ; item := MOD(x, j, realiseModDef(rea, d)) )
      | realiseItem(rea, ref(INF(x, k, d))) =
	( realiseKind(rea, k) ; realiseInfDef(rea, d) )
      | realiseItem(rea, ref(FIX _)) = ()

    and realiseCon(rea, kp as (k,p)) =
	case PathMap.lookup(#inf_rea rea, p)
	  of SOME j => let val j' = instance j in
			  realise(rea, j') ; LINK j'		(* expand *)
		       end
	   | NONE   => ( realiseKind(rea, k) ; CON kp )

    and realisePath(rea', p)		= case PathMap.lookup(rea', p)
					    of NONE    => p
					     | SOME p' => realisePath(rea', p')
    and realisePathDef(rea', NONE  )	= NONE
      | realisePathDef(rea', SOME p)	= SOME(realisePath(rea', p))

    and realiseValDef(rea, d)		= realisePathDef(#val_rea rea, d)
    and realiseModDef(rea, d)		= realisePathDef(#mod_rea rea, d)

    and realiseTypDef(rea, NONE  )	= ()
      | realiseTypDef(rea, SOME t)	= realiseTyp(rea, t)

    and realiseInfDef(rea, NONE  )	= ()
      | realiseInfDef(rea, SOME j)	= realise(rea, j)

    and realiseTyp(rea, t)		= Type.realise(#typ_rea rea, t)


  (* Instantiation *)

    (*
     * This is really ugly! To maintain sharing of types in signatures
     * at signature instantiation we have to clone types with those special
     * functions from the Type module. This implies that we cannot apply
     * the path realisation build up during instantiation on-the-fly to
     * types (types cloned by Type.cloneCont may not be touched before
     * executing Type.cloneFinish). Consequently, we have to do a second
     * walk over the interface to perform those realisations. :-(
     *)

    and instance j =
	let
	    val rea'       = PathMap.new()
	    val cloneState = Type.cloneStart()
	    val j1         = instanceInf(rea', cloneState, j)
	in
	    Type.cloneFinish cloneState ;
	    realiseT(rea', j1) ;
	    j1
	end

    and instanceInf (r,z, ref j')		= ref(instanceInf'(r,z, j'))
    and instanceInf'(r,z, LINK j)		= instanceInf'(r,z, !j)
      | instanceInf'(r,z, TOP)			= TOP
      | instanceInf'(r,z, CON c)		= CON(instanceCon(r,z, c))
      | instanceInf'(r,z, SIG s)		= SIG(instanceSig(r,z, s))
      | instanceInf'(r,z, FUN(p,j1,j2))		= FUN(instancePath(r, p),
						      instanceInf(r,z, j1),
						      instanceInf(r,z, j2))
      | instanceInf'(r,z, LAMBDA(p,j1,j2))	= LAMBDA(instancePath(r, p),
							 instanceInf(r,z, j1),
							 instanceInf(r,z, j2))
      | instanceInf'(r,z, APPLY(j1,p,j2))	= APPLY(instanceInf(r,z, j1),
							realisePath(r, p),
							instanceInf(r,z, j2))
      | instanceInf'(r,z, ABBREV(j1,j2))	= ABBREV(instanceInf(r,z, j1),
							 instanceInf(r,z, j2))

    and instanceCon(r,z, (k,p))			= ( instanceKind(r,z, k),
						    realisePath(r, p) )

    and instanceKind (r,z, ref k')		= ref(instanceKind'(r,z, k'))
    and instanceKind'(r,z, GROUND)		= GROUND
      | instanceKind'(r,z, DEP(p,j,k))		= DEP(instancePath(r, p),
						      instanceInf(r,z, j),
						      instanceKind(r,z, k))
    and instancePath(rea, p) =
	let
	    val p' = Path.instance PathMap.lookup (rea, p)
	in
	    (*UNFINISHED: do we need to make the check? *)
	    if p' <> p then PathMap.insert(rea, p, p') else () ;
	    p'
	end

    and instanceSig(r,z, (ref items,_)) =
	let
	    val s as (itemsr,map) = empty()

	    fun extendSig(space_l, item) =
		( itemsr := item :: !itemsr
		; Map.insertWith (fn(l1,l2) => l2 @ l1) (map, space_l, [item])
		)

	    fun instanceItem(ref item') = instanceItem' item'

	    and instanceItem'(VAL((p,l,n), t, w, d)) =
		let
		    val p'   = instancePath(r, p)
		    val t'   = instanceTyp(r,z, t)
		    val d'   = instancePathDef(r, d)
		    val item = ref(VAL((p',l,n), t', w, d'))
		in
		    extendSig((VAL',l), item)
		end

	      | instanceItem'(TYP((p,l,n), k, w, d)) =
		let
		    val p'   = instancePath(r, p)
		    val d'   = instanceTypDef(r,z, d)
		    val item = ref(TYP((p',l,n), k, w, d'))
		in
		    extendSig((TYP',l), item)
		end

	      | instanceItem'(MOD((p,l,n), j, d)) =
		let
		    val p'   = instancePath(r, p)
		    val j'   = instanceInf(r,z, j)
		    val d'   = instancePathDef(r, d)
		    val item = ref(MOD((p',l,n), j', d'))
		in
		    extendSig((MOD',l), item)
		end

	      | instanceItem'(INF((p,l,n), k, d)) =
		let
		    val p'   = instancePath(r, p)
		    val k'   = instanceKind(r,z, k)
		    val d'   = instanceInfDef(r,z, d)
		    val item = ref(INF((p',l,n), k', d'))
		in
		    extendSig((INF',l), item)
		end

	      | instanceItem'(FIX((p,l,n), q)) =
		let
		    val p'   = instancePath(r, p)
		    val item = ref(FIX((p',l,n), q))
		in
		    extendSig((FIX',l), item)
		end
	in
	    Misc.List_appr instanceItem items ;
	    s
	end

    and instancePathDef(rea, NONE  )	= NONE
      | instancePathDef(rea, SOME p)	= SOME(realisePath(rea, p))

    and instanceTypDef(r,z, NONE  )	= NONE
      | instanceTypDef(r,z, SOME t)	= SOME(instanceTyp(r,z, t))

    and instanceInfDef(r,z, NONE  )	= NONE
      | instanceInfDef(r,z, SOME j)	= SOME(instanceInf(r,z, j))

    and instanceTyp(r,z, t)		= Type.cloneCont z t
					  (* Cannot do 
						Type.realisePath(r,t')
					     here! *)

    and realiseT (rea', ref j')			= realiseT'(rea', j')

    and realiseT'(rea', LINK j)			= realiseT(rea', j)
      | realiseT'(rea', (TOP | CON _))		= ()
      | realiseT'(rea', SIG s)			= realiseTSig(rea', s)
      | realiseT'(rea', (FUN(_,j1,j2) | LAMBDA(_,j1,j2) | ABBREV(j1,j2))) =
						  ( realiseT(rea', j1)
						  ; realiseT(rea', j2)
						  )
      | realiseT'(rea', APPLY(j1,p,j2))		= ( realiseT(rea', j1)
						  ; realiseT(rea', j2)
						  )

    and realiseTKind (rea', ref k')		= realiseTKind'(rea', k')
    and realiseTKind'(rea, GROUND)		= ()
      | realiseTKind'(rea, DEP(_,j,k))		= ( realiseT(rea, j)
						  ; realiseTKind(rea, k)
						  )

    and realiseTSig(rea', (ref items, _))	=
	    List.app (fn item => realiseTItem(rea', item)) items

    and realiseTItem(rea', ref item')		= realiseTItem'(rea', item')
    and realiseTItem'(rea', VAL(x, t, w, d))	= realiseTTyp(rea', t)
      | realiseTItem'(rea', TYP(x, k, w, d))	= realiseTTypDef(rea', d)
      | realiseTItem'(rea', MOD(x, j, d))	= realiseT(rea', j)
      | realiseTItem'(rea', INF(x, k, d))	= ( realiseTKind(rea', k)
						  ; realiseTInfDef(rea', d)
						  )
      | realiseTItem'(rea', FIX _)		= ()

    and realiseTCon(rea', (k,p))		= realiseTKind(rea', k)

    and realiseTTypDef(rea', NONE  )		= ()
      | realiseTTypDef(rea', SOME t)		= realiseTTyp(rea', t)

    and realiseTInfDef(rea', NONE  )		= ()
      | realiseTInfDef(rea', SOME j)		= realiseT(rea', j)

    and realiseTTyp(rea', t)			= Type.realisePath(rea', t)



  (* Creation of singleton (shallow instantiation) *)

    (* Creates an instance of an interface where every item is equal to
     * to the original one.
     *)

    and singleton j =
	let
	    val cloneState = Type.cloneStart()
	    val j1         = singletonInf(cloneState, j)
	in
	    Type.cloneFinish cloneState ;
	    j1
	end

    and singletonInf (z, ref j')		= ref(singletonInf'(z, j'))
    and singletonInf'(z, LINK j)		= singletonInf'(z, !j)
      | singletonInf'(z, TOP)			= TOP
      | singletonInf'(z, CON c)			= CON(singletonCon(z, c))
      | singletonInf'(z, SIG s)			= SIG(singletonSig(z, s))
      | singletonInf'(z, FUN(p,j1,j2))		= FUN(Path.clone p,
						      singletonInf(z, j1),
						      singletonInf(z, j2))
      | singletonInf'(z, LAMBDA(p,j1,j2))	= LAMBDA(Path.clone p,
							 singletonInf(z, j1),
							 singletonInf(z, j2))
      | singletonInf'(z, APPLY(j1,p,j2))	= APPLY(singletonInf(z, j1),
							p,
							singletonInf(z, j2))
      | singletonInf'(z, ABBREV(j1,j2))		= ABBREV(singletonInf(z, j1),
							 singletonInf(z, j2))

    and singletonCon(z, (k,p))			= ( singletonKind(z, k), p )

    and singletonKind (z, ref k')		= ref(singletonKind'(z, k'))
    and singletonKind'(z, GROUND)		= GROUND
      | singletonKind'(z, DEP(p,j,k))		= DEP(Path.clone p,
						      singletonInf(z, j),
						      singletonKind(z, k))

    and singletonSig(z, (ref items,_)) =
	let
	    val s as (itemsr,map) = empty()

	    fun extendSig(space_l, item) =
		( itemsr := item :: !itemsr
		; Map.insertWith (fn(l1,l2) => l2 @ l1) (map, space_l, [item])
		)

	    fun singletonItem(ref item') = singletonItem' item'

	    and singletonItem'(VAL((p,l,n), t, w, d)) =
		let
		    val p'   = Path.clone p
		    val t'   = singletonTyp(z, t)
		    val item = ref(VAL((p',l,n), t', w, d))
		in
		    extendSig((VAL',l), item)
		end

	      | singletonItem'(TYP((p,l,n), k, w, d)) =
		let
		    val p'   = Path.clone p
		    val d'   = singletonTypDef(z, d)
		    val item = ref(TYP((p',l,n), k, w, d'))
		in
		    extendSig((TYP',l), item)
		end

	      | singletonItem'(MOD((p,l,n), j, d)) =
		let
		    val p'   = Path.clone p
		    val j'   = singletonInf(z, j)
		    val item = ref(MOD((p',l,n), j', d))
		in
		    extendSig((MOD',l), item)
		end

	      | singletonItem'(INF((p,l,n), k, d)) =
		let
		    val p'   = Path.clone p
		    val k'   = singletonKind(z, k)
		    val d'   = singletonInfDef(z, d)
		    val item = ref(INF((p',l,n), k', d'))
		in
		    extendSig((INF',l), item)
		end

	      | singletonItem'(FIX((p,l,n), q)) =
		let
		    val p'   = Path.clone p
		    val item = ref(FIX((p',l,n), q))
		in
		    extendSig((FIX',l), item)
		end
	in
	    Misc.List_appr singletonItem items ;
	    s
	end

    and singletonTypDef(z, NONE  )	= NONE
      | singletonTypDef(z, SOME t)	= SOME(singletonTyp(z, t))

    and singletonInfDef(z, NONE  )	= NONE
      | singletonInfDef(z, SOME j)	= SOME(singletonInf(z, j))

    and singletonTyp(z, t)		= Type.cloneCont z t


  (* Cloning (does not instantiate paths!) *)

    fun clone(ref j')		= ref(clone' j')
    and clone'(LINK j)		= clone'(!j)
      | clone'(TOP)		= TOP
      | clone'(CON c)		= CON(cloneCon c)
      | clone'(SIG s)		= SIG(cloneSig s)
      | clone'(FUN(p,j1,j2))	= FUN(p, clone j1, clone j2)
      | clone'(LAMBDA(p,j1,j2))	= LAMBDA(p, clone j1, clone j2)
      | clone'(APPLY(j1,p,j2))	= APPLY(clone j1, p, clone j2)
      | clone'(ABBREV(j1,j2))	= ABBREV(clone j1, clone j2)

    and cloneCon (k,p)		= (cloneKind k, p)

    and cloneKind (ref k')	= ref(cloneKind' k')
    and cloneKind'(GROUND)	= GROUND
      | cloneKind'(DEP(p,j,k))	= DEP(p, clone j, cloneKind k)

    and cloneSig (ref items, _)	=
	let
	    val s as (itemsr,map) = empty()

	    fun extendSig(space_l, item) =
		( itemsr := item :: !itemsr
		; Map.insertWith (fn(l1,l2) => l2 @ l1) (map, space_l, [item])
		)

	    fun cloneItem(ref item') = cloneItem' item'
	    and cloneItem'(item' as VAL(x,t,w,d)) =
		    extendSig((VAL', idLab x), ref item')
	      | cloneItem'(item' as TYP(x,k,w,d)) =
		    extendSig((TYP', idLab x), ref item')
	      | cloneItem'(MOD(x,j,d)) =
		let val item' = MOD(x, clone j, d) in
		    extendSig((MOD', idLab x), ref item')
		end
	      | cloneItem'(INF(x,k,d)) =
		let val item' = INF(x, cloneKind k, Option.map clone d) in
		    extendSig((INF', idLab x), ref item')
		end
	      | cloneItem'(item' as FIX(x,q)) =
		    extendSig((FIX', idLab x), ref item')
	in
	    Misc.List_appr cloneItem items ;
	    s
	end


  (* Creation and injections *)

    fun inTop()		= ref TOP
    fun inCon c		= ref(CON c)
    fun inSig s		= ref(SIG s)
    fun inArrow pjj	= ref(FUN pjj)
    fun inLambda pjj	= ref(LAMBDA pjj)
    fun inApply jpj	= let val j = ref(APPLY jpj) in reduce j ; j end
    fun inAbbrev jj	= ref(ABBREV jj)

    fun pathToPath  p	= p
    fun pathToTyp k p	= Type.inCon(k, Type.CLOSED, p)
    fun pathToInf k p	= inCon(k,p)


  (* Projections and extractions *)

    exception Interface

    fun asInf(ref(LINK j))	= asInf j
      | asInf(ref(ABBREV(_,j)))	= asInf j
      | asInf(ref j')		= j'

    fun isTop j		= case asInf j of TOP      => true | _ => false
    fun isCon j		= case asInf j of CON _    => true | _ => false
    fun isSig j		= case asInf j of SIG _    => true | _ => false
    fun isArrow j	= case asInf j of FUN _    => true | _ => false
    fun isLambda j	= case asInf j of LAMBDA _ => true | _ => false
    fun isApply j	= case asInf j of APPLY _  => true | _ => false

    fun asCon j		= case asInf j of CON z    => z | _ => raise Interface
    fun asSig j		= case asInf j of SIG z    => z | _ => raise Interface
    fun asArrow j	= case asInf j of FUN z    => z | _ => raise Interface
    fun asLambda j	= case asInf j of LAMBDA z => z | _ => raise Interface
    fun asApply j	= case asInf j of APPLY z  => z | _ => raise Interface

    fun isAbbrev j	= case !(follow j) of ABBREV _  => true | _ => false
    fun asAbbrev j	= case !(follow j) of ABBREV jj => jj   | _ =>
								raise Interface
    fun pathCon(_,p)	= p
    fun path j		= pathCon(asCon j)


  (* Strengthening *)

    fun strengthen(p, ref(SIG s))		= strengthenSig(p, s)
      | strengthen(p, ref(LINK j))		= strengthen(p, j)
      | strengthen(p, ref(ABBREV(j1,j2)))	= ( strengthen(p, j1)
						  ; strengthen(p, j2) )
      | strengthen(p, _)			= ()

    and strengthenSig(p, (ref items, _)) =
	    List.app (fn item => strengthenItem(p, item)) items

    and strengthenItem(p, item as ref item') =
	    item := strengthenItem'(p, item')

    and strengthenItem'(p, VAL(x, t, w, d)) =
	let
	    val _  = strengthenId(p, x)
	    val d' = strengthenPathDef(idPath x, d)
	in
	    VAL(x, t, w, d')
	end

      | strengthenItem'(p, TYP(x, k, w, d)) =
	let
	    val _  = strengthenId(p, x)
	    val d' = strengthenTypDef(idPath x, k, d)
	in
	    TYP(x, k, w, d')
	end

      | strengthenItem'(p, MOD(x, j, d)) =
	let
	    val _  = strengthenId(p, x)
	    val _  = strengthen(idPath x, j)
	    val d' = strengthenPathDef(idPath x, d)
	in
	    MOD(x, j, d')
	end

      | strengthenItem'(p, INF(x, k, d)) =
	let
	    val _  = strengthenId(p, x)
	    val d' = strengthenInfDef(idPath x, k, d)
	in
	    INF(x, k, d')
	end

      | strengthenItem'(p, FIX(x, q)) =
	let
	    val _  = strengthenId(p, x)
	in
	    FIX(x, q)
	end

    and strengthenId(p, pln)		= Path.strengthen(p, pln)

    and strengthenPathDef(p, NONE)	= SOME p
      | strengthenPathDef(p, d)		= d

    and strengthenTypDef(p, k, NONE)	= SOME(pathToTyp k p)
      | strengthenTypDef(p, k, SOME t)	= SOME(Type.inAbbrev(pathToTyp k p,t))

    and strengthenInfDef(p, k, NONE)	= SOME(pathToInf k p)
      | strengthenInfDef(p, k, SOME j)	= SOME(inAbbrev(pathToInf k p,j))


  (* Kinds *)

    exception Kind

    fun inGround ()		= ref GROUND
    fun inDependent pjk		= ref(DEP pjk)

    fun isGround(ref GROUND)	= true
      | isGround _		= false

    fun isDependent k		= not(isGround k)
    fun asDependent(ref(DEP x))	= x
      | asDependent _		= raise Kind

    fun kind(ref j')		= kind' j'
    and kind'( TOP
	     | SIG _
	     | FUN _ )		= inGround()
      | kind'(CON(k,p))		= k
      | kind'(LAMBDA(p,j1,j2))	= inDependent(p, j1, kind j2)
      | kind'(APPLY(j1,p,j2))	= (*UNFINISHED*) inGround()
      | kind'(LINK j)		= kind j
      | kind'(ABBREV(j1,j2))	= kind j2


  (* Matching *)

    datatype mismatch =
	  MissingVal      of lab
	| MissingTyp      of lab
	| MissingMod      of lab
	| MissingInf      of lab
	| MissingFix      of lab
	| ManifestVal     of lab * path option * path
	| ManifestTyp     of lab * typ option * typ
	| ManifestMod     of lab * path option * path
	| ManifestInf     of lab * mismatch option
	| MismatchVal     of lab * typ * typ
	| MismatchTyp     of lab * tkind * tkind
	| MismatchMod     of lab * mismatch
	| MismatchInf     of lab * mismatch
	| MismatchFix     of lab * fix * fix
	| MismatchValSort of lab * val_sort * val_sort
	| MismatchTypSort of lab * typ_sort * typ_sort
	| MismatchDom     of mismatch
	| MismatchRan     of mismatch
	| Incompatible    of inf * inf
	| IncompatibleArg of path * path

    exception Mismatch of mismatch



    fun match(j1,j2) =
	let
	    val rea = emptyRea()
	in
	    match'(rea, j1, j2) ;
	    rea
	end

    and match'(rea, _, ref TOP) = ()
      | match'(rea, j1 as ref(CON(_,p1)), j2 as ref(CON(_,p2))) =
	if p1 = p2 then
	    ()
	else
	    raise Mismatch(Incompatible(j1,j2))

      | match'(rea, ref(SIG s1), ref(SIG s2)) = matchSig(rea, s1, s2)

      | match'(rea, ref(FUN(p1,j11,j12)), ref(FUN(p2,j21,j22))) =
	( realise(rea, j21)
	; match'(rea, j21, j11) handle Mismatch mismatch =>
		raise Mismatch(MismatchDom mismatch)
	; realise(rea, j12)
	; match'(rea, j12, j22) handle Mismatch mismatch =>
		raise Mismatch(MismatchRan mismatch)
	)

      | match'(rea, ref(LAMBDA(p1,j11,j12)), ref(LAMBDA(p2,j21,j22))) =
	(*UNFINISHED*)
	    ()

      | match'(rea, ref(APPLY(j11,p1,j12)), ref(APPLY(j21,p2,j22))) =
	( match'(rea, j11, j21)
	; if p1 = p2 then () else
	      raise Mismatch(IncompatibleArg(p1,p2))
	)

      | match'(rea, ref(LINK j1), j2)		= match'(rea, j1, j2)
      | match'(rea, j1, ref(LINK j2))		= match'(rea, j1, j2)
      | match'(rea, ref(ABBREV(_,j1)), j2)	= match'(rea, j1, j2)
      | match'(rea, j1, j2 as ref(ABBREV(j21,j22))) =
	( match'(rea, j1, j22)
(*	; j2 := ABBREV(j21,j1)
*)	)

      | match'(rea, j1,j2) = raise Mismatch(Incompatible(j1,j2))


    and matchSig(rea, (ref items1, m1), s2 as (ref items2, m2)) =
	let
	    val {val_rea, typ_rea, mod_rea, inf_rea} = rea

	    fun pair(m1,      [],      pairs) = List.rev pairs
	      | pair(m1, item2::items, pairs) =
		let
		    val (p,l,n) = itemId item2
		    val  space  = itemSpace item2
		    val  item1  = List.hd(Map.lookupExistent(m1, (space,l)))
		in
		    if p = itemPath item1 then () else
		    case space
		     of VAL' => PathMap.insert(val_rea, p, selectVal(!item1))
		      | TYP' => PathMap.insert(typ_rea, p, selectTyp(!item1))
		      | INF' => PathMap.insert(inf_rea, p, selectInf(!item1))
		      | FIX' => ()
		      | MOD' => let val p1 = selectMod(!item1)
				    val j1 = selectMod'(!item1)
				    val j2 = selectMod'(!item2)
				in
				    PathMap.insert(mod_rea, p, p1) ;
				    matchNested(j1, j2)
				    handle Mismatch mismatch =>
					raise Mismatch(MismatchMod(l, mismatch))
				end ;
		    pair(m1, items, (item1,item2)::pairs)
		end
		handle Map.Lookup (VAL',l) => raise Mismatch(MissingVal l)
		     | Map.Lookup (TYP',l) => raise Mismatch(MissingTyp l)
		     | Map.Lookup (MOD',l) => raise Mismatch(MissingMod l)
		     | Map.Lookup (INF',l) => raise Mismatch(MissingInf l)
		     | Map.Lookup (FIX',l) => raise Mismatch(MissingFix l)

	    (* Necessary to create complete realisation. *)
	    and matchNested(ref(SIG(_,m1)), ref(SIG(ref items2,_))) =
		    ignore(pair(m1, items2, []))
	      | matchNested(ref(FUN _), ref(FUN _)) =
		(*UNFINISHED: when introducing functor paths*) ()
	      | matchNested(ref(LINK j1), j2) = matchNested(j1, j2)
	      | matchNested(j1, ref(LINK j2)) = matchNested(j1, j2)
	      | matchNested(ref(ABBREV(_,j1)), j2) = matchNested(j1, j2)
	      | matchNested(j1, ref(ABBREV(_,j2))) = matchNested(j1, j2)
	      | matchNested _ = ()

	    val pairs = pair(m1, items2, [])
	in
	    realiseSig(rea, s2) ;
	    List.app matchItem pairs
	end

    and matchItem(ref item1', item2 as ref item2') =
	( matchItem'(item1', item2') ; item2 := item1' )

    and matchItem'(VAL(x1,t1,w1,d1), VAL(x2,t2,w2,d2)) =
	let val l = idLab x2 in
	    matchTyp(l, t1, t2) ;
	    matchValSort(l, w1, w2) ;
	    matchValDef(l, d1, d2)
	end
      | matchItem'(TYP(x1,k1,w1,d1), TYP(x2,k2,w2,d2)) =
	let val l = idLab x2 in
	    matchTKind(l, k1, k2) ;
	    matchTypSort(l, w1, w2) ;
	    matchTypDef(l, d1, d2)
	end
      | matchItem'(MOD(x1,j1,d1), MOD(x2,j2,d2)) =
	let val l = idLab x2 in
	    matchInf(l, j1, j2) ;
	    matchModDef(l, d1, d2)
	end
      | matchItem'(INF(x1,k1,d1), INF(x2,k2,d2)) =
	let val l = idLab x2 in
	    matchKind(l, k1, k2) ;
	    matchInfDef(l, d1, d2)
	end
      | matchItem'(FIX(x1,q1), FIX(x2,q2)) =
	let val l = idLab x2 in
	    matchFix(l, q1, q2)
	end
      | matchItem' _ = raise Crash.Crash "Inf.matchItem"

    and matchTyp(l,t1,t2) =
	if Type.matches(t1,t2) then () else
	    raise Mismatch(MismatchVal(l,t1,t2))

    and matchTKind(l,k1,k2) =
	if k1 = k2 then () else
	    raise Mismatch(MismatchTyp(l,k1,k2))

    and matchInf(l,j1,j2) =
	match'(emptyRea(), j1, j2)
	handle Mismatch mismatch =>
	    raise Mismatch(MismatchMod(l, mismatch))

    and matchKind(l,k1,k2) =
	(*UNFINISHED: match contravariant*)
	equaliseKind(k1,k2)
	handle Mismatch mismatch =>
	    raise Mismatch(MismatchInf(l, mismatch))

    and matchFix(l,q1,q2) =
	if q1 = q2 then () else
	    raise Mismatch(MismatchFix(l,q1,q2))

    and matchValSort(l,w1,w2) =
	if w1 = CONSTRUCTOR orelse w2 = VALUE then () else
	    raise Mismatch(MismatchValSort(l, w1, w2))

    and matchTypSort(l,w1,w2) =
	if w1 = OPEN orelse w2 = CLOSED then () else
	    raise Mismatch(MismatchTypSort(l, w1, w2))


    and matchValDef(l, _,    NONE)	= ()
      | matchValDef(l, NONE, SOME p2)	= raise Mismatch(ManifestVal(l,NONE,p2))
      | matchValDef(l, SOME p1, SOME p2) =
	    if p1 = p2 then () else raise Mismatch(ManifestVal(l, SOME p1, p2))

    and matchTypDef(l, _,    NONE)	= ()
      | matchTypDef(l, NONE, SOME t2)	= raise Mismatch(ManifestTyp(l,NONE,t2))
      | matchTypDef(l, SOME t1, SOME t2) =
	    if Type.equals(t1,t2) then () else
		raise Mismatch(ManifestTyp(l, SOME t1, t2))

    and matchModDef(l, _,    NONE)	= ()
      | matchModDef(l, NONE, SOME p2)	= raise Mismatch(ManifestMod(l,NONE,p2))
      | matchModDef(l, SOME p1, SOME p2) =
	    if p1 = p2 then () else raise Mismatch(ManifestMod(l, SOME p1, p2))

    and matchInfDef(l, _,    NONE)	= ()
      | matchInfDef(l, NONE, SOME j2)	= raise Mismatch(ManifestInf(l,NONE))
      | matchInfDef(l, SOME j1, SOME j2) =
	    equalise(j1,j2) handle Mismatch mismatch =>
		raise Mismatch(ManifestInf(l, SOME mismatch))


    and equalise(j1,j2) = (*UNFINISHED*) ()
    and equaliseKind(k1,k2) = (*UNFINISHED*) ()



  (* Intersection *)

    fun intersect(j1,j2) =
	let
	    val j1' = clone j1
	    val j2' = clone j2
	    val rea = emptyRea()
	in
	    intersect'(rea, j1', j2')
	end

    and intersect'(rea, j1, ref TOP) = j1
      | intersect'(rea, ref TOP, j2) = j2
      | intersect'(rea, j1 as ref(CON(_,p1)), j2 as ref(CON(_,p2))) =
	if p1 = p2 then
	    j1
	else
	    raise Mismatch(Incompatible(j1,j2))

      | intersect'(rea, j1 as ref(SIG s1), ref(SIG s2)) =
	    ( intersectSig(rea, s1, s2) ; j1 )

      | intersect'(rea, ref(FUN(p1,j11,j12)), ref(FUN(p2,j21,j22))) =
	(*UNFINISHED*)
	    raise Crash.Crash "Inf.intersect: FUN"

      | intersect'(rea, ref(LAMBDA(p1,j11,j12)), ref(LAMBDA(p2,j21,j22))) =
	(*UNFINISHED*)
	    raise Crash.Crash "Inf.intersect: LAMBDA"

      | intersect'(rea, j1 as ref(APPLY(j11,p1,j12)), ref(APPLY(j21,p2,j22))) =
	(*UNFINISHED*)
	    raise Crash.Crash "Inf.intersect: APPLY"

      | intersect'(rea, ref(LINK j1), j2)	= intersect'(rea, j1, j2)
      | intersect'(rea, j1, ref(LINK j2))	= intersect'(rea, j1, j2)

      | intersect'(rea, j1 as ref(ABBREV(j11,j12)), j2)	=
	(*UNFINISHED: need some node for intersection... *)
	( intersect'(rea, j12, j2)
	; j1 := ABBREV(j11,j2)
	; j1
	)
      | intersect'(rea, j1, j2 as ref(ABBREV(j21,j22))) =
	(*UNFINISHED: need some node for intersection... *)
	( intersect'(rea, j1, j22)
	; j2 := ABBREV(j21,j1)
	; j2
	)
      | intersect'(rea, j1,j2) = raise Mismatch(Incompatible(j1,j2))


    (* UNFINISHED: does ignore dependencies on second argument signature *)

    and intersectSig(rea, s1 as (itemsr1 as ref items1, m1),
			  s2 as (itemsr2 as ref items2, m2)) =
	let
	    fun pairDef(rea', toZ, b, x1, NONE, x2, SOME z) =
		    ( if b then PathMap.insert(rea', idPath x1, z) else ()
		    ; false )
	      | pairDef(rea', toZ, b, x1, SOME z, x2, NONE) =
		    ( if b then PathMap.insert(rea', idPath x2, z) else ()
		    ; true )
	      | pairDef(rea', toZ, b, x1, SOME z1, x2, SOME z2) =
		    ( if b then PathMap.insert(rea', idPath x2, z1) else ()
		    ; true )
	      | pairDef(rea', toZ, b, x1, NONE, x2, NONE) =
		    ( if b then PathMap.insert(rea', idPath x2, toZ(idPath x1))
			   else ()
		    ; true )

	    fun pair1(b, VAL(x1,t1,w1,d1), VAL(x2,t2,w2,d2)) =
		    pairDef(#val_rea rea, pathToPath, b, x1, d1, x2, d2)
	      | pair1(b, TYP(x1,k1,w1,d1), TYP(x2,k2,w2,d2)) =
		    pairDef(#typ_rea rea, pathToTyp k1, b, x1, d1, x2, d2)
	      | pair1(b, MOD(x1,j1,d1), MOD(x2,j2,d2)) =
		    pairDef(#mod_rea rea, pathToPath, b, x1, d1, x2, d2)
		    before pairNested(j1,j2)
	      | pair1(b, INF(x1,k1,d1), INF(x2,k2,d2)) =
		    pairDef(#inf_rea rea, pathToInf k1, b, x1, d1, x2, d2)
	      | pair1(b, FIX(x1,q1), FIX(x2,q2)) =
		    true
	      | pair1 _ =
		    raise Crash.Crash "Inf.intersectSig: pairing"

	    and pair(m1, [], pairs, left) = ( List.rev pairs, List.rev left )
	      | pair(m1, item2::items, pairs, left) =
		case Map.lookup(m1, (itemSpace item2, itemLab item2))
		  of NONE => pair(m1, items, pairs, item2::left)
		   | SOME [] => raise Crash.Crash "Inf.intersectSig: lookup"
		   | SOME(item1::_) =>
		     (* Nested structures are already realised.
		      * We would loop during realisation if we inserted
		      * identity realisations. *)
		     ( if pair1(itemPath item1 <> itemPath item2,
				!item1, !item2) then () else
			  Misc.General_swap(item1, item2)
		     ; pair(m1, items, (item1,item2)::pairs, left)
		     )

	    (* Necessary to create complete realisation. *)
	    and pairNested(ref(SIG(_,m1)), ref(SIG(ref items2,_))) =
		    ignore(pair(m1, items2, [], []))
	      | pairNested(ref(FUN _), ref(FUN _)) =
		(*UNFINISHED: when introducing functor paths*) ()
	      | pairNested(ref(LINK j1), j2) = pairNested(j1, j2)
	      | pairNested(j1, ref(LINK j2)) = pairNested(j1, j2)
	      | pairNested(ref(ABBREV(_,j1)), j2) = pairNested(j1, j2)
	      | pairNested(j1, ref(ABBREV(_,j2))) = pairNested(j1, j2)
	      | pairNested _ = ()

	    val (pairs,left) = pair(m1, items2, [], [])
	in
	    realiseSig(rea, s1) ;
	    realiseSig(rea, s2) ;
	    List.app (intersectItem rea) pairs ;
	    itemsr1 := items1 @ left ;
	    itemsr2 := !itemsr1
	end
    and intersectItem rea (item1 as ref item1', ref item2') =
	    item1 := intersectItem'(rea, item1', item2')

    and intersectItem'(rea, VAL(x1,t1,w1,d1), VAL(x2,t2,w2,d2)) =
	let
	    val l = idLab x1
	    val t = intersectTyp(l, t1, t2)
	    val w = intersectValSort(l, w1, w2)
	    val d = intersectValDef(l, d1, d2)
	in
	    VAL(x1,t,w,d)
	end
      | intersectItem'(rea, TYP(x1,k1,w1,d1), TYP(x2,k2,w2,d2)) =
	let
	    val l = idLab x1
	    val k = intersectTKind(l, k1, k2)
	    val w = intersectTypSort(l, w1, w2)
	    val d = intersectTypDef(l, d1, d2)
	in
	    TYP(x1,k,w,d)
	end
      | intersectItem'(rea, MOD(x1,j1,d1), MOD(x2,j2,d2)) =
	let
	    val l = idLab x1
	    val j = intersectInf(l, j1, j2)
	    val d = intersectModDef(l, d1, d2)
	in
	    MOD(x1,j,d)
	end
      | intersectItem'(rea, INF(x1,k1,d1), INF(x2,k2,d2)) =
	let
	    val l = idLab x1
	    val k = intersectKind(l, k1, k2)
	    val d = intersectInfDef(l, d1, d2)
	in
	    INF(x1,k,d)
	end
      | intersectItem'(rea, FIX(x1,q1), FIX(x2,q2)) =
	let
	    val l = idLab x1
	    val q = intersectFix(l, q1, q2)
	in
	    FIX(x1,q)
	end
      | intersectItem' _ = raise Crash.Crash "Inf.intersectItem"

    and intersectTyp(l,t1,t2) =
	( Type.intersect(t1,t2) ; t1 )
	handle Type.Intersect =>
	    raise Mismatch(MismatchVal(l,t1,t2))

    and intersectTKind(l,k1,k2) =
	if k1 = k2 then k1 else
	    raise Mismatch(MismatchTyp(l,k1,k2))

    and intersectInf(l,j1,j2) =
	intersect'(emptyRea(), j1, j2)
	handle Mismatch mismatch =>
	    raise Mismatch(MismatchMod(l, mismatch))

    and intersectKind(l,k1,k2) =
	( equaliseKind(k1,k2) ; k1 )
	handle Mismatch mismatch =>
	    raise Mismatch(MismatchInf(l, mismatch))

    and intersectFix(l,q1,q2) =
	if q1 = q2 then q1 else
	    raise Mismatch(MismatchFix(l,q1,q2))

    and intersectValSort(l,w1,w2) =
	if w1 = CONSTRUCTOR orelse w2 = CONSTRUCTOR then
	    CONSTRUCTOR
	else
	    VALUE

    and intersectTypSort(l,w1,w2) =
	if w1 = OPEN orelse w2 = OPEN then
	    OPEN
	else
	    CLOSED


    and intersectValDef(l, NONE,    NONE)	= NONE
      | intersectValDef(l, SOME p1, NONE)	= SOME p1
      | intersectValDef(l, NONE,    SOME p2)	= SOME p2
      | intersectValDef(l, SOME p1, SOME p2)	=
	    if p1 = p2 then SOME p1 else
		raise Mismatch(ManifestVal(l, SOME p1, p2))

    and intersectTypDef(l, NONE,    NONE)	= NONE
      | intersectTypDef(l, SOME t1, NONE)	= SOME t1
      | intersectTypDef(l, NONE,    SOME t2)	= SOME t2
      | intersectTypDef(l, SOME t1, SOME t2)	=
	    if Type.equals(t1,t2) then SOME t1 else
		raise Mismatch(ManifestTyp(l, SOME t1, t2))

    and intersectModDef(l, NONE,    NONE)	= NONE
      | intersectModDef(l, SOME p1, NONE)	= SOME p1
      | intersectModDef(l, NONE,    SOME p2)	= SOME p2
      | intersectModDef(l, SOME p1, SOME p2)	=
	    if p1 = p2 then SOME p1 else
		raise Mismatch(ManifestMod(l, SOME p1, p2))

    and intersectInfDef(l, NONE,    NONE)	= NONE
      | intersectInfDef(l, SOME j1, NONE)	= SOME j1
      | intersectInfDef(l, NONE,    SOME j2)	= SOME j2
      | intersectInfDef(l, SOME j1, SOME j2)	=
	    ( equalise(j1,j2) ; SOME j1 ) handle Mismatch mismatch =>
		raise Mismatch(ManifestInf(l, SOME mismatch))
  end


structure Inf : INF = InfPrivate
(* src # 74 ../frontend-common/ABSTRACT_GRAMMAR.sig *)
signature ABSTRACT_GRAMMAR =
  sig

    (* Generic *)

    type fix_info
    type lab_info
    type id_info
    type longid_info
    type exp_info
    type pat_info
    type 'a row_info
    type 'a field_info
    type match_info
    type typ_info
    type con_info
    type mod_info
    type inf_info
    type dec_info
    type spec_info
    type imp_info
    type ann_info
    type comp_info

    (* Literals *)

    datatype lit =
	  WordLit   of LargeWord.word		(* word *)
	| IntLit    of LargeInt.int		(* integer *)
	| CharLit   of WideChar.char		(* character *)
	| StringLit of WideString.string	(* string *)
	| RealLit   of LargeReal.real		(* floating point *)

    (* Fixity *)

    datatype fix = Fix of fix_info * Fixity.t

    (* Identifiers *)

    datatype lab    = Lab     of lab_info * Label.t
    datatype id     = Id      of id_info * Stamp.t * Name.t
    datatype longid = ShortId of longid_info * id
		    | LongId  of longid_info * longid * lab

    (* Expressions *)

    datatype exp =
	  LitExp    of exp_info * lit		(* literal *)
	| PrimExp   of exp_info * string * typ	(* builtin values *)
	| VarExp    of exp_info * longid	(* variable *)
	| TagExp    of exp_info * lab * int	(* tag (constructor) *)
	| ConExp    of exp_info * longid * int	(* (generative) constructor *)
	| RefExp    of exp_info			(* reference constructor *)
	| TupExp    of exp_info * exp list	(* tuple *)
	| ProdExp   of exp_info * exp row	(* row (record) *)
	| SelExp    of exp_info * lab		(* row selector *)
	| VecExp    of exp_info * exp list	(* vector *)
	| FunExp    of exp_info * match list	(* function *)
	| AppExp    of exp_info * exp * exp	(* application *)
	| CompExp   of exp_info * exp * exp	(* adjunction *)
	| AndExp    of exp_info * exp * exp	(* short-circuit conjunction *)
	| OrExp     of exp_info * exp * exp	(* short-circuit disjunction *)
	| IfExp     of exp_info * exp * exp * exp (* conditional *)
	| WhileExp  of exp_info * exp * exp	(* while loop *)
	| SeqExp    of exp_info * exp list	(* sequential expressions *)
	| CaseExp   of exp_info * exp * match list (* case *)
	| RaiseExp  of exp_info * exp		(* exception raising *)
	| HandleExp of exp_info * exp * match list (* exception handling *)
	| AnnExp    of exp_info * exp * typ	(* type annotation *)
	| LetExp    of exp_info * dec list * exp (* let *)
	| PackExp   of exp_info * mod		(* package introduction *)

    and 'a row   = Row   of 'a row_info * 'a field list * bool
    and 'a field = Field of 'a field_info * lab * 'a list

    and match    = Match of match_info * pat * exp

    (* Patterns *)

    and pat =
	  JokPat    of pat_info			(* joker (wildcard) *)
	| LitPat    of pat_info * lit		(* literal *)
	| VarPat    of pat_info * id		(* variable *)
	| TagPat    of pat_info * lab * int	(* tag (fully applied) *)
	| ConPat    of pat_info * longid * int	(* constructor (fully applied)*)
	| RefPat    of pat_info			(* reference (fully applied) *)
	| TupPat    of pat_info * pat list	(* tuple *)
	| ProdPat   of pat_info * pat row	(* row (record) *)
	| VecPat    of pat_info * pat list	(* vector *)
	| AppPat    of pat_info * pat * pat	(* constructor application *)
	| AsPat     of pat_info * pat * pat	(* as (layered) pattern *)
	| AltPat    of pat_info * pat list	(* alternative pattern *)
	| NegPat    of pat_info * pat		(* negated pattern *)
	| GuardPat  of pat_info * pat * exp	(* guarded pattern *)
	| AnnPat    of pat_info * pat * typ	(* type annotation *)
	| WithPat   of pat_info * pat * dec list (* local declarations *)

    (* Types *)

    and typ =
	  VarTyp    of typ_info * id		(* variable *)
	| ConTyp    of typ_info * longid	(* constructor *)
	| FunTyp    of typ_info * id * typ	(* type function *)
	| AppTyp    of typ_info * typ * typ	(* constructor application *)
	| RefTyp    of typ_info * typ		(* reference type *)
	| TupTyp    of typ_info * typ list	(* tuple (cartesian) type *)
	| ProdTyp   of typ_info * typ row	(* product (record) type *)
	| SumTyp    of typ_info * typ row	(* sum type (datatype) *)
	| ArrTyp    of typ_info * typ * typ	(* arrow (function) type *)
	| AllTyp    of typ_info * id * typ	(* universal quantification *)
	| ExTyp     of typ_info * id * typ	(* existential quantification *)
	| PackTyp   of typ_info * inf		(* package type *)
	| SingTyp   of typ_info * longid	(* singleton type *)
	| AbsTyp    of typ_info			(* abstract type *)
	| ExtTyp    of typ_info			(* extensible sum type *)

    (* Modules *)

    and mod =
	  PrimMod   of mod_info * string * inf	(* builtin modules *)
	| VarMod    of mod_info * id		(* module id *)
	| StrMod    of mod_info * dec list	(* structure *)
	| SelMod    of mod_info * mod * lab	(* selection *)
	| FunMod    of mod_info * id * inf * mod (* functor *)
	| AppMod    of mod_info * mod * mod	(* application *)
	| AnnMod    of mod_info * mod * inf	(* annotation *)
	| UpMod     of mod_info * mod * inf	(* coercion *)
	| LetMod    of mod_info * dec list * mod (* let *)
	| UnpackMod of mod_info * exp * inf	(* package elimination *)

    (* Interfaces *)

    and inf =
	  TopInf    of inf_info			(* top interface *)
	| ConInf    of inf_info * longid	(* interface constructor *)
	| SigInf    of inf_info * spec list	(* signature *)
	| FunInf    of inf_info * id * inf * inf (* interface function *)
	| AppInf    of inf_info * inf * mod	(* interface application *)
	| CompInf   of inf_info * inf * inf	(* composition *)
	| ArrInf    of inf_info * id * inf * inf (* arrow (functor) interface *)
	| LetInf    of inf_info * dec list * inf (* let *)
	| SingInf   of inf_info * mod		(* singleton interface *)
	| AbsInf    of inf_info			(* abstract interface *)

    (* Declarations *)

    and dec =
	  ValDec    of dec_info * pat * exp	(* values *)
	| ConDec    of dec_info * id * typ * int (* constructor *)
	| TypDec    of dec_info * id * typ	(* type *)
	| ModDec    of dec_info * id * mod	(* module *)
	| InfDec    of dec_info * id * inf	(* interface *)
	| FixDec    of dec_info * id * fix	(* fixity *)
	| VarDec    of dec_info * id * dec	(* scoped type variable *)
	| RecDec    of dec_info * dec list	(* recursive declarations *)
	| LocalDec  of dec_info * dec list	(* local declarations *)

    (* Specifications *)

    and spec =
	  ValSpec   of spec_info * id * typ	(* value *)
	| ConSpec   of spec_info * id * typ * int (* constructor *)
	| TypSpec   of spec_info * id * typ	(* type *)
	| ModSpec   of spec_info * id * inf	(* module *)
	| InfSpec   of spec_info * id * inf	(* interface *)
	| FixSpec   of spec_info * id * fix	(* fixity *)
	| RecSpec   of spec_info * spec list	(* recursive specifications *)
	| ExtSpec   of spec_info * inf		(* extension (include) *)

    (* Import *)

    and imp =
	  ValImp of imp_info * id * (typ_info,typ) desc	(* value *)
	| ConImp of imp_info * id * (typ_info,typ) desc * int (* constructor *)
	| TypImp of imp_info * id * (typ_info,typ) desc (* type *)
	| ModImp of imp_info * id * (inf_info,inf) desc (* module *)
	| InfImp of imp_info * id * (inf_info,inf) desc (* interface *)
	| FixImp of imp_info * id * (fix_info,fix) desc (* fixity *)
	| RecImp of imp_info * imp list			(* recursive items *)

    and ('info,'a) desc =
	  NoDesc   of 'info
	| SomeDesc of 'info * 'a

    (* Components *)

    and ann  = ImpAnn of ann_info * imp list * Url.t

    and comp = Comp of comp_info * ann list * dec list

    type t = comp


    (* Operations *)

    val stamp :		id	-> Stamp.t
    val name :		id	-> Name.t
    val lab :		lab	-> Label.t
    val idToLab :	id	-> lab
    val labToId :	lab	-> id

    val infoLab :	lab	-> lab_info
    val infoId :	id	-> id_info
    val infoLongid :	longid	-> longid_info
    val infoExp :	exp	-> exp_info
    val infoRow :	'a row	-> 'a row_info
    val infoField :	'a field -> 'a field_info
    val infoMatch :	match	-> match_info
    val infoPat :	pat	-> pat_info
    val infoTyp :	typ	-> typ_info
    val infoMod :	mod	-> mod_info
    val infoInf :	inf	-> inf_info
    val infoDec :	dec	-> dec_info
    val infoSpec :	spec	-> spec_info
    val infoImp :	imp	-> imp_info
    val infoAnn :	ann	-> ann_info
    val infoDesc :	('a,'b) desc -> 'a
    val infoComp :	comp	-> comp_info

  end
(* src # 75 ../frontend-common/MakeAbstractGrammar.sml *)
functor MakeAbstractGrammar(type fix_info
			    type lab_info
			    type id_info
			    type longid_info
			    type exp_info
			    type pat_info
			    type 'a row_info
			    type 'a field_info
			    type match_info
			    type typ_info
			    type con_info
			    type mod_info
			    type inf_info
			    type dec_info
			    type spec_info
			    type imp_info
			    type ann_info
			    type comp_info
			    val labToIdInfo: lab_info -> id_info
			    val idToLabInfo: id_info -> lab_info
			   ) : ABSTRACT_GRAMMAR =
  struct

    (* Generic *)

    type fix_info	= fix_info
    type lab_info	= lab_info
    type id_info	= id_info
    type longid_info	= longid_info
    type exp_info	= exp_info
    type pat_info	= pat_info
    type 'a row_info	= 'a row_info
    type 'a field_info	= 'a field_info
    type match_info	= match_info
    type typ_info	= typ_info
    type con_info	= con_info
    type mod_info	= mod_info
    type inf_info	= inf_info
    type dec_info	= dec_info
    type spec_info	= spec_info
    type imp_info	= imp_info
    type ann_info	= ann_info
    type comp_info	= comp_info

    (* Literals *)

    datatype lit =
	  WordLit   of LargeWord.word		(* word *)
	| IntLit    of LargeInt.int		(* integer *)
	| CharLit   of WideChar.char		(* character *)
	| StringLit of WideString.string	(* string *)
	| RealLit   of LargeReal.real		(* floating point *)

    (* Fixity *)

    datatype fix = Fix of fix_info * Fixity.t

    (* Identifiers *)

    datatype lab    = Lab     of lab_info * Label.t
    datatype id     = Id      of id_info * Stamp.t * Name.t
    datatype longid = ShortId of longid_info * id
		    | LongId  of longid_info * longid * lab

    (* Expressions *)

    datatype exp =
	  LitExp    of exp_info * lit		(* literal *)
	| PrimExp   of exp_info * string * typ	(* builtin values *)
	| VarExp    of exp_info * longid	(* variable *)
	| TagExp    of exp_info * lab * int	(* tag (constructor) *)
	| ConExp    of exp_info * longid * int	(* (generative) constructor *)
	| RefExp    of exp_info			(* reference constructor *)
	| TupExp    of exp_info * exp list	(* tuple *)
	| ProdExp   of exp_info * exp row	(* row (record) *)
	| SelExp    of exp_info * lab		(* row selector *)
	| VecExp    of exp_info * exp list	(* vector *)
	| FunExp    of exp_info * match list	(* function *)
	| AppExp    of exp_info * exp * exp	(* application *)
	| CompExp   of exp_info * exp * exp	(* adjunction *)
	| AndExp    of exp_info * exp * exp	(* short-circuit conjunction *)
	| OrExp     of exp_info * exp * exp	(* short-circuit disjunction *)
	| IfExp     of exp_info * exp * exp * exp (* conditional *)
	| WhileExp  of exp_info * exp * exp	(* while loop *)
	| SeqExp    of exp_info * exp list	(* sequential expressions *)
	| CaseExp   of exp_info * exp * match list (* case *)
	| RaiseExp  of exp_info * exp		(* exception raising *)
	| HandleExp of exp_info * exp * match list (* exception handling *)
	| AnnExp    of exp_info * exp * typ	(* type annotation *)
	| LetExp    of exp_info * dec list * exp (* let *)
	| PackExp   of exp_info * mod		(* package introduction *)

    and 'a row   = Row   of 'a row_info * 'a field list * bool
    and 'a field = Field of 'a field_info * lab * 'a list

    and match    = Match of match_info * pat * exp

    (* Patterns *)

    and pat =
	  JokPat    of pat_info			(* joker (wildcard) *)
	| LitPat    of pat_info * lit		(* literal *)
	| VarPat    of pat_info * id		(* variable *)
	| TagPat    of pat_info * lab * int	(* tag (fully applied) *)
	| ConPat    of pat_info * longid * int	(* constructor (fully applied)*)
	| RefPat    of pat_info			(* reference (fully applied) *)
	| TupPat    of pat_info * pat list	(* tuple *)
	| ProdPat   of pat_info * pat row	(* row (record) *)
	| VecPat    of pat_info * pat list	(* vector *)
	| AppPat    of pat_info * pat * pat	(* constructor application *)
	| AsPat     of pat_info * pat * pat	(* as (layered) pattern *)
	| AltPat    of pat_info * pat list	(* alternative pattern *)
	| NegPat    of pat_info * pat		(* negated pattern *)
	| GuardPat  of pat_info * pat * exp	(* guarded pattern *)
	| AnnPat    of pat_info * pat * typ	(* type annotation *)
	| WithPat   of pat_info * pat * dec list (* local declarations *)

    (* Types *)

    and typ =
	  VarTyp    of typ_info * id		(* variable *)
	| ConTyp    of typ_info * longid	(* constructor *)
	| FunTyp    of typ_info * id * typ	(* type function *)
	| AppTyp    of typ_info * typ * typ	(* constructor application *)
	| RefTyp    of typ_info * typ		(* reference type *)
	| TupTyp    of typ_info * typ list	(* tuple (cartesian) type *)
	| ProdTyp   of typ_info * typ row	(* row (record) type *)
	| ArrTyp    of typ_info * typ * typ	(* arrow (function) type *)
	| SumTyp    of typ_info * typ row	(* sum type (datatype) *)
	| AllTyp    of typ_info * id * typ	(* universal quantification *)
	| ExTyp     of typ_info * id * typ	(* existential quantification *)
	| PackTyp   of typ_info * inf		(* package type *)
	| SingTyp   of typ_info * longid	(* singleton type *)
	| AbsTyp    of typ_info			(* abstract type *)
	| ExtTyp    of typ_info			(* extensible sum type *)

    and con =   Con of con_info * id * typ list	(* data constructor *)

    (* Modules *)

    and mod =
	  PrimMod   of mod_info * string * inf	(* builtin modules *)
	| VarMod    of mod_info * id		(* module id *)
	| StrMod    of mod_info * dec list	(* structure *)
	| SelMod    of mod_info * mod * lab	(* selection *)
	| FunMod    of mod_info * id * inf * mod (* functor *)
	| AppMod    of mod_info * mod * mod	(* application *)
	| AnnMod    of mod_info * mod * inf	(* annotation *)
	| UpMod     of mod_info * mod * inf	(* coercion *)
	| LetMod    of mod_info * dec list * mod (* let *)
	| UnpackMod of mod_info * exp * inf	(* package elimination *)

    (* Interfaces *)

    and inf =
	  TopInf    of inf_info			(* top interface *)
	| ConInf    of inf_info * longid	(* interface constructor *)
	| SigInf    of inf_info * spec list	(* signature *)
	| FunInf    of inf_info * id * inf * inf (* interface function *)
	| AppInf    of inf_info * inf * mod	(* interface application *)
	| CompInf   of inf_info * inf * inf	(* composition *)
	| ArrInf    of inf_info * id * inf * inf (* arrow (functor) interface *)
	| LetInf    of inf_info * dec list * inf (* let *)
	| SingInf   of inf_info * mod		(* singleton interface *)
	| AbsInf    of inf_info			(* abstract interface *)

    (* Declarations *)

    and dec =
	  ValDec    of dec_info * pat * exp	(* values *)
	| ConDec    of dec_info * id * typ * int (* constructor *)
	| TypDec    of dec_info * id * typ	(* type *)
	| ModDec    of dec_info * id * mod	(* module *)
	| InfDec    of dec_info * id * inf	(* interface *)
	| FixDec    of dec_info * id * fix	(* fixity *)
	| VarDec    of dec_info * id * dec	(* scoped type variable *)
	| RecDec    of dec_info * dec list	(* recursive declarations *)
	| LocalDec  of dec_info * dec list	(* local declarations *)

    (* Specifications *)

    and spec =
	  ValSpec   of spec_info * id * typ	(* value *)
	| ConSpec   of spec_info * id * typ * int (* constructor *)
	| TypSpec   of spec_info * id * typ	(* type *)
	| ModSpec   of spec_info * id * inf	(* module *)
	| InfSpec   of spec_info * id * inf	(* interface *)
	| FixSpec   of spec_info * id * fix	(* fixity *)
	| RecSpec   of spec_info * spec list	(* recursive specifications *)
	| ExtSpec   of spec_info * inf		(* extension (include) *)

    (* Import *)

    and imp =
	  ValImp of imp_info * id * (typ_info,typ) desc	(* value *)
	| ConImp of imp_info * id * (typ_info,typ) desc * int (* constructor *)
	| TypImp of imp_info * id * (typ_info,typ) desc (* type *)
	| ModImp of imp_info * id * (inf_info,inf) desc (* module *)
	| InfImp of imp_info * id * (inf_info,inf) desc (* interface *)
	| FixImp of imp_info * id * (fix_info,fix) desc (* fixity *)
	| RecImp of imp_info * imp list			(* recursive items *)

    and ('info,'a) desc =
	  NoDesc   of 'info
	| SomeDesc of 'info * 'a

    (* Components *)

    and ann  = ImpAnn of ann_info * imp list * Url.t

    and comp = Comp of comp_info * ann list * dec list

    type t = comp


    (* Projections *)

    fun stamp(Id(_,x,_))	= x
    fun name(Id(_,_,n))		= n
    fun lab(Lab(_,a))		= a

    fun labToId(Lab(i,l))	= Id(labToIdInfo i, Stamp.new(), Label.toName l)
    fun idToLab(Id(i,_,n))	= Lab(idToLabInfo i, Label.fromName n)

    fun infoLab(Lab(i,_))		= i
    fun infoId(Id(i,_,_))		= i
    fun infoLongid(ShortId(i,_))	= i
      | infoLongid(LongId(i,_,_))	= i

    fun infoExp(LitExp(i,_))		= i
      | infoExp(PrimExp(i,_,_))		= i
      | infoExp(VarExp(i,_))		= i
      | infoExp(TagExp(i,_,_))		= i
      | infoExp(ConExp(i,_,_))		= i
      | infoExp(RefExp(i))		= i
      | infoExp(TupExp(i,_))		= i
      | infoExp(ProdExp(i,_))		= i
      | infoExp(SelExp(i,_))		= i
      | infoExp(VecExp(i,_))		= i
      | infoExp(FunExp(i,_))		= i
      | infoExp(AppExp(i,_,_))		= i
      | infoExp(CompExp(i,_,_))		= i
      | infoExp(AndExp(i,_,_))		= i
      | infoExp(OrExp(i,_,_))		= i
      | infoExp(IfExp(i,_,_,_))		= i
      | infoExp(WhileExp(i,_,_))	= i
      | infoExp(SeqExp(i,_))		= i
      | infoExp(CaseExp(i,_,_))		= i
      | infoExp(RaiseExp(i,_))		= i
      | infoExp(HandleExp(i,_,_))	= i
      | infoExp(AnnExp(i,_,_))		= i
      | infoExp(LetExp(i,_,_))		= i
      | infoExp(PackExp(i,_))		= i

    fun infoRow(Row(i,_,_))		= i
    fun infoField(Field(i,_,_))		= i
    fun infoMatch(Match(i,_,_))		= i

    fun infoPat(JokPat(i))		= i
      | infoPat(LitPat(i,_))		= i
      | infoPat(VarPat(i,_))		= i
      | infoPat(TagPat(i,_,_))		= i
      | infoPat(ConPat(i,_,_))		= i
      | infoPat(RefPat(i))		= i
      | infoPat(TupPat(i,_))		= i
      | infoPat(ProdPat(i,_))		= i
      | infoPat(VecPat(i,_))		= i
      | infoPat(AppPat(i,_,_))		= i
      | infoPat(AsPat(i,_,_))		= i
      | infoPat(AltPat(i,_))		= i
      | infoPat(NegPat(i,_))		= i
      | infoPat(GuardPat(i,_,_))	= i
      | infoPat(AnnPat(i,_,_))		= i
      | infoPat(WithPat(i,_,_))		= i

    fun infoTyp(VarTyp(i,_))		= i
      | infoTyp(ConTyp(i,_))		= i
      | infoTyp(FunTyp(i,_,_))		= i
      | infoTyp(AppTyp(i,_,_))		= i
      | infoTyp(RefTyp(i,_))		= i
      | infoTyp(TupTyp(i,_))		= i
      | infoTyp(ProdTyp(i,_))		= i
      | infoTyp(SumTyp(i,_))		= i
      | infoTyp(ArrTyp(i,_,_))		= i
      | infoTyp(AllTyp(i,_,_))		= i
      | infoTyp(ExTyp(i,_,_))		= i
      | infoTyp(PackTyp(i,_))		= i
      | infoTyp(SingTyp(i,_))		= i
      | infoTyp(ExtTyp(i))		= i
      | infoTyp(AbsTyp(i))		= i

    fun infoMod(PrimMod(i,_,_))		= i
      | infoMod(VarMod(i,_))		= i
      | infoMod(StrMod(i,_))		= i
      | infoMod(SelMod(i,_,_))		= i
      | infoMod(FunMod(i,_,_,_))	= i
      | infoMod(AppMod(i,_,_))		= i
      | infoMod(AnnMod(i,_,_))		= i
      | infoMod(UpMod(i,_,_))		= i
      | infoMod(LetMod(i,_,_))		= i
      | infoMod(UnpackMod(i,_,_))	= i

    fun infoInf(TopInf(i))		= i
      | infoInf(ConInf(i,_))		= i
      | infoInf(SigInf(i,_))		= i
      | infoInf(FunInf(i,_,_,_))	= i
      | infoInf(AppInf(i,_,_))		= i
      | infoInf(CompInf(i,_,_))		= i
      | infoInf(ArrInf(i,_,_,_))	= i
      | infoInf(LetInf(i,_,_))		= i
      | infoInf(SingInf(i,_))		= i
      | infoInf(AbsInf(i))		= i

    fun infoDec(ValDec(i,_,_))		= i
      | infoDec(ConDec(i,_,_,_))	= i
      | infoDec(TypDec(i,_,_))		= i
      | infoDec(ModDec(i,_,_))		= i
      | infoDec(InfDec(i,_,_))		= i
      | infoDec(FixDec(i,_,_))		= i
      | infoDec(VarDec(i,_,_))		= i
      | infoDec(RecDec(i,_))		= i
      | infoDec(LocalDec(i,_))		= i

    fun infoSpec(ValSpec(i,_,_))	= i
      | infoSpec(ConSpec(i,_,_,_))	= i
      | infoSpec(TypSpec(i,_,_))	= i
      | infoSpec(ModSpec(i,_,_))	= i
      | infoSpec(InfSpec(i,_,_))	= i
      | infoSpec(FixSpec(i,_,_))	= i
      | infoSpec(RecSpec(i,_))		= i
      | infoSpec(ExtSpec(i,_))		= i

    fun infoImp(ValImp(i,_,_))		= i
      | infoImp(ConImp(i,_,_,_))	= i
      | infoImp(TypImp(i,_,_))		= i
      | infoImp(ModImp(i,_,_))		= i
      | infoImp(InfImp(i,_,_))		= i
      | infoImp(FixImp(i,_,_))		= i
      | infoImp(RecImp(i,_))		= i

    fun infoAnn(ImpAnn(i,_,_))		= i

    fun infoDesc(NoDesc(i))		= i
      | infoDesc(SomeDesc(i,_))		= i

    fun infoComp(Comp(i,_,_))		= i

  end
(* src # 76 ../frontend-common/AbstractGrammar.sml *)
structure AbstractInfo =
  struct
    type fix_info	= Source.region
    type lab_info	= Source.region
    type id_info	= Source.region
    type longid_info	= Source.region
    type exp_info	= Source.region
    type pat_info	= Source.region
    type 'a row_info	= Source.region
    type 'a field_info	= Source.region
    type match_info	= Source.region
    type typ_info	= Source.region
    type con_info	= Source.region
    type mod_info	= Source.region
    type inf_info	= Source.region
    type dec_info	= Source.region
    type spec_info	= Source.region
    type imp_info	= Source.region
    type ann_info	= Source.region
    type comp_info	= Source.region

    fun labToIdInfo r	= r
    fun idToLabInfo r	= r
  end

structure AbstractGrammar = MakeAbstractGrammar(AbstractInfo)
(* src # 77 ../frontend-common/TypedGrammar.sml *)
structure TypedInfo =
  struct
    type fix_info	= { region: Source.region, fix: Fixity.t }
    type lab_info	= { region: Source.region }
    type id_info	= { region: Source.region }
    type longid_info	= { region: Source.region }
    type exp_info	= { region: Source.region, typ: Type.t }
    type pat_info	= { region: Source.region, typ: Type.t }
    type 'a row_info	= { region: Source.region }
    type 'a field_info	= { region: Source.region }
    type match_info	= { region: Source.region }
    type typ_info	= { region: Source.region, typ: Type.t }
    type con_info	= { region: Source.region, typ: Type.t }
    type mod_info	= { region: Source.region, inf: Inf.t }
    type inf_info	= { region: Source.region, inf: Inf.t }
    type dec_info	= { region: Source.region }
    type spec_info	= { region: Source.region }
    type imp_info	= { region: Source.region }
    type ann_info	= { region: Source.region }
    type comp_info	= { region: Source.region }

    fun labToIdInfo i	= i
    fun idToLabInfo i	= i

    fun nonInfo r	= { region = r }
    fun fixInfo(r,f)	= { region = r, fix = f }
    fun typInfo(r,t)	= { region = r, typ = t }
    fun infInfo(r,j)	= { region = r, inf = j }
  end

structure TypedGrammar = MakeAbstractGrammar(TypedInfo)
(* src # 78 ../frontend-common/ENV.sig *)
signature ENV =
  sig

    type id    = AbstractGrammar.id
    type stamp = Stamp.t
    type path  = Path.t
    type typ   = Type.t
    type var   = Type.var
    type inf   = Inf.t

    type env
    type t = env

    type val_entry = { id: id, path: path, typ: typ, sort: Inf.val_sort }
    type typ_entry = { id: id, path: path, typ: typ, sort: Inf.typ_sort }
    type var_entry = { id: id, var: var }
    type mod_entry = { id: id, path: path, inf: inf }
    type inf_entry = { id: id, path: path, inf: inf }

    exception Collision of stamp
    exception Lookup    of stamp

    val new :		unit -> env
    val clone :		env -> env
    val cloneScope :	env -> env
    val splitScope :	env -> env
    val insertScope :	env -> unit
    val deleteScope :	env -> unit
    val mergeScope :	env -> unit

    val union :		env * env -> unit		(* Collision *)

    val insertVal :	env * stamp * val_entry -> unit	(* Collision *)
    val insertTyp :	env * stamp * typ_entry -> unit	(* Collision *)
    val insertVar :	env * stamp * var_entry -> unit	(* Collision *)
    val insertMod :	env * stamp * mod_entry -> unit	(* Collision *)
    val insertInf :	env * stamp * inf_entry -> unit	(* Collision *)

    val lookupVal :	env * stamp -> val_entry	(* Lookup *)
    val lookupTyp :	env * stamp -> typ_entry	(* Lookup *)
    val lookupVar :	env * stamp -> var_entry	(* Lookup *)
    val lookupMod :	env * stamp -> mod_entry	(* Lookup *)
    val lookupInf :	env * stamp -> inf_entry	(* Lookup *)

    val appVals :	(stamp * val_entry -> unit) -> env -> unit
    val appTyps :	(stamp * typ_entry -> unit) -> env -> unit
    val appVars :	(stamp * var_entry -> unit) -> env -> unit
    val appMods :	(stamp * mod_entry -> unit) -> env -> unit
    val appInfs :	(stamp * inf_entry -> unit) -> env -> unit

    val foldVals :	(stamp * val_entry * 'a -> 'a) -> 'a -> env -> 'a
    val foldTyps :	(stamp * typ_entry * 'a -> 'a) -> 'a -> env -> 'a
    val foldVars :	(stamp * var_entry * 'a -> 'a) -> 'a -> env -> 'a
    val foldMods :	(stamp * mod_entry * 'a -> 'a) -> 'a -> env -> 'a
    val foldInfs :	(stamp * inf_entry * 'a -> 'a) -> 'a -> env -> 'a

  end
(* src # 79 ../frontend-common/Env.sml *)
structure Env :> ENV =
  struct

    type id    = AbstractGrammar.id
    type stamp = Stamp.t
    type path  = Path.t
    type typ   = Type.t
    type var   = Type.var
    type inf   = Inf.t


    (* The map implementing the environment *)

    structure Map = MakeHashScopedImpMap(Stamp)

    datatype env = ENV of ran Map.t
    and      ran = VAL of val_entry
		 | TYP of typ_entry
		 | VAR of var_entry
		 | MOD of mod_entry
		 | INF of inf_entry

    withtype val_entry = { id: id, path: path, typ: typ, sort: Inf.val_sort }
    and      typ_entry = { id: id, path: path, typ: typ, sort: Inf.typ_sort }
    and      var_entry = { id: id, var: var }
    and      mod_entry = { id: id, path: path, inf: inf }
    and      inf_entry = { id: id, path: path, inf: inf }

    type t = env


    (* Conversions *)

    fun asVal(VAL x) = x | asVal _ = raise Crash.Crash "Env.asVal: inconsistent"
    fun asTyp(TYP x) = x | asTyp _ = raise Crash.Crash "Env.asTyp: inconsistent"
    fun asVar(VAR x) = x | asVar _ = raise Crash.Crash "Env.asVar: inconsistent"
    fun asMod(MOD x) = x | asMod _ = raise Crash.Crash "Env.asMod: inconsistent"
    fun asInf(INF x) = x | asInf _ = raise Crash.Crash "Env.asInf: inconsistent"

    fun appVal f (x, VAL y) = f(x,y) | appVal f _ = ()
    fun appTyp f (x, TYP y) = f(x,y) | appTyp f _ = ()
    fun appVar f (x, VAR y) = f(x,y) | appVar f _ = ()
    fun appMod f (x, MOD y) = f(x,y) | appMod f _ = ()
    fun appInf f (x, INF y) = f(x,y) | appInf f _ = ()

    fun foldVal f (x, VAL y, a) = f(x,y,a) | foldVal f (_,_,a) = a
    fun foldTyp f (x, TYP y, a) = f(x,y,a) | foldTyp f (_,_,a) = a
    fun foldVar f (x, VAR y, a) = f(x,y,a) | foldVar f (_,_,a) = a
    fun foldMod f (x, MOD y, a) = f(x,y,a) | foldMod f (_,_,a) = a
    fun foldInf f (x, INF y, a) = f(x,y,a) | foldInf f (_,_,a) = a


    (* Operation wrappers *)

    exception Collision = Map.Collision
    exception Lookup    = Map.Lookup

    fun new()				= ENV(Map.new())
    fun clone(ENV E)			= ENV(Map.clone E)
    fun cloneScope(ENV E)		= ENV(Map.cloneScope E)
    fun splitScope(ENV E)		= ENV(Map.splitScope E)
    fun insertScope(ENV E)		= Map.insertScope E
    fun deleteScope(ENV E)		= Map.deleteScope E
    fun mergeScope(ENV E)		= Map.mergeScope E

    fun union(ENV E1, ENV E2)		= Map.unionDisjoint(E1,E2)

    fun insertVal(ENV E, x, y)		= Map.insertDisjoint(E, x, VAL y)
(*UNFINISHED: quick hack*)
    fun insertTyp(ENV E, x, y)		= Map.insert(E, x, TYP y)
    fun insertVar(ENV E, x, y)		= Map.insert(E, x, VAR y)
    fun insertMod(ENV E, x, y)		= Map.insertDisjoint(E, x, MOD y)
    fun insertInf(ENV E, x, y)		= Map.insertDisjoint(E, x, INF y)

    fun lookupVal(ENV E, x)		= asVal(Map.lookupExistent(E,x))
    fun lookupTyp(ENV E, x)		= asTyp(Map.lookupExistent(E,x))
    fun lookupVar(ENV E, x)		= asVar(Map.lookupExistent(E,x))
    fun lookupMod(ENV E, x)		= asMod(Map.lookupExistent(E,x))
    fun lookupInf(ENV E, x)		= asInf(Map.lookupExistent(E,x))

    fun appVals f (ENV E)		= Map.appi (appVal f) E
    fun appTyps f (ENV E)		= Map.appi (appTyp f) E
    fun appVars f (ENV E)		= Map.appi (appVar f) E
    fun appMods f (ENV E)		= Map.appi (appMod f) E
    fun appInfs f (ENV E)		= Map.appi (appInf f) E

    fun foldVals f a (ENV E)		= Map.foldi (foldVal f) a E
    fun foldTyps f a (ENV E)		= Map.foldi (foldTyp f) a E
    fun foldVars f a (ENV E)		= Map.foldi (foldVar f) a E
    fun foldMods f a (ENV E)		= Map.foldi (foldMod f) a E
    fun foldInfs f a (ENV E)		= Map.foldi (foldInf f) a E

  end
(* src # 80 ../frontend-common/ENV0.sig *)
signature ENV0 =
  sig
    val E0 :	Env.t
  end
(* src # 81 ../frontend-common/Env0.sml *)
structure Env0 :> ENV0 =
  struct

    open Env
    open Prebound
    open PreboundType

    datatype id   = datatype AbstractGrammar.id
    datatype sort = datatype Type.sort


  (* Prebound *)

    val E0 = new()


  (* Type environment *)

    fun insertTyp'(stamp, path, typ, sort, name) =
	let
	    val entry = { id   = Id(Source.nowhere, stamp, name)
			, path = path
			, typ  = typ
			, sort = sort
			}
	in
	    insertTyp(E0, stamp, entry)
	end

    val _ = insertTyp'(typstamp_int,    typpath_int,    typ_int,    CLOSED,
		       typname_int)
    val _ = insertTyp'(typstamp_word,   typpath_word,   typ_word,   CLOSED,
		       typname_word)
    val _ = insertTyp'(typstamp_char,   typpath_char,   typ_char,   CLOSED,
		       typname_char)
    val _ = insertTyp'(typstamp_string, typpath_string, typ_string, CLOSED,
		       typname_string)
    val _ = insertTyp'(typstamp_real,   typpath_real,   typ_real,   CLOSED,
		       typname_real)
    val _ = insertTyp'(typstamp_bool,   typpath_bool,   typ_bool,   CLOSED,
		       typname_bool)
    val _ = insertTyp'(typstamp_exn,    typpath_exn,    typ_exn,    OPEN,
		       typname_exn)
    val _ = insertTyp'(typstamp_ref,    typpath_ref,    typ_ref,    CLOSED,
		       typname_ref)
    val _ = insertTyp'(typstamp_vec,    typpath_vec,    typ_vec,    CLOSED,
		       typname_vec)
    val _ = insertTyp'(typstamp_list,   typpath_list,   typ_list,   CLOSED,
		       typname_list)


  (* Value environment *)

    fun poly typF =
	let
	    val alpha = Type.var Type.STAR
	in
	    Type.inAll(alpha, typF(Type.inVar alpha))
	end

    val typ_false = typ_bool
    val typ_true  = typ_bool
    val typ_nil   = poly (fn a => Type.inApply(typ_list, a))
    val typ_cons  = poly (fn a => let val listA = Type.inApply(typ_list, a) in
				      Type.inArrow(Type.inTuple[a,listA], listA)
				  end)
    val typ_ref   = poly (fn a => Type.inArrow(a, Type.inApply(typ_ref, a)))
    val typ_match = typ_exn
    val typ_bind  = typ_exn

    fun insertCon'(stamp, path, typ, name) =
	let
	    val entry = { id   = Id(Source.nowhere, stamp, name)
			, path = path
			, typ  = typ
			, sort = Inf.CONSTRUCTOR
			}
	in
	    insertVal(E0, stamp, entry)
	end

    val _ = insertCon'(valstamp_false, valpath_false, typ_false, valname_false)
    val _ = insertCon'(valstamp_true,  valpath_true,  typ_true,  valname_true)
    val _ = insertCon'(valstamp_nil,   valpath_nil,   typ_nil,   valname_nil)
    val _ = insertCon'(valstamp_cons,  valpath_cons,  typ_cons,  valname_cons)
    val _ = insertCon'(valstamp_ref,   valpath_ref,   typ_ref,   valname_ref)
    val _ = insertCon'(valstamp_match, valpath_match, typ_match, valname_match)
    val _ = insertCon'(valstamp_bind,  valpath_bind,  typ_bind,  valname_bind)

  end
(* src # 82 ../frontend-common/PP_INF.sig *)
signature PP_INF =
  sig

    type doc  = PrettyPrint.doc
    type inf  = Inf.inf
    type sign = Inf.sign

    val ppInf :	inf -> doc
    val ppSig : sign -> doc

  end
(* src # 83 ../frontend-common/PPInf.sml *)
structure PPInf :> PP_INF =
  struct

    (* Import *)

    open InfPrivate
    open PrettyPrint
    open PPMisc

    infixr ^^ ^/^


    (* Helpers *)

    fun uncurry(ref(APPLY(j1,p,_))) = let val (j,ps) = uncurry j1
				      in (j,ps@[p]) end
      | uncurry j		    = (j,[])


    (* Simple objects *)

    fun ppLab l		= text(Label.toString l)
    fun ppCon (k,p)	= PPPath.ppPath p


    (* Interfaces *)

    (* Precedence:
     *	0 : binders (LAMBDA(id : inf1) . inf2)
     *	1 : constructed type (inf(path))
     *)

    fun ppInf(ref j') = fbox(below(ppInf' j'))

    and ppInf'(TOP) =
	    text "TOP"

      | ppInf'(CON c) =
	    ppCon c

      | ppInf'(SIG s) =
	    ppSig' s

      | ppInf'(FUN(p,j1,j2)) =
	let
	    val doc = ppBinder("FCT",p,j1,j2)
	in
	    fbox(below doc)
	end

      | ppInf'(LAMBDA(p,j1,j2)) =
	let
	    val doc = ppBinder("LAMBDA",p,j1,j2)
	in
	    fbox(below doc)
	end

      | ppInf'(j' as APPLY _) =
	let
	    val (j,ps) = uncurry(ref j')
	in
	    fbox(nest(List.foldl (fn(p,d) => d ^/^ paren(PPPath.ppPath p))
				 (ppInf j) ps))
	end

      | ppInf'(ABBREV(j1,j2)) =
	    ppInf j1

      | ppInf'(LINK j) =
(*DEBUG
text "@" ^^*)
	    ppInf j

    and ppBinder(s,p,j1,j2) =
	    abox(
		fbox(
		    text s ^^
		    text "(" ^/^
		    below(break ^^
			PPPath.ppPath p ^/^
			text ":" ^^
			nest(break ^^
			    ppInf j1
			)
		    ) ^/^
		    text ")" ^/^
		    text "."
		) ^^
		nest(break ^^
		    ppInf j2
		)
	    )


    (* Signatures *)

    and ppSig' s =
	let
	    val doc = ppSig s
	in
	    abox(below(
		text "sig" ^^
		(if isEmpty doc then
		    empty
		 else
		    nest(vbox(break ^^ doc))
		) ^^ break ^^
		text "end"
	    ))
	end

    and ppSig(ref items, _) = vbox(List.foldl ppItem empty items)

    and ppItem(ref item', doc) = ppItem'(item', doc)

    and ppItem'(VAL((p,l,0), t, w, d), doc) =
	    abox(
		hbox(
		    text(if w = VALUE then "val" else "constructor") ^/^
		    ppLab l ^/^
(*DEBUG
text "(" ^^ PPPath.ppPath p ^^ text ")" ^/^*)
		    text ":"
		) ^^
		nest(break ^^
		    abox(PPType.ppTyp t)
		) ^^
		(case d of NONE => empty | SOME p' =>
		if p' = p then empty else
		nest(break ^^
		    abox(text "=" ^/^ PPPath.ppPath p')
		))
	    ) ^/^ doc

      | ppItem'(TYP((p,l,0), k, w, d), doc) =
	    abox(
		hbox(
		    text(if w = CLOSED then "type" else "datatype") ^/^
		    ppLab l ^/^
(*DEBUG
text "(" ^^ PPPath.ppPath p ^^ text ")" ^/^*)
		    text ":"
		) ^^
		nest(break ^^
		    abox(PPType.ppKind k)
		) ^^
		(case d of NONE => empty | SOME t =>
		if Type.isCon t andalso #3(Type.asCon t) = p then empty else
		nest(break ^^
		    abox(text "=" ^/^ PPType.ppTyp t)
		))
	    ) ^/^ doc

      | ppItem'(MOD((p,l,0), j, d), doc) =
	    abox(
		hbox(
		    text(if isArrow j then "functor" else "structure") ^/^
		    ppLab l ^/^
(*DEBUG
text "(" ^^ PPPath.ppPath p ^^ text ")" ^/^*)
		    text ":"
		) ^^
		nest(break ^^
		    abox(ppInf j)
		) ^^
		(case d of NONE => empty | SOME p' =>
		if p' = p then empty else
		nest(break ^^
		    abox(text "=" ^/^ PPPath.ppPath p')
		))
	    ) ^/^ doc

      | ppItem'(INF((p,l,0), k, d), doc) =
	    abox(
		hbox(
		    text "signature" ^/^
		    ppLab l ^/^
(*DEBUG
text "(" ^^ PPPath.ppPath p ^^ text ")" ^/^*)
		    text ":"
		) ^^
		nest(break ^^
		    abox(ppKind k)
		) ^^
		(case d of NONE => empty | SOME j =>
		if isCon j andalso #2(asCon j) = p then empty else
		nest(break ^^
		    abox(text "=" ^/^ ppInf j)
		))
	    ) ^/^ doc

      | ppItem'(_, doc) = doc		(* hidden item *)


    (* Kinds *)

    and ppKind(ref k') = fbox(below(ppKind' k'))

    and ppKind'(GROUND) =
	    text "*"

      | ppKind'(DEP(p,j,k)) =
	    fbox(below(
		abox(
		    fbox(
			text "PI" ^/^
			text "(" ^^
			below(break ^^
			    PPPath.ppPath p ^/^
			    text ":" ^^
			    nest(break ^^
				ppInf j
			    )
			) ^/^
			text ")" ^/^
			text "."
		    ) ^^
		    nest(break ^^
			ppKind k
		    )
		)
	    ))

  end
(* src # 84 ../frontend-common/ELABORATION_ERROR.sig *)
signature ELABORATION_ERROR =
  sig

    type lab    = Label.t
    type typ    = Type.t
    type var    = Type.var
    type kind   = Type.kind
    type inf	= Inf.t
    type fix    = Fixity.t
    type id     = AbstractGrammar.id
    type longid = AbstractGrammar.longid

    type unify_error  = typ * typ * typ * typ
    type inf_mismatch = Inf.mismatch

    datatype error =
	(* Expressions *)
	  VecExpUnify		of unify_error
	| AppExpFunUnify	of unify_error
	| AppExpArgUnify	of unify_error
	| CompExpNoRow		of typ
	| CompExpUnify		of unify_error
	| AndExpUnify		of unify_error
	| OrExpUnify		of unify_error
	| IfExpCondUnify	of unify_error
	| IfExpBranchUnify	of unify_error
	| WhileExpCondUnify	of unify_error
	| RaiseExpUnify		of unify_error
	| HandleExpUnify	of unify_error
	| AnnExpUnify		of unify_error
	| MatchPatUnify		of unify_error
	| MatchExpUnify		of unify_error
	(* Patterns *)
	| VecPatUnify		of unify_error
	| AppPatArrTyp		of typ
	| AppPatFunUnify	of unify_error
	| AppPatUnify		of unify_error
	| AsPatUnify		of unify_error
	| AltPatUnify		of unify_error
	| GuardPatUnify		of unify_error
	| AnnPatUnify		of unify_error
	(* Types *)
	| StarTypKind		of kind
	| AppTypFunKind		of kind
	| AppTypArgKind		of kind * kind
	| RefTypKind		of kind
	(* Declarations *)
	| ValDecUnify		of unify_error
	| ValDecLift		of id * var
	(* Long ids *)
	| ModLongidInf		of longid * inf
	(* Modules *)
	| StrModUnclosed	of lab * int * typ
	| SelModInf		of inf
	| AppModFunMismatch	of inf
	| AppModArgMismatch	of inf_mismatch
	| AnnModMismatch	of inf_mismatch
	(* Interfaces *)
	| GroundInfKind		of Inf.kind
	| CompInfMismatch	of inf_mismatch
	| SingInfPath
	(* Imports *)
	| ValItemMismatch	of lab * typ * typ
	| ConItemMismatch	of lab * typ * typ
	| TypItemMismatch	of lab * kind * kind
	| ModItemMismatch	of lab * inf_mismatch
	| InfItemMismatch	of lab * inf_mismatch
	| FixItemMismatch	of lab * fix * fix
	(* Components *)
	| CompUnclosed		of lab * int * typ

    datatype warning =
	  NotGeneralized	of id * typ

    val error :	Source.region * error -> 'a
    val warn :	Source.region * warning -> unit

  end
(* src # 85 ../frontend-common/ElaborationError.sml *)
structure ElaborationError :> ELABORATION_ERROR =
  struct

  (* Pretty printer *)

    open PrettyPrint
    open PPMisc

    infixr ^^ ^/^

  (* Types *)

    type lab    = Label.t
    type typ    = Type.t
    type var    = Type.var
    type kind   = Type.kind
    type inf	= Inf.t
    type fix    = Fixity.t
    type id     = AbstractGrammar.id
    type longid = AbstractGrammar.longid

    type unify_error  = typ * typ * typ * typ
    type inf_mismatch = Inf.mismatch

    datatype error =
	(* Expressions *)
	  VecExpUnify		of unify_error
	| AppExpFunUnify	of unify_error
	| AppExpArgUnify	of unify_error
	| CompExpNoRow		of typ
	| CompExpUnify		of unify_error
	| AndExpUnify		of unify_error
	| OrExpUnify		of unify_error
	| IfExpCondUnify	of unify_error
	| IfExpBranchUnify	of unify_error
	| WhileExpCondUnify	of unify_error
	| RaiseExpUnify		of unify_error
	| HandleExpUnify	of unify_error
	| AnnExpUnify		of unify_error
	| MatchPatUnify		of unify_error
	| MatchExpUnify		of unify_error
	(* Patterns *)
	| VecPatUnify		of unify_error
	| AppPatArrTyp		of typ
	| AppPatFunUnify	of unify_error
	| AppPatUnify		of unify_error
	| AsPatUnify		of unify_error
	| AltPatUnify		of unify_error
	| GuardPatUnify		of unify_error
	| AnnPatUnify		of unify_error
	(* Types *)
	| StarTypKind		of kind
	| AppTypFunKind		of kind
	| AppTypArgKind		of kind * kind
	| RefTypKind		of kind
	(* Declarations *)
	| ValDecUnify		of unify_error
	| ValDecLift		of id * var
	(* Long ids *)
	| ModLongidInf		of longid * inf
	(* Modules *)
	| StrModUnclosed	of lab * int * typ
	| SelModInf		of inf
	| AppModFunMismatch	of inf
	| AppModArgMismatch	of inf_mismatch
	| AnnModMismatch	of inf_mismatch
	(* Interfaces *)
	| GroundInfKind		of Inf.kind
	| CompInfMismatch	of inf_mismatch
	| SingInfPath
	(* Imports *)
	| ValItemMismatch	of lab * typ * typ
	| ConItemMismatch	of lab * typ * typ
	| TypItemMismatch	of lab * kind * kind
	| ModItemMismatch	of lab * inf_mismatch
	| InfItemMismatch	of lab * inf_mismatch
	| FixItemMismatch	of lab * fix * fix
	(* Components *)
	| CompUnclosed		of lab * int * typ

    datatype warning =
	  NotGeneralized	of id * typ


  (* Pretty printing *)

    fun ppQuoted s	= "`" ^ s ^ "'"

    fun ppLab'(AbstractGrammar.Lab(_,l)) = Label.toString l

    fun ppId'(AbstractGrammar.Id(_,_,n)) = Name.toString n
    fun ppId x = ppQuoted(ppId' x)

    fun ppLongid'(AbstractGrammar.ShortId(_,x))  = ppId' x
      | ppLongid'(AbstractGrammar.LongId(_,y,l)) = ppLongid' y ^ "." ^ ppLab' l
    fun ppLongid y = ppQuoted(ppLongid' y)

    fun ppLab a = Label.toString a

    val ppPath = PPPath.ppPath
    val ppTyp  = PPType.ppTyp
    val ppInf  = PPInf.ppInf


    fun ppUnify2(d1, d2, (t1,t2,t3,t4)) =
	vbox(
	    d1 ^^ indent(PPType.ppTyp t1) ^^
	    d2 ^^ indent(PPType.ppTyp t2)
	)

    fun ppUnify4(d1, d2, (t1,t2,t3,t4)) =
	let
	    val td1 = PPType.ppTyp t1
	    val td2 = PPType.ppTyp t2
	    val td3 = PPType.ppTyp t3
	    val td4 = PPType.ppTyp t4
	in
	    if td3 = td1 andalso td4 = td2 then
		vbox(
		    d1 ^^ indent td1 ^^
		    d2 ^^ indent td2
		)
	    else
		vbox(
		    d1 ^^ indent td1 ^^
		    d2 ^^ indent td2 ^^
		    textpar["because","type"] ^^ indent td3 ^^
		    textpar["does","not","unify","with"] ^^ indent td4
		)
	end

    fun ppMismatch(d, im) =
        vbox(
	    d ^^
	    ppMismatch' im
	)

    and ppMismatch'(Inf.MissingVal a) =
	    indent(textpar["val",ppLab a]) ^^
	    textpar["is","missing"]
      | ppMismatch'(Inf.MissingTyp  a) =
	    indent(textpar["type",ppLab a]) ^^
	    textpar["is","missing"]
      | ppMismatch'(Inf.MissingMod  a) =
	    indent(textpar["structure",ppLab a]) ^^
	    textpar["is","missing"]
      | ppMismatch'(Inf.MissingInf  a) =
	    indent(textpar["signature",ppLab a]) ^^
	    textpar["is","missing"]
      | ppMismatch'(Inf.MissingFix  a) =
	    textpar["fixity","of",ppQuoted(ppLab a),"is","unspecified"]
      | ppMismatch'(Inf.ManifestVal(a,po,p)) =
	    indent(par([text"val",text(ppLab a)] @
		(case po of NONE => [] | SOME p' => [text"=",ppPath p']))) ^^
	    textpar["does","not","match","manifest","specification"] ^^
	    indent(par[text"val",text(ppLab a),text"=",ppPath p])
      | ppMismatch'(Inf.ManifestTyp(a,to,t)) =
	    indent(
		case to of NONE => textpar["type",ppLab a]
		| SOME t' => par[text"type",text(ppLab a),text"=",ppTyp t']) ^^
	    textpar["does","not","match","manifest","specification"] ^^
	    indent(par[text"type",text(ppLab a),text"=",ppTyp t])
      | ppMismatch'(Inf.ManifestMod(a,po,p)) =
	    indent(par([text"structure",text(ppLab a)] @
		(case po of NONE => [] | SOME p' => [text"=",ppPath p']))) ^^
	    textpar["does","not","match","manifest","specification"] ^^
	    indent(par[text"structure",text(ppLab a),text"=",ppPath p])
      | ppMismatch'(Inf.ManifestInf(a,NONE)) =
	    indent(textpar["signature",ppLab a]) ^^
	    textpar["does","not","match","manifest","specification"]
      | ppMismatch'(Inf.ManifestInf(a,SOME im)) =
	    indent(textpar["signature",ppLab a]) ^^
	    textpar["does","not","match","manifest","specification,",
		"because"] ^^
	    ppMismatch' im
      | ppMismatch'(Inf.MismatchVal(a,t1,t2)) =
	    indent(par([text"val",text(ppLab a),text":",ppTyp t1])) ^^
	    textpar["does","not","match"] ^^
	    indent(par([text"val",text(ppLab a),text":",ppTyp t2]))
      | ppMismatch'(Inf.MismatchTyp(a,k1,k2)) =
	    indent(textpar["type",ppLab a]) ^^
	    textpar["has","incompatible","arity"]
      | ppMismatch'(Inf.MismatchMod(a, Inf.Incompatible(j1,j2))) =
	    indent(par([text"structure",text(ppLab a),text":",ppInf j1])) ^^
	    textpar["does","not","match"] ^^
	    indent(par([text"structure",text(ppLab a),text":",ppInf j2]))
      | ppMismatch'(Inf.MismatchMod(a, im as Inf.IncompatibleArg(p1,p2))) =
	    indent(textpar["structure",ppLab a]) ^^
	    textpar["has","incompatible","signature,",
		"because","signature","argument"] ^^
	    indent(ppPath p1) ^^
	    textpar["does","not","equal"] ^^
	    indent(ppPath p2)
      | ppMismatch'(Inf.MismatchMod(a,im)) =
	    indent(textpar["structure",ppLab a]) ^^
	    textpar["has","incompatible","signature,","because"] ^^
	    ppMismatch' im
      | ppMismatch'(Inf.MismatchInf(a,im)) =
	    indent(textpar["signature",ppLab a]) ^^
	    textpar["is","incompatible"]
      | ppMismatch'(Inf.MismatchFix(a,q1,q2)) =
	    textpar["fixity","of",ppQuoted(ppLab a),"is","different"]
      | ppMismatch'(Inf.MismatchValSort(a,w1,w2)) =
	    indent(textpar["val",ppLab a]) ^^
	    textpar["is","not","a","constructor"]
      | ppMismatch'(Inf.MismatchTypSort(a,w1,w2)) =
	    indent(textpar["val",ppLab a]) ^^
	    textpar["is","not","an","open","datatype"]
      | ppMismatch'(Inf.MismatchDom im) =
	    textpar["functor","argument","signature","is","incompatible,",
		"because"] ^^
	    ppMismatch' im
      | ppMismatch'(Inf.MismatchRan im) =
	    textpar["functor","result","signature","is","incompatible,",
		"because"] ^^
	    ppMismatch' im
      | ppMismatch'(Inf.Incompatible(j1,j2)) =
	    textpar["signature"] ^^
	    indent(ppInf j1) ^^
	    textpar["is","not","compatible","to"] ^^
	    indent(ppInf j2)
      | ppMismatch'(Inf.IncompatibleArg(p1,p2)) =
	    textpar["applied","signature","argument"] ^^
	    textpar["signature"] ^^
	    indent(ppPath p1) ^^
	    textpar["does","not","equal"] ^^
	    indent(ppPath p2)


    fun ppUnclosed(d, (a,n,t)) =
	vbox(
	    d ^^
	    indent(
		fbox(nest(
		    text(Label.toString a) ^/^
		    text ":" ^/^
		    below(PPType.ppTyp t)
		))
	    ) ^^
	    textpar["contains","free","type","variable",
		    "or","unresolved","record","type"]
	)


    fun ppError(VecExpUnify ue) =
	ppUnify2(
	  textpar["inconsistent","types","in","vector","expression:"],
	  textpar["does","not","agree","with","previous","element","type"], ue)
      | ppError(AppExpFunUnify ue) =
	ppUnify2(
	  textpar["applied","value","is","not","a","function:"],
	  textpar["does","not","match","function","type"], ue)
      | ppError(AppExpArgUnify ue) =
	ppUnify4(
	  textpar["argument","type","mismatch:"],
	  textpar["does","not","match","argument","type"], ue)
      | ppError(CompExpNoRow t) =
	vbox(
	    textpar["specialization","type","is","not","a","record:"] ^^
	    nest(break ^^ PPType.ppTyp t)
	)
      | ppError(CompExpUnify ue) =
	ppUnify4(
	  textpar["mismatch","on","record","update:"],
	  textpar["does","not","match","type"], ue)
      | ppError(AndExpUnify ue) =
	ppUnify2(
	  textpar["operand","of","`andalso'","is","not","a","boolean:"],
	  textpar["does","not","match","type"], ue)
      | ppError(OrExpUnify ue) =
	ppUnify2(
	  textpar["operand","of","`orelse'","is","not","a","boolean:"],
	  textpar["does","not","match","type"], ue)
      | ppError(IfExpCondUnify ue) =
	ppUnify2(
	  textpar["operand","of","`if'","is","not","a","boolean:"],
	  textpar["does","not","match","type"], ue)
      | ppError(IfExpBranchUnify ue) =
	ppUnify4(
	  textpar["inconsistent","types","in","branches","of","`if':"],
	  textpar["does","not","agree","with","type"], ue)
      | ppError(WhileExpCondUnify ue) =
	ppUnify2(
	  textpar["operand","of","`while'","is","not","a","boolean:"],
	  textpar["does","not","match","type"], ue)
      | ppError(RaiseExpUnify ue) =
	ppUnify2(
	  textpar["operand","of","`raise'","is","not","an","exception:"],
	  textpar["does","not","match","type"], ue)
      | ppError(HandleExpUnify ue) =
	ppUnify4(
	  textpar["inconsistent","types","in","branches","of","`handle':"],
	  textpar["does","not","agree","with","type"], ue)
      | ppError(AnnExpUnify ue) =
	ppUnify4(
	  textpar["expression","does","not","match","annotation:"],
	  textpar["does","not","match","type"], ue)
      (* Patterns *)
      | ppError(MatchPatUnify ue) =
	ppUnify4(
	  textpar["inconsistent","types","in","`case'","patterns:"],
	  textpar["does","not","agree","with","previous","type"], ue)
      | ppError(MatchExpUnify ue) =
	ppUnify4(
	  textpar["inconsistent","types","in","branches","of","`case':"],
	  textpar["does","not","agree","with","previous","type"], ue)
      | ppError(VecPatUnify ue) =
	ppUnify2(
	  textpar["inconsistent","types","in","vector","pattern:"],
	  textpar["does","not","agree","with","previous","element","type"], ue)
      | ppError(AppPatArrTyp t) =
	  textpar["missing","argument","to","constructor","in","pattern"]
      | ppError(AppPatFunUnify ue) =
	  textpar["surplus","argument","to","constructor","in","pattern"]
      | ppError(AppPatUnify ue) =
	ppUnify4(
	  textpar["ill-typed","constructor","argument:"],
	  textpar["does","not","match","argument","type"], ue)
      | ppError(AsPatUnify ue) =
	ppUnify4(
	  textpar["inconsistent","types","in","`as'","pattern:"],
	  textpar["does","not","agree","with","type"], ue)
      | ppError(AltPatUnify ue) =
	ppUnify4(
	  textpar["inconsistent","types","in","pattern","alternatives:"],
	  textpar["does","not","agree","with","previous","type"], ue)
      | ppError(GuardPatUnify ue) =
	ppUnify2(
	  textpar["pattern","guard","is","not","a","boolean:"],
	  textpar["does","not","match","type"], ue)
      | ppError(AnnPatUnify ue) =
	ppUnify4(
	  textpar["pattern","does","not","match","annotation:"],
	  textpar["does","not","match","type"], ue)
      (* Types *)
      | ppError(StarTypKind k) =
	  textpar["missing","arguments","in","type","expression"]
      | ppError(AppTypFunKind k) =
	  textpar["type","expression","is","not","a","type","function"]
      | ppError(AppTypArgKind(k1,k2)) =
	  textpar["missing","arguments","in","type","expression"]
      | ppError(RefTypKind k) =
	  textpar["missing","arguments","in","type","expression"]
      (* Declarations *)
      | ppError(ValDecUnify ue) =
	ppUnify4(
	  textpar["expression","does","not","match","pattern","type:"],
	  textpar["does","not","match","type"], ue)
      | ppError(ValDecLift(x,a)) =
	  textpar["could not generalize","type","of",ppId x,
	      "due","to","value","restriction",
	      "although","it","contains","explicit","type","variables"]
      (* Modules *)
      | ppError(ModLongidInf(y,j)) =
	  textpar["module",ppLongid y,"is","not","a","structure"]
      | ppError(StrModUnclosed lnt) =
	ppUnclosed(
	  textpar["structure","is","not","closed:"], lnt)
      | ppError(SelModInf j) =
	  textpar["module","expression","is","not","a","structure"]
      | ppError(AppModFunMismatch j) =
	  textpar["applied","module","is","not","a","functor"]
	  (* UNFINISHED: print actual signature j *)
      | ppError(AppModArgMismatch im) =
	ppMismatch(
	  textpar["module","expression","does","not","match",
	      "functor","parameter","signature:"], im)
      | ppError(AnnModMismatch im) =
	ppMismatch(
	  textpar["module","expression","does","not","match","signature:"], im)
      (* Interfaces *)
      | ppError(GroundInfKind k) =
	  textpar["missing","arguments","in","signature","expression"]
      | ppError(CompInfMismatch im) =
	ppMismatch(
	  textpar["inconsistency","at","signature","specialization:"], im)
      | ppError(SingInfPath) =
	  textpar["module","expression","is","not","a","path"]
      (* Imports *)
      | ppError(ValItemMismatch(a,t1,t2)) =
	vbox(
	    textpar["type","annotation","of","value",ppLab a] ^^
	    nest(break ^^ below(PPType.ppTyp t1)) ^/^
	    textpar["does","not","match","component","export","type"] ^^
	    nest(break ^^ below(PPType.ppTyp t2))
	)
      | ppError(ConItemMismatch(a,t1,t2)) =
	vbox(
	    textpar["type","of","constructor",ppLab a] ^^
	    nest(break ^^ below(PPType.ppTyp t1)) ^/^
	    textpar["does","not","match","component","export","type"] ^^
	    nest(break ^^ below(PPType.ppTyp t2))
	)
      | ppError(TypItemMismatch(a,k1,k2)) =
	  textpar["type",ppLab a,"exported","by","component",
		  "has","incompatible","arity"]
      | ppError(ModItemMismatch(a,im)) =
	ppMismatch(
	  textpar["module",ppLab a,"exported","by","component","does","not",
		  "match","signature,","because"], im)
      | ppError(InfItemMismatch(a,im)) =
	ppMismatch(
	  textpar["signature",ppLab a,"exported","by","component","is",
		  "incompatible,","because"], im)
      | ppError(FixItemMismatch(a,f1,f2)) =
	  textpar["fixity","status","for",ppLab a,"does","not","match",
		  "export"]
      (* Components *)
      | ppError(CompUnclosed ant) =
	ppUnclosed(
	  textpar["component","is","not","closed:"], ant)

    fun ppWarning(NotGeneralized(x,t)) =
	vbox(
	    textpar["type","of",ppId x,"cannot","be","generalized","due","to",
		"value","restriction:"] ^^
	    nest(break ^^ PPType.ppTyp t)
	)

  (* Export *)

    fun errorToString e   = PrettyPrint.toString(ppError e, 75)
    fun warningToString w = PrettyPrint.toString(ppWarning w, 75)

    fun error(region, e)  = Error.error(region, errorToString e)
    fun warn(region, w)   = Error.warn(region, warningToString w)

  end
(* src # 86 ../frontend-common/ELABORATION_PHASE.sig *)
signature ELABORATION_PHASE =
  sig

    structure C : CONTEXT          = Env
    structure I : ABSTRACT_GRAMMAR = AbstractGrammar
    structure O : ABSTRACT_GRAMMAR = TypedGrammar

    val translate : Env.t -> I.comp -> O.comp

  end
(* src # 87 ../frontend-common/ElaborationPhase.sml *)
(* UNFINISHED:
   - packages
   - appropriate treatment of value paths
*)

(*
 * Note: We assume complete binding analysis and alpha conversion has been
 * performed on the input program. So we would not need to bother with scoping.
 * Nevertheless, we sometimes use scopes to reduce the size of the symbol
 * table.
 *)

(*UNFINISHED*)
signature COMPOSER' = sig val sign: Url.t -> Inf.sign end
functor MakeElaborationPhase(Composer: COMPOSER') :> ELABORATION_PHASE =
  struct

    structure C = Env
    structure I = AbstractGrammar
    structure O = TypedGrammar
    structure E = ElaborationError

    open Env
    open TypedInfo

    nonfix mod

(*DEBUG*)
val lev = ref 0

  (* Error *)

    val error = E.error

  (* Under construction... *)

    fun unfinished i funname casename =
	Error.warn(i, "Elab." ^ funname ^ ": " ^ casename ^ " not checked yet")


  (* Predefined types *)

    fun unitTyp E	= PreboundType.typ_unit
    fun boolTyp E	= PreboundType.typ_bool
    fun exnTyp E	= PreboundType.typ_exn

    (* UNFINISHED: overloading *)
    fun wordTyp E	= PreboundType.typ_word
    fun intTyp E	= PreboundType.typ_int
    fun charTyp E	= PreboundType.typ_char
    fun stringTyp E	= PreboundType.typ_string
    fun realTyp E	= PreboundType.typ_real

    fun refTyp(E,t)	= Type.inApply(PreboundType.typ_ref, t)
    fun vecTyp(E,t)	= Type.inApply(PreboundType.typ_vec, t)
    fun listTyp(E,t)	= Type.inApply(PreboundType.typ_list, t)


  (* Check value restriction *)

    fun isValue( I.LitExp _
	       | I.PrimExp _
	       | I.VarExp _
	       | I.TagExp _
	       | I.ConExp _
	       | I.SelExp _
	       | I.CompExp _
	       | I.FunExp _ )			= true
      | isValue( I.TupExp(_, exps)
	       | I.VecExp(_, exps) )		= List.all isValue exps
      | isValue( I.ProdExp(_, exprow))		= isValueRow exprow
      | isValue( I.AppExp(_, exp1, exp2))	= isConstr exp1 andalso
						  isValue exp2
      | isValue( I.IfExp (_, exp1, exp2, exp3))	= isValue exp1 andalso
						  isValue exp2 andalso
						  isValue exp3
      | isValue( I.AnnExp(_, exp, _))		= isValue exp
      | isValue  _				= false

    and isValueRow(I.Row(_, fields, _))		= List.all isValueField fields
    and isValueField(I.Field(_, _, exps))	= List.all isValue exps

    and isConstr( I.VarExp _
		| I.FunExp _ )			= false
      | isConstr  exp				= isValue exp


  (* Literals *)

    fun elabLit(E, I.WordLit w)		= ( wordTyp E, O.WordLit w )
      | elabLit(E, I.IntLit n)		= ( intTyp E, O.IntLit n )
      | elabLit(E, I.CharLit c)		= ( charTyp E, O.CharLit c )
      | elabLit(E, I.StringLit s)	= ( stringTyp E, O.StringLit s )
      | elabLit(E, I.RealLit x)		= ( realTyp E, O.RealLit x )

  (* Fixity *)

    fun elabFix(E, I.Fix(i,f))		= (f, O.Fix(fixInfo(i,f), f))

  (* Rows (polymorphic, thus put here) *)

    fun elabLab(E, I.Lab(i, a)) = ( a, O.Lab(nonInfo(i), a) )

    fun elabRow(elabX, E, I.Row(i, fields, b)) =
	let
	    val  r0         = (if b then Type.unknownRow else Type.emptyRow)()
	    val (r,fields') = elabFields(elabX, E, r0, fields)
	in
	    ( r, O.Row(nonInfo(i), fields', b) )
	end

    and elabField(elabX, E, I.Field(i, lab, xs)) =
	let
	    val (a,lab') = elabLab(E, lab)
	    val (ts,xs') = ListPair.unzip(List.map (fn x => elabX(E,x)) xs)
	in
	    ( a, ts, O.Field(nonInfo(i), lab', xs') )
	end

    and elabFields(elabX, E, r, fields) =
	let
	    fun elabField1(field, (r,fields')) =
		let
		    val (l,ts,field') = elabField(elabX, E, field)
		in
		    ( Type.extendRow(l, ts, r), field'::fields' )
		end
	in
	    List.foldr elabField1 (r,[]) fields
	end


  (* Value identifiers *)

    fun elabValId_bind'(E, id as I.Id(i, stamp, name)) =
	    O.Id(nonInfo(i), stamp, name)

    fun elabValId_bind(E, s, w, id as I.Id(i, stamp, name)) =
	let
(*DEBUG
val x=case Name.toString(I.name id) of "?" => "?" | x => x
val _=print("-- insert val " ^ x ^ "(" ^ Stamp.toString stamp ^ ")")
*)
	    val  p      = Inf.newVal(s, Label.fromName name)
	    val  t      = Type.unknown(Type.STAR)
	    (*UNFINISHED: use punning: *)
	    val (p',t') = ( insertVal(E, stamp, {id=id, path=p, typ=t, sort=w})
			  ; (p,t) )
			  handle Collision _ =>	(* val rec or alt pat *)
			    let val {path=p', typ=t', ...} = lookupVal(E, stamp)
			    in (p',t') end
(*
before (print" (* found : ";
PrettyPrint.output(TextIO.stdOut, PPType.ppTyp t', 60);
print" *)")
val _=print "\n"
*)
	in
	    ( t', p', O.Id(nonInfo(i), stamp, name) )
	end

    fun elabValId(E, id as I.Id(i, stamp, name)) =
	let
(*DEBUG
val x=case Name.toString(I.name id) of "?" => "?" | x => x
val _=print("-- lookup val " ^ x ^ "(" ^ Stamp.toString stamp ^ ") : ")
val _=PrettyPrint.output(TextIO.stdOut, PPType.ppTyp(#typ(lookupVal(E, stamp))), 60)
val _=print "\n"
"*)
	    val t  = #typ(lookupVal(E, stamp))
	in
	    ( t, O.Id(nonInfo(i), stamp, name) )
	end

    and elabValLongid(E, I.ShortId(i, id)) =
	let
	    val (t,id') = elabValId(E, id)
	in
	    ( t, O.ShortId(nonInfo(i), id') )
	end

      | elabValLongid(E, I.LongId(i, longid, lab)) =
	let
	    val (s,longid') = elabModLongid_path(E, longid)
	    val (l,lab')    = elabLab(E, lab)
	    val  t          = Inf.lookupVal(s, l)
	in
	    ( t, O.LongId(nonInfo(i), longid', lab') )
	end

    and elabValLongid_path(E, I.ShortId(_, I.Id(_, stamp, _))) =
	    #path(lookupVal(E, stamp))

      | elabValLongid_path(E, I.LongId(_, longid, I.Lab(_, l))) =
	let
	    val (s,_) = elabModLongid_path(E, longid)
	in
	    Inf.lookupValPath(s, l)
	end


  (* Expressions *)

    and elabExp(E, I.LitExp(i, lit)) =
	let
	    val (t,lit') = elabLit(E, lit)
	in
	    ( t, O.LitExp(typInfo(i,t), lit') )
	end

      | elabExp(E, I.PrimExp(i, s, typ)) =
	let
	    val (t,typ') = elabStarTyp(E, typ)
	in
	    ( t, O.PrimExp(typInfo(i,t), s, typ') )
	end

      | elabExp(E, I.VarExp(i, longid)) =
	let
	    val (t,longid') = elabValLongid(E, longid)
	    val  t'         = Type.instance t
	in
	    ( t', O.VarExp(typInfo(i,t'), longid') )
	end

      | elabExp(E, I.TagExp(i, lab, k)) =
	let
	    val (a,lab') = elabLab(E, lab)
	    val  t1      = Type.unknown(Type.STAR)
	    val  r       = Type.extendRow(a, [t1], Type.unknownRow())
	    val  t       = Type.inArrow(t1, Type.inSum r)
	in
	    ( t, O.TagExp(typInfo(i,t), lab', k) )
	end

      | elabExp(E, I.ConExp(i, longid, k)) =
	let
	    val (t,longid') = elabValLongid(E, longid)
	    val  t'         = Type.instance t
	in
	    ( t', O.ConExp(typInfo(i,t'), longid', k) )
	end

      | elabExp(E, I.RefExp(i)) =
	let
	    val ta = Type.unknown(Type.STAR)
	    val t  = Type.inArrow(ta, refTyp(E, ta))
	in
	    ( t, O.RefExp(typInfo(i,t)) )
	end

      | elabExp(E, I.TupExp(i, exps)) =
	let
	    val (ts,exps') = elabExps(E, exps)
	    val  t         = Type.inTuple ts
	in
	    ( t, O.TupExp(typInfo(i,t), exps') )
	end

      | elabExp(E, I.ProdExp(i, exprow)) =
	let
	    val (r,exprow') = elabRow(elabExp, E, exprow)
	    val  t          = Type.inProd r
	in
	    ( t, O.ProdExp(typInfo(i,t), exprow') )
	end

      | elabExp(E, I.SelExp(i, lab)) =
	let
	    val (a,lab') = elabLab(E, lab)
	    val  t1      = Type.unknown(Type.STAR)
	    val  r       = Type.extendRow(a, [t1], Type.unknownRow())
	    val  t       = Type.inArrow(Type.inProd r, t1)
	in
	    ( t, O.SelExp(typInfo(i,t), lab') )
	end

      | elabExp(E, I.VecExp(i, exps)) =
	let
	    val (ts,exps') = elabExps(E, exps)
	    val  t         = vecTyp(E, List.hd ts)
	    val  _         = Type.unifyList ts handle Type.UnifyList(n,t1,t2) =>
				error(I.infoExp(List.nth(exps,n)),
				      E.VecExpUnify(t, List.nth(ts,n), t1, t2))
	in
	    ( t, O.VecExp(typInfo(i,t), exps') )
	end

      | elabExp(E, I.FunExp(i, matchs)) =
	let
	    val  t1          = Type.unknown(Type.STAR)
	    val (t2,matchs') = elabMatchs(E, t1, matchs)
	    val  t           = Type.inArrow(t1,t2)
	in
	    ( t, O.FunExp(typInfo(i,t), matchs') )
	end

      | elabExp(E, I.AppExp(i, exp1, exp2)) =
	let
	    val (t1,exp1') = elabExp(E, exp1)
	    val (t2,exp2') = elabExp(E, exp2)
	    val  t11       = Type.unknown(Type.STAR)
	    val  t12       = Type.unknown(Type.STAR)
	    val  t1'       = Type.inArrow(t11,t12)
	    val  _         = Type.unify(t1,t1') handle Type.Unify(t3,t4) =>
				error(I.infoExp exp1,
				      E.AppExpFunUnify(t1, t1', t3, t4))
	    val  _         = Type.unify(t11,t2) handle Type.Unify(t3,t4) =>
				error(i, E.AppExpArgUnify(t11, t2, t3, t4))
	in
	    ( t12, O.AppExp(typInfo(i,t12), exp1', exp2') )
	end

      | elabExp(E, I.CompExp(i, exp1, exp2)) =
	(* UNFINISHED: more polymorphic treatment *)
	let
	    val (t1,exp1') = elabExp(E, exp1)
	    val (t2,exp2') = elabExp(E, exp2)
	    val  _         = Type.openRowType t2 handle Type.Row =>
				error(I.infoExp exp2, E.CompExpNoRow t2)
	    val  _         = Type.unify(t1,t2) handle Type.Unify(t3,t4) =>
				error(i, E.CompExpUnify(t2, t1, t4, t3))
	in
	    ( t1, O.CompExp(typInfo(i,t1), exp1', exp2') )
	end

      | elabExp(E, I.AndExp(i, exp1, exp2)) =
	let
	    val (t1,exp1') = elabExp(E, exp1)
	    val (t2,exp2') = elabExp(E, exp2)
	    val  t         = boolTyp E
	    val  _         = Type.unify(t1,t) handle Type.Unify(t3,t4) =>
				error(I.infoExp exp1, E.AndExpUnify(t1,t,t3,t4))
	    val  _         = Type.unify(t2,t) handle Type.Unify(t3,t4) =>
				error(I.infoExp exp2, E.AndExpUnify(t2,t,t3,t4))
	in
	    ( t, O.AndExp(typInfo(i,t), exp1', exp2') )
	end

      | elabExp(E, I.OrExp(i, exp1, exp2)) =
	let
	    val (t1,exp1') = elabExp(E, exp1)
	    val (t2,exp2') = elabExp(E, exp2)
	    val  t         = boolTyp E
	    val  _         = Type.unify(t1,t) handle Type.Unify(t3,t4) =>
				error(I.infoExp exp1, E.OrExpUnify(t1,t,t3,t4))
	    val  _         = Type.unify(t2,t) handle Type.Unify(t3,t4) =>
				error(I.infoExp exp2, E.OrExpUnify(t2,t,t3,t4))
	in
	    ( t, O.OrExp(typInfo(i,t), exp1', exp2') )
	end

      | elabExp(E, I.IfExp(i, exp1, exp2, exp3)) =
	let
	    val (t1,exp1') = elabExp(E, exp1)
	    val (t2,exp2') = elabExp(E, exp2)
	    val (t3,exp3') = elabExp(E, exp3)
	    val  tb        = boolTyp E
	    val  _         = Type.unify(t1,tb) handle Type.Unify(t4,t5) =>
				error(I.infoExp exp1,
				      E.IfExpCondUnify(t1, tb, t4, t5))
	    val  _         = Type.unify(t2,t3) handle Type.Unify(t4,t5) =>
				error(i, E.IfExpBranchUnify(t2, t3, t4, t5))
	in
	    ( t2, O.IfExp(typInfo(i,t2), exp1', exp2', exp3') )
	end

      | elabExp(E, I.WhileExp(i, exp1, exp2)) =
	let
	    val (t1,exp1') = elabExp(E, exp1)
	    val (t2,exp2') = elabExp(E, exp2)
	    val  tb        = boolTyp E
	    val  t         = unitTyp E
	    val  _         = Type.unify(t1,tb) handle Type.Unify(t3,t4) =>
				error(I.infoExp exp1,
				      E.WhileExpCondUnify(t1, tb, t3, t4))
	in
	    ( t, O.WhileExp(typInfo(i,t), exp1', exp2') )
	end

      | elabExp(E, I.SeqExp(i, exps)) =
	let
	    val (ts,exps') = elabExps(E, exps)
	    val  t         = List.last ts
	in
	    ( t, O.SeqExp(typInfo(i,t), exps') )
	end

      | elabExp(E, I.CaseExp(i, exp, matchs)) =
	(* UNFINISHED: check for exhaustiveness and redundancy *)
	let
	    val (t1,exp')    = elabExp(E, exp)
	    val (t2,matchs') = elabMatchs(E, t1, matchs)
	in
	    ( t2, O.CaseExp(typInfo(i,t2), exp', matchs') )
	end

      | elabExp(E, I.RaiseExp(i, exp)) =
	let
	    val (t1,exp') = elabExp(E, exp)
	    val  te       = exnTyp E
	    val  t        = Type.unknown(Type.STAR)
	    val  _        = Type.unify(t1,te) handle Type.Unify(t2,t3) =>
				error(I.infoExp exp,
				      E.RaiseExpUnify(t1, te, t2, t3))
	in
	    ( t, O.RaiseExp(typInfo(i,t), exp') )
	end

      | elabExp(E, I.HandleExp(i, exp, matchs)) =
	(* UNFINISHED: check for redundancy *)
	let
	    val (t1,exp')    = elabExp(E, exp)
	    val (t2,matchs') = elabMatchs(E, exnTyp E, matchs)
	    val  _           = Type.unify(t1,t2) handle Type.Unify(t3,t4) =>
				error(i, E.HandleExpUnify(t1, t2, t3, t4))
	in
	    ( t1, O.HandleExp(typInfo(i,t1), exp', matchs') )
	end

      | elabExp(E, I.AnnExp(i, exp, typ)) =
	let
	    val (t1,exp') = elabExp(E, exp)
	    val (t2,typ') = elabStarTyp(E, typ)
	    val  _        = Type.unify(t1,t2) handle Type.Unify(t3,t4) =>
				error(i, E.AnnExpUnify(t1, t2, t3, t4))
	in
	    ( t2, O.AnnExp(typInfo(i,t2), exp', typ') )
	end

      | elabExp(E, I.LetExp(i, decs, exp)) =
	let
	    val  _       = insertScope E
	    val  s       = Inf.empty()
	    val  decs'   = elabDecs(E, s, decs)
(*DEBUG*)
val _ = Inf.strengthenSig(Path.fromLab(Label.fromString "?let"), s)
	    val  _       = Inf.strengthenSig(Path.invent(), s)
	    val (t,exp') = elabExp(E, exp)
	    val  _       = deleteScope E
	in
	    ( t, O.LetExp(typInfo(i,t), decs', exp') )
	end

      | elabExp(E, I.PackExp(i, mod)) =
	let
	    val (j,mod') = elabMod(E, mod)
	    (*UNFINISHED*)
	    val  t       = Type.unknown(Type.STAR)
	in
	    unfinished i "elabExp" "packages";
	    ( t, O.PackExp(typInfo(i,t), mod') )
	end

    and elabExps(E, exps) =
	ListPair.unzip(List.map (fn exp => elabExp(E,exp)) exps)


  (* Matches *)

    and elabMatch(E, t1, t2, I.Match(i, pat, exp)) =
	let
	    val  _        = insertScope E
	    val (t3,pat') = elabPat(E, Inf.empty(), pat)
	    val  _        = Type.unify(t1,t3) handle Type.Unify(t5,t6) =>
				error(I.infoPat pat,
				      E.MatchPatUnify(t1, t3, t5, t6))
	    val (t4,exp') = elabExp(E, exp)
	    val  _        = Type.unify(t2,t4) handle Type.Unify(t5,t6) =>
				error(I.infoExp exp,
				      E.MatchExpUnify(t2, t4, t5, t6))
	    val  _        = deleteScope E
	in
	    O.Match(nonInfo(i), pat', exp')
	end

    and elabMatchs(E, t1, matchs) =
	let
	    val t2 = Type.unknown(Type.STAR)

	    fun elabMatch1 match = elabMatch(E, t1, t2, match)
	in
	    ( t2, List.map elabMatch1 matchs )
	end


  (* Patterns *)

    and elabPat(E, s, I.JokPat(i)) =
	let
	    val t = Type.unknown(Type.STAR)
	in
	    ( t, O.JokPat(typInfo(i,t)) )
	end

      | elabPat(E, s, I.LitPat(i, lit)) =
	let
	    val (t,lit') = elabLit(E, lit)
	in
	    ( t, O.LitPat(typInfo(i,t), lit') )
	end

      | elabPat(E, s, I.VarPat(i, id)) =
	let
	    val (t,p,id') = elabValId_bind(E, s, Inf.VALUE, id)
	in
	    ( t, O.VarPat(typInfo(i,t), id') )
	end

      | elabPat(E, s, I.TupPat(i, pats)) =
	let
	    val (ts,pats') = elabPats(E, s, pats)
	    val  t         = Type.inTuple ts
	in
	    ( t, O.TupPat(typInfo(i,t), pats') )
	end

      | elabPat(E, s, I.ProdPat(i, patrow)) =
	let
	    val (r,patrow') = elabRow(fn(E,pat) => elabPat(E,s,pat), E, patrow)
	    val  t          = Type.inProd r
	in
	    ( t, O.ProdPat(typInfo(i,t), patrow') )
	end

      | elabPat(E, s, I.VecPat(i, pats)) =
	let
	    val (ts,pats') = elabPats(E, s, pats)
	    val  t         = vecTyp(E, List.hd ts)
	    val  _         = Type.unifyList ts handle Type.UnifyList(n,t1,t2) =>
				error(I.infoPat(List.nth(pats,n)),
				      E.VecPatUnify(t, List.nth(ts,n), t1, t2))
	in
	    ( t, O.VecPat(typInfo(i,t), pats') )
	end

      | elabPat(E, s, I.AsPat(i, pat1, pat2)) =
	let
	    val (t1,pat1') = elabPat(E, s, pat1)
	    val (t2,pat2') = elabPat(E, s, pat2)
	    val  _         = Type.unify(t1,t2) handle Type.Unify(t3,t4) =>
				error(i, E.AsPatUnify(t1, t2, t3, t4))
	in
	    ( t2, O.AsPat(typInfo(i,t2), pat1', pat2') )
	end

      | elabPat(E, s, I.AltPat(i, pats)) =
	let
	    val (ts,pats') = elabPats(E, s, pats)
	    val  t         = List.hd ts
	    val  _         = Type.unifyList ts handle Type.UnifyList(n,t1,t2) =>
				error(I.infoPat(List.nth(pats,n)),
				      E.AltPatUnify(t, List.nth(ts,n), t1, t2))
	in
	    ( t, O.AltPat(typInfo(i,t), pats') )
	end

      | elabPat(E, s, I.NegPat(i, pat)) =
	let
	    val (t,pat') = elabPat(E, s, pat)
	in
	    ( t, O.NegPat(typInfo(i,t), pat') )
	end

      | elabPat(E, s, I.GuardPat(i, pat, exp)) =
	let
	    val (t1,pat') = elabPat(E, s, pat)
	    val (t2,exp') = elabExp(E, exp)
	    val  tb       = boolTyp E
	    val  _        = Type.unify(t2,tb) handle Type.Unify(t3,t4) =>
				error(i, E.GuardPatUnify(t2, tb, t3, t4))
	in
	    ( t1, O.GuardPat(typInfo(i,t1), pat', exp') )
	end

      | elabPat(E, s, I.AnnPat(i, pat, typ)) =
	let
	    val (t1,pat') = elabPat(E, s, pat)
	    val (t2,typ') = elabStarTyp(E, typ)
	    val  _        = Type.unify(t1,t2) handle Type.Unify(t3,t4) =>
				error(i, E.AnnPatUnify(t1, t2, t3, t4))
	in
	    ( t2, O.AnnPat(typInfo(i,t2), pat', typ') )
	end

      | elabPat(E, s, I.WithPat(i, pat, decs)) =
	let
	    val (t,pat') = elabPat(E, s, pat)
	    val  decs'   = elabDecs(E, s, decs)
	in
	    ( t, O.WithPat(typInfo(i,t), pat', decs') )
	end

      | elabPat(E, s, pat as (I.TagPat _| I.ConPat _| I.RefPat _| I.AppPat _)) =
	let
	    val tpat' as (t,pat') = elabAppPat(E, s, pat)
	in
	    if Type.isArrow t then
		error(I.infoPat pat, E.AppPatArrTyp(t))
	    else
		tpat'
	end


    and elabAppPat(E, s, I.TagPat(i, lab, k)) =
	let
	    val (a,lab') = elabLab(E, lab)
	    val  t1      = Type.unknown(Type.STAR)
	    val  r       = Type.extendRow(a, [t1], Type.unknownRow())
	    val  t       = Type.inArrow(t1, Type.inSum r)
	in
	    ( t, O.TagPat(typInfo(i,t), lab', k) )
	end

      | elabAppPat(E, s, I.ConPat(i, longid, k)) =
	let
	    val (t,longid') = elabValLongid(E, longid)
	    val  t'         = Type.instance t
	in
	    ( t', O.ConPat(typInfo(i,t'), longid', k) )
	end

      | elabAppPat(E, s, I.RefPat(i)) =
	let
	    val ta = Type.unknown(Type.STAR)
	    val t  = Type.inArrow(ta, refTyp(E, ta))
	in
	    ( t, O.RefPat(typInfo(i,t)) )
	end

      | elabAppPat(E, s, I.AppPat(i, pat1, pat2)) =
	let
	    val (t1,pat1') = elabAppPat(E, s, pat1)
	    val (t2,pat2') = elabPat(E, s, pat2)
	    val  t11       = Type.unknown(Type.STAR)
	    val  t12       = Type.unknown(Type.STAR)
	    val  t1'       = Type.inArrow(t11,t12)
	    val  _         = Type.unify(t1',t1) handle Type.Unify(t3,t4) =>
				error(i, E.AppPatFunUnify(t1', t1, t3, t4))
	    val  _         = Type.unify(t11,t2) handle Type.Unify(t3,t4) =>
				error(i, E.AppPatUnify(t11, t2, t3, t4))
	in
	    ( t12, O.AppPat(typInfo(i,t12), pat1', pat2') )
	end

      | elabAppPat(E, s, pat) = raise Crash.Crash "Elab.elabAppPat: invalid con"


    and elabPats(E, s, pats) =
	ListPair.unzip(List.map (fn pat => elabPat(E,s,pat)) pats)



  (* Type identifiers *)

    and elabVarId_bind'(E, id as I.Id(i, stamp, name)) =
	    O.Id(nonInfo(i), stamp, name)

    and elabVarId_bind(E, k, id as I.Id(i, stamp, name)) =
	let
	    val a = Type.var k
	    (*UNFINISHED: use punning: *)
	    val _ = insertVar(E, stamp, {id=id, var=a})
	in
	    ( a, O.Id(nonInfo(i), stamp, name) )
	end

    and elabVarId(E, id as I.Id(i, stamp, name)) =
	let
(*DEBUG
val x=case Name.toString(I.name id) of "?" => "?" | x => x
val _=print("-- lookup type variable " ^ x ^ "(" ^ Stamp.toString stamp ^ ") = ")
val _=PrettyPrint.output(TextIO.stdOut, PPType.ppTyp(Type.inVar(#var(lookupVar(E, stamp)))), 60)
val _=print "\n"
*)
	    val a = #var(lookupVar(E, stamp))
	in
	    ( a, O.Id(nonInfo(i), stamp, name) )
	end


    and elabTypId_bind(E, p, t, w, id as I.Id(i, stamp, name)) =
	let
(*DEBUG
val x=case Name.toString(I.name id) of "?" => "?" | x => x
val _=print("-- insert type " ^ x ^ "(" ^ Stamp.toString stamp ^ ") = ")
val _=PrettyPrint.output(TextIO.stdOut, PPType.ppTyp t, 60)
val _=print "\n"
*)
	    val t' = Type.inAbbrev(Type.inCon(Type.kind t,w,p), t)
	    (*UNFINISHED: use punning: *)
	    val _  = insertTyp(E, stamp, {id=id, path=p, typ=t', sort=w})
	in
	    O.Id(nonInfo(i), stamp, name)
	end

    and elabTypId(E, id as I.Id(i, stamp, name)) =
	let
(*DEBUG
val x=case Name.toString(I.name id) of "?" => "?" | x => x
val _=print("-- lookup type " ^ x ^ "(" ^ Stamp.toString stamp ^ ") = ")
val _=PrettyPrint.output(TextIO.stdOut, PPType.ppTyp(#typ(lookupTyp(E, stamp))), 60)
val _=print "\n"
*)
	    val {typ=t, path=p, sort=w, ...} = lookupTyp(E, stamp)
	in
	    ( t, p, w, O.Id(nonInfo(i), stamp, name) )
	end

    and elabTypLongid(E, I.ShortId(i, id)) =
	let
	    val (t,_,w,id') = elabTypId(E, id)
	in
	    ( t, w, O.ShortId(nonInfo(i), id') )
	end

      | elabTypLongid(E, I.LongId(i, longid, lab)) =
	let
	    val (s,longid') = elabModLongid_path(E, longid)
	    val (l,lab')    = elabLab(E, lab)
	    val  t          = Inf.lookupTyp(s, l)
	    val  w          = Inf.lookupTypSort(s, l)
	in
	    ( t, w, O.LongId(nonInfo(i), longid', lab') )
	end


  (* Kinds of types (without elaborating the full type) *)

    (* These are needed to elaborate recursive type bindings.
     * ASSUMPTION: under recursion we do not have higher-order bindings.
     * ASSUMPTION: type lambdas are first order.
     *)

    and elabTypKind(E, I.FunTyp(i, id, typ)) =
	let
	    val k = elabTypKind(E, typ)
	in
	    Type.ARROW(Type.STAR,k)
	end

      | elabTypKind(E, I.ConTyp(i, longid)) =
	let
	    val (t,_,_) = elabTypLongid(E, longid)
	in
	    Type.kind t
	end

      | elabTypKind(E, I.VarTyp(i, id)) =
	let
	    val (a,_) = elabVarId(E, id)
	in
	    Type.kindVar a
	end

      | elabTypKind(E, I.AppTyp(i, typ1, typ2)) =
	let
	    val k = elabTypKind(E, typ1)
	in
	    case k
	      of Type.ARROW(k1,k2) => k2
	       | _                 => error(i, E.AppTypFunKind(k))
	end

      | elabTypKind(E, _) =
	    Type.STAR


  (* Types *)

    and elabTyp(E, I.VarTyp(i, id)) =
	let
	    val (a,id') = elabVarId(E, id)
	    val  t      = Type.inVar a
	in
	    ( t, O.VarTyp(typInfo(i,t), id') )
	end

      | elabTyp(E, I.ConTyp(i, longid)) =
	let
	    val (t,_,longid') = elabTypLongid(E, longid)
	in
	    ( t, O.ConTyp(typInfo(i,t), longid') )
	end

      | elabTyp(E, I.FunTyp(i, id, typ)) =
	let
	    val (a,id')   = elabVarId_bind(E, Type.STAR, id)
	    val (t1,typ') = elabTyp(E, typ)
	    val  t        = Type.inLambda(a,t1)
	in
	    ( t, O.FunTyp(typInfo(i,t), id', typ') )
	end

      | elabTyp(E, I.AppTyp(i, typ1, typ2)) =
	let
	    val (t1,typ1') = elabTyp(E, typ1)
	    val (t2,typ2') = elabTyp(E, typ2)
	    val  k1        = Type.kind t1
	    val  k2        = Type.kind t2
	    val  _         = case k1
			       of Type.STAR =>
					error(i, E.AppTypFunKind(k1))
				| Type.ARROW(k11,k12) =>
				    if k11 = k2 then () else
					error(i, E.AppTypArgKind(k11, k2))
	    val  t         = Type.inApply(t1,t2)
	in
	    ( t, O.AppTyp(typInfo(i,t), typ1', typ2') )
	end

      | elabTyp(E, I.RefTyp(i, typ)) =
	let
	    val (t1,typ') = elabTyp(E, typ)
	    val  _        = case Type.kind t1 of Type.STAR => () | k =>
				error(I.infoTyp typ, E.RefTypKind(k))
	    val  t        = refTyp(E, t1)
	in
	    ( t, O.RefTyp(typInfo(i,t), typ') )
	end

      | elabTyp(E, I.TupTyp(i, typs)) =
	let
	    val (ts,typs') = elabStarTyps(E, typs)
	    val  t         = Type.inTuple ts
	in
	    ( t, O.TupTyp(typInfo(i,t), typs') )
	end

      | elabTyp(E, I.ProdTyp(i, typrow)) =
	let
	    val (r,typrow') = elabRow(elabStarTyp, E, typrow)
	    val  t          = Type.inProd r
	in
	    ( t, O.ProdTyp(typInfo(i,t), typrow') )
	end

      | elabTyp(E, I.SumTyp(i, typrow)) =
	let
	    val (r,typrow') = elabRow(elabStarTyp, E, typrow)
	    val  t          = Type.inSum r
	in
	    ( t, O.SumTyp(typInfo(i,t), typrow') )
	end

      | elabTyp(E, I.ArrTyp(i, typ1, typ2)) =
	let
	    val (t1,typ1') = elabStarTyp(E, typ1)
	    val (t2,typ2') = elabStarTyp(E, typ2)
	    val  t         = Type.inArrow(t1,t2)
	in
	    ( t, O.ArrTyp(typInfo(i,t), typ1', typ2') )
	end

      | elabTyp(E, I.AllTyp(i, id, typ)) =
	let
	    val (a,id')   = elabVarId_bind(E, Type.STAR, id)
	    val (t1,typ') = elabTyp(E, typ)
	    val  t        = Type.inAll(a,t1)
	in
	    ( t, O.AllTyp(typInfo(i,t), id', typ') )
	end

      | elabTyp(E, I.ExTyp(i, id, typ)) =
	let
	    val (a,id')   = elabVarId_bind(E, Type.STAR, id)
	    val (t1,typ') = elabTyp(E, typ)
	    val  t        = Type.inExist(a,t1)
	in
	    ( t, O.ExTyp(typInfo(i,t), id', typ') )
	end

      | elabTyp(E, I.PackTyp(i, inf)) =
	let
	    val (j,inf') = elabInf(E, inf)
	    (*UNFINISHED*)
	    val  t       = Type.unknown(Type.STAR)
	in
	    unfinished i "elabTyp" "packages";
	    ( t, O.PackTyp(typInfo(i,t), inf') )
	end

      | elabTyp(E, I.SingTyp(i, longid)) =
	let
	    val (t,longid') = elabValLongid(E, longid)
	in
	    ( t, O.SingTyp(typInfo(i,t), longid') )
	end

      | elabTyp(E, I.AbsTyp(i)) =
	raise Crash.Crash "Elab.elabTyp: AbsTyp"

      | elabTyp(E, I.ExtTyp(i)) =
	raise Crash.Crash "Elab.elabTyp: ExtTyp"


  (* Types in positions where they may not be higher order *)

    and elabStarTyp(E, typ) =
	let
	    val ttyp' as (t,typ') = elabTyp(E, typ)
	in
	    case Type.kind t
	      of Type.STAR => ttyp'
	       | k         => error(I.infoTyp typ, E.StarTypKind(k))
	end

    and elabStarTyps(E, typs) =
	ListPair.unzip(List.map (fn typ => elabStarTyp(E, typ)) typs)



  (* Type representations (RHSs of type bindings) *)

    and elabTypRep(E, p, buildKind, I.ConTyp(i, longid)) =
	let
	    val (t,w,longid') = elabTypLongid(E, longid)
	in
	    ( t, false, w, O.ConTyp(typInfo(i,t), longid') )
	end

      | elabTypRep(E, p, buildKind, I.FunTyp(i, id, typ)) =
	let
	    val  k              = Type.STAR
	    val (a,id')         = elabVarId_bind(E, k, id)
	    val (t1,gen,w,typ') = elabTypRep(E, p,
				      fn k' => Type.ARROW(k, buildKind k'), typ)
            val  t              = if gen then t1 else Type.inLambda(a,t1)
				(* If the type is generative then we
				 * get a constructor with appropriate kind
				 * and do not need to insert lambdas.
				 *)
	in
	    ( t, gen, w, O.FunTyp(typInfo(i,t), id', typ') )
	end

      | elabTypRep(E, p, buildKind, I.AbsTyp(i))=
	let
	    val t = Type.inCon(buildKind Type.STAR, Type.CLOSED, p)
	in
	    ( t, true, Type.CLOSED, O.AbsTyp(typInfo(i,t)) )
	end

      | elabTypRep(E, p, buildKind, I.ExtTyp(i))=
	let
	    val t = Type.inCon(buildKind Type.STAR, Type.OPEN, p)
	in
	    ( t, true, Type.OPEN, O.ExtTyp(typInfo(i,t)) )
	end

      | elabTypRep(E, p, buildKind, typ) =
	let
	    val (t,typ') = elabTyp(E, typ)
	in
	    ( t, false, Type.CLOSED, typ' )
	end


  (* Module identifiers *)

    and elabModId_bind(E, p, j, id as I.Id(i, stamp, name)) =
	let
(*DEBUG
val _ = if false then "" else let
val x=case Name.toString(I.name id) of "?" => "?" | x => x
val _=print("-- insert module " ^ x ^ "(" ^ Stamp.toString stamp ^ ") :\n")
val _=PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j, 75)
val _=print "\n"
in ""(*TextIO.inputLine TextIO.stdIn*) end
*)
	    (*UNFINISHED: use punning: *)
	    val _ = insertMod(E, stamp, {id=id, path=p, inf=j})
	in
	    O.Id(nonInfo(i), stamp, name)
	end

    and elabModId(E, id as I.Id(i, stamp, name)) =
	let
(*DEBUG
val x=case Name.toString(I.name id) of "?" => "?" | x => x
val _=print("-- lookup module " ^ x ^ "(" ^ Stamp.toString stamp ^ ") :\n")
val _=PrettyPrint.output(TextIO.stdOut, PPInf.ppInf(#inf(lookupMod(E, stamp))), 75)
val _=print "\n"
*)
	    val j = #inf(lookupMod(E, stamp))
	in
	    ( j, O.Id(nonInfo(i), stamp, name) )
	end

    and elabModLongid(E, I.ShortId(i, id)) =
	let
	    val (j,id') = elabModId(E, id)
	in
	    ( j, O.ShortId(nonInfo(i), id') )
	end

      | elabModLongid(E, I.LongId(i, longid, lab)) =
	let
	    val (s,longid') = elabModLongid_path(E, longid)
	    val (l,lab')    = elabLab(E, lab)
	    val  j          = Inf.lookupMod(s, l)
	in
	    ( j, O.LongId(nonInfo(i), longid', lab') )
	end

    and elabModLongid_path(E, longid) =
	let
	    val (j,longid') = elabModLongid(E, longid)
	    val  s          = Inf.asSig j handle Inf.Interface =>
				error(I.infoLongid longid,
				      E.ModLongidInf(longid, j))
	in
	    ( s, longid' )
	end


  (* Modules *)

    and elabMod(E, I.PrimMod(i, s, inf)) =
	let
	    val (j,inf') = elabGroundInf(E, inf)
	in
	    ( j, O.PrimMod(infInfo(i,j), s, inf') )
	end

      | elabMod(E, I.VarMod(i, id)) =
	let
	    val (j,id') = elabModId(E, id)
	in
	    ( j, O.VarMod(infInfo(i,j), id') )
	end

      | elabMod(E, I.StrMod(i, decs)) =
	let
	    val s     = Inf.empty()
	    val decs' = elabDecs(E, s, decs)
	    val _     = Inf.close s handle Inf.Unclosed lnt =>
			    error(i, E.StrModUnclosed lnt)
	    val j     = Inf.inSig s
	in
	    ( j, O.StrMod(infInfo(i,j), decs') )
	end

      | elabMod(E, I.SelMod(i, mod, lab)) =
	let
	    val (j1,mod') = elabMod(E, mod)
	    val (l,lab')  = elabLab(E, lab)
	    val  s        = Inf.asSig j1 handle Inf.Interface =>
				error(I.infoMod mod, E.SelModInf j1)
	    val  j        = Inf.lookupMod(s, l)
	in
	    ( j, O.SelMod(infInfo(i,j), mod', lab') )
	end

      | elabMod(E, I.FunMod(i, id, inf, mod)) =
	let
	    val  _        = insertScope E
	    val (j1,inf') = elabGroundInf(E, inf)
	    val  j1'      = Inf.clone j1
	    val  p        = Path.fromLab(Label.fromName(I.name id))
	    val  _        = Inf.strengthen(p, j1')
	    val  id'      = elabModId_bind(E, p, j1', id)
	    val (j2,mod') = elabMod(E, mod)
	    val  _        = deleteScope E
	    val  j        = Inf.inArrow(p, j1, j2)
	in
	    ( j, O.FunMod(infInfo(i,j), id', inf', mod') )
	end

      | elabMod(E, I.AppMod(i, mod1, mod2)) =
	let
	    val (j1,mod1')  = elabMod(E, mod1)
	    val (j2,mod2')  = elabMod(E, mod2)
	    val (p,j11,j12) = if Inf.isArrow j1 then
				 Inf.asArrow(Inf.instance j1)
			      else
				 error(I.infoMod mod1, E.AppModFunMismatch j1)
(*DEBUG
val _ = (
print "#### Application ####\n\
\#### j_param =\n";
PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j11, 75);
print "\n\
\#### j_arg =\n";
PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j2, 75);
print "\n"
)*)
	    val  p2         = case elabMod_path(E, mod2)
				of SOME(p2,_) => p2
(*DEBUG*)
| NONE => Path.fromLab(Label.fromString "?arg")(*
				 | NONE       => Path.invent()
*)
	    val  _          = Inf.strengthen(p2, j2)
(*val _ = (
print "#### p_arg = ";
PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p2, 75);
print "\n\
\#### j_arg' =\n";
PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j2, 75);
print "\n"
)*)
	    val  rea        = Inf.match(j2,j11) handle Inf.Mismatch mismatch =>
				  error(i, E.AppModArgMismatch mismatch)
	    val  _          = PathMap.insert(#mod_rea rea, p, p2)
	    val  _          = Inf.realise(rea, j12)
	    val  j          = j12
	in
	    ( j, O.AppMod(infInfo(i,j), mod1', mod2') )
	end

      | elabMod(E, I.AnnMod(i, mod, inf)) =
	let
	    val (j1,mod') = elabMod(E, mod)
	    val (j2,inf') = elabGroundInf(E, inf)
	    val  _        = Inf.match(j1, j2) handle Inf.Mismatch mismatch =>
				error(i, E.AnnModMismatch mismatch)
	    val  j        = j2
	in
	    ( j, O.AnnMod(infInfo(i,j), mod', inf') )
	end

      | elabMod(E, I.UpMod(i, mod, inf)) =
	let
	    val (j1,mod') = elabMod(E, mod)
	    val (j2,inf') = elabGroundInf(E, inf)
	    val  j        = Inf.instance j2	(* opaque *)
	    val  _        = Inf.match(j1, j2) handle Inf.Mismatch mismatch =>
				error(i, E.AnnModMismatch mismatch)
	in
	    ( j, O.UpMod(infInfo(i,j), mod', inf') )
	end

      | elabMod(E, I.LetMod(i, decs, mod)) =
	let
	    val  _       = insertScope E
	    val  s       = Inf.empty()
	    val  decs'   = elabDecs(E, s, decs)
	    val  p       = Path.invent()
(*DEBUG*)
val p = Path.fromLab(Label.fromString "?let")
	    val  _       = Inf.strengthenSig(Path.invent(), s)
	    val (j,mod') = elabMod(E, mod)
	    val  _       = deleteScope E
	in
	    ( j, O.LetMod(infInfo(i,j), decs', mod') )
	end

      | elabMod(E, I.UnpackMod(i, exp, inf)) =
	let
	    val (t,exp') = elabExp(E, exp)
	    val (j,inf') = elabInf(E, inf)
	    val  j'      = Inf.instance j
	    (*UNFINISHED*)
	in
	    unfinished i "elabMod" "packages";
	    ( j', O.UnpackMod(infInfo(i,j), exp', inf') )
	end


  (* Modules as paths *)

    and elabMod_path(E, I.VarMod(i, I.Id(_, stamp, _))) =
	let
	    val {path=p, inf=j, ...} = lookupMod(E, stamp)
	in
	    SOME (p,j)
	end

      | elabMod_path(E, I.SelMod(_, mod, I.Lab(_, l))) =
	(case elabMod_path(E, mod)
	   of NONE      => NONE
	    | SOME(_,j) =>
	      let
		  val s = Inf.asSig j
		  val j = Inf.lookupMod(s, l)
		  val p = Inf.lookupModPath(s, l)
	      in
		  SOME (p,j)
	      end
	)

      | elabMod_path(E, I.AnnMod(_, mod, inf))=
	    elabMod_path(E, mod)

      | elabMod_path _ = NONE


  (* Interface identifiers *)

    and elabInfId_bind(E, p, j, id as I.Id(i, stamp, name)) =
	let
(*DEBUG
val x=case Name.toString(I.name id) of "?" => "?" | x => x
val _=print("-- insert interface " ^ x ^ "(" ^ Stamp.toString stamp ^ ") =\n")
val _=PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j, 75)
val _=print "\n"
*)
	    val j' = Inf.inAbbrev(Inf.inCon(Inf.kind j,p), j)
	    (*UNFINISHED: use punning: *)
	    val _  = insertInf(E, stamp, {id=id, path=p, inf=j'})
	in
	    O.Id(nonInfo(i), stamp, name)
	end

    and elabInfId(E, id as I.Id(i, stamp, name)) =
	let
(*DEBUG
val x=case Name.toString(I.name id) of "?" => "?" | x => x
val _=print("-- lookup interface " ^ x ^ "(" ^ Stamp.toString stamp ^ ") =\n")
val _=PrettyPrint.output(TextIO.stdOut, PPInf.ppInf(#inf(lookupInf(E, stamp))), 75)
val _=print "\n"
*)
	    val j = #inf(lookupInf(E, stamp))
	in
	    ( j, O.Id(nonInfo(i), stamp, name) )
	end

    and elabInfLongid(E, I.ShortId(i, id)) =
	let
	    val (j,id') = elabInfId(E, id)
	in
	    ( j, O.ShortId(nonInfo(i), id') )
	end

      | elabInfLongid(E, I.LongId(i, longid, lab)) =
	let
	    val (s,longid') = elabModLongid_path(E, longid)
	    val (l,lab')    = elabLab(E, lab)
	    val  j          = Inf.lookupInf(s, l)
	in
	    ( j, O.LongId(nonInfo(i), longid', lab') )
	end


  (* Interfaces *)

    and elabInf(E, I.TopInf(i)) =
	let
	    val j = Inf.inTop()
	in
	    ( j, O.TopInf(infInfo(i,j)) )
	end

      | elabInf(E, I.ConInf(i, longid)) =
	let
	    val (j,longid') = elabInfLongid(E, longid)
	    val  j'         = Inf.instance j
	in
	    ( j', O.ConInf(infInfo(i,j'), longid') )
	end

      | elabInf(E, I.SigInf(i, specs)) =
	let
	    val s      = Inf.empty()
	    val specs' = elabSpecs(E, s, specs)
	    val j      = Inf.inSig s
	in
	    ( j, O.SigInf(infInfo(i,j), specs') )
	end

      | elabInf(E, I.FunInf(i, id, inf1, inf2)) =
	let
	    val  _         = insertScope E
	    val (j1,inf1') = elabGroundInf(E, inf1)
	    val  j1'       = Inf.clone j1
	    val  p         = Path.fromLab(Label.fromName(I.name id))
	    val  _         = Inf.strengthen(p, j1')
	    (* UNFINISHED: revert renaming of paths somehow *)
	    val  id'       = elabModId_bind(E, p, j1', id)
	    val (j2,inf2') = elabInf(E, inf2)
	    val  _         = deleteScope E
	    val  j         = Inf.inLambda(p, j1, j2)
	in
	    ( j, O.FunInf(infInfo(i,j), id', inf1', inf2') )
	end

      | elabInf(E, I.AppInf(i, inf, mod)) =
	let
	    val (j1,inf') = elabInf(E, inf)
	    val (j2,mod') = elabMod(E, mod)
	(*UNFINISHED*)
	    val j = j1
	in
	    unfinished i "elabMod" "interface application";
	    ( j, O.AppInf(infInfo(i,j), inf', mod') )
	end

      | elabInf(E, I.CompInf(i, inf1, inf2)) =
	let
	    val (j1,inf1') = elabGroundInf(E, inf1)
	    val (j2,inf2') = elabGroundInf(E, inf2)
(*DEBUG
val _ = (
print "#### Intersection ####\n\
\#### j1 =\n";
PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j1, 75);
print "\n\
\#### j2 =\n";
PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j2, 75);
print "\n"
)*)
	    val  j         = Inf.intersect(j1,j2) handle Inf.Mismatch mismatch=>
				error(i, E.CompInfMismatch mismatch)
(*val _ = (
print "#### j =\n";
PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j, 75);
print "\n\
\#### End Intersection ####\n"
)*)
	in
	    ( j, O.CompInf(infInfo(i,j), inf1', inf2') )
	end

      | elabInf(E, I.ArrInf(i, id, inf1, inf2)) =
	let
	    val  _         = insertScope E
	    val (j1,inf1') = elabGroundInf(E, inf1)
	    val  j1'       = Inf.clone j1
	    val  p         = Path.fromLab(Label.fromName(I.name id))
	    val  _         = Inf.strengthen(p, j1')
	    val  id'       = elabModId_bind(E, p, j1', id)
	    val (j2,inf2') = elabGroundInf(E, inf2)
	    val  _         = deleteScope E
	    val  j         = Inf.inArrow(p, j1, j2)
	in
	    ( j, O.ArrInf(infInfo(i,j), id', inf1', inf2') )
	end

      | elabInf(E, I.LetInf(i, decs, inf)) =
	let
	    val  _       = insertScope E
	    val  s       = Inf.empty()
	    val  decs'   = elabDecs(E, s, decs)
	    val  p       = Path.invent()
(*DEBUG*)
val p = Path.fromLab(Label.fromString "?let")
	    val  _       = Inf.strengthenSig(Path.invent(), s)
	    val (j,inf') = elabInf(E, inf)
	    val  _       = deleteScope E
	in
	    ( j, O.LetInf(infInfo(i,j), decs', inf') )
	end

      | elabInf(E, I.SingInf(i, mod)) =
	let
	    val (j,mod') = elabMod(E, mod)
(*DEBUG*)
val _ = Inf.strengthen(Path.fromLab(Label.fromString "?singleton"), j)
	    val  _       = Inf.strengthen(Path.invent(), j)
(*DEBUG
val _ = (
print "#### Singleton ####\n\
\#### j =\n";
PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j, 75);
print "\n"
)*)
	    val  j'      = Inf.singleton j
(*val _ = (
print "#### j' =\n";
PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j', 75);
print "\n\
\#### End Singleton ####\n"
)*)
	in
	    ( j', O.SingInf(infInfo(i,j'), mod') )
	end

      | elabInf(E, I.AbsInf(i)) =
	    raise Crash.Crash "Elab.elabInf: AbsInf"


  (* Interfaces in positions where they not be higher order *)

    and elabGroundInf(E, inf) =
	let
	    val jinf' as (j,_) = elabInf(E, inf)
	    val k              = Inf.kind j
	in
	    if Inf.isGround k then
		jinf'
	    else
		error(I.infoInf inf, E.GroundInfKind(k))
	end


  (* Interfaces representations (RHSs of bindings) *)

    and elabInfRep(E, p', buildKind, I.FunInf(i, id, inf1, inf2)) =
	let
	    val  _             = insertScope E
	    val (j1,inf1')     = elabGroundInf(E, inf1)
	    val  j1'           = Inf.clone j1
	    val  p             = Path.fromLab(Label.fromName(I.name id))
	    val  _             = Inf.strengthen(p, j1')
	    val  id'           = elabModId_bind(E, p, j1', id)
	    val (j2,gen,inf2') = elabInfRep(E, p',
				     fn k => Inf.inDependent(p,j1,buildKind k),
				     inf2)
	    val  _             = deleteScope E
	    val  j             = Inf.inLambda(p, j1, j2)
	in
	    ( j, gen, O.FunInf(infInfo(i,j), id', inf1', inf2') )
	end

      | elabInfRep(E, p, buildKind, I.AbsInf(i)) =
	let
	    val c = (buildKind(Inf.inGround()), p)
	    val j = Inf.inCon c
	in
	    ( j, true, O.AbsInf(infInfo(i,j)) )
	end

      | elabInfRep(E, p, buildKind, inf) =
	let
	    val (j,inf') = elabInf(E, inf)
	in
	    ( j, false, inf' )
	end


  (* Declarations *)

    and elabDec(E, s, vars, I.ValDec(i, pat, exp)) =
	let
	    val  _        = insertScope E
	    val  _        = Type.enterLevel()
	    val  _        = enterVars(E, vars)
	    val  _        = insertScope E
	    val (t2,exp') = elabExp(E, exp)
	    val  _        = deleteScope E
	    val (t1,pat') = elabPat(E, s, pat)
	    val  _        = Type.exitLevel()
	    val  E'       = splitScope E
	    val  _        = Type.unify(t1,t2) handle Type.Unify(t3,t4) =>
				error(i, E.ValDecUnify(t1, t2, t3, t4))
	    (* UNFINISHED: if pat = x and exp = y then equate x to y *)
	    val  _        = appVals (generaliseVal
					(E, s, SOME NONE, isValue exp)) E'
	in
	    O.ValDec(nonInfo(i), pat', exp')
	end

      | elabDec(E, s, vars, I.ConDec(i, id, typ, k)) =
	let
	    val (t0,p,id')  = elabValId_bind(E, s, Inf.CONSTRUCTOR, id)
	    val (t,typ')    = elabStarTyp(E, typ)
	    (*UNFINISHED: check that type is extensible or an appropriate sum*)
	    val  d          = case typ
				of I.SingTyp(_, longid) =>
					SOME(elabValLongid_path(E,longid))
				 | _ => NONE
	    val  _          = Type.unify(t,t0)
	    val  _          = Inf.extendVal(s, p, t, Inf.CONSTRUCTOR, d)
	in
	    O.ConDec(nonInfo(i), id', typ', k)
	end

      | elabDec(E, s, vars, I.TypDec(i, id, typ)) =
	let
	    val  p             = Inf.newTyp(s, Label.fromName(I.name id))
	    val (t,gen,w,typ') = elabTypRep(E, p, fn k'=>k', typ)
	    val  id'           = elabTypId_bind(E, p, t, w, id)
	    val  _             = Inf.extendTyp(s, p, Type.kind t, w, SOME t)
(*DEBUG
val x=case Name.toString(I.name id) of "?" => "?" ^ Stamp.toString(I.stamp id) | x => x
val _=print("type " ^ x ^ " = ")
val _=PrettyPrint.output(TextIO.stdOut, PPType.ppTyp t, 60)
val _=print "\n"
*)
	in
	    O.TypDec(nonInfo(i), id', typ')
	end

      | elabDec(E, s, vars, I.ModDec(i, id, mod)) =
	let
	    val  p       = Inf.newMod(s, Label.fromName(I.name id))
	    val (j,mod') = elabMod(E, mod)
	    val  _       = Inf.strengthen(p, j)
	    val  p'      = case elabMod_path(E, mod)
			     of SOME (p',_) => p'
			      | NONE        => p
	    val  id'     = elabModId_bind(E, p', j, id)
	    val  _       = Inf.extendMod(s, p, j, SOME p')
	in
	    O.ModDec(nonInfo(i), id', mod')
	end

      | elabDec(E, s, vars, I.InfDec(i, id, inf)) =
	let
	    val  p         = Inf.newInf(s, Label.fromName(I.name id))
	    val (j,_,inf') = elabInfRep(E, p, fn k'=>k', inf)
	    val  k         = Inf.kind j
	    val  id'       = elabInfId_bind(E, p, j, id)
	    val  _         = Inf.extendInf(s, p, k, SOME j)
	in
	    O.InfDec(nonInfo(i), id', inf')
	end

      | elabDec(E, s, vars, I.FixDec(i, id, fix)) =
	let
	    val  id'     = elabValId_bind'(E, id)
	    val (f,fix') = elabFix(E, fix)
	in
	    O.FixDec(nonInfo(i), id', fix')
	end

      | elabDec(E, s, vars, I.VarDec(i, id, dec)) =
	let
	    val id'  = elabVarId_bind'(E, id)
	    val dec' = elabDec(E, s, id::vars, dec)
	in
	    O.VarDec(nonInfo(i), id', dec')
	end

      | elabDec(E, s, vars, I.RecDec(i, decs)) =
	let
	    val _      = insertScope E
	    val _      = Type.enterLevel()
	    val _      = enterVars(E, vars)
	    val tpats' = elabLHSRecDecs(E, s, decs)
	    val decs'  = elabRHSRecDecs(E, s, ref tpats', decs)
	    val _      = Type.exitLevel()
	    val E'     = splitScope E
	    (* ASSUME that only ValDec or TypDec are under RecDec *)
	    (* ASSUME that recursive ValDecs are never expansive *)
	    (* ASSUME that recursive ValDecs are never equatable *)
	    val _      = appTyps (fn(x,entry) => insertTyp(E,x,entry)) E'
	    val _      = appVals (generaliseVal (E, s, SOME NONE, true)) E'
	in
	    O.RecDec(nonInfo(i), decs')
	end

      | elabDec(E, s, vars, I.LocalDec(i, decs)) =
	let
	    val s'    = Inf.empty()
	    val decs' = elabDecs(E, s', decs)
	    val p     = Path.invent()
(*DEBUG*)
val p = Path.fromLab(Label.fromString "?local")
	    val _     = Inf.strengthenSig(p, s')
	in
	    O.LocalDec(nonInfo(i), decs')
	end


    and enterVars(E, vars) =
	List.app (fn id as I.Id(_, stamp, name) =>
		  (*UNFINISHED: use punning: *)
		  insertVar(E, stamp, {id=id, var = Type.var(Type.STAR)})) vars

    and generaliseVal (E, s, poo, isPoly) (x, {id, path=p, typ=t, sort=w}) =
	let
	    val t' = if isPoly then Type.close t
			       else (Type.lift t ; t) handle Type.Lift a =>
				   error(I.infoId id, E.ValDecLift(id, a))
	    val d  = Option.map (fn po => Option.getOpt(po, p)) poo
	in
	    (*UNFINISHED: use record update: *)
	    (*insertVal(E, x, {entry where typ=t'}));*)
	    insertVal(E, x, {id=id, path=p, typ=t', sort=w});
	    Inf.extendVal(s, p, t', w, d)
(*DEBUG
;let val x= case Name.toString(I.name id) of "?" => "?" ^ Stamp.toString x | x => x
in print("val " ^ x ^ " : ") end;
PrettyPrint.output(TextIO.stdOut, PPType.ppTyp t', 60);
print(if w = Inf.CONSTRUCTOR then " (* constructor *)\n" else if isPoly then "\n" else " (* not generalised *)\n")
"*)
	end


      and elabDecs(E, s, decs)        = elabDecs'(E, s, [], decs)
      and elabDecs'(E, s, vars, decs) =
	    List.map (fn dec => elabDec(E, s, vars, dec)) decs
(*DEBUG
and elabDecs(E, s, decs)        = (lev:= !lev+1;elabDecs'(E, s, [], decs) before lev:= !lev-1)
and elabDecs'(E, s, vars, decs) =
    List.map (fn dec => elabDec'(E, s, vars, dec)) decs
and elabDec' bla =
( print("Elaborating declaration at "^Source.regionToString(I.infoDec(#4 bla))^" (level "^Int.toString(!lev)^"): "^
    (case #4 bla
       of I.ValDec _ => "ValDec"
        | I.ConDec _ => "ConDec"
	| I.TypDec _ => "TypDec"
	| I.ModDec _ => "ModDec"
	| I.InfDec _ => "InfDec"
	| I.FixDec _ => "FixDec"
	| I.VarDec _ => "VarDec"
	| I.RecDec _ => "RecDec"
	| I.LocalDec _ => "LocalDec"
    )
  ^"\n")
(*; TextIO.inputLine(TextIO.stdIn)*)
; elabDec bla )
*)


  (* Recursive declarations *)

    and elabLHSRecDecs(E, s, decs) =
	List.foldr (fn(dec,xs) => elabLHSRecDec(E,s,dec) @ xs) [] decs

    and elabLHSRecDec(E, s, I.ValDec(i, pat, exp)) =
	    [elabPat(E, s, pat)]

      | elabLHSRecDec(E, s, I.TypDec(i, id, typ)) =
	let
	    val p = Inf.newTyp(s, Label.fromName(I.name id))
	    val k = elabTypKind(E, typ)
	    val t = Type.inMu(Type.unknown k)
	    val _ = elabTypId_bind(E, p, t, Type.CLOSED, id)
			(* Type sort is updated in elabRHSRecDec *)
	in
	    []
	end

      | elabLHSRecDec(E, s, I.RecDec(i, decs)) =
	    elabLHSRecDecs(E, s, decs)

      | elabLHSRecDec(E, s, _) = raise Crash.Crash "elabLHSRecDec"


    and elabRHSRecDecs(E, s, rtpats', decs) =
	    List.map (fn dec => elabRHSRecDec(E, s, rtpats', dec)) decs
(*DEBUG
and elabRHSRecDecs(E, s, rtpats', decs) =
    List.map (fn dec => elabRHSRecDec'(E, s, rtpats', dec)) decs
and elabRHSRecDec' bla =
( print("Elaborating rec declaration at "^Source.regionToString(I.infoDec(#4 bla))^" (level "^Int.toString(!lev)^"): "^
    (case #4 bla
       of I.ValDec _ => "ValDec"
        | I.ConDec _ => "ConDec"
	| I.TypDec _ => "TypDec"
	| I.ModDec _ => "ModDec"
	| I.InfDec _ => "InfDec"
	| I.FixDec _ => "FixDec"
	| I.VarDec _ => "VarDec"
	| I.RecDec _ => "RecDec"
	| I.LocalDec _ => "LocalDec"
    )
  ^"\n")
(*; TextIO.inputLine(TextIO.stdIn)*)
; elabRHSRecDec bla )
*)

    and elabRHSRecDec(E, s, r as ref((t1,pat')::tpats'), I.ValDec(i, pat, exp))=
	let
	    val  _        = insertScope E
	    val (t2,exp') = elabExp(E, exp)
	    val  _        = deleteScope E
	    val  _        = r := tpats'
	    val  _        = Type.unify(t1,t2) handle Type.Unify(t3,t4) =>
				error(i, E.ValDecUnify(t1, t2, t3, t4))
	in
	    O.ValDec(nonInfo(i), pat', exp')
	end

      | elabRHSRecDec(E, s, rtpats', I.TypDec(i, id, typ)) =
	let
	    val (t0,p,_,id') = elabTypId(E, id)
	    val (t,_,w,typ') = elabTypRep(E, p, fn k'=>k', typ)
	    val  t1          = #2(Type.asAbbrev t0)
	    val  _           = Type.unify(Type.inMu t, t1)
	    val  _           = elabTypId_bind(E, p, t1, w, id)
				(* Updates type sort *)
	    val  _           = Inf.extendTyp(s, p, Type.kind t1, w, SOME t1)
(*DEBUG
val x= case Name.toString(I.name id) of "?" => "?" ^ Stamp.toString(I.stamp id) | x => x
val _= print("type " ^ x ^ " = ")
val _=PrettyPrint.output(TextIO.stdOut, PPType.ppTyp t, 60)
val _=print "\n"
*)
	in
	    O.TypDec(nonInfo(i), id', typ')
	end

      | elabRHSRecDec(E, s, rtpats', I.RecDec(i, decs)) =
	let
	    val dec' = elabRHSRecDecs(E, s, rtpats', decs)
	in
	    O.RecDec(nonInfo(i), dec')
	end

      | elabRHSRecDec(E, s, rtpats', dec) =
	    raise Crash.Crash "elabRHSRecDec"



  (* Specifications *)

    and elabSpec(E, s, I.ValSpec(i, id, typ)) =
	let
	    val (t0,p,id') = elabValId_bind(E, s, Inf.VALUE, id)
	    val (t,typ')   = elabStarTyp(E, typ)
	    val  d          = case typ
				of I.SingTyp(_, longid) =>
					SOME(elabValLongid_path(E,longid))
				 | _ => NONE
	    val  _         = Type.unify(t,t0)
	    val  _         = Inf.extendVal(s, p, t, Inf.VALUE, d)
	in
	    O.ValSpec(nonInfo(i), id', typ')
	end

      | elabSpec(E, s, I.ConSpec(i, id, typ, k)) =
	let
	    val (t0,p,id')  = elabValId_bind(E, s, Inf.CONSTRUCTOR, id)
	    val (t,typ')    = elabStarTyp(E, typ)
	    (*UNFINISHED: check that type is extensible or an appropriate sum *)
	    val  d          = case typ
				of I.SingTyp(_, longid) =>
					SOME(elabValLongid_path(E,longid))
				 | _ => NONE
	    val  _          = Type.unify(t,t0)
	    val  _          = Inf.extendVal(s, p, t, Inf.CONSTRUCTOR, d)
	in
	    O.ConSpec(nonInfo(i), id', typ', k)
	end

      | elabSpec(E, s, I.TypSpec(i, id, typ)) =
	let
	    val  p             = Inf.newTyp(s, Label.fromName(I.name id))
	    val (t,gen,w,typ') = elabTypRep(E, p, fn k'=>k', typ)
	    val  id'           = elabTypId_bind(E, p, t, w, id)
	    val  _             = Inf.extendTyp(s, p, Type.kind t, w,
					       if gen then NONE else SOME t)
	in
	    O.TypSpec(nonInfo(i), id', typ')
	end

      | elabSpec(E, s, I.ModSpec(i, id, inf)) =
	let
	    val  p       = Inf.newMod(s, Label.fromName(I.name id))
	    val (j,inf') = elabGroundInf(E, inf)
	    val  j'      = Inf.clone j
(*DEBUG
val _ = (
print "#### Mod Spec ####\n\
\#### j =\n";
PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j, 75);
print "\n\
\#### j' =\n";
PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j', 75);
print "\n"
)*)
	    val  _       = Inf.strengthen(p, j')
(*val _ = (
print "#### j =\n";
PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j, 75);
print "\n\
\#### j' =\n";
PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j', 75);
print "\n\
\#### End Mod Spec ####\n"
)*)
	    (* UNFINISHED: revert renaming of paths somehow *)
	    val (p',d)   = case inf
			     of I.SingInf(i', mod) =>
				(case elabMod_path(E, mod)
				   of NONE        => error(i', E.SingInfPath)
				    | SOME (p',_) => (p', SOME p')
				)
			      | _ => (p, NONE)
	    val  id'     = elabModId_bind(E, p', j', id)
	    val  _       = Inf.extendMod(s, p, j, d)
	in
	    O.ModSpec(nonInfo(i), id', inf')
	end

      | elabSpec(E, s, I.InfSpec(i, id, inf)) =
	let
	    val  p           = Inf.newInf(s, Label.fromName(I.name id))
	    val (j,gen,inf') = elabInfRep(E, p, fn k'=>k', inf)
	    val  k           = Inf.kind j
	    val  id'         = elabInfId_bind(E, p, j, id)
	    val  _           = Inf.extendInf(s, p, k,
					     if gen then NONE else SOME j)
	in
	    O.InfSpec(nonInfo(i), id', inf')
	end

      | elabSpec(E, s, I.FixSpec(i, id, fix)) =
	let
	    val id'      = elabValId_bind'(E, id)
	    val (f,fix') = elabFix(E, fix)
	in
	    O.FixSpec(nonInfo(i), id', fix')
	end

      | elabSpec(E, s, I.RecSpec(i, specs)) =
	let
	    val _      = elabLHSRecSpecs(E, s, specs)
	    val specs' = elabRHSRecSpecs(E, s, specs)
	    (* ASSUME that only TypSpec is under RecSpec *)
	in
	    O.RecSpec(nonInfo(i), specs')
	end

      | elabSpec(E, s, I.ExtSpec(i, inf)) =
	let
	    val (j,inf') = elabGroundInf(E, inf)
	(*UNFINISHED: insert stuff*)
	in
	    unfinished i "elabSpec" "signature extension";
	    O.ExtSpec(nonInfo(i), inf')
	end


    and elabSpecs(E, s, specs) =
	List.map (fn spec => elabSpec(E, s, spec)) specs
(*DEBUG
and elabSpecs(E, s, specs) =
( lev:= !lev+1;
  List.map (fn spec => elabSpec'(E, s, spec)) specs
  before lev:= !lev-1
)
and elabSpec' bla =
( print("Elaborating specification at "^Source.regionToString(I.infoSpec(#3 bla))^" (level "^Int.toString(!lev)^"): "^
    (case #3 bla
       of I.ValSpec _ => "ValSpec"
        | I.ConSpec _ => "ConSpec"
	| I.TypSpec _ => "TypSpec"
	| I.ModSpec _ => "ModSpec"
	| I.InfSpec _ => "InfSpec"
	| I.FixSpec _ => "FixSpec"
	| I.RecSpec _ => "RecSpec"
	| I.ExtSpec _ => "ExtSpec"
    )
  ^"\n")
(*; TextIO.inputLine(TextIO.stdIn)*)
; elabSpec bla )
*)


  (* Recursive specifications *)

    and elabLHSRecSpecs(E, s, specs) =
	List.app (fn spec => elabLHSRecSpec(E,s,spec)) specs

    and elabLHSRecSpec(E, s, I.TypSpec(i, id, typ)) =
	let
	    val p = Inf.newTyp(s, Label.fromName(I.name id))
	    val k = elabTypKind(E, typ)
	    val t = Type.inMu(Type.unknown k)
	    val _ = elabTypId_bind(E, p, t, Type.CLOSED, id)
			(* Type sort is updated in elabRHSRecSpec *)
	in
	    ()
	end

      | elabLHSRecSpec(E, s, I.RecSpec(i, specs)) =
	    elabLHSRecSpecs(E, s, specs)

      | elabLHSRecSpec(E, s, _) = ()


    and elabRHSRecSpecs(E, s, specs) =
	List.map (fn spec => elabRHSRecSpec(E, s, spec)) specs
(*DEBUG
and elabRHSRecSpecs(E, s, specs) =
    List.map (fn spec => elabRHSRecSpec'(E, s, spec)) specs
and elabRHSRecSpec' bla =
( print("Elaborating rec specification at "^Source.regionToString(I.infoSpec(#3 bla))^" (level "^Int.toString(!lev)^"): "^
    (case #3 bla
       of I.ValSpec _ => "ValSpec"
        | I.ConSpec _ => "ConSpec"
	| I.TypSpec _ => "TypSpec"
	| I.ModSpec _ => "ModSpec"
	| I.InfSpec _ => "InfSpec"
	| I.FixSpec _ => "FixSpec"
	| I.RecSpec _ => "RecSpec"
	| I.ExtSpec _ => "ExtSpec"
    )
  ^"\n")
(*; TextIO.inputLine(TextIO.stdIn)*)
; elabRHSRecSpec bla )
*)

    and elabRHSRecSpec(E, s, I.RecSpec(i, specs)) =
	let
	    val spec' = elabRHSRecSpecs(E, s, specs)
	in
	    O.RecSpec(nonInfo(i), spec')
	end

      | elabRHSRecSpec(E, s, I.TypSpec(i, id, typ)) =
	let
	    val (t0,p,_,id')   = elabTypId(E, id)
	    val (t,gen,w,typ') = elabTypRep(E, p, fn k'=>k', typ)
	    val  t1            = #2(Type.asAbbrev t0)
	    val  _             = Type.unify(Type.inMu t, t1)
	    val  _             = elabTypId_bind(E, p, t1, w, id)
				 (* Updates type sort *)
	    val  _             = Inf.extendTyp(s, p, Type.kind t1, w,
					       if gen then NONE else SOME t1)
	in
	    O.TypSpec(nonInfo(i), id', typ')
	end

      | elabRHSRecSpec(E, s, spec) =
	    elabSpec(E, s, spec)


  (* Announcements *)

    fun elabAnn(E, I.ImpAnn(i, imps, url)) =
	let
	    val s     = Composer.sign url
			(*UNFINISHED: Handling of IO failure? *)
	    val imps' = elabImps(E, s, imps)
	in
	    O.ImpAnn(nonInfo(i), imps', url)
	end

    and elabAnns(E, anns) = List.map (fn ann => elabAnn(E, ann)) anns


  (* Imports *)

    and elabImp(E, s, I.ValImp(i, id, desc)) =
	let
	    val (t0,p,id') = elabValId_bind(E, s, Inf.VALUE, id)
	    val  a         = Label.fromName(O.name id')
	    val  t1        = Inf.lookupVal(s, a)
	    val (t2,desc') = case desc
				of I.NoDesc(i') =>
				   (t1, O.NoDesc(typInfo(i',t1)))
				 | I.SomeDesc(i',typ) =>
				   let				
				      val (t2,typ')  = elabStarTyp(E, typ)
				   in
				      if Type.matches(t2,t1) then
					  (t2, O.SomeDesc(typInfo(i',t2), typ'))
				      else
					  error(i, E.ValItemMismatch(a,t2,t1))
				   end
	    val  _         = Type.unify(t2,t0)
	in
	    O.ValImp(nonInfo(i), id', desc')
	end

      | elabImp(E, s, I.ConImp(i, id, desc, k)) =
	let
	    val (t0,p,id')  = elabValId_bind(E, s, Inf.CONSTRUCTOR, id)
	    val  a          = Label.fromName(O.name id')
	    val  t1         = Inf.lookupVal(s, a)
	    (*UNFINISHED: check that it is constructor*)
	    (*UNFINISHED: check that type is extensible or an appropriate sum *)
	    val (t2,desc') = case desc
				of I.NoDesc(i') =>
				   (t1, O.NoDesc(typInfo(i',t1)))
				 | I.SomeDesc(i',typ) =>
				   let				
				      val (t2,typ')  = elabStarTyp(E, typ)
				   in
				      if Type.matches(t2,t1) then
					  (t2, O.SomeDesc(typInfo(i',t2), typ'))
				      else
					  error(i, E.ValItemMismatch(a,t2,t1))
				   end
	    val  _         = Type.unify(t2,t0)
	in
	    O.ConImp(nonInfo(i), id', desc', k)
	end

      | elabImp(E, s, I.TypImp(i, id, desc)) =
	let
	    (*UNFINISHED: have to check (or disallow) manifest type *)
	    val  a            = Label.fromName(I.name id)
	    val  p            = Inf.newTyp(s, a)
	    val  t1           = Inf.lookupTyp(s, a)
	    val  w1           = Inf.lookupTypSort(s, a)
	    val (t2,w2,desc') = case desc
				of I.NoDesc(i') =>
				   (t1, w1, O.NoDesc(typInfo(i', t1)))
				 | I.SomeDesc(i',typ) =>
				   let
				      val (t2,_,w2,typ') =
						elabTypRep(E, p, fn k'=>k', typ)
				      val  k1 = Type.kind t1
				      val  k2 = Type.kind t2
				   in
				      if k2 = k1 then
					 (t1,w1,O.SomeDesc(typInfo(i',t1),typ'))
				      else
					 error(i, E.TypItemMismatch(a,k2,k1))
				   end
	    val  id'       = elabTypId_bind(E, p, t2, w2, id)
	in
	    O.TypImp(nonInfo(i), id', desc')
	end

      | elabImp(E, s, I.ModImp(i, id, desc)) =
	let
	    val  a         = Label.fromName(I.name id)
	    val  p         = Inf.newMod(s, a)
	    val  j1        = Inf.lookupMod(s, a)
	    val (j2,desc') = case desc
				of I.NoDesc(i') =>
				   (j1, O.NoDesc(infInfo(i',j1)))
				 | I.SomeDesc(i',inf) =>
				   let				
				       val (j2,inf') = elabGroundInf(E, inf)
				       val  j2'      = Inf.clone j2
				       val  _        = Inf.strengthen(p, j2')
				   in
				       Inf.match(j2,j1) handle Inf.Mismatch m =>
					   error(i, E.ModItemMismatch(a, m)) ;
				       (j2', O.SomeDesc(infInfo(i',j2'), inf'))
				   end
	    val id'        = elabModId_bind(E, p, j2, id)
	in
	    O.ModImp(nonInfo(i), id', desc')
	end

      | elabImp(E, s, I.InfImp(i, id, desc)) =
	let
	    val  a         = Label.fromName(I.name id)
	    val  p         = Inf.newInf(s, a)
	    val  j1        = Inf.lookupInf(s, a)
	    val (j2,desc') = case desc
				of I.NoDesc(i') =>
				   (j1, O.NoDesc(infInfo(i',j1)))
				 | I.SomeDesc(i',inf) =>
				   let				
					val (j2,gen,inf') =
						elabInfRep(E, p, fn k'=>k', inf)
					val  k2 = Inf.kind j2
				   in
					Inf.equaliseKind(k2, Inf.kind j1)
					handle Inf.Mismatch m =>
					    error(i, E.InfItemMismatch(a,m)) ;
					(j1, O.SomeDesc(infInfo(i',j1), inf'))
				   end
	    val  id'       = elabInfId_bind(E, p, j2, id)
	in
	    O.InfImp(nonInfo(i), id', desc')
	end

      | elabImp(E, s, I.FixImp(i, id, desc)) =
	let
	    val a     = Label.fromName(I.name id)
	    val id'   = elabValId_bind'(E, id)
	    val f1    = Inf.lookupFix(s, a)
	    val desc' = case desc
			  of I.NoDesc(i')       => O.NoDesc(fixInfo(i',f1))
			   | I.SomeDesc(i',fix) =>
				let
				    val (f2,fix') = elabFix(E, fix)
				in
				    if f2 = f1 then
					O.SomeDesc(fixInfo(i',f2), fix')
				    else
					error(i, E.FixItemMismatch(a,f2,f1))
				end
	in
	    O.FixImp(nonInfo(i), id', desc')
	end

      | elabImp(E, s, I.RecImp(i, imps)) =
	let
	    val _     = elabLHSRecImps(E, s, imps)
	    val imps' = elabRHSRecImps(E, s, imps)
	    (* ASSUME that only TypImp is under RecImp *)
	in
	    O.RecImp(nonInfo(i), imps')
	end


    and elabImps(E, s, imps) = List.map (fn imp => elabImp(E, s, imp)) imps


  (* Recursive specifications *)

    and elabLHSRecImps(E, s, imps) =
	List.app (fn imp => elabLHSRecImp(E,s,imp)) imps

    and elabLHSRecImp(E, s, I.TypImp(i, id, desc)) =
	let
	    val a  = Label.fromName(I.name id)
	    val p  = Inf.newTyp(s, a)
	    val t1 = Inf.lookupTyp(s, a)
	    val k1 = Type.kind t1
	    val w1 = Inf.lookupTypSort(s, a)
	    val _  = case desc
			of I.NoDesc(i')       => ()
			 | I.SomeDesc(i',typ) =>
			   let
				val k2 = elabTypKind(E, typ)
			   in
				if k2 = k1 then () else
				    error(i, E.TypItemMismatch(a,k2,k1))
			   end
	    val _  = elabTypId_bind(E, p, t1, w1, id)
	in
	    ()
	end

      | elabLHSRecImp(E, s, I.RecImp(i, imps)) =
	    elabLHSRecImps(E, s, imps)

      | elabLHSRecImp(E, s, _) = ()


    and elabRHSRecImps(E, s, imps) =
	List.map (fn imp => elabRHSRecImp(E, s, imp)) imps

    and elabRHSRecImp(E, s, I.RecImp(i, imps)) =
	let
	    val imps' = elabRHSRecImps(E, s, imps)
	in
	    O.RecImp(nonInfo(i), imps')
	end

      | elabRHSRecImp(E, s, I.TypImp(i, id, desc)) =
	let
	    (*UNFINISHED: have to check (or disallow) manifest type *)
	    val (t1,p,w1,id') = elabTypId(E, id)
	    val (t2,w2,desc') = case desc
				of I.NoDesc(i') =>
				   (t1, w1, O.NoDesc(typInfo(i',t1)))
				 | I.SomeDesc(i',typ) =>
				   let
				      val (t2,_,w2,typ') =
						elabTypRep(E, p, fn k'=>k', typ)
				   in
				      (t1, w1, O.SomeDesc(typInfo(i',t1),typ'))
				   end
	in
	    O.TypImp(nonInfo(i), id', desc')
	end

      | elabRHSRecImp(E, s, imp) =
	    elabImp(E, s, imp)


  (* Components *)

    fun elabComp(E, I.Comp(i, anns, decs)) =
	let
	    val anns' = elabAnns(E, anns)
	    val s     = Inf.empty()
	    val decs' = elabDecs(E, s, decs)
	    val _     = Inf.close s handle Inf.Unclosed lnt =>
			    error(i, E.CompUnclosed lnt)
(*DEBUG*)
val n = List.foldl (fn(i,n) => if Inf.isInfItem i then n+1 else n) 0 (Inf.items s)
val _ = if n < ~160 then
  print "Component signature too large to be printed\n"
else
( print "Component signature:\n"
; PrettyPrint.output(TextIO.stdOut, PPInf.ppSig s, 78)
; print "\n"
)
	in
	    O.Comp(nonInfo(i), anns', decs')
	end


    fun translate E component =
	let
	    val _         = insertScope E
	    val impsdecs' = elabComp(E, component)
	    val _         = mergeScope E
	in
	    impsdecs'
	end
	handle Error.Error x =>
	    ( deleteScope E
	    ; Type.resetLevel()
	    ; raise Error.Error x
	    )

  end

structure ElaborationPhase = MakeElaborationPhase(fun sign _ = Inf.empty())
(* src # 88 ../frontend-common/TRANSLATION_PHASE.sig *)
signature TRANSLATION_PHASE =
  sig
    structure C : CONTEXT              = EmptyContext
    structure I : ABSTRACT_GRAMMAR     = TypedGrammar
    structure O : INTERMEDIATE_GRAMMAR = IntermediateGrammar

    val translate : C.t -> I.comp -> O.comp
  end
(* src # 89 ../frontend-common/TranslationPhase.sml *)
structure TranslationPhase :> TRANSLATION_PHASE =
  struct

    structure C = EmptyContext
    structure I = TypedGrammar
    structure O = IntermediateGrammar

    open TypedInfo


  (* Recognize sum type constructors (tags) *)

    fun isTagType t =
	Type.isArrow t andalso isTagType(#2(Type.asArrow t)) orelse
	Type.isAll t   andalso isTagType(#2(Type.asAll t))   orelse
	Type.isExist t andalso isTagType(#2(Type.asExist t)) orelse
	Type.isSum t


  (* Names and labels *)

    fun trName  n		= n
    fun trName'(n as Name.InId)	= n
      | trName'(Name.ExId s)	= Name.ExId("$" ^ s)

    fun trLabel l		= Label.fromName(trName(Label.toName l))
    fun trLabel' l		= Label.fromName(trName'(Label.toName l))


  (* Transformation of type info *)

    fun kindToKind k =
	if Inf.isGround k then
	    Type.STAR
	else if Inf.isGround k then
	    let
		val (p,j,k1) = Inf.asDependent k
	    in
		Type.ARROW(Type.STAR, kindToKind k1)
	    end
	else
	    raise Crash.Crash "TranslationPhase.kindToKind: unknown kind"

    fun infToTyp j =
	if Inf.isTop j then
	    (*UNFINISHED: is this right? *)
	    PreboundType.typ_unit
	else if Inf.isCon j then
	    let
		val (k,p) = Inf.asCon j
	    in
		Type.inCon(kindToKind k, Type.CLOSED, p)
	    end
	else if Inf.isSig j then
	    let
		val s = Inf.asSig j
	    in
		Type.inProd(sigToRow s)
	    end
	else if Inf.isArrow j then
	    let
		val (p,j1,j2) = Inf.asArrow j
	    in
		Type.inArrow(infToTyp j1, infToTyp j2)
	    end
	else if Inf.isLambda j then
	    let
		val (p,j1,j2) = Inf.asLambda j
	    in
		Type.inLambda(Type.var(Type.STAR), infToTyp j2)
	    end
	else if Inf.isApply j then
	    let
		val (j1,p,j2) = Inf.asApply j
	    in
		Type.inApply(infToTyp j1, infToTyp j2)
	    end
	else
	    raise Crash.Crash "TranslationPhase.infToTyp: unknown inf"

    and sigToRow s			= itemsToRow(Inf.items s)

    and itemsToRow  []			= Type.emptyRow()
      | itemsToRow(i::is)		=
	let
	    val r = itemsToRow is
	in
	    if Inf.isValItem i then
		let
		    val (l,t,s,d) = Inf.asValItem i
		in
		    Type.extendRow(trLabel l, [t], r)
		end
	    else if Inf.isModItem i then
		let
		    val (l,j,d) = Inf.asModItem i
		in
		    Type.extendRow(trLabel' l, [infToTyp j], r)
		end
	    else
		r
	end

    fun trInfo {region,inf} = { region = region, typ = infToTyp inf }
    (*UNFINISHED: use punning*)


  (* Create fields for all structures and values in an environment *)

    fun idToField(x' as O.Id(i,_,n), t) =
	    O.Field(i, O.Lab(i,Label.fromName n),
		       O.VarExp(typInfo(#region i,t), O.ShortId(i, x')))

    fun idToDec(O.Id(i as {region=r,...}, z, n), y, t) =
	let
	    val l    = Label.fromName n
	    val tMod = Type.inProd(Type.extendRow(l, [t], Type.unknownRow()))
	    val tSel = Type.inArrow(tMod, t)
	in
	    O.ValDec(i, O.VarPat(typInfo(r,t), O.Id(i,z,n)),
			O.AppExp(typInfo(r,t),
				 O.SelExp(typInfo(r,tSel), O.Lab(i,l)),
				 O.VarExp(typInfo(r,tMod), y)))
	end

    fun idsToRow'(     [],    r) = r
      | idsToRow'((x,t)::ids, r) =
	Type.extendRow(Label.fromName(O.name x), [t], r)

    fun idsToRow ids = idsToRow'(ids, Type.emptyRow())



  (* Literals *)

    fun trLit(I.WordLit w)		= O.WordLit w
      | trLit(I.IntLit n)		= O.IntLit n
      | trLit(I.CharLit c)		= O.CharLit c
      | trLit(I.StringLit s)		= O.StringLit s
(*    | trLit(I.RealLit x)		= O.RealLit x
UNFINISHED: obsolete after bootstrapping:
*)    | trLit(I.RealLit x)		= O.RealLit(LargeReal.toString x)


  (* Identifiers *)

    fun trLab(I.Lab(i,l))		= O.Lab(i, trLabel  l)
    fun trLab'(I.Lab(i,l))		= O.Lab(i, trLabel' l)

    fun trId(I.Id(i,z,n))		= O.Id(i, z, trName n)
    fun trId'(I.Id(i,z,n))		= O.Id(i, z, trName' n)

    fun trLongid'(I.ShortId(i,x))	= O.ShortId(i, trId' x)
      | trLongid'(I.LongId(i,y,a))	= O.LongId(i, trLongid' y, trLab' a)

    fun trLongid(I.ShortId(i,x))	= O.ShortId(i, trId x)
      | trLongid(I.LongId(i,y,a))	= O.LongId(i, trLongid' y, trLab a)


  (* Extract bound ids from declarations. *)

    fun idsId trId xs' x t =
	case trId x
	  of x' as O.Id(_,_,Name.ExId s') => StringMap.insert(xs', s', (x',t))
	   | _                            => ()

    fun idsDec xs' (I.ValDec(i,p,e))	= idsPat xs' p
      | idsDec xs' (I.ConDec(i,x,t,k))	= idsId trId xs' x (#typ(I.infoTyp t))
      | idsDec xs' (I.TypDec(i,x,t))	= ()
      | idsDec xs' (I.ModDec(i,x,m))	= idsId trId' xs' x
						(infToTyp(#inf(I.infoMod m)))
      | idsDec xs' (I.InfDec(i,x,j))	= ()
      | idsDec xs' (I.FixDec(i,x,q))	= ()
      | idsDec xs' (I.VarDec(i,x,d))	= idsDec xs' d
      | idsDec xs' (I.RecDec(i,ds))	= idsDecs xs' ds
      | idsDec xs' (I.LocalDec(i,ds))	= ()
    and idsDecs xs'			= List.app(idsDec xs')

    and idsPat xs' (I.JokPat(i))	= ()
      | idsPat xs' (I.LitPat(i,l))	= ()
      | idsPat xs' (I.VarPat(i,x))	= idsId trId xs' x (#typ i)
      | idsPat xs' (I.TagPat(i,l,k))	= ()
      | idsPat xs' (I.ConPat(i,y,k))	= ()
      | idsPat xs' (I.RefPat(i))	= ()
      | idsPat xs' (I.TupPat(i,ps))	= idsPats xs' ps
      | idsPat xs' (I.ProdPat(i,r))	= idsRow xs' r
      | idsPat xs' (I.VecPat(i,ps))	= idsPats xs' ps
      | idsPat xs' (I.AppPat(i,p1,p2))	= ( idsPat xs' p1 ; idsPat xs' p2 )
      | idsPat xs' (I.AsPat(i,p1,p2))	= ( idsPat xs' p1 ; idsPat xs' p2 )
      | idsPat xs' (I.AltPat(i,ps))	= idsPats xs' ps
      | idsPat xs' (I.NegPat(i,p))	= idsPat xs' p
      | idsPat xs' (I.GuardPat(i,p,e))	= idsPat xs' p
      | idsPat xs' (I.AnnPat(i,p,t))	= idsPat xs' p
      | idsPat xs' (I.WithPat(i,p,ds))	= ( idsPat xs' p ; idsDecs xs' ds )
    and idsPats xs'			= List.app(idsPat xs')

    and idsRow    xs' (I.Row(i,fs,_))   = idsFields xs' fs
    and idsField  xs' (I.Field(i,a,z))  = idsPats xs' z
    and idsFields xs'			= List.app(idsField xs')

    fun ids ds				= let val xs' = StringMap.new() in
					      idsDecs xs' ds ;
					      StringMap.fold op:: [] xs'
					  end


  (* Expressions *)

    fun trExp(I.LitExp(i,l))		= O.LitExp(i, trLit l)
      | trExp(I.PrimExp(i,s,t))		= O.PrimExp(i, s)
      | trExp(I.VarExp(i,y))		= O.VarExp(i, trLongid y)
      | trExp(I.TagExp(i,a,k))		= O.TagExp(i, trLab a, k>1)
      | trExp(I.ConExp(i,y,k))		= O.ConExp(i, trLongid y, k>1)
      | trExp(I.RefExp(i))		= O.RefExp(i)
      | trExp(I.TupExp(i,es))		= O.TupExp(i, trExps es)
      | trExp(I.ProdExp(i,r))		= O.RowExp(i, trExpRow r)
      | trExp(I.SelExp(i,a))		= O.SelExp(i, trLab a)
      | trExp(I.VecExp(i,es))		= O.VecExp(i, trExps es)
      | trExp(I.FunExp(i,ms))		= O.FunExp(i, trMatchs ms)
      | trExp(I.AppExp(i,e1,e2))	= O.AppExp(i, trExp e1, trExp e2)
      | trExp(I.CompExp(i,e1,e2))	= O.AdjExp(i, trExp e1, trExp e2)
      | trExp(I.AndExp(i,e1,e2))	= O.AndExp(i, trExp e1, trExp e2)
      | trExp(I.OrExp(i,e1,e2))		= O.OrExp(i, trExp e1, trExp e2)
      | trExp(I.IfExp(i,e1,e2,e3))	= O.IfExp(i, trExp e1, trExp e2,
							       trExp e3)
      | trExp(I.WhileExp(i,e1,e2))	= O.WhileExp(i, trExp e1, trExp e2)
      | trExp(I.SeqExp(i,es))		= O.SeqExp(i, trExps es)
      | trExp(I.CaseExp(i,e,ms))	= O.CaseExp(i, trExp e, trMatchs ms)
      | trExp(I.RaiseExp(i,e))		= O.RaiseExp(i, trExp e)
      | trExp(I.HandleExp(i,e,ms))	= O.HandleExp(i, trExp e, trMatchs ms)
      | trExp(I.AnnExp(i,e,t))		= trExp e
      | trExp(I.LetExp(i,ds,e))		= O.LetExp(i, trDecs ds, trExp e)
      | trExp(I.PackExp(i,m))		= trMod m

    and trExps es			= List.map trExp es

    and trExpRow(I.Row(i,fs,_))		= trExpFields fs
    and trExpField(I.Field(i,a,e))	= O.Field(i, trLab a, List.hd(trExps e))
    and trExpFields fs			= List.map trExpField fs


  (* Matches and Patterns *)

    and trMatch(I.Match(i,p,e))		= O.Match(i, trPat p, trExp e)
    and trMatchs ms			= List.map trMatch ms

    and trPat(I.JokPat(i))		= O.WildPat(i)
      | trPat(I.LitPat(i,l))		= O.LitPat(i, trLit l)
      | trPat(I.VarPat(i,x))		= O.VarPat(i, trId x)
      | trPat(I.TagPat(i,a,k))		= O.TagPat(i, trLab a, k>1)
      | trPat(I.ConPat(i,y,k))		= O.ConPat(i, trLongid y, k>1)
      | trPat(I.RefPat(i))		= O.RefPat(i)
      | trPat(I.TupPat(i,ps))		= O.TupPat(i, trPats ps)
      | trPat(I.ProdPat(i,r))		= O.RowPat(i, trPatRow r)
      | trPat(I.VecPat(i,ps))		= O.VecPat(i, trPats ps)
      | trPat(I.AppPat(i,p1,p2))	= O.AppPat(i, trPat p1, trPat p2)
      | trPat(I.AsPat(i,p1,p2))		= O.AsPat(i, trPat p1, trPat p2)
      | trPat(I.AltPat(i,ps))		= O.AltPat(i, trPats ps)
      | trPat(I.NegPat(i,p))		= O.NegPat(i, trPat p)
      | trPat(I.GuardPat(i,p,e))	= O.GuardPat(i, trPat p, trExp e)
      | trPat(I.AnnPat(i,p,t))		= trPat p
      | trPat(I.WithPat(i,p,ds))	= O.WithPat(i, trPat p,trDecs ds)

    and trPats ps			= List.map trPat ps

    and trPatRow(I.Row(i,fs,b))		= trPatFields fs
    and trPatField(I.Field(i,a,p))	= O.Field(i, trLab a, List.hd(trPats p))
    and trPatFields fs			= List.map trPatField fs


  (* Modules *)

    and trMod(I.PrimMod(i,s,j))		= O.PrimExp(trInfo i, s)
      | trMod(I.VarMod(i,x))		= let val x' as O.Id(i',_,_)= trId' x in
					      O.VarExp(trInfo i,
						       O.ShortId(i', x'))
					  end
      | trMod(I.StrMod(i,ds))		= let val i'   = trInfo i
					      val ids' = ids ds
					      val fs'  = List.map idToField ids'
					      val ds'  = trDecs ds in
					      O.LetExp(i',ds', O.RowExp(i',fs'))
					  end
      | trMod(I.SelMod(i,m,a))		= let val i' = trInfo i
					      val r  = #region i'
					      val e' = trMod m
					      val t1 = #typ(O.infoExp e')
					      val t2 = #typ i'
					      val t  = Type.inArrow(t1,t2) in
					      O.AppExp(i',O.SelExp(typInfo(r,t),
							           trLab' a),e')
					  end
      | trMod(I.FunMod(i,x,j,m))	= let val i' = trInfo i
					      val r  = #region(I.infoId x)
					      val e' = trMod m
					      val t  = #typ(O.infoExp e')
					      val p' = O.VarPat(typInfo(r,t),
								trId' x)
					      val m' = O.Match(nonInfo r,p',e')
					      in O.FunExp(i', [m'])
					  end
      | trMod(I.AppMod(i,m1,m2))	= O.AppExp(trInfo i, trMod m1, trMod m2)
      | trMod(I.AnnMod(i,m,j))		= O.UpExp(trInfo i, trMod m)
      | trMod(I.UpMod(i,m,j))		= O.UpExp(trInfo i, trMod m)
      | trMod(I.LetMod(i,ds,m))		= O.LetExp(trInfo i, trDecs ds, trMod m)
      | trMod(I.UnpackMod(i,e,j))	= trExp e


  (* Declarations *)

    and trDec(I.ValDec(i,p,e), ds')	= O.ValDec(i, trPat p, trExp e) :: ds'
      | trDec(I.ConDec(i,x,t,k), ds')	= let val i' = I.infoTyp t in
					      case t of I.SingTyp(_,y) =>
						trEqCon(i',x,trLongid y,ds')
					      | _ => if isTagType(#typ i') then
						trTagCon(i',x,k,ds')
					      else
						trNewCon(i',x,k,ds')
					  end
      | trDec(I.TypDec(i,x,t), ds')	= ds'
      | trDec(I.ModDec(i,x,m), ds')	= let val r  = #region(I.infoId x)
					      val e' = trMod m
					      val t  = #typ(O.infoExp e') in
					      O.ValDec(i, O.VarPat(typInfo(r,t),
							trId' x), e') :: ds'
					  end
      | trDec(I.InfDec(i,x,j), ds')	= ds'
      | trDec(I.FixDec(i,x,q), ds')	= ds'
      | trDec(I.VarDec(i,x,d), ds')	= trDec(d, ds')
      | trDec(I.RecDec(i,ds), ds')	= O.RecDec(i, trDecs ds) :: ds'
      | trDec(I.LocalDec(i,ds), ds')	= trDecs'(ds, ds')

    and trDecs ds			= trDecs'(ds, [])
    and trDecs'(ds, ds')		= List.foldr trDec ds' ds

    and trEqCon(i,x,y',ds')		= O.ValDec(nonInfo(#region i),
						   O.VarPat(i,trId x),
						   O.VarExp(i,y')) :: ds'
    and trNewCon(i,x,k,ds')		= O.ValDec(nonInfo(#region i),
						   O.VarPat(i,trId x),
						   O.NewExp(i,k>1)) :: ds'
    and trTagCon(i,x,k,ds')		= O.ValDec(nonInfo(#region i),
						   O.VarPat(i,trId x),
						   O.TagExp(i,trLab(I.idToLab x)
							     ,k>1)) :: ds'


  (* Imports and annotations *)

    fun trAnns'(a_s, ds') = List.foldr trAnn ([],ds') a_s

    and trAnn(I.ImpAnn(i,is,u),(xsus',ds')) =
	let
	    val x'   = O.Id(i, Stamp.new(), Name.InId)
	    val y'   = O.ShortId(i, x')
	    val ds'' = trImps(is, y', ds')
	in
	    ( (x',(),u)::xsus', ds'' )
	end

    and trImps(is, y, ds')		= List.foldr (trImp y) ds' is

    and trImp y (I.ValImp(i,x,d),ds')	= idToDec(trId x, y, #typ(I.infoDesc d))
					  :: ds'
      | trImp y (I.ConImp(i,x,d,k),ds')	= idToDec(trId x, y, #typ(I.infoDesc d))
					  :: ds'
      | trImp y (I.TypImp(i,x,d),ds')	= ds'
      | trImp y (I.ModImp(i,x,d),ds')	= idToDec(trId' x, y,
						  infToTyp(#inf(I.infoDesc d)))
					  :: ds'
      | trImp y (I.InfImp(i,x,d),ds')	= ds'
      | trImp y (I.FixImp(i,x,d),ds')	= ds'
      | trImp y (I.RecImp(i,is), ds')	= trImps(is, y, ds')


  (* Components *)

    fun trComp(I.Comp(i,a_s,ds)) =
	let
	    val  ids'       = ids ds
	    val (xsus',ds') = trAnns'(a_s, trDecs ds)
	    val  fs'        = List.map idToField ids'
	    val  t          = Type.inProd(idsToRow ids')
	    val  i'         = typInfo(#region i,t)
	    val  exp'       = O.LetExp(i', ds', O.RowExp(i', fs'))
	in
	    ( xsus', (exp',()) )
	end

    fun translate() = trComp

  end
(* src # 90 ../frontend-sml/LAB.sig *)
(*
 * Standard ML label identifiers
 *
 * Definition, section 2.4
 *)


signature LAB =
  sig

    eqtype Lab
    type t = Lab

    val fromString:	string       -> Lab
    val fromInt:	int          -> Lab
    val fromLargeInt:	LargeInt.int -> Lab
    val toString:	Lab          -> string

    val equalsNum:	Lab * LargeInt.int -> bool

    val compare:	Lab * Lab -> order

  end
(*DEBUG*) where type Lab = string
(* src # 91 ../frontend-sml/Lab.sml *)
(*
 * Standard ML label identifiers
 *
 * Definition, section 2.4
 *)


structure Lab :> LAB =
  struct

    type Lab = string
    type t   = Lab

    fun fromString s   = s
    fun fromInt n      = Int.toString n
    fun fromLargeInt n = LargeInt.toString n
    fun toString s     = s

    fun compare(s1,s2) =
      case (LargeInt.fromString s1, LargeInt.fromString s2)
	of (SOME n1, SOME n2) => LargeInt.compare(n1,n2)
	 |     _              => String.compare(s1,s2)

    fun equalsNum(s,n) =
      case LargeInt.fromString s
	of SOME n' => n = n'
	 | NONE    => false

  end
(* src # 92 ../frontend-sml/ID.sig *)
(*
 * Standard ML identifiers
 *
 * Definition, section 2.4
 *
 * Note:
 *   This is a generic signature to represent all kinds of identifiers (except
 *   for labels and tyvars).
 *)


signature ID =
  sig

    eqtype Id
    type t = Id

    val invent:		unit -> Id
    val inventAs:	Id   -> Id

    val fromString:	string -> Id
    val toString:	Id -> string

    val compare:	Id * Id -> order

  end
(*DEBUG*) where type Id = string
(* src # 93 ../frontend-sml/MakeId.sml *)
(*
 * Standard ML identifiers
 *
 * Definition, section 2.4
 *
 * Note:
 *   This is a generic functor to represent all kinds of identifiers (except
 *   for labels tyvars).
 *)


functor MakeId(Stamp: STAMP) : (*DEBUG :>*) ID =
  struct

    type Id = string
    type t  = Id

    fun invent()    = "_id" ^ Stamp.toString(Stamp.new())
    fun inventAs id = "_" ^ id ^ Stamp.toString(Stamp.new())

    fun fromString s = s
    fun toString s   = s

    val compare = String.compare

  end
(* src # 94 ../frontend-sml/Ids.sml *)
(*
 * Standard ML basic objects (shared between syntax and semantics)
 *
 * Definition, sections 2.2, 2.4, 3.2, 4.1, 5.1, 6.2, and 7.2
 *
 * Modifications:
 *   Longids are not included since they have been moved to the context-free
 *   grammar.
 *)


local
structure Stamp	= MakeStamp()
in
structure VId	= MakeId(Stamp)
structure TyCon	= MakeId(Stamp)
structure TyVar	= MakeId(Stamp)
structure StrId	= MakeId(Stamp)
structure SigId = MakeId(Stamp)
end
(* src # 95 ../frontend-sml/SCON.sig *)
(*
 * Standard ML special constants
 *
 * Definition, section 2.2
 *
 * Note:
 *   I would like to use WideChar and WideString, but SML/NJ does not
 *   support it.
 *)


signature SCON =    
  sig 

    datatype SCon =
	  INT    of LargeInt.int
	| WORD   of LargeWord.word
	| STRING of WideString.string
	| CHAR   of WideChar.char
	| REAL   of LargeReal.real

    type t = SCon

    val toString: SCon -> string

  end
(* src # 96 ../frontend-sml/SCon.sml *)
(*
 * Standard ML special constants
 *
 * Definition, section 2.2
 *)


structure SCon :> SCON =
  struct

    datatype SCon =
	  INT    of LargeInt.int
	| WORD   of LargeWord.word
	| STRING of WideString.string
	| CHAR   of WideChar.char
	| REAL   of LargeReal.real

    type t = SCon

    fun toString(INT i)    = LargeInt.toString i
      | toString(WORD w)   = "0wx" ^ LargeWord.toString w
      | toString(STRING s) = "\""  ^ WideString.toCString s ^ "\""
      | toString(CHAR c)   = "\"#" ^ WideChar.toCString c   ^ "\""
      | toString(REAL r)   = LargeReal.toString r

  end
(* src # 97 ../frontend-sml/INPUT_GRAMMAR.sig *)
(*
 * Stockhausen input grammar
 *
 * Extensions and modifications to core language:
 *   - unified dec and topdec (i.e. top declarations can appear in let)
 *   - record update expressions
 *   - vector expressions and patterns
 *   - generalized layered patterns
 *   - alternative patterns
 *   - guarded patterns
 *   - negated patterns
 *   - withval patterns
 *   - abstract type declarations
 *   - open datatypes and free construct declarations
 *   - package types and expressions
 *   - removed exception declarations (made into a derived form)
 *   - removed abstype (made into a derived form with local)
 *   - simplified open and fixity declarations to single id (multi ids made DF)
 *   - some hacks to build libraries: primitive value declarations,
 *     overloading declarations, special eqtype declarations and specifications
 *
 * Extensions and modifications to module language:
 *   - components
 *   - unified strdec and topdec
 *   - unified strid and funid
 *   - functor expressions
 *   - removed functor declarations (made into a derived form)
 *   - package elimination
 *   - parameterized signatures
 *   - open datatypes and free constructor specifications
 *   - straightified type specifications (synonyms are kept)
 *   - signature specifications
 *   - definitional value, constructor, and structure specifications
 *   - functor signatures
 *   - top signature
 *   - generalized where
 *   - sharing for signatures
 *   - let for signature expressions
 *   - functor parameters as a separate syntactic class StrPat
 *   - parenthesized structure and signature expressions
 *   - fixity directives in signatures
 *   - op keyword in signatures
 *
 * Notes:
 *   For easier interfacing with the back end we keep several derived forms:
 *   - tuple expressions, patterns, and types
 *   - selector functions
 *   - case, if, orelse, andalso expressions
 *   - sequential expressions
 *   - while expressions
 *   Optional semicolons are omitted.
 *   Because of delayed infix resolution we have to keep fvalbind forms and
 *   need a special app pattern form.
 *   Constructor patterns with arguments are represented as APPPats.
 *   We must also keep parentheses and stuff because of delayed infix resolving.
 *   The structure where and sharing derived forms [Definition, Appendix A]
 *   have been kept because they cannot be derived purely syntactically.
 *)

signature INPUT_GRAMMAR =
  sig

    (* Import *)

    type Info


    (* Identifiers and constants *)

    datatype SCon  = SCon  of Info * SCon.t
    datatype Lab   = Lab   of Info * Lab.t
    datatype VId   = VId   of Info * VId.t
    datatype TyCon = TyCon of Info * TyCon.t
    datatype TyVar = TyVar of Info * TyVar.t
    datatype StrId = StrId of Info * StrId.t
    datatype SigId = SigId of Info * SigId.t

    datatype 'a Long =
	  SHORTLong of Info * 'a
	| DOTLong   of Info * LongStrId * 'a

    withtype LongVId   = VId Long
    and      LongTyCon = TyCon Long
    and      LongStrId = StrId Long
    and      LongSigId = SigId Long


    (* Optional keyword `op' *)

    datatype Op = SANSOp | WITHOp


    (* Expressions *)

    datatype AtExp =
	  SCONAtExp      of Info * SCon
	| LONGVIDAtExp   of Info * Op * LongVId
	| RECORDAtExp    of Info * ExpRow option
	| UPDATEAtExp    of Info * AtExp * ExpRow
	| HASHAtExp      of Info * Lab
	| TUPLEAtExp     of Info * Exp list
	| VECTORAtExp    of Info * Exp list
	| SEQAtExp       of Info * Exp list
	| LETAtExp       of Info * Dec * Exp
	| PARAtExp       of Info * Exp

    and ExpRow =
	  ROWExpRow      of Info * Lab * Exp * ExpRow option

    and Exp =
	  ATEXPExp       of Info * AtExp
	| APPExp         of Info * Exp * AtExp
	| TYPEDExp       of Info * Exp * Ty
	| ANDALSOExp     of Info * Exp * Exp
	| ORELSEExp      of Info * Exp * Exp
	| HANDLEExp      of Info * Exp * Match
	| RAISEExp       of Info * Exp
	| IFExp          of Info * Exp * Exp * Exp
	| WHILEExp       of Info * Exp * Exp
	| CASEExp        of Info * Exp * Match
	| FNExp          of Info * Match
	| PACKExp        of Info * LongStrId

    (* Matches *)      

    and Match =
	  Match          of Info * Mrule * Match option

    and Mrule =
	  Mrule          of Info * Pat * Exp

    (* Declarations *)

    and Dec =
	  VALDec          of Info * TyVarSeq * ValBind
	| FUNDec          of Info * TyVarSeq * FvalBind
	| TYPEDec         of Info * TypBind
	| EQTYPEDec       of Info * TypBind
	| EQEQTYPEDec     of Info * TypBind
	| DATATYPEDec     of Info * DatBind
	| REPLICATIONDec  of Info * TyCon * LongTyCon
	| CONSTRUCTORDec  of Info * DconBind
	| STRUCTUREDec    of Info * StrBind
	| SIGNATUREDec    of Info * SigBind
	| LOCALDec        of Info * Dec * Dec
	| OPENDec         of Info * LongStrId
	| EMPTYDec        of Info
	| SEQDec          of Info * Dec * Dec
	| PRIMITIVEVALDec         of Info * Op * VId * Ty * string
	| PRIMITIVECONSTRUCTORDec of Info * Op * VId * Ty option
					       * TyVarSeq * LongTyCon * string
	| PRIMITIVESTRUCTUREDec   of Info * StrId * SigExp * string
	| OVERLOADDec     of Info * Op * VId * TyVar * Ty
	| INSTANCEDec     of Info * Op * VId * LongTyCon * LongVId
	| INSTANCESCONDec of Info * SCon * LongTyCon
	| INFIXDec        of Info * int * VId
	| INFIXRDec       of Info * int * VId
	| NONFIXDec       of Info * VId

    (* Bindings *)

    and ValBind =
	  PLAINValBind   of Info * Pat * Exp * ValBind option
	| RECValBind     of Info * ValBind

    and FvalBind =
	  FvalBind       of Info * Match * FvalBind option

    and TypBind =
	  NEWTypBind     of Info * TyVarSeq * TyCon * TypBind option
	| EQUALTypBind   of Info * TyVarSeq * TyCon * Ty * TypBind option

    and DatBind =
	  CLOSEDDatBind  of Info * TyVarSeq * TyCon * ConBind * DatBind option
	| OPENDatBind    of Info * TyVarSeq * TyCon * DatBind option

    and ConBind =
	  ConBind        of Info * Op * VId * Ty option * ConBind option

    and DconBind =
	  NEWDconBind    of Info * Op * VId * Ty option * TyVarSeq * LongTyCon
							* DconBind option
	| EQUALDconBind  of Info * Op * VId * Op * LongVId * DconBind option

    and StrBind =
          StrBind        of Info * StrId * StrExp * StrBind option

    and SigBind =
          SigBind        of Info * SigId * StrPat list * SigExp * SigBind option

    (* Patterns *)

    and AtPat =
	  WILDCARDAtPat  of Info
	| SCONAtPat      of Info * SCon
	| LONGVIDAtPat   of Info * Op * LongVId
	| RECORDAtPat    of Info * PatRow option
	| TUPLEAtPat     of Info * Pat list
	| VECTORAtPat    of Info * Pat list
	| ALTAtPat       of Info * Pat list
	| PARAtPat       of Info * Pat

    and PatRow =
	  WILDCARDPatRow of Info
	| ROWPatRow      of Info * Lab * Pat * PatRow option

    and Pat =
	  ATPATPat       of Info * AtPat
	| APPPat         of Info * Pat * AtPat
	| TYPEDPat       of Info * Pat * Ty
	| NONPat         of Info * Pat
	| ASPat          of Info * Pat * Pat
	| WHENPat        of Info * Pat * AtExp
	| WITHVALPat     of Info * Pat * ValBind
	| WITHFUNPat     of Info * Pat * FvalBind

    (* Type expressions *)

    and Ty =
	  TYVARTy        of Info * TyVar
	| RECORDTy       of Info * TyRow option
	| TUPLETy        of Info * Ty list
	| TYCONTy        of Info * TySeq * LongTyCon
	| ARROWTy        of Info * Ty * Ty
	| PACKTy         of Info * LongSigId
	| PARTy          of Info * Ty

    and TyRow =
	  ROWTyRow       of Info * Lab * Ty * TyRow option

    (* Structures *)

    and AtStrExp =
	  STRUCTAtStrExp    of Info * Dec
	| LONGSTRIDAtStrExp of Info * LongStrId
	| LETAtStrExp       of Info * Dec * StrExp
	| PARAtStrExp       of Info * StrExp

    and StrExp =
	  ATSTREXPStrExp    of Info * AtStrExp
	| APPStrExp         of Info * StrExp * AtStrExp
	| TRANSStrExp       of Info * StrExp * SigExp
	| OPAQStrExp        of Info * StrExp * SigExp
	| FCTStrExp         of Info * StrPat * StrExp
	| UNPACKStrExp      of Info * Exp * SigExp

    and StrPat =
	  StrPat            of Info * StrId * SigExp

    (* Signatures *)

    and AtSigExp =
	  ANYAtSigExp       of Info
	| SIGAtSigExp       of Info * Spec
	| LONGSIGIDAtSigExp of Info * LongSigId
	| LETAtSigExp       of Info * Dec * SigExp
	| PARAtSigExp       of Info * SigExp

    and SigExp =
	  ATSIGEXPSigExp    of Info * AtSigExp
	| APPSigExp         of Info * SigExp * AtStrExp
	| FCTSigExp         of Info * StrPat * SigExp
	| WHERESigExp       of Info * SigExp * SigExp

    (* Specifications *)

    and Spec =
	  VALSpec          of Info * ValDesc
	| TYPESpec         of Info * TypDesc
	| EQTYPESpec       of Info * TypDesc
	| EQEQTYPESpec     of Info * TypDesc
	| DATATYPESpec     of Info * DatDesc
	| REPLICATIONSpec  of Info * TyCon * LongTyCon
	| CONSTRUCTORSpec  of Info * DconDesc
	| STRUCTURESpec    of Info * StrDesc
	| SIGNATURESpec    of Info * SigDesc
	| INCLUDESpec      of Info * SigExp
	| EMPTYSpec        of Info
	| SEQSpec          of Info * Spec * Spec
	| SHARINGTYPESpec  of Info * Spec * LongTyCon list
	| SHARINGSIGNATURESpec of Info * Spec * LongSigId list
	| SHARINGSpec      of Info * Spec * LongStrId list
	| OVERLOADSpec     of Info * Op * VId * TyVar * Ty
	| INSTANCESpec     of Info * Op * VId * LongTyCon * LongVId
	| INSTANCESCONSpec of Info * SCon * LongTyCon
	| INFIXSpec        of Info * int * VId
	| INFIXRSpec       of Info * int * VId
	| NONFIXSpec       of Info * VId

    and ValDesc =
	  NEWValDesc      of Info * Op * VId * Ty * ValDesc option
	| EQUALValDesc    of Info * Op * VId * Op * LongVId * ValDesc option

    and TypDesc =
	  NEWTypDesc      of Info * TyVarSeq * TyCon * TypDesc option
	| EQUALTypDesc    of Info * TyVarSeq * TyCon * Ty * TypDesc option

    and DatDesc =
	  CLOSEDDatDesc   of Info * TyVarSeq * TyCon * ConDesc * DatDesc option
	| OPENDatDesc     of Info * TyVarSeq * TyCon * DatDesc option

    and ConDesc =
	  ConDesc         of Info * Op * VId * Ty option * ConDesc option

    and DconDesc =
	  NEWDconDesc     of Info * Op * VId * Ty option * TyVarSeq * LongTyCon
			 				      * DconDesc option
	| EQUALDconDesc   of Info * Op * VId * Op * LongVId * DconDesc option

    and StrDesc =
          NEWStrDesc      of Info * StrId * SigExp * StrDesc option
	| EQUALStrDesc    of Info * StrId * SigExp option * LongStrId
							    * StrDesc option
    and SigDesc =
          NEWSigDesc      of Info * SigId * StrPat list * SigDesc option
	| EQUALSigDesc    of Info * SigId * StrPat list * SigExp
							* SigDesc option

    (* Imports *)

    and Imp =
	  VALImp          of Info * ValItem
	| TYPEImp         of Info * TypItem
	| DATATYPEImp     of Info * DatItem
	| CONSTRUCTORImp  of Info * DconItem
	| STRUCTUREImp    of Info * StrItem
	| SIGNATUREImp    of Info * SigItem
	| EMPTYImp        of Info
	| SEQImp          of Info * Imp * Imp

    and ValItem =
	  PLAINValItem    of Info * Op * VId * ValItem option
	| DESCValItem     of Info * Op * VId * Ty * ValItem option

    and TypItem =
	  PLAINTypItem    of Info * TyCon * TypItem option
	| DESCTypItem     of Info * TyVarSeq * TyCon * TypItem option

    and DatItem =
	  PLAINDatItem    of Info * TyCon * DatItem option
	| DESCDatItem     of Info * TyVarSeq * TyCon * ConItem * DatItem option

    and ConItem =
	  ConItem         of Info * Op * VId * Ty option * ConItem option

    and DconItem =
	  PLAINDconItem   of Info * Op * VId * DconItem option
	| DESCDconItem    of Info * Op * VId * Ty option * TyVarSeq * LongTyCon
			 				      * DconItem option
    and StrItem =
	  PLAINStrItem    of Info * StrId * StrItem option
        | DESCStrItem     of Info * StrId * SigExp * StrItem option

    and SigItem =
	  PLAINSigItem    of Info * SigId * SigItem option
        | DESCSigItem     of Info * SigId * StrPat list * SigItem option

    (* Announcements *)

    and Ann =
	  IMPORTAnn   of Info * Imp * string
	| PREBOUNDAnn of Info * StrId
	| EMPTYAnn    of Info
	| SEQAnn      of Info * Ann * Ann

    (* Programs and components *)

    and Program   = Program   of Info * Dec * Program option
    and Component = Component of Info * Ann * Program option

    (* Sequences *)

    and 'a Seq    = Seq of Info * 'a list

    withtype TySeq    = Ty Seq
    and      TyVarSeq = TyVar Seq

    (* The Type(tm) *)

    type t = Component


    (* Operations *)

    val infoSCon :	SCon		-> Info
    val infoLab :	Lab		-> Info
    val infoVId :	VId		-> Info
    val infoTyCon :	TyCon		-> Info
    val infoTyVar :	TyVar		-> Info
    val infoStrId :	StrId		-> Info
    val infoSigId :	SigId		-> Info
    val infoLong :	'a Long		-> Info
    val infoAtExp :	AtExp		-> Info
    val infoExpRow :	ExpRow		-> Info
    val infoExp :	Exp		-> Info
    val infoMatch :	Match		-> Info
    val infoMrule :	Mrule		-> Info
    val infoDec :	Dec		-> Info
    val infoValBind :	ValBind		-> Info
    val infoFvalBind :	FvalBind	-> Info
    val infoTypBind :	TypBind		-> Info
    val infoDatBind :	DatBind		-> Info
    val infoConBind :	ConBind		-> Info
    val infoDconBind :	DconBind	-> Info
    val infoStrBind :	StrBind		-> Info
    val infoSigBind :	SigBind		-> Info
    val infoAtPat :	AtPat		-> Info
    val infoPatRow :	PatRow		-> Info
    val infoPat :	Pat		-> Info
    val infoTy :	Ty		-> Info
    val infoTyRow :	TyRow		-> Info
    val infoAtStrExp :	AtStrExp	-> Info
    val infoStrExp :	StrExp		-> Info
    val infoStrPat :	StrPat		-> Info
    val infoAtSigExp :	AtSigExp	-> Info
    val infoSigExp :	SigExp		-> Info
    val infoSpec :	Spec		-> Info
    val infoValDesc :	ValDesc		-> Info
    val infoTypDesc :	TypDesc		-> Info
    val infoDatDesc :	DatDesc		-> Info
    val infoConDesc :	ConDesc		-> Info
    val infoDconDesc :	DconDesc	-> Info
    val infoStrDesc :	StrDesc		-> Info
    val infoSigDesc :	SigDesc		-> Info
    val infoImp :	Imp		-> Info
    val infoValItem :	ValItem		-> Info
    val infoTypItem :	TypItem		-> Info
    val infoDatItem :	DatItem		-> Info
    val infoConItem :	ConItem		-> Info
    val infoDconItem :	DconItem	-> Info
    val infoStrItem :	StrItem		-> Info
    val infoSigItem :	SigItem		-> Info
    val infoAnn :	Ann		-> Info
    val infoProgram :	Program		-> Info
    val infoComponent :	Component	-> Info
    val infoSeq :	'a Seq		-> Info

    val idLab :		Lab		-> Lab.t
    val idVId :		VId		-> VId.t
    val idTyCon :	TyCon		-> TyCon.t
    val idTyVar :	TyVar		-> TyVar.t
    val idStrId :	StrId		-> StrId.t
    val idSigId :	SigId		-> SigId.t

    val explodeLong :	'a Long		-> StrId list * 'a

  end
(* src # 98 ../frontend-sml/MakeInputGrammar.sml *)
(*
 * Stockhausen input grammar
 *
 * Extensions and modifications to core language:
 *   - unified dec and topdec (i.e. top declarations can appear in let)
 *   - record update expressions
 *   - vector expressions and patterns
 *   - generalized layered patterns
 *   - alternative patterns
 *   - guarded patterns
 *   - negated patterns
 *   - withval patterns
 *   - abstract type declarations
 *   - open datatypes and free construct declarations
 *   - package types and expressions
 *   - removed exception declarations (made into a derived form)
 *   - removed abstype (made into a derived form with local)
 *   - simplified open and fixity declarations to single id (multi ids made DF)
 *   - some hacks to build libraries: primitive value declarations,
 *     overloading declarations, special eqtype declarations and specifications
 *
 * Extensions and modifications to module language:
 *   - components
 *   - unified strdec and topdec
 *   - unified strid and funid
 *   - functor expressions
 *   - removed functor declarations (made into a derived form)
 *   - package elimination
 *   - parameterized signatures
 *   - open datatypes and free constructor specifications
 *   - straightified type specifications (synonyms are kept)
 *   - signature specifications
 *   - definitional value, constructor, and structure specifications
 *   - functor signatures
 *   - top signature
 *   - generalized where
 *   - sharing for signatures
 *   - let for signature expressions
 *   - functor parameters as a separate syntactic class StrPat
 *   - parenthesized structure and signature expressions
 *   - fixity directives in signatures
 *   - op keyword in signatures
 *
 * Notes:
 *   For easier interfacing with the back end we keep several derived forms:
 *   - tuple expressions, patterns, and types
 *   - selector functions
 *   - case, if, orelse, andalso expressions
 *   - sequential expressions
 *   - while expressions
 *   Optional semicolons are omitted.
 *   Because of delayed infix resolution we have to keep fvalbind forms and
 *   need a special app pattern form.
 *   Constructor patterns with arguments are represented as APPPats.
 *   We must also keep parentheses and stuff because of delayed infix resolving.
 *   The structure where and sharing derived forms [Definition, Appendix A]
 *   have been kept because they cannot be derived purely syntactically.
 *)

functor MakeInputGrammar(type Info) :> INPUT_GRAMMAR where type Info = Info =
  struct

    (* Import *)

    type Info = Info


    (* Identifiers and constants *)

    datatype SCon  = SCon  of Info * SCon.t
    datatype Lab   = Lab   of Info * Lab.t
    datatype VId   = VId   of Info * VId.t
    datatype TyCon = TyCon of Info * TyCon.t
    datatype TyVar = TyVar of Info * TyVar.t
    datatype StrId = StrId of Info * StrId.t
    datatype SigId = SigId of Info * SigId.t

    datatype 'a Long =
	  SHORTLong of Info * 'a
	| DOTLong   of Info * LongStrId * 'a

    withtype LongVId   = VId Long
    and      LongTyCon = TyCon Long
    and      LongStrId = StrId Long
    and      LongSigId = SigId Long


    (* Optional keyword `op' *)

    datatype Op = SANSOp | WITHOp


    (* Expressions *)

    datatype AtExp =
	  SCONAtExp      of Info * SCon
	| LONGVIDAtExp   of Info * Op * LongVId
	| RECORDAtExp    of Info * ExpRow option
	| UPDATEAtExp    of Info * AtExp * ExpRow
	| HASHAtExp      of Info * Lab
	| TUPLEAtExp     of Info * Exp list
	| VECTORAtExp    of Info * Exp list
	| SEQAtExp       of Info * Exp list
	| LETAtExp       of Info * Dec * Exp
	| PARAtExp       of Info * Exp

    and ExpRow =
	  ROWExpRow      of Info * Lab * Exp * ExpRow option

    and Exp =
	  ATEXPExp       of Info * AtExp
	| APPExp         of Info * Exp * AtExp
	| TYPEDExp       of Info * Exp * Ty
	| ANDALSOExp     of Info * Exp * Exp
	| ORELSEExp      of Info * Exp * Exp
	| HANDLEExp      of Info * Exp * Match
	| RAISEExp       of Info * Exp
	| IFExp          of Info * Exp * Exp * Exp
	| WHILEExp       of Info * Exp * Exp
	| CASEExp        of Info * Exp * Match
	| FNExp          of Info * Match
	| PACKExp        of Info * LongStrId

    (* Matches *)      

    and Match =
	  Match          of Info * Mrule * Match option

    and Mrule =
	  Mrule          of Info * Pat * Exp

    (* Declarations *)

    and Dec =
	  VALDec          of Info * TyVarSeq * ValBind
	| FUNDec          of Info * TyVarSeq * FvalBind
	| TYPEDec         of Info * TypBind
	| EQTYPEDec       of Info * TypBind
	| EQEQTYPEDec     of Info * TypBind
	| DATATYPEDec     of Info * DatBind
	| REPLICATIONDec  of Info * TyCon * LongTyCon
	| CONSTRUCTORDec  of Info * DconBind
	| STRUCTUREDec    of Info * StrBind
	| SIGNATUREDec    of Info * SigBind
	| LOCALDec        of Info * Dec * Dec
	| OPENDec         of Info * LongStrId
	| EMPTYDec        of Info
	| SEQDec          of Info * Dec * Dec
	| PRIMITIVEVALDec         of Info * Op * VId * Ty * string
	| PRIMITIVECONSTRUCTORDec of Info * Op * VId * Ty option
					       * TyVarSeq * LongTyCon * string
	| PRIMITIVESTRUCTUREDec   of Info * StrId * SigExp * string
	| OVERLOADDec     of Info * Op * VId * TyVar * Ty
	| INSTANCEDec     of Info * Op * VId * LongTyCon * LongVId
	| INSTANCESCONDec of Info * SCon * LongTyCon
	| INFIXDec        of Info * int * VId
	| INFIXRDec       of Info * int * VId
	| NONFIXDec       of Info * VId

    (* Bindings *)

    and ValBind =
	  PLAINValBind   of Info * Pat * Exp * ValBind option
	| RECValBind     of Info * ValBind

    and FvalBind =
	  FvalBind       of Info * Match * FvalBind option

    and TypBind =
	  NEWTypBind     of Info * TyVarSeq * TyCon * TypBind option
	| EQUALTypBind   of Info * TyVarSeq * TyCon * Ty * TypBind option

    and DatBind =
	  CLOSEDDatBind  of Info * TyVarSeq * TyCon * ConBind * DatBind option
	| OPENDatBind    of Info * TyVarSeq * TyCon * DatBind option

    and ConBind =
	  ConBind        of Info * Op * VId * Ty option * ConBind option

    and DconBind =
	  NEWDconBind    of Info * Op * VId * Ty option * TyVarSeq * LongTyCon
							* DconBind option
	| EQUALDconBind  of Info * Op * VId * Op * LongVId * DconBind option

    and StrBind =
          StrBind        of Info * StrId * StrExp * StrBind option

    and SigBind =
          SigBind        of Info * SigId * StrPat list * SigExp * SigBind option

    (* Patterns *)

    and AtPat =
	  WILDCARDAtPat  of Info
	| SCONAtPat      of Info * SCon
	| LONGVIDAtPat   of Info * Op * LongVId
	| RECORDAtPat    of Info * PatRow option
	| TUPLEAtPat     of Info * Pat list
	| VECTORAtPat    of Info * Pat list
	| ALTAtPat       of Info * Pat list
	| PARAtPat       of Info * Pat

    and PatRow =
	  WILDCARDPatRow of Info
	| ROWPatRow      of Info * Lab * Pat * PatRow option

    and Pat =
	  ATPATPat       of Info * AtPat
	| APPPat         of Info * Pat * AtPat
	| TYPEDPat       of Info * Pat * Ty
	| NONPat         of Info * Pat
	| ASPat          of Info * Pat * Pat
	| WHENPat        of Info * Pat * AtExp
	| WITHVALPat     of Info * Pat * ValBind
	| WITHFUNPat     of Info * Pat * FvalBind

    (* Type expressions *)

    and Ty =
	  TYVARTy        of Info * TyVar
	| RECORDTy       of Info * TyRow option
	| TUPLETy        of Info * Ty list
	| TYCONTy        of Info * TySeq * LongTyCon
	| ARROWTy        of Info * Ty * Ty
	| PACKTy         of Info * LongSigId
	| PARTy          of Info * Ty

    and TyRow =
	  ROWTyRow       of Info * Lab * Ty * TyRow option

    (* Structures *)

    and AtStrExp =
	  STRUCTAtStrExp    of Info * Dec
	| LONGSTRIDAtStrExp of Info * LongStrId
	| LETAtStrExp       of Info * Dec * StrExp
	| PARAtStrExp       of Info * StrExp

    and StrExp =
	  ATSTREXPStrExp    of Info * AtStrExp
	| APPStrExp         of Info * StrExp * AtStrExp
	| TRANSStrExp       of Info * StrExp * SigExp
	| OPAQStrExp        of Info * StrExp * SigExp
	| FCTStrExp         of Info * StrPat * StrExp
	| UNPACKStrExp      of Info * Exp * SigExp

    and StrPat =
	  StrPat            of Info * StrId * SigExp

    (* Signatures *)

    and AtSigExp =
	  ANYAtSigExp       of Info
	| SIGAtSigExp       of Info * Spec
	| LONGSIGIDAtSigExp of Info * LongSigId
	| LETAtSigExp       of Info * Dec * SigExp
	| PARAtSigExp       of Info * SigExp

    and SigExp =
	  ATSIGEXPSigExp    of Info * AtSigExp
	| APPSigExp         of Info * SigExp * AtStrExp
	| FCTSigExp         of Info * StrPat * SigExp
	| WHERESigExp       of Info * SigExp * SigExp

    (* Specifications *)

    and Spec =
	  VALSpec          of Info * ValDesc
	| TYPESpec         of Info * TypDesc
	| EQTYPESpec       of Info * TypDesc
	| EQEQTYPESpec     of Info * TypDesc
	| DATATYPESpec     of Info * DatDesc
	| REPLICATIONSpec  of Info * TyCon * LongTyCon
	| CONSTRUCTORSpec  of Info * DconDesc
	| STRUCTURESpec    of Info * StrDesc
	| SIGNATURESpec    of Info * SigDesc
	| INCLUDESpec      of Info * SigExp
	| EMPTYSpec        of Info
	| SEQSpec          of Info * Spec * Spec
	| SHARINGTYPESpec  of Info * Spec * LongTyCon list
	| SHARINGSIGNATURESpec of Info * Spec * LongSigId list
	| SHARINGSpec      of Info * Spec * LongStrId list
	| OVERLOADSpec     of Info * Op * VId * TyVar * Ty
	| INSTANCESpec     of Info * Op * VId * LongTyCon * LongVId
	| INSTANCESCONSpec of Info * SCon * LongTyCon
	| INFIXSpec        of Info * int * VId
	| INFIXRSpec       of Info * int * VId
	| NONFIXSpec       of Info * VId

    and ValDesc =
	  NEWValDesc      of Info * Op * VId * Ty * ValDesc option
	| EQUALValDesc    of Info * Op * VId * Op * LongVId * ValDesc option

    and TypDesc =
	  NEWTypDesc      of Info * TyVarSeq * TyCon * TypDesc option
	| EQUALTypDesc    of Info * TyVarSeq * TyCon * Ty * TypDesc option

    and DatDesc =
	  CLOSEDDatDesc   of Info * TyVarSeq * TyCon * ConDesc * DatDesc option
	| OPENDatDesc     of Info * TyVarSeq * TyCon * DatDesc option

    and ConDesc =
	  ConDesc         of Info * Op * VId * Ty option * ConDesc option

    and DconDesc =
	  NEWDconDesc     of Info * Op * VId * Ty option * TyVarSeq * LongTyCon
			 				      * DconDesc option
	| EQUALDconDesc   of Info * Op * VId * Op * LongVId * DconDesc option

    and StrDesc =
          NEWStrDesc      of Info * StrId * SigExp * StrDesc option
	| EQUALStrDesc    of Info * StrId * SigExp option * LongStrId
							    * StrDesc option
    and SigDesc =
          NEWSigDesc      of Info * SigId * StrPat list * SigDesc option
	| EQUALSigDesc    of Info * SigId * StrPat list * SigExp
							* SigDesc option
    (* Imports *)

    and Imp =
	  VALImp          of Info * ValItem
	| TYPEImp         of Info * TypItem
	| DATATYPEImp     of Info * DatItem
	| CONSTRUCTORImp  of Info * DconItem
	| STRUCTUREImp    of Info * StrItem
	| SIGNATUREImp    of Info * SigItem
	| EMPTYImp        of Info
	| SEQImp          of Info * Imp * Imp

    and ValItem =
	  PLAINValItem    of Info * Op * VId * ValItem option
	| DESCValItem     of Info * Op * VId * Ty * ValItem option

    and TypItem =
	  PLAINTypItem    of Info * TyCon * TypItem option
	| DESCTypItem     of Info * TyVarSeq * TyCon * TypItem option

    and DatItem =
	  PLAINDatItem    of Info * TyCon * DatItem option
	| DESCDatItem     of Info * TyVarSeq * TyCon * ConItem * DatItem option

    and ConItem =
	  ConItem         of Info * Op * VId * Ty option * ConItem option

    and DconItem =
	  PLAINDconItem   of Info * Op * VId * DconItem option
	| DESCDconItem    of Info * Op * VId * Ty option * TyVarSeq * LongTyCon
			 				      * DconItem option
    and StrItem =
	  PLAINStrItem    of Info * StrId * StrItem option
        | DESCStrItem     of Info * StrId * SigExp * StrItem option

    and SigItem =
	  PLAINSigItem    of Info * SigId * SigItem option
        | DESCSigItem     of Info * SigId * StrPat list * SigItem option

    (* Announcements *)

    and Ann =
	  IMPORTAnn   of Info * Imp * string
	| PREBOUNDAnn of Info * StrId
	| EMPTYAnn    of Info
	| SEQAnn      of Info * Ann * Ann

    (* Programs and components *)

    and Program   = Program   of Info * Dec * Program option
    and Component = Component of Info * Ann * Program option

    (* Sequences *)

    and 'a Seq    = Seq of Info * 'a list

    withtype TySeq    = Ty Seq
    and      TyVarSeq = TyVar Seq

    (* The Type(tm) *)

    type t = Component


    (* Extracting info fields *)

    fun infoSCon(SCon(I,_))				= I
    fun infoLab(Lab(I,_))				= I
    fun infoVId(VId(I,_))				= I
    fun infoTyCon(TyCon(I,_))				= I
    fun infoTyVar(TyVar(I,_))				= I
    fun infoStrId(StrId(I,_))				= I
    fun infoSigId(SigId(I,_))				= I

    fun infoLong(SHORTLong(I,_))			= I
      | infoLong(DOTLong(I,_,_))			= I

    fun infoAtExp(SCONAtExp(I,_))			= I
      | infoAtExp(LONGVIDAtExp(I,_,_))			= I
      | infoAtExp(RECORDAtExp(I,_))			= I
      | infoAtExp(UPDATEAtExp(I,_,_))			= I
      | infoAtExp(HASHAtExp(I,_))			= I
      | infoAtExp(TUPLEAtExp(I,_))			= I
      | infoAtExp(VECTORAtExp(I,_))			= I
      | infoAtExp(SEQAtExp(I,_))			= I
      | infoAtExp(LETAtExp(I,_,_))			= I
      | infoAtExp(PARAtExp(I,_))			= I

    fun infoExpRow(ROWExpRow(I,_,_,_))			= I

    fun infoExp(ATEXPExp(I,_))				= I
      | infoExp(APPExp(I,_,_))				= I
      | infoExp(TYPEDExp(I,_,_))			= I
      | infoExp(ANDALSOExp(I,_,_))			= I
      | infoExp(ORELSEExp(I,_,_))			= I
      | infoExp(HANDLEExp(I,_,_))			= I
      | infoExp(RAISEExp(I,_))				= I
      | infoExp(IFExp(I,_,_,_))				= I
      | infoExp(WHILEExp(I,_,_))			= I
      | infoExp(CASEExp(I,_,_))				= I
      | infoExp(FNExp(I,_))				= I
      | infoExp(PACKExp(I,_))				= I

    fun infoMatch(Match(I,_,_))				= I

    fun infoMrule(Mrule(I,_,_))				= I

    fun infoDec(VALDec(I,_,_))				= I
      | infoDec(FUNDec(I,_,_))				= I
      | infoDec(TYPEDec(I,_))				= I
      | infoDec(EQTYPEDec(I,_))				= I
      | infoDec(EQEQTYPEDec(I,_))			= I
      | infoDec(DATATYPEDec(I,_))			= I
      | infoDec(REPLICATIONDec(I,_,_))			= I
      | infoDec(CONSTRUCTORDec(I,_))			= I
      | infoDec(STRUCTUREDec(I,_))			= I
      | infoDec(SIGNATUREDec(I,_))			= I
      | infoDec(LOCALDec(I,_,_))			= I
      | infoDec(OPENDec(I,_))				= I
      | infoDec(EMPTYDec(I))				= I
      | infoDec(SEQDec(I,_,_))				= I
      | infoDec(PRIMITIVEVALDec(I,_,_,_,_))		= I
      | infoDec(PRIMITIVECONSTRUCTORDec(I,_,_,_,_,_,_))	= I
      | infoDec(PRIMITIVESTRUCTUREDec(I,_,_,_))		= I
      | infoDec(OVERLOADDec(I,_,_,_,_))			= I
      | infoDec(INSTANCEDec(I,_,_,_,_))			= I
      | infoDec(INSTANCESCONDec(I,_,_))			= I
      | infoDec(INFIXDec(I,_,_))			= I
      | infoDec(INFIXRDec(I,_,_))			= I
      | infoDec(NONFIXDec(I,_))				= I

    fun infoValBind(PLAINValBind(I,_,_,_))		= I
      | infoValBind(RECValBind(I,_))			= I

    fun infoFvalBind(FvalBind(I,_,_))			= I

    fun infoTypBind(NEWTypBind(I,_,_,_))		= I
      | infoTypBind(EQUALTypBind(I,_,_,_,_))		= I

    fun infoDatBind(CLOSEDDatBind(I,_,_,_,_))		= I
      | infoDatBind(OPENDatBind(I,_,_,_))		= I

    fun infoConBind(ConBind(I,_,_,_,_))			= I

    fun infoDconBind(NEWDconBind(I,_,_,_,_,_,_))	= I
      | infoDconBind(EQUALDconBind(I,_,_,_,_,_))	= I

    fun infoStrBind(StrBind(I,_,_,_))			= I

    fun infoSigBind(SigBind(I,_,_,_,_))			= I

    fun infoAtPat(WILDCARDAtPat(I))			= I
      | infoAtPat(SCONAtPat(I,_))			= I
      | infoAtPat(LONGVIDAtPat(I,_,_))			= I
      | infoAtPat(RECORDAtPat(I,_))			= I
      | infoAtPat(TUPLEAtPat(I,_))			= I
      | infoAtPat(VECTORAtPat(I,_))			= I
      | infoAtPat(ALTAtPat(I,_))			= I
      | infoAtPat(PARAtPat(I,_))			= I

    fun infoPatRow(WILDCARDPatRow(I))			= I
      | infoPatRow(ROWPatRow(I,_,_,_))			= I

    fun infoPat(ATPATPat(I,_))				= I
      | infoPat(APPPat(I,_,_))				= I
      | infoPat(TYPEDPat(I,_,_))			= I
      | infoPat(NONPat(I,_))				= I
      | infoPat(ASPat(I,_,_))				= I
      | infoPat(WHENPat(I,_,_))				= I
      | infoPat(WITHVALPat(I,_,_))			= I
      | infoPat(WITHFUNPat(I,_,_))			= I

    fun infoTy(TYVARTy(I,_))				= I
      | infoTy(RECORDTy(I,_))				= I
      | infoTy(TUPLETy(I,_))				= I
      | infoTy(TYCONTy(I,_,_))				= I
      | infoTy(ARROWTy(I,_,_))				= I
      | infoTy(PACKTy(I,_))				= I
      | infoTy(PARTy(I,_))				= I

    fun infoTyRow(ROWTyRow(I,_,_,_))			= I

    fun infoAtStrExp(STRUCTAtStrExp(I,_))		= I
      | infoAtStrExp(LONGSTRIDAtStrExp(I,_))		= I
      | infoAtStrExp(LETAtStrExp(I,_,_))		= I
      | infoAtStrExp(PARAtStrExp(I,_))			= I

    fun infoStrExp(ATSTREXPStrExp(I,_))			= I
      | infoStrExp(APPStrExp(I,_,_))			= I
      | infoStrExp(TRANSStrExp(I,_,_))			= I
      | infoStrExp(OPAQStrExp(I,_,_))			= I
      | infoStrExp(FCTStrExp(I,_,_))			= I
      | infoStrExp(UNPACKStrExp(I,_,_))			= I

    fun infoStrPat(StrPat(I,_,_))			= I

    fun infoAtSigExp(ANYAtSigExp(I))			= I
      | infoAtSigExp(SIGAtSigExp(I,_))			= I
      | infoAtSigExp(LONGSIGIDAtSigExp(I,_))		= I
      | infoAtSigExp(LETAtSigExp(I,_,_))		= I
      | infoAtSigExp(PARAtSigExp(I,_))			= I

    fun infoSigExp(ATSIGEXPSigExp(I,_))			= I
      | infoSigExp(APPSigExp(I,_,_))			= I
      | infoSigExp(FCTSigExp(I,_,_))			= I
      | infoSigExp(WHERESigExp(I,_,_))			= I

    fun infoSpec(VALSpec(I,_))				= I
      | infoSpec(TYPESpec(I,_))				= I
      | infoSpec(EQTYPESpec(I,_))			= I
      | infoSpec(EQEQTYPESpec(I,_))			= I
      | infoSpec(DATATYPESpec(I,_))			= I
      | infoSpec(REPLICATIONSpec(I,_,_))		= I
      | infoSpec(CONSTRUCTORSpec(I,_))			= I
      | infoSpec(STRUCTURESpec(I,_))			= I
      | infoSpec(SIGNATURESpec(I,_))			= I
      | infoSpec(INCLUDESpec(I,_))			= I
      | infoSpec(EMPTYSpec(I))				= I
      | infoSpec(SEQSpec(I,_,_))			= I
      | infoSpec(SHARINGTYPESpec(I,_,_))		= I
      | infoSpec(SHARINGSIGNATURESpec(I,_,_))		= I
      | infoSpec(SHARINGSpec(I,_,_))			= I
      | infoSpec(OVERLOADSpec(I,_,_,_,_))		= I
      | infoSpec(INSTANCESpec(I,_,_,_,_))		= I
      | infoSpec(INSTANCESCONSpec(I,_,_))		= I
      | infoSpec(INFIXSpec(I,_,_))			= I
      | infoSpec(INFIXRSpec(I,_,_))			= I
      | infoSpec(NONFIXSpec(I,_))			= I

    fun infoValDesc(NEWValDesc(I,_,_,_,_))		= I
      | infoValDesc(EQUALValDesc(I,_,_,_,_,_))		= I

    fun infoTypDesc(NEWTypDesc(I,_,_,_))		= I
      | infoTypDesc(EQUALTypDesc(I,_,_,_,_))		= I

    fun infoDatDesc(CLOSEDDatDesc(I,_,_,_,_))		= I
      | infoDatDesc(OPENDatDesc(I,_,_,_))		= I

    fun infoConDesc(ConDesc(I,_,_,_,_))			= I

    fun infoDconDesc(NEWDconDesc(I,_,_,_,_,_,_))	= I
      | infoDconDesc(EQUALDconDesc(I,_,_,_,_,_))	= I

    fun infoStrDesc(NEWStrDesc(I,_,_,_))		= I
      | infoStrDesc(EQUALStrDesc(I,_,_,_,_))		= I

    fun infoSigDesc(NEWSigDesc(I,_,_,_))		= I
      | infoSigDesc(EQUALSigDesc(I,_,_,_,_))		= I

    fun infoImp(VALImp(I,_))				= I
      | infoImp(TYPEImp(I,_))				= I
      | infoImp(DATATYPEImp(I,_))			= I
      | infoImp(CONSTRUCTORImp(I,_))			= I
      | infoImp(STRUCTUREImp(I,_))			= I
      | infoImp(SIGNATUREImp(I,_))			= I
      | infoImp(EMPTYImp(I))				= I
      | infoImp(SEQImp(I,_,_))				= I

    fun infoValItem(PLAINValItem(I,_,_,_))		= I
      | infoValItem(DESCValItem(I,_,_,_,_))		= I

    fun infoTypItem(PLAINTypItem(I,_,_))		= I
      | infoTypItem(DESCTypItem(I,_,_,_))		= I

    fun infoDatItem(PLAINDatItem(I,_,_))		= I
      | infoDatItem(DESCDatItem(I,_,_,_,_))		= I

    fun infoConItem(ConItem(I,_,_,_,_))			= I

    fun infoDconItem(PLAINDconItem(I,_,_,_))		= I
      | infoDconItem(DESCDconItem(I,_,_,_,_,_,_))	= I

    fun infoStrItem(PLAINStrItem(I,_,_))		= I
      | infoStrItem(DESCStrItem(I,_,_,_))		= I

    fun infoSigItem(PLAINSigItem(I,_,_))		= I
      | infoSigItem(DESCSigItem(I,_,_,_))		= I

    fun infoAnn(IMPORTAnn(I,_,_))			= I
      | infoAnn(PREBOUNDAnn(I,_))			= I
      | infoAnn(EMPTYAnn(I))				= I
      | infoAnn(SEQAnn(I,_,_))				= I

    fun infoProgram(Program(I,_,_))			= I
    fun infoComponent(Component(I,_,_))			= I

    fun infoSeq(Seq(I,_))				= I


    fun idLab(Lab(_,id))				= id
    fun idVId(VId(_,id))				= id
    fun idTyCon(TyCon(_,id))				= id
    fun idTyVar(TyVar(_,id))				= id
    fun idStrId(StrId(_,id))				= id
    fun idSigId(SigId(_,id))				= id


    fun explodeLong(SHORTLong(_,id))		= ([], id)
      | explodeLong(DOTLong(_,longid,id))	= (explodeLong'(longid,[]), id)

    and explodeLong'(SHORTLong(_,id),      ids)	= id::ids
      | explodeLong'(DOTLong(_,longid,id), ids)	= explodeLong'(longid, id::ids)

  end
(* src # 99 ../frontend-sml/InputGrammar.sml *)
structure InputGrammar = MakeInputGrammar(type Info = Source.region)
(* src # 100 ../frontend-sml/PARSING_ERROR.sig *)
signature PARSING_ERROR =
  sig

    type VId = VId.t

    datatype error =
	(* Lexer *)
	  UnclosedComment
	| InvalidChar		of char
	| InvalidString
	| IntTooLarge
	| WordTooLarge
	| RealTooLarge
	| CharLengthInvalid	of string
	| EscapeCharTooLarge	of bool
	(* Parser *)
	| SyntaxError		of string
	(* Derived forms *)
	| WithtypeInvalid
	| WithtypeArityMismatch
	(* Infix *)
	| InfixMisplaced	of VId
	| AssocConflict		of VId * VId

    type warning	(* yet empty *)

    val error :	Source.region * error -> 'a
    val warn :	Source.region * warning -> unit

  end
(* src # 101 ../frontend-sml/ParsingError.sml *)
structure ParsingError :> PARSING_ERROR =
  struct

  (* Pretty printer *)

    open PrettyPrint
    open PPMisc

    infixr ^^ ^/^

  (* Types *)

    type VId = VId.t

    datatype error =
	(* Lexer *)
	  UnclosedComment
	| InvalidChar		of char
	| InvalidString
	| IntTooLarge
	| WordTooLarge
	| RealTooLarge
	| CharLengthInvalid	of string
	| EscapeCharTooLarge	of bool
	(* Parser *)
	| SyntaxError		of string
	(* Derived forms *)
	| WithtypeInvalid
	| WithtypeArityMismatch
	(* Infix *)
	| InfixMisplaced	of VId
	| AssocConflict		of VId * VId


    type warning = unit		(* yet empty *)


  (* Pretty printing *)

    fun ppQuoted s	= "`" ^ s ^ "'"
    fun ppVId vid	= ppQuoted(VId.toString vid)

    fun ppError(UnclosedComment) =
	  textpar["unclosed","comment"]
      | ppError(InvalidChar c) =
	  textpar["invalid","character",ppQuoted(Char.toCString c)]
      | ppError(InvalidString) =
	  textpar["invalid","string","constant"]
      | ppError(IntTooLarge) =
	  textpar["integer","constant","too","large"]
      | ppError(WordTooLarge) =
	  textpar["word","constant","too","large"]
      | ppError(RealTooLarge) =
	  textpar["real","constant","too","large"]
      | ppError(CharLengthInvalid "") =
	  textpar["empty","character","constant"]
      | ppError(CharLengthInvalid s) =
	  textpar["multiple","characters","in","character","constant"]
      | ppError(EscapeCharTooLarge uc) =
	  textpar[if uc then "unicode" else "ASCII",
		  "escape","character","too","large"]
      (* Parser *)
      | ppError(SyntaxError s) =
	  textpar(String.tokens (fn c => c = #" ") s)
      (* Derived forms *)
      | ppError(WithtypeInvalid) =
	  textpar["invalid","type","binding","inside","withtype"]
      | ppError(WithtypeArityMismatch) =
	  textpar["type","has","wrong","arity"]
      (* Infix *)
      | ppError(InfixMisplaced vid) =
	  textpar["misplaced","infix","identifier",ppVId vid]
      | ppError(AssocConflict(vid1,vid2)) =
	  textpar["conflicting","infix","associativity","between","operators",
		  ppVId vid1,"and",ppVId vid2]


    fun ppWarning w = empty


  (* Export *)

    fun errorToString e   = PrettyPrint.toString(ppError e, 75)
    fun warningToString w = PrettyPrint.toString(ppWarning w, 75)

    fun error(region, e)  = Error.error(region, errorToString e)
    fun warn(region, w)   = Error.warn(region, warningToString w)

  end
(* src # 102 ../frontend-sml/ABSTRACTION_ERROR.sig *)
signature ABSTRACTION_ERROR =
  sig

    type Lab	= Lab.t
    type VId	= VId.t
    type TyVar	= TyVar.t
    type TyCon	= TyCon.t
    type StrId	= StrId.t
    type SigId	= SigId.t
    type id	= AbstractGrammar.id

    datatype error =
	(* Identifiers *)
	  VIdUnbound		of VId
	| TyConUnbound		of TyCon
	| TyVarUnbound		of TyVar
	| StrIdUnbound		of StrId
	| SigIdUnbound		of SigId
	| PreboundFirstClass
	(* Expressions *)
	| ExpRowLabDuplicate	of Lab
	(* Patterns *)
	| PatVIdDuplicate	of VId
	| WithPatVIdDuplicate	of VId
	| PatLongVIdVar
	| PatRowLabDuplicate	of Lab
	| AppPatNonCon
	| AltPatInconsistent
	(* Types *)
	| TyRowLabDuplicate	of Lab
	| TyVarSeqDuplicate	of TyVar
	| ValTyVarSeqDuplicate	of TyVar
	(* Declarations and bindings *)
	| FvalBindDuplicate	of VId
	| FvalBindArityInconsistent
	| FvalBindArityZero
	| FvalBindNameInconsistent of VId
	| FvalBindNameMissing
	| FvalBindNameCon	of VId
	| FvalBindPatInvalid
	| TypBindDuplicate	of TyCon
	| DatBindDuplicate	of TyCon
	| DatBindConDuplicate	of VId
	| ConBindDuplicate	of VId
	| DconBindDuplicate	of VId
	| DconBindNonCon
	| StrBindDuplicate	of StrId
	| SigBindDuplicate	of SigId
	(* Specifications and descriptions *)
	| SpecFixDuplicate	of VId
	| SpecVIdDuplicate	of VId
	| SpecTyConDuplicate	of TyCon
	| SpecStrIdDuplicate	of StrId
	| SpecSigIdDuplicate	of SigId
	| ConDescDuplicate	of VId
	| DconDescNonCon
	(* Imports and items *)
	| ImpVIdDuplicate	of VId
	| ImpTyConDuplicate	of TyCon
	| ImpStrIdDuplicate	of StrId
	| ImpSigIdDuplicate	of SigId
	| ConItemDuplicate	of VId
	| ValItemUnbound	of VId
	| TypItemUnbound	of TyCon
	| DatItemUnbound	of TyCon
	| ConItemUnbound	of VId
	| DconItemUnbound	of VId
	| StrItemUnbound	of StrId
	| SigItemUnbound	of SigId
	| ConItemNonCon		of VId
	| DconItemNonCon	of VId
	(* Sharing translation *)
	| SharingExternalTy	of id
	| SharingExternalSig	of id
	| SharingExternalStr	of id

    datatype warning =
	(* Shadowing *)
	  VIdShadowed		of VId
	| TyConShadowed		of TyCon
	| TyVarShadowed		of TyVar
	| StrIdShadowed		of StrId
	| SigIdShadowed		of SigId

    val error :	Source.region * error -> 'a
    val warn :	Source.region * warning -> unit

  end
(* src # 103 ../frontend-sml/AbstractionError.sml *)
structure AbstractionError :> ABSTRACTION_ERROR =
  struct

  (* Pretty printer *)

    open PrettyPrint
    open PPMisc

    infixr ^^ ^/^

  (* Types *)

    type Lab	= Lab.t
    type VId	= VId.t
    type TyVar	= TyVar.t
    type TyCon	= TyCon.t
    type StrId	= StrId.t
    type SigId	= SigId.t
    type id	= AbstractGrammar.id

    datatype error =
	(* Identifiers *)
	  VIdUnbound		of VId
	| TyConUnbound		of TyCon
	| TyVarUnbound		of TyVar
	| StrIdUnbound		of StrId
	| SigIdUnbound		of SigId
	| PreboundFirstClass
	(* Expressions *)
	| ExpRowLabDuplicate	of Lab
	(* Patterns *)
	| PatVIdDuplicate	of VId
	| WithPatVIdDuplicate	of VId
	| PatLongVIdVar
	| PatRowLabDuplicate	of Lab
	| AppPatNonCon
	| AltPatInconsistent
	(* Types *)
	| TyRowLabDuplicate	of Lab
	| TyVarSeqDuplicate	of TyVar
	| ValTyVarSeqDuplicate	of TyVar
	(* Declarations and bindings *)
	| FvalBindDuplicate	of VId
	| FvalBindArityInconsistent
	| FvalBindArityZero
	| FvalBindNameInconsistent of VId
	| FvalBindNameMissing
	| FvalBindNameCon	of VId
	| FvalBindPatInvalid
	| TypBindDuplicate	of TyCon
	| DatBindDuplicate	of TyCon
	| DatBindConDuplicate	of VId
	| ConBindDuplicate	of VId
	| DconBindDuplicate	of VId
	| DconBindNonCon
	| StrBindDuplicate	of StrId
	| SigBindDuplicate	of SigId
	(* Specifications and descriptions *)
	| SpecFixDuplicate	of VId
	| SpecVIdDuplicate	of VId
	| SpecTyConDuplicate	of TyCon
	| SpecStrIdDuplicate	of StrId
	| SpecSigIdDuplicate	of SigId
	| ConDescDuplicate	of VId
	| DconDescNonCon
	(* Imports and items *)
	| ImpVIdDuplicate	of VId
	| ImpTyConDuplicate	of TyCon
	| ImpStrIdDuplicate	of StrId
	| ImpSigIdDuplicate	of SigId
	| ConItemDuplicate	of VId
	| ValItemUnbound	of VId
	| TypItemUnbound	of TyCon
	| DatItemUnbound	of TyCon
	| ConItemUnbound	of VId
	| DconItemUnbound	of VId
	| StrItemUnbound	of StrId
	| SigItemUnbound	of SigId
	| ConItemNonCon		of VId
	| DconItemNonCon	of VId
	(* Sharing translation *)
	| SharingExternalTy	of id
	| SharingExternalSig	of id
	| SharingExternalStr	of id

    datatype warning =
	(* Shadowing *)
	  VIdShadowed		of VId
	| TyConShadowed		of TyCon
	| TyVarShadowed		of TyVar
	| StrIdShadowed		of StrId
	| SigIdShadowed		of SigId


  (* Pretty printing *)

    fun ppQuoted s	= "`" ^ s ^ "'"

    fun ppLab lab	= ppQuoted(Lab.toString lab)
    fun ppVId vid	= ppQuoted(VId.toString vid)
    fun ppTyCon tycon	= ppQuoted(TyCon.toString tycon)
    fun ppTyVar tyvar	= ppQuoted(TyVar.toString tyvar)
    fun ppStrId strid	= ppQuoted(StrId.toString strid)
    fun ppSigId sigid	= ppQuoted(SigId.toString sigid)

    fun ppLab'(AbstractGrammar.Lab(_,l)) = Label.toString l

    fun ppId'(AbstractGrammar.Id(_,_,n)) = Name.toString n
    fun ppId x = ppQuoted(ppId' x)

    fun ppLongid'(AbstractGrammar.ShortId(_,x))  = ppId' x
      | ppLongid'(AbstractGrammar.LongId(_,y,l)) = ppLongid' y ^ "." ^ ppLab' l
    fun ppLongid y = ppQuoted(ppLongid' y)


    val classLab	= (ppLab,   ["label"])
    val classVId	= (ppVId,   ["value","or","constructor"])
    val classTyCon	= (ppTyCon, ["type"])
    val classTyVar	= (ppTyVar, ["type","variable"])
    val classStrId	= (ppStrId, ["structure","or","functor"])
    val classSigId	= (ppSigId, ["signature"])

    fun ppUnbound((ppId,class), id) =
	  textpar(["unknown"] @ class @ [ppId id])
    fun ppUnboundImport((ppId,class), id) =
	  textpar(class @ [ppId id,"is","not","exported","by","component"])

    fun ppError(VIdUnbound vid) =
	  ppUnbound(classVId, vid)
      | ppError(TyConUnbound tycon) =
	  ppUnbound(classTyCon, tycon)
      | ppError(TyVarUnbound tyvar) =
	  ppUnbound(classTyVar, tyvar)
      | ppError(StrIdUnbound strid) =
	  ppUnbound(classStrId, strid)
      | ppError(SigIdUnbound sigid) =
	  ppUnbound(classSigId, sigid)
      | ppError(PreboundFirstClass) =
	  textpar["invalid","use","of","pseudo","structure"]
      (* Expressions *)
      | ppError(ExpRowLabDuplicate lab) =
	  textpar(["duplicate"] @ #2 classLab @ [ppLab lab,"in","record"])
      (* Patterns *)
      | ppError(PatVIdDuplicate vid) =
	  textpar["duplicate","variable",ppVId vid,"in","pattern",
		  "or","binding","group"]
      | ppError(WithPatVIdDuplicate vid) =
	  textpar["pattern","variable",ppVId vid,"redefined",
		  "inside","value","binding"]
      | ppError(PatLongVIdVar) =
	  textpar["non-constructor","long","identifier","in","pattern"]
      | ppError(PatRowLabDuplicate lab) =
	  textpar(["duplicate"] @ #2 classLab @ [ppLab lab,"in","record"])
      | ppError(AppPatNonCon) =
	  textpar["application","of","non-constructor","in","pattern"]
      | ppError(AltPatInconsistent) =
	  textpar["inconsistent","pattern","alternative"]
      (* Types *)
      | ppError(TyRowLabDuplicate lab) =
	  textpar(["duplicate"] @ #2 classLab @ [ppLab lab,"in","record"])
      | ppError(TyVarSeqDuplicate tyvar) =
	  textpar(["duplicate"] @ #2 classTyVar @ [ppTyVar tyvar])
      | ppError(ValTyVarSeqDuplicate tyvar) =
	  textpar(["duplicate","or","shadowing"] @ #2 classTyVar @
		  [ppTyVar tyvar])
      (* Declarations and bindings *)
      | ppError(FvalBindDuplicate vid) =
	  textpar["duplicate","function",ppVId vid,"in","binding","group"]
      | ppError(FvalBindArityInconsistent) =
	  textpar["inconsistent","function","arity","in","function","clause"]
      | ppError(FvalBindArityZero) =
	  textpar["no","arguments","in","function","clause"]
      | ppError(FvalBindNameInconsistent vid) =
	  textpar["inconsistent","function","name",ppVId vid,
		  "in","function","clause"]
      | ppError(FvalBindNameMissing) =
	  textpar["no","function","name","in","function","clause"]
      | ppError(FvalBindNameCon vid) =
	  textpar["redefining","constructor",ppVId vid,"as","value"]
      | ppError(FvalBindPatInvalid) =
	  textpar["invalid","function","clause"]
      | ppError(TypBindDuplicate tycon) =
	  textpar(["duplicate"] @ #2 classTyCon @
		  [ppTyCon tycon,"in","binding","group"])
      | ppError(DatBindDuplicate tycon) =
	  textpar(["duplicate"] @ #2 classTyCon @
		  [ppTyCon tycon,"in","binding","group"])
      | ppError(DatBindConDuplicate vid) =
	  textpar["duplicate","constructor",ppVId vid,"in","binding","group"]
      | ppError(ConBindDuplicate vid) =
	  textpar["duplicate","constructor",ppVId vid,"in","datatype"]
      | ppError(DconBindDuplicate vid) =
	  textpar["duplicate","constructor",ppVId vid,"in","binding","group"]
      | ppError(DconBindNonCon) =
	  textpar["non-constructor","on","constructor","binding",
		  "right","hand","side"]
      | ppError(StrBindDuplicate strid) =
	  textpar(["duplicate"] @ #2 classStrId @
		  [ppStrId strid,"in","binding","group"])
      | ppError(SigBindDuplicate sigid) =
	  textpar(["duplicate"] @ #2 classSigId @
		  [ppSigId sigid,"in","binding","group"])
      (* Specifications and descriptions *)
      | ppError(SpecFixDuplicate vid) =
	  textpar(["duplicate","fixity","specification","for"] @ #2 classVId @
		  [ppVId vid,"in","signature"])
      | ppError(SpecVIdDuplicate vid) =
	  textpar(["duplicate"] @ #2 classVId @ [ppVId vid,"in","signature"])
      | ppError(SpecTyConDuplicate tycon) =
	  textpar(["duplicate"] @ #2 classTyCon @
		  [ppTyCon tycon,"in","signature"])
      | ppError(SpecStrIdDuplicate strid) =
	  textpar(["duplicate"] @ #2 classStrId @
		  [ppStrId strid,"in","signature"])
      | ppError(SpecSigIdDuplicate sigid) =
	  textpar(["duplicate"] @ #2 classSigId @
		  [ppSigId sigid,"in","signature"])
      | ppError(ConDescDuplicate vid) =
	  textpar["duplicate","constructor",ppVId vid,"in","datatype"]
      | ppError(DconDescNonCon) =
	  textpar["non-constructor","on","constructor","description",
		  "right","hand","side"]
      (* Imports and items *)
      | ppError(ImpVIdDuplicate vid) =
	  textpar(["duplicate"] @ #2 classVId @ [ppVId vid,"in","import"])
      | ppError(ImpTyConDuplicate tycon) =
	  textpar(["duplicate"] @ #2 classTyCon @ [ppTyCon tycon,"in","import"])
      | ppError(ImpStrIdDuplicate strid) =
	  textpar(["duplicate"] @ #2 classStrId @ [ppStrId strid,"in","import"])
      | ppError(ImpSigIdDuplicate sigid) =
	  textpar(["duplicate"] @ #2 classSigId @ [ppSigId sigid,"in","import"])
      | ppError(ConItemDuplicate vid) =
	  textpar["duplicate","constructor",ppVId vid,"in","datatype"]
      | ppError(ValItemUnbound vid) =
	  ppUnboundImport(classVId, vid)
      | ppError(TypItemUnbound tycon) =
	  ppUnboundImport(classTyCon, tycon)
      | ppError(DatItemUnbound tycon) =
	  ppUnboundImport(classTyCon, tycon)
      | ppError(ConItemUnbound vid) =
	  ppUnboundImport(classVId, vid)
      | ppError(DconItemUnbound vid) =
	  ppUnboundImport(classVId, vid)
      | ppError(StrItemUnbound strid) =
	  ppUnboundImport(classStrId, strid)
      | ppError(SigItemUnbound sigid) =
	  ppUnboundImport(classSigId, sigid)
      | ppError(ConItemNonCon vid) =
	  textpar["value",ppVId vid,"exported","by","component","is",
		  "not","a","constructor"]
      | ppError(DconItemNonCon vid) =
	  textpar["value",ppVId vid,"exported","by","component","is",
		  "not","a","constructor"]
      (* Sharing translation *)
      | ppError(SharingExternalTy x) =
	  textpar(#2 classTyCon @ [ppId x,"is","external","to","signature"])
      | ppError(SharingExternalSig x) =
	  textpar(#2 classSigId @ [ppId x,"is","external","to","signature"])
      | ppError(SharingExternalStr x) =
	  textpar(#2 classStrId @ [ppId x,"is","external","to","signature"])


    fun ppShadowed((ppId,class), id) =
	  textpar(class @ [ppId id,"shadows","previous","one"])

    fun ppWarning(VIdShadowed vid) =
	  ppShadowed(classVId, vid)
      | ppWarning(TyConShadowed tycon) =
	  ppShadowed(classTyCon, tycon)
      | ppWarning(TyVarShadowed tyvar) =
	  ppShadowed(classTyVar, tyvar)
      | ppWarning(StrIdShadowed strid) =
	  ppShadowed(classStrId, strid)
      | ppWarning(SigIdShadowed sigid) =
	  ppShadowed(classSigId, sigid)


  (* Export *)

    fun errorToString e   = PrettyPrint.toString(ppError e, 75)
    fun warningToString w = PrettyPrint.toString(ppWarning w, 75)

    fun error(region, e)  = Error.error(region, errorToString e)
    fun warn(region, w)   = Error.warn(region, warningToString w)

  end
(* src # 104 ../frontend-sml/INFIX.sig *)
(*
 * Standard ML infix resolution
 *
 * Definition, section 2.6
 *)


signature INFIX =
  sig

    (* Import *)

    structure Grammar: INPUT_GRAMMAR = InputGrammar


    (* Infix environment *)

    datatype Assoc = LEFT | RIGHT
    type InfStatus = (Assoc * int) option

    type InfEnv    = VId.t -> InfStatus


    (* Resolving phrases containing infixed identifiers *)

    val exp :	InfEnv -> Grammar.Exp -> Grammar.Exp
    val pat :	InfEnv -> Grammar.Pat -> Grammar.Pat

  end
(* src # 105 ../frontend-sml/Infix.sml *)
(*
 * Standard ML infix resolution
 *
 * Definition, section 2.6
 *)


structure Infix :> INFIX =
  struct

  (* Import *)

    structure Grammar = InputGrammar
    structure E       = ParsingError

    open Grammar

    val error = E.error


  (* Type definitions *)

    datatype Assoc = LEFT | RIGHT

    type InfStatus = (Assoc * int) option

    type InfEnv    = VId.t -> InfStatus


    (* Categorisation of atomic expressions and patterns *)

    datatype 'a FixityCategory = NONFIX of 'a
			       | INFIX  of Assoc * int * VId

    fun categoriseVId IE (at, vid as VId(i,vid')) =
	case IE vid'
	  of NONE             => NONFIX(at)
	   | SOME(assoc,prec) => INFIX(assoc, prec, vid)


    fun categoriseLongVId IE (at, SHORTLong(i, vid)) =
	    categoriseVId IE (at, vid)
      | categoriseLongVId IE (at, longvid) = NONFIX(at)

    fun categoriseAtExp IE (atexp as LONGVIDAtExp(i, SANSOp, longvid)) =
	    categoriseLongVId IE (atexp, longvid)
      | categoriseAtExp IE (atexp) = NONFIX(atexp)

    fun categoriseAtPat IE (atpat as LONGVIDAtPat(i, SANSOp, longvid)) =
	    categoriseLongVId IE (atpat, longvid)
      | categoriseAtPat IE (atpat) = NONFIX(atpat)



    (* Converting app expressions and patterns into atomic lists *)

    fun flattenExp'(ATEXPExp(i,atexp))   = atexp :: []
      | flattenExp'(APPExp(i,exp,atexp)) = atexp :: flattenExp' exp
      | flattenExp' _ = raise Crash.Crash "Infix.flattenExp: invalid expression"

    fun flattenExp exp = List.rev(flattenExp' exp)

    fun flattenPat'(ATPATPat(i,atpat))   = atpat :: []
      | flattenPat'(APPPat(i,pat,atpat)) = atpat :: flattenPat' pat
      | flattenPat' _ = raise Crash.Crash "Infix.flattenPat: invalid pattern"

    fun flattenPat pat = List.rev(flattenPat' pat)



    (* Resolving infixed expressions and patterns *)

    datatype ('a,'b) x = ATOMIC of 'a | NONATOMIC of 'b

    fun parse (ATXx, APPx, PARAtX, TUPLEAtX, LONGVIDAtX,
	       infoX, infoAtX, categorise, flatten) IE x =
	let
	    fun info(ATOMIC x)         = infoAtX x
	      | info(NONATOMIC x)      = infoX x

	    fun atomic(ATOMIC x)       = x
	      | atomic(NONATOMIC x)    = PARAtX(infoX x, x)

	    fun nonatomic(ATOMIC x)    = ATXx(infoAtX x, x)
	      | nonatomic(NONATOMIC x) = x

	    fun pair(x1,x2) =
		let
		    val x1' = nonatomic x1
		    val x2' = nonatomic x2
		in
		    TUPLEAtX(Source.over(info x1,info x2), [x1', x2'])
		end

	    fun apply(x1,x2) =
		let
		    val x1' = nonatomic x1
		    val x2' = atomic x2
		    val x'  = APPx(Source.over(info x1, info x2), x1', x2')
		in
		    NONATOMIC x'
		end

	    fun infapply(x1,vid,x2) =
		let
		    val i       = Source.over(info x1, info x2)
		    val i_vid   = infoVId vid
		    val longvid	= SHORTLong(i_vid, vid)
		    val x1'	= LONGVIDAtX(i_vid, WITHOp, longvid)
		    val x2'	= pair(x1,x2)
		    val x'      = APPx(i, ATXx(i_vid, x1'), x2')
		in
		    NONATOMIC x'
		end


	    fun loop(NONFIX(x)::[], []) = x

	      | loop(NONFIX(x2)::NONFIX(x1)::s', i) =
		    (* reduce nonfix application *)
		    loop(NONFIX(apply(x1, x2))::s', i)

	      | loop(s, NONFIX(x)::i') =
		    (* shift *)
		    loop(NONFIX(ATOMIC x)::s, i')

	      | loop(s as NONFIX(x)::[], INFIX(q)::i') =
		    (* shift *)
		    loop(INFIX(q)::s, i')

	      | loop(NONFIX(x2)::INFIX(a,p,vid)::NONFIX(x1)::s', []) =
		    (* reduce infix application *)
		    loop(NONFIX(infapply(x1, vid, x2))::s', [])

	      | loop(s as NONFIX(x2)::INFIX(a1,p1,vid1)::NONFIX(x1)::s',
		       i as INFIX(q2 as (a2,p2,vid2))::i') =
		if p1 > p2 then
		    (* reduce infix application *)
		    loop(NONFIX(infapply(x1, vid1, x2))::s', i)
		else if p1 < p2 then
		    (* shift *)
		    loop(INFIX(q2)::s, i')
		else if a1 <> a2 then
		    let
		        val VId(i1,vid1') = vid1
		        val VId(i2,vid2') = vid2
		    in
			error(Source.over(i1,i2), E.AssocConflict(vid1',vid2'))
		    end
		else if a1 = LEFT then
		    (* reduce infix application *)
		    loop(NONFIX(infapply(x1, vid1, x2))::s', i)
		else (* a1 = RIGHT *)
		    (* shift *)
		    loop(INFIX(q2)::s, i')

	      | loop(INFIX(a,p,VId(i,vid'))::s', []) =
		    error(i, E.InfixMisplaced vid')

	      | loop(INFIX(x)::s', INFIX(a,p,VId(i,vid'))::i') =
		    error(i, E.InfixMisplaced vid')

	      | loop([], INFIX(a,p,VId(i,vid'))::i') =
		    error(i, E.InfixMisplaced vid')

	      | loop _ = raise Crash.Crash "Infix.parse: inconsistency"

	    val x' = loop([], List.map (categorise IE) (flatten x))
	in
	    nonatomic x'
	end


    (* Expressions *)

    val exp = parse(ATEXPExp, APPExp, PARAtExp, TUPLEAtExp, LONGVIDAtExp,
		    infoExp, infoAtExp, categoriseAtExp, flattenExp)

    (* Patterns *)

    val pat = parse(ATPATPat, APPPat, PARAtPat, TUPLEAtPat, LONGVIDAtPat,
		    infoPat, infoAtPat, categoriseAtPat, flattenPat)

  end
(* src # 106 ../frontend-sml/BIND_ENV.sig *)
(*******************************************************************************

The binding environment just contains the information necessary to do
binding analysis for identifiers:

	Env	= InfEnv U FldEnv U VarEnv U ValEnv U TyEnv U StrEnv U SigEnv
	InfEnv	= VId   -> InfStatus		(infix env)
	FldEnv	= Lab   -> 0			(field env)
	VarEnv	= TyVar -> Stamp		(type variable env)
	ValEnv	= VId   -> Stamp * IdStatus	(value env)
	TyEnv	= TyCon -> Stamp * Env		(type env)
	StrEnv	= StrId -> Stamp * Env		(module env)
	SigEnv	= SigId -> Stamp * Env		(signature env)

Field envs are just used to detect duplicate labels. Type envs map to
constructor environments. Module envs map to environments representing the
module's signature (th result signature for functors, as we never need to look
at the argument signature). Similarly, signature envs map to the result
environment (ignoring signature parameters).

*******************************************************************************)

signature BIND_ENV =
  sig

    type Lab   = Lab.t
    type VId   = VId.t
    type TyVar = TyVar.t
    type TyCon = TyCon.t
    type StrId = StrId.t
    type SigId = SigId.t

    type Info  = Source.region
    type stamp = Stamp.t

    datatype InfAssoc  = datatype Infix.Assoc
    type     InfStatus = Infix.InfStatus
    datatype IdStatus  = V | C of int | R

    type Env
    type Inf = Info * InfStatus
    type Fld = Info
    type Var = Info * stamp
    type Val = Info * stamp * IdStatus
    type Ty  = Info * stamp * Env
    type Str = Info * stamp * Env
    type Sig = Info * stamp * Env

    type t = Env


    exception CollisionInf of VId
    exception CollisionFld of Lab
    exception CollisionVal of VId
    exception CollisionTy  of TyCon
    exception CollisionVar of TyVar
    exception CollisionStr of StrId
    exception CollisionSig of SigId


    val new :			unit -> Env

    val size :			Env -> int
    val sizeScope :		Env -> int

    val clone :			Env -> Env
    val cloneScope :		Env -> Env

    val insertScope :		Env -> unit
    val deleteScope :		Env -> unit
    val mergeScope :		Env -> unit
    val mergeDisjointScope :	Env -> unit		(* Collision* *)
    val inheritScope :		Env * Env -> unit
    val splitScope :		Env -> Env

    val union :			Env * Env -> unit
    val unionDisjoint :		Env * Env -> unit	(* Collision* *)
    val unionCompose :		Env * Env -> unit
    val unionInf :		Env * Env -> unit

    val insertInf :		Env *  VId  * Inf -> unit
    val insertFld :		Env *  Lab  * Fld -> unit
    val insertVal :		Env *  VId  * Val -> unit
    val insertTy :		Env * TyCon * Ty  -> unit
    val insertVar :		Env * TyVar * Var -> unit
    val insertStr :		Env * StrId * Str -> unit
    val insertSig :		Env * SigId * Sig -> unit
    val insertDisjointInf :	Env *  VId  * Inf -> unit   (* CollisionInf *)
    val insertDisjointFld :	Env *  Lab  * Fld -> unit   (* CollisionFld *)
    val insertDisjointVal :	Env *  VId  * Val -> unit   (* CollisionVal *)
    val insertDisjointTy :	Env * TyCon * Ty  -> unit   (* CollisionTy *)
    val insertDisjointVar :	Env * TyVar * Var -> unit   (* CollisionVar *)
    val insertDisjointStr :	Env * StrId * Str -> unit   (* CollisionStr *)
    val insertDisjointSig :	Env * SigId * Sig -> unit   (* CollisionSig *)

    val lookupInf :		Env *  VId  -> Inf option
    val lookupFld :		Env *  Lab  -> Fld option
    val lookupVar :		Env * TyVar -> Var option
    val lookupVal :		Env *  VId  -> Val option
    val lookupTy :		Env * TyCon -> Ty  option
    val lookupStr :		Env * StrId -> Str option
    val lookupSig :		Env * SigId -> Sig option
    val lookupScopeInf :	Env *  VId  -> Inf option
    val lookupScopeFld :	Env *  Lab  -> Fld option
    val lookupScopeVar :	Env * TyVar -> Var option
    val lookupScopeVal :	Env *  VId  -> Val option
    val lookupScopeTy :		Env * TyCon -> Ty  option
    val lookupScopeStr :	Env * StrId -> Str option
    val lookupScopeSig :	Env * SigId -> Sig option

    val appiInfs :		( VId  * Inf -> unit) -> Env -> unit
    val appiFlds :		( Lab  * Fld -> unit) -> Env -> unit
    val appiVars :		(TyVar * Var -> unit) -> Env -> unit
    val appiVals :		( VId  * Val -> unit) -> Env -> unit
    val appiTys :		(TyCon * Ty  -> unit) -> Env -> unit
    val appiStrs :		(StrId * Str -> unit) -> Env -> unit
    val appiSigs :		(SigId * Sig -> unit) -> Env -> unit
    val appiScopeVals :		( VId  * Val -> unit) -> Env -> unit

    val foldiInfs :		( VId  * Inf * 'a -> 'a) -> 'a -> Env -> 'a
    val foldiFlds :		( Lab  * Fld * 'a -> 'a) -> 'a -> Env -> 'a
    val foldiVars :		(TyVar * Var * 'a -> 'a) -> 'a -> Env -> 'a
    val foldiVals :		( VId  * Val * 'a -> 'a) -> 'a -> Env -> 'a
    val foldiTys :		(TyCon * Ty  * 'a -> 'a) -> 'a -> Env -> 'a
    val foldiStrs :		(StrId * Str * 'a -> 'a) -> 'a -> Env -> 'a
    val foldiSigs :		(SigId * Sig * 'a -> 'a) -> 'a -> Env -> 'a

    val infEnv :		Env -> VId -> InfStatus

  end
(* src # 107 ../frontend-sml/BindEnv.sml *)
structure BindEnv :> BIND_ENV =
  struct

    type Info  = Source.region
    type stamp = Stamp.t


    (* The environment's domain *)

    type Lab   = Lab.t
    type VId   = VId.t
    type TyVar = TyVar.t
    type TyCon = TyCon.t
    type StrId = StrId.t
    type SigId = SigId.t

    datatype Dom = INFIX of VId
		 | LAB   of Lab
		 | TYVAR of TyVar
		 | VID   of VId
		 | TYCON of TyCon
		 | STRID of StrId
		 | SIGID of SigId

    fun hashDom(INFIX id) = StringHashKey.hash(  VId.toString id)
      | hashDom(LAB   id) = StringHashKey.hash(  Lab.toString id)
      | hashDom(TYVAR id) = StringHashKey.hash(TyVar.toString id)
      | hashDom(VID   id) = StringHashKey.hash(  VId.toString id)
      | hashDom(TYCON id) = StringHashKey.hash(TyCon.toString id)
      | hashDom(STRID id) = StringHashKey.hash(StrId.toString id)
      | hashDom(SIGID id) = StringHashKey.hash(SigId.toString id)


    (* The map implementing the environment *)

    structure Map = MakeHashScopedImpMap(type t = Dom val hash = hashDom)


    (* The environment's range *)

    datatype InfAssoc  = datatype Infix.Assoc
    type     InfStatus = Infix.InfStatus
    datatype IdStatus  = V | C of int | R

    datatype Env = ENV of Ran Map.t
    and      Ran = INF of Inf
		 | FLD of Fld
		 | VAR of Var
		 | VAL of Val
		 | TY  of Ty
		 | STR of Str
		 | SIG of Sig

    withtype Inf = Info * InfStatus
    and      Fld = Info
    and      Var = Info * stamp
    and      Val = Info * stamp * IdStatus
    and      Ty  = Info * stamp * Env
    and      Str = Info * stamp * Env
    and      Sig = Info * stamp * Env

    type t = Env

    fun asInfo(SOME(INF x)) = SOME x | asInfo _ = NONE
    fun asFldo(SOME(FLD x)) = SOME x | asFldo _ = NONE
    fun asVaro(SOME(VAR x)) = SOME x | asVaro _ = NONE
    fun asValo(SOME(VAL x)) = SOME x | asValo _ = NONE
    fun asTyo (SOME(TY  x)) = SOME x | asTyo  _ = NONE
    fun asStro(SOME(STR x)) = SOME x | asStro _ = NONE
    fun asSigo(SOME(SIG x)) = SOME x | asSigo _ = NONE

    fun appInf f (INFIX id, INF x) = f(id,x) | appInf f _ = ()
    fun appFld f (LAB   id, FLD x) = f(id,x) | appFld f _ = ()
    fun appVar f (TYVAR id, VAR x) = f(id,x) | appVar f _ = ()
    fun appVal f (VID   id, VAL x) = f(id,x) | appVal f _ = ()
    fun appTy  f (TYCON id, TY  x) = f(id,x) | appTy  f _ = ()
    fun appStr f (STRID id, STR x) = f(id,x) | appStr f _ = ()
    fun appSig f (SIGID id, SIG x) = f(id,x) | appSig f _ = ()

    fun foldInf f (INFIX id, INF x, a) = f(id,x,a) | foldInf f (_,_,a) = a
    fun foldFld f (LAB   id, FLD x, a) = f(id,x,a) | foldFld f (_,_,a) = a
    fun foldVar f (TYVAR id, VAR x, a) = f(id,x,a) | foldVar f (_,_,a) = a
    fun foldVal f (VID   id, VAL x, a) = f(id,x,a) | foldVal f (_,_,a) = a
    fun foldTy  f (TYCON id, TY  x, a) = f(id,x,a) | foldTy  f (_,_,a) = a
    fun foldStr f (STRID id, STR x, a) = f(id,x,a) | foldStr f (_,_,a) = a
    fun foldSig f (SIGID id, SIG x, a) = f(id,x,a) | foldSig f (_,_,a) = a


    (* Collision exceptions *)

    exception CollisionInf of VId
    exception CollisionFld of Lab
    exception CollisionVal of VId
    exception CollisionTy  of TyCon
    exception CollisionVar of TyVar
    exception CollisionStr of StrId
    exception CollisionSig of SigId

    fun transformCollision(INFIX id)	= raise CollisionInf id
      | transformCollision(LAB   id)	= raise CollisionFld id
      | transformCollision(TYVAR id)	= raise CollisionVar id
      | transformCollision(VID   id)	= raise CollisionVal id
      | transformCollision(TYCON id)	= raise CollisionTy  id
      | transformCollision(STRID id)	= raise CollisionStr id
      | transformCollision(SIGID id)	= raise CollisionSig id


    (* Actual operations *)

    fun new()				= ENV(Map.new())
    fun clone(ENV E)			= ENV(Map.clone E)
    fun cloneScope(ENV E)		= ENV(Map.cloneScope E)
    fun splitScope(ENV E)		= ENV(Map.splitScope E)

    fun insertScope(ENV E)		= Map.insertScope E
    fun inheritScope(ENV E1, ENV E2)	= Map.inheritScope(E1,E2)
    fun deleteScope(ENV E)		= Map.deleteScope E
    fun mergeScope(ENV E)		= Map.mergeScope E
    fun mergeDisjointScope(ENV E)	= Map.mergeDisjointScope E
					  handle Map.Collision coll =>
						 transformCollision coll

    fun union(ENV E1, ENV E2)		= Map.union(E1,E2)
    fun unionDisjoint(ENV E1, ENV E2)	= Map.unionDisjoint(E1,E2)
					  handle Map.Collision coll =>
						 transformCollision coll

    fun size(ENV E)			= Map.size E
    fun sizeScope(ENV E)		= Map.sizeScope E

    fun insertInf(ENV E, id, x)		= Map.insert(E, INFIX id, INF x)
    fun insertFld(ENV E, id, x)		= Map.insert(E, LAB   id, FLD x)
    fun insertVar(ENV E, id, x)		= Map.insert(E, TYVAR id, VAR x)
    fun insertVal(ENV E, id, x)		= Map.insert(E, VID   id, VAL x)
    fun insertTy (ENV E, id, x)		= Map.insert(E, TYCON id, TY  x)
    fun insertStr(ENV E, id, x)		= Map.insert(E, STRID id, STR x)
    fun insertSig(ENV E, id, x)		= Map.insert(E, SIGID id, SIG x)

    fun insertDisjointInf(ENV E, id, x)	= Map.insertDisjoint(E, INFIX id, INF x)
					  handle Map.Collision(INFIX id) =>
						 raise CollisionInf id
    fun insertDisjointFld(ENV E, id, x)	= Map.insertDisjoint(E, LAB id, FLD x)
					  handle Map.Collision(LAB id) =>
						 raise CollisionFld id
    fun insertDisjointVar(ENV E, id, x)	= Map.insertDisjoint(E, TYVAR id, VAR x)
					  handle Map.Collision(TYVAR id) =>
						 raise CollisionVar id
    fun insertDisjointVal(ENV E, id, x)	= Map.insertDisjoint(E, VID id, VAL x)
					  handle Map.Collision(VID id) =>
						 raise CollisionVal id
    fun insertDisjointTy(ENV E, id, x)	= Map.insertDisjoint(E, TYCON id, TY x)
					  handle Map.Collision(TYCON id) =>
						 raise CollisionTy id
    fun insertDisjointStr(ENV E, id, x)	= Map.insertDisjoint(E, STRID id, STR x)
					  handle Map.Collision(STRID id) =>
						 raise CollisionStr id
    fun insertDisjointSig(ENV E, id, x)	= Map.insertDisjoint(E, SIGID id, SIG x)
					  handle Map.Collision(SIGID id) =>
						 raise CollisionSig id

    fun lookupInf(ENV E, id)		= asInfo(Map.lookup(E, INFIX id))
    fun lookupFld(ENV E, id)		= asFldo(Map.lookup(E, LAB   id))
    fun lookupVar(ENV E, id)		= asVaro(Map.lookup(E, TYVAR id))
    fun lookupVal(ENV E, id)		= asValo(Map.lookup(E, VID   id))
    fun lookupTy (ENV E, id)		= asTyo (Map.lookup(E, TYCON id))
    fun lookupStr(ENV E, id)		= asStro(Map.lookup(E, STRID id))
    fun lookupSig(ENV E, id)		= asSigo(Map.lookup(E, SIGID id))

    fun lookupScopeInf(ENV E, id)	= asInfo(Map.lookupScope(E, INFIX id))
    fun lookupScopeFld(ENV E, id)	= asFldo(Map.lookupScope(E, LAB   id))
    fun lookupScopeVar(ENV E, id)	= asVaro(Map.lookupScope(E, TYVAR id))
    fun lookupScopeVal(ENV E, id)	= asValo(Map.lookupScope(E, VID   id))
    fun lookupScopeTy (ENV E, id)	= asTyo (Map.lookupScope(E, TYCON id))
    fun lookupScopeStr(ENV E, id)	= asStro(Map.lookupScope(E, STRID id))
    fun lookupScopeSig(ENV E, id)	= asSigo(Map.lookupScope(E, SIGID id))

    fun appiInfs f (ENV E)		= Map.appi (appInf f) E
    fun appiFlds f (ENV E)		= Map.appi (appFld f) E
    fun appiVars f (ENV E)		= Map.appi (appVar f) E
    fun appiVals f (ENV E)		= Map.appi (appVal f) E
    fun appiTys  f (ENV E)		= Map.appi (appTy  f) E
    fun appiStrs f (ENV E)		= Map.appi (appStr f) E
    fun appiSigs f (ENV E)		= Map.appi (appSig f) E
    fun appiScopeVals f (ENV E)		= Map.appiScope (appVal f) E

    fun foldiInfs f a (ENV E)		= Map.foldi (foldInf f) a E
    fun foldiFlds f a (ENV E)		= Map.foldi (foldFld f) a E
    fun foldiVars f a (ENV E)		= Map.foldi (foldVar f) a E
    fun foldiVals f a (ENV E)		= Map.foldi (foldVal f) a E
    fun foldiTys  f a (ENV E)		= Map.foldi (foldTy  f) a E
    fun foldiStrs f a (ENV E)		= Map.foldi (foldStr f) a E
    fun foldiSigs f a (ENV E)		= Map.foldi (foldSig f) a E


    fun unionInf(E1,E2)			= appiInfs (fn(id,x) =>
						     insertInf(E1,id,x)) E2

    fun unionCompose(ENV E1, ENV E2)		= Map.unionWith compose (E1,E2)

    and compose(INF(I1,fix1),   INF(I2,fix2))	= INF(I1,fix2)
      | compose(FLD(I1),        FLD(I2))	= FLD(I1)
      | compose(VAR(I1,z1),     VAR(I2,z2))	= VAR(I1,z1)
      | compose(VAL(I1,z1,is1), VAL(I2,z2,is2))	= VAL(I1,z1,
						    composeIdStatus(is1,is2))
      | compose(TY (I1,z1,E1),  TY (I2,z2,E2))	= ( unionCompose(E1,E2)
						  ; TY(I1,z1,E1) )
      | compose(STR(I1,z1,E1),  STR(I2,z2,E2))	= ( unionCompose(E1,E2)
						  ; STR(I1,z1,E1) )
      | compose(SIG(I1,z1,E1),  SIG(I2,z2,E2))	= ( unionCompose(E1,E2)
						  ; SIG(I1,z1,E1) )
      | compose _				= raise Crash.Crash
							"BindEnv.compose"
    and composeIdStatus(V, is)			= is
      | composeIdStatus(is, V)			= is
      | composeIdStatus(is1, is2)		= is2


    fun infEnv E vid				= case lookupInf(E, vid)
						    of NONE        => NONE
						     | SOME(_,inf) => inf

  end
(* src # 108 ../frontend-sml/SHARING.sig *)
signature SHARING =
  sig

    type spec   = AbstractGrammar.spec
    type longid = AbstractGrammar.longid

    val shareTyp :	spec list * longid list -> spec list  (* -> reversed *)
    val shareSig :	spec list * longid list -> spec list  (* -> reversed *)
    val shareStr :	spec list * longid list -> spec list  (* -> reversed *)

  end
(* src # 109 ../frontend-sml/Sharing.sml *)
(*
 * Translation of sharing constraints.
 *
 * The algorithm takes a list of specs and a list of longids inducing sharing
 * upon the specs and works as follows:
 * 1. Build annotated specs, that pair each longid with the spec it refers to.
 * 2. Look for the first spec now annotated with a longid, take this longid as
 *    the original object.
 * 3. Transform each remaining annotated spec to express the induced sharing
 *    equivalence. For a type or signature spec this is done by replacing it
 *    with an appropriate manifest spec (blindly overwriting the spec - there is
 *    no check for either rigidness or kind consistency). For a structures its
 *    signature is intersected with an appropriate specialisation. Note that
 *    even type sharing constraints with longids effect only structure specs.
 *)

structure Sharing :> SHARING =
  struct

    open AbstractGrammar

    nonfix mod

  (* Class *)

    datatype class = TYP | SIG | STR

  (* Error handling *)

    structure E = AbstractionError

    fun error(class, LongId(_, longid, _)) = error(STR, longid)
      | error(TYP, ShortId(i,id)) = E.error(i, E.SharingExternalTy id)
      | error(SIG, ShortId(i,id)) = E.error(i, E.SharingExternalSig id)
      | error(STR, ShortId(i,id)) = E.error(i, E.SharingExternalStr id)

  (* Find ids in a list of longids *)

    fun isRootedAt(ShortId(_, id),       stamp') = stamp id = stamp'
      | isRootedAt(LongId(_, longid, _), stamp') = isRootedAt(longid, stamp')

    fun findId(stamp, [], longids') = NONE
      | findId(stamp, longid::longids, longids') =
	if isRootedAt(longid, stamp)
	then SOME(longid, longids' @ longids)
	else findId(stamp, longids, longid::longids')


  (* Annotated specifications *)

    datatype annotated_spec =
	  Plain     of spec
	| Annotated of spec * longid
	| Recursive of Source.region * annotated_spec list
	(* UNFINISHED: what about ExtSpec? *)


    fun cons1st(x, (xs,y)) = (x::xs, y)

    fun annotate( spec as ( TypSpec(_, id, _)
			  | ModSpec(_, id, _)
			  | InfSpec(_, id, _) ), longids) =
	(case findId(stamp id, longids, [])
	   of SOME(longid,longids') => ( Annotated(spec,longid), longids' )
	    | NONE                  => ( Plain(spec), longids )
	)
      | annotate(RecSpec(i, specs), longids) =
	let val (specs',longids') = annotateList(specs, longids) in
	    ( Recursive(i, specs'), longids' )
	end
      | annotate(spec, longids) =
	    ( Plain(spec), longids )

    and annotateList(    [],      longids) = ([], longids)
      | annotateList(spec::specs, longids) =
	let val (spec',longids') = annotate(spec, longids) in
	    cons1st(spec', annotateList(specs, longids'))
	end


  (* Convert annotated spec to spec with where constraints *)

    fun longidToMod(ShortId(i, id))         = VarMod(i, id)
      | longidToMod(LongId(i, longid, lab)) = SelMod(i, longidToMod longid, lab)

    fun singleton(inf, longid) =
	let
	    val i   = Source.over(infoInf inf, infoLongid longid)
	    val mod = AnnMod(i, longidToMod longid, inf)
	in
	    SingInf(i, mod)
	end

    fun constrain(class, inf1, ShortId _, longid) =
	    raise Crash.Crash "Sharing.constrain"
      | constrain(class, inf1, LongId(i, longid', lab), longid) =
	let
	    fun buildSig(ShortId(i, id), inf) = inf
	      | buildSig(LongId(_, longid, lab), inf) =
		let val i = infoLab lab in
		    SigInf(i, [ModSpec(i, labToId lab, inf)])
		end

	    val i0    = infoLab lab
	    val i1    = infoLongid longid
	    val id0   = labToId lab
	    val spec0 = case class
			  of TYP => TypSpec(i0, id0, ConTyp(i1, longid))
			   | SIG => InfSpec(i0, id0, ConInf(i1, longid))
			   | STR => ModSpec(i0, id0,
					    SingInf(i1, longidToMod longid))
	    val inf2  = buildSig(longid', SigInf(i0, [spec0]))
	in
	    CompInf(Source.over(infoInf inf1, i), inf1, inf2)
	end


    (* UNFINISHED: no error checks for non-qualified types and interfaces *)

    fun withWhere(TYP, TypSpec(i, id, typ), _, longid) =
	    TypSpec(i, id, ConTyp(infoLongid longid, longid))
      | withWhere(SIG, InfSpec(i, id, inf), _, longid) =
	    InfSpec(i, id, ConInf(infoLongid longid, longid))
      | withWhere(STR, ModSpec(i, id, inf), ShortId _, longid) =
	    ModSpec(i, id, singleton(inf, longid))
      | withWhere(class, ModSpec(i, id, inf), longid', longid) =
	    ModSpec(i, id, constrain(class, inf, longid', longid))
      | withWhere _ = raise Crash.Crash "Sharing.withWhere"


  (* Map where constraints over list of annotated specs *)

    (* find 1st annotation *)
    fun mapWhere(class, []) = raise Crash.Crash "Sharing.mapWhere"
      | mapWhere(class, Plain(spec)::specs') =
	    spec :: mapWhere(class, specs')
      | mapWhere(class, Annotated(spec, longid)::specs') =
	    spec :: mapWhere''(class, specs', longid)
      | mapWhere(class, Recursive(i, specs'')::specs') =
	(case mapWhere'(class, specs'')
	   of (specs, NONE) =>
		RecSpec(i,specs) :: mapWhere(class, specs')
	    | (specs, SOME longid) =>
		RecSpec(i,specs) :: mapWhere''(class, specs', longid)
	)

    (* find 1st annotation in nested lists *)
    and mapWhere'(class, []) = raise Crash.Crash "Sharing.mapWhere'"
      | mapWhere'(class, Plain(spec)::specs') =
	    cons1st(spec, mapWhere'(class, specs'))
      | mapWhere'(class, Annotated(spec, longid)::specs') =
	    ( spec :: mapWhere''(class, specs', longid), SOME longid )
      | mapWhere'(class, Recursive(i, specs'')::specs') =
	(case mapWhere'(class, specs'')
	   of (specs, NONE) =>
		cons1st(RecSpec(i,specs), mapWhere'(class, specs'))
	    | (specs, some as SOME longid) =>
		( RecSpec(i,specs) :: mapWhere''(class, specs', longid), some )
	)

    (* transform remaining annotations *)
    and mapWhere''(class, [], longid) = []
      | mapWhere''(class, Plain(spec)::specs', longid) =
	    spec :: mapWhere''(class, specs', longid)
      | mapWhere''(class, Annotated(spec, longid')::specs', longid) =
	    withWhere(class, spec, longid', longid)
		:: mapWhere''(class, specs', longid)
      | mapWhere''(class, Recursive(i, specs'')::specs', longid) =
	    RecSpec(i, mapWhere''(class, specs'',longid))
		:: mapWhere''(class, specs',longid)


  (* Sharing *)

    fun share class (specs, longids) =
	case annotateList(specs, longids)
	  of (specs', longid::_) => error(class, longid)
	   | (specs',       [] ) => mapWhere(class, specs')

    val shareTyp = share TYP
    val shareSig = share SIG
    val shareStr = share STR

  end
(* src # 110 ../frontend-sml/ABSTRACTION_PHASE.sig *)
signature ABSTRACTION_PHASE =
  sig
    structure C : CONTEXT          = BindEnv
    structure I : INPUT_GRAMMAR    = InputGrammar
    structure O : ABSTRACT_GRAMMAR = AbstractGrammar

    val translate : BindEnv.t -> I.Component -> O.comp
  end
(* src # 111 ../frontend-sml/AbstractionPhase.sml *)
structure AbstractionPhase :> ABSTRACTION_PHASE =
  struct

    structure C   = BindEnv
    structure I   = InputGrammar
    structure O   = AbstractGrammar
    structure E   = AbstractionError

    open I
    open BindEnv


  (* Error handling *)

    val error = E.error
    val warn  = E.warn

    fun errorVId(E, vid', Error) =
	error((#1 o Option.valOf o lookupVal)(E, vid'), Error vid')


  (* Miscellanous helpers *)

    fun prebound E =
	case lookupStr(E, StrId.fromString "")
	  of SOME x => x
	   | NONE   => raise Crash.Crash "AbstractionPhase: prebounds not found"

    fun stamp_prebound E = #2 (prebound E)
    fun Env_prebound   E = #3 (prebound E)

    fun inventId i = O.Id(i, Stamp.new(), Name.InId)

    fun longidToMod(O.ShortId(i, id))         = O.VarMod(i, id)
      | longidToMod(O.LongId(i, longid, lab)) =
	    O.SelMod(i, longidToMod longid, lab)

    fun tupexp(i, [exp]) = exp
      | tupexp(i,  exps) = O.TupExp(i, exps)

    fun tuppat(i, [pat]) = pat
      | tuppat(i,  pats) = O.TupPat(i, pats)

    fun annexp(exp,    []    ) = exp
      | annexp(exp, typ::typs) = annexp(O.AnnExp(O.infoTyp typ, exp, typ), typs)


    fun varToTyp id = O.VarTyp(O.infoId id, id)

    fun alltyp(ids,typ) =
	List.foldr (fn(id,typ) => O.AllTyp(O.infoTyp typ, id, typ)) typ ids

    fun funtyp(ids,typ) =
	List.foldr (fn(id,typ) => O.FunTyp(O.infoTyp typ, id, typ)) typ ids

    fun apptyp(typs,typ) =
	List.foldl (fn(typ1,typ2) =>
	      O.AppTyp(Source.over(O.infoTyp typ1, O.infoTyp typ2), typ2, typ1)
	    ) typ typs

    fun arrtyp(typs,typ) =
	List.foldr (fn(typ1,typ2) =>
	      O.ArrTyp(Source.over(O.infoTyp typ1, O.infoTyp typ2), typ1, typ2)
	    ) typ typs

    fun funinf(idinfs,inf) =
	List.foldr (fn((id,inf1),inf2) =>
	      O.FunInf(Source.over(O.infoId id, O.infoInf inf2), id, inf1, inf2)
	    ) inf idinfs

    fun vardec(ids,dec) =
	List.foldr (fn(id,dec) => O.VarDec(O.infoId id, id, dec)) dec ids


    fun lookupIdStatus(E, vid') =
	case lookupVal(E, vid')
	  of NONE             => V
	   | SOME(i,stamp,is) => is



  (* Syntactic arity of constructors *)

    fun conArity []			= 0
      | conArity typs'			= typArity(List.hd typs')

    and typArity(O.TupTyp(_,typs'))	= Int.max(1, List.length typs')
      | typArity(O.ProdTyp(_,row'))	= Int.max(1, rowArity row')
      | typArity _			= 1

    and rowArity(O.Row(_,fields',_))	= List.length fields'




  (* Constants and identifiers *)

    fun trSCon E =
	fn SCon(i, SCon.INT n)		=> O.IntLit n
	 | SCon(i, SCon.WORD w)		=> O.WordLit w
	 | SCon(i, SCon.CHAR c)		=> O.CharLit c
	 | SCon(i, SCon.STRING s)	=> O.StringLit s
	 | SCon(i, SCon.REAL x)		=> O.RealLit x

    fun trLab E (Lab(i, lab)) = O.Lab(i, Label.fromString(Lab.toString lab))

    fun trTyVar E (tyvar as TyVar(i, tyvar')) =
	let
	    val (_,stamp) =
		case lookupVar(E, tyvar')
		  of SOME xx => xx
		   | NONE    => error(i, E.TyVarUnbound tyvar')
	in
	    O.Id(i, stamp, Name.ExId(TyVar.toString tyvar'))
	end

    fun trId (lookup,infoId,idId,toString,Unbound) E id =
	let
	    val i   = infoId id
	    val id' = idId id
	    val (_,stamp,x) = case lookup(E, id')
				of SOME xx => xx
				 | NONE    => error(i, Unbound id')
	in
	    ( O.Id(i, stamp, Name.ExId(toString id')), x )
	end

    val trVId   = trId(lookupVal, infoVId, idVId, VId.toString, E.VIdUnbound)
    val trTyCon = trId(lookupTy, infoTyCon, idTyCon,
			TyCon.toString, E.TyConUnbound)
    val trStrId = trId(lookupStr, infoStrId, idStrId,
			StrId.toString, E.StrIdUnbound)
    val trSigId = trId(lookupSig, infoSigId, idSigId,
			SigId.toString, E.SigIdUnbound)


    fun trId_bind (lookup,infoId,idId,toString,Shadowed) E id =
	let
	    val i     = infoId id
	    val id'   = idId id
	    val name  = toString id'
	    val stamp = Stamp.new()
	    val _     = if not(Option.isSome(lookup(E, id'))) then () else
			   warn(i, Shadowed id')
	in
	    ( O.Id(i, stamp, Name.ExId name), stamp )
	end


    val trTyVar_bind = trId_bind(lookupVar, infoTyVar, idTyVar, TyVar.toString,
				 E.TyVarShadowed)
    val trVId_bind   = trId_bind(lookupVal, infoVId,   idVId,   VId.toString,
				 E.VIdShadowed)
    val trTyCon_bind = trId_bind(lookupTy,  infoTyCon, idTyCon, TyCon.toString,
				 E.TyConShadowed)
    val trStrId_bind = trId_bind(lookupStr, infoStrId, idStrId, StrId.toString,
				 E.StrIdShadowed)
    val trSigId_bind = trId_bind(lookupSig, infoSigId, idSigId, SigId.toString,
				 E.SigIdShadowed)

    fun trVId_bind' E (VId(i, vid')) =
	let
	    val name  = VId.toString vid'
	    val stamp = Stamp.new()
	in
	    O.Id(i, stamp, Name.ExId name)
	end


    (* With polymorphic recursion we could avoid the following code
       duplication... *)

    fun trLongStrId' E =
	fn SHORTLong(i, strid) =>
	   let
		val (id',E') = trStrId E strid
	   in
		if O.stamp id' = stamp_prebound E then
		    ( NONE, E' )
		else
		    ( SOME(O.ShortId(i,id')), E' )
	   end

	 | DOTLong(i, longstrid, strid) =>
	   let
		val (longido',E') = trLongStrId' E longstrid
		val (id',x)       = trStrId E' strid
		val  longid'      =
		     case longido'
		       of SOME longid' => O.LongId(i, longid', O.idToLab id')
			| NONE         => O.ShortId(i, id')

	   in
		( SOME longid', x )
	   end

    fun trLongId trId E =
	fn SHORTLong(i, id) =>
	   let
		val (id',x) = trId E id
	   in
		if O.stamp id' = stamp_prebound E then
		    error(i, E.PreboundFirstClass)
		else
		    ( O.ShortId(i,id'), x )
	   end

	 | DOTLong(i, longstrid, id) =>
	   let
		val (longido',E') = trLongStrId' E longstrid
		val (id',x)       = trId E' id
	   in
		case longido'
		  of SOME longid' => ( O.LongId(i,longid', O.idToLab id'), x )
		   | NONE         => ( O.ShortId(i,id'), x )
	   end

    val trLongVId   = trLongId trVId
    val trLongTyCon = trLongId trTyCon
    val trLongStrId = trLongId trStrId
    val trLongSigId = trLongId trSigId



  (* Calculate sets of unguarded explicit type variables [Section 4.6] *)

    fun ? tyvarsX E  NONE    = []
      | ? tyvarsX E (SOME x) = tyvarsX E x

    fun unguardedTyVarsAtExp E (RECORDAtExp(_, exprow_opt)) =
	    ?unguardedTyVarsExpRow E exprow_opt

      | unguardedTyVarsAtExp E ( TUPLEAtExp(_, exps)
			       | VECTORAtExp(_, exps)
			       | SEQAtExp(_, exps) ) =
	    List.concat(List.map (unguardedTyVarsExp E) exps)

      | unguardedTyVarsAtExp E (LETAtExp(_, dec, exp)) =
	    unguardedTyVarsDec E dec @ unguardedTyVarsExp E exp

      | unguardedTyVarsAtExp E (PARAtExp(_, exp)) =
	    unguardedTyVarsExp E exp

      | unguardedTyVarsAtExp E _ = []

    and unguardedTyVarsExpRow E (ROWExpRow(_, lab, exp, exprow_opt)) =
	    unguardedTyVarsExp E exp @ ?unguardedTyVarsExpRow E exprow_opt

    and unguardedTyVarsExp E (ATEXPExp(_, atexp)) =
	    unguardedTyVarsAtExp E atexp

      | unguardedTyVarsExp E (APPExp(_, exp, atexp)) =
	    unguardedTyVarsExp E exp @ unguardedTyVarsAtExp E atexp

      | unguardedTyVarsExp E (TYPEDExp(_, exp, ty)) =
	    unguardedTyVarsExp E exp @ unguardedTyVarsTy E ty

      | unguardedTyVarsExp E ( ANDALSOExp(_, exp1, exp2)
			     | ORELSEExp(_, exp1, exp2)
			     | WHILEExp(_, exp1, exp2) ) =
	    unguardedTyVarsExp E exp1 @ unguardedTyVarsExp E exp2

      | unguardedTyVarsExp E (HANDLEExp(_, exp, match)) =
	    unguardedTyVarsExp E exp @ unguardedTyVarsMatch E match

      | unguardedTyVarsExp E (RAISEExp(_, exp)) =
	    unguardedTyVarsExp E exp

      | unguardedTyVarsExp E (IFExp(_, exp1, exp2, exp3)) =
	    unguardedTyVarsExp E exp1 @ unguardedTyVarsExp E exp2 @
	    unguardedTyVarsExp E exp3

      | unguardedTyVarsExp E (CASEExp(_, exp, match)) =
	    unguardedTyVarsExp E exp @ unguardedTyVarsMatch E match

      | unguardedTyVarsExp E (FNExp(_, match)) =
	    unguardedTyVarsMatch E match

      | unguardedTyVarsExp E (PACKExp(_, longstrid)) =
	    []

    and unguardedTyVarsMatch E (Match(_, mrule, match_opt)) =
	    unguardedTyVarsMrule E mrule @ ?unguardedTyVarsMatch E match_opt

    and unguardedTyVarsMrule E (Mrule(_, pat, exp)) =
	    unguardedTyVarsPat E pat @ unguardedTyVarsExp E exp

    and unguardedTyVarsDec E (CONSTRUCTORDec(_, dconbind)) =
	    unguardedTyVarsDconBind E dconbind

      | unguardedTyVarsDec E (STRUCTUREDec(_, strbind)) =
	    unguardedTyVarsStrBind E strbind

      | unguardedTyVarsDec E ( LOCALDec(_, dec1, dec2)
			     | SEQDec(_, dec1, dec2) ) =
	    unguardedTyVarsDec E dec1 @ unguardedTyVarsDec E dec2

      | unguardedTyVarsDec E _ = []

    and unguardedTyVarsValBind E (PLAINValBind(_, pat, exp, valbind_opt)) =
	    unguardedTyVarsPat E pat @ unguardedTyVarsExp E exp @
	    ?unguardedTyVarsValBind E valbind_opt

      | unguardedTyVarsValBind E (RECValBind(_, valbind)) =
	    unguardedTyVarsValBind E valbind

    and unguardedTyVarsFvalBind E (FvalBind(_, match, fvalbind_opt)) =
	    unguardedTyVarsMatch E match @
	    ?unguardedTyVarsFvalBind E fvalbind_opt

    and unguardedTyVarsDconBind E (NEWDconBind(_, _, vid, ty_opt, tyvarseq,
						     longtycon, dconbind_opt)) =
	let
	    val  _   = insertScope E
	    val  _   = trTyVarSeq E tyvarseq
	    val  _   = insertScope E
	    val ids' = ?unguardedTyVarsTy E ty_opt
	    val  E'  = splitScope E
	    val  _   = deleteScope E
	    val  _   = union(E,E')
	in
	    ids' @ ?unguardedTyVarsDconBind E dconbind_opt
	end

      | unguardedTyVarsDconBind E (EQUALDconBind(_, _,vid, _,longvid,
								dconbind_opt)) =
	    ?unguardedTyVarsDconBind E dconbind_opt

    and unguardedTyVarsStrBind E (StrBind(_, strid, strexp, strbind_opt)) =
	    unguardedTyVarsStrExp E strexp @
	    ?unguardedTyVarsStrBind E strbind_opt

    and unguardedTyVarsAtPat E (RECORDAtPat(_, patrow_opt)) =
	    ?unguardedTyVarsPatRow E patrow_opt

      | unguardedTyVarsAtPat E ( TUPLEAtPat(_, pats)
			       | VECTORAtPat(_, pats)
			       | ALTAtPat(_, pats) ) =
	    List.concat(List.map (unguardedTyVarsPat E) pats)

      | unguardedTyVarsAtPat E (PARAtPat(_, pat)) =
	    unguardedTyVarsPat E pat

      | unguardedTyVarsAtPat E _ = []

    and unguardedTyVarsPatRow E (WILDCARDPatRow(_)) = []

      | unguardedTyVarsPatRow E (ROWPatRow(_, lab, pat, patrow_opt)) =
	    unguardedTyVarsPat E pat @ ?unguardedTyVarsPatRow E patrow_opt

    and unguardedTyVarsPat E (ATPATPat(_, atpat)) =
	    unguardedTyVarsAtPat E atpat

      | unguardedTyVarsPat E (APPPat(_, pat, atpat)) =
	    unguardedTyVarsPat E pat @ unguardedTyVarsAtPat E atpat

      | unguardedTyVarsPat E (TYPEDPat(_, pat, ty)) =
	    unguardedTyVarsPat E pat @ unguardedTyVarsTy E ty

      | unguardedTyVarsPat E (NONPat(_, pat)) =
	    unguardedTyVarsPat E pat

      | unguardedTyVarsPat E (ASPat(_, pat1, pat2)) =
	    unguardedTyVarsPat E pat1 @ unguardedTyVarsPat E pat2

      | unguardedTyVarsPat E (WHENPat(_, pat, atexp)) =
	    unguardedTyVarsPat E pat @ unguardedTyVarsAtExp E atexp

      | unguardedTyVarsPat E (WITHVALPat(_, pat, valbind)) =
	    unguardedTyVarsPat E pat @ unguardedTyVarsValBind E valbind

      | unguardedTyVarsPat E (WITHFUNPat(_, pat, fvalbind)) =
	    unguardedTyVarsPat E pat @ unguardedTyVarsFvalBind E fvalbind

    and unguardedTyVarsTy E (TYVARTy(_, tyvar as TyVar(i,tyvar'))) =
	if Option.isSome(lookupVar(E, tyvar')) then
	    []
	else
	let
	    val (id',stamp) = trTyVar_bind E tyvar
	    val  _          = insertVar(E, tyvar', (i, stamp))
	in
	    [id']
	end

      | unguardedTyVarsTy E (RECORDTy(_, tyrow_opt)) =
	    ?unguardedTyVarsTyRow E tyrow_opt

      | unguardedTyVarsTy E (TUPLETy(_, tys)) =
	    List.concat(List.map (unguardedTyVarsTy E) tys)

      | unguardedTyVarsTy E (TYCONTy(_, tyseq, longtycon)) =
	    unguardedTyVarsTyseq E tyseq

      | unguardedTyVarsTy E (ARROWTy(_, ty, ty')) =
	    unguardedTyVarsTy E ty @ unguardedTyVarsTy E ty'

      | unguardedTyVarsTy E (PACKTy(_, longsigid)) =
	    []

      | unguardedTyVarsTy E (PARTy(_, ty)) =
	    unguardedTyVarsTy E ty

    and unguardedTyVarsTyRow E (ROWTyRow(_, lab, ty, tyrow_opt)) =
	    unguardedTyVarsTy E ty @ ?unguardedTyVarsTyRow E tyrow_opt

    and unguardedTyVarsTyseq E (Seq(_, tys)) =
	    List.concat(List.map (unguardedTyVarsTy E) tys)

    and unguardedTyVarsAtStrExp E (STRUCTAtStrExp(_, dec)) =
	    unguardedTyVarsDec E dec

      | unguardedTyVarsAtStrExp E (LONGSTRIDAtStrExp(_, longstrid)) =
	    []

      | unguardedTyVarsAtStrExp E (LETAtStrExp(_, dec, strexp)) =
	    unguardedTyVarsDec E dec @ unguardedTyVarsStrExp E strexp

      | unguardedTyVarsAtStrExp E (PARAtStrExp(_, strexp)) =
	    unguardedTyVarsStrExp E strexp

    and unguardedTyVarsStrExp E (ATSTREXPStrExp(_, atstrexp)) =
	    unguardedTyVarsAtStrExp E atstrexp

      | unguardedTyVarsStrExp E (APPStrExp(_, strexp, atstrexp)) =
	    unguardedTyVarsStrExp E strexp @ unguardedTyVarsAtStrExp E atstrexp

      | unguardedTyVarsStrExp E ( TRANSStrExp(_, strexp, _)
				| OPAQStrExp(_, strexp, _)
				| FCTStrExp(_, _, strexp) ) =
	    unguardedTyVarsStrExp E strexp

      | unguardedTyVarsStrExp E (UNPACKStrExp(_, exp, sigexp)) =
	    unguardedTyVarsExp E exp

      (*UNFINISHED: if we have LETSigExp then we must check sigexps as well*)



  (* Expressions *)

    and trAtExp E =
	fn SCONAtExp(i, scon)		=> O.LitExp(i, trSCon E scon)
	 | LONGVIDAtExp(i, _, longvid)	=>
	   (case trLongVId E longvid
	      of (longid', V) =>
		 O.VarExp(i, longid')

	       | (longid', C k) =>
		 O.ConExp(i, longid', k)

	       | (longid', R) =>
		 O.RefExp(i)
	   )
	 | RECORDAtExp(i, exprowo) =>
	   let
		val  _   = insertScope E
		val row' = trExpRowo E exprowo
		val  _   = deleteScope E
	   in
		O.ProdExp(i, row')
	   end
	 | UPDATEAtExp(i, atexp, exprow) =>
	   let
		val exp' = trAtExp E atexp
		val  _   = insertScope E
		val row' = trExpRowo E (SOME exprow)
		val  _   = deleteScope E
	   in
		O.CompExp(i, exp', O.ProdExp(infoExpRow exprow, row'))
	   end
	 | HASHAtExp(i, lab)		=> O.SelExp(i, trLab E lab)
	 | TUPLEAtExp(i, exps)		=> O.TupExp(i, trExps E exps)
	 | VECTORAtExp(i, exps)		=> O.VecExp(i, trExps E exps)
	 | SEQAtExp(i, exps)		=> O.SeqExp(i, trExps E exps)
	 | LETAtExp(i, dec, exp)	=>
	   let
		val  _   = insertScope E
		val dec' = trDec E dec
		val exp' = trExp E exp
		val  _   = deleteScope E
	   in
		O.LetExp(i, dec', exp')
	   end
	 | PARAtExp(i, exp)		=> trExp E exp


    and trExpRowo E =
	fn NONE => O.Row(Source.nowhere, [], false)

	 | SOME(ROWExpRow(i, lab as Lab(i',lab'), exp, exprowo)) =>
	   let
		val i1'    = Source.over(i', infoExp exp)
		val field' = O.Field(i1', trLab E lab, [trExp E exp])
		val _      = insertFld(E, lab', i') handle CollisionFld _ =>
				error(i', E.ExpRowLabDuplicate lab')
		val O.Row(_,fields',_) = trExpRowo E exprowo
	   in
		O.Row(i, field'::fields', false)
	   end


    and trExp E =
	fn exp as (ATEXPExp _|APPExp _)	=> trAppExp E (Infix.exp (infEnv E) exp)
 	 | TYPEDExp(i, exp, ty)		=> O.AnnExp(i,trExp E exp, trTy E ty)
	 | ANDALSOExp(i, exp1, exp2)	=> O.AndExp(i,trExp E exp1,trExp E exp2)
	 | ORELSEExp(i, exp1, exp2)	=> O.OrExp(i,trExp E exp1, trExp E exp2)
	 | HANDLEExp(i, exp, match)	=>
		O.HandleExp(i, trExp E exp, trMatcho E (SOME match))

	 | RAISEExp(i, exp)		=> O.RaiseExp(i, trExp E exp)
	 | IFExp(i, exp1, exp2, exp3)	=>
		O.IfExp(i, trExp E exp1, trExp E exp2, trExp E exp3)

	 | WHILEExp(i, exp1, exp2) =>
		O.WhileExp(i, trExp E exp1, trExp E exp2)

	 | CASEExp(i, exp, match) =>
		O.CaseExp(i, trExp E exp, trMatcho E (SOME match))

	 | FNExp(i, match) =>
	   let
		val i'       = infoMatch match
		val matches' = trMatcho E (SOME match)
	   in
		O.FunExp(i, matches')
	   end

	| PACKExp(i, longstrid) =>
	  let
		val (longid',E') = trLongStrId E longstrid
		val  mod'        = longidToMod longid'
	  in
		O.PackExp(i, mod')
	  end


    and trAppExp E =
	fn APPExp(i, exp, atexp) => O.AppExp(i, trAppExp E exp, trAtExp E atexp)
	 | ATEXPExp(i, atexp)    => trAtExp E atexp
	 | exp                   => trExp E exp

    and trExps E = List.map(trExp E)



  (* Matches and patterns *)

    and trMatcho  E matcho = List.rev(trMatcho' (E,[]) matcho)
    and trMatcho'(E,acc) =
	fn NONE => acc
	 | SOME(Match(i, mrule, matcho)) =>
	   let
		val match' = trMrule E mrule
	   in
		trMatcho' (E, match'::acc) matcho
	   end

    and trMrule E (Mrule(i, pat, exp)) =
	let
		val E'   = BindEnv.new()
		val pat' = trPat (E,E') pat
		val  _   = inheritScope(E,E')
		val exp' = trExp E exp
		val  _   = deleteScope E
	in
		O.Match(i, pat', exp')
	end


    and trAtPat (E,E') =
	fn WILDCARDAtPat(i)	=> O.JokPat(i)
	 | SCONAtPat(i, scon)	=> O.LitPat(i, trSCon E scon)
	 | LONGVIDAtPat(_, _, longvid as SHORTLong(i, vid as VId(i',vid'))) =>
	   (case lookupIdStatus(E, vid')
	      of C k => O.ConPat(i, #1(trLongVId E longvid), k)
	       | R   => O.RefPat(i)
	       | V   =>
		 let
		    (* If inside an alternative pattern then E' contains
		     * an upper scope where the variable is already bound.
		     * We have to reuse the stamp found there.
		     *)
		    val _ = if Option.isSome(lookupScopeVal(E', vid')) then
			       error(i', E.PatVIdDuplicate vid')
			    else ()
		    val (id',stamp) =
			case lookupVal(E', vid')
			  of NONE            => trVId_bind E vid
			   | SOME(_,stamp,_) => ( O.Id(i', stamp,
						   Name.ExId(VId.toString vid'))
						, stamp )
		    val _ = insertVal(E', vid', (i',stamp,V))
		 in
		    O.VarPat(i, id')
		 end
	   )
	 | LONGVIDAtPat(i, _, longvid) =>
	   (case trLongVId E longvid
	      of (longid', C k) => O.ConPat(i, longid', k)
	       | (longid', R)   => O.RefPat(i)
	       | (longid', V)   => error(i, E.PatLongVIdVar)
	   )
	 | RECORDAtPat(i, patrowo) =>
	   let
		val  _   = insertScope E
		val row' = trPatRowo (E,E') patrowo
		val  _   = deleteScope E
	   in
		O.ProdPat(i, row')
	   end

	 | TUPLEAtPat(i, pats)     => O.TupPat(i, trPats (E,E') pats)
	 | VECTORAtPat(i, pats)    => O.VecPat(i, trPats (E,E') pats)
	 | ALTAtPat(i, pats)       =>
	   let
		val  _    = insertScope E'
		val pat'  = trPat (E,E') (List.hd pats)
		val pats' = trAltPats (E,E') (List.tl pats)
		val  _    = mergeDisjointScope E' handle CollisionVal vid' =>
				errorVId(E', vid', E.PatVIdDuplicate)
	   in
		O.AltPat(i, pat'::pats')
	   end

	 | PARAtPat(i, pat) => trPat (E,E') pat


    and trPatRowo (E,E') =
	fn NONE => O.Row(Source.nowhere, [], false)

	 | SOME(WILDCARDPatRow(i)) => O.Row(i, [], true)

	 | SOME(ROWPatRow(i, lab as Lab(i',lab'), pat, patrowo)) =>
	   let
		val i1'    = Source.over(i', infoPat pat)
		val field' = O.Field(i1', trLab E lab, [trPat (E,E') pat])
		val _      = insertFld(E, lab', i') handle CollisionFld _ =>
				error(i', E.PatRowLabDuplicate lab')
		val O.Row(_,fields',dots') = trPatRowo (E,E') patrowo
	   in
		O.Row(i, field'::fields', dots')
	   end


    and trPat (E,E') =
	fn pat as (ATPATPat _|APPPat _) =>
		trAppPat (E,E') (Infix.pat (infEnv E) pat)

	 | TYPEDPat(i, pat, ty)	=> O.AnnPat(i, trPat (E,E') pat, trTy E ty)
	 | NONPat(i, pat)	=> O.NegPat(i, trPat (E,BindEnv.new()) pat)
	 | ASPat(i, pat1, pat2) => O.AsPat(i,trPat (E,E') pat1,trPat(E,E') pat2)
	 | WHENPat(i, pat, atexp) =>
	   let
		val  _   = insertScope E'
		val pat' = trPat (E,E') pat
		val  _   = inheritScope(E, cloneScope E')
		val exp' = trAtExp E atexp
		val  _   = deleteScope E
		val  _   = mergeDisjointScope E' handle CollisionVal vid' =>
				errorVId(E', vid', E.PatVIdDuplicate)
	   in
		O.GuardPat(i, pat', exp')
	   end

	 | WITHVALPat(i, pat, valbind) =>
	   let
		val  _   = insertScope E'
		val pat' = trPat (E,E') pat
		val  _   = inheritScope(E, cloneScope E')
		val  _   = insertScope E'
		val decs'= trValBindo (E,E') (SOME valbind)
		val  _   = deleteScope E
		val  _   = mergeDisjointScope E' handle CollisionVal vid' =>
				errorVId(E', vid', E.WithPatVIdDuplicate)
		val  _   = mergeDisjointScope E' handle CollisionVal vid' =>
				errorVId(E', vid', E.PatVIdDuplicate)
	   in
		O.WithPat(i, pat', decs')
	   end

	 | WITHFUNPat(i, pat, fvalbind) =>
	   let
		val  _   = insertScope E'
		val pat' = trPat (E,E') pat
		val  _   = inheritScope(E, cloneScope E')
		val  _   = insertScope E'
		val ids' = trFvalBindo_lhs (E,E') (SOME fvalbind)
		val  _   = inheritScope(E, cloneScope E')
		val exps'= trFvalBindo_rhs E (SOME fvalbind)
		val decs'= ListPair.map
				(fn(id',exp') =>
				 O.ValDec(O.infoExp exp',
					  O.VarPat(O.infoId id', id'), exp'))
				(ids',exps')
		val  _   = deleteScope E
		val  _   = deleteScope E
		val  _   = mergeDisjointScope E' handle CollisionVal vid' =>
				errorVId(E', vid', E.WithPatVIdDuplicate)
		val  _   = mergeDisjointScope E' handle CollisionVal vid' =>
				errorVId(E', vid', E.PatVIdDuplicate)
	   in
		O.WithPat(i, pat', [O.RecDec(infoFvalBind fvalbind, decs')])
	   end

    and trAppPat (E,E') =
	fn APPPat(i, pat, atpat) =>
	   let
		val pat1' = trAppPat (E,E') pat
		val pat2' = trAtPat (E,E') atpat
	   in
		case pat1'
		  of ( O.ConPat _ | O.RefPat _ | O.AppPat _ ) =>
			O.AppPat(i, pat1', pat2')

		   | _ => error(i, E.AppPatNonCon)
	   end

	 | ATPATPat(i, atpat) => trAtPat (E,E') atpat

	 | pat => trPat (E,E') pat


    and trPats (E,E') = List.map(trPat (E,E'))

    and trAltPats (E,E') = List.map(trAltPat (E,E'))

    and trAltPat (E,E') pat =
	let
	    val _    = insertScope E'
	    val pat' = trPat (E,E') pat
	    val E''  = splitScope E'
	    val _    = if BindEnv.sizeScope E' = BindEnv.sizeScope E'' then ()
		       else error(infoPat pat, E.AltPatInconsistent)
	    val _    = BindEnv.appiScopeVals
			    (fn(vid,_) =>
				if Option.isSome(lookupVal(E'',vid)) then ()
				else error(infoPat pat, E.AltPatInconsistent)
			    ) E'
	in
	    pat'
	end



  (* Types *)

    and trTy E =
	fn TYVARTy(i, tyvar as TyVar(i',tyvar')) =>
		O.VarTyp(i, trTyVar E tyvar)

	 | TYCONTy(i, tyseq, longtycon) =>
	   let
		val (longid',_) = trLongTyCon E longtycon
		val  typs'      = trTySeq E tyseq
	   in
		apptyp(typs', O.ConTyp(i, longid'))
	   end

	 | RECORDTy(i, tyrowo) =>
	   let
		val  _   = insertScope E
		val row' = trTyRowo E tyrowo
		val  _   = deleteScope E
	   in
		O.ProdTyp(i, row')
	   end

	 | TUPLETy(i, tys) =>
	   let
		val typs' = trTys E tys
	   in
		O.TupTyp(i, typs')
	   end

	 | ARROWTy(i, ty1, ty2) => O.ArrTyp(i, trTy E ty1, trTy E ty2)

	 | PACKTy(i, longsigid) =>
	   let
		val (longid',E') = trLongSigId E longsigid
		val  inf'        = O.ConInf(infoLong longsigid, longid')
	   in
		O.PackTyp(i, inf')
	   end

	 | PARTy(i, ty) => trTy E ty

    and trTys E = List.map (trTy E)


    and trTyRowo E =
	fn NONE => O.Row(Source.nowhere, [], false)

	 | SOME(ROWTyRow(i, lab as Lab(i',lab'), ty, tyrowo)) =>
	   let
		val i1'    = Source.over(i', infoTy ty)
		val field' = O.Field(i1', trLab E lab, [trTy E ty])
		val _      = insertFld(E, lab', i') handle CollisionFld _ =>
				error(i', E.TyRowLabDuplicate lab')
		val O.Row(_,fields',_) = trTyRowo E tyrowo
	   in
		O.Row(i, field'::fields', false)
	   end



    and trTySeq E (Seq(i, tys)) = List.map (trTy E) tys


    and trTyVarSeq E (Seq(i, tyvars)) = List.map (trSeqTyVar E) tyvars

    and trSeqTyVar E (tyvar as TyVar(i, tyvar')) =
	let
	    val (id',stamp) = trTyVar_bind E tyvar
	    val  _          = insertDisjointVar(E, tyvar', (i, stamp))
			      handle CollisionVar _ =>
				error(i, E.TyVarSeqDuplicate tyvar')
	in
	    id'
	end


    (* Tyvarseqs at a val or fun *)

    and trValTyVarSeq E (Seq(i, tyvars)) = List.map (trValSeqTyVar E) tyvars

    and trValSeqTyVar E (tyvar as TyVar(i, tyvar')) =
	if Option.isSome(lookupVar(E, tyvar')) then
	    error(i, E.ValTyVarSeqDuplicate tyvar')
	else
	let
	    val (id',stamp) = trTyVar_bind E tyvar
	    val  _          = insertVar(E, tyvar', (i, stamp))
	in
	    id'
	end


    (* Extract type variables from a type (as implicitly quantified) *)

    and trAllTy E =
	fn TYVARTy(i, tyvar as TyVar(i',tyvar')) =>
	   if Option.isSome(lookupVar(E, tyvar')) then
		[]
	   else
	   let
		val (id',stamp) = trTyVar_bind E tyvar
		val  _          = insertVar(E, tyvar', (i, stamp))
	   in
		[id']
	   end

	 | TYCONTy(i, tyseq, longtycon) => trAllTySeq E tyseq
	 | RECORDTy(i, tyrowo)   => trAllTyRowo E tyrowo
	 | TUPLETy(i, tys)       => List.concat(List.map (trAllTy E) tys)
	 | ARROWTy(i, ty1, ty2)  => trAllTy E ty1 @ trAllTy E ty2
	 | PACKTy(i, longsigid)  => []
	 | PARTy(i, ty)          => trAllTy E ty

    and trAllTyRowo E =
	fn NONE                               => []
	 | SOME(ROWTyRow(i, lab, ty, tyrowo)) =>
		trAllTy E ty @ trAllTyRowo E tyrowo

    and trAllTySeq E (Seq(i, tys)) = List.concat(List.map (trAllTy E) tys)



  (* Declarations *)

    and trDec  E dec  = List.rev(trDec' (E,[]) dec)
    and trDec'(E,acc) =
	fn VALDec(i, tyvarseq, valbind) =>
	   let
		val  E'   = BindEnv.new()
		val  _    = insertScope E
		val ids'  = trValTyVarSeq E tyvarseq @
			    unguardedTyVarsValBind E valbind
		val decs' = (if List.null ids'
			     then trValBindo'(E,E',acc)
			     else trValBindo (E,E') ) (SOME valbind)
		val  _    = deleteScope E
		val  _    = union(E,E')
	   in
		if List.null ids'
		then decs'
		else List.map (fn dec' => vardec(ids', dec')) decs' @ acc
	   (* UNFINISHED: violates uniqueness of stamps in bindings *)
	   end

	 | FUNDec(i, tyvarseq, fvalbind) =>
	   let
		val E'    = BindEnv.new()
		val ids'  = trFvalBindo_lhs (E,E') (SOME fvalbind)
		val  _    = union(E,E')
		val  _    = insertScope E
		val ids'' = trValTyVarSeq E tyvarseq @
			    unguardedTyVarsFvalBind E fvalbind
		val exps' = trFvalBindo_rhs E (SOME fvalbind)
		val  _    = deleteScope E
		val decs' = ListPair.map
				(fn(id',exp') =>
				 O.ValDec(O.infoExp exp',
					  O.VarPat(O.infoId id', id'), exp'))
				(ids',exps')
	   in
		vardec(ids'', O.RecDec(i, decs')) :: acc
	   end

	 | TYPEDec(i, typbind) =>
	   let
		val E'    = BindEnv.new()
		val decs' = trTypBindo' (E,E',acc) (SOME typbind)
		val  _    = union(E,E')
	   in
		decs'
	   end

	 | EQTYPEDec(i, typbind) =>
	   (* UNFINISHED *)
	   let
		val E'    = BindEnv.new()
		val decs' = trTypBindo' (E,E',acc) (SOME typbind)
		val  _    = union(E,E')
	   in
		decs'
	   end

	 | EQEQTYPEDec(i, typbind) =>
	   (* UNFINISHED *)
	   let
		val E'    = BindEnv.new()
		val decs' = trTypBindo' (E,E',acc) (SOME typbind)
		val  _    = union(E,E')
	   in
		decs'
	   end

	 | DATATYPEDec(i, datbind) =>
	   let
		val  E'             = BindEnv.new()
		val  _              = trDatBindo_lhs (E,E') (SOME datbind)
		val  _              = union(E,E')
		val (tdecs',cdecs') = trDatBindo_rhs (E,E') (SOME datbind)
		val  _              = union(E,E')
	   in
		cdecs' @ O.RecDec(i, tdecs') :: acc
	   end

	 | REPLICATIONDec(i, tycon as TyCon(i',tycon'), longtycon) =>
	   let
		val (id',stamp)  = trTyCon_bind E tycon
		val (longid',E') = trLongTyCon E longtycon
		val  longido'    = case longid'
				     of O.LongId(_,longid',_) => SOME longid'
				      | O.ShortId _           => NONE
		val _            = insertTy(E, tycon', (i', stamp, E'))
	   in
		foldiVals (trOpenDecVal (E,i,longido'))
		  (O.TypDec(i, id', O.ConTyp(infoLong longtycon, longid'))::acc)
		  E'
	   end

	 | CONSTRUCTORDec(i, dconbind) =>
	   let
		val E'    = BindEnv.new()
		val decs' = trDconBindo' (E,E',acc) (SOME dconbind)
		val  _    = union(E,E')
	   in
		decs'
	   end

	 | STRUCTUREDec(i, strbind) =>
	   let
		val E'    = BindEnv.new()
		val decs' = trStrBindo' (E,E',acc) (SOME strbind)
		val  _    = union(E,E')
	   in
		decs'
	   end

	 | SIGNATUREDec(i, sigbind) =>
	   let
		val E'    = BindEnv.new()
		val decs' = trSigBindo' (E,E',acc) (SOME sigbind)
		val _     = union(E,E')
	   in
		decs'
	   end

	 | LOCALDec(i, dec1, dec2) =>
	   let
		val  _     = insertScope E
		val decs1' = trDec E dec1
		val  _     = insertScope E
		val decs2' = trDec' (E, O.LocalDec(i, decs1')::acc) dec2
		val  E'    = splitScope E
		val  _     = deleteScope E
		val  _     = union(E,E')
	   in
		decs2'
	   end

	 | OPENDec(i, longstrid) =>
	   let
		val (longid', E') = trLongStrId E longstrid
		val   _           = unionInf(E,E')
	   in
		(foldiVals (trOpenDecVal(E,i,SOME longid'))
		(foldiTys  (trOpenDecTy (E,i,longid'))
		(foldiStrs (trOpenDecStr(E,i,longid'))
		(foldiSigs (trOpenDecSig(E,i,longid')) acc E') E') E') E')
	   end

	 | EMPTYDec(i) =>
		acc

	 | SEQDec(i, dec1, dec2) =>
		trDec' (E, trDec' (E,acc) dec1) dec2

	 | PRIMITIVEVALDec(i, _, vid as VId(i',vid'), ty, s) =>
	   let
		val (id',stamp) = trVId_bind E vid
		val  _          = insertScope E
		val  ids'       = trAllTy E ty
		val  typ'       = trTy E ty
		val  _          = deleteScope E
		val  pat'       = O.VarPat(i', id')
		val  exp'       = O.PrimExp(i, s, typ')
		val  dec'       = O.ValDec(i, pat', exp')
		val  _          = insertVal(E, vid', (i, stamp, V))
	   in
		vardec(ids', dec') :: acc
	   end

	 | PRIMITIVECONSTRUCTORDec
		(i, _, vid as VId(i',vid'), tyo, tyvarseq, longtycon, s) =>
	   let
		val  id1'        = inventId i
		val (id2',stamp) = trVId_bind E vid
		val  _           = insertScope E
		val (ids',typ')  = trTyVarSeqLongTyCon E (tyvarseq, longtycon)
		val  typs'       = trTyo E tyo
		val  _           = deleteScope E
		val  typ1'       = arrtyp(typs',typ')
		val  pat1'       = O.VarPat(i', id1')
		val  exp1'       = O.PrimExp(i, s, typ1')
		val  dec1'       = O.ValDec(i, pat1', exp1')
		val  typ2'       = O.SingTyp(i, O.ShortId(i',id1'))
		val  k           = conArity typs'
		val  dec2'       = O.ConDec(i, id2', typ2', k)
		val  _           = insertVal(E, vid', (i', stamp, C k))
	   in
		dec2' :: vardec(ids', dec1') :: acc
	   end

	 | PRIMITIVESTRUCTUREDec(i, strid as StrId(i',strid'), sigexp, s) =>
	   let
		val (id',stamp) = trStrId_bind E strid
		val (inf',E')   = trSigExp E sigexp
		val  mod'       = O.PrimMod(i, s, inf')
		val  dec'       = O.ModDec(i, id', mod')
		val  _          = insertStr(E, strid', (i, stamp, E'))
	   in
		dec' :: acc
	   end

	 | OVERLOADDec(i, _, vid, tyvar, ty) =>
	   (*UNFINISHED*)
	   let
		val (id',stamp) = trVId_bind E vid
		val _           = insertScope E
		val id1'        = trTyVar_bind E tyvar
		val _           = insertScope E
		val ids'        = trAllTy E ty
		val typ'        = alltyp(ids', trTy E ty)
		val _           = deleteScope E
		val _           = deleteScope E
	   in
		acc
	   end

	 | INSTANCEDec(i, _, vid, longtycon, longvid) =>
	   (*UNFINISHED*)
		acc

	 | INSTANCESCONDec(i, scon, longtycon) =>
	   (*UNFINISHED*)
		acc

	 | INFIXDec(i, n, vid as VId(i',vid')) =>
	   let
		val id'  = trVId_bind' E vid
		val fix  = Fixity.INFIX(n, Fixity.LEFT)
		val fix' = O.Fix(i, fix)
		val dec' = O.FixDec(i, id', fix')
		val _    = insertInf(E, vid', (i', SOME(LEFT, n)))
	   in
		dec' :: acc
	   end

	 | INFIXRDec(i, n, vid as VId(i',vid')) =>
	   let
		val id'  = trVId_bind' E vid
		val fix  = Fixity.INFIX(n, Fixity.RIGHT)
		val fix' = O.Fix(i, fix)
		val dec' = O.FixDec(i, id', fix')
		val _    = insertInf(E, vid', (i', SOME(RIGHT, n)))
	   in
		dec' :: acc
	   end

	 | NONFIXDec(i, vid as VId(i',vid')) =>
	   let
		val id'  = trVId_bind' E vid
		val fix  = Fixity.NONFIX
		val fix' = O.Fix(i, fix)
		val dec' = O.FixDec(i, id', fix')
		val _    = insertInf(E, vid', (i', NONE))
	   in
		dec' :: acc
	   end


    and trOpenDecVal (E,i,longido') (vid', (_,stamp1,is), acc) =
	let
	    val name    = VId.toString vid'
	    val stamp2  = Stamp.new()
	    val id1'    = O.Id(i, stamp1, Name.ExId name)
	    val id2'    = O.Id(i, stamp2, Name.ExId name)
	    val longid' = case longido'
			    of SOME longid' => O.LongId(i,longid',O.Lab(i,
							Label.fromString name))
			     | NONE         => O.ShortId(i, id1')
	    val pat'    = O.VarPat(i, id2')
	    val exp'    = O.VarExp(i, longid')
	    val _       = insertVal(E, vid', (i,stamp2,is))
	in
	    (case is
	       of V   => O.ValDec(i, O.VarPat(i, id2'), O.VarExp(i, longid'))
		| C k => O.ConDec(i, id2', O.SingTyp(i, longid'), k)
		| R   => O.ConDec(i, id2', O.SingTyp(i, longid'), 1)
	    ) :: acc
	end

    and trOpenDecTy (E,i,longid) (tycon', (_,stamp1,E'), acc) =
	let
	    val name    = TyCon.toString tycon'
	    val stamp2  = Stamp.new()
	    val id'     = O.Id(i, stamp2, Name.ExId name)
	    val lab'    = O.Lab(i, Label.fromString name)
	    val longid' = O.LongId(i, longid, lab')
	    val typ'    = O.ConTyp(i, longid')
	    val _       = insertTy(E, tycon', (i,stamp2,E'))
	in
	    O.TypDec(i, id', typ') :: acc
	end

    and trOpenDecStr (E,i,longid) (strid', (_,stamp1,E'), acc) =
	let
	    val name    = StrId.toString strid'
	    val stamp2  = Stamp.new()
	    val id'     = O.Id(i, stamp2, Name.ExId name)
	    val lab'    = O.Lab(i, Label.fromString name)
	    val longid' = O.LongId(i, longid, lab')
	    val mod'    = longidToMod longid'
	    val _       = insertStr(E, strid', (i,stamp2,E'))
	in
	    O.ModDec(i, id', mod') :: acc
	end

    and trOpenDecSig (E,i,longid) (sigid', (_,stamp1,E'), acc) =
	let
	    val name    = SigId.toString sigid'
	    val stamp2  = Stamp.new()
	    val id'     = O.Id(i, stamp2, Name.ExId name)
	    val lab'    = O.Lab(i, Label.fromString name)
	    val longid' = O.LongId(i, longid, lab')
	    val inf'    = O.ConInf(i, longid')
	    val _       = insertSig(E, sigid', (i,stamp2,E'))
	in
	    O.InfDec(i, id', inf') :: acc
	end



  (* Value bindings *)

    and trValBindo (E,E') valbindo = List.rev(trValBindo' (E,E',[]) valbindo)
    and trValBindo'(E,E',acc) =
	fn NONE => acc

	 | SOME(PLAINValBind(_, pat, exp, valbindo)) =>
	   let
		val i    = Source.over(infoPat pat, infoExp exp)
		val pat' = trPat (E,E') pat
		val exp' = trExp E exp
		val dec' = O.ValDec(i, pat', exp')
	   in
		trValBindo' (E,E', dec'::acc) valbindo
	   end

	| SOME(RECValBind(i, valbind)) =>
	   let
		val pats' = trRecValBindo_lhs' (E,E',[]) (SOME valbind)
		val  _    = union(E,E')
		val exps' = trRecValBindo_rhs' (E,[]) (SOME valbind)
		val decs' = ListPair.map
				(fn(pat',exp') =>
				 O.ValDec(Source.over(O.infoPat pat',
						      O.infoExp exp'),
					  pat', exp'))
				(pats',exps')
	   in
		O.RecDec(i, decs') :: acc
	   end


    and trRecValBindo_lhs' (E,E',acc) =
	fn NONE => acc

	 | SOME(PLAINValBind(i, pat, exp, valbindo)) =>
	   let
		val pat' = trPat (E,E') pat
	   in
		trRecValBindo_lhs' (E,E', pat'::acc) valbindo
	   end

	 | SOME(RECValBind(i, valbind)) =>
		trRecValBindo_lhs' (E,E',acc) (SOME valbind)


    and trRecValBindo_rhs' (E,acc) =
	fn NONE => acc

	 | SOME(PLAINValBind(i, pat, exp, valbindo)) =>
	   (* BUG: no check for admissibility *)
	   let
		val exp' = trExp E exp
	   in
		trRecValBindo_rhs' (E, exp'::acc) valbindo
	   end

	 | SOME(RECValBind(i, valbind)) =>
		trRecValBindo_rhs' (E,acc) (SOME valbind)



  (* Function bindings *)

    and trFvalBindo_lhs (E,E') fvalbindo =
	    List.rev(trFvalBindo_lhs' (E,E',[]) fvalbindo)

    and trFvalBindo_lhs'(E,E',acc) =
	fn NONE => acc
	 | SOME(FvalBind(i, fmatch, fvalbindo)) =>
	   let
		val id' = trFmatch_lhs (E,E') fmatch
	   in
		trFvalBindo_lhs' (E,E', id'::acc) fvalbindo
	   end


    and trFmatch_lhs (E,E') (Match(i, fmrule, fmatcho)) =
	   let
		val vid as VId(i',vid') = trFmrule_lhs E fmrule
		val (id',stamp)         = trVId_bind E vid
		val _ = trFmatcho_lhs (E,vid) fmatcho
		val _ = insertDisjointVal(E', vid', (i',stamp,V))
			handle CollisionVal _ =>
			       error(i', E.FvalBindDuplicate vid')
	   in
		id'
	   end

    and trFmatcho_lhs (E,vid1) =
	fn NONE => ()
	 | SOME(Match(i, fmrule, fmatcho)) =>
	   let
		val vid2 as VId(i',vid2') = trFmrule_lhs E fmrule
	   in
		if idVId vid1 = idVId vid2 then
		    trFmatcho_lhs (E,vid1) fmatcho
		else
		    error(i', E.FvalBindNameInconsistent vid2')
	   end

    and trFmrule_lhs E (Mrule(i, fpat, exp)) =
	   trFpat_lhs E fpat

    and trFpat_lhs E =
	fn fpat as (ATPATPat _ | APPPat _) =>
		trFappPat_lhs E (Infix.pat (infEnv E) fpat)
	 | ( TYPEDPat(i, fpat, _)
	   | WHENPat(i, fpat, _) )	=> trFpat_lhs E fpat
	 | ( NONPat(i,_)
	   | ASPat(i,_,_)
	   | WITHVALPat(i,_,_)
	   | WITHFUNPat(i,_,_) )	=> error(i, E.FvalBindPatInvalid)

    and trFappPat_lhs E =
	fn APPPat(i, fpat, atpat)	=> trFappPat_lhs E fpat
	 | ATPATPat(i, atpat)		=> trFatPat_lhs E atpat
	 | fpat				=> trFpat_lhs E fpat

    and trFatPat_lhs E =
	fn LONGVIDAtPat(i, _, SHORTLong(_, vid as VId(i', vid'))) =>
	   (case lookupIdStatus(E, vid')
	      of  V        => vid
	       | (R | C _) => error(i', E.FvalBindNameCon vid')
	   )

	 | ALTAtPat(i, fpats) =>
	   let
		val vids               = trFpats_lhs E fpats
		val vid as VId(_,vid') = List.hd vids
	   in
		case List.find (fn(VId(_,vid'')) => vid'<>vid'') (List.tl vids)
		  of NONE                => vid
		   | SOME(VId(i',vid2')) =>
			error(i', E.FvalBindNameInconsistent vid2')
	   end

	 | PARAtPat(i, fpat) =>
		trFpat_lhs E fpat

	 | atpat =>
		error(infoAtPat atpat, E.FvalBindNameMissing)

    and trFpats_lhs E = List.map(trFpat_lhs E)



    and trFvalBindo_rhs E fvalbindo =
	    List.rev(trFvalBindo_rhs' (E,[]) fvalbindo)

    and trFvalBindo_rhs'(E,acc) =
	fn NONE => acc
	 | SOME(FvalBind(i, fmatch, fvalbindo)) =>
	   let
		val exp' = trFmatch_rhs E fmatch
	   in
		trFvalBindo_rhs' (E, exp'::acc) fvalbindo
	   end

    and trFmatch_rhs E (Match(i, fmrule, fmatcho)) =
	   let
		val (match',arity) = trFmrule_rhs E fmrule
		val  matches'      = match' :: trFmatcho_rhs (E,arity) fmatcho
		val  i'            = O.infoMatch match'
	   in
		if arity = 1 then
		    O.FunExp(i', matches')
		else
		    let
			val ids'     = List.tabulate(arity, fn _ => inventId i)
			val exps'    = List.map(fn id' =>
						O.VarExp(Source.nowhere,
						O.ShortId(Source.nowhere, id')))
					      ids'
			val tupexp'  = tupexp(i', exps')
			val caseexp' = O.CaseExp(i', tupexp', matches')

			fun funexp    []      = caseexp'
			  | funexp(id'::ids') =
			    let
				val pat'   = O.VarPat(i, id')
				val match' = O.Match(i, pat', funexp ids')
			    in
				O.FunExp(i', [match'])
			    end
		    in
			funexp ids'
		    end
	   end

    and trFmatcho_rhs (E,arity) fmatcho =
	    List.rev(trFmatcho_rhs' (E,arity,[]) fmatcho)

    and trFmatcho_rhs' (E,arity,acc) =
	fn NONE => acc

	 | SOME(Match(i, fmrule, fmatcho)) =>
	   let
		val (match',arity') = trFmrule_rhs E fmrule
	   in
		if arity <> arity' then
		    error(infoMrule fmrule, E.FvalBindArityInconsistent)
		else
		    trFmatcho_rhs' (E, arity, match'::acc) fmatcho
	   end

    and trFmrule_rhs E (Mrule(i, fpat, exp)) =
	   let
		val  E'                = BindEnv.new()
		val (pat',arity,typs') = trFpat_rhs (E,E') fpat
		val  _                 = inheritScope(E,E')
		val  exp'              = trExp E exp
		val  _                 = deleteScope E
	   in
		( O.Match(i, pat', annexp(exp',typs')), arity )
	   end

    and trFpat_rhs (E,E') =
	fn fpat as (ATPATPat _ | APPPat _) =>
		trFappPat_rhs (E,E') (Infix.pat (infEnv E) fpat)

	 | TYPEDPat(i, fpat, ty) =>
	   let
		val (pat',arity,typs') = trFpat_rhs (E,E') fpat
		val  typ'              = trTy E ty
	   in
		( pat', arity, typ'::typs' )
	   end

	 | WHENPat(i, fpat, atexp) =>
	   let
		val  _   = insertScope E'
		val (pat',arity,typs') = trFpat_rhs (E,E') fpat
		val  _   = inheritScope(E, cloneScope E')
		val exp' = trAtExp E atexp
		val  _   = deleteScope E
		val  _   = mergeDisjointScope E' handle CollisionVal vid' =>
				errorVId(E', vid', E.PatVIdDuplicate)
	   in
		( O.GuardPat(i, pat', exp'), arity, typs' )
	   end

	 | ( NONPat(i,_) | ASPat(i,_,_)
	   | WITHVALPat(i,_,_) | WITHFUNPat(i,_,_) ) =>
		error(i, E.FvalBindPatInvalid)

    and trFappPat_rhs (E,E') =
	fn fpat as APPPat _ =>
	   let
		val pats' = trAppliedFappPat_rhs (E,E') fpat
	   in
		( tuppat(infoPat fpat, pats'), List.length pats', [] )
	   end
	 | ATPATPat(i, atpat)		=> trFatPat_rhs (E,E') atpat
	 | fpat				=> trFpat_rhs (E,E') fpat

    and trFatPat_rhs (E,E') =
	fn ALTAtPat(i, fpats) =>
	   let
		val  _                 = insertScope E'
		val (pat',arity,typs') = trFpat_rhs (E,E') (List.hd fpats)
		val  pat'aritytyps's   = trAltFpats_rhs (E,E') (List.tl fpats)
		val (pats',arities,typs'') =
			 List.foldr (fn((p,a,ts), (pl,al,tl)) =>
					(p::pl, a::al, ts@tl)
				    ) ([],[],[]) pat'aritytyps's
		val  _ = mergeDisjointScope E'
			 handle CollisionVal vid' =>
				errorVId(E', vid', E.PatVIdDuplicate)
	   in
		case List.find (fn(_,arity',_) => arity<>arity') pat'aritytyps's
		  of NONE => ( O.AltPat(i, pat'::pats'), arity, typs' @ typs'' )
		   | SOME(pat',_,_) =>
			error(O.infoPat pat', E.FvalBindArityInconsistent)
	   end

	 | PARAtPat(i, fpat)	=> trFpat_rhs (E,E') fpat
	 | LONGVIDAtPat(i,_,_)	=> error(i, E.FvalBindArityZero)
	 | fatpat		=> error(infoAtPat fatpat, E.FvalBindPatInvalid)

    and trAltFpats_rhs (E,E') = List.map(trAltFpat_rhs (E,E'))

    and trAltFpat_rhs (E,E') fpat =
	let
	    val _    = insertScope E'
	    val pat'aritytyps' = trFpat_rhs (E,E') fpat
	    val E''  = splitScope E'
	    val _    = if BindEnv.sizeScope E' = BindEnv.sizeScope E'' then ()
		       else error(infoPat fpat, E.AltPatInconsistent)
	    val _    = BindEnv.appiVals
			    (fn(vid,_) =>
				if Option.isSome(lookupVal(E'',vid)) then ()
				else error(infoPat fpat, E.AltPatInconsistent)
			    ) E'
	in
	    pat'aritytyps'
	end


    and trAppliedFpat_rhs (E,E') =
	fn fpat as (ATPATPat _ | APPPat _) =>
		trAppliedFappPat_rhs (E,E') (Infix.pat (infEnv E) fpat)
	 | fpat => error(infoPat fpat, E.FvalBindPatInvalid)

    and trAppliedFappPat_rhs (E,E') =
	fn ATPATPat(i, fatpat)	  => trAppliedFatPat_rhs (E,E') fatpat
	 | APPPat(i, fpat, atpat) => trAppliedFappPat_rhs (E,E') fpat
				     @ [trAtPat (E,E') atpat]
	 | fpat => error(infoPat fpat, E.FvalBindPatInvalid)

    and trAppliedFatPat_rhs (E,E') =
	fn LONGVIDAtPat _	=> []
	 | PARAtPat(i, fpat)	=> trAppliedFpat_rhs (E,E') fpat
	 | fatpat => error(infoAtPat fatpat, E.FvalBindPatInvalid)



  (* Type and constructor bindings *)

    and trTypBindo' (E,E',acc) =
	fn NONE => acc

	 | SOME(NEWTypBind(_, tyvarseq, tycon as TyCon(i',tycon'), typbindo)) =>
	   let
		val i           = Source.over(infoSeq tyvarseq, i')
		val (id',stamp) = trTyCon_bind E tycon
		val _           = insertScope E
		val ids'        = trTyVarSeq E tyvarseq
		val _           = deleteScope E
		val funtyp'     = funtyp(ids', O.AbsTyp(i'))
		val dec'        = O.TypDec(i, id', funtyp')
		val _           = insertDisjointTy(E', tycon',
						  (i', stamp, BindEnv.new()))
				  handle CollisionTy _ =>
				      error(i', E.TypBindDuplicate tycon')
	   in
		trTypBindo' (E,E', dec'::acc) typbindo
	   end

	 | SOME(EQUALTypBind(_, tyvarseq, tycon as TyCon(i',tycon'), ty,
								typbindo)) =>
	   let
		val i           = Source.over(infoSeq tyvarseq, infoTy ty)
		val (id',stamp) = trTyCon_bind E tycon
		val _           = insertScope E
		val ids'        = trTyVarSeq E tyvarseq
		val typ'        = trTy E ty
		val _           = deleteScope E
		val funtyp'     = funtyp(ids', typ')
		val dec'        = O.TypDec(i', id', funtyp')
		val _           = insertDisjointTy(E', tycon',
						   (i', stamp, BindEnv.new()))
				  handle CollisionTy _ =>
				      error(i', E.TypBindDuplicate tycon')
	   in
		trTypBindo' (E,E', dec'::acc) typbindo
	   end


    and trDatBindo_lhs (E,E') =
	fn NONE => ()

	 | ( SOME(CLOSEDDatBind(i, tyvarseq, tycon, _, datbindo))
	   | SOME(OPENDatBind(i, tyvarseq, tycon, datbindo)) ) =>
	   let
		val TyCon(i',tycon') = tycon
		val (id',stamp)      = trTyCon_bind E tycon
		val  _               = insertDisjointTy(E', tycon',
						(i', stamp, BindEnv.new()))
				       handle CollisionTy _ =>
					   error(i', E.DatBindDuplicate tycon')
	   in
		trDatBindo_lhs (E,E') datbindo
	   end

    and trDatBindo_rhs (E,E') datbindo =
	let
	    val (tdecs',cdecs') = trDatBindo_rhs' (E,E',[],[]) datbindo
	in
	    (List.rev tdecs', cdecs')
	end

    and trDatBindo_rhs'(E,E',acc1,acc2) =
	fn NONE => (acc1,acc2)

	 | SOME(CLOSEDDatBind(_, tyvarseq, tycon, conbind, datbindo)) =>
	   let
		val  i'           = infoConBind conbind
		val  i            = Source.over(infoSeq tyvarseq, i')
		val (id',E'')     = trTyCon E tycon	(* bound before *)
		val  _            = insertScope E
		val  ids'         = trTyVarSeq E tyvarseq
		val  i_id         = O.infoId id'
		val  contyp'      = O.ConTyp(i_id, O.ShortId(i_id, id'))
		val  typ'         = apptyp(List.map varToTyp ids', contyp')
		val (flds',decs') = trConBindo (E,E'',ids',typ') (SOME conbind)
		val  _            = deleteScope E
		val  sumtyp'      = O.SumTyp(i', O.Row(i', flds', false))
		val  dec'         = O.TypDec(i, id', funtyp(ids', sumtyp'))
		val  _            = unionDisjoint(E',E'')
				    handle CollisionVal vid' =>
				      errorVId(E'', vid', E.DatBindConDuplicate)
	   in
		trDatBindo_rhs' (E,E', dec'::acc1, decs'@acc2) datbindo
	   end

	 | SOME(OPENDatBind(_, tyvarseq, tycon, datbindo)) =>
	   let
		val  i'       = infoTyCon tycon
		val  i        = Source.over(infoSeq tyvarseq, i')
		val (id',E'') = trTyCon E tycon		(* bound before *)
		val  _        = insertScope E
		val  ids'     = trTyVarSeq E tyvarseq
		val  _        = deleteScope E
		val  funtyp'  = funtyp(ids', O.ExtTyp(i'))
		val  dec'     = O.TypDec(i, id', funtyp')
	   in
		trDatBindo_rhs' (E,E', dec'::acc1, acc2) datbindo
	   end


    and trConBindo (E,E',ids',typ') conbindo =
	let
	    val (fields',decs') = trConBindo' (E,E',ids',typ',[],[]) conbindo
	in
	    (List.rev fields', decs')
	end

    and trConBindo'(E,E',ids',typ',acc1,acc2) =
	fn NONE => (acc1,acc2)

	 | SOME(ConBind(i, _, vid as VId(i',vid'), tyo, conbindo)) =>
	   let
		val (id',stamp) = trVId_bind E vid
		val  typs'      = trTyo E tyo
		val  lab'       = O.Lab(i', Label.fromName(O.name id'))
		val  field'     = O.Field(i, lab', typs')
		val  k          = conArity typs'
		val  dec'       = O.ConDec(i, id',
					   alltyp(ids', arrtyp(typs',typ')), k)
		val  _          = insertDisjointVal(E', vid', (i', stamp, C k))
				  handle CollisionVal _ =>
				      error(i', E.ConBindDuplicate vid')
	   in
		trConBindo' (E,E',ids',typ', field'::acc1, dec'::acc2) conbindo
	   end

    and trDconBindo' (E,E',acc) =
	fn NONE => acc

	 | SOME(NEWDconBind(_, _, vid as VId(i',vid'), tyo, tyvarseq, longtycon,
								 dconbindo)) =>
	   let
		val  i          = Source.over(i', infoLong longtycon)
		val (id',stamp) = trVId_bind E vid
		val  _          = insertScope E
		val (ids',typ') = trTyVarSeqLongTyCon E (tyvarseq, longtycon)
		val  typs'      = trTyo E tyo
		val  k          = conArity typs'
		val  dec'       = O.ConDec(i, id',
					   alltyp(ids', arrtyp(typs',typ')), k)
		val  _          = deleteScope E
		val  _          = insertDisjointVal(E', vid', (i', stamp, C k))
				  handle CollisionVal _ =>
				      error(i', E.DconBindDuplicate vid')
	   in
		trDconBindo' (E,E', dec'::acc) dconbindo
	   end

	 | SOME(EQUALDconBind(_, _, vid as VId(i',vid'), _,
							longvid, dconbindo)) =>
	   let
		val  i           = Source.over(i', infoLong longvid)
		val (id',stamp)  = trVId_bind E vid
		val (longid',is) = trLongVId E longvid
		val  k           = case is
				     of C k => k
				      | R   => 1
				      | V   => error(i, E.DconBindNonCon)
		val  typ'        = O.SingTyp(O.infoLongid longid', longid')
		val  dec'        = O.ConDec(i, id', typ', k)
		val  _           = insertDisjointVal(E', vid', (i', stamp, is))
				   handle CollisionVal _ =>
				       error(i', E.DconBindDuplicate vid')
	   in
		trDconBindo' (E,E', dec'::acc) dconbindo
	   end


    and trTyo E  NONE     = []
      | trTyo E (SOME ty) = [trTy E ty]


    and trTyVarSeqLongTyCon E (tyvarseq, longtycon) =
	let
	    val (longid',_) = trLongTyCon E longtycon
	    val  typ'  = O.ConTyp(O.infoLongid longid', longid')
	    val  ids'  = trTyVarSeq E tyvarseq
	    val  typs' = List.map (fn id' => O.VarTyp(O.infoId id', id')) ids'
	in
	    ( ids', apptyp(typs', typ') )
	end


  (* Structure and signature bindings *)

    and trStrBindo' (E,E',acc) =
	fn NONE => acc

	 | SOME(StrBind(_, strid as StrId(i',strid'), strexp, strbindo)) =>
	   let
		val i           = Source.over(i', infoStrExp strexp)
		val (id',stamp) = trStrId_bind E strid
		val (mod',E'')  = trStrExp E strexp
		val  dec'       = O.ModDec(i, id', mod')
		val  _          = insertDisjointStr(E', strid', (i',stamp,E''))
				  handle CollisionStr _ =>
				      error(i', E.StrBindDuplicate strid')
	   in
		trStrBindo' (E,E', dec'::acc) strbindo
	   end


    and trSigBindo' (E,E',acc) =
	fn NONE => acc

	 | SOME(SigBind(_, sigid as SigId(i',sigid'), strpats, sigexp,
								sigbindo)) =>
	   let
		val  i          = Source.over(i', infoSigExp sigexp)
		val (id',stamp) = trSigId_bind E sigid
		val  _          = insertScope E
		val  idinfs'    = trStrPats E strpats
		val (inf',E'')  = trSigExp E sigexp
		val  _          = deleteScope E
		val  dec'       = O.InfDec(i, id', funinf(idinfs',inf'))
		val  _          = insertDisjointSig(E', sigid', (i',stamp,E''))
				  handle CollisionSig _ =>
				      error(i', E.SigBindDuplicate sigid')
	   in
		trSigBindo' (E,E', dec'::acc) sigbindo
	   end


  (* Structure expressions *)

    and trAtStrExp E =
	fn STRUCTAtStrExp(i, dec) =>
	   let
		val _     = insertScope E
		val decs' = trDec E dec
		val E'    = splitScope E
	   in
		( O.StrMod(i, decs'), E' )
	   end

	 | LONGSTRIDAtStrExp(i, longstrid) =>
	   let
		val (longid',E') = trLongStrId E longstrid
	   in
		( longidToMod longid', E' )
	   end

	 | LETAtStrExp(i, dec, strexp) =>
	   let
		val  _        = insertScope E
		val  decs'    = trDec E dec
		val (mod',E') = trStrExp E strexp
		val  _        = deleteScope E
	   in
		( O.LetMod(i, decs', mod'), E' )
	   end

	 | PARAtStrExp(i, strexp) => trStrExp E strexp

    and trStrExp E =
	fn ATSTREXPStrExp(i, atstrexp) => trAtStrExp E atstrexp

	 | APPStrExp(i, strexp, atstrexp) =>
	   let
		val (mod1',E1') = trStrExp E strexp
		val (mod2',E2') = trAtStrExp E atstrexp
	   in
		( O.AppMod(i, mod1', mod2'), E1' )
	   end

	 | TRANSStrExp(i, strexp, sigexp) =>
	   let
		val (mod',E')  = trStrExp E strexp
		val (inf',E'') = trSigExp E sigexp
	   in
		( O.AnnMod(i, mod', inf'), E'' )
	   end

	 | OPAQStrExp (i, strexp, sigexp) =>
	   let
		val (mod',E')  = trStrExp E strexp
		val (inf',E'') = trSigExp E sigexp
	   in
		( O.UpMod(i, mod', inf'), E'' )
	   end

	 | FCTStrExp(i, strpat, strexp) =>
	   let
		val  _         = insertScope E
		val (id',inf') = trStrPat E strpat
		val (mod',E')  = trStrExp E strexp
		val  _         = deleteScope E
	   in
		( O.FunMod(i, id', inf', mod'), E' )
	   end

	 | UNPACKStrExp(i, exp, sigexp) =>
	   let
		val  exp'     = trExp E exp
		val (inf',E') = trSigExp E sigexp
	   in
		( O.UnpackMod(i, exp', inf'), E' )
	   end


    and trStrPat E (StrPat(i, strid as StrId(i', strid'), sigexp)) =
	let
	    val (id',stamp) = trStrId_bind E strid
	    val (inf',E')   = trSigExp E sigexp
	    val  _          = insertStr(E, strid', (i', stamp, E'))
	in
	    (id', inf')
	end

    and trStrPats E = List.map (trStrPat E)



  (* Signatures and specifications *)

    and trAtSigExp E =
	fn ANYAtSigExp(i) =>
	   let
		val E' = BindEnv.new()
	   in
		( O.TopInf(i), E' )
	   end

	 | SIGAtSigExp(i, spec) =>
	   let
		val _      = insertScope E
		val specs' = trSpec E spec
		val E'     = splitScope E
	   in
		( O.SigInf(i, specs'), E' )
	   end

	 | LONGSIGIDAtSigExp(i, sigid) =>
	   let
		val (longid',E') = trLongSigId E sigid
	   in
		( O.ConInf(i, longid'), E' )
	   end

	 | LETAtSigExp(i, dec, sigexp) =>
	   let
		val  _        = insertScope E
		val  decs'    = trDec E dec
		val (inf',E') = trSigExp E sigexp
		val  _        = deleteScope E
	   in
		( O.LetInf(i, decs', inf'), E' )
	   end

	 | PARAtSigExp(i, sigexp) => trSigExp E sigexp


    and trSigExp E =
	fn ATSIGEXPSigExp(i, atsigexp) => trAtSigExp E atsigexp

	 | APPSigExp(i, sigexp, atstrexp) =>
	   let
		val (inf',E') = trSigExp E sigexp
		val (mod',_)  = trAtStrExp E atstrexp
	   in
		( O.AppInf(i, inf', mod'), E' )
	   end

	 | FCTSigExp(i, strpat, sigexp) =>
	   let
		val  _          = insertScope E
		val (id',inf1') = trStrPat E strpat
		val (inf2',E')  = trSigExp E sigexp
		val  _          = deleteScope E
	   in
		( O.ArrInf(i, id', inf1', inf2'), E' )
	   end

	 | WHERESigExp(i, sigexp1, sigexp2) =>
	   let
		val (inf1',E1) = trSigExp E sigexp1
		val (inf2',E2) = trSigExp E sigexp2
		val  _         = unionCompose(E1, E2)
	   in
		( O.CompInf(i, inf1', inf2'), E1 )
	   end


    and trSpec  E spec = List.rev(trSpec' (E,[]) spec)
    and trSpec'(E,acc) =
	fn VALSpec(i, valdesc) =>
		trValDesco' (E,acc) (SOME valdesc)

	 | TYPESpec(i, typdesc) =>
		trTypDesco' (E,acc) (SOME typdesc)

	 | EQTYPESpec(i, typdesc) =>
		(* UNFINISHED *)
		trTypDesco' (E,acc) (SOME typdesc)

	 | EQEQTYPESpec(i, typdesc) =>
		(* UNFINISHED *)
		trTypDesco' (E,acc) (SOME typdesc)

	 | DATATYPESpec(i, datdesc) =>
	   let
		val  _                = trDatDesco_lhs E (SOME datdesc)
		val (tspecs',cspecs') = trDatDesco_rhs E (SOME datdesc)
	   in
		cspecs' @ O.RecSpec(i, tspecs') :: acc
	   end

	 | REPLICATIONSpec(i, tycon as TyCon(i', tycon'), longtycon) =>
	   let
		val (id',stamp)  = trTyCon_bind E tycon
		val (longid',E') = trLongTyCon E longtycon
		val  longido'    = case longid'
				     of O.LongId(_,longid',_) => SOME longid'
				      | O.ShortId _           => NONE
		val  _           = insertDisjointTy(E, tycon', (i', stamp, E'))
				   handle CollisionTy _ =>
				       error(i', E.SpecTyConDuplicate tycon')
	   in
		foldiVals (trOpenSpecVal (E,i,longido'))
		 (O.TypSpec(i, id', O.ConTyp(infoLong longtycon, longid'))::acc)
		 E'
	   end

	 | CONSTRUCTORSpec(i, dcondesc) =>
		trDconDesco' (E,acc) (SOME dcondesc)

	 | STRUCTURESpec(i, strdesc) =>
		trStrDesco' (E,acc) (SOME strdesc)

	 | SIGNATURESpec(i, sigdesc) =>
		trSigDesco' (E,acc) (SOME sigdesc)

	 | INCLUDESpec(i, sigexp) =>
	   let
		val (inf',E') = trSigExp E sigexp
		val _ =
		    unionDisjoint(E,E')
		    handle CollisionInf x => error(i, E.SpecFixDuplicate x)
			 | CollisionVal x => error(i, E.SpecVIdDuplicate x)
			 | CollisionTy  x => error(i, E.SpecTyConDuplicate x)
			 | CollisionStr x => error(i, E.SpecStrIdDuplicate x)
			 | CollisionSig x => error(i, E.SpecSigIdDuplicate x)
	   in
		O.ExtSpec(i, inf') :: acc
	   end

	 | EMPTYSpec(i) =>
		acc

	 | SEQSpec(i, spec1, spec2) =>
		trSpec' (E, trSpec' (E,acc) spec1) spec2

	 | SHARINGTYPESpec(i, spec, longtycons) =>
	   let
		val specs'   = trSpec E spec
		val longids' = List.map (#1 o trLongTyCon E) longtycons
		val rspecs'  = List.rev(Sharing.shareTyp(specs', longids'))
	   in
		rspecs' @ acc
	   end

	 | SHARINGSIGNATURESpec(i, spec, longsigids) =>
	   let
		val specs'   = trSpec E spec
		val longids' = List.map (#1 o trLongSigId E) longsigids
		val rspecs'  = List.rev(Sharing.shareSig(specs', longids'))
	   in
		rspecs' @ acc
	   end

	 | SHARINGSpec(i, spec, longstrids) =>
	   let
		val specs'   = trSpec E spec
		val longids' = List.map (#1 o trLongStrId E) longstrids
		val rspecs'  = List.rev(Sharing.shareStr(specs', longids'))
	   in
		rspecs' @ acc
	   end

	 | OVERLOADSpec(i, _, vid, tyvar, ty) =>
	   (*UNFINISHED*)
		acc

	 | INSTANCESpec(i, _, vid, longtycon, longvid) =>
	   (*UNFINISHED*)
		acc

	 | INSTANCESCONSpec(i, scon, longtycon) =>
	   (*UNFINISHED*)
		acc

	 | INFIXSpec(i, n, vid as VId(i',vid')) =>
	   let
		val id'   = trVId_bind' E vid
		val fix   = Fixity.INFIX(n, Fixity.LEFT)
		val fix'  = O.Fix(i, fix)
		val spec' = O.FixSpec(i, id', fix')
		val _     = insertDisjointInf(E, vid', (i', SOME(LEFT, n)))
			    handle CollisionInf vid' =>
				   error(i', E.SpecFixDuplicate vid')
	   in
		spec' :: acc
	   end

	 | INFIXRSpec(i, n, vid as VId(i',vid')) =>
	   let
		val id'   = trVId_bind' E vid
		val fix   = Fixity.INFIX(n, Fixity.RIGHT)
		val fix'  = O.Fix(i, fix)
		val spec' = O.FixSpec(i, id', fix')
		val _     = insertDisjointInf(E, vid', (i', SOME(RIGHT, n)))
			    handle CollisionInf vid' =>
				   error(i', E.SpecFixDuplicate vid')
	   in
		spec' :: acc
	   end

	 | NONFIXSpec(i, vid as VId(i',vid')) =>
	   let
		val id'   = trVId_bind' E vid
		val fix   = Fixity.NONFIX
		val fix'  = O.Fix(i, fix)
		val spec' = O.FixSpec(i, id', fix')
		val _     = insertDisjointInf(E, vid', (i', NONE))
			    handle CollisionInf vid' =>
				   error(i', E.SpecFixDuplicate vid')
	   in
		spec' :: acc
	   end


    and trOpenSpecVal (E,i,longido') (vid', (_,stamp1,is), acc) =
	let
	    val name    = VId.toString vid'
	    val stamp2  = Stamp.new()
	    val id1'    = O.Id(i, stamp1, Name.ExId name)
	    val id2'    = O.Id(i, stamp2, Name.ExId name)
	    val longid' = case longido'
			    of SOME longid' => O.LongId(i,longid',O.Lab(i,
							Label.fromString name))
			     | NONE         => O.ShortId(i, id1')
	    val typ'    = O.SingTyp(i, longid')
	    val _       = insertDisjointVal(E, vid', (i,stamp2,is))
			  handle CollisionVal _ =>
			      error(i, E.SpecVIdDuplicate vid')
	in
	    (case is
	       of V   => O.ValSpec(i, id2', typ')
	        | C k => O.ConSpec(i, id2', typ', k)
	        | R   => O.ConSpec(i, id2', typ', 1)
	    ) :: acc
	end




  (* Descriptions *)

    and trValDesco' (E,acc) =
	fn NONE => acc

	 | SOME(NEWValDesc(_, _, vid as VId(i',vid'), ty, valdesco)) =>
	   let
		val  i          = Source.over(i', infoTy ty)
		val (id',stamp) = trVId_bind E vid
		val  _          = insertScope E
		val  ids'       = trAllTy E ty
		val  typ'       = alltyp(ids', trTy E ty)
		val  _          = deleteScope E
		val  spec'      = O.ValSpec(i, id', typ')
		val  _          = insertDisjointVal(E, vid', (i', stamp, V))
				  handle CollisionVal vid' =>
				      error(i', E.SpecVIdDuplicate vid')
	   in
		trValDesco' (E, spec'::acc) valdesco
	   end

	 | SOME(EQUALValDesc(i, _, vid as VId(i',vid'), _, longvid, valdesco))=>
	   let
		val (id',stamp)  = trVId_bind E vid
		val (longid',is) = trLongVId E longvid
		val  typ'        = O.SingTyp(O.infoLongid longid', longid')
		val  spec'       = O.ValSpec(i, id', typ')
		val  _           = insertDisjointVal(E, vid', (i', stamp, V))
				   handle CollisionVal vid' =>
				      error(i', E.SpecVIdDuplicate vid')
	   in
		trValDesco' (E, spec'::acc) valdesco
	   end


    and trTypDesco' (E,acc) =
	fn NONE => acc

	 | SOME(NEWTypDesc(_, tyvarseq, tycon as TyCon(i',tycon'), typdesco)) =>
	   let
		val i           = Source.over(infoSeq tyvarseq, i')
		val (id',stamp) = trTyCon_bind E tycon
		val _           = insertScope E
		val ids'        = trTyVarSeq E tyvarseq
		val _           = deleteScope E
		val funtyp'     = funtyp(ids', O.AbsTyp(i'))
		val spec'       = O.TypSpec(i, id', funtyp')
		val _           = insertDisjointTy(E, tycon',
						   (i', stamp, BindEnv.new()))
				  handle CollisionTy _ =>
				      error(i', E.SpecTyConDuplicate tycon')
	   in
		trTypDesco' (E, spec'::acc) typdesco
	   end

	 | SOME(EQUALTypDesc(_, tyvarseq, tycon as TyCon(i',tycon'),
							ty, typdesco)) =>
	   let
		val i           = Source.over(infoSeq tyvarseq, infoTy ty)
		val (id',stamp) = trTyCon_bind E tycon
		val _           = insertScope E
		val ids'        = trTyVarSeq E tyvarseq
		val typ'        = trTy E ty
		val _           = deleteScope E
		val funtyp'     = funtyp(ids', typ')
		val spec'       = O.TypSpec(i, id', funtyp')
		val _           = insertDisjointTy(E, tycon',
						   (i', stamp, BindEnv.new()))
				  handle CollisionTy _ =>
				      error(i', E.SpecTyConDuplicate tycon')
	   in
		trTypDesco' (E, spec'::acc) typdesco
	   end


    and trDatDesco_lhs E =
	fn NONE => ()

	 | ( SOME(CLOSEDDatDesc(i, tyvarseq, tycon, _, datdesco))
	   | SOME(OPENDatDesc(i, tyvarseq, tycon, datdesco)) ) =>
	   let
		val TyCon(i',tycon') = tycon
		val (id',stamp)      = trTyCon_bind E tycon
		val _                = insertDisjointTy(E, tycon',
						   (i', stamp, BindEnv.new()))
				       handle CollisionTy _ =>
					 error(i', E.SpecTyConDuplicate tycon')
	   in
		trDatDesco_lhs E datdesco
	   end

    and trDatDesco_rhs E datdesco =
	let
	    val (tspecs',cspecs') = trDatDesco_rhs' (E,[],[]) datdesco
	in
	    (List.rev tspecs', cspecs')
	end

    and trDatDesco_rhs' (E,acc1,acc2) =
	fn NONE => (acc1,acc2)

	 | SOME(CLOSEDDatDesc(_, tyvarseq, tycon, condesc, datdesco)) =>
	   let
		val  i'            = infoConDesc condesc
		val  i             = Source.over(infoSeq tyvarseq, i')
		val (id',E')       = trTyCon E tycon	(* bound before *)
		val  _             = insertScope E
		val  ids'          = trTyVarSeq E tyvarseq
		val  i_id          = O.infoId id'
		val  contyp'       = O.ConTyp(i_id, O.ShortId(i_id, id'))
		val  typ'          = apptyp(List.map varToTyp ids', contyp')
		val (flds',specs') = trConDesco (E,E',ids',typ') (SOME condesc)
		val  _             = deleteScope E
		val  sumtyp'       = O.SumTyp(i', O.Row(i', flds', false))
		val  spec'         = O.TypSpec(i, id', funtyp(ids', sumtyp'))
		val  _             = unionDisjoint(E,E')
				     handle CollisionVal vid' =>
					errorVId(E', vid', E.SpecVIdDuplicate)
	   in
		trDatDesco_rhs' (E, spec'::acc1, specs'@acc2) datdesco
	   end

	 | SOME(OPENDatDesc(_, tyvarseq, tycon, datdesco)) =>
	   let
		val i'       = infoTyCon tycon
		val i        = Source.over(infoSeq tyvarseq, i')
		val (id',E') = trTyCon E tycon
		val _        = insertScope E
		val ids'     = trTyVarSeq E tyvarseq
		val _        = deleteScope E
		val funtyp'  = funtyp(ids', O.ExtTyp(i'))
		val spec'    = O.TypSpec(i, id', funtyp')
	   in
		trDatDesco_rhs' (E, spec'::acc1, acc2) datdesco
	   end


    and trConDesco (E,E',ids',typ') condesco =
	let
	    val (fields',specs') = trConDesco' (E,E',ids',typ',[],[]) condesco
	in
	    (List.rev fields', specs')
	end

    and trConDesco'(E,E',ids',typ',acc1,acc2) =
	fn NONE => (acc1,acc2)

	 | SOME(ConDesc(i, _, vid as VId(i',vid'), tyo, condesco)) =>
	   let
		val (id',stamp) = trVId_bind E vid
		val  typs'      = trTyo E tyo
		val  lab'       = O.Lab(i', Label.fromName(O.name id'))
		val  field'     = O.Field(i, lab', typs')
		val  k          = conArity typs'
		val  spec'      = O.ConSpec(i, id',
					    alltyp(ids', arrtyp(typs',typ')), k)
		val  _          = insertDisjointVal(E', vid', (i', stamp, C k))
				  handle CollisionVal _ =>
				      error(i', E.ConDescDuplicate vid')
	   in
		trConDesco' (E,E',ids',typ', field'::acc1, spec'::acc2) condesco
	   end


    and trDconDesco' (E,acc) =
	fn NONE => acc

	 | SOME(NEWDconDesc(_, _, vid as VId(i',vid'), tyo, tyvarseq, longtycon,
								 dcondesco)) =>
	   let
		val  i          = Source.over(i', infoLong longtycon)
		val (id',stamp) = trVId_bind E vid
		val  _          = insertScope E
		val (ids',typ') = trTyVarSeqLongTyCon E (tyvarseq, longtycon)
		val  typs'      = trTyo E tyo
		val  _          = deleteScope E
		val  k          = conArity typs'
		val  spec'      = O.ConSpec(i', id',
					    alltyp(ids', arrtyp(typs',typ')), k)
		val  _          = insertDisjointVal(E, vid', (i', stamp, C k))
				  handle CollisionVal _ =>
				      error(i', E.SpecVIdDuplicate vid')
	   in
		trDconDesco' (E, spec'::acc) dcondesco
	   end

	 | SOME(EQUALDconDesc(_, _, vid as VId(i',vid'), _, longvid,
								dcondesco)) =>
	   let
		val  i           = Source.over(i', infoLong longvid)
		val (id',stamp)  = trVId_bind E vid
		val (longid',is) = trLongVId E longvid
		val  k           = case is
				     of C k => k
				      | R   => 1
				      | V   => error(i, E.DconDescNonCon)
		val  typ'        = O.SingTyp(O.infoLongid longid', longid')
		val  spec'       = O.ConSpec(i', id', typ', k)
		val  _           = insertDisjointVal(E, vid', (i', stamp, is))
				   handle CollisionVal _ =>
				       error(i', E.SpecVIdDuplicate vid')
	   in
		trDconDesco' (E, spec'::acc) dcondesco
	   end



    and trStrDesco' (E,acc) =
	fn NONE => acc

	 | SOME(NEWStrDesc(_, strid as StrId(i',strid'), sigexp, strdesco)) =>
	   let
		val  i          = Source.over(i', infoSigExp sigexp)
		val (id',stamp) = trStrId_bind E strid
		val (inf',E')   = trSigExp E sigexp
		val  spec'      = O.ModSpec(i, id', inf')
		val  _          = insertDisjointStr(E, strid', (i', stamp, E'))
				  handle CollisionStr strid' =>
				      error(i', E.SpecStrIdDuplicate strid')
	   in
		trStrDesco' (E, spec'::acc) strdesco
	   end

	 | SOME(EQUALStrDesc(_, strid as StrId(i',strid'), sigexpo, longstrid,
								strdesco)) =>
	   let
		val  i           = Source.over(i', infoLong longstrid)
		val (id',stamp)  = trStrId_bind E strid
		val (longid',E') = trLongStrId E longstrid
		val  mod'        = longidToMod longid'
		val (mod'',E'')  = case sigexpo
				     of NONE => (mod',E')
				      | SOME sigexp =>
					let
					    val (inf',E'') = trSigExp E sigexp
					    val i''   = Source.over(
							  infoSigExp sigexp,
							  O.infoLongid longid')
					    val mod'' = O.AnnMod(i'', mod',inf')
					in
					    (mod'',E'')
					end
		val  inf'        = O.SingInf(O.infoMod mod'', mod'')
		val  spec'       = O.ModSpec(i, id', inf')
		val  _           = insertDisjointStr(E, strid', (i', stamp, E''))
				   handle CollisionStr strid' =>
				       error(i', E.SpecStrIdDuplicate strid')
	   in
		trStrDesco' (E, spec'::acc) strdesco
	   end



    and trSigDesco' (E,acc) =
	fn NONE => acc

	 | SOME(NEWSigDesc(_, sigid as SigId(i',sigid'), strpats, sigdesco)) =>
	   let
		val (id',stamp) = trSigId_bind E sigid
		val  _          = insertScope E
		val  idinfs'    = trStrPats E strpats
		val  inf'       = funinf(idinfs', O.AbsInf(i'))
		val  _          = deleteScope E
		val  spec'      = O.InfSpec(i', id', inf')
		val  _          = insertDisjointSig(E, sigid',
						    (i', stamp, BindEnv.new()))
				  handle CollisionSig _ =>
				      error(i', E.SpecSigIdDuplicate sigid')
	   in
		trSigDesco' (E, spec'::acc) sigdesco
	   end

	 | SOME(EQUALSigDesc(_, sigid as SigId(i',sigid'), strpats, sigexp,
								sigdesco)) =>
	   let
		val  i          = Source.over(i', infoSigExp sigexp)
		val (id',stamp) = trSigId_bind E sigid
		val  _          = insertScope E
		val  idinfs'    = trStrPats E strpats
		val (inf',E')   = trSigExp E sigexp
		val  inf''      = funinf(idinfs', inf')
		val  _          = deleteScope E
		val  spec'      = O.InfSpec(i', id', inf'')
		val  _          = insertDisjointSig(E, sigid', (i', stamp, E'))
				  handle CollisionSig _ =>
				      error(i', E.SpecSigIdDuplicate sigid')
	   in
		trSigDesco' (E, spec'::acc) sigdesco
	   end



  (* Imports *)

    and trImp (E,E') imp = List.rev(trImp' (E,E',[]) imp)
    and trImp'(E,E',acc) =
	fn VALImp(i, valitem) =>
		trValItemo' (E,E',acc) (SOME valitem)

	 | TYPEImp(i, typitem) =>
		trTypItemo' (E,E',acc) (SOME typitem)

	 | DATATYPEImp(i, datitem) =>
	   let
		val   _             = trDatItemo_lhs (E,E') (SOME datitem)
		val (timps',cimps') = trDatItemo_rhs (E,E') (SOME datitem)
	   in
		cimps' @ O.RecImp(i, timps') :: acc
	   end

	 | CONSTRUCTORImp(i, dconitem) =>
		trDconItemo' (E,E',acc) (SOME dconitem)

	 | STRUCTUREImp(i, stritem) =>
		trStrItemo' (E,E',acc) (SOME stritem)

	 | SIGNATUREImp(i, sigitem) =>
		trSigItemo' (E,E',acc) (SOME sigitem)

	 | EMPTYImp(i) =>
		acc

	 | SEQImp(i, imp1, imp2) =>
		trImp' (E,E', trImp' (E,E',acc) imp1) imp2


    and trOpenImpVal (E,i) (vid', (_,_,is), acc) =
	let
	    val name  = VId.toString vid'
	    val stamp = Stamp.new()
	    val id'   = O.Id(i, stamp, Name.ExId name)
	    val _     = insertDisjointVal(E, vid', (i,stamp,is))
			handle CollisionVal _ =>
			      error(i, E.ImpVIdDuplicate vid')
	in
	    (case is
	       of V   => O.ValImp(i, id', O.NoDesc(i))
	        | C k => O.ConImp(i, id', O.NoDesc(i), k)
	        | R   => O.ConImp(i, id', O.NoDesc(i), 1)
	    ) :: acc
	end



  (* Items *)

    and trValItemo' (E,E',acc) =
	fn NONE => acc

	 | SOME(PLAINValItem(_, _, vid as VId(i',vid'), valitemo)) =>
	   let
		val (id',stamp) = trVId_bind E vid
		val  imp'       = O.ValImp(i', id', O.NoDesc(i'))
		val  _          = if isSome(lookupVal(E', vid')) then () else
					error(i', E.ValItemUnbound vid')
		val  _          = insertDisjointVal(E, vid', (i', stamp, V))
				  handle CollisionVal vid' =>
					error(i', E.ImpVIdDuplicate vid')
	   in
		trValItemo' (E,E', imp'::acc) valitemo
	   end

	 | SOME(DESCValItem(_, _, vid as VId(i',vid'), ty, valitemo)) =>
	   let
		val  i          = Source.over(i', infoTy ty)
		val (id',stamp) = trVId_bind E vid
		val  _          = insertScope E
		val  ids'       = trAllTy E ty
		val  typ'       = alltyp(ids', trTy E ty)
		val  _          = deleteScope E
		val  desc'      = O.SomeDesc(O.infoTyp typ', typ')
		val  imp'       = O.ValImp(i, id', desc')
		val  _          = if isSome(lookupVal(E', vid')) then () else
					error(i', E.ValItemUnbound vid')
		val  _          = insertDisjointVal(E, vid', (i', stamp, V))
				  handle CollisionVal vid' =>
					error(i', E.ImpVIdDuplicate vid')
	   in
		trValItemo' (E,E', imp'::acc) valitemo
	   end


    and trTypItemo' (E,E',acc) =
	fn NONE => acc

	 | SOME(PLAINTypItem(_, tycon as TyCon(i',tycon'), typitemo)) =>
	   let
		val (id',stamp) = trTyCon_bind E tycon
		val  imp'       = O.TypImp(i', id', O.NoDesc(i'))
		val  E''        = BindEnv.new()
		val  _          = if isSome(lookupTy(E', tycon')) then () else
					error(i', E.TypItemUnbound tycon')
		val  _          = insertDisjointTy(E, tycon', (i', stamp, E''))
				  handle CollisionTy _ =>
					error(i', E.ImpTyConDuplicate tycon')
	   in
		trTypItemo' (E,E', imp'::acc) typitemo
	   end

	 | SOME(DESCTypItem(_, tyvarseq, tycon as TyCon(i',tycon'), typitemo)) =>
	   let
		val i           = Source.over(infoSeq tyvarseq, i')
		val (id',stamp) = trTyCon_bind E tycon
		val _           = insertScope E
		val ids'        = trTyVarSeq E tyvarseq
		val _           = deleteScope E
		val funtyp'     = funtyp(ids', O.AbsTyp(i'))
		val desc'       = O.SomeDesc(O.infoTyp funtyp', funtyp')
		val imp'        = O.TypImp(i, id', desc')
		val  E''        = BindEnv.new()
		val _           = if isSome(lookupTy(E', tycon')) then () else
					error(i', E.TypItemUnbound tycon')
		val _           = insertDisjointTy(E, tycon', (i', stamp, E''))
				  handle CollisionTy _ =>
					error(i', E.SpecTyConDuplicate tycon')
	   in
		trTypItemo' (E,E', imp'::acc) typitemo
	   end


    and trDatItemo_lhs (E,E') =
	fn NONE => ()

	 | ( SOME(PLAINDatItem(i, tycon, datitemo))
	   | SOME(DESCDatItem(i, _, tycon, _, datitemo)) ) =>
	   let
		val TyCon(i',tycon') = tycon
		val (id',stamp)      = trTyCon_bind E tycon
		val E''              = BindEnv.new()
		val _                = insertDisjointTy(E,tycon',(i',stamp,E''))
				       handle CollisionTy _ =>
					 error(i', E.ImpTyConDuplicate tycon')
	   in
		trDatItemo_lhs (E,E') datitemo
	   end

    and trDatItemo_rhs (E,E') datitemo =
	let
	    val (timps',cimps') = trDatItemo_rhs' (E,E',[],[]) datitemo
	in
	    (List.rev timps', cimps')
	end

    and trDatItemo_rhs' (E,E',acc1, acc2) =
	fn NONE => (acc1,acc2)

	 | SOME(PLAINDatItem(i, tycon as TyCon(i', tycon'), datitemo)) =>
	   let
		val (id',E'') = trTyCon E tycon
		val  E'''     = case lookupTy(E', tycon')
				  of SOME(_,_,E''') => E'''
				   | NONE => error(i', E.DatItemUnbound tycon')
		val  _        = unionDisjoint(E'',E''')
	   in
		trDatItemo_rhs' (E,E', O.TypImp(i, id', O.NoDesc(i))::acc1,
				       foldiVals (trOpenImpVal (E,i)) acc2 E'')
				datitemo
	   end

	 | SOME(DESCDatItem(_, tyvarseq, tycon as TyCon(_,tycon'), conitem,
								   datitemo)) =>
	   let
		val  i'           = infoConItem conitem
		val  i            = Source.over(infoSeq tyvarseq, i')
		val (id',E'')     = trTyCon E tycon
		val  _            = insertScope E
		val  ids'         = trTyVarSeq E tyvarseq
		val  i_id         = O.infoId id'
		val  contyp'      = O.ConTyp(i_id, O.ShortId(i_id, id'))
		val  typ'         = apptyp(List.map varToTyp ids', contyp')
		val (flds',imps') = trConItemo (E,E'',ids',typ') (SOME conitem)
		val  _            = deleteScope E
		val  sumtyp'      = O.SumTyp(i', O.Row(i', flds', false))
		val  desc'        = O.SomeDesc(i', funtyp(ids', sumtyp'))
		val  imp'         = O.TypImp(i, id', desc')
		val  _            = if isSome(lookupTy(E', tycon')) then () else
					error(i', E.TypItemUnbound tycon')
		val  _            = unionDisjoint(E,E'')
				    handle CollisionVal vid' =>
					errorVId(E'', vid', E.ImpVIdDuplicate)
	   in
		trDatItemo_rhs' (E,E', imp'::acc1, imps'@acc2) datitemo
	   end


    and trConItemo (E,E',ids',typ') conitemo =
	let
	    val (fields',imps') = trConItemo' (E,E',ids',typ',[],[]) conitemo
	in
	    (List.rev fields', imps')
	end

    and trConItemo'(E,E',ids',typ',acc1,acc2) =
	fn NONE => (acc1,acc2)

	 | SOME(ConItem(i, _, vid as VId(i',vid'), tyo, conitemo)) =>
	   let
		val (id',stamp) = trVId_bind E vid
		val  typs'      = trTyo E tyo
		val  lab'       = O.Lab(i', Label.fromName(O.name id'))
		val  field'     = O.Field(i, lab', typs')
		val  k          = conArity typs'
		val  desc'      = O.SomeDesc(i',alltyp(ids',arrtyp(typs',typ')))
		val  imp'       = O.ConImp(i, id', desc', k)
		val  _          = case lookupVal(E', vid')
				    of SOME(_,_,(C _ | R)) => ()
				     | SOME(_,_,V) =>
					error(i', E.ConItemNonCon vid')
				     | NONE => error(i', E.ConItemUnbound vid')
		val  _          = insertDisjointVal(E', vid', (i', stamp, C k))
				  handle CollisionVal _ =>
					error(i', E.ConItemDuplicate vid')
	   in
		trConItemo' (E,E',ids',typ', field'::acc1, imp'::acc2) conitemo
	   end


    and trDconItemo' (E,E',acc) =
	fn NONE => acc

	 | SOME(PLAINDconItem(_, _, vid as VId(i',vid'), dconitemo)) =>
	   let
		val (id',stamp) = trVId_bind E vid
		val  k          = case lookupVal(E', vid')
				    of SOME(_,_,C k) => k
				     | SOME(_,_,R)   => 1
				     | SOME(_,_,V)   =>
					error(i', E.DconItemNonCon vid')
				     | NONE =>
					error(i', E.DconItemUnbound vid')
		val  imp'       = O.ConImp(i', id', O.NoDesc(i'), k)
		val  _          = insertDisjointVal(E, vid', (i', stamp, C k))
				  handle CollisionVal _ =>
					error(i', E.ImpVIdDuplicate vid')
	   in
		trDconItemo' (E,E', imp'::acc) dconitemo
	   end

	 | SOME(DESCDconItem(_, _, vid as VId(i',vid'), tyo, tyvarseq,longtycon,
								 dconitemo)) =>
	   let
		val  i          = Source.over(i', infoLong longtycon)
		val (id',stamp) = trVId_bind E vid
		val  _          = insertScope E
		val (ids',typ') = trTyVarSeqLongTyCon E (tyvarseq, longtycon)
		val  typs'      = trTyo E tyo
		val  _          = deleteScope E
		val  k          = conArity typs'
		val  desc'      = O.SomeDesc(i, alltyp(ids',arrtyp(typs',typ')))
		val  imp'       = O.ConImp(i', id', desc', k)
		val  _          = case lookupVal(E', vid')
				    of SOME(_,_,(C _ | R)) => ()
				     | SOME(_,_,V) =>
					error(i', E.DconItemNonCon vid')
				     | NONE => error(i', E.DconItemUnbound vid')
		val  _          = insertDisjointVal(E, vid', (i', stamp, C k))
				  handle CollisionVal _ =>
					error(i', E.ImpVIdDuplicate vid')
	   in
		trDconItemo' (E,E', imp'::acc) dconitemo
	   end



    and trStrItemo' (E,E',acc) =
	fn NONE => acc

	 | SOME(PLAINStrItem(_, strid as StrId(i',strid'), stritemo)) =>
	   let
		val (id',stamp) = trStrId_bind E strid
		val  imp'       = O.ModImp(i', id', O.NoDesc(i'))
		val  E''        = case lookupStr(E', strid')
				    of SOME(_,_,E'') => E''
				     | NONE => error(i',E.StrItemUnbound strid')
		val  _          = insertDisjointStr(E, strid', (i', stamp, E''))
				  handle CollisionStr strid' =>
				      error(i', E.ImpStrIdDuplicate strid')
	   in
		trStrItemo' (E,E', imp'::acc) stritemo
	   end

	 | SOME(DESCStrItem(_, strid as StrId(i',strid'), sigexp, stritemo)) =>
	   let
		val  i          = Source.over(i', infoSigExp sigexp)
		val (id',stamp) = trStrId_bind E strid
		val (inf',E'')  = trSigExp E sigexp
		val  desc'      = O.SomeDesc(O.infoInf inf', inf')
		val  imp'       = O.ModImp(i, id', desc')
		val  _          = if isSome(lookupStr(E', strid')) then () else
					error(i', E.StrItemUnbound strid')
		val  _          = insertDisjointStr(E, strid', (i', stamp, E''))
				  handle CollisionStr strid' =>
					error(i', E.ImpStrIdDuplicate strid')
	   in
		trStrItemo' (E,E', imp'::acc) stritemo
	   end



    and trSigItemo' (E,E',acc) =
	fn NONE => acc

	 | SOME(PLAINSigItem(_, sigid as SigId(i',sigid'), sigitemo)) =>
	   let
		val (id',stamp) = trSigId_bind E sigid
		val  imp'       = O.InfImp(i', id', O.NoDesc(i'))
		val  E''        = case lookupSig(E', sigid')
				    of SOME(_,_,E'') => E''
				     | NONE => error(i',E.SigItemUnbound sigid')
		val  _          = insertDisjointSig(E, sigid', (i', stamp, E''))
				  handle CollisionSig _ =>
				      error(i', E.ImpSigIdDuplicate sigid')
	   in
		trSigItemo' (E,E', imp'::acc) sigitemo
	   end

	 | SOME(DESCSigItem(_, sigid as SigId(i',sigid'), strpats, sigitemo)) =>
	   let
		val (id',stamp) = trSigId_bind E sigid
		val  _          = insertScope E
		val  idinfs'    = trStrPats E strpats
		val  inf'       = funinf(idinfs', O.AbsInf(i'))
		val  _          = deleteScope E
		val  desc'      = O.SomeDesc(O.infoInf inf', inf')
		val  imp'       = O.InfImp(i', id', desc')
		val  E''        = case lookupSig(E', sigid')
				    of SOME(_,_,E'') => E''
				     | NONE => error(i',E.SigItemUnbound sigid')
		val  _          = insertDisjointSig(E, sigid', (i', stamp, E''))
				  handle CollisionSig _ =>
				      error(i', E.ImpSigIdDuplicate sigid')
	   in
		trSigItemo' (E,E', imp'::acc) sigitemo
	   end



  (* Announcements *)

    and trAnn  E ann  = List.rev(trAnn' (E,[]) ann)
    and trAnn'(E,acc) =
	fn IMPORTAnn(i, imp, s) =>
	   let
		val url   = Url.fromString s
		(*UNFINISHED: extract bind env from component*)
		val E'    = BindEnv.new()
		val _     = insertScope E
		val imps' = trImp (E,E') imp
		val _     = mergeScope E
	   in
		O.ImpAnn(i, imps', url) :: acc
	   end

	 | PREBOUNDAnn(i, strid as StrId(i',strid')) =>
	   let
		val  _           = trStrId_bind E strid
		val (_,stamp,E') = prebound E
		val  _           = insertStr(E, strid', (i',stamp,E'))
	   in
		acc
	   end

	 | EMPTYAnn(i) =>
		acc

	 | SEQAnn(i, ann1, ann2) =>
		trAnn' (E, trAnn' (E,acc) ann1) ann2


  (* Programs and components *)

    fun trProgramo  E programo = List.rev(trProgramo' (E,[]) programo)
    and trProgramo'(E,acc) =
	fn NONE => acc

	 | SOME(Program(i, dec, programo)) =>
	   let
		val acc' = trDec' (E,acc) dec
	   in
		trProgramo' (E,acc') programo
	   end


    fun trComponent E (Component(i, ann, programo)) =
	let
	    val anns' = trAnn E ann
	    val decs' = trProgramo E programo
	in
	    O.Comp(i, anns', decs')
	end


    val translate = trComponent

  end
(* src # 112 ../frontend-sml/DERIVED_FORMS.sig *)
(*
 * Standard ML derived forms
 *
 * Definition, Appendix A
 *
 * Extensions and modifications:
 *   - recursive expressions:
 *	rec pat => exp     ==>     let val rec x as pat = exp in x end
 *     where x is a fresh identifier.
 *   - exception declarations have been made a derived form:
 *	exception exbind          ==>  con exbind'
 *	vid <of ty> <and exbind>  ==>  vid <of ty> : exn <and exbind'>
 *   - abstype has been made a derived form:
 *	abstype datbind <withtype tybind> with dec end
 *	  ==>
 *	<type typbind> local datatype datbind in type typbind' dec end
 *     where typbind' contains a binding t = t for each tycon t bound in
 *     datbind. Note that this results in a different treatment of equality.
 *   - include takes longsigids:
 *	include longsigid_1 ... longsigid_n
 *	==>
 *	include longsigid_1 ; ... ; include longsigid_n
 *   - derived forms for primitive declarations similar to specifications:
 *   - where constraints have been made a derived form of intersection:
 *	sigexp where type tyvarseq strid_1....strid_n.tycon = ty
 *	==>
 *      sigexp where sig structure strid_1 :
 *			...
 *			   sig structure strid_n :
 *			      sig type tyvarseq tycon = ty end
 *			   end
 *			...
 *		     end
 *
 *	sigexp where strid_1....strid_n.strid = longstrid
 *	==>
 *      sigexp where sig structure strid_1 :
 *			...
 *			   sig structure strid_n :
 *			      sig structure strid = longstrid end
 *			   end
 *			...
 *		     end
 *
 * We did NOT introduce a sharing signature ... and signature ... derived form
 * similar to types, because we consider that one completely broken.
 *
 * Notes:
 * - Two phrases named Fmatch and Fmrule have been added to factorize FvalBind.
 * - A phrase named TyReaDesc has been added to factorize type
 *   realisation signature expressions.
 *)


signature DERIVED_FORMS =
  sig

    (* Import *)

    structure Grammar: INPUT_GRAMMAR = InputGrammar

    type Info      = Grammar.Info

    type Lab       = Grammar.Lab
    type VId       = Grammar.VId
    type StrId     = Grammar.StrId
    type LongVId   = Grammar.LongVId
    type LongTyCon = Grammar.LongTyCon
    type LongStrId = Grammar.LongStrId
    type LongSigId = Grammar.LongSigId

    type Op        = Grammar.Op
    type AtExp     = Grammar.AtExp
    type AppExp    = Grammar.Exp
    type InfExp    = Grammar.Exp
    type Exp       = Grammar.Exp
    type ExpRow    = Grammar.ExpRow
    type Match     = Grammar.Match
    type Mrule     = Grammar.Mrule
    type Dec       = Grammar.Dec
    type ValBind   = Grammar.ValBind
    type FvalBind  = Grammar.FvalBind
    type ExBind    = Grammar.DconBind
    type Fmatch    = Grammar.Match
    type Fmrule    = Grammar.Mrule
    type Fpat      = Grammar.Pat
    type TypBind   = Grammar.TypBind
    type DatBind   = Grammar.DatBind
    type AtPat     = Grammar.AtPat
    type PatRow    = Grammar.PatRow
    type Pat       = Grammar.Pat
    type Ty        = Grammar.Ty
    type TyVarSeq  = Grammar.TyVarSeq
    type AtStrExp  = Grammar.AtStrExp
    type AppStrExp = Grammar.StrExp
    type StrExp    = Grammar.StrExp
    type StrPat    = Grammar.StrPat
    type StrBind   = Grammar.StrBind
    type AppSigExp = Grammar.SigExp
    type SigExp    = Grammar.SigExp
    type Spec      = Grammar.Spec
    type ValDesc   = Grammar.ValDesc
    type TypDesc   = Grammar.TypDesc
    type DatDesc   = Grammar.DatDesc
    type ExDesc    = Grammar.DconDesc
    type Imp       = Grammar.Imp
    type ValItem   = Grammar.ValItem
    type TypItem   = Grammar.TypItem
    type DatItem   = Grammar.DatItem
    type ExItem    = Grammar.DconItem
    type FunBind
    type FunDesc
    type FunItem
    type Rea
    type Program   = Grammar.Program

    (* Expressions *)

    val UNITAtExp:   Info                                      -> AtExp
    val TUPLEAtExp:  Info * Exp list                           -> AtExp
    val HASHAtExp:   Info * Lab                                -> AtExp
    val CASEExp:     Info * Exp * Match                        -> Exp
    val IFExp:       Info * Exp * Exp * Exp                    -> Exp
    val ANDALSOExp:  Info * Exp * Exp                          -> Exp
    val ORELSEExp:   Info * Exp * Exp                          -> Exp
    val SEQAtExp:    Info * Exp list                           -> AtExp
    val LETAtExp:    Info * Dec * Exp list                     -> AtExp
    val WHILEExp:    Info * Exp * Exp                          -> Exp
    val LISTAtExp:   Info * Exp list                           -> AtExp
    val RECExp:      Info * Pat * Exp                          -> Exp

    val VIDExpRow:   Info * VId * Ty option * ExpRow option    -> ExpRow

    (* Patterns *)

    val UNITAtPat:   Info                                      -> AtPat
    val TUPLEAtPat:  Info * Pat list                           -> AtPat
    val LISTAtPat:   Info * Pat list                           -> AtPat

    val VIDPatRow:   Info * VId * Ty option * Pat option * PatRow option
                                                               -> PatRow
    val WITHFUNPat:  Info * Pat * FvalBind                     -> Pat

    (* Types *)

    val TUPLETy:     Info * Ty list                            -> Ty

    (* Bindings *)

    val FvalBind:    Info * Fmatch * FvalBind option           -> FvalBind
    val Fmatch:      Info * Fmrule * Fmatch option             -> Fmatch
    val Fmrule:      Info * Fpat * Exp                         -> Fmrule

    (* Declarations *)

    val FUNDec:		Info * TyVarSeq * FvalBind		-> Dec
    val DATATYPEDec:	Info * DatBind * TypBind option		-> Dec
    val ABSTYPEDec:	Info * DatBind * TypBind option * Dec	-> Dec
    val EXCEPTIONDec:	Info * ExBind				-> Dec
    val FUNCTORDec:     Info * FunBind                          -> Dec
    val OPENMULTIDec:	Info * LongStrId list			-> Dec
    val INFIXMULTIDec:	Info * int option * VId list		-> Dec
    val INFIXRMULTIDec:	Info * int option * VId list		-> Dec
    val NONFIXMULTIDec:	Info * VId list				-> Dec

    val NEWExBind:    Info * Op * VId * Ty option * ExBind option    -> ExBind
    val EQUALExBind:  Info * Op * VId * Op * LongVId * ExBind option -> ExBind

    (* Structure bindings *)

    val TRANSStrBind:     Info * StrId * SigExp option * StrExp
			       * StrBind option                    -> StrBind
    val OPAQStrBind:      Info * StrId * SigExp * StrExp
			       * StrBind option                    -> StrBind
    val WILDCARDStrBind:  Info * SigExp option * StrExp
			       * StrBind option                    -> StrBind

    (* Structure expressions *)

    val DECAtStrExp:      Info * Dec -> AtStrExp
    val FCTStrExp:        Info * StrPat * StrExp -> StrExp

    val STRIDStrPat:      Info * StrId * SigExp -> StrPat
    val WILDCARDStrPat:   Info * SigExp         -> StrPat
    val SPECStrPat:       Info * Spec           -> StrPat

    (* Functor bindings *)

    val TRANSFunBind:     Info * StrId * StrPat list * SigExp option
			       * StrExp * FunBind option           -> FunBind
    val OPAQFunBind:      Info * StrId * StrPat list * SigExp
			       * StrExp * FunBind option           -> FunBind

    (* Specifications *)

    val FUNSpec:          Info * ValDesc                           -> Spec
    val DATATYPESpec:     Info * DatDesc * TypDesc option          -> Spec
    val EXCEPTIONSpec:    Info * ExDesc                            -> Spec
    val FUNCTORSpec:      Info * FunDesc                           -> Spec
    val SHARINGSpec:      Info * Spec * LongStrId list             -> Spec
    val INCLUDEMULTISpec: Info * LongSigId list                    -> Spec
    val INFIXMULTISpec:   Info * int option * VId list             -> Spec
    val INFIXRMULTISpec:  Info * int option * VId list             -> Spec
    val NONFIXMULTISpec:  Info * VId list                          -> Spec

    val NEWExDesc:        Info * Op * VId * Ty option * ExDesc option -> ExDesc
    val EQUALExDesc:      Info * Op * VId * Op * LongVId
						      * ExDesc option -> ExDesc

    val FunDesc:          Info * StrId * StrPat list * SigExp * FunDesc option
								   -> FunDesc

    (* Signature expressions *)

    val WHEREREASigExp:   Info * SigExp * Rea                      -> SigExp
    val WHERELONGSTRIDSigExp:
			  Info * SigExp * LongStrId * LongStrId    -> SigExp

    val VALRea:           Info * Op * LongVId * Op * LongVId * Rea option -> Rea
    val FUNRea:           Info * Op * LongVId * Op * LongVId * Rea option -> Rea
    val CONSTRUCTORRea:   Info * Op * LongVId * Op * LongVId * Rea option -> Rea
    val EXCEPTIONRea:     Info * Op * LongVId * Op * LongVId * Rea option -> Rea
    val TYPERea:          Info * TyVarSeq * LongTyCon * Ty * Rea option   -> Rea
    val STRUCTURERea:     Info * LongStrId * SigExp option * LongStrId
							   * Rea option   -> Rea
    val FUNCTORRea:       Info * LongStrId * SigExp option * LongStrId
							   * Rea option   -> Rea
    val SIGNATURERea:     Info * LongSigId * StrPat list * AppSigExp
							 * Rea option     -> Rea

    (* Imports *)

    val FUNImp:           Info * ValItem                           -> Imp
    val EXCEPTIONImp:     Info * ExItem                            -> Imp
    val FUNCTORImp:       Info * FunItem                           -> Imp

    val PLAINExItem:      Info * Op * VId * ExItem option          -> ExItem
    val DESCExItem:       Info * Op * VId * Ty * ExItem option     -> ExItem

    val PLAINFunItem:     Info * StrId * FunItem option            -> FunItem
    val DESCFunItem:      Info * StrId * StrPat list * SigExp * FunItem option
								   -> FunItem

    (* Programs *)

    val DECProgram:       Info * Dec * Program option -> Program
    val EXPProgram:       Info * Exp * Program option -> Program

  end
(* src # 113 ../frontend-sml/Parser.grm.sig *)
signature Parser_TOKENS =
sig
type ('a,'b) token
type svalue
val ETYVAR: (string) *  'a * 'a -> (svalue,'a) token
val TYVAR: (string) *  'a * 'a -> (svalue,'a) token
val STAR:  'a * 'a -> (svalue,'a) token
val SYMBOL: (string) *  'a * 'a -> (svalue,'a) token
val ALPHA: (string) *  'a * 'a -> (svalue,'a) token
val CHAR: (WideChar.char) *  'a * 'a -> (svalue,'a) token
val STRING: (WideString.string) *  'a * 'a -> (svalue,'a) token
val REAL: (LargeReal.real) *  'a * 'a -> (svalue,'a) token
val WORD: (LargeWord.word) *  'a * 'a -> (svalue,'a) token
val INT: (LargeInt.int) *  'a * 'a -> (svalue,'a) token
val NUMERIC: (LargeInt.int) *  'a * 'a -> (svalue,'a) token
val DIGIT: (int) *  'a * 'a -> (svalue,'a) token
val ZERO:  'a * 'a -> (svalue,'a) token
val COLONGREATER:  'a * 'a -> (svalue,'a) token
val WHERE:  'a * 'a -> (svalue,'a) token
val STRUCTURE:  'a * 'a -> (svalue,'a) token
val STRUCT:  'a * 'a -> (svalue,'a) token
val SIGNATURE:  'a * 'a -> (svalue,'a) token
val SIG:  'a * 'a -> (svalue,'a) token
val SHARING:  'a * 'a -> (svalue,'a) token
val INCLUDE:  'a * 'a -> (svalue,'a) token
val FUNCTOR:  'a * 'a -> (svalue,'a) token
val EQTYPE:  'a * 'a -> (svalue,'a) token
val EQEQTYPE:  'a * 'a -> (svalue,'a) token
val PREBOUND:  'a * 'a -> (svalue,'a) token
val INSTANCE:  'a * 'a -> (svalue,'a) token
val OVERLOAD:  'a * 'a -> (svalue,'a) token
val PRIMITIVE:  'a * 'a -> (svalue,'a) token
val FROM:  'a * 'a -> (svalue,'a) token
val IMPORT:  'a * 'a -> (svalue,'a) token
val UNPACK:  'a * 'a -> (svalue,'a) token
val PACK:  'a * 'a -> (svalue,'a) token
val FCT:  'a * 'a -> (svalue,'a) token
val ANY:  'a * 'a -> (svalue,'a) token
val HASHBRACK:  'a * 'a -> (svalue,'a) token
val DOT:  'a * 'a -> (svalue,'a) token
val WITHVAL:  'a * 'a -> (svalue,'a) token
val WITHFUN:  'a * 'a -> (svalue,'a) token
val NON:  'a * 'a -> (svalue,'a) token
val CONSTRUCTOR:  'a * 'a -> (svalue,'a) token
val HASH:  'a * 'a -> (svalue,'a) token
val ARROW:  'a * 'a -> (svalue,'a) token
val DARROW:  'a * 'a -> (svalue,'a) token
val EQUALS:  'a * 'a -> (svalue,'a) token
val BAR:  'a * 'a -> (svalue,'a) token
val UNDERBAR:  'a * 'a -> (svalue,'a) token
val DOTS:  'a * 'a -> (svalue,'a) token
val SEMICOLON:  'a * 'a -> (svalue,'a) token
val COLON:  'a * 'a -> (svalue,'a) token
val COMMA:  'a * 'a -> (svalue,'a) token
val RBRACE:  'a * 'a -> (svalue,'a) token
val LBRACE:  'a * 'a -> (svalue,'a) token
val RBRACK:  'a * 'a -> (svalue,'a) token
val LBRACK:  'a * 'a -> (svalue,'a) token
val RPAR:  'a * 'a -> (svalue,'a) token
val LPAR:  'a * 'a -> (svalue,'a) token
val WHILE:  'a * 'a -> (svalue,'a) token
val WITHTYPE:  'a * 'a -> (svalue,'a) token
val WITH:  'a * 'a -> (svalue,'a) token
val VAL:  'a * 'a -> (svalue,'a) token
val TYPE:  'a * 'a -> (svalue,'a) token
val THEN:  'a * 'a -> (svalue,'a) token
val REC:  'a * 'a -> (svalue,'a) token
val RAISE:  'a * 'a -> (svalue,'a) token
val ORELSE:  'a * 'a -> (svalue,'a) token
val OPEN:  'a * 'a -> (svalue,'a) token
val OP:  'a * 'a -> (svalue,'a) token
val OF:  'a * 'a -> (svalue,'a) token
val NONFIX:  'a * 'a -> (svalue,'a) token
val LOCAL:  'a * 'a -> (svalue,'a) token
val LET:  'a * 'a -> (svalue,'a) token
val INFIXR:  'a * 'a -> (svalue,'a) token
val INFIX:  'a * 'a -> (svalue,'a) token
val IN:  'a * 'a -> (svalue,'a) token
val IF:  'a * 'a -> (svalue,'a) token
val HANDLE:  'a * 'a -> (svalue,'a) token
val FUN:  'a * 'a -> (svalue,'a) token
val FN:  'a * 'a -> (svalue,'a) token
val EXCEPTION:  'a * 'a -> (svalue,'a) token
val END:  'a * 'a -> (svalue,'a) token
val ELSE:  'a * 'a -> (svalue,'a) token
val DATATYPE:  'a * 'a -> (svalue,'a) token
val DO:  'a * 'a -> (svalue,'a) token
val CASE:  'a * 'a -> (svalue,'a) token
val AS:  'a * 'a -> (svalue,'a) token
val ANDALSO:  'a * 'a -> (svalue,'a) token
val AND:  'a * 'a -> (svalue,'a) token
val ABSTYPE:  'a * 'a -> (svalue,'a) token
val EOF:  'a * 'a -> (svalue,'a) token
end
signature Parser_LRVALS=
sig
structure ParserData:PARSER_DATA
structure Tokens : Parser_TOKENS
sharing type ParserData.Token.token = Tokens.token
sharing type ParserData.svalue = Tokens.svalue
end
(* src # 114 ../frontend-sml/Parser.grm.sml *)

functor LrVals(structure Token:        TOKEN
			structure DerivedForms: DERIVED_FORMS
		       )
	 = 
struct
structure ParserData=
struct
structure Header = 
struct
(*										*)
(* Standard ML syntactic analysis						*)
(*										*)
(* Definition, sections 2, 3, and 8, Appendix A and B				*)
(*										*)
(* Extensions:									*)
(*   - allow = to be bound as vid (in a pattern it must be prefixed by op)	*)
(*   - record update expressions:						*)
(*	  atexp ::= { atexp where exprow }					*)
(*   - vector expressions and patterns:						*)
(*	  atexp ::= #[ exp_1 , ... , exp_n ] 	(n>=0)				*)
(*	  atpat ::= #[ pat_1 , ... , pat_n ]	(n>=0)				*)
(*   - punning in record expressions (derived form):				*)
(*	  exprow ::= vid <: ty> <, exprow>					*)
(*   - recursive expressions (derived form):					*)
(*	  exp ::= rec pat => exp						*)
(*   - more relaxed constructor pattern syntax:					*)
(*	  pat ::= pat atpat			(R)				*)
(*   - generalized layered patterns:						*)
(*	  pat ::= pat as pat			(R)				*)
(*   - alternative and guarded patterns:					*)
(*	  atpat ::= ( pat_1 | ... | pat_n )	(n>=2)				*)
(*	  pat   ::= pat where atexp		(L)				*)
(*   - negated patterns:							*)
(*	  pat ::= non pat							*)
(*   - with patterns:								*)
(*	  pat ::= pat withval valbind end					*)
(*	      ::= pat withfun fvalbind end	(derived form)			*)
(*   - open datatypes (exception declarations become a derived form),		*)
(*     constructor synonym specifications:					*)
(*        dec      ::= constructor dconbind					*)
(*	  datbind  ::= tyvarseq tycon						*)
(*	  dconbind ::= <op> vid <of ty> : tyvarseq longtycon <and dconbind>	*)
(*		   ::= <op> vid = <op> longvid <and dconbind>			*)
(*        spec     ::= constructor dcondesc					*)
(*	  datdesc  ::= tyvarseq tycon						*)
(*	  dcondesc ::= vid <of ty> : tyvarseq longtycon <and dcondesc>		*)
(*		   ::= vid = longvid <and dcondesc>				*)
(*   - abstract type declarations:						*)
(*	  typbind  ::= tyvarseq tycon						*)
(*	  dec      ::= eqtype typbind						*)
(*   - straightified type specifications:					*)
(*	  typdesc ::= tyvarseq tycon						*)
(*		      tyvarseq tycon = ty					*)
(*   - where for structures:							*)
(*	  sigexp ::= sigexp where longstrid_1 = longstrid_2			*)
(*   - definitional structure specifications:					*)
(*	  strdesc ::= strid <: sigexp> = longstrid <and strdesc>		*)
(*   - top signature:								*)
(*	  sigexp ::= any							*)
(*   - parenthesised structure and signature expressions (derived forms):	*)
(*        strexp ::= ( strexp )							*)
(*        sigexp ::= ( sigexp )							*)
(*   - fun keyword in signatures (derived form):				*)
(*	  spec ::= fun valdesc							*)
(*   - op keyword in signatures:						*)
(*	  valdesc  ::= <op> vid : ty <and valdesc>				*)
(*	  condesc  ::= <op> vid <of ty> <| condesc>				*)
(*	  exdesc   ::= <op> vid <of ty> <and exdesc>				*)
(*	  dcondesc ::= <op> vid <of ty> : tyvarseq longtycon <and dcondesc>	*)
(*		   ::= <op> vid = <op> longvid <and dcondesc>			*)
(*   - withtype in signatures (derived form):					*)
(*	  spec ::= datatype datdesc <withtype syndesc>				*)
(*   - fixity directives in signatures:						*)
(*	  spec ::= infix <d> vid_1 ... vid_n	(n>=1)				*)
(*		   infixr <d> vid_1 ... vid_n	(n>=1)				*)
(*		   nonfix vid_1 ... vid_n	(n>=1)				*)
(*   - no distinction between dec, strdec, and topdec				*)
(*   - long signature identifiers:						*)
(*	  sigexp  ::= longsigid							*)
(*	  spec    ::= include longsigid_1 ... longsigid_n			*)
(*   - functor specifications:							*)
(*	  spec    ::= functor fundesc						*)
(*	  fundesc ::= strid ( strid : sigexp ) : sigexp <and fundesc>		*)
(*	          ::= strid ( spec ) : sigexp <and fundesc>			*)
(*   - signature specifications:						*)
(*	  spec    ::= signature sigdesc						*)
(*	  sigdesc ::= sigid <and sigdesc>					*)
(*	          ::= sigid = sigexp <and sigdesc>				*)
(*   - sharing and where for signature:						*)
(*	  spec   ::= spec sharing signature longsigid_1 = ... = longsigid_n	*)
(*	  sigexp ::= sigexp where signature longsigid_1 = sigexp		*)
(*   - components:								*)
(*	  component ::= ann <program>						*)
(*	  ann       ::= import spec from string					*)
(*			<>							*)
(*			ann <;> ann						*)
(*										*)
(* We did NOT introduce a sharing signature ... and signature ... derived form	*)
(* similar to types, because we consider that completely broken.		*)
(*										*)
(* To avoid hardwiring certain library issues, we further added the following	*)
(* low-level constructs:							*)
(*	  dec     ::= __primitive val <op> vid : ty = string			*)
(*	          ::= __primitive constructor <op> vid <of ty> : ty = string	*)
(*	          ::= __primitive structure strid : sigexp = string		*)
(*	          ::= __overload <op> vid with tyvar : ty			*)
(*	          ::= __instance <op> vid with longtycon = longvid		*)
(*	          ::= __instance scon with longtycon				*)
(*	          ::= __eqtype typbind						*)
(*	  spec    ::= __eqtype typdesc						*)
(*	          ::= __overload <op> vid with tyvar : ty			*)
(*	          ::= __instance <op> vid with longtycon = longvid		*)
(*	          ::= __instance scon with longtycon				*)
(*	  ann     ::= __prebound strid						*)
(*										*)
(* Notes:									*)
(*   - Two phrases named Fmatch and Fmrule have been added to factorize		*)
(*     Fvalbind.								*)
(*   - A phrase named SynDesc has been added to factorize type synonym		*)
(*     specifications. Similarly, a phrase named Rea has been added to		*)
(*     factorize realisation signature expressions.				*)
(*   - Infix expressions [Definition, section 2.6] are resolved during		*)
(*     elaboration because we allow fixity specifications in signatures that	*)
(*     come into effect by an open declaration. Infix status is completely	*)
(*     ignored here.								*)
(*   - Syntactic restrictions [Definition, sections 2.9 and 3.5] are checked	*)
(*     during elaboration, as well as the Fvalbind derived form.		*)
(*   - The Definition is not clear about whether `=' should also be legal as	*)
(*     a tycon. Since this would result in massive conflicts, and a type named	*)
(*     `=' could only be used legally if an implementation would be mad enough	*)
(*     to predefine it anyway, we simply disallow it.				*)
(*   - Datatype replication requires rules for datatype to be duplicated to	*)
(*     avoid conflicts on empty tyvarseqs.					*)
(*   - The messy `sigexp where type ... and type ...' syntax requires some	*)
(*     really ugly transformations (in absence of a lookahead of 2), watch out	*)
(*     for non-terminals of the form xxx__AND_yyybind_opt.			*)
(*   - We do NOT support declarations like					*)
(*	  fun f p1 = case e1 of p2 => e2					*)
(*	    | f p3 = e3								*)
(*     (without parentheses around the case) because the transformations	*)
(*     required to support this would be even a magnitude uglier than those	*)
(*     above. In fact, no compiler I know of supports this.			*)
(*   - ML-Yacc does not seem to like comments that stretch over several		*)
(*     lines... Similarly, comments in semantic actions make it puke...		*)
(*										*)



    (* Import *)

    open InputGrammar
    open DerivedForms


    (* Helper to build position fields *)

    fun I(left, right) = (left, right)



end
structure LrTable = Token.LrTable
structure Token = Token
local open LrTable in 
val table=let val actionRows =
"\
\\001\000\001\000\000\000\000\000\
\\001\000\001\000\191\005\002\000\191\005\003\000\191\005\004\000\191\005\
\\005\000\191\005\007\000\191\005\008\000\191\005\009\000\191\005\
\\010\000\191\005\011\000\191\005\013\000\191\005\014\000\191\005\
\\016\000\191\005\017\000\191\005\018\000\191\005\019\000\191\005\
\\020\000\191\005\021\000\191\005\022\000\191\005\023\000\191\005\
\\024\000\191\005\025\000\191\005\028\000\191\005\029\000\191\005\
\\030\000\191\005\034\000\191\005\035\000\191\005\036\000\191\005\
\\037\000\191\005\038\000\191\005\039\000\191\005\040\000\191\005\
\\041\000\191\005\042\000\191\005\044\000\191\005\045\000\191\005\
\\046\000\191\005\047\000\191\005\049\000\191\005\050\000\191\005\
\\052\000\191\005\053\000\191\005\054\000\197\005\055\000\191\005\
\\061\000\191\005\062\000\191\005\063\000\191\005\064\000\191\005\
\\066\000\191\005\067\000\191\005\068\000\191\005\069\000\191\005\
\\070\000\191\005\072\000\191\005\074\000\191\005\075\000\191\005\
\\076\000\191\005\077\000\191\005\078\000\191\005\079\000\191\005\
\\080\000\191\005\081\000\191\005\082\000\191\005\083\000\191\005\
\\084\000\191\005\085\000\191\005\086\000\191\005\087\000\191\005\000\000\
\\001\000\001\000\194\005\002\000\194\005\003\000\194\005\004\000\194\005\
\\005\000\194\005\007\000\194\005\008\000\194\005\009\000\194\005\
\\010\000\194\005\011\000\194\005\013\000\194\005\014\000\194\005\
\\016\000\194\005\017\000\194\005\018\000\194\005\020\000\194\005\
\\021\000\194\005\022\000\194\005\024\000\194\005\025\000\194\005\
\\028\000\194\005\029\000\194\005\030\000\194\005\031\000\194\005\
\\032\000\194\005\035\000\194\005\037\000\194\005\039\000\194\005\
\\040\000\194\005\041\000\194\005\042\000\194\005\045\000\194\005\
\\046\000\194\005\047\000\194\005\048\000\194\005\050\000\194\005\
\\052\000\194\005\053\000\194\005\054\000\197\005\061\000\194\005\
\\062\000\194\005\063\000\194\005\064\000\194\005\066\000\194\005\
\\067\000\194\005\068\000\194\005\069\000\194\005\070\000\194\005\
\\072\000\194\005\074\000\194\005\075\000\194\005\076\000\194\005\
\\085\000\194\005\086\000\194\005\087\000\194\005\000\000\
\\001\000\001\000\198\005\002\000\198\005\003\000\198\005\004\000\198\005\
\\005\000\198\005\007\000\198\005\008\000\198\005\009\000\198\005\
\\010\000\198\005\011\000\198\005\013\000\198\005\014\000\198\005\
\\016\000\198\005\017\000\198\005\018\000\198\005\019\000\198\005\
\\020\000\198\005\021\000\198\005\022\000\198\005\024\000\198\005\
\\025\000\198\005\028\000\198\005\029\000\198\005\030\000\198\005\
\\031\000\198\005\032\000\198\005\034\000\198\005\035\000\198\005\
\\037\000\198\005\039\000\198\005\040\000\198\005\041\000\198\005\
\\042\000\198\005\045\000\198\005\046\000\198\005\047\000\198\005\
\\048\000\198\005\050\000\198\005\052\000\198\005\053\000\198\005\
\\054\000\197\005\061\000\198\005\062\000\198\005\063\000\198\005\
\\064\000\198\005\066\000\198\005\067\000\198\005\068\000\198\005\
\\069\000\198\005\070\000\198\005\072\000\198\005\073\000\198\005\
\\074\000\198\005\075\000\198\005\076\000\198\005\085\000\198\005\
\\086\000\198\005\087\000\198\005\000\000\
\\001\000\001\000\123\006\002\000\123\006\003\000\123\006\004\000\123\006\
\\005\000\123\006\007\000\123\006\008\000\123\006\009\000\123\006\
\\010\000\123\006\011\000\123\006\013\000\123\006\014\000\123\006\
\\016\000\123\006\017\000\123\006\018\000\123\006\020\000\123\006\
\\021\000\123\006\022\000\123\006\024\000\123\006\025\000\123\006\
\\028\000\123\006\029\000\123\006\030\000\123\006\031\000\123\006\
\\032\000\123\006\035\000\123\006\037\000\123\006\039\000\123\006\
\\040\000\123\006\041\000\123\006\042\000\123\006\045\000\123\006\
\\046\000\123\006\047\000\123\006\048\000\123\006\050\000\123\006\
\\052\000\123\006\053\000\123\006\061\000\123\006\062\000\123\006\
\\063\000\123\006\064\000\123\006\066\000\123\006\067\000\123\006\
\\068\000\123\006\069\000\123\006\070\000\123\006\072\000\123\006\
\\074\000\123\006\075\000\123\006\076\000\123\006\085\000\135\006\
\\086\000\135\006\087\000\099\001\000\000\
\\001\000\001\000\165\006\002\000\165\006\003\000\116\002\008\000\165\006\
\\010\000\165\006\011\000\165\006\013\000\165\006\016\000\165\006\
\\017\000\165\006\018\000\165\006\019\000\001\002\020\000\165\006\
\\021\000\165\006\024\000\165\006\029\000\165\006\030\000\165\006\
\\034\000\000\002\035\000\165\006\041\000\153\006\042\000\165\006\
\\050\000\165\006\062\000\165\006\063\000\165\006\064\000\165\006\
\\066\000\165\006\067\000\165\006\068\000\165\006\072\000\165\006\
\\073\000\253\001\074\000\165\006\076\000\153\006\085\000\071\000\000\000\
\\001\000\001\000\165\006\002\000\165\006\003\000\116\002\008\000\165\006\
\\010\000\165\006\011\000\165\006\013\000\165\006\016\000\165\006\
\\017\000\165\006\018\000\165\006\020\000\165\006\021\000\165\006\
\\024\000\165\006\029\000\165\006\030\000\165\006\035\000\165\006\
\\041\000\194\006\042\000\165\006\050\000\165\006\062\000\165\006\
\\063\000\165\006\064\000\165\006\066\000\165\006\067\000\165\006\
\\068\000\165\006\072\000\165\006\074\000\165\006\075\000\194\006\
\\076\000\194\006\000\000\
\\001\000\001\000\165\006\002\000\165\006\003\000\073\005\008\000\165\006\
\\010\000\165\006\011\000\165\006\013\000\165\006\016\000\165\006\
\\017\000\165\006\018\000\165\006\019\000\001\002\020\000\165\006\
\\021\000\165\006\024\000\165\006\029\000\165\006\030\000\165\006\
\\034\000\000\002\035\000\165\006\041\000\227\006\042\000\165\006\
\\050\000\165\006\062\000\165\006\063\000\165\006\064\000\165\006\
\\066\000\165\006\067\000\165\006\068\000\165\006\072\000\165\006\
\\073\000\253\001\074\000\165\006\075\000\227\006\076\000\227\006\
\\085\000\071\000\000\000\
\\001\000\001\000\165\006\002\000\165\006\003\000\073\005\008\000\165\006\
\\010\000\165\006\011\000\165\006\013\000\165\006\016\000\165\006\
\\017\000\165\006\018\000\165\006\020\000\165\006\021\000\165\006\
\\024\000\165\006\029\000\165\006\030\000\165\006\035\000\165\006\
\\041\000\227\006\042\000\165\006\050\000\165\006\054\000\004\001\
\\062\000\165\006\063\000\165\006\064\000\165\006\066\000\165\006\
\\067\000\165\006\068\000\165\006\072\000\165\006\074\000\165\006\
\\075\000\227\006\076\000\227\006\000\000\
\\001\000\001\000\165\006\002\000\165\006\003\000\073\005\008\000\165\006\
\\010\000\165\006\011\000\165\006\013\000\165\006\016\000\165\006\
\\017\000\165\006\018\000\165\006\020\000\165\006\021\000\165\006\
\\024\000\165\006\029\000\165\006\030\000\165\006\035\000\165\006\
\\041\000\227\006\042\000\165\006\050\000\165\006\062\000\165\006\
\\063\000\165\006\064\000\165\006\066\000\165\006\067\000\165\006\
\\068\000\165\006\072\000\165\006\074\000\165\006\075\000\227\006\
\\076\000\227\006\000\000\
\\001\000\001\000\203\006\002\000\203\006\003\000\142\002\008\000\203\006\
\\010\000\203\006\011\000\203\006\013\000\203\006\016\000\203\006\
\\017\000\203\006\018\000\203\006\020\000\203\006\021\000\203\006\
\\024\000\203\006\029\000\203\006\030\000\203\006\035\000\203\006\
\\042\000\203\006\050\000\203\006\062\000\203\006\063\000\203\006\
\\064\000\203\006\066\000\203\006\067\000\203\006\068\000\203\006\
\\072\000\203\006\074\000\203\006\075\000\194\006\000\000\
\\001\000\001\000\203\006\002\000\203\006\003\000\220\004\008\000\203\006\
\\010\000\203\006\011\000\203\006\013\000\203\006\016\000\203\006\
\\017\000\203\006\018\000\203\006\019\000\001\002\020\000\203\006\
\\021\000\203\006\024\000\203\006\029\000\203\006\030\000\203\006\
\\034\000\000\002\035\000\203\006\042\000\203\006\050\000\203\006\
\\062\000\203\006\063\000\203\006\064\000\203\006\066\000\203\006\
\\067\000\203\006\068\000\203\006\072\000\203\006\073\000\253\001\
\\074\000\203\006\075\000\227\006\085\000\071\000\000\000\
\\001\000\001\000\203\006\002\000\203\006\003\000\220\004\008\000\203\006\
\\010\000\203\006\011\000\203\006\013\000\203\006\016\000\203\006\
\\017\000\203\006\018\000\203\006\020\000\203\006\021\000\203\006\
\\024\000\203\006\029\000\203\006\030\000\203\006\035\000\203\006\
\\042\000\203\006\050\000\203\006\054\000\004\001\062\000\203\006\
\\063\000\203\006\064\000\203\006\066\000\203\006\067\000\203\006\
\\068\000\203\006\072\000\203\006\074\000\203\006\075\000\227\006\000\000\
\\001\000\001\000\203\006\002\000\203\006\003\000\220\004\008\000\203\006\
\\010\000\203\006\011\000\203\006\013\000\203\006\016\000\203\006\
\\017\000\203\006\018\000\203\006\020\000\203\006\021\000\203\006\
\\024\000\203\006\029\000\203\006\030\000\203\006\035\000\203\006\
\\042\000\203\006\050\000\203\006\062\000\203\006\063\000\203\006\
\\064\000\203\006\066\000\203\006\067\000\203\006\068\000\203\006\
\\072\000\203\006\074\000\203\006\075\000\227\006\000\000\
\\001\000\001\000\234\006\002\000\234\006\003\000\045\003\008\000\234\006\
\\010\000\234\006\011\000\234\006\013\000\234\006\016\000\234\006\
\\017\000\234\006\018\000\234\006\019\000\001\002\020\000\234\006\
\\021\000\234\006\024\000\234\006\029\000\234\006\030\000\234\006\
\\034\000\000\002\035\000\234\006\041\000\153\006\042\000\234\006\
\\050\000\234\006\062\000\234\006\063\000\234\006\064\000\234\006\
\\066\000\234\006\067\000\234\006\068\000\234\006\072\000\234\006\
\\073\000\253\001\074\000\234\006\076\000\153\006\085\000\071\000\000\000\
\\001\000\001\000\234\006\002\000\234\006\003\000\045\003\008\000\234\006\
\\010\000\234\006\011\000\234\006\013\000\234\006\016\000\234\006\
\\017\000\234\006\018\000\234\006\020\000\234\006\021\000\234\006\
\\024\000\234\006\029\000\234\006\030\000\234\006\035\000\234\006\
\\041\000\194\006\042\000\234\006\050\000\234\006\062\000\234\006\
\\063\000\234\006\064\000\234\006\066\000\234\006\067\000\234\006\
\\068\000\234\006\072\000\234\006\074\000\234\006\075\000\194\006\
\\076\000\194\006\000\000\
\\001\000\001\000\234\006\002\000\234\006\003\000\150\005\008\000\234\006\
\\010\000\234\006\011\000\234\006\013\000\234\006\016\000\234\006\
\\017\000\234\006\018\000\234\006\019\000\001\002\020\000\234\006\
\\021\000\234\006\024\000\234\006\029\000\234\006\030\000\234\006\
\\034\000\000\002\035\000\234\006\041\000\227\006\042\000\234\006\
\\050\000\234\006\062\000\234\006\063\000\234\006\064\000\234\006\
\\066\000\234\006\067\000\234\006\068\000\234\006\072\000\234\006\
\\073\000\253\001\074\000\234\006\075\000\227\006\076\000\227\006\
\\085\000\071\000\000\000\
\\001\000\001\000\234\006\002\000\234\006\003\000\150\005\008\000\234\006\
\\010\000\234\006\011\000\234\006\013\000\234\006\016\000\234\006\
\\017\000\234\006\018\000\234\006\020\000\234\006\021\000\234\006\
\\024\000\234\006\029\000\234\006\030\000\234\006\035\000\234\006\
\\041\000\227\006\042\000\234\006\050\000\234\006\054\000\004\001\
\\062\000\234\006\063\000\234\006\064\000\234\006\066\000\234\006\
\\067\000\234\006\068\000\234\006\072\000\234\006\074\000\234\006\
\\075\000\227\006\076\000\227\006\000\000\
\\001\000\001\000\234\006\002\000\234\006\003\000\150\005\008\000\234\006\
\\010\000\234\006\011\000\234\006\013\000\234\006\016\000\234\006\
\\017\000\234\006\018\000\234\006\020\000\234\006\021\000\234\006\
\\024\000\234\006\029\000\234\006\030\000\234\006\035\000\234\006\
\\041\000\227\006\042\000\234\006\050\000\234\006\062\000\234\006\
\\063\000\234\006\064\000\234\006\066\000\234\006\067\000\234\006\
\\068\000\234\006\072\000\234\006\074\000\234\006\075\000\227\006\
\\076\000\227\006\000\000\
\\001\000\003\000\077\001\008\000\161\007\011\000\161\007\013\000\161\007\
\\029\000\161\007\030\000\161\007\050\000\161\007\061\000\161\007\
\\068\000\161\007\072\000\161\007\074\000\161\007\075\000\194\006\000\000\
\\001\000\003\000\083\001\008\000\183\007\011\000\183\007\013\000\183\007\
\\029\000\183\007\030\000\183\007\034\000\249\000\041\000\201\006\
\\050\000\183\007\061\000\183\007\068\000\183\007\072\000\183\007\
\\074\000\183\007\000\000\
\\001\000\003\000\083\001\008\000\183\007\011\000\183\007\013\000\183\007\
\\029\000\183\007\030\000\183\007\050\000\183\007\061\000\183\007\
\\068\000\183\007\072\000\183\007\074\000\183\007\075\000\194\006\000\000\
\\001\000\003\000\226\001\008\000\153\007\011\000\153\007\013\000\153\007\
\\022\000\165\001\029\000\153\007\030\000\153\007\041\000\072\006\
\\050\000\153\007\061\000\153\007\068\000\153\007\072\000\153\007\
\\074\000\153\007\000\000\
\\001\000\003\000\015\003\008\000\088\007\010\000\088\007\011\000\088\007\
\\013\000\088\007\017\000\088\007\018\000\088\007\021\000\088\007\
\\029\000\088\007\030\000\088\007\035\000\088\007\050\000\088\007\
\\063\000\088\007\064\000\088\007\066\000\088\007\067\000\088\007\
\\068\000\088\007\069\000\088\007\070\000\088\007\072\000\088\007\
\\074\000\088\007\075\000\194\006\000\000\
\\001\000\003\000\119\003\008\000\070\007\010\000\070\007\011\000\070\007\
\\013\000\070\007\017\000\070\007\018\000\070\007\021\000\070\007\
\\029\000\070\007\030\000\070\007\035\000\070\007\046\000\194\006\
\\050\000\070\007\063\000\070\007\064\000\070\007\066\000\070\007\
\\067\000\070\007\068\000\070\007\069\000\070\007\070\000\070\007\
\\072\000\070\007\074\000\070\007\075\000\194\006\000\000\
\\001\000\003\000\234\003\008\000\105\007\010\000\105\007\011\000\105\007\
\\013\000\105\007\017\000\105\007\018\000\105\007\021\000\105\007\
\\029\000\105\007\030\000\105\007\035\000\105\007\050\000\105\007\
\\063\000\105\007\064\000\105\007\066\000\105\007\067\000\105\007\
\\068\000\105\007\069\000\105\007\070\000\105\007\072\000\105\007\
\\074\000\105\007\075\000\194\006\000\000\
\\001\000\003\000\188\004\008\000\161\007\011\000\161\007\013\000\161\007\
\\019\000\001\002\029\000\161\007\030\000\161\007\034\000\000\002\
\\050\000\161\007\061\000\161\007\068\000\161\007\072\000\161\007\
\\073\000\253\001\074\000\161\007\075\000\227\006\085\000\071\000\000\000\
\\001\000\003\000\188\004\008\000\161\007\011\000\161\007\013\000\161\007\
\\029\000\161\007\030\000\161\007\050\000\161\007\054\000\004\001\
\\061\000\161\007\068\000\161\007\072\000\161\007\074\000\161\007\
\\075\000\227\006\000\000\
\\001\000\003\000\188\004\008\000\161\007\011\000\161\007\013\000\161\007\
\\029\000\161\007\030\000\161\007\050\000\161\007\061\000\161\007\
\\068\000\161\007\072\000\161\007\074\000\161\007\075\000\227\006\000\000\
\\001\000\003\000\011\005\008\000\183\007\011\000\183\007\013\000\183\007\
\\019\000\001\002\029\000\183\007\030\000\183\007\034\000\000\002\
\\050\000\183\007\061\000\183\007\068\000\183\007\072\000\183\007\
\\073\000\253\001\074\000\183\007\075\000\227\006\085\000\071\000\000\000\
\\001\000\003\000\011\005\008\000\183\007\011\000\183\007\013\000\183\007\
\\029\000\183\007\030\000\183\007\050\000\183\007\054\000\004\001\
\\061\000\183\007\068\000\183\007\072\000\183\007\074\000\183\007\
\\075\000\227\006\000\000\
\\001\000\003\000\011\005\008\000\183\007\011\000\183\007\013\000\183\007\
\\029\000\183\007\030\000\183\007\050\000\183\007\061\000\183\007\
\\068\000\183\007\072\000\183\007\074\000\183\007\075\000\227\006\000\000\
\\001\000\003\000\083\005\008\000\070\007\010\000\070\007\011\000\070\007\
\\013\000\070\007\017\000\070\007\018\000\070\007\019\000\001\002\
\\021\000\070\007\029\000\070\007\030\000\070\007\034\000\000\002\
\\035\000\070\007\046\000\227\006\050\000\070\007\063\000\070\007\
\\064\000\070\007\066\000\070\007\067\000\070\007\068\000\070\007\
\\069\000\070\007\070\000\070\007\072\000\070\007\073\000\253\001\
\\074\000\070\007\075\000\227\006\085\000\071\000\000\000\
\\001\000\003\000\083\005\008\000\070\007\010\000\070\007\011\000\070\007\
\\013\000\070\007\017\000\070\007\018\000\070\007\021\000\070\007\
\\029\000\070\007\030\000\070\007\035\000\070\007\046\000\227\006\
\\050\000\070\007\054\000\004\001\063\000\070\007\064\000\070\007\
\\066\000\070\007\067\000\070\007\068\000\070\007\069\000\070\007\
\\070\000\070\007\072\000\070\007\074\000\070\007\075\000\227\006\000\000\
\\001\000\003\000\083\005\008\000\070\007\010\000\070\007\011\000\070\007\
\\013\000\070\007\017\000\070\007\018\000\070\007\021\000\070\007\
\\029\000\070\007\030\000\070\007\035\000\070\007\046\000\227\006\
\\050\000\070\007\063\000\070\007\064\000\070\007\066\000\070\007\
\\067\000\070\007\068\000\070\007\069\000\070\007\070\000\070\007\
\\072\000\070\007\074\000\070\007\075\000\227\006\000\000\
\\001\000\003\000\130\005\008\000\088\007\010\000\088\007\011\000\088\007\
\\013\000\088\007\017\000\088\007\018\000\088\007\019\000\001\002\
\\021\000\088\007\029\000\088\007\030\000\088\007\034\000\000\002\
\\035\000\088\007\050\000\088\007\063\000\088\007\064\000\088\007\
\\066\000\088\007\067\000\088\007\068\000\088\007\069\000\088\007\
\\070\000\088\007\072\000\088\007\073\000\253\001\074\000\088\007\
\\075\000\227\006\085\000\071\000\000\000\
\\001\000\003\000\130\005\008\000\088\007\010\000\088\007\011\000\088\007\
\\013\000\088\007\017\000\088\007\018\000\088\007\021\000\088\007\
\\029\000\088\007\030\000\088\007\035\000\088\007\050\000\088\007\
\\054\000\004\001\063\000\088\007\064\000\088\007\066\000\088\007\
\\067\000\088\007\068\000\088\007\069\000\088\007\070\000\088\007\
\\072\000\088\007\074\000\088\007\075\000\227\006\000\000\
\\001\000\003\000\130\005\008\000\088\007\010\000\088\007\011\000\088\007\
\\013\000\088\007\017\000\088\007\018\000\088\007\021\000\088\007\
\\029\000\088\007\030\000\088\007\035\000\088\007\050\000\088\007\
\\063\000\088\007\064\000\088\007\066\000\088\007\067\000\088\007\
\\068\000\088\007\069\000\088\007\070\000\088\007\072\000\088\007\
\\074\000\088\007\075\000\227\006\000\000\
\\001\000\003\000\140\005\008\000\105\007\010\000\105\007\011\000\105\007\
\\013\000\105\007\017\000\105\007\018\000\105\007\019\000\001\002\
\\021\000\105\007\029\000\105\007\030\000\105\007\034\000\000\002\
\\035\000\105\007\050\000\105\007\063\000\105\007\064\000\105\007\
\\066\000\105\007\067\000\105\007\068\000\105\007\069\000\105\007\
\\070\000\105\007\072\000\105\007\073\000\253\001\074\000\105\007\
\\075\000\227\006\085\000\071\000\000\000\
\\001\000\003\000\140\005\008\000\105\007\010\000\105\007\011\000\105\007\
\\013\000\105\007\017\000\105\007\018\000\105\007\021\000\105\007\
\\029\000\105\007\030\000\105\007\035\000\105\007\050\000\105\007\
\\054\000\004\001\063\000\105\007\064\000\105\007\066\000\105\007\
\\067\000\105\007\068\000\105\007\069\000\105\007\070\000\105\007\
\\072\000\105\007\074\000\105\007\075\000\227\006\000\000\
\\001\000\003\000\140\005\008\000\105\007\010\000\105\007\011\000\105\007\
\\013\000\105\007\017\000\105\007\018\000\105\007\021\000\105\007\
\\029\000\105\007\030\000\105\007\035\000\105\007\050\000\105\007\
\\063\000\105\007\064\000\105\007\066\000\105\007\067\000\105\007\
\\068\000\105\007\069\000\105\007\070\000\105\007\072\000\105\007\
\\074\000\105\007\075\000\227\006\000\000\
\\001\000\004\000\091\000\007\000\019\001\014\000\090\000\025\000\089\000\
\\041\000\088\000\000\000\
\\001\000\004\000\091\000\009\000\081\002\014\000\090\000\025\000\089\000\
\\041\000\088\000\000\000\
\\001\000\004\000\091\000\014\000\090\000\022\000\071\001\025\000\089\000\
\\041\000\088\000\000\000\
\\001\000\004\000\091\000\014\000\090\000\025\000\089\000\028\000\053\001\
\\041\000\088\000\000\000\
\\001\000\004\000\091\000\014\000\090\000\025\000\089\000\035\000\016\001\
\\040\000\015\001\041\000\088\000\042\000\014\001\000\000\
\\001\000\004\000\091\000\014\000\090\000\025\000\089\000\041\000\088\000\
\\042\000\087\000\000\000\
\\001\000\005\000\191\005\039\000\191\005\040\000\191\005\041\000\191\005\
\\046\000\184\005\000\000\
\\001\000\005\000\192\005\039\000\192\005\040\000\192\005\041\000\192\005\
\\046\000\185\005\075\000\192\005\000\000\
\\001\000\005\000\193\005\039\000\193\005\040\000\193\005\041\000\193\005\
\\046\000\186\005\075\000\193\005\000\000\
\\001\000\005\000\026\001\035\000\190\001\040\000\189\001\041\000\025\001\
\\045\000\188\001\052\000\023\001\053\000\022\001\075\000\021\001\000\000\
\\001\000\005\000\026\001\041\000\025\001\046\000\024\001\052\000\023\001\
\\053\000\022\001\075\000\021\001\000\000\
\\001\000\005\000\026\001\041\000\025\001\047\000\045\001\052\000\023\001\
\\053\000\022\001\075\000\021\001\000\000\
\\001\000\005\000\026\001\041\000\025\001\047\000\060\001\052\000\023\001\
\\053\000\022\001\075\000\021\001\000\000\
\\001\000\006\000\068\000\012\000\065\000\015\000\063\000\019\000\060\000\
\\023\000\057\000\026\000\055\000\027\000\054\000\033\000\051\000\
\\034\000\050\000\035\000\142\000\036\000\049\000\038\000\048\000\
\\046\000\047\000\049\000\046\000\055\000\044\000\058\000\043\000\
\\077\000\034\000\078\000\033\000\079\000\032\000\080\000\031\000\
\\081\000\030\000\082\000\029\000\083\000\028\000\084\000\027\000\
\\085\000\026\000\086\000\025\000\087\000\024\000\000\000\
\\001\000\006\000\068\000\012\000\065\000\015\000\063\000\019\000\060\000\
\\023\000\057\000\026\000\055\000\027\000\054\000\033\000\051\000\
\\034\000\050\000\036\000\049\000\038\000\048\000\046\000\047\000\
\\049\000\046\000\055\000\044\000\058\000\043\000\077\000\034\000\
\\078\000\033\000\079\000\032\000\080\000\031\000\081\000\030\000\
\\082\000\029\000\083\000\028\000\084\000\027\000\085\000\026\000\
\\086\000\025\000\087\000\024\000\000\000\
\\001\000\010\000\068\002\000\000\
\\001\000\010\000\069\002\000\000\
\\001\000\010\000\079\002\000\000\
\\001\000\010\000\080\002\000\000\
\\001\000\010\000\137\002\000\000\
\\001\000\010\000\201\002\000\000\
\\001\000\010\000\229\002\000\000\
\\001\000\010\000\106\003\075\000\002\002\000\000\
\\001\000\010\000\198\003\041\000\233\002\076\000\232\002\000\000\
\\001\000\011\000\135\002\013\000\134\002\029\000\133\002\030\000\132\002\
\\050\000\131\002\068\000\130\002\072\000\129\002\074\000\128\002\000\000\
\\001\000\011\000\135\002\013\000\134\002\029\000\133\002\030\000\132\002\
\\050\000\131\002\068\000\130\002\072\000\129\002\074\000\128\002\
\\085\000\071\000\000\000\
\\001\000\011\000\210\002\013\000\209\002\029\000\208\002\030\000\207\002\
\\050\000\206\002\068\000\205\002\072\000\204\002\074\000\203\002\
\\085\000\071\000\000\000\
\\001\000\011\000\003\003\013\000\002\003\029\000\001\003\030\000\000\003\
\\050\000\255\002\068\000\254\002\072\000\253\002\074\000\252\002\
\\085\000\071\000\000\000\
\\001\000\011\000\003\003\013\000\002\003\029\000\001\003\030\000\000\003\
\\050\000\255\002\068\000\254\002\072\000\253\002\074\000\252\002\
\\085\000\099\000\000\000\
\\001\000\011\000\079\003\013\000\078\003\029\000\077\003\030\000\076\003\
\\050\000\075\003\068\000\074\003\072\000\073\003\074\000\072\003\
\\085\000\071\000\000\000\
\\001\000\011\000\194\003\013\000\193\003\029\000\192\003\030\000\191\003\
\\044\000\096\000\050\000\190\003\068\000\189\003\072\000\188\003\
\\074\000\187\003\085\000\071\000\000\000\
\\001\000\011\000\194\003\013\000\193\003\029\000\192\003\030\000\191\003\
\\050\000\190\003\068\000\189\003\072\000\188\003\074\000\187\003\
\\085\000\071\000\000\000\
\\001\000\011\000\225\003\013\000\224\003\029\000\223\003\030\000\222\003\
\\050\000\221\003\068\000\220\003\072\000\219\003\074\000\218\003\
\\085\000\071\000\000\000\
\\001\000\011\000\064\004\013\000\063\004\029\000\062\004\030\000\061\004\
\\050\000\060\004\068\000\059\004\072\000\058\004\074\000\057\004\
\\085\000\071\000\000\000\
\\001\000\011\000\064\004\013\000\063\004\029\000\062\004\030\000\061\004\
\\050\000\060\004\068\000\059\004\072\000\058\004\074\000\057\004\
\\085\000\099\000\000\000\
\\001\000\011\000\077\004\013\000\076\004\029\000\075\004\030\000\074\004\
\\050\000\073\004\068\000\072\004\072\000\071\004\074\000\070\004\
\\085\000\071\000\000\000\
\\001\000\011\000\098\004\013\000\097\004\029\000\096\004\030\000\095\004\
\\050\000\094\004\068\000\093\004\072\000\092\004\074\000\091\004\
\\085\000\071\000\000\000\
\\001\000\016\000\049\001\000\000\
\\001\000\016\000\050\001\000\000\
\\001\000\016\000\140\002\000\000\
\\001\000\016\000\238\002\000\000\
\\001\000\019\000\060\000\023\000\057\000\034\000\050\000\036\000\049\000\
\\038\000\048\000\046\000\047\000\049\000\046\000\055\000\044\000\
\\077\000\034\000\078\000\033\000\079\000\032\000\080\000\031\000\
\\081\000\030\000\082\000\029\000\083\000\028\000\084\000\027\000\
\\085\000\026\000\086\000\025\000\087\000\024\000\000\000\
\\001\000\019\000\120\001\034\000\119\001\056\000\118\001\057\000\117\001\
\\071\000\116\001\085\000\104\001\000\000\
\\001\000\019\000\120\001\034\000\119\001\056\000\118\001\057\000\218\001\
\\071\000\116\001\085\000\104\001\000\000\
\\001\000\019\000\120\001\034\000\119\001\056\000\118\001\057\000\013\002\
\\071\000\116\001\085\000\104\001\000\000\
\\001\000\019\000\120\001\034\000\119\001\056\000\118\001\057\000\097\002\
\\071\000\116\001\085\000\104\001\000\000\
\\001\000\019\000\120\001\034\000\119\001\056\000\118\001\057\000\225\002\
\\071\000\116\001\085\000\104\001\000\000\
\\001\000\019\000\120\001\034\000\119\001\056\000\118\001\057\000\012\003\
\\071\000\116\001\085\000\104\001\000\000\
\\001\000\019\000\120\001\034\000\119\001\056\000\118\001\057\000\125\003\
\\071\000\116\001\085\000\104\001\000\000\
\\001\000\019\000\120\001\034\000\119\001\056\000\118\001\057\000\135\003\
\\071\000\116\001\085\000\104\001\000\000\
\\001\000\019\000\120\001\034\000\119\001\056\000\118\001\057\000\155\003\
\\071\000\116\001\085\000\104\001\000\000\
\\001\000\019\000\120\001\034\000\119\001\056\000\118\001\071\000\116\001\
\\085\000\104\001\000\000\
\\001\000\019\000\001\002\034\000\000\002\057\000\255\001\059\000\254\001\
\\073\000\253\001\085\000\071\000\000\000\
\\001\000\019\000\001\002\034\000\000\002\057\000\124\002\059\000\123\002\
\\073\000\253\001\085\000\071\000\000\000\
\\001\000\019\000\001\002\034\000\000\002\057\000\179\002\059\000\178\002\
\\073\000\253\001\085\000\071\000\000\000\
\\001\000\023\000\158\000\027\000\157\000\034\000\156\000\036\000\155\000\
\\038\000\154\000\044\000\153\000\051\000\152\000\055\000\151\000\
\\077\000\034\000\078\000\033\000\079\000\032\000\080\000\031\000\
\\081\000\030\000\082\000\029\000\083\000\028\000\084\000\027\000\
\\085\000\026\000\086\000\025\000\087\000\024\000\088\000\106\000\000\000\
\\001\000\023\000\158\000\027\000\157\000\034\000\161\000\036\000\155\000\
\\038\000\154\000\044\000\153\000\051\000\152\000\055\000\151\000\
\\077\000\034\000\078\000\033\000\079\000\032\000\080\000\031\000\
\\081\000\030\000\082\000\029\000\083\000\028\000\084\000\027\000\
\\085\000\026\000\086\000\025\000\087\000\024\000\000\000\
\\001\000\023\000\158\000\034\000\156\000\036\000\155\000\038\000\154\000\
\\044\000\153\000\051\000\152\000\055\000\151\000\077\000\034\000\
\\078\000\033\000\079\000\032\000\080\000\031\000\081\000\030\000\
\\082\000\029\000\083\000\028\000\084\000\027\000\085\000\026\000\
\\086\000\025\000\087\000\024\000\088\000\106\000\000\000\
\\001\000\023\000\158\000\034\000\161\000\035\000\042\001\036\000\155\000\
\\038\000\154\000\044\000\153\000\051\000\152\000\055\000\151\000\
\\077\000\034\000\078\000\033\000\079\000\032\000\080\000\031\000\
\\081\000\030\000\082\000\029\000\083\000\028\000\084\000\027\000\
\\085\000\026\000\086\000\025\000\087\000\024\000\000\000\
\\001\000\023\000\158\000\034\000\161\000\035\000\042\001\036\000\155\000\
\\038\000\154\000\044\000\153\000\051\000\152\000\055\000\151\000\
\\077\000\034\000\078\000\033\000\079\000\032\000\080\000\031\000\
\\081\000\030\000\082\000\029\000\083\000\028\000\084\000\027\000\
\\085\000\026\000\086\000\025\000\087\000\024\000\088\000\106\000\000\000\
\\001\000\023\000\158\000\034\000\161\000\036\000\155\000\038\000\154\000\
\\044\000\153\000\051\000\152\000\055\000\151\000\077\000\034\000\
\\078\000\033\000\079\000\032\000\080\000\031\000\081\000\030\000\
\\082\000\029\000\083\000\028\000\084\000\027\000\085\000\026\000\
\\086\000\025\000\087\000\024\000\000\000\
\\001\000\029\000\025\002\072\000\024\002\085\000\071\000\000\000\
\\001\000\029\000\147\002\072\000\146\002\085\000\071\000\000\000\
\\001\000\030\000\115\000\050\000\114\000\074\000\113\000\000\000\
\\001\000\031\000\255\000\000\000\
\\001\000\031\000\156\001\000\000\
\\001\000\031\000\158\001\000\000\
\\001\000\031\000\214\001\000\000\
\\001\000\031\000\160\002\000\000\
\\001\000\031\000\024\003\000\000\
\\001\000\031\000\026\003\000\000\
\\001\000\034\000\107\000\085\000\198\000\086\000\197\000\088\000\106\000\000\000\
\\001\000\034\000\249\000\000\000\
\\001\000\035\000\017\001\000\000\
\\001\000\035\000\018\001\000\000\
\\001\000\035\000\154\001\000\000\
\\001\000\035\000\191\001\000\000\
\\001\000\035\000\192\001\000\000\
\\001\000\035\000\245\001\000\000\
\\001\000\035\000\247\001\040\000\246\001\000\000\
\\001\000\035\000\016\002\000\000\
\\001\000\035\000\139\002\075\000\002\002\000\000\
\\001\000\035\000\234\002\041\000\233\002\076\000\232\002\000\000\
\\001\000\035\000\235\002\000\000\
\\001\000\035\000\007\003\075\000\002\002\000\000\
\\001\000\035\000\029\003\075\000\002\002\000\000\
\\001\000\037\000\006\001\000\000\
\\001\000\037\000\013\001\000\000\
\\001\000\037\000\183\001\000\000\
\\001\000\037\000\187\001\000\000\
\\001\000\039\000\191\005\040\000\191\005\041\000\191\005\046\000\184\005\
\\054\000\197\005\075\000\191\005\000\000\
\\001\000\039\000\105\006\040\000\105\006\041\000\011\001\075\000\201\005\000\000\
\\001\000\039\000\008\001\000\000\
\\001\000\039\000\184\001\000\000\
\\001\000\039\000\243\001\000\000\
\\001\000\039\000\064\002\000\000\
\\001\000\041\000\159\001\000\000\
\\001\000\041\000\222\001\000\000\
\\001\000\041\000\244\001\000\000\
\\001\000\041\000\017\002\000\000\
\\001\000\041\000\037\002\000\000\
\\001\000\041\000\060\002\000\000\
\\001\000\041\000\061\002\000\000\
\\001\000\041\000\098\002\000\000\
\\001\000\041\000\113\002\076\000\112\002\000\000\
\\001\000\041\000\183\002\000\000\
\\001\000\041\000\185\002\000\000\
\\001\000\041\000\230\002\000\000\
\\001\000\041\000\020\003\000\000\
\\001\000\041\000\031\003\046\000\030\003\000\000\
\\001\000\041\000\043\003\076\000\042\003\000\000\
\\001\000\041\000\094\003\000\000\
\\001\000\041\000\140\003\000\000\
\\001\000\041\000\159\003\000\000\
\\001\000\041\000\239\003\000\000\
\\001\000\043\000\037\001\078\000\127\000\079\000\126\000\085\000\036\001\
\\086\000\134\000\087\000\133\000\000\000\
\\001\000\044\000\096\000\085\000\071\000\000\000\
\\001\000\046\000\187\005\075\000\175\005\000\000\
\\001\000\046\000\188\005\075\000\176\005\000\000\
\\001\000\046\000\047\000\085\000\026\000\086\000\025\000\087\000\024\000\000\000\
\\001\000\046\000\170\000\085\000\026\000\086\000\025\000\087\000\024\000\000\000\
\\001\000\046\000\170\000\085\000\169\000\086\000\025\000\087\000\024\000\000\000\
\\001\000\046\000\012\001\000\000\
\\001\000\046\000\055\001\000\000\
\\001\000\046\000\110\001\000\000\
\\001\000\046\000\122\001\000\000\
\\001\000\046\000\123\001\000\000\
\\001\000\046\000\186\001\000\000\
\\001\000\046\000\235\001\000\000\
\\001\000\046\000\003\002\075\000\002\002\000\000\
\\001\000\046\000\051\002\000\000\
\\001\000\046\000\152\002\054\000\004\001\000\000\
\\001\000\046\000\180\002\075\000\002\002\000\000\
\\001\000\046\000\182\002\000\000\
\\001\000\046\000\184\002\075\000\002\002\000\000\
\\001\000\046\000\239\002\054\000\004\001\000\000\
\\001\000\046\000\008\003\000\000\
\\001\000\046\000\018\003\000\000\
\\001\000\046\000\019\003\000\000\
\\001\000\046\000\053\003\000\000\
\\001\000\046\000\199\003\000\000\
\\001\000\046\000\200\003\000\000\
\\001\000\046\000\201\003\000\000\
\\001\000\046\000\202\003\000\000\
\\001\000\046\000\203\003\000\000\
\\001\000\046\000\204\003\000\000\
\\001\000\046\000\205\003\000\000\
\\001\000\046\000\206\003\000\000\
\\001\000\046\000\238\003\000\000\
\\001\000\046\000\002\004\000\000\
\\001\000\046\000\003\004\000\000\
\\001\000\046\000\004\004\000\000\
\\001\000\046\000\005\004\000\000\
\\001\000\046\000\006\004\000\000\
\\001\000\046\000\007\004\000\000\
\\001\000\046\000\008\004\000\000\
\\001\000\046\000\009\004\000\000\
\\001\000\046\000\010\004\000\000\
\\001\000\046\000\038\004\000\000\
\\001\000\046\000\039\004\000\000\
\\001\000\046\000\040\004\000\000\
\\001\000\046\000\041\004\000\000\
\\001\000\046\000\042\004\000\000\
\\001\000\046\000\043\004\000\000\
\\001\000\046\000\044\004\000\000\
\\001\000\046\000\045\004\000\000\
\\001\000\046\000\110\004\000\000\
\\001\000\046\000\111\004\000\000\
\\001\000\046\000\112\004\000\000\
\\001\000\046\000\113\004\000\000\
\\001\000\046\000\114\004\000\000\
\\001\000\046\000\115\004\000\000\
\\001\000\046\000\116\004\000\000\
\\001\000\046\000\117\004\000\000\
\\001\000\046\000\205\004\000\000\
\\001\000\046\000\206\004\000\000\
\\001\000\046\000\207\004\000\000\
\\001\000\046\000\208\004\000\000\
\\001\000\046\000\209\004\000\000\
\\001\000\046\000\210\004\000\000\
\\001\000\046\000\211\004\000\000\
\\001\000\046\000\212\004\000\000\
\\001\000\046\000\228\004\000\000\
\\001\000\046\000\229\004\000\000\
\\001\000\046\000\230\004\000\000\
\\001\000\046\000\231\004\000\000\
\\001\000\046\000\232\004\000\000\
\\001\000\046\000\233\004\000\000\
\\001\000\046\000\234\004\000\000\
\\001\000\046\000\235\004\000\000\
\\001\000\046\000\042\005\000\000\
\\001\000\046\000\043\005\000\000\
\\001\000\046\000\044\005\000\000\
\\001\000\046\000\045\005\000\000\
\\001\000\046\000\046\005\000\000\
\\001\000\046\000\047\005\000\000\
\\001\000\046\000\048\005\000\000\
\\001\000\046\000\049\005\000\000\
\\001\000\046\000\050\005\000\000\
\\001\000\046\000\051\005\000\000\
\\001\000\046\000\052\005\000\000\
\\001\000\046\000\053\005\000\000\
\\001\000\046\000\054\005\000\000\
\\001\000\046\000\055\005\000\000\
\\001\000\046\000\056\005\000\000\
\\001\000\046\000\057\005\000\000\
\\001\000\046\000\058\005\000\000\
\\001\000\046\000\059\005\000\000\
\\001\000\046\000\060\005\000\000\
\\001\000\046\000\061\005\000\000\
\\001\000\046\000\062\005\000\000\
\\001\000\046\000\063\005\000\000\
\\001\000\046\000\064\005\000\000\
\\001\000\046\000\065\005\000\000\
\\001\000\047\000\231\002\000\000\
\\001\000\047\000\095\003\000\000\
\\001\000\047\000\160\003\000\000\
\\001\000\048\000\138\002\000\000\
\\001\000\048\000\211\002\000\000\
\\001\000\048\000\004\003\000\000\
\\001\000\048\000\080\003\000\000\
\\001\000\048\000\195\003\000\000\
\\001\000\048\000\226\003\000\000\
\\001\000\048\000\065\004\000\000\
\\001\000\048\000\078\004\000\000\
\\001\000\048\000\099\004\000\000\
\\001\000\054\000\093\000\000\000\
\\001\000\054\000\239\001\000\000\
\\001\000\054\000\242\001\000\000\
\\001\000\061\000\203\000\000\000\
\\001\000\075\000\009\001\000\000\
\\001\000\075\000\092\002\000\000\
\\001\000\075\000\143\002\000\000\
\\001\000\075\000\213\002\000\000\
\\001\000\075\000\228\003\000\000\
\\001\000\075\000\235\003\000\000\
\\001\000\078\000\127\000\079\000\126\000\085\000\125\000\086\000\124\000\
\\087\000\123\000\000\000\
\\001\000\078\000\127\000\079\000\126\000\085\000\036\001\086\000\134\000\
\\087\000\133\000\000\000\
\\001\000\083\000\074\001\000\000\
\\001\000\083\000\051\003\000\000\
\\001\000\083\000\162\003\000\000\
\\001\000\083\000\100\004\000\000\
\\001\000\085\000\071\000\000\000\
\\001\000\085\000\099\000\000\000\
\\001\000\085\000\198\000\086\000\197\000\000\000\
\\001\000\085\000\098\001\086\000\197\000\000\000\
\\001\000\085\000\104\001\000\000\
\\001\000\088\000\106\000\000\000\
\\174\005\000\000\
\\175\005\000\000\
\\176\005\000\000\
\\177\005\000\000\
\\178\005\000\000\
\\179\005\000\000\
\\180\005\000\000\
\\181\005\000\000\
\\182\005\000\000\
\\183\005\000\000\
\\184\005\000\000\
\\185\005\000\000\
\\186\005\000\000\
\\187\005\000\000\
\\188\005\000\000\
\\189\005\000\000\
\\190\005\000\000\
\\191\005\000\000\
\\192\005\000\000\
\\193\005\000\000\
\\194\005\000\000\
\\195\005\000\000\
\\196\005\000\000\
\\197\005\000\000\
\\198\005\000\000\
\\199\005\000\000\
\\200\005\000\000\
\\201\005\000\000\
\\202\005\000\000\
\\203\005\000\000\
\\204\005\000\000\
\\205\005\000\000\
\\206\005\000\000\
\\207\005\000\000\
\\208\005\000\000\
\\209\005\000\000\
\\210\005\008\000\209\001\023\000\111\000\000\000\
\\210\005\008\000\039\003\023\000\111\000\000\000\
\\210\005\023\000\111\000\000\000\
\\210\005\023\000\111\000\077\000\034\000\078\000\033\000\079\000\032\000\
\\080\000\031\000\081\000\030\000\082\000\029\000\083\000\028\000\
\\084\000\027\000\000\000\
\\211\005\000\000\
\\212\005\000\000\
\\213\005\000\000\
\\214\005\000\000\
\\215\005\000\000\
\\216\005\000\000\
\\217\005\000\000\
\\218\005\000\000\
\\219\005\000\000\
\\220\005\000\000\
\\221\005\000\000\
\\222\005\000\000\
\\223\005\000\000\
\\224\005\000\000\
\\225\005\006\000\068\000\012\000\065\000\015\000\063\000\019\000\060\000\
\\023\000\057\000\026\000\055\000\027\000\054\000\033\000\051\000\
\\034\000\050\000\036\000\049\000\038\000\048\000\046\000\047\000\
\\049\000\046\000\055\000\044\000\058\000\043\000\077\000\034\000\
\\078\000\033\000\079\000\032\000\080\000\031\000\081\000\030\000\
\\082\000\029\000\083\000\028\000\084\000\027\000\085\000\026\000\
\\086\000\025\000\087\000\024\000\000\000\
\\226\005\000\000\
\\227\005\004\000\091\000\014\000\090\000\025\000\089\000\040\000\005\001\
\\041\000\088\000\000\000\
\\228\005\000\000\
\\229\005\000\000\
\\230\005\004\000\091\000\014\000\090\000\025\000\089\000\041\000\088\000\
\\042\000\067\002\000\000\
\\231\005\000\000\
\\232\005\000\000\
\\233\005\000\000\
\\234\005\000\000\
\\235\005\004\000\091\000\014\000\090\000\025\000\089\000\040\000\169\001\
\\041\000\088\000\000\000\
\\235\005\040\000\169\001\000\000\
\\236\005\000\000\
\\237\005\019\000\060\000\023\000\057\000\034\000\050\000\036\000\049\000\
\\038\000\048\000\046\000\047\000\049\000\046\000\055\000\044\000\
\\077\000\034\000\078\000\137\000\079\000\136\000\080\000\031\000\
\\081\000\030\000\082\000\029\000\083\000\028\000\084\000\027\000\
\\085\000\135\000\086\000\134\000\087\000\133\000\000\000\
\\238\005\000\000\
\\239\005\000\000\
\\240\005\019\000\060\000\023\000\057\000\034\000\050\000\036\000\049\000\
\\038\000\048\000\046\000\047\000\049\000\046\000\055\000\044\000\
\\077\000\034\000\078\000\033\000\079\000\032\000\080\000\031\000\
\\081\000\030\000\082\000\029\000\083\000\028\000\084\000\027\000\
\\085\000\026\000\086\000\025\000\087\000\024\000\000\000\
\\241\005\000\000\
\\242\005\000\000\
\\243\005\004\000\091\000\041\000\088\000\000\000\
\\244\005\004\000\091\000\025\000\089\000\041\000\088\000\000\000\
\\245\005\000\000\
\\246\005\004\000\091\000\014\000\090\000\025\000\089\000\041\000\088\000\000\000\
\\247\005\004\000\091\000\014\000\090\000\025\000\089\000\041\000\088\000\000\000\
\\248\005\004\000\091\000\014\000\090\000\025\000\089\000\041\000\088\000\000\000\
\\249\005\000\000\
\\250\005\000\000\
\\251\005\004\000\091\000\014\000\090\000\025\000\089\000\041\000\088\000\000\000\
\\252\005\054\000\004\001\000\000\
\\253\005\000\000\
\\254\005\000\000\
\\255\005\045\000\062\001\000\000\
\\000\006\004\000\091\000\014\000\090\000\025\000\089\000\041\000\088\000\000\000\
\\001\006\002\000\069\000\008\000\067\000\011\000\066\000\013\000\064\000\
\\017\000\062\000\018\000\061\000\020\000\059\000\021\000\058\000\
\\024\000\056\000\029\000\053\000\030\000\052\000\042\000\174\000\
\\050\000\045\000\062\000\042\000\063\000\041\000\064\000\040\000\
\\066\000\039\000\067\000\038\000\068\000\037\000\072\000\036\000\
\\074\000\035\000\000\000\
\\002\006\002\000\069\000\008\000\067\000\011\000\066\000\013\000\064\000\
\\017\000\062\000\018\000\061\000\019\000\001\002\020\000\059\000\
\\021\000\058\000\024\000\056\000\029\000\053\000\030\000\052\000\
\\034\000\000\002\042\000\174\000\050\000\045\000\057\000\124\002\
\\059\000\123\002\062\000\042\000\063\000\041\000\064\000\040\000\
\\066\000\039\000\067\000\038\000\068\000\037\000\072\000\036\000\
\\073\000\253\001\074\000\035\000\085\000\071\000\000\000\
\\002\006\002\000\069\000\008\000\067\000\011\000\066\000\013\000\064\000\
\\017\000\062\000\018\000\061\000\020\000\059\000\021\000\058\000\
\\024\000\056\000\029\000\053\000\030\000\052\000\042\000\174\000\
\\050\000\045\000\062\000\042\000\063\000\041\000\064\000\040\000\
\\066\000\039\000\067\000\038\000\068\000\037\000\072\000\036\000\
\\074\000\035\000\000\000\
\\003\006\000\000\
\\004\006\002\000\069\000\008\000\067\000\011\000\066\000\013\000\064\000\
\\017\000\062\000\018\000\061\000\020\000\059\000\021\000\058\000\
\\024\000\056\000\029\000\053\000\030\000\052\000\050\000\045\000\
\\062\000\042\000\063\000\041\000\064\000\040\000\066\000\039\000\
\\067\000\038\000\068\000\037\000\072\000\036\000\074\000\035\000\000\000\
\\005\006\000\000\
\\006\006\000\000\
\\007\006\002\000\069\000\008\000\067\000\011\000\066\000\013\000\064\000\
\\017\000\062\000\018\000\061\000\020\000\059\000\021\000\058\000\
\\024\000\056\000\029\000\053\000\030\000\052\000\050\000\045\000\
\\062\000\042\000\063\000\041\000\064\000\040\000\066\000\039\000\
\\067\000\038\000\068\000\037\000\072\000\036\000\074\000\035\000\000\000\
\\008\006\000\000\
\\009\006\000\000\
\\010\006\000\000\
\\011\006\000\000\
\\012\006\000\000\
\\013\006\000\000\
\\014\006\000\000\
\\015\006\000\000\
\\016\006\000\000\
\\017\006\000\000\
\\018\006\000\000\
\\019\006\000\000\
\\020\006\000\000\
\\021\006\000\000\
\\022\006\000\000\
\\023\006\000\000\
\\024\006\000\000\
\\025\006\000\000\
\\026\006\000\000\
\\027\006\000\000\
\\028\006\000\000\
\\029\006\000\000\
\\030\006\000\000\
\\031\006\000\000\
\\032\006\000\000\
\\033\006\000\000\
\\034\006\000\000\
\\035\006\000\000\
\\036\006\000\000\
\\037\006\032\000\066\001\000\000\
\\038\006\000\000\
\\039\006\046\000\170\000\085\000\169\000\086\000\025\000\087\000\024\000\000\000\
\\040\006\000\000\
\\041\006\054\000\004\001\085\000\071\000\000\000\
\\042\006\000\000\
\\043\006\077\000\179\000\078\000\178\000\000\000\
\\044\006\000\000\
\\045\006\000\000\
\\046\006\000\000\
\\047\006\003\000\071\002\004\000\091\000\014\000\090\000\025\000\089\000\
\\041\000\088\000\000\000\
\\048\006\000\000\
\\049\006\000\000\
\\050\006\003\000\059\001\000\000\
\\051\006\000\000\
\\052\006\000\000\
\\053\006\045\000\057\001\000\000\
\\054\006\004\000\091\000\014\000\090\000\025\000\089\000\041\000\088\000\000\000\
\\055\006\005\000\026\001\041\000\025\001\052\000\023\001\053\000\022\001\
\\075\000\021\001\000\000\
\\056\006\000\000\
\\057\006\000\000\
\\058\006\000\000\
\\059\006\003\000\153\001\000\000\
\\059\006\003\000\153\001\046\000\152\001\000\000\
\\060\006\000\000\
\\061\006\000\000\
\\062\006\000\000\
\\063\006\000\000\
\\064\006\000\000\
\\065\006\000\000\
\\066\006\000\000\
\\067\006\003\000\070\001\000\000\
\\067\006\003\000\070\001\046\000\069\001\000\000\
\\067\006\003\000\070\001\046\000\205\001\000\000\
\\067\006\003\000\070\001\046\000\213\001\000\000\
\\068\006\000\000\
\\069\006\000\000\
\\070\006\045\000\060\003\000\000\
\\071\006\000\000\
\\072\006\022\000\165\001\000\000\
\\072\006\022\000\165\001\046\000\164\001\000\000\
\\072\006\022\000\165\001\046\000\203\001\000\000\
\\072\006\022\000\165\001\046\000\028\003\000\000\
\\072\006\022\000\165\001\046\000\033\003\000\000\
\\073\006\000\000\
\\074\006\000\000\
\\075\006\000\000\
\\076\006\003\000\056\003\000\000\
\\077\006\000\000\
\\078\006\000\000\
\\079\006\000\000\
\\080\006\003\000\083\002\000\000\
\\081\006\000\000\
\\082\006\000\000\
\\083\006\000\000\
\\084\006\000\000\
\\085\006\000\000\
\\086\006\000\000\
\\087\006\000\000\
\\088\006\000\000\
\\089\006\000\000\
\\090\006\000\000\
\\091\006\000\000\
\\092\006\000\000\
\\093\006\023\000\158\000\034\000\161\000\036\000\155\000\038\000\154\000\
\\044\000\153\000\051\000\152\000\055\000\151\000\077\000\034\000\
\\078\000\033\000\079\000\032\000\080\000\031\000\081\000\030\000\
\\082\000\029\000\083\000\028\000\084\000\027\000\085\000\026\000\
\\086\000\025\000\087\000\024\000\000\000\
\\094\006\000\000\
\\095\006\005\000\026\001\040\000\182\001\041\000\025\001\052\000\023\001\
\\053\000\022\001\075\000\021\001\000\000\
\\096\006\000\000\
\\097\006\005\000\026\001\041\000\025\001\045\000\188\001\052\000\023\001\
\\053\000\022\001\075\000\021\001\000\000\
\\098\006\000\000\
\\099\006\000\000\
\\100\006\000\000\
\\101\006\000\000\
\\102\006\000\000\
\\103\006\005\000\026\001\040\000\192\002\041\000\025\001\052\000\023\001\
\\053\000\022\001\075\000\021\001\000\000\
\\103\006\040\000\192\002\000\000\
\\104\006\000\000\
\\105\006\041\000\011\001\000\000\
\\106\006\005\000\026\001\041\000\025\001\052\000\023\001\053\000\022\001\
\\075\000\021\001\000\000\
\\107\006\005\000\074\002\000\000\
\\108\006\000\000\
\\109\006\043\000\037\001\078\000\127\000\079\000\126\000\085\000\036\001\
\\086\000\134\000\087\000\133\000\000\000\
\\110\006\000\000\
\\111\006\000\000\
\\112\006\023\000\158\000\034\000\161\000\036\000\155\000\038\000\154\000\
\\044\000\153\000\055\000\151\000\077\000\034\000\078\000\033\000\
\\079\000\032\000\080\000\031\000\081\000\030\000\082\000\029\000\
\\083\000\028\000\084\000\027\000\085\000\026\000\086\000\025\000\
\\087\000\024\000\000\000\
\\113\006\000\000\
\\114\006\041\000\025\001\000\000\
\\115\006\005\000\026\001\041\000\025\001\000\000\
\\116\006\000\000\
\\117\006\000\000\
\\118\006\000\000\
\\119\006\048\000\100\001\000\000\
\\120\006\000\000\
\\121\006\000\000\
\\122\006\000\000\
\\124\006\000\000\
\\125\006\000\000\
\\126\006\000\000\
\\127\006\000\000\
\\128\006\000\000\
\\129\006\000\000\
\\130\006\000\000\
\\131\006\000\000\
\\132\006\040\000\221\002\000\000\
\\133\006\000\000\
\\134\006\078\000\127\000\079\000\126\000\085\000\125\000\086\000\124\000\
\\087\000\123\000\000\000\
\\136\006\034\000\236\000\038\000\235\000\058\000\234\000\088\000\106\000\000\000\
\\137\006\000\000\
\\138\006\000\000\
\\139\006\040\000\246\001\000\000\
\\140\006\000\000\
\\141\006\034\000\107\000\088\000\106\000\000\000\
\\142\006\000\000\
\\143\006\000\000\
\\144\006\000\000\
\\145\006\040\000\155\001\000\000\
\\146\006\000\000\
\\147\006\054\000\004\001\000\000\
\\148\006\000\000\
\\149\006\000\000\
\\150\006\000\000\
\\151\006\000\000\
\\152\006\000\000\
\\153\006\019\000\001\002\034\000\000\002\073\000\253\001\085\000\071\000\000\000\
\\154\006\075\000\002\002\000\000\
\\154\006\075\000\086\003\000\000\
\\154\006\075\000\252\003\000\000\
\\155\006\075\000\002\002\000\000\
\\155\006\075\000\086\003\000\000\
\\155\006\075\000\252\003\000\000\
\\156\006\041\000\233\002\076\000\232\002\000\000\
\\157\006\075\000\002\002\000\000\
\\157\006\075\000\086\003\000\000\
\\157\006\075\000\252\003\000\000\
\\158\006\000\000\
\\159\006\000\000\
\\160\006\000\000\
\\161\006\000\000\
\\162\006\000\000\
\\163\006\000\000\
\\164\006\000\000\
\\166\006\000\000\
\\167\006\000\000\
\\168\006\000\000\
\\169\006\000\000\
\\170\006\000\000\
\\171\006\000\000\
\\172\006\000\000\
\\173\006\000\000\
\\174\006\000\000\
\\175\006\000\000\
\\176\006\000\000\
\\177\006\000\000\
\\178\006\000\000\
\\179\006\000\000\
\\180\006\000\000\
\\181\006\000\000\
\\182\006\000\000\
\\183\006\000\000\
\\184\006\000\000\
\\185\006\075\000\002\002\000\000\
\\185\006\075\000\120\003\000\000\
\\186\006\041\000\244\000\000\000\
\\186\006\041\000\244\000\054\000\004\001\000\000\
\\186\006\041\000\244\000\076\000\243\000\000\000\
\\186\006\041\000\244\000\076\000\150\001\000\000\
\\186\006\041\000\150\002\000\000\
\\187\006\000\000\
\\188\006\000\000\
\\189\006\000\000\
\\190\006\000\000\
\\191\006\000\000\
\\192\006\000\000\
\\193\006\000\000\
\\194\006\000\000\
\\195\006\000\000\
\\196\006\000\000\
\\197\006\019\000\001\002\034\000\000\002\073\000\253\001\085\000\071\000\000\000\
\\198\006\054\000\004\001\000\000\
\\199\006\000\000\
\\200\006\000\000\
\\201\006\034\000\249\000\000\000\
\\202\006\000\000\
\\204\006\000\000\
\\205\006\000\000\
\\206\006\000\000\
\\207\006\000\000\
\\208\006\000\000\
\\209\006\000\000\
\\210\006\000\000\
\\211\006\000\000\
\\212\006\000\000\
\\213\006\000\000\
\\214\006\000\000\
\\215\006\000\000\
\\216\006\000\000\
\\217\006\000\000\
\\218\006\000\000\
\\219\006\000\000\
\\220\006\000\000\
\\221\006\000\000\
\\222\006\000\000\
\\223\006\000\000\
\\224\006\000\000\
\\225\006\000\000\
\\226\006\000\000\
\\227\006\003\000\127\004\000\000\
\\227\006\003\000\127\004\019\000\001\002\034\000\000\002\073\000\253\001\
\\085\000\071\000\000\000\
\\227\006\003\000\127\004\054\000\004\001\000\000\
\\228\006\000\000\
\\229\006\000\000\
\\230\006\000\000\
\\231\006\034\000\249\000\000\000\
\\232\006\000\000\
\\233\006\000\000\
\\235\006\000\000\
\\236\006\000\000\
\\237\006\000\000\
\\238\006\000\000\
\\239\006\000\000\
\\240\006\000\000\
\\241\006\000\000\
\\242\006\000\000\
\\243\006\000\000\
\\244\006\000\000\
\\245\006\000\000\
\\246\006\000\000\
\\247\006\000\000\
\\248\006\000\000\
\\249\006\000\000\
\\250\006\000\000\
\\251\006\000\000\
\\252\006\000\000\
\\253\006\000\000\
\\254\006\008\000\148\001\011\000\147\001\013\000\146\001\017\000\145\001\
\\018\000\144\001\021\000\143\001\029\000\142\001\030\000\141\001\
\\050\000\138\001\063\000\137\001\064\000\136\001\066\000\135\001\
\\067\000\134\001\068\000\133\001\069\000\132\001\070\000\015\002\
\\072\000\130\001\074\000\129\001\000\000\
\\255\006\008\000\148\001\011\000\147\001\013\000\146\001\017\000\145\001\
\\018\000\144\001\021\000\143\001\029\000\142\001\030\000\141\001\
\\042\000\140\001\044\000\139\001\050\000\138\001\063\000\137\001\
\\064\000\136\001\066\000\135\001\067\000\134\001\068\000\133\001\
\\069\000\132\001\070\000\131\001\072\000\130\001\074\000\129\001\
\\085\000\071\000\000\000\
\\255\006\008\000\148\001\011\000\147\001\013\000\146\001\017\000\145\001\
\\018\000\144\001\021\000\143\001\029\000\142\001\030\000\141\001\
\\042\000\140\001\050\000\138\001\063\000\137\001\064\000\136\001\
\\066\000\135\001\067\000\134\001\068\000\133\001\069\000\132\001\
\\070\000\131\001\072\000\130\001\074\000\129\001\000\000\
\\000\007\000\000\
\\001\007\000\000\
\\002\007\000\000\
\\003\007\000\000\
\\004\007\000\000\
\\005\007\000\000\
\\006\007\000\000\
\\007\007\000\000\
\\008\007\000\000\
\\009\007\000\000\
\\010\007\000\000\
\\011\007\000\000\
\\012\007\000\000\
\\013\007\000\000\
\\014\007\000\000\
\\015\007\000\000\
\\016\007\000\000\
\\017\007\000\000\
\\018\007\000\000\
\\019\007\000\000\
\\020\007\000\000\
\\021\007\000\000\
\\022\007\075\000\002\002\000\000\
\\023\007\000\000\
\\024\007\000\000\
\\025\007\000\000\
\\026\007\000\000\
\\027\007\000\000\
\\028\007\000\000\
\\029\007\000\000\
\\030\007\032\000\169\002\000\000\
\\031\007\000\000\
\\032\007\046\000\232\003\000\000\
\\033\007\000\000\
\\034\007\000\000\
\\035\007\046\000\231\003\000\000\
\\036\007\000\000\
\\037\007\000\000\
\\038\007\046\000\127\003\054\000\004\001\000\000\
\\039\007\000\000\
\\040\007\000\000\
\\041\007\000\000\
\\042\007\000\000\
\\043\007\003\000\244\003\000\000\
\\044\007\000\000\
\\045\007\000\000\
\\046\007\000\000\
\\047\007\003\000\023\003\000\000\
\\047\007\003\000\023\003\046\000\022\003\000\000\
\\048\007\000\000\
\\049\007\000\000\
\\050\007\000\000\
\\051\007\000\000\
\\052\007\000\000\
\\053\007\000\000\
\\054\007\000\000\
\\055\007\003\000\174\002\000\000\
\\055\007\003\000\174\002\046\000\173\002\000\000\
\\055\007\003\000\174\002\046\000\036\003\000\000\
\\055\007\003\000\174\002\046\000\250\003\000\000\
\\056\007\000\000\
\\057\007\000\000\
\\058\007\045\000\088\004\000\000\
\\059\007\000\000\
\\060\007\000\000\
\\061\007\000\000\
\\062\007\003\000\083\004\000\000\
\\063\007\000\000\
\\064\007\000\000\
\\065\007\000\000\
\\066\007\003\000\145\003\000\000\
\\067\007\000\000\
\\068\007\000\000\
\\069\007\000\000\
\\070\007\003\000\119\003\054\000\004\001\000\000\
\\071\007\000\000\
\\072\007\000\000\
\\073\007\000\000\
\\074\007\000\000\
\\075\007\000\000\
\\076\007\000\000\
\\077\007\000\000\
\\078\007\000\000\
\\079\007\000\000\
\\080\007\000\000\
\\081\007\000\000\
\\082\007\000\000\
\\083\007\000\000\
\\084\007\000\000\
\\085\007\000\000\
\\086\007\000\000\
\\087\007\000\000\
\\088\007\003\000\015\003\046\000\014\003\000\000\
\\089\007\000\000\
\\090\007\000\000\
\\091\007\000\000\
\\092\007\000\000\
\\093\007\000\000\
\\094\007\000\000\
\\095\007\000\000\
\\096\007\000\000\
\\097\007\000\000\
\\098\007\000\000\
\\099\007\000\000\
\\100\007\000\000\
\\101\007\000\000\
\\102\007\000\000\
\\103\007\000\000\
\\104\007\000\000\
\\106\007\000\000\
\\107\007\000\000\
\\108\007\000\000\
\\109\007\000\000\
\\110\007\000\000\
\\111\007\000\000\
\\112\007\000\000\
\\113\007\000\000\
\\114\007\000\000\
\\115\007\000\000\
\\116\007\000\000\
\\117\007\000\000\
\\118\007\000\000\
\\119\007\000\000\
\\120\007\008\000\084\000\011\000\083\000\013\000\082\000\029\000\081\000\
\\030\000\080\000\050\000\078\000\068\000\077\000\072\000\076\000\
\\074\000\075\000\000\000\
\\121\007\008\000\084\000\011\000\083\000\013\000\082\000\029\000\081\000\
\\030\000\080\000\042\000\079\000\050\000\078\000\068\000\077\000\
\\072\000\076\000\074\000\075\000\000\000\
\\122\007\000\000\
\\123\007\000\000\
\\124\007\000\000\
\\125\007\000\000\
\\126\007\000\000\
\\127\007\000\000\
\\128\007\000\000\
\\129\007\000\000\
\\130\007\000\000\
\\131\007\000\000\
\\132\007\000\000\
\\133\007\000\000\
\\134\007\000\000\
\\135\007\000\000\
\\136\007\000\000\
\\137\007\003\000\229\001\000\000\
\\137\007\003\000\229\001\041\000\228\001\000\000\
\\138\007\000\000\
\\139\007\000\000\
\\140\007\000\000\
\\141\007\003\000\088\001\000\000\
\\142\007\000\000\
\\143\007\000\000\
\\144\007\000\000\
\\145\007\000\000\
\\146\007\003\000\093\001\000\000\
\\146\007\003\000\093\001\046\000\092\001\000\000\
\\147\007\000\000\
\\148\007\000\000\
\\149\007\045\000\083\003\000\000\
\\150\007\000\000\
\\151\007\000\000\
\\152\007\000\000\
\\153\007\003\000\226\001\000\000\
\\154\007\000\000\
\\155\007\000\000\
\\156\007\000\000\
\\157\007\003\000\234\001\000\000\
\\157\007\003\000\234\001\022\000\233\001\000\000\
\\158\007\000\000\
\\159\007\000\000\
\\160\007\000\000\
\\161\007\003\000\077\001\041\000\076\001\000\000\
\\162\007\000\000\
\\163\007\000\000\
\\164\007\000\000\
\\165\007\000\000\
\\166\007\000\000\
\\167\007\000\000\
\\168\007\000\000\
\\169\007\000\000\
\\170\007\000\000\
\\171\007\000\000\
\\172\007\000\000\
\\173\007\000\000\
\\174\007\000\000\
\\175\007\000\000\
\\176\007\000\000\
\\177\007\000\000\
\\178\007\000\000\
\\179\007\003\000\080\001\000\000\
\\179\007\003\000\080\001\034\000\249\000\000\000\
\\180\007\000\000\
\\181\007\000\000\
\\182\007\000\000\
\\184\007\000\000\
\\185\007\000\000\
\\186\007\000\000\
\\187\007\000\000\
\\188\007\000\000\
\\189\007\000\000\
\\190\007\000\000\
\\191\007\000\000\
\\192\007\000\000\
\\193\007\000\000\
\\194\007\000\000\
\\195\007\000\000\
\\196\007\000\000\
\\197\007\000\000\
\\198\007\042\000\007\000\060\000\006\000\065\000\005\000\000\000\
\\199\007\042\000\007\000\060\000\006\000\065\000\005\000\000\000\
\\200\007\000\000\
\\201\007\000\000\
\\202\007\060\000\006\000\065\000\005\000\000\000\
\\203\007\000\000\
\\204\007\002\000\069\000\008\000\067\000\011\000\066\000\013\000\064\000\
\\017\000\062\000\018\000\061\000\020\000\059\000\021\000\058\000\
\\024\000\056\000\029\000\053\000\030\000\052\000\042\000\086\000\
\\050\000\045\000\062\000\042\000\063\000\041\000\064\000\040\000\
\\066\000\039\000\067\000\038\000\068\000\037\000\072\000\036\000\
\\074\000\035\000\000\000\
\\205\007\000\000\
\\206\007\000\000\
\\207\007\000\000\
\\208\007\002\000\069\000\006\000\068\000\008\000\067\000\011\000\066\000\
\\012\000\065\000\013\000\064\000\015\000\063\000\017\000\062\000\
\\018\000\061\000\019\000\060\000\020\000\059\000\021\000\058\000\
\\023\000\057\000\024\000\056\000\026\000\055\000\027\000\054\000\
\\029\000\053\000\030\000\052\000\033\000\051\000\034\000\050\000\
\\036\000\049\000\038\000\048\000\042\000\225\000\046\000\047\000\
\\049\000\046\000\050\000\045\000\055\000\044\000\058\000\043\000\
\\062\000\042\000\063\000\041\000\064\000\040\000\066\000\039\000\
\\067\000\038\000\068\000\037\000\072\000\036\000\074\000\035\000\
\\077\000\034\000\078\000\033\000\079\000\032\000\080\000\031\000\
\\081\000\030\000\082\000\029\000\083\000\028\000\084\000\027\000\
\\085\000\026\000\086\000\025\000\087\000\024\000\000\000\
\\208\007\002\000\069\000\006\000\068\000\008\000\067\000\011\000\066\000\
\\012\000\065\000\013\000\064\000\015\000\063\000\017\000\062\000\
\\018\000\061\000\019\000\060\000\020\000\059\000\021\000\058\000\
\\023\000\057\000\024\000\056\000\026\000\055\000\027\000\054\000\
\\029\000\053\000\030\000\052\000\033\000\051\000\034\000\050\000\
\\036\000\049\000\038\000\048\000\046\000\047\000\049\000\046\000\
\\050\000\045\000\055\000\044\000\058\000\043\000\062\000\042\000\
\\063\000\041\000\064\000\040\000\066\000\039\000\067\000\038\000\
\\068\000\037\000\072\000\036\000\074\000\035\000\077\000\034\000\
\\078\000\033\000\079\000\032\000\080\000\031\000\081\000\030\000\
\\082\000\029\000\083\000\028\000\084\000\027\000\085\000\026\000\
\\086\000\025\000\087\000\024\000\000\000\
\\209\007\000\000\
\\210\007\000\000\
\\211\007\000\000\
\"
val actionRowNumbers =
"\087\003\086\003\097\003\027\001\
\\006\003\091\003\090\003\100\003\
\\095\003\128\001\123\001\092\003\
\\046\000\104\001\103\001\101\001\
\\011\001\058\001\074\001\064\001\
\\060\001\073\001\052\001\051\001\
\\001\000\039\001\038\001\040\001\
\\037\001\036\001\035\001\034\001\
\\033\001\157\000\028\001\027\001\
\\012\002\012\002\072\001\071\001\
\\104\000\027\001\087\001\071\001\
\\021\001\059\001\100\001\087\001\
\\054\000\055\000\096\000\012\002\
\\101\000\055\000\027\001\160\000\
\\162\000\122\001\122\001\163\001\
\\163\001\055\000\098\000\101\000\
\\071\001\112\000\055\000\012\002\
\\089\003\056\001\007\003\005\003\
\\014\001\027\001\028\001\027\001\
\\071\001\009\003\071\001\112\000\
\\071\001\071\001\112\000\124\001\
\\096\003\096\003\007\002\055\000\
\\101\000\055\000\102\001\161\000\
\\143\001\065\002\063\002\144\001\
\\082\002\057\001\145\001\113\000\
\\011\002\029\001\135\001\013\002\
\\055\001\032\001\136\001\162\000\
\\105\000\068\001\162\000\027\001\
\\071\001\071\001\115\001\089\001\
\\086\001\127\000\141\001\162\000\
\\078\001\045\001\044\001\043\001\
\\047\001\046\001\133\000\099\001\
\\015\001\132\000\163\000\049\000\
\\048\000\131\000\159\000\158\000\
\\128\000\045\000\114\000\115\000\
\\079\001\041\000\097\000\051\000\
\\241\001\239\001\130\001\210\001\
\\212\001\221\001\101\000\209\001\
\\238\001\221\001\100\000\097\000\
\\160\000\134\001\052\000\099\000\
\\109\001\146\001\161\001\075\001\
\\155\001\048\001\159\001\050\001\
\\049\001\125\001\120\001\078\000\
\\126\001\079\000\162\000\162\001\
\\042\001\041\001\162\000\044\000\
\\101\000\175\001\164\000\173\001\
\\170\001\132\001\053\000\118\001\
\\113\001\142\001\162\000\029\001\
\\157\001\157\001\189\001\054\001\
\\053\001\043\000\029\001\157\001\
\\008\003\023\001\016\003\049\003\
\\017\003\068\003\018\003\020\000\
\\014\003\162\000\010\003\162\000\
\\012\003\029\001\027\003\011\003\
\\015\003\162\000\013\003\029\001\
\\033\003\093\003\098\003\096\003\
\\094\003\030\001\252\001\004\000\
\\250\001\248\001\105\001\254\001\
\\031\001\006\002\007\002\107\001\
\\108\001\106\001\065\001\061\001\
\\165\000\083\000\083\000\166\000\
\\081\002\167\000\113\002\136\002\
\\066\002\180\001\116\000\016\002\
\\106\000\030\001\107\000\137\000\
\\162\000\162\000\027\001\055\000\
\\082\001\197\001\076\001\022\001\
\\098\001\007\002\055\000\081\001\
\\055\000\055\000\085\001\083\001\
\\080\001\055\000\131\001\082\000\
\\097\000\101\000\055\000\007\002\
\\101\000\240\001\223\001\220\001\
\\129\000\243\001\134\000\237\001\
\\234\001\168\000\047\000\227\001\
\\130\000\050\000\117\000\118\000\
\\214\001\165\001\211\001\055\000\
\\160\001\158\001\127\001\122\001\
\\055\000\154\001\153\001\055\000\
\\133\001\055\000\171\001\101\000\
\\168\001\101\000\055\000\116\001\
\\101\000\198\001\190\001\138\001\
\\012\002\137\001\183\001\069\001\
\\012\002\101\000\191\001\108\000\
\\088\003\046\003\084\000\027\001\
\\064\003\067\003\028\001\069\003\
\\138\000\027\001\022\000\023\003\
\\027\003\024\003\112\000\045\003\
\\169\000\028\003\071\001\112\000\
\\099\003\012\001\253\001\062\001\
\\002\000\007\002\007\002\001\002\
\\013\001\066\001\003\000\135\000\
\\005\002\139\000\119\000\120\000\
\\093\000\075\002\170\000\078\002\
\\073\002\070\002\137\002\113\000\
\\068\002\083\000\122\001\061\002\
\\093\000\085\000\114\002\138\002\
\\135\002\121\000\140\000\027\001\
\\028\001\102\000\083\000\027\001\
\\012\002\012\002\072\001\071\001\
\\071\001\141\000\140\002\071\001\
\\012\002\162\000\163\001\163\001\
\\071\001\071\001\112\000\171\000\
\\083\000\176\001\007\002\012\002\
\\014\002\032\001\030\001\152\001\
\\032\001\083\000\196\001\142\000\
\\088\001\143\000\071\001\007\002\
\\136\000\234\001\095\001\022\001\
\\233\001\097\001\092\001\093\001\
\\090\001\111\001\245\001\056\000\
\\057\000\167\001\242\001\244\001\
\\101\000\217\001\213\001\236\001\
\\101\000\216\001\101\000\101\000\
\\219\001\218\001\215\001\114\001\
\\058\000\059\000\042\000\174\001\
\\172\001\169\001\119\001\117\001\
\\208\001\071\001\185\001\071\001\
\\156\001\188\001\162\000\030\001\
\\187\001\112\001\181\001\071\001\
\\122\001\047\003\019\000\016\001\
\\113\000\048\003\065\003\066\003\
\\086\000\071\003\037\003\144\000\
\\071\001\019\003\007\002\071\001\
\\025\003\026\003\041\003\007\002\
\\071\001\071\001\032\003\162\000\
\\031\003\030\001\251\001\249\001\
\\031\001\255\001\007\002\008\002\
\\007\002\000\002\038\002\145\000\
\\005\000\022\002\018\002\122\001\
\\082\000\113\000\121\001\122\001\
\\066\000\093\000\074\002\060\000\
\\002\001\122\000\080\000\040\002\
\\080\002\010\000\017\001\113\000\
\\139\002\103\000\037\002\083\000\
\\157\002\067\002\158\002\082\002\
\\145\002\172\000\031\001\030\001\
\\160\002\159\002\082\002\150\002\
\\029\001\151\002\162\000\109\000\
\\162\000\155\002\162\000\083\000\
\\147\002\162\000\149\002\166\002\
\\162\000\162\000\148\002\156\002\
\\162\000\168\002\168\002\029\001\
\\195\002\095\000\173\000\179\001\
\\178\001\015\002\174\000\146\000\
\\175\000\147\000\007\002\012\002\
\\160\000\195\001\077\001\096\001\
\\094\001\055\000\246\001\247\001\
\\164\001\097\000\222\001\232\001\
\\101\000\231\001\225\001\226\001\
\\224\001\129\001\084\001\055\000\
\\205\001\071\001\160\000\188\001\
\\184\001\196\001\139\001\188\001\
\\061\000\050\003\067\000\003\001\
\\070\003\021\000\018\001\113\000\
\\012\002\039\003\022\003\021\003\
\\044\003\043\003\032\003\029\003\
\\196\001\063\001\067\001\004\002\
\\009\002\010\002\087\000\087\000\
\\042\002\023\002\157\000\062\000\
\\148\000\255\000\123\000\024\002\
\\124\000\082\000\113\000\081\000\
\\077\002\176\000\027\001\031\001\
\\027\001\071\001\071\001\012\002\
\\071\001\071\001\039\002\069\002\
\\083\000\072\002\083\000\084\002\
\\028\001\068\000\004\001\146\002\
\\031\001\030\001\125\000\177\000\
\\088\000\230\002\027\001\143\002\
\\178\000\141\002\179\000\149\000\
\\186\002\110\000\030\001\111\000\
\\199\001\126\000\150\000\165\002\
\\164\002\200\001\153\002\012\002\
\\152\002\196\002\189\002\070\001\
\\012\002\111\002\151\000\014\000\
\\082\000\113\000\095\000\177\001\
\\160\000\007\002\024\001\012\002\
\\180\000\030\001\204\001\091\001\
\\166\001\229\001\156\000\235\001\
\\228\001\110\001\207\001\208\001\
\\186\001\194\001\182\001\140\001\
\\052\003\027\001\031\001\027\001\
\\071\001\071\001\012\002\071\001\
\\071\001\084\000\072\003\070\000\
\\005\001\030\001\020\003\042\003\
\\030\003\036\003\002\002\021\001\
\\006\000\029\002\044\002\113\000\
\\026\002\043\002\041\002\017\002\
\\087\000\093\000\083\000\083\000\
\\019\002\020\002\152\000\000\001\
\\094\000\027\001\064\002\082\002\
\\064\002\160\000\160\000\030\001\
\\160\000\160\000\076\002\063\000\
\\083\002\086\002\027\001\031\001\
\\027\001\071\001\071\001\012\002\
\\071\001\071\001\085\000\144\002\
\\142\002\035\002\027\001\209\002\
\\024\000\062\002\113\000\227\002\
\\089\000\028\001\177\002\176\002\
\\031\001\030\001\090\000\182\002\
\\007\002\012\002\030\001\163\002\
\\032\001\153\000\071\001\036\002\
\\071\001\007\002\208\002\071\001\
\\167\002\191\002\071\001\194\002\
\\162\000\030\001\193\002\029\001\
\\091\000\091\000\116\002\027\001\
\\154\000\001\001\112\002\151\001\
\\150\001\149\001\030\001\025\001\
\\204\001\202\001\071\001\230\001\
\\206\001\192\001\071\001\064\002\
\\082\002\064\002\160\000\160\000\
\\030\001\160\000\160\000\051\003\
\\076\002\074\003\027\001\031\001\
\\027\001\071\001\071\001\012\002\
\\071\001\071\001\086\000\040\003\
\\034\003\071\001\003\002\047\002\
\\072\000\006\001\033\002\046\002\
\\045\002\145\000\028\002\025\002\
\\083\000\094\000\064\000\079\002\
\\181\000\182\000\183\000\184\000\
\\185\000\186\000\187\000\188\000\
\\071\002\064\002\082\002\064\002\
\\160\000\160\000\030\001\160\000\
\\160\000\085\002\076\002\212\002\
\\213\002\027\001\073\000\007\001\
\\228\002\023\000\019\001\113\000\
\\229\002\027\001\174\002\173\002\
\\171\002\170\002\245\002\025\000\
\\020\001\113\000\185\002\184\002\
\\189\000\155\000\012\002\160\000\
\\160\000\181\002\205\002\071\001\
\\160\000\194\002\190\002\196\001\
\\154\002\197\002\118\002\015\000\
\\030\002\113\000\117\002\027\002\
\\115\002\091\000\095\000\190\000\
\\147\001\201\001\203\001\193\001\
\\191\000\192\000\193\000\194\000\
\\195\000\196\000\197\000\198\000\
\\064\002\082\002\064\002\160\000\
\\160\000\030\001\160\000\160\000\
\\073\003\076\002\038\003\035\003\
\\049\002\027\001\031\001\027\001\
\\071\001\071\001\012\002\071\001\
\\071\001\087\000\032\002\031\002\
\\021\002\027\001\092\000\027\001\
\\071\001\071\001\007\002\071\001\
\\071\001\199\000\200\000\201\000\
\\202\000\203\000\204\000\205\000\
\\206\000\210\002\211\002\215\002\
\\027\001\031\001\027\001\071\001\
\\071\001\012\002\071\001\071\001\
\\088\000\231\002\074\000\008\001\
\\175\002\031\001\030\001\247\002\
\\027\001\076\000\009\001\183\002\
\\160\000\007\002\030\001\204\002\
\\181\002\178\002\071\001\207\002\
\\208\002\192\002\200\002\187\002\
\\071\001\121\002\077\000\010\001\
\\120\002\034\002\119\002\151\000\
\\026\001\027\001\092\000\027\001\
\\071\001\071\001\007\002\071\001\
\\071\001\207\000\208\000\209\000\
\\210\000\211\000\212\000\213\000\
\\214\000\064\002\082\002\064\002\
\\160\000\160\000\030\001\160\000\
\\160\000\076\002\048\002\109\002\
\\105\002\108\002\109\002\160\000\
\\160\000\107\002\160\000\160\000\
\\027\001\092\000\027\001\071\001\
\\071\001\007\002\071\001\071\001\
\\064\002\082\002\064\002\160\000\
\\160\000\030\001\160\000\160\000\
\\214\002\076\002\233\002\027\001\
\\031\001\027\001\071\001\071\001\
\\012\002\071\001\071\001\089\000\
\\172\002\169\002\246\002\249\002\
\\027\001\031\001\027\001\071\001\
\\071\001\012\002\071\001\071\001\
\\090\000\162\002\161\002\204\002\
\\202\002\071\001\179\002\180\002\
\\206\002\198\002\071\001\194\002\
\\123\002\027\001\031\001\027\001\
\\071\001\071\001\012\002\071\001\
\\071\001\091\000\148\001\027\000\
\\060\003\026\000\027\000\160\000\
\\160\000\028\000\160\000\160\000\
\\027\001\092\000\027\001\071\001\
\\071\001\007\002\071\001\071\001\
\\215\000\216\000\217\000\218\000\
\\219\000\220\000\221\000\222\000\
\\103\002\065\000\110\002\104\002\
\\107\002\107\002\102\002\107\002\
\\107\002\012\000\094\002\011\000\
\\012\000\160\000\160\000\013\000\
\\160\000\160\000\223\000\224\000\
\\225\000\226\000\227\000\228\000\
\\229\000\230\000\064\002\082\002\
\\064\002\160\000\160\000\030\001\
\\160\000\160\000\232\002\076\002\
\\064\002\082\002\064\002\160\000\
\\160\000\030\001\160\000\160\000\
\\248\002\076\002\201\002\203\002\
\\199\002\188\002\064\002\082\002\
\\064\002\160\000\160\000\030\001\
\\160\000\160\000\122\002\076\002\
\\058\003\061\003\067\000\063\003\
\\059\003\028\000\028\000\057\003\
\\028\000\028\000\030\000\082\003\
\\029\000\030\000\160\000\160\000\
\\031\000\160\000\160\000\027\001\
\\092\000\027\001\071\001\071\001\
\\007\002\071\001\071\001\106\002\
\\100\002\098\002\099\002\101\002\
\\092\002\095\002\069\000\097\002\
\\093\002\013\000\013\000\091\002\
\\013\000\013\000\027\001\092\000\
\\027\001\071\001\071\001\007\002\
\\071\001\071\001\231\000\232\000\
\\233\000\234\000\235\000\236\000\
\\237\000\238\000\239\000\240\000\
\\241\000\242\000\243\000\244\000\
\\245\000\246\000\247\000\248\000\
\\249\000\250\000\251\000\252\000\
\\253\000\254\000\062\003\055\003\
\\053\003\054\003\056\003\080\003\
\\083\003\070\000\085\003\081\003\
\\031\000\031\000\079\003\031\000\
\\031\000\008\000\007\000\057\002\
\\008\000\160\000\160\000\009\000\
\\160\000\160\000\096\002\089\002\
\\087\002\088\002\090\002\033\000\
\\223\002\032\000\033\000\160\000\
\\160\000\034\000\160\000\160\000\
\\027\001\092\000\027\001\071\001\
\\071\001\007\002\071\001\071\001\
\\027\001\092\000\027\001\071\001\
\\071\001\007\002\071\001\071\001\
\\027\001\092\000\027\001\071\001\
\\071\001\007\002\071\001\071\001\
\\084\003\077\003\075\003\076\003\
\\078\003\055\002\058\002\071\000\
\\060\002\056\002\009\000\009\000\
\\054\002\009\000\009\000\221\002\
\\224\002\073\000\226\002\222\002\
\\034\000\034\000\220\002\034\000\
\\034\000\036\000\241\002\035\000\
\\036\000\160\000\160\000\037\000\
\\160\000\160\000\039\000\001\003\
\\038\000\039\000\160\000\160\000\
\\040\000\160\000\160\000\017\000\
\\131\002\016\000\017\000\160\000\
\\160\000\018\000\160\000\160\000\
\\059\002\052\002\050\002\051\002\
\\053\002\225\002\218\002\216\002\
\\217\002\219\002\239\002\242\002\
\\075\000\244\002\240\002\037\000\
\\037\000\238\002\037\000\037\000\
\\255\002\002\003\076\000\004\003\
\\000\003\040\000\040\000\254\002\
\\040\000\040\000\129\002\132\002\
\\077\000\134\002\130\002\018\000\
\\018\000\128\002\018\000\018\000\
\\243\002\236\002\234\002\235\002\
\\237\002\003\003\252\002\250\002\
\\251\002\253\002\133\002\126\002\
\\124\002\125\002\127\002\000\000"
val gotoT =
"\
\\191\000\002\000\192\000\001\000\196\000\171\005\000\000\
\\192\000\006\000\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\025\000\014\000\
\\026\000\013\000\027\000\012\000\032\000\011\000\034\000\010\000\
\\035\000\009\000\193\000\008\000\194\000\007\000\000\000\
\\008\000\068\000\000\000\
\\162\000\072\000\163\000\071\000\164\000\070\000\000\000\
\\000\000\
\\192\000\006\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\032\000\083\000\034\000\010\000\035\000\009\000\000\000\
\\000\000\
\\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\090\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\093\000\090\000\092\000\000\000\
\\009\000\096\000\102\000\095\000\000\000\
\\008\000\099\000\112\000\098\000\000\000\
\\007\000\103\000\048\000\102\000\083\000\101\000\084\000\100\000\000\000\
\\007\000\103\000\048\000\106\000\083\000\101\000\084\000\100\000\000\000\
\\001\000\108\000\015\000\107\000\000\000\
\\015\000\110\000\000\000\
\\000\000\
\\008\000\019\000\013\000\114\000\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\017\000\117\000\
\\018\000\116\000\025\000\014\000\026\000\013\000\027\000\115\000\000\000\
\\015\000\119\000\057\000\118\000\000\000\
\\003\000\120\000\000\000\
\\000\000\
\\001\000\021\000\003\000\130\000\005\000\129\000\008\000\019\000\
\\010\000\018\000\011\000\017\000\013\000\016\000\016\000\128\000\
\\022\000\127\000\023\000\126\000\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\017\000\136\000\
\\018\000\116\000\025\000\014\000\026\000\013\000\027\000\115\000\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\019\000\139\000\
\\021\000\138\000\025\000\014\000\026\000\013\000\027\000\137\000\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\025\000\014\000\
\\026\000\013\000\027\000\141\000\000\000\
\\001\000\148\000\005\000\020\000\007\000\103\000\008\000\019\000\
\\011\000\147\000\013\000\016\000\040\000\146\000\061\000\145\000\
\\071\000\144\000\072\000\143\000\084\000\142\000\000\000\
\\007\000\103\000\048\000\157\000\083\000\101\000\084\000\100\000\000\000\
\\001\000\148\000\005\000\020\000\008\000\019\000\011\000\147\000\
\\013\000\016\000\061\000\145\000\071\000\144\000\072\000\158\000\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\025\000\014\000\
\\026\000\013\000\027\000\160\000\000\000\
\\008\000\019\000\013\000\162\000\038\000\161\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\163\000\011\000\017\000\
\\013\000\016\000\000\000\
\\004\000\166\000\005\000\165\000\037\000\164\000\000\000\
\\031\000\171\000\033\000\170\000\034\000\169\000\035\000\009\000\000\000\
\\031\000\173\000\033\000\170\000\034\000\169\000\035\000\009\000\000\000\
\\002\000\175\000\039\000\174\000\000\000\
\\002\000\175\000\039\000\178\000\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\025\000\014\000\
\\026\000\013\000\027\000\179\000\000\000\
\\001\000\148\000\005\000\020\000\007\000\103\000\008\000\019\000\
\\011\000\147\000\013\000\016\000\042\000\185\000\044\000\184\000\
\\046\000\183\000\047\000\182\000\061\000\145\000\071\000\144\000\
\\072\000\181\000\084\000\180\000\000\000\
\\001\000\148\000\005\000\020\000\008\000\019\000\011\000\147\000\
\\013\000\016\000\028\000\188\000\030\000\187\000\061\000\145\000\
\\071\000\144\000\072\000\186\000\000\000\
\\015\000\190\000\059\000\189\000\000\000\
\\006\000\194\000\007\000\103\000\051\000\193\000\052\000\192\000\
\\084\000\191\000\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\025\000\014\000\
\\026\000\013\000\027\000\197\000\000\000\
\\007\000\103\000\050\000\199\000\083\000\198\000\084\000\100\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\164\000\200\000\000\000\
\\000\000\
\\008\000\203\000\177\000\202\000\000\000\
\\009\000\205\000\183\000\204\000\000\000\
\\008\000\207\000\185\000\206\000\000\000\
\\015\000\209\000\173\000\208\000\000\000\
\\000\000\
\\015\000\211\000\165\000\210\000\000\000\
\\006\000\214\000\007\000\103\000\084\000\213\000\167\000\212\000\000\000\
\\015\000\211\000\165\000\215\000\000\000\
\\015\000\217\000\175\000\216\000\000\000\
\\006\000\220\000\007\000\103\000\084\000\219\000\169\000\218\000\000\000\
\\032\000\083\000\034\000\010\000\035\000\009\000\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\025\000\014\000\
\\026\000\013\000\027\000\012\000\032\000\011\000\034\000\010\000\
\\035\000\009\000\193\000\008\000\194\000\222\000\195\000\221\000\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\025\000\014\000\
\\026\000\013\000\027\000\012\000\032\000\011\000\034\000\010\000\
\\035\000\009\000\193\000\008\000\194\000\222\000\195\000\224\000\000\000\
\\007\000\231\000\073\000\230\000\074\000\229\000\075\000\228\000\
\\076\000\227\000\077\000\226\000\081\000\225\000\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\025\000\014\000\
\\026\000\013\000\027\000\235\000\000\000\
\\001\000\148\000\005\000\020\000\008\000\019\000\011\000\147\000\
\\013\000\016\000\028\000\236\000\030\000\187\000\061\000\145\000\
\\071\000\144\000\072\000\186\000\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\025\000\014\000\
\\026\000\013\000\027\000\237\000\000\000\
\\000\000\
\\004\000\239\000\005\000\165\000\008\000\238\000\000\000\
\\000\000\
\\097\000\240\000\000\000\
\\097\000\243\000\000\000\
\\000\000\
\\089\000\246\000\103\000\245\000\113\000\244\000\000\000\
\\000\000\
\\000\000\
\\089\000\246\000\113\000\248\000\000\000\
\\000\000\
\\006\000\249\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\007\000\251\000\085\000\250\000\000\000\
\\000\000\
\\004\000\252\000\005\000\165\000\000\000\
\\000\000\
\\000\000\
\\004\000\254\000\005\000\165\000\000\000\
\\008\000\255\000\000\000\
\\015\000\000\001\000\000\
\\015\000\001\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\004\000\005\001\005\000\165\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\069\000\008\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\148\000\005\000\020\000\008\000\019\000\011\000\147\000\
\\013\000\016\000\040\000\018\001\061\000\145\000\071\000\144\000\
\\072\000\143\000\000\000\
\\000\000\
\\001\000\148\000\005\000\020\000\008\000\019\000\011\000\147\000\
\\013\000\016\000\061\000\025\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\148\000\005\000\020\000\008\000\019\000\011\000\147\000\
\\013\000\016\000\061\000\145\000\062\000\028\001\063\000\027\001\
\\071\000\144\000\072\000\026\001\000\000\
\\001\000\148\000\005\000\020\000\008\000\019\000\011\000\147\000\
\\013\000\016\000\061\000\145\000\071\000\144\000\072\000\029\001\000\000\
\\000\000\
\\003\000\033\001\005\000\032\001\066\000\031\001\067\000\030\001\000\000\
\\001\000\148\000\005\000\020\000\008\000\019\000\011\000\147\000\
\\013\000\016\000\061\000\145\000\062\000\036\001\063\000\027\001\
\\071\000\144\000\072\000\026\001\000\000\
\\001\000\148\000\005\000\020\000\007\000\251\000\008\000\019\000\
\\011\000\147\000\013\000\016\000\061\000\145\000\064\000\039\001\
\\065\000\038\001\071\000\144\000\072\000\037\001\085\000\250\000\000\000\
\\001\000\148\000\005\000\020\000\008\000\019\000\011\000\147\000\
\\013\000\016\000\040\000\041\001\061\000\145\000\071\000\144\000\
\\072\000\143\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\042\001\011\000\017\000\
\\013\000\016\000\000\000\
\\000\000\
\\000\000\
\\001\000\148\000\005\000\020\000\008\000\019\000\011\000\147\000\
\\013\000\016\000\061\000\145\000\064\000\039\001\065\000\038\001\
\\071\000\144\000\072\000\037\001\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\013\000\162\000\038\000\044\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\004\000\166\000\005\000\165\000\037\000\045\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\033\000\046\001\034\000\169\000\035\000\009\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\004\000\166\000\005\000\165\000\037\000\049\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\004\000\166\000\005\000\165\000\037\000\050\001\000\000\
\\000\000\
\\001\000\148\000\005\000\020\000\008\000\019\000\011\000\147\000\
\\013\000\016\000\042\000\052\001\044\000\184\000\046\000\183\000\
\\047\000\182\000\061\000\145\000\071\000\144\000\072\000\181\000\000\000\
\\000\000\
\\000\000\
\\045\000\054\001\000\000\
\\043\000\056\001\000\000\
\\000\000\
\\000\000\
\\029\000\059\001\000\000\
\\000\000\
\\000\000\
\\004\000\061\001\005\000\165\000\000\000\
\\006\000\062\001\000\000\
\\036\000\063\001\000\000\
\\036\000\065\001\000\000\
\\053\000\066\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\006\000\070\001\000\000\
\\036\000\071\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\178\000\073\001\000\000\
\\000\000\
\\089\000\246\000\113\000\077\001\184\000\076\001\000\000\
\\000\000\
\\089\000\246\000\103\000\080\001\113\000\244\000\186\000\079\001\000\000\
\\000\000\
\\004\000\082\001\005\000\165\000\000\000\
\\000\000\
\\004\000\083\001\005\000\165\000\000\000\
\\000\000\
\\006\000\084\001\000\000\
\\168\000\085\001\000\000\
\\000\000\
\\000\000\
\\004\000\087\001\005\000\165\000\000\000\
\\000\000\
\\006\000\088\001\000\000\
\\170\000\089\001\000\000\
\\000\000\
\\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\025\000\014\000\
\\026\000\013\000\027\000\012\000\032\000\011\000\034\000\010\000\
\\035\000\009\000\193\000\008\000\194\000\222\000\195\000\092\001\000\000\
\\000\000\
\\006\000\095\001\008\000\019\000\012\000\094\001\013\000\093\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\099\001\000\000\
\\003\000\105\001\078\000\104\001\079\000\103\001\000\000\
\\007\000\231\000\073\000\107\001\074\000\229\000\075\000\228\000\
\\076\000\227\000\077\000\226\000\081\000\225\000\082\000\106\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\110\001\101\000\109\001\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\119\001\101\000\109\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\089\000\246\000\113\000\122\001\000\000\
\\008\000\126\001\120\000\125\001\121\000\124\001\122\000\123\001\000\000\
\\097\000\147\001\000\000\
\\049\000\149\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\006\000\095\001\008\000\019\000\012\000\155\001\013\000\093\001\000\000\
\\000\000\
\\000\000\
\\004\000\158\001\005\000\165\000\000\000\
\\004\000\159\001\005\000\165\000\000\000\
\\008\000\238\000\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\018\000\160\001\
\\025\000\014\000\026\000\013\000\027\000\115\000\000\000\
\\000\000\
\\056\000\161\001\000\000\
\\000\000\
\\003\000\130\000\005\000\165\001\022\000\164\001\000\000\
\\024\000\166\001\000\000\
\\007\000\231\000\073\000\168\001\074\000\229\000\075\000\228\000\
\\076\000\227\000\077\000\226\000\081\000\225\000\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\025\000\014\000\
\\026\000\013\000\027\000\169\001\000\000\
\\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\020\000\171\001\
\\025\000\014\000\026\000\013\000\027\000\170\001\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\018\000\172\001\
\\025\000\014\000\026\000\013\000\027\000\115\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\025\000\014\000\
\\026\000\013\000\027\000\173\001\000\000\
\\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\174\001\000\000\
\\001\000\148\000\005\000\020\000\008\000\019\000\011\000\147\000\
\\013\000\016\000\040\000\175\001\061\000\145\000\071\000\144\000\
\\072\000\143\000\000\000\
\\001\000\148\000\005\000\020\000\008\000\019\000\011\000\147\000\
\\013\000\016\000\042\000\176\001\044\000\184\000\046\000\183\000\
\\047\000\182\000\061\000\145\000\071\000\144\000\072\000\181\000\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\025\000\014\000\
\\026\000\013\000\027\000\177\001\000\000\
\\007\000\231\000\073\000\178\001\074\000\229\000\075\000\228\000\
\\076\000\227\000\077\000\226\000\081\000\225\000\000\000\
\\001\000\148\000\005\000\020\000\008\000\019\000\011\000\147\000\
\\013\000\016\000\061\000\145\000\071\000\144\000\072\000\179\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\069\000\183\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\025\000\014\000\
\\026\000\013\000\027\000\191\001\000\000\
\\000\000\
\\000\000\
\\033\000\046\001\034\000\169\000\035\000\009\000\000\000\
\\031\000\192\001\033\000\170\000\034\000\169\000\035\000\009\000\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\020\000\193\001\
\\025\000\014\000\026\000\013\000\027\000\170\001\000\000\
\\000\000\
\\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\025\000\014\000\
\\026\000\013\000\027\000\194\001\000\000\
\\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\025\000\014\000\
\\026\000\013\000\027\000\195\001\000\000\
\\000\000\
\\001\000\148\000\005\000\020\000\008\000\019\000\011\000\147\000\
\\013\000\016\000\044\000\196\001\046\000\183\000\047\000\182\000\
\\061\000\145\000\071\000\144\000\072\000\181\000\000\000\
\\000\000\
\\001\000\148\000\005\000\020\000\008\000\019\000\011\000\147\000\
\\013\000\016\000\042\000\197\001\044\000\184\000\046\000\183\000\
\\047\000\182\000\061\000\145\000\071\000\144\000\072\000\181\000\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\025\000\014\000\
\\026\000\013\000\027\000\198\001\000\000\
\\000\000\
\\001\000\148\000\005\000\020\000\008\000\019\000\011\000\147\000\
\\013\000\016\000\028\000\199\001\030\000\187\000\061\000\145\000\
\\071\000\144\000\072\000\186\000\000\000\
\\056\000\200\001\000\000\
\\053\000\202\001\000\000\
\\000\000\
\\007\000\103\000\048\000\204\001\083\000\101\000\084\000\100\000\000\000\
\\000\000\
\\000\000\
\\015\000\206\001\054\000\205\001\000\000\
\\007\000\103\000\050\000\208\001\083\000\198\000\084\000\100\000\000\000\
\\001\000\148\000\005\000\020\000\008\000\019\000\011\000\147\000\
\\013\000\016\000\028\000\209\001\030\000\187\000\061\000\145\000\
\\071\000\144\000\072\000\186\000\000\000\
\\053\000\210\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\215\001\101\000\214\001\
\\179\000\213\001\000\000\
\\008\000\203\000\177\000\217\001\000\000\
\\000\000\
\\184\000\218\001\000\000\
\\009\000\205\000\183\000\219\001\000\000\
\\000\000\
\\000\000\
\\008\000\207\000\185\000\221\001\000\000\
\\056\000\223\001\174\000\222\001\000\000\
\\166\000\225\001\000\000\
\\168\000\228\001\000\000\
\\000\000\
\\006\000\214\000\007\000\103\000\084\000\213\000\167\000\229\001\000\000\
\\176\000\230\001\000\000\
\\000\000\
\\000\000\
\\015\000\235\001\171\000\234\001\000\000\
\\006\000\220\000\007\000\103\000\084\000\219\000\169\000\236\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\007\000\231\000\075\000\238\001\076\000\227\000\077\000\226\000\
\\081\000\225\000\000\000\
\\007\000\231\000\073\000\239\001\074\000\229\000\075\000\228\000\
\\076\000\227\000\077\000\226\000\081\000\225\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\013\000\250\001\086\000\249\001\087\000\248\001\
\\088\000\247\001\092\000\246\001\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\013\000\250\001\086\000\002\002\000\000\
\\000\000\
\\000\000\
\\120\000\003\002\121\000\124\001\122\000\123\001\000\000\
\\089\000\004\002\000\000\
\\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\005\002\101\000\109\001\000\000\
\\031\000\006\002\033\000\170\000\034\000\169\000\035\000\009\000\000\000\
\\000\000\
\\008\000\019\000\013\000\250\001\086\000\249\001\087\000\248\001\
\\088\000\247\001\092\000\007\002\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\010\002\101\000\009\002\
\\105\000\008\002\000\000\
\\000\000\
\\000\000\
\\122\000\012\002\000\000\
\\000\000\
\\000\000\
\\008\000\017\002\144\000\016\002\000\000\
\\009\000\019\002\150\000\018\002\000\000\
\\008\000\019\000\013\000\021\002\129\000\020\002\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\024\002\101\000\109\001\000\000\
\\008\000\026\002\156\000\025\002\000\000\
\\007\000\103\000\083\000\028\002\084\000\100\000\132\000\027\002\000\000\
\\007\000\103\000\083\000\028\002\084\000\100\000\132\000\029\002\000\000\
\\001\000\031\002\015\000\030\002\000\000\
\\015\000\032\002\000\000\
\\015\000\034\002\140\000\033\002\000\000\
\\000\000\
\\000\000\
\\015\000\037\002\130\000\036\002\000\000\
\\007\000\103\000\083\000\028\002\084\000\100\000\132\000\038\002\000\000\
\\004\000\166\000\005\000\165\000\037\000\039\002\000\000\
\\002\000\175\000\039\000\040\002\000\000\
\\002\000\175\000\039\000\041\002\000\000\
\\015\000\037\002\130\000\042\002\000\000\
\\015\000\044\002\142\000\043\002\000\000\
\\006\000\048\002\007\000\103\000\084\000\047\002\135\000\046\002\
\\136\000\045\002\000\000\
\\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\050\002\101\000\109\001\000\000\
\\000\000\
\\007\000\231\000\073\000\051\002\074\000\229\000\075\000\228\000\
\\076\000\227\000\077\000\226\000\081\000\225\000\000\000\
\\007\000\103\000\048\000\052\002\083\000\101\000\084\000\100\000\000\000\
\\000\000\
\\007\000\251\000\085\000\053\002\000\000\
\\006\000\095\001\008\000\019\000\012\000\054\002\013\000\093\001\000\000\
\\000\000\
\\007\000\055\002\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\056\002\101\000\109\001\000\000\
\\056\000\057\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\015\000\060\002\000\000\
\\007\000\231\000\073\000\061\002\074\000\229\000\075\000\228\000\
\\076\000\227\000\077\000\226\000\081\000\225\000\000\000\
\\000\000\
\\069\000\008\001\000\000\
\\000\000\
\\003\000\130\000\005\000\165\001\022\000\063\002\000\000\
\\000\000\
\\024\000\064\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\041\000\068\002\000\000\
\\000\000\
\\000\000\
\\001\000\148\000\005\000\020\000\008\000\019\000\011\000\147\000\
\\013\000\016\000\061\000\145\000\063\000\070\002\071\000\144\000\
\\072\000\026\001\000\000\
\\000\000\
\\000\000\
\\070\000\071\002\000\000\
\\001\000\148\000\005\000\020\000\008\000\019\000\011\000\147\000\
\\013\000\016\000\061\000\145\000\071\000\144\000\072\000\073\002\000\000\
\\000\000\
\\001\000\148\000\005\000\020\000\008\000\019\000\011\000\147\000\
\\013\000\016\000\061\000\145\000\065\000\075\002\071\000\144\000\
\\072\000\074\002\000\000\
\\001\000\148\000\005\000\020\000\008\000\019\000\011\000\147\000\
\\013\000\016\000\061\000\145\000\063\000\076\002\071\000\144\000\
\\072\000\026\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\060\000\080\002\000\000\
\\015\000\082\002\000\000\
\\000\000\
\\015\000\206\001\054\000\083\002\000\000\
\\000\000\
\\053\000\084\002\000\000\
\\004\000\085\002\005\000\165\000\000\000\
\\006\000\095\001\008\000\019\000\012\000\086\002\013\000\093\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\015\000\206\001\054\000\087\002\000\000\
\\031\000\088\002\033\000\170\000\034\000\169\000\035\000\009\000\000\000\
\\000\000\
\\178\000\089\002\000\000\
\\000\000\
\\089\000\091\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\094\002\101\000\093\002\
\\187\000\092\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\015\000\209\000\173\000\097\002\000\000\
\\000\000\
\\007\000\231\000\073\000\098\002\074\000\229\000\075\000\228\000\
\\076\000\227\000\077\000\226\000\081\000\225\000\000\000\
\\015\000\211\000\165\000\099\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\007\000\231\000\073\000\100\002\074\000\229\000\075\000\228\000\
\\076\000\227\000\077\000\226\000\081\000\225\000\000\000\
\\015\000\217\000\175\000\101\002\000\000\
\\015\000\235\001\171\000\102\002\000\000\
\\170\000\103\002\000\000\
\\004\000\104\002\005\000\165\000\000\000\
\\000\000\
\\006\000\105\002\008\000\238\000\000\000\
\\000\000\
\\000\000\
\\008\000\238\000\009\000\106\002\000\000\
\\000\000\
\\007\000\231\000\073\000\107\002\074\000\229\000\075\000\228\000\
\\076\000\227\000\077\000\226\000\081\000\225\000\000\000\
\\000\000\
\\007\000\231\000\073\000\109\002\074\000\229\000\075\000\228\000\
\\076\000\227\000\077\000\226\000\081\000\225\000\082\000\108\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\013\000\250\001\086\000\113\002\091\000\112\002\000\000\
\\000\000\
\\000\000\
\\031\000\115\002\033\000\170\000\034\000\169\000\035\000\009\000\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\025\000\014\000\
\\026\000\116\002\000\000\
\\089\000\117\002\000\000\
\\008\000\019\000\013\000\250\001\031\000\120\002\033\000\170\000\
\\034\000\169\000\035\000\009\000\086\000\249\001\087\000\119\002\
\\088\000\118\002\000\000\
\\031\000\123\002\033\000\170\000\034\000\169\000\035\000\009\000\000\000\
\\008\000\019\000\013\000\125\002\109\000\124\002\000\000\
\\008\000\019\000\013\000\250\001\086\000\249\001\087\000\248\001\
\\088\000\247\001\092\000\134\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\104\000\139\002\000\000\
\\000\000\
\\089\000\142\002\000\000\
\\000\000\
\\008\000\019\000\013\000\021\002\129\000\143\002\000\000\
\\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\146\002\101\000\109\001\000\000\
\\000\000\
\\097\000\147\002\000\000\
\\000\000\
\\089\000\246\000\103\000\149\002\113\000\244\000\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\152\002\
\\127\000\151\002\000\000\
\\006\000\095\001\008\000\019\000\012\000\154\002\013\000\093\001\
\\125\000\153\002\000\000\
\\000\000\
\\000\000\
\\089\000\246\000\103\000\155\002\113\000\244\000\000\000\
\\000\000\
\\006\000\156\002\000\000\
\\000\000\
\\004\000\157\002\005\000\165\000\000\000\
\\000\000\
\\004\000\159\002\005\000\165\000\000\000\
\\000\000\
\\004\000\160\002\005\000\165\000\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\161\002\101\000\109\001\000\000\
\\000\000\
\\004\000\162\002\005\000\165\000\000\000\
\\000\000\
\\000\000\
\\004\000\166\000\005\000\165\000\037\000\163\002\000\000\
\\004\000\166\000\005\000\165\000\037\000\164\002\000\000\
\\000\000\
\\000\000\
\\004\000\165\002\005\000\165\000\000\000\
\\123\000\166\002\000\000\
\\123\000\168\002\000\000\
\\006\000\169\002\000\000\
\\137\000\170\002\000\000\
\\008\000\019\000\013\000\250\001\086\000\249\001\087\000\175\002\
\\088\000\174\002\115\000\173\002\000\000\
\\000\000\
\\049\000\179\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\007\000\231\000\073\000\184\002\074\000\229\000\075\000\228\000\
\\076\000\227\000\077\000\226\000\081\000\225\000\000\000\
\\007\000\103\000\083\000\185\002\084\000\100\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\186\002\011\000\017\000\
\\013\000\016\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\020\000\187\002\
\\025\000\014\000\026\000\013\000\027\000\170\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\148\000\005\000\020\000\008\000\019\000\011\000\147\000\
\\013\000\016\000\040\000\188\002\061\000\145\000\071\000\144\000\
\\072\000\143\000\000\000\
\\000\000\
\\068\000\189\002\000\000\
\\001\000\148\000\005\000\020\000\008\000\019\000\011\000\147\000\
\\013\000\016\000\061\000\145\000\071\000\144\000\072\000\191\002\000\000\
\\068\000\192\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\025\000\014\000\
\\026\000\013\000\027\000\193\002\000\000\
\\000\000\
\\015\000\190\000\059\000\194\002\000\000\
\\005\000\020\000\008\000\019\000\010\000\195\002\011\000\017\000\
\\013\000\016\000\000\000\
\\053\000\196\002\000\000\
\\000\000\
\\056\000\197\002\000\000\
\\000\000\
\\053\000\198\002\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\013\000\125\002\109\000\124\002\180\000\200\002\000\000\
\\000\000\
\\000\000\
\\186\000\210\002\000\000\
\\000\000\
\\089\000\212\002\000\000\
\\007\000\103\000\083\000\213\002\084\000\100\000\000\000\
\\000\000\
\\166\000\214\002\000\000\
\\000\000\
\\176\000\215\002\000\000\
\\000\000\
\\170\000\216\002\000\000\
\\000\000\
\\056\000\217\002\000\000\
\\000\000\
\\000\000\
\\080\000\218\002\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\093\000\222\002\098\000\112\001\099\000\111\001\100\000\221\002\
\\101\000\220\002\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\093\000\225\002\098\000\112\001\099\000\111\001\100\000\224\002\
\\101\000\220\002\000\000\
\\000\000\
\\000\000\
\\008\000\093\000\090\000\226\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\013\000\250\001\086\000\113\002\000\000\
\\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\025\000\014\000\
\\026\000\234\002\000\000\
\\089\000\235\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\013\000\238\002\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\239\002\000\000\
\\008\000\019\000\013\000\240\002\000\000\
\\015\000\241\002\000\000\
\\015\000\242\002\000\000\
\\007\000\103\000\083\000\243\002\084\000\100\000\000\000\
\\015\000\244\002\000\000\
\\015\000\245\002\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\246\002\101\000\109\001\000\000\
\\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\247\002\101\000\109\001\000\000\
\\000\000\
\\009\000\096\000\102\000\248\002\000\000\
\\008\000\019\000\013\000\125\002\106\000\249\002\109\000\124\002\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\152\002\
\\127\000\003\003\000\000\
\\006\000\095\001\008\000\019\000\012\000\154\002\013\000\093\001\
\\125\000\004\003\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\009\003\101\000\008\003\
\\146\000\007\003\000\000\
\\151\000\011\003\000\000\
\\008\000\019\000\013\000\015\003\128\000\014\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\133\000\019\003\000\000\
\\000\000\
\\006\000\095\001\008\000\019\000\012\000\023\003\013\000\093\001\000\000\
\\000\000\
\\056\000\025\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\056\000\030\003\000\000\
\\000\000\
\\007\000\103\000\083\000\028\002\084\000\100\000\132\000\032\003\000\000\
\\000\000\
\\137\000\033\003\000\000\
\\000\000\
\\015\000\036\003\138\000\035\003\000\000\
\\007\000\103\000\083\000\039\003\084\000\100\000\134\000\038\003\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\013\000\250\001\086\000\113\002\114\000\042\003\000\000\
\\001\000\021\000\005\000\020\000\008\000\019\000\010\000\018\000\
\\011\000\017\000\013\000\016\000\016\000\015\000\025\000\014\000\
\\026\000\044\003\000\000\
\\089\000\045\003\000\000\
\\008\000\019\000\013\000\250\001\086\000\249\001\087\000\175\002\
\\088\000\174\002\115\000\046\003\000\000\
\\000\000\
\\005\000\020\000\008\000\019\000\010\000\047\003\011\000\017\000\
\\013\000\016\000\000\000\
\\007\000\231\000\073\000\048\003\074\000\229\000\075\000\228\000\
\\076\000\227\000\077\000\226\000\081\000\225\000\000\000\
\\000\000\
\\007\000\103\000\083\000\050\003\084\000\100\000\000\000\
\\000\000\
\\006\000\095\001\008\000\019\000\012\000\052\003\013\000\093\001\000\000\
\\058\000\053\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\003\000\033\001\005\000\032\001\066\000\055\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\060\000\056\003\000\000\
\\000\000\
\\055\000\057\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\013\000\059\003\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\060\003\000\000\
\\008\000\019\000\013\000\061\003\000\000\
\\015\000\062\003\000\000\
\\015\000\063\003\000\000\
\\007\000\103\000\083\000\064\003\084\000\100\000\000\000\
\\015\000\065\003\000\000\
\\015\000\066\003\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\068\003\101\000\214\001\
\\179\000\067\003\000\000\
\\000\000\
\\008\000\019\000\013\000\125\002\109\000\124\002\188\000\069\003\000\000\
\\000\000\
\\006\000\095\001\008\000\019\000\012\000\079\003\013\000\093\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\172\000\080\003\000\000\
\\000\000\
\\003\000\105\001\078\000\082\003\000\000\
\\091\000\083\003\000\000\
\\000\000\
\\000\000\
\\089\000\085\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\093\000\087\003\098\000\112\001\099\000\111\001\100\000\086\003\
\\101\000\220\002\000\000\
\\008\000\019\000\013\000\250\001\086\000\249\001\087\000\248\001\
\\088\000\089\003\092\000\088\003\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\090\003\101\000\109\001\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\091\003\101\000\109\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\013\000\250\001\086\000\249\001\087\000\119\002\
\\088\000\094\003\000\000\
\\008\000\019\000\013\000\095\003\000\000\
\\097\000\096\003\000\000\
\\089\000\246\000\103\000\097\003\113\000\244\000\000\000\
\\097\000\098\003\000\000\
\\005\000\020\000\008\000\019\000\010\000\099\003\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\100\003\011\000\017\000\
\\013\000\016\000\000\000\
\\006\000\095\001\008\000\019\000\012\000\101\003\013\000\093\001\000\000\
\\005\000\020\000\008\000\019\000\010\000\102\003\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\103\003\011\000\017\000\
\\013\000\016\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\013\000\105\003\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\106\003\000\000\
\\008\000\019\000\013\000\107\003\000\000\
\\015\000\108\003\000\000\
\\015\000\109\003\000\000\
\\007\000\103\000\083\000\110\003\084\000\100\000\000\000\
\\015\000\111\003\000\000\
\\015\000\112\003\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\114\003\101\000\009\002\
\\105\000\113\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\013\000\115\003\000\000\
\\000\000\
\\145\000\116\003\000\000\
\\000\000\
\\089\000\119\003\000\000\
\\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\122\003\101\000\121\003\
\\152\000\120\003\000\000\
\\009\000\019\002\150\000\124\003\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\127\003\
\\126\000\126\003\000\000\
\\006\000\095\001\008\000\019\000\012\000\129\003\013\000\093\001\
\\124\000\128\003\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\132\003\101\000\131\003\
\\158\000\130\003\000\000\
\\000\000\
\\007\000\231\000\073\000\134\003\074\000\229\000\075\000\228\000\
\\076\000\227\000\077\000\226\000\081\000\225\000\000\000\
\\007\000\103\000\083\000\028\002\084\000\100\000\132\000\135\003\000\000\
\\006\000\095\001\008\000\019\000\012\000\136\003\013\000\093\001\000\000\
\\000\000\
\\007\000\137\003\000\000\
\\000\000\
\\015\000\139\003\000\000\
\\000\000\
\\015\000\140\003\000\000\
\\007\000\231\000\073\000\141\003\074\000\229\000\075\000\228\000\
\\076\000\227\000\077\000\226\000\081\000\225\000\000\000\
\\143\000\142\003\000\000\
\\015\000\144\003\000\000\
\\000\000\
\\000\000\
\\015\000\036\003\138\000\145\003\000\000\
\\137\000\146\003\000\000\
\\004\000\147\003\005\000\165\000\000\000\
\\006\000\095\001\008\000\019\000\012\000\148\003\013\000\093\001\000\000\
\\000\000\
\\006\000\149\003\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\152\003\101\000\151\003\
\\116\000\150\003\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\155\003\101\000\151\003\
\\116\000\154\003\000\000\
\\000\000\
\\008\000\099\000\112\000\156\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\006\000\095\001\008\000\019\000\012\000\159\003\013\000\093\001\000\000\
\\000\000\
\\058\000\161\003\000\000\
\\000\000\
\\015\000\119\000\057\000\162\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\015\000\206\001\054\000\163\003\000\000\
\\097\000\164\003\000\000\
\\089\000\246\000\103\000\165\003\113\000\244\000\000\000\
\\097\000\166\003\000\000\
\\005\000\020\000\008\000\019\000\010\000\167\003\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\168\003\011\000\017\000\
\\013\000\016\000\000\000\
\\006\000\095\001\008\000\019\000\012\000\169\003\013\000\093\001\000\000\
\\005\000\020\000\008\000\019\000\010\000\170\003\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\171\003\011\000\017\000\
\\013\000\016\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\013\000\172\003\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\173\003\000\000\
\\008\000\019\000\013\000\174\003\000\000\
\\015\000\175\003\000\000\
\\015\000\176\003\000\000\
\\007\000\103\000\083\000\177\003\084\000\100\000\000\000\
\\015\000\178\003\000\000\
\\015\000\179\003\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\181\003\101\000\093\002\
\\187\000\180\003\000\000\
\\174\000\182\003\000\000\
\\000\000\
\\015\000\235\001\171\000\183\003\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\013\000\125\002\094\000\184\003\109\000\124\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\194\003\101\000\109\001\000\000\
\\008\000\019\000\013\000\250\001\086\000\249\001\087\000\119\002\
\\088\000\195\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\097\000\205\003\000\000\
\\089\000\246\000\103\000\206\003\113\000\244\000\000\000\
\\097\000\207\003\000\000\
\\005\000\020\000\008\000\019\000\010\000\208\003\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\209\003\011\000\017\000\
\\013\000\016\000\000\000\
\\006\000\095\001\008\000\019\000\012\000\210\003\013\000\093\001\000\000\
\\005\000\020\000\008\000\019\000\010\000\211\003\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\212\003\011\000\017\000\
\\013\000\016\000\000\000\
\\000\000\
\\000\000\
\\145\000\213\003\000\000\
\\000\000\
\\008\000\017\002\144\000\214\003\000\000\
\\008\000\019\000\013\000\125\002\109\000\124\002\147\000\215\003\000\000\
\\000\000\
\\000\000\
\\151\000\225\003\000\000\
\\000\000\
\\089\000\227\003\000\000\
\\000\000\
\\008\000\019\000\013\000\015\003\128\000\228\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\157\000\231\003\000\000\
\\000\000\
\\089\000\234\003\000\000\
\\133\000\235\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\007\000\103\000\083\000\238\003\084\000\100\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\239\003\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\240\003\011\000\017\000\
\\013\000\016\000\000\000\
\\131\000\241\003\000\000\
\\000\000\
\\015\000\044\002\142\000\243\003\000\000\
\\005\000\020\000\008\000\019\000\010\000\244\003\011\000\017\000\
\\013\000\016\000\000\000\
\\137\000\245\003\000\000\
\\000\000\
\\056\000\246\003\000\000\
\\000\000\
\\137\000\247\003\000\000\
\\000\000\
\\114\000\249\003\000\000\
\\000\000\
\\089\000\251\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\253\003\101\000\151\003\
\\116\000\252\003\000\000\
\\008\000\019\000\013\000\250\001\086\000\249\001\087\000\175\002\
\\088\000\255\003\115\000\254\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\097\000\009\004\000\000\
\\089\000\246\000\103\000\010\004\113\000\244\000\000\000\
\\097\000\011\004\000\000\
\\005\000\020\000\008\000\019\000\010\000\012\004\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\013\004\011\000\017\000\
\\013\000\016\000\000\000\
\\006\000\095\001\008\000\019\000\012\000\014\004\013\000\093\001\000\000\
\\005\000\020\000\008\000\019\000\010\000\015\004\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\016\004\011\000\017\000\
\\013\000\016\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\013\000\017\004\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\018\004\000\000\
\\008\000\019\000\013\000\019\004\000\000\
\\015\000\020\004\000\000\
\\015\000\021\004\000\000\
\\007\000\103\000\083\000\022\004\084\000\100\000\000\000\
\\015\000\023\004\000\000\
\\015\000\024\004\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\093\000\026\004\098\000\112\001\099\000\111\001\100\000\025\004\
\\101\000\220\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\013\000\027\004\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\029\004\111\000\028\004\000\000\
\\008\000\019\000\013\000\030\004\000\000\
\\015\000\031\004\000\000\
\\015\000\032\004\000\000\
\\007\000\231\000\073\000\033\004\074\000\229\000\075\000\228\000\
\\076\000\227\000\077\000\226\000\081\000\225\000\000\000\
\\015\000\034\004\000\000\
\\015\000\035\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\013\000\044\004\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\045\004\000\000\
\\008\000\019\000\013\000\046\004\000\000\
\\015\000\047\004\000\000\
\\015\000\048\004\000\000\
\\007\000\103\000\083\000\049\004\084\000\100\000\000\000\
\\015\000\050\004\000\000\
\\015\000\051\004\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\053\004\101\000\008\003\
\\146\000\052\004\000\000\
\\000\000\
\\008\000\019\000\013\000\125\002\109\000\124\002\153\000\054\004\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\127\003\
\\126\000\064\004\000\000\
\\006\000\095\001\008\000\019\000\012\000\129\003\013\000\093\001\
\\124\000\065\004\000\000\
\\000\000\
\\008\000\026\002\156\000\066\004\000\000\
\\008\000\019\000\013\000\125\002\109\000\124\002\159\000\067\004\000\000\
\\000\000\
\\000\000\
\\005\000\020\000\008\000\019\000\010\000\077\004\011\000\017\000\
\\013\000\016\000\000\000\
\\007\000\231\000\073\000\078\004\074\000\229\000\075\000\228\000\
\\076\000\227\000\077\000\226\000\081\000\225\000\000\000\
\\006\000\095\001\008\000\019\000\012\000\079\004\013\000\093\001\000\000\
\\141\000\080\004\000\000\
\\131\000\082\004\000\000\
\\000\000\
\\015\000\037\002\130\000\083\004\000\000\
\\000\000\
\\143\000\084\004\000\000\
\\000\000\
\\139\000\085\004\000\000\
\\000\000\
\\015\000\036\003\138\000\087\004\000\000\
\\000\000\
\\008\000\019\000\013\000\125\002\109\000\124\002\117\000\088\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\013\000\099\004\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\101\004\111\000\028\004\182\000\100\004\000\000\
\\008\000\019\000\013\000\102\004\000\000\
\\015\000\103\004\000\000\
\\015\000\104\004\000\000\
\\007\000\231\000\073\000\105\004\074\000\229\000\075\000\228\000\
\\076\000\227\000\077\000\226\000\081\000\225\000\000\000\
\\015\000\106\004\000\000\
\\015\000\107\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\097\000\116\004\000\000\
\\089\000\246\000\103\000\117\004\113\000\244\000\000\000\
\\097\000\118\004\000\000\
\\005\000\020\000\008\000\019\000\010\000\119\004\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\120\004\011\000\017\000\
\\013\000\016\000\000\000\
\\006\000\095\001\008\000\019\000\012\000\121\004\013\000\093\001\000\000\
\\005\000\020\000\008\000\019\000\010\000\122\004\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\123\004\011\000\017\000\
\\013\000\016\000\000\000\
\\000\000\
\\000\000\
\\110\000\124\004\000\000\
\\000\000\
\\008\000\019\000\013\000\250\001\086\000\002\002\110\000\126\004\000\000\
\\110\000\127\004\000\000\
\\005\000\020\000\008\000\019\000\010\000\128\004\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\129\004\011\000\017\000\
\\013\000\016\000\000\000\
\\110\000\130\004\000\000\
\\005\000\020\000\008\000\019\000\010\000\131\004\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\132\004\011\000\017\000\
\\013\000\016\000\000\000\
\\008\000\019\000\013\000\133\004\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\135\004\108\000\134\004\111\000\028\004\000\000\
\\008\000\019\000\013\000\136\004\000\000\
\\015\000\137\004\000\000\
\\015\000\138\004\000\000\
\\007\000\231\000\073\000\139\004\074\000\229\000\075\000\228\000\
\\076\000\227\000\077\000\226\000\081\000\225\000\000\000\
\\015\000\140\004\000\000\
\\015\000\141\004\000\000\
\\097\000\142\004\000\000\
\\089\000\246\000\103\000\143\004\113\000\244\000\000\000\
\\097\000\144\004\000\000\
\\005\000\020\000\008\000\019\000\010\000\145\004\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\146\004\011\000\017\000\
\\013\000\016\000\000\000\
\\006\000\095\001\008\000\019\000\012\000\147\004\013\000\093\001\000\000\
\\005\000\020\000\008\000\019\000\010\000\148\004\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\149\004\011\000\017\000\
\\013\000\016\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\013\000\150\004\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\151\004\000\000\
\\008\000\019\000\013\000\152\004\000\000\
\\015\000\153\004\000\000\
\\015\000\154\004\000\000\
\\007\000\103\000\083\000\155\004\084\000\100\000\000\000\
\\015\000\156\004\000\000\
\\015\000\157\004\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\159\004\101\000\121\003\
\\152\000\158\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\019\000\013\000\160\004\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\161\004\000\000\
\\008\000\019\000\013\000\162\004\000\000\
\\015\000\163\004\000\000\
\\015\000\164\004\000\000\
\\007\000\103\000\083\000\165\004\084\000\100\000\000\000\
\\015\000\166\004\000\000\
\\015\000\167\004\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\169\004\101\000\131\003\
\\158\000\168\004\000\000\
\\000\000\
\\000\000\
\\141\000\170\004\000\000\
\\000\000\
\\015\000\034\002\140\000\171\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\015\000\036\003\138\000\172\004\000\000\
\\137\000\173\004\000\000\
\\000\000\
\\008\000\019\000\013\000\174\004\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\175\004\000\000\
\\008\000\019\000\013\000\176\004\000\000\
\\015\000\177\004\000\000\
\\015\000\178\004\000\000\
\\007\000\103\000\083\000\179\004\084\000\100\000\000\000\
\\015\000\180\004\000\000\
\\015\000\181\004\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\111\001\100\000\183\004\101\000\151\003\
\\116\000\182\004\000\000\
\\000\000\
\\110\000\124\004\178\000\185\004\181\000\184\004\000\000\
\\000\000\
\\008\000\019\000\013\000\250\001\086\000\002\002\110\000\126\004\
\\178\000\185\004\181\000\187\004\000\000\
\\110\000\127\004\178\000\185\004\181\000\188\004\000\000\
\\005\000\020\000\008\000\019\000\010\000\189\004\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\190\004\011\000\017\000\
\\013\000\016\000\000\000\
\\110\000\130\004\178\000\185\004\181\000\191\004\000\000\
\\005\000\020\000\008\000\019\000\010\000\192\004\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\193\004\011\000\017\000\
\\013\000\016\000\000\000\
\\008\000\019\000\013\000\194\004\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\196\004\111\000\028\004\190\000\195\004\000\000\
\\008\000\019\000\013\000\197\004\000\000\
\\015\000\198\004\000\000\
\\015\000\199\004\000\000\
\\007\000\231\000\073\000\200\004\074\000\229\000\075\000\228\000\
\\076\000\227\000\077\000\226\000\081\000\225\000\000\000\
\\015\000\201\004\000\000\
\\015\000\202\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\109\000\211\004\000\000\
\\000\000\
\\000\000\
\\110\000\212\004\000\000\
\\110\000\213\004\000\000\
\\000\000\
\\110\000\214\004\000\000\
\\110\000\215\004\000\000\
\\104\000\217\004\107\000\216\004\110\000\124\004\000\000\
\\000\000\
\\008\000\019\000\013\000\250\001\086\000\002\002\104\000\217\004\
\\107\000\219\004\110\000\126\004\000\000\
\\104\000\217\004\107\000\220\004\110\000\127\004\000\000\
\\005\000\020\000\008\000\019\000\010\000\221\004\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\222\004\011\000\017\000\
\\013\000\016\000\000\000\
\\104\000\217\004\107\000\223\004\110\000\130\004\000\000\
\\005\000\020\000\008\000\019\000\010\000\224\004\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\225\004\011\000\017\000\
\\013\000\016\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\097\000\234\004\000\000\
\\089\000\246\000\103\000\235\004\113\000\244\000\000\000\
\\097\000\236\004\000\000\
\\005\000\020\000\008\000\019\000\010\000\237\004\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\238\004\011\000\017\000\
\\013\000\016\000\000\000\
\\006\000\095\001\008\000\019\000\012\000\239\004\013\000\093\001\000\000\
\\005\000\020\000\008\000\019\000\010\000\240\004\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\241\004\011\000\017\000\
\\013\000\016\000\000\000\
\\000\000\
\\000\000\
\\097\000\242\004\000\000\
\\089\000\246\000\103\000\243\004\113\000\244\000\000\000\
\\097\000\244\004\000\000\
\\005\000\020\000\008\000\019\000\010\000\245\004\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\246\004\011\000\017\000\
\\013\000\016\000\000\000\
\\006\000\095\001\008\000\019\000\012\000\247\004\013\000\093\001\000\000\
\\005\000\020\000\008\000\019\000\010\000\248\004\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\249\004\011\000\017\000\
\\013\000\016\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\097\000\250\004\000\000\
\\089\000\246\000\103\000\251\004\113\000\244\000\000\000\
\\097\000\252\004\000\000\
\\005\000\020\000\008\000\019\000\010\000\253\004\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\254\004\011\000\017\000\
\\013\000\016\000\000\000\
\\006\000\095\001\008\000\019\000\012\000\255\004\013\000\093\001\000\000\
\\005\000\020\000\008\000\019\000\010\000\000\005\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\001\005\011\000\017\000\
\\013\000\016\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\203\000\109\000\211\004\177\000\217\001\180\000\002\005\000\000\
\\000\000\
\\000\000\
\\110\000\212\004\178\000\185\004\181\000\003\005\000\000\
\\110\000\213\004\178\000\185\004\181\000\004\005\000\000\
\\000\000\
\\110\000\214\004\178\000\185\004\181\000\005\005\000\000\
\\110\000\215\004\178\000\185\004\181\000\006\005\000\000\
\\110\000\124\004\186\000\008\005\189\000\007\005\000\000\
\\000\000\
\\008\000\019\000\013\000\250\001\086\000\002\002\110\000\126\004\
\\186\000\008\005\189\000\010\005\000\000\
\\110\000\127\004\186\000\008\005\189\000\011\005\000\000\
\\005\000\020\000\008\000\019\000\010\000\012\005\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\013\005\011\000\017\000\
\\013\000\016\000\000\000\
\\110\000\130\004\186\000\008\005\189\000\014\005\000\000\
\\005\000\020\000\008\000\019\000\010\000\015\005\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\016\005\011\000\017\000\
\\013\000\016\000\000\000\
\\008\000\019\000\013\000\017\005\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\096\000\019\005\098\000\112\001\099\000\018\005\111\000\028\004\000\000\
\\008\000\019\000\013\000\020\005\000\000\
\\015\000\021\005\000\000\
\\015\000\022\005\000\000\
\\007\000\231\000\073\000\023\005\074\000\229\000\075\000\228\000\
\\076\000\227\000\077\000\226\000\081\000\225\000\000\000\
\\015\000\024\005\000\000\
\\015\000\025\005\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\009\000\096\000\102\000\248\002\106\000\026\005\109\000\211\004\000\000\
\\000\000\
\\000\000\
\\104\000\217\004\107\000\027\005\110\000\212\004\000\000\
\\104\000\217\004\107\000\028\005\110\000\213\004\000\000\
\\000\000\
\\104\000\217\004\107\000\029\005\110\000\214\004\000\000\
\\104\000\217\004\107\000\030\005\110\000\215\004\000\000\
\\008\000\019\000\013\000\031\005\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\033\005\111\000\028\004\149\000\032\005\000\000\
\\008\000\019\000\013\000\034\005\000\000\
\\015\000\035\005\000\000\
\\015\000\036\005\000\000\
\\007\000\231\000\073\000\037\005\074\000\229\000\075\000\228\000\
\\076\000\227\000\077\000\226\000\081\000\225\000\000\000\
\\015\000\038\005\000\000\
\\015\000\039\005\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\207\000\109\000\211\004\185\000\221\001\188\000\064\005\000\000\
\\000\000\
\\000\000\
\\110\000\212\004\186\000\008\005\189\000\065\005\000\000\
\\110\000\213\004\186\000\008\005\189\000\066\005\000\000\
\\000\000\
\\110\000\214\004\186\000\008\005\189\000\067\005\000\000\
\\110\000\215\004\186\000\008\005\189\000\068\005\000\000\
\\091\000\070\005\095\000\069\005\110\000\124\004\000\000\
\\008\000\019\000\013\000\250\001\086\000\002\002\091\000\070\005\
\\095\000\072\005\110\000\126\004\000\000\
\\000\000\
\\091\000\070\005\095\000\073\005\110\000\127\004\000\000\
\\005\000\020\000\008\000\019\000\010\000\074\005\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\075\005\011\000\017\000\
\\013\000\016\000\000\000\
\\091\000\070\005\095\000\076\005\110\000\130\004\000\000\
\\005\000\020\000\008\000\019\000\010\000\077\005\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\078\005\011\000\017\000\
\\013\000\016\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\110\000\124\004\145\000\080\005\148\000\079\005\000\000\
\\000\000\
\\008\000\019\000\013\000\250\001\086\000\002\002\110\000\126\004\
\\145\000\080\005\148\000\082\005\000\000\
\\110\000\127\004\145\000\080\005\148\000\083\005\000\000\
\\005\000\020\000\008\000\019\000\010\000\084\005\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\085\005\011\000\017\000\
\\013\000\016\000\000\000\
\\110\000\130\004\145\000\080\005\148\000\086\005\000\000\
\\005\000\020\000\008\000\019\000\010\000\087\005\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\088\005\011\000\017\000\
\\013\000\016\000\000\000\
\\008\000\019\000\013\000\089\005\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\091\005\111\000\028\004\155\000\090\005\000\000\
\\008\000\019\000\013\000\092\005\000\000\
\\015\000\093\005\000\000\
\\015\000\094\005\000\000\
\\007\000\231\000\073\000\095\005\074\000\229\000\075\000\228\000\
\\076\000\227\000\077\000\226\000\081\000\225\000\000\000\
\\015\000\096\005\000\000\
\\015\000\097\005\000\000\
\\008\000\019\000\013\000\098\005\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\100\005\111\000\028\004\161\000\099\005\000\000\
\\008\000\019\000\013\000\101\005\000\000\
\\015\000\102\005\000\000\
\\015\000\103\005\000\000\
\\007\000\231\000\073\000\104\005\074\000\229\000\075\000\228\000\
\\076\000\227\000\077\000\226\000\081\000\225\000\000\000\
\\015\000\105\005\000\000\
\\015\000\106\005\000\000\
\\008\000\019\000\013\000\107\005\000\000\
\\008\000\019\000\009\000\101\001\013\000\100\001\014\000\113\001\
\\098\000\112\001\099\000\109\005\111\000\028\004\119\000\108\005\000\000\
\\008\000\019\000\013\000\110\005\000\000\
\\015\000\111\005\000\000\
\\015\000\112\005\000\000\
\\007\000\231\000\073\000\113\005\074\000\229\000\075\000\228\000\
\\076\000\227\000\077\000\226\000\081\000\225\000\000\000\
\\015\000\114\005\000\000\
\\015\000\115\005\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\093\000\090\000\226\002\094\000\116\005\109\000\211\004\000\000\
\\000\000\
\\000\000\
\\091\000\070\005\095\000\117\005\110\000\212\004\000\000\
\\091\000\070\005\095\000\118\005\110\000\213\004\000\000\
\\000\000\
\\091\000\070\005\095\000\119\005\110\000\214\004\000\000\
\\091\000\070\005\095\000\120\005\110\000\215\004\000\000\
\\000\000\
\\000\000\
\\008\000\017\002\109\000\211\004\144\000\214\003\147\000\121\005\000\000\
\\000\000\
\\000\000\
\\110\000\212\004\145\000\080\005\148\000\122\005\000\000\
\\110\000\213\004\145\000\080\005\148\000\123\005\000\000\
\\000\000\
\\110\000\214\004\145\000\080\005\148\000\124\005\000\000\
\\110\000\215\004\145\000\080\005\148\000\125\005\000\000\
\\110\000\124\004\151\000\127\005\154\000\126\005\000\000\
\\000\000\
\\008\000\019\000\013\000\250\001\086\000\002\002\110\000\126\004\
\\151\000\127\005\154\000\129\005\000\000\
\\110\000\127\004\151\000\127\005\154\000\130\005\000\000\
\\005\000\020\000\008\000\019\000\010\000\131\005\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\132\005\011\000\017\000\
\\013\000\016\000\000\000\
\\110\000\130\004\151\000\127\005\154\000\133\005\000\000\
\\005\000\020\000\008\000\019\000\010\000\134\005\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\135\005\011\000\017\000\
\\013\000\016\000\000\000\
\\110\000\124\004\157\000\137\005\160\000\136\005\000\000\
\\000\000\
\\008\000\019\000\013\000\250\001\086\000\002\002\110\000\126\004\
\\157\000\137\005\160\000\139\005\000\000\
\\110\000\127\004\157\000\137\005\160\000\140\005\000\000\
\\005\000\020\000\008\000\019\000\010\000\141\005\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\142\005\011\000\017\000\
\\013\000\016\000\000\000\
\\110\000\130\004\157\000\137\005\160\000\143\005\000\000\
\\005\000\020\000\008\000\019\000\010\000\144\005\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\145\005\011\000\017\000\
\\013\000\016\000\000\000\
\\110\000\124\004\114\000\147\005\118\000\146\005\000\000\
\\000\000\
\\008\000\019\000\013\000\250\001\086\000\002\002\110\000\126\004\
\\114\000\147\005\118\000\149\005\000\000\
\\110\000\127\004\114\000\147\005\118\000\150\005\000\000\
\\005\000\020\000\008\000\019\000\010\000\151\005\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\152\005\011\000\017\000\
\\013\000\016\000\000\000\
\\110\000\130\004\114\000\147\005\118\000\153\005\000\000\
\\005\000\020\000\008\000\019\000\010\000\154\005\011\000\017\000\
\\013\000\016\000\000\000\
\\005\000\020\000\008\000\019\000\010\000\155\005\011\000\017\000\
\\013\000\016\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\009\000\019\002\109\000\211\004\150\000\124\003\153\000\156\005\000\000\
\\000\000\
\\000\000\
\\110\000\212\004\151\000\127\005\154\000\157\005\000\000\
\\110\000\213\004\151\000\127\005\154\000\158\005\000\000\
\\000\000\
\\110\000\214\004\151\000\127\005\154\000\159\005\000\000\
\\110\000\215\004\151\000\127\005\154\000\160\005\000\000\
\\000\000\
\\000\000\
\\008\000\026\002\109\000\211\004\156\000\066\004\159\000\161\005\000\000\
\\000\000\
\\000\000\
\\110\000\212\004\157\000\137\005\160\000\162\005\000\000\
\\110\000\213\004\157\000\137\005\160\000\163\005\000\000\
\\000\000\
\\110\000\214\004\157\000\137\005\160\000\164\005\000\000\
\\110\000\215\004\157\000\137\005\160\000\165\005\000\000\
\\000\000\
\\000\000\
\\008\000\099\000\109\000\211\004\112\000\156\003\117\000\166\005\000\000\
\\000\000\
\\000\000\
\\110\000\212\004\114\000\147\005\118\000\167\005\000\000\
\\110\000\213\004\114\000\147\005\118\000\168\005\000\000\
\\000\000\
\\110\000\214\004\114\000\147\005\118\000\169\005\000\000\
\\110\000\215\004\114\000\147\005\118\000\170\005\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\"
val numstates = 1452
val numrules = 550
val s = ref "" and index = ref 0
val string_to_int = fn () => 
let val i = !index
in index := i+2; Char.ord(String.sub(!s,i)) + Char.ord(String.sub(!s,i+1)) * 256
end
val string_to_list = fn s' =>
    let val len = String.size s'
        fun f () =
           if !index < len then string_to_int() :: f()
           else nil
   in index := 0; s := s'; f ()
   end
val string_to_pairlist = fn (conv_key,conv_entry) =>
     let fun f () =
         case string_to_int()
         of 0 => EMPTY
          | n => PAIR(conv_key (n-1),conv_entry (string_to_int()),f())
     in f
     end
val string_to_pairlist_default = fn (conv_key,conv_entry) =>
    let val conv_row = string_to_pairlist(conv_key,conv_entry)
    in fn () =>
       let val default = conv_entry(string_to_int())
           val row = conv_row()
       in (row,default)
       end
   end
val string_to_table = fn (convert_row,s') =>
    let val len = String.size s'
        fun f ()=
           if !index < len then convert_row() :: f()
           else nil
     in (s := s'; index := 0; f ())
     end
local
  val memo = Array.array(numstates+numrules,ERROR)
  val _ =let fun g i=(Array.update(memo,i,REDUCE(i-numstates)); g(i+1))
       fun f i =
            if i=numstates then g i
            else (Array.update(memo,i,SHIFT (STATE i)); f (i+1))
          in f 0 handle Subscript => ()
          end
in
val entry_to_action = fn 0 => ACCEPT | 1 => ERROR | j => Array.sub(memo,(j-2))
end
val gotoT=Array.fromList(string_to_table(string_to_pairlist(NT,STATE),gotoT))
val actionRows=string_to_table(string_to_pairlist_default(T,entry_to_action),actionRows)
val actionRowNumbers = string_to_list actionRowNumbers
val actionT = let val actionRowLookUp=
let val a=Array.fromList(actionRows) in fn i=>Array.sub(a,i) end
in Array.fromList(map actionRowLookUp actionRowNumbers)
end
in LrTable.mkLrTable {actions=actionT,gotos=gotoT,numRules=numrules,
numStates=numstates,initialState=STATE 0}
end
end
local open Header in
type pos = Source.pos
type arg = unit
structure MlyValue = 
struct
datatype svalue = VOID | ntVOID of unit ->  unit
 | ETYVAR of unit ->  (string) | TYVAR of unit ->  (string)
 | SYMBOL of unit ->  (string) | ALPHA of unit ->  (string)
 | CHAR of unit ->  (WideChar.char)
 | STRING of unit ->  (WideString.string)
 | REAL of unit ->  (LargeReal.real)
 | WORD of unit ->  (LargeWord.word) | INT of unit ->  (LargeInt.int)
 | NUMERIC of unit ->  (LargeInt.int) | DIGIT of unit ->  (int)
 | component of unit ->  (Component)
 | program_opt' of unit ->  (Program option)
 | program_opt of unit ->  (Program option)
 | program of unit ->  (Program) | ann1 of unit ->  (Ann)
 | ann0 of unit ->  (Ann)
 | sigexp__AND_rea_opt__AND_funitem_opt of unit ->  (SigExp*Rea option*FunItem option)
 | AND_rea_opt__AND_funitem_opt of unit ->  (Rea option*FunItem option)
 | rea__AND_funitem_opt of unit ->  (Rea*FunItem option)
 | sigexp__AND_funitem_opt of unit ->  (SigExp*FunItem option)
 | AND_funitem_opt of unit ->  (FunItem option)
 | funitem of unit ->  (FunItem)
 | AND_sigitem_opt of unit ->  (SigItem option)
 | sigitem of unit ->  (SigItem)
 | sigexp__AND_rea_opt__AND_stritem_opt of unit ->  (SigExp*Rea option*StrItem option)
 | AND_rea_opt__AND_stritem_opt of unit ->  (Rea option*StrItem option)
 | rea__AND_stritem_opt of unit ->  (Rea*StrItem option)
 | sigexp__AND_stritem_opt of unit ->  (SigExp*StrItem option)
 | AND_stritem_opt of unit ->  (StrItem option)
 | stritem of unit ->  (StrItem)
 | AND_exitem_opt of unit ->  (ExItem option)
 | exitem of unit ->  (ExItem)
 | AND_dconitem_opt of unit ->  (DconItem option)
 | dconitem of unit ->  (DconItem)
 | BAR_conitem_opt of unit ->  (ConItem option)
 | conitem of unit ->  (ConItem)
 | AND_datitem_opt of unit ->  (DatItem option)
 | datitem of unit ->  (DatItem)
 | AND_typitem_opt of unit ->  (TypItem option)
 | typitem of unit ->  (TypItem)
 | AND_valitem_opt of unit ->  (ValItem option)
 | valitem of unit ->  (ValItem) | imp1' of unit ->  (Imp)
 | imp1 of unit ->  (Imp) | imp of unit ->  (Imp)
 | sigexp__AND_rea_opt__AND_fundesc_opt of unit ->  (SigExp*Rea option*FunDesc option)
 | AND_rea_opt__AND_fundesc_opt of unit ->  (Rea option*FunDesc option)
 | rea__AND_fundesc_opt of unit ->  (Rea*FunDesc option)
 | sigexp__AND_fundesc_opt of unit ->  (SigExp*FunDesc option)
 | AND_fundesc_opt of unit ->  (FunDesc option)
 | fundesc of unit ->  (FunDesc)
 | sigexp__AND_rea_opt__AND_sigdesc_opt of unit ->  (SigExp*Rea option*SigDesc option)
 | AND_rea_opt__AND_sigdesc_opt of unit ->  (Rea option*SigDesc option)
 | rea__AND_sigdesc_opt of unit ->  (Rea*SigDesc option)
 | sigexp__AND_sigdesc_opt of unit ->  (SigExp*SigDesc option)
 | AND_sigdesc_opt of unit ->  (SigDesc option)
 | sigdesc of unit ->  (SigDesc)
 | sigexp__AND_rea_opt__AND_strdesc_opt of unit ->  (SigExp*Rea option*StrDesc option)
 | AND_rea_opt__AND_strdesc_opt of unit ->  (Rea option*StrDesc option)
 | rea__AND_strdesc_opt of unit ->  (Rea*StrDesc option)
 | sigexp__AND_strdesc_opt of unit ->  (SigExp*StrDesc option)
 | AND_strdesc_opt of unit ->  (StrDesc option)
 | strdesc of unit ->  (StrDesc)
 | AND_exdesc_opt of unit ->  (ExDesc option)
 | exdesc of unit ->  (ExDesc)
 | AND_dcondesc_opt of unit ->  (DconDesc option)
 | dcondesc of unit ->  (DconDesc)
 | BAR_condesc_opt of unit ->  (ConDesc option)
 | condesc of unit ->  (ConDesc)
 | AND_datdesc_opt of unit ->  (DatDesc option)
 | datdesc1 of unit ->  (DatDesc) | datdesc0 of unit ->  (DatDesc)
 | datdesc of unit ->  (DatDesc)
 | AND_typdesc_opt of unit ->  (TypDesc option)
 | typdesc of unit ->  (TypDesc)
 | AND_valdesc_opt of unit ->  (ValDesc option)
 | valdesc of unit ->  (ValDesc)
 | longstrid_EQUALS_list2 of unit ->  (LongStrId list)
 | longstrid_EQUALS_list1 of unit ->  (LongStrId list)
 | longsigid_EQUALS_list2 of unit ->  (LongSigId list)
 | longsigid_EQUALS_list1 of unit ->  (LongSigId list)
 | longtycon_EQUALS_list2 of unit ->  (LongTyCon list)
 | longtycon_EQUALS_list1 of unit ->  (LongTyCon list)
 | WITHTYPE_typdesc_opt of unit ->  (TypDesc option)
 | spec1' of unit ->  (Spec) | spec1 of unit ->  (Spec)
 | spec of unit ->  (Spec)
 | sigexp__AND_rea_opt__AND_funbind_opt of unit ->  (SigExp*Rea option*FunBind option)
 | AND_rea_opt__AND_funbind_opt of unit ->  (Rea option*FunBind option)
 | rea__AND_funbind_opt of unit ->  (Rea*FunBind option)
 | sigexp__AND_funbind_opt of unit ->  (SigExp*FunBind option)
 | strexp__AND_funbind_opt of unit ->  (StrExp*FunBind option)
 | AND_funbind_opt of unit ->  (FunBind option)
 | strpat_list1 of unit ->  (StrPat list)
 | funbind of unit ->  (FunBind)
 | sigexp__AND_rea_opt of unit ->  (SigExp*Rea option)
 | AND_rea_opt of unit ->  (Rea option) | rea of unit ->  (Rea)
 | sigexp__AND_rea_opt__AND_sigbind_opt of unit ->  (SigExp*Rea option*SigBind option)
 | AND_rea_opt__AND_sigbind_opt of unit ->  (Rea option*SigBind option)
 | rea__AND_sigbind_opt of unit ->  (Rea*SigBind option)
 | sigexp__AND_sigbind_opt of unit ->  (SigExp*SigBind option)
 | AND_sigbind_opt of unit ->  (SigBind option)
 | strpat_list0 of unit ->  (StrPat list)
 | sigbind of unit ->  (SigBind) | sigexp' of unit ->  (SigExp)
 | sigexp of unit ->  (SigExp) | appsigexp of unit ->  (AppSigExp)
 | atsigexp of unit ->  (AtSigExp)
 | COLON_sigexp_opt of unit ->  (SigExp option)
 | sigexp__AND_rea_opt__AND_strbind_opt of unit ->  (SigExp*Rea option*StrBind option)
 | AND_rea_opt__AND_strbind_opt of unit ->  (Rea option*StrBind option)
 | rea__AND_strbind_opt of unit ->  (Rea*StrBind option)
 | sigexp__AND_strbind_opt of unit ->  (SigExp*StrBind option)
 | strexp__AND_strbind_opt of unit ->  (StrExp*StrBind option)
 | AND_strbind_opt of unit ->  (StrBind option)
 | strbind of unit ->  (StrBind) | strpat of unit ->  (StrPat)
 | strexp of unit ->  (StrExp) | appstrexp of unit ->  (AppStrExp)
 | atstrexp of unit ->  (AtStrExp)
 | tyvar_COMMA_list1 of unit ->  (TyVar list)
 | tyvarseq1 of unit ->  (TyVarSeq) | tyvarseq of unit ->  (TyVarSeq)
 | ty_COMMA_list2 of unit ->  (Ty list) | tyseq of unit ->  (TySeq)
 | COMMA_tyrow_opt of unit ->  (TyRow option)
 | tyrow_opt of unit ->  (TyRow option) | tyrow of unit ->  (TyRow)
 | atty of unit ->  (Ty) | consty of unit ->  (Ty)
 | ty_STAR_list of unit ->  (Ty list) | tupty of unit ->  (Ty)
 | ty of unit ->  (Ty) | pat of unit ->  (Pat)
 | infpat of unit ->  (Pat) | AS_pat_opt of unit ->  (Pat option)
 | COLON_ty_opt of unit ->  (Ty option)
 | COMMA_patrow_opt of unit ->  (PatRow option)
 | patrow_opt of unit ->  (PatRow option)
 | patrow of unit ->  (PatRow) | pat_BAR_list2 of unit ->  (Pat list)
 | pat_COMMA_list2 of unit ->  (Pat list)
 | pat_COMMA_list1 of unit ->  (Pat list)
 | pat_COMMA_list0 of unit ->  (Pat list) | atpat of unit ->  (AtPat)
 | AND_exbind_opt of unit ->  (ExBind option)
 | exbind of unit ->  (ExBind)
 | AND_dconbind_opt of unit ->  (DconBind option)
 | dconbind of unit ->  (DconBind) | OF_ty_opt of unit ->  (Ty option)
 | BAR_conbind_opt of unit ->  (ConBind option)
 | conbind of unit ->  (ConBind)
 | AND_datbind_opt of unit ->  (DatBind option)
 | datbind1 of unit ->  (DatBind) | datbind0 of unit ->  (DatBind)
 | datbind of unit ->  (DatBind)
 | AND_typbind_opt of unit ->  (TypBind option)
 | typbind of unit ->  (TypBind) | fpat of unit ->  (Fpat)
 | fmrule of unit ->  (Fmrule)
 | BAR_fmatch_opt of unit ->  (Fmatch option)
 | fmatch of unit ->  (Fmatch)
 | AND_fvalbind_opt of unit ->  (FvalBind option)
 | fvalbind of unit ->  (FvalBind)
 | AND_valbind_opt of unit ->  (ValBind option)
 | valbind of unit ->  (ValBind) | d_opt of unit ->  (int option)
 | longstrid_list1 of unit ->  (LongStrId list)
 | vid_list1 of unit ->  (VId list)
 | WITHTYPE_typbind_opt of unit ->  (TypBind option)
 | dec1'' of unit ->  (Dec) | dec1' of unit ->  (Dec)
 | dec1 of unit ->  (Dec) | dec' of unit ->  (Dec)
 | dec of unit ->  (Dec) | mrule of unit ->  (Mrule)
 | BAR_match_opt of unit ->  (Match option)
 | match of unit ->  (Match) | exp of unit ->  (Exp)
 | infexp of unit ->  (InfExp) | appexp of unit ->  (AppExp)
 | COMMA_exprow_opt of unit ->  (ExpRow option)
 | exprow_opt of unit ->  (ExpRow option)
 | exprow of unit ->  (ExpRow)
 | exp_SEMICOLON_list2 of unit ->  (Exp list)
 | exp_SEMICOLON_list1 of unit ->  (Exp list)
 | exp_COMMA_list2 of unit ->  (Exp list)
 | exp_COMMA_list1 of unit ->  (Exp list)
 | exp_COMMA_list0 of unit ->  (Exp list) | atexp of unit ->  (AtExp)
 | OP_opt of unit ->  (Op) | longsigid of unit ->  (LongSigId)
 | longstrid of unit ->  (LongStrId)
 | longtycon of unit ->  (LongTyCon) | longvid' of unit ->  (LongVId)
 | longvid of unit ->  (LongVId) | sigid of unit ->  (SigId)
 | strid of unit ->  (StrId) | tyvar of unit ->  (TyVar)
 | tycon of unit ->  (TyCon) | vid' of unit ->  (VId)
 | vid of unit ->  (VId) | lab of unit ->  (Lab) | d of unit ->  (int)
 | scon of unit ->  (SCon)
end
type svalue = MlyValue.svalue
type result = Component
end
structure EC=
struct
open LrTable
val is_keyword =
fn (T 1) => true | (T 2) => true | (T 3) => true | (T 4) => true | (T 
5) => true | (T 6) => true | (T 7) => true | (T 8) => true | (T 9)
 => true | (T 10) => true | (T 11) => true | (T 12) => true | (T 13)
 => true | (T 14) => true | (T 15) => true | (T 16) => true | (T 17)
 => true | (T 18) => true | (T 19) => true | (T 20) => true | (T 21)
 => true | (T 22) => true | (T 23) => true | (T 24) => true | (T 25)
 => true | (T 26) => true | (T 27) => true | (T 28) => true | (T 29)
 => true | (T 30) => true | (T 31) => true | (T 32) => true | (T 66)
 => true | (T 67) => true | (T 68) => true | (T 69) => true | (T 70)
 => true | (T 71) => true | (T 72) => true | (T 73) => true | (T 74)
 => true | (T 49) => true | (T 50) => true | (T 51) => true | (T 52)
 => true | (T 55) => true | (T 56) => true | (T 57) => true | (T 58)
 => true | (T 59) => true | (T 60) => true | (T 61) => true | (T 62)
 => true | (T 63) => true | (T 64) => true | (T 65) => true | _ => false
val preferred_change = 
nil
val noShift = 
fn (T 0) => true | _ => false
val showTerminal =
fn (T 0) => "EOF"
  | (T 1) => "ABSTYPE"
  | (T 2) => "AND"
  | (T 3) => "ANDALSO"
  | (T 4) => "AS"
  | (T 5) => "CASE"
  | (T 6) => "DO"
  | (T 7) => "DATATYPE"
  | (T 8) => "ELSE"
  | (T 9) => "END"
  | (T 10) => "EXCEPTION"
  | (T 11) => "FN"
  | (T 12) => "FUN"
  | (T 13) => "HANDLE"
  | (T 14) => "IF"
  | (T 15) => "IN"
  | (T 16) => "INFIX"
  | (T 17) => "INFIXR"
  | (T 18) => "LET"
  | (T 19) => "LOCAL"
  | (T 20) => "NONFIX"
  | (T 21) => "OF"
  | (T 22) => "OP"
  | (T 23) => "OPEN"
  | (T 24) => "ORELSE"
  | (T 25) => "RAISE"
  | (T 26) => "REC"
  | (T 27) => "THEN"
  | (T 28) => "TYPE"
  | (T 29) => "VAL"
  | (T 30) => "WITH"
  | (T 31) => "WITHTYPE"
  | (T 32) => "WHILE"
  | (T 33) => "LPAR"
  | (T 34) => "RPAR"
  | (T 35) => "LBRACK"
  | (T 36) => "RBRACK"
  | (T 37) => "LBRACE"
  | (T 38) => "RBRACE"
  | (T 39) => "COMMA"
  | (T 40) => "COLON"
  | (T 41) => "SEMICOLON"
  | (T 42) => "DOTS"
  | (T 43) => "UNDERBAR"
  | (T 44) => "BAR"
  | (T 45) => "EQUALS"
  | (T 46) => "DARROW"
  | (T 47) => "ARROW"
  | (T 48) => "HASH"
  | (T 49) => "CONSTRUCTOR"
  | (T 50) => "NON"
  | (T 51) => "WITHFUN"
  | (T 52) => "WITHVAL"
  | (T 53) => "DOT"
  | (T 54) => "HASHBRACK"
  | (T 55) => "ANY"
  | (T 56) => "FCT"
  | (T 57) => "PACK"
  | (T 58) => "UNPACK"
  | (T 59) => "IMPORT"
  | (T 60) => "FROM"
  | (T 61) => "PRIMITIVE"
  | (T 62) => "OVERLOAD"
  | (T 63) => "INSTANCE"
  | (T 64) => "PREBOUND"
  | (T 65) => "EQEQTYPE"
  | (T 66) => "EQTYPE"
  | (T 67) => "FUNCTOR"
  | (T 68) => "INCLUDE"
  | (T 69) => "SHARING"
  | (T 70) => "SIG"
  | (T 71) => "SIGNATURE"
  | (T 72) => "STRUCT"
  | (T 73) => "STRUCTURE"
  | (T 74) => "WHERE"
  | (T 75) => "COLONGREATER"
  | (T 76) => "ZERO"
  | (T 77) => "DIGIT"
  | (T 78) => "NUMERIC"
  | (T 79) => "INT"
  | (T 80) => "WORD"
  | (T 81) => "REAL"
  | (T 82) => "STRING"
  | (T 83) => "CHAR"
  | (T 84) => "ALPHA"
  | (T 85) => "SYMBOL"
  | (T 86) => "STAR"
  | (T 87) => "TYVAR"
  | (T 88) => "ETYVAR"
  | _ => "bogus-term"
local open Header in
val errtermvalue=
fn _ => MlyValue.VOID
end
val terms = (T 0) :: (T 1) :: (T 2) :: (T 3) :: (T 4) :: (T 5) :: (T 6
) :: (T 7) :: (T 8) :: (T 9) :: (T 10) :: (T 11) :: (T 12) :: (T 13)
 :: (T 14) :: (T 15) :: (T 16) :: (T 17) :: (T 18) :: (T 19) :: (T 20)
 :: (T 21) :: (T 22) :: (T 23) :: (T 24) :: (T 25) :: (T 26) :: (T 27)
 :: (T 28) :: (T 29) :: (T 30) :: (T 31) :: (T 32) :: (T 33) :: (T 34)
 :: (T 35) :: (T 36) :: (T 37) :: (T 38) :: (T 39) :: (T 40) :: (T 41)
 :: (T 42) :: (T 43) :: (T 44) :: (T 45) :: (T 46) :: (T 47) :: (T 48)
 :: (T 49) :: (T 50) :: (T 51) :: (T 52) :: (T 53) :: (T 54) :: (T 55)
 :: (T 56) :: (T 57) :: (T 58) :: (T 59) :: (T 60) :: (T 61) :: (T 62)
 :: (T 63) :: (T 64) :: (T 65) :: (T 66) :: (T 67) :: (T 68) :: (T 69)
 :: (T 70) :: (T 71) :: (T 72) :: (T 73) :: (T 74) :: (T 75) :: (T 76)
 :: (T 86) :: nil
end
structure Actions =
struct 
exception mlyAction of int
local open Header in
val actions = 
fn (i392,defaultPos,stack,
    (()):arg) =>
case (i392,stack)
of (0,(_,(_,ZEROleft as ZERO1left,ZEROright as ZERO1right))::rest671)
 => let val result=MlyValue.scon(fn _ => (
 SCon(I(ZEROleft,ZEROright),
				SCon.INT(LargeInt.fromInt 0)) ))
 in (LrTable.NT 0,(result,ZERO1left,ZERO1right),rest671) end
| (1,(_,(MlyValue.DIGIT DIGIT1,DIGITleft as DIGIT1left,DIGITright as 
DIGIT1right))::rest671) => let val result=MlyValue.scon(fn _ => let 
val DIGIT as DIGIT1=DIGIT1 ()
 in (
 SCon(I(DIGITleft,DIGITright),
				SCon.INT(LargeInt.fromInt DIGIT)) )
 end
)
 in (LrTable.NT 0,(result,DIGIT1left,DIGIT1right),rest671) end
| (2,(_,(MlyValue.NUMERIC NUMERIC1,NUMERICleft as NUMERIC1left,
NUMERICright as NUMERIC1right))::rest671) => let val result=
MlyValue.scon(fn _ => let val NUMERIC as NUMERIC1=NUMERIC1 ()
 in ( SCon(I(NUMERICleft,NUMERICright),
							SCon.INT NUMERIC) ) end
)
 in (LrTable.NT 0,(result,NUMERIC1left,NUMERIC1right),rest671) end
| (3,(_,(MlyValue.INT INT1,INTleft as INT1left,INTright as INT1right))
::rest671) => let val result=MlyValue.scon(fn _ => let val INT as INT1
=INT1 ()
 in ( SCon(I(INTleft,INTright),     SCon.INT INT) ) end
)
 in (LrTable.NT 0,(result,INT1left,INT1right),rest671) end
| (4,(_,(MlyValue.WORD WORD1,WORDleft as WORD1left,WORDright as 
WORD1right))::rest671) => let val result=MlyValue.scon(fn _ => let 
val WORD as WORD1=WORD1 ()
 in ( SCon(I(WORDleft,WORDright),   SCon.WORD WORD) ) end
)
 in (LrTable.NT 0,(result,WORD1left,WORD1right),rest671) end
| (5,(_,(MlyValue.STRING STRING1,STRINGleft as STRING1left,STRINGright
 as STRING1right))::rest671) => let val result=MlyValue.scon(fn _ => 
let val STRING as STRING1=STRING1 ()
 in ( SCon(I(STRINGleft,STRINGright),
							SCon.STRING STRING)) end
)
 in (LrTable.NT 0,(result,STRING1left,STRING1right),rest671) end
| (6,(_,(MlyValue.CHAR CHAR1,CHARleft as CHAR1left,CHARright as 
CHAR1right))::rest671) => let val result=MlyValue.scon(fn _ => let 
val CHAR as CHAR1=CHAR1 ()
 in ( SCon(I(CHARleft,CHARright),   SCon.CHAR CHAR) ) end
)
 in (LrTable.NT 0,(result,CHAR1left,CHAR1right),rest671) end
| (7,(_,(MlyValue.REAL REAL1,REALleft as REAL1left,REALright as 
REAL1right))::rest671) => let val result=MlyValue.scon(fn _ => let 
val REAL as REAL1=REAL1 ()
 in ( SCon(I(REALleft,REALright),   SCon.REAL REAL) ) end
)
 in (LrTable.NT 0,(result,REAL1left,REAL1right),rest671) end
| (8,(_,(_,ZERO1left,ZERO1right))::rest671) => let val result=
MlyValue.d(fn _ => ( 0 ))
 in (LrTable.NT 1,(result,ZERO1left,ZERO1right),rest671) end
| (9,(_,(MlyValue.DIGIT DIGIT1,DIGIT1left,DIGIT1right))::rest671) => 
let val result=MlyValue.d(fn _ => let val DIGIT as DIGIT1=DIGIT1 ()
 in ( DIGIT ) end
)
 in (LrTable.NT 1,(result,DIGIT1left,DIGIT1right),rest671) end
| (10,(_,(MlyValue.ALPHA ALPHA1,ALPHAleft as ALPHA1left,ALPHAright as 
ALPHA1right))::rest671) => let val result=MlyValue.lab(fn _ => let 
val ALPHA as ALPHA1=ALPHA1 ()
 in ( Lab(I(ALPHAleft,ALPHAright),   Lab.fromString ALPHA) ) end
)
 in (LrTable.NT 2,(result,ALPHA1left,ALPHA1right),rest671) end
| (11,(_,(MlyValue.SYMBOL SYMBOL1,SYMBOLleft as SYMBOL1left,
SYMBOLright as SYMBOL1right))::rest671) => let val result=MlyValue.lab
(fn _ => let val SYMBOL as SYMBOL1=SYMBOL1 ()
 in ( Lab(I(SYMBOLleft,SYMBOLright), Lab.fromString SYMBOL)) end
)
 in (LrTable.NT 2,(result,SYMBOL1left,SYMBOL1right),rest671) end
| (12,(_,(_,STARleft as STAR1left,STARright as STAR1right))::rest671)
 => let val result=MlyValue.lab(fn _ => (
 Lab(I(STARleft,STARright),     Lab.fromString "*") ))
 in (LrTable.NT 2,(result,STAR1left,STAR1right),rest671) end
| (13,(_,(MlyValue.DIGIT DIGIT1,DIGITleft as DIGIT1left,DIGITright as 
DIGIT1right))::rest671) => let val result=MlyValue.lab(fn _ => let 
val DIGIT as DIGIT1=DIGIT1 ()
 in ( Lab(I(DIGITleft,DIGITright),   Lab.fromInt DIGIT) ) end
)
 in (LrTable.NT 2,(result,DIGIT1left,DIGIT1right),rest671) end
| (14,(_,(MlyValue.NUMERIC NUMERIC1,NUMERICleft as NUMERIC1left,
NUMERICright as NUMERIC1right))::rest671) => let val result=
MlyValue.lab(fn _ => let val NUMERIC as NUMERIC1=NUMERIC1 ()
 in ( Lab(I(NUMERICleft,NUMERICright),
						Lab.fromLargeInt NUMERIC)
) end
)
 in (LrTable.NT 2,(result,NUMERIC1left,NUMERIC1right),rest671) end
| (15,(_,(MlyValue.vid' vid'1,vid'1left,vid'1right))::rest671) => let 
val result=MlyValue.vid(fn _ => let val vid' as vid'1=vid'1 ()
 in ( vid' ) end
)
 in (LrTable.NT 3,(result,vid'1left,vid'1right),rest671) end
| (16,(_,(_,EQUALSleft as EQUALS1left,EQUALSright as EQUALS1right))::
rest671) => let val result=MlyValue.vid(fn _ => (
 VId(I(EQUALSleft,EQUALSright), VId.fromString "=") ))
 in (LrTable.NT 3,(result,EQUALS1left,EQUALS1right),rest671) end
| (17,(_,(MlyValue.ALPHA ALPHA1,ALPHAleft as ALPHA1left,ALPHAright as 
ALPHA1right))::rest671) => let val result=MlyValue.vid'(fn _ => let 
val ALPHA as ALPHA1=ALPHA1 ()
 in ( VId(I(ALPHAleft,ALPHAright),   VId.fromString ALPHA) ) end
)
 in (LrTable.NT 4,(result,ALPHA1left,ALPHA1right),rest671) end
| (18,(_,(MlyValue.SYMBOL SYMBOL1,SYMBOLleft as SYMBOL1left,
SYMBOLright as SYMBOL1right))::rest671) => let val result=
MlyValue.vid'(fn _ => let val SYMBOL as SYMBOL1=SYMBOL1 ()
 in ( VId(I(SYMBOLleft,SYMBOLright), VId.fromString SYMBOL)) end
)
 in (LrTable.NT 4,(result,SYMBOL1left,SYMBOL1right),rest671) end
| (19,(_,(_,STARleft as STAR1left,STARright as STAR1right))::rest671)
 => let val result=MlyValue.vid'(fn _ => (
 VId(I(STARleft,STARright),     VId.fromString "*") ))
 in (LrTable.NT 4,(result,STAR1left,STAR1right),rest671) end
| (20,(_,(MlyValue.ALPHA ALPHA1,ALPHAleft as ALPHA1left,ALPHAright as 
ALPHA1right))::rest671) => let val result=MlyValue.tycon(fn _ => let 
val ALPHA as ALPHA1=ALPHA1 ()
 in ( TyCon(I(ALPHAleft,ALPHAright),
				TyCon.fromString ALPHA) ) end
)
 in (LrTable.NT 5,(result,ALPHA1left,ALPHA1right),rest671) end
| (21,(_,(MlyValue.SYMBOL SYMBOL1,SYMBOLleft as SYMBOL1left,
SYMBOLright as SYMBOL1right))::rest671) => let val result=
MlyValue.tycon(fn _ => let val SYMBOL as SYMBOL1=SYMBOL1 ()
 in ( TyCon(I(SYMBOLleft,SYMBOLright),
				TyCon.fromString SYMBOL) )
 end
)
 in (LrTable.NT 5,(result,SYMBOL1left,SYMBOL1right),rest671) end
| (22,(_,(MlyValue.TYVAR TYVAR1,TYVARleft as TYVAR1left,TYVARright as 
TYVAR1right))::rest671) => let val result=MlyValue.tyvar(fn _ => let 
val TYVAR as TYVAR1=TYVAR1 ()
 in ( TyVar(I(TYVARleft,TYVARright),
				TyVar.fromString TYVAR) ) end
)
 in (LrTable.NT 6,(result,TYVAR1left,TYVAR1right),rest671) end
| (23,(_,(MlyValue.ALPHA ALPHA1,ALPHAleft as ALPHA1left,ALPHAright as 
ALPHA1right))::rest671) => let val result=MlyValue.strid(fn _ => let 
val ALPHA as ALPHA1=ALPHA1 ()
 in ( StrId(I(ALPHAleft,ALPHAright),
				StrId.fromString ALPHA) ) end
)
 in (LrTable.NT 7,(result,ALPHA1left,ALPHA1right),rest671) end
| (24,(_,(MlyValue.ALPHA ALPHA1,ALPHAleft as ALPHA1left,ALPHAright as 
ALPHA1right))::rest671) => let val result=MlyValue.sigid(fn _ => let 
val ALPHA as ALPHA1=ALPHA1 ()
 in ( SigId(I(ALPHAleft,ALPHAright),
				SigId.fromString ALPHA) ) end
)
 in (LrTable.NT 8,(result,ALPHA1left,ALPHA1right),rest671) end
| (25,(_,(MlyValue.longvid' longvid'1,longvid'1left,longvid'1right))::
rest671) => let val result=MlyValue.longvid(fn _ => let val longvid'
 as longvid'1=longvid'1 ()
 in ( longvid' ) end
)
 in (LrTable.NT 9,(result,longvid'1left,longvid'1right),rest671) end
| (26,(_,(_,EQUALSleft as EQUALS1left,EQUALSright as EQUALS1right))::
rest671) => let val result=MlyValue.longvid(fn _ => (
 SHORTLong(I(EQUALSleft,EQUALSright),
					    VId(I(EQUALSleft,EQUALSright),
						VId.fromString "=")) 
))
 in (LrTable.NT 9,(result,EQUALS1left,EQUALS1right),rest671) end
| (27,(_,(MlyValue.vid' vid'1,vid'left as vid'1left,vid'right as 
vid'1right))::rest671) => let val result=MlyValue.longvid'(fn _ => 
let val vid' as vid'1=vid'1 ()
 in ( SHORTLong(I(vid'left,vid'right), vid') ) end
)
 in (LrTable.NT 10,(result,vid'1left,vid'1right),rest671) end
| (28,(_,(MlyValue.vid vid1,_,vidright as vid1right))::_::(_,(
MlyValue.longstrid longstrid1,longstridleft as longstrid1left,_))::
rest671) => let val result=MlyValue.longvid'(fn _ => let val longstrid
 as longstrid1=longstrid1 ()
val vid as vid1=vid1 ()
 in ( DOTLong(I(longstridleft,vidright),
					  longstrid, vid) ) end
)
 in (LrTable.NT 10,(result,longstrid1left,vid1right),rest671) end
| (29,(_,(MlyValue.tycon tycon1,tyconleft as tycon1left,tyconright as 
tycon1right))::rest671) => let val result=MlyValue.longtycon(fn _ => 
let val tycon as tycon1=tycon1 ()
 in ( SHORTLong(I(tyconleft,tyconright), tycon) ) end
)
 in (LrTable.NT 11,(result,tycon1left,tycon1right),rest671) end
| (30,(_,(MlyValue.tycon tycon1,_,tyconright as tycon1right))::_::(_,(
MlyValue.longstrid longstrid1,longstridleft as longstrid1left,_))::
rest671) => let val result=MlyValue.longtycon(fn _ => let val 
longstrid as longstrid1=longstrid1 ()
val tycon as tycon1=tycon1 ()
 in ( DOTLong(I(longstridleft,tyconright),
					  longstrid, tycon) )
 end
)
 in (LrTable.NT 11,(result,longstrid1left,tycon1right),rest671) end
| (31,(_,(MlyValue.strid strid1,stridleft as strid1left,stridright as 
strid1right))::rest671) => let val result=MlyValue.longstrid(fn _ => 
let val strid as strid1=strid1 ()
 in ( SHORTLong(I(stridleft,stridright), strid) ) end
)
 in (LrTable.NT 12,(result,strid1left,strid1right),rest671) end
| (32,(_,(MlyValue.strid strid1,_,stridright as strid1right))::_::(_,(
MlyValue.longstrid longstrid1,longstridleft as longstrid1left,_))::
rest671) => let val result=MlyValue.longstrid(fn _ => let val 
longstrid as longstrid1=longstrid1 ()
val strid as strid1=strid1 ()
 in ( DOTLong(I(longstridleft,stridright),
					  longstrid, strid) )
 end
)
 in (LrTable.NT 12,(result,longstrid1left,strid1right),rest671) end
| (33,(_,(MlyValue.sigid sigid1,sigidleft as sigid1left,sigidright as 
sigid1right))::rest671) => let val result=MlyValue.longsigid(fn _ => 
let val sigid as sigid1=sigid1 ()
 in ( SHORTLong(I(sigidleft,sigidright), sigid) ) end
)
 in (LrTable.NT 13,(result,sigid1left,sigid1right),rest671) end
| (34,(_,(MlyValue.sigid sigid1,_,sigidright as sigid1right))::_::(_,(
MlyValue.longstrid longstrid1,longstridleft as longstrid1left,_))::
rest671) => let val result=MlyValue.longsigid(fn _ => let val 
longstrid as longstrid1=longstrid1 ()
val sigid as sigid1=sigid1 ()
 in ( DOTLong(I(longstridleft,sigidright),
					  longstrid, sigid) )
 end
)
 in (LrTable.NT 13,(result,longstrid1left,sigid1right),rest671) end
| (35,(_,(_,OP1left,OP1right))::rest671) => let val result=
MlyValue.OP_opt(fn _ => ( WITHOp ))
 in (LrTable.NT 14,(result,OP1left,OP1right),rest671) end
| (36,rest671) => let val result=MlyValue.OP_opt(fn _ => ( SANSOp ))
 in (LrTable.NT 14,(result,defaultPos,defaultPos),rest671) end
| (37,(_,(MlyValue.scon scon1,sconleft as scon1left,sconright as 
scon1right))::rest671) => let val result=MlyValue.atexp(fn _ => let 
val scon as scon1=scon1 ()
 in ( SCONAtExp(I(sconleft,sconright), scon) ) end
)
 in (LrTable.NT 15,(result,scon1left,scon1right),rest671) end
| (38,(_,(MlyValue.longvid longvid1,longvidleft as longvid1left,
longvidright as longvid1right))::rest671) => let val result=
MlyValue.atexp(fn _ => let val longvid as longvid1=longvid1 ()
 in (
 LONGVIDAtExp(I(longvidleft,longvidright),
				       SANSOp, longvid) 
) end
)
 in (LrTable.NT 15,(result,longvid1left,longvid1right),rest671) end
| (39,(_,(MlyValue.longvid longvid1,_,longvidright as longvid1right))
::(_,(_,OPleft as OP1left,_))::rest671) => let val result=
MlyValue.atexp(fn _ => let val longvid as longvid1=longvid1 ()
 in (
 LONGVIDAtExp(I(OPleft,longvidright),
				       WITHOp, longvid) )
 end
)
 in (LrTable.NT 15,(result,OP1left,longvid1right),rest671) end
| (40,(_,(_,_,RBRACEright as RBRACE1right))::(_,(MlyValue.exprow_opt 
exprow_opt1,_,_))::(_,(_,LBRACEleft as LBRACE1left,_))::rest671) => 
let val result=MlyValue.atexp(fn _ => let val exprow_opt as 
exprow_opt1=exprow_opt1 ()
 in ( RECORDAtExp(I(LBRACEleft,RBRACEright), exprow_opt) ) end
)
 in (LrTable.NT 15,(result,LBRACE1left,RBRACE1right),rest671) end
| (41,(_,(_,_,RBRACEright as RBRACE1right))::(_,(MlyValue.exprow 
exprow1,_,_))::_::(_,(MlyValue.atexp atexp1,_,_))::(_,(_,LBRACEleft
 as LBRACE1left,_))::rest671) => let val result=MlyValue.atexp(fn _
 => let val atexp as atexp1=atexp1 ()
val exprow as exprow1=exprow1 ()
 in ( UPDATEAtExp(I(LBRACEleft,RBRACEright), atexp, exprow)) end
)
 in (LrTable.NT 15,(result,LBRACE1left,RBRACE1right),rest671) end
| (42,(_,(MlyValue.lab lab1,_,labright as lab1right))::(_,(_,HASHleft
 as HASH1left,_))::rest671) => let val result=MlyValue.atexp(fn _ => 
let val lab as lab1=lab1 ()
 in ( HASHAtExp(I(HASHleft,labright), lab) ) end
)
 in (LrTable.NT 15,(result,HASH1left,lab1right),rest671) end
| (43,(_,(_,_,RPARright as RPAR1right))::(_,(_,LPARleft as LPAR1left,_
))::rest671) => let val result=MlyValue.atexp(fn _ => (
 UNITAtExp(I(LPARleft,RPARright)) ))
 in (LrTable.NT 15,(result,LPAR1left,RPAR1right),rest671) end
| (44,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.exp_COMMA_list2 
exp_COMMA_list21,_,_))::(_,(_,LPARleft as LPAR1left,_))::rest671) => 
let val result=MlyValue.atexp(fn _ => let val exp_COMMA_list2 as 
exp_COMMA_list21=exp_COMMA_list21 ()
 in ( TUPLEAtExp(I(LPARleft,RPARright), exp_COMMA_list2) ) end
)
 in (LrTable.NT 15,(result,LPAR1left,RPAR1right),rest671) end
| (45,(_,(_,_,RBRACKright as RBRACK1right))::(_,(
MlyValue.exp_COMMA_list0 exp_COMMA_list01,_,_))::(_,(_,LBRACKleft as 
LBRACK1left,_))::rest671) => let val result=MlyValue.atexp(fn _ => 
let val exp_COMMA_list0 as exp_COMMA_list01=exp_COMMA_list01 ()
 in ( LISTAtExp(I(LBRACKleft,RBRACKright),
				    exp_COMMA_list0 ))
 end
)
 in (LrTable.NT 15,(result,LBRACK1left,RBRACK1right),rest671) end
| (46,(_,(_,_,RBRACKright as RBRACK1right))::(_,(
MlyValue.exp_COMMA_list0 exp_COMMA_list01,_,_))::(_,(_,HASHBRACKleft
 as HASHBRACK1left,_))::rest671) => let val result=MlyValue.atexp(fn _
 => let val exp_COMMA_list0 as exp_COMMA_list01=exp_COMMA_list01 ()
 in (
 VECTORAtExp(I(HASHBRACKleft,RBRACKright),
				    exp_COMMA_list0 ))
 end
)
 in (LrTable.NT 15,(result,HASHBRACK1left,RBRACK1right),rest671) end
| (47,(_,(_,_,RPARright as RPAR1right))::(_,(
MlyValue.exp_SEMICOLON_list2 exp_SEMICOLON_list21,_,_))::(_,(_,
LPARleft as LPAR1left,_))::rest671) => let val result=MlyValue.atexp(
fn _ => let val exp_SEMICOLON_list2 as exp_SEMICOLON_list21=
exp_SEMICOLON_list21 ()
 in ( SEQAtExp(I(LPARleft,RPARright), exp_SEMICOLON_list2) ) end
)
 in (LrTable.NT 15,(result,LPAR1left,RPAR1right),rest671) end
| (48,(_,(_,_,ENDright as END1right))::(_,(
MlyValue.exp_SEMICOLON_list1 exp_SEMICOLON_list11,_,_))::_::(_,(
MlyValue.dec dec1,_,_))::(_,(_,LETleft as LET1left,_))::rest671) => 
let val result=MlyValue.atexp(fn _ => let val dec as dec1=dec1 ()
val exp_SEMICOLON_list1 as exp_SEMICOLON_list11=exp_SEMICOLON_list11 
()
 in ( LETAtExp(I(LETleft,ENDright),
				   dec, exp_SEMICOLON_list1) )
 end
)
 in (LrTable.NT 15,(result,LET1left,END1right),rest671) end
| (49,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.exp exp1,_,_))::
(_,(_,LPARleft as LPAR1left,_))::rest671) => let val result=
MlyValue.atexp(fn _ => let val exp as exp1=exp1 ()
 in ( PARAtExp(I(LPARleft,RPARright), exp) ) end
)
 in (LrTable.NT 15,(result,LPAR1left,RPAR1right),rest671) end
| (50,(_,(MlyValue.exp_COMMA_list1 exp_COMMA_list11,
exp_COMMA_list11left,exp_COMMA_list11right))::rest671) => let val 
result=MlyValue.exp_COMMA_list0(fn _ => let val exp_COMMA_list1 as 
exp_COMMA_list11=exp_COMMA_list11 ()
 in ( exp_COMMA_list1 ) end
)
 in (LrTable.NT 16,(result,exp_COMMA_list11left,exp_COMMA_list11right)
,rest671) end
| (51,rest671) => let val result=MlyValue.exp_COMMA_list0(fn _ => (
 [] ))
 in (LrTable.NT 16,(result,defaultPos,defaultPos),rest671) end
| (52,(_,(MlyValue.exp_COMMA_list1 exp_COMMA_list11,_,
exp_COMMA_list11right))::_::(_,(MlyValue.exp exp1,exp1left,_))::
rest671) => let val result=MlyValue.exp_COMMA_list1(fn _ => let val 
exp as exp1=exp1 ()
val exp_COMMA_list1 as exp_COMMA_list11=exp_COMMA_list11 ()
 in ( exp::exp_COMMA_list1 ) end
)
 in (LrTable.NT 17,(result,exp1left,exp_COMMA_list11right),rest671)
 end
| (53,(_,(MlyValue.exp exp1,exp1left,exp1right))::rest671) => let val 
result=MlyValue.exp_COMMA_list1(fn _ => let val exp as exp1=exp1 ()
 in ( exp::[] ) end
)
 in (LrTable.NT 17,(result,exp1left,exp1right),rest671) end
| (54,(_,(MlyValue.exp_COMMA_list1 exp_COMMA_list11,_,
exp_COMMA_list11right))::_::(_,(MlyValue.exp exp1,exp1left,_))::
rest671) => let val result=MlyValue.exp_COMMA_list2(fn _ => let val 
exp as exp1=exp1 ()
val exp_COMMA_list1 as exp_COMMA_list11=exp_COMMA_list11 ()
 in ( exp::exp_COMMA_list1 ) end
)
 in (LrTable.NT 18,(result,exp1left,exp_COMMA_list11right),rest671)
 end
| (55,(_,(MlyValue.exp_SEMICOLON_list1 exp_SEMICOLON_list11,_,
exp_SEMICOLON_list11right))::_::(_,(MlyValue.exp exp1,exp1left,_))::
rest671) => let val result=MlyValue.exp_SEMICOLON_list1(fn _ => let 
val exp as exp1=exp1 ()
val exp_SEMICOLON_list1 as exp_SEMICOLON_list11=exp_SEMICOLON_list11 
()
 in ( exp::exp_SEMICOLON_list1 ) end
)
 in (LrTable.NT 19,(result,exp1left,exp_SEMICOLON_list11right),rest671
) end
| (56,(_,(MlyValue.exp exp1,exp1left,exp1right))::rest671) => let val 
result=MlyValue.exp_SEMICOLON_list1(fn _ => let val exp as exp1=exp1 
()
 in ( exp::[] ) end
)
 in (LrTable.NT 19,(result,exp1left,exp1right),rest671) end
| (57,(_,(MlyValue.exp_SEMICOLON_list1 exp_SEMICOLON_list11,_,
exp_SEMICOLON_list11right))::_::(_,(MlyValue.exp exp1,exp1left,_))::
rest671) => let val result=MlyValue.exp_SEMICOLON_list2(fn _ => let 
val exp as exp1=exp1 ()
val exp_SEMICOLON_list1 as exp_SEMICOLON_list11=exp_SEMICOLON_list11 
()
 in ( exp::exp_SEMICOLON_list1 ) end
)
 in (LrTable.NT 20,(result,exp1left,exp_SEMICOLON_list11right),rest671
) end
| (58,(_,(MlyValue.COMMA_exprow_opt COMMA_exprow_opt1,_,
COMMA_exprow_optright as COMMA_exprow_opt1right))::(_,(MlyValue.exp 
exp1,_,_))::_::(_,(MlyValue.lab lab1,lableft as lab1left,_))::rest671)
 => let val result=MlyValue.exprow(fn _ => let val lab as lab1=lab1 ()
val exp as exp1=exp1 ()
val COMMA_exprow_opt as COMMA_exprow_opt1=COMMA_exprow_opt1 ()
 in (
 ROWExpRow(I(lableft,COMMA_exprow_optright),
	  				    lab, exp, COMMA_exprow_opt) 
) end
)
 in (LrTable.NT 21,(result,lab1left,COMMA_exprow_opt1right),rest671)
 end
| (59,(_,(MlyValue.COMMA_exprow_opt COMMA_exprow_opt1,_,
COMMA_exprow_optright as COMMA_exprow_opt1right))::(_,(
MlyValue.COLON_ty_opt COLON_ty_opt1,_,_))::(_,(MlyValue.vid' vid'1,
vid'left as vid'1left,_))::rest671) => let val result=MlyValue.exprow(
fn _ => let val vid' as vid'1=vid'1 ()
val COLON_ty_opt as COLON_ty_opt1=COLON_ty_opt1 ()
val COMMA_exprow_opt as COMMA_exprow_opt1=COMMA_exprow_opt1 ()
 in (
 VIDExpRow(I(vid'left,COMMA_exprow_optright),
	  				    vid', COLON_ty_opt,
					    COMMA_exprow_opt) 
) end
)
 in (LrTable.NT 21,(result,vid'1left,COMMA_exprow_opt1right),rest671)
 end
| (60,(_,(MlyValue.exprow exprow1,_,exprow1right))::(_,(_,COMMA1left,_
))::rest671) => let val result=MlyValue.COMMA_exprow_opt(fn _ => let 
val exprow as exprow1=exprow1 ()
 in ( SOME exprow ) end
)
 in (LrTable.NT 23,(result,COMMA1left,exprow1right),rest671) end
| (61,rest671) => let val result=MlyValue.COMMA_exprow_opt(fn _ => (
 NONE ))
 in (LrTable.NT 23,(result,defaultPos,defaultPos),rest671) end
| (62,(_,(MlyValue.exprow exprow1,exprow1left,exprow1right))::rest671)
 => let val result=MlyValue.exprow_opt(fn _ => let val exprow as 
exprow1=exprow1 ()
 in ( SOME exprow ) end
)
 in (LrTable.NT 22,(result,exprow1left,exprow1right),rest671) end
| (63,rest671) => let val result=MlyValue.exprow_opt(fn _ => ( NONE ))
 in (LrTable.NT 22,(result,defaultPos,defaultPos),rest671) end
| (64,(_,(MlyValue.atexp atexp1,atexpleft as atexp1left,atexpright as 
atexp1right))::rest671) => let val result=MlyValue.appexp(fn _ => let 
val atexp as atexp1=atexp1 ()
 in ( ATEXPExp(I(atexpleft,atexpright), atexp) ) end
)
 in (LrTable.NT 24,(result,atexp1left,atexp1right),rest671) end
| (65,(_,(MlyValue.atexp atexp1,_,atexpright as atexp1right))::(_,(
MlyValue.appexp appexp1,appexpleft as appexp1left,_))::rest671) => 
let val result=MlyValue.appexp(fn _ => let val appexp as appexp1=
appexp1 ()
val atexp as atexp1=atexp1 ()
 in ( APPExp(I(appexpleft,atexpright),
					 appexp, atexp) ) end
)
 in (LrTable.NT 24,(result,appexp1left,atexp1right),rest671) end
| (66,(_,(MlyValue.appexp appexp1,appexp1left,appexp1right))::rest671)
 => let val result=MlyValue.infexp(fn _ => let val appexp as appexp1=
appexp1 ()
 in ( appexp ) end
)
 in (LrTable.NT 25,(result,appexp1left,appexp1right),rest671) end
| (67,(_,(MlyValue.infexp infexp1,infexp1left,infexp1right))::rest671)
 => let val result=MlyValue.exp(fn _ => let val infexp as infexp1=
infexp1 ()
 in ( infexp ) end
)
 in (LrTable.NT 26,(result,infexp1left,infexp1right),rest671) end
| (68,(_,(MlyValue.ty ty1,_,tyright as ty1right))::_::(_,(MlyValue.exp
 exp1,expleft as exp1left,_))::rest671) => let val result=MlyValue.exp
(fn _ => let val exp as exp1=exp1 ()
val ty as ty1=ty1 ()
 in ( TYPEDExp(I(expleft,tyright), exp, ty) ) end
)
 in (LrTable.NT 26,(result,exp1left,ty1right),rest671) end
| (69,(_,(MlyValue.exp exp2,_,exp2right))::_::(_,(MlyValue.exp exp1,
exp1left,_))::rest671) => let val result=MlyValue.exp(fn _ => let val 
exp1=exp1 ()
val exp2=exp2 ()
 in ( ANDALSOExp(I(exp1left,exp2right), exp1, exp2)) end
)
 in (LrTable.NT 26,(result,exp1left,exp2right),rest671) end
| (70,(_,(MlyValue.exp exp2,_,exp2right))::_::(_,(MlyValue.exp exp1,
exp1left,_))::rest671) => let val result=MlyValue.exp(fn _ => let val 
exp1=exp1 ()
val exp2=exp2 ()
 in ( ORELSEExp(I(exp1left,exp2right), exp1, exp2) ) end
)
 in (LrTable.NT 26,(result,exp1left,exp2right),rest671) end
| (71,(_,(MlyValue.match match1,_,matchright as match1right))::_::(_,(
MlyValue.exp exp1,expleft as exp1left,_))::rest671) => let val result=
MlyValue.exp(fn _ => let val exp as exp1=exp1 ()
val match as match1=match1 ()
 in ( HANDLEExp(I(expleft,matchright), exp, match) ) end
)
 in (LrTable.NT 26,(result,exp1left,match1right),rest671) end
| (72,(_,(MlyValue.exp exp1,_,expright as exp1right))::(_,(_,RAISEleft
 as RAISE1left,_))::rest671) => let val result=MlyValue.exp(fn _ => 
let val exp as exp1=exp1 ()
 in ( RAISEExp(I(RAISEleft,expright), exp) ) end
)
 in (LrTable.NT 26,(result,RAISE1left,exp1right),rest671) end
| (73,(_,(MlyValue.exp exp3,_,exp3right))::_::(_,(MlyValue.exp exp2,_,
_))::_::(_,(MlyValue.exp exp1,_,_))::(_,(_,IFleft as IF1left,_))::
rest671) => let val result=MlyValue.exp(fn _ => let val exp1=exp1 ()
val exp2=exp2 ()
val exp3=exp3 ()
 in ( IFExp(I(IFleft,exp3right), exp1, exp2, exp3) ) end
)
 in (LrTable.NT 26,(result,IF1left,exp3right),rest671) end
| (74,(_,(MlyValue.exp exp2,_,exp2right))::_::(_,(MlyValue.exp exp1,_,
_))::(_,(_,WHILEleft as WHILE1left,_))::rest671) => let val result=
MlyValue.exp(fn _ => let val exp1=exp1 ()
val exp2=exp2 ()
 in ( WHILEExp(I(WHILEleft,exp2right), exp1, exp2) ) end
)
 in (LrTable.NT 26,(result,WHILE1left,exp2right),rest671) end
| (75,(_,(MlyValue.match match1,_,matchright as match1right))::_::(_,(
MlyValue.exp exp1,_,_))::(_,(_,CASEleft as CASE1left,_))::rest671) => 
let val result=MlyValue.exp(fn _ => let val exp as exp1=exp1 ()
val match as match1=match1 ()
 in ( CASEExp(I(CASEleft,matchright), exp, match) ) end
)
 in (LrTable.NT 26,(result,CASE1left,match1right),rest671) end
| (76,(_,(MlyValue.match match1,_,matchright as match1right))::(_,(_,
FNleft as FN1left,_))::rest671) => let val result=MlyValue.exp(fn _
 => let val match as match1=match1 ()
 in ( FNExp(I(FNleft,matchright), match) ) end
)
 in (LrTable.NT 26,(result,FN1left,match1right),rest671) end
| (77,(_,(MlyValue.exp exp1,_,expright as exp1right))::_::(_,(
MlyValue.pat pat1,_,_))::(_,(_,RECleft as REC1left,_))::rest671) => 
let val result=MlyValue.exp(fn _ => let val pat as pat1=pat1 ()
val exp as exp1=exp1 ()
 in ( RECExp(I(RECleft,expright), pat, exp) ) end
)
 in (LrTable.NT 26,(result,REC1left,exp1right),rest671) end
| (78,(_,(MlyValue.longstrid longstrid1,_,longstridright as 
longstrid1right))::(_,(_,PACKleft as PACK1left,_))::rest671) => let 
val result=MlyValue.exp(fn _ => let val longstrid as longstrid1=
longstrid1 ()
 in ( PACKExp(I(PACKleft,longstridright),
					  longstrid) ) end
)
 in (LrTable.NT 26,(result,PACK1left,longstrid1right),rest671) end
| (79,(_,(MlyValue.BAR_match_opt BAR_match_opt1,_,BAR_match_optright
 as BAR_match_opt1right))::(_,(MlyValue.mrule mrule1,mruleleft as 
mrule1left,_))::rest671) => let val result=MlyValue.match(fn _ => let 
val mrule as mrule1=mrule1 ()
val BAR_match_opt as BAR_match_opt1=BAR_match_opt1 ()
 in (
 Match(I(mruleleft,BAR_match_optright),
					mrule, BAR_match_opt) )
 end
)
 in (LrTable.NT 27,(result,mrule1left,BAR_match_opt1right),rest671)
 end
| (80,(_,(MlyValue.match match1,_,match1right))::(_,(_,BAR1left,_))::
rest671) => let val result=MlyValue.BAR_match_opt(fn _ => let val 
match as match1=match1 ()
 in ( SOME match ) end
)
 in (LrTable.NT 28,(result,BAR1left,match1right),rest671) end
| (81,rest671) => let val result=MlyValue.BAR_match_opt(fn _ => (
 NONE ))
 in (LrTable.NT 28,(result,defaultPos,defaultPos),rest671) end
| (82,(_,(MlyValue.exp exp1,_,expright as exp1right))::_::(_,(
MlyValue.pat pat1,patleft as pat1left,_))::rest671) => let val result=
MlyValue.mrule(fn _ => let val pat as pat1=pat1 ()
val exp as exp1=exp1 ()
 in ( Mrule(I(patleft,expright), pat, exp) ) end
)
 in (LrTable.NT 29,(result,pat1left,exp1right),rest671) end
| (83,(_,(MlyValue.dec1 dec11,dec11left,dec11right))::rest671) => let 
val result=MlyValue.dec(fn _ => let val dec1 as dec11=dec11 ()
 in ( dec1 ) end
)
 in (LrTable.NT 30,(result,dec11left,dec11right),rest671) end
| (84,rest671) => let val result=MlyValue.dec(fn _ => (
 EMPTYDec(I(defaultPos,defaultPos)) ))
 in (LrTable.NT 30,(result,defaultPos,defaultPos),rest671) end
| (85,(_,(MlyValue.dec1' dec1'1,dec1'1left,dec1'1right))::rest671) => 
let val result=MlyValue.dec'(fn _ => let val dec1' as dec1'1=dec1'1 ()
 in ( dec1' ) end
)
 in (LrTable.NT 31,(result,dec1'1left,dec1'1right),rest671) end
| (86,(_,(MlyValue.dec' dec'2,_,dec'2right))::(_,(MlyValue.dec' dec'1,
dec'1left,_))::rest671) => let val result=MlyValue.dec'(fn _ => let 
val dec'1=dec'1 ()
val dec'2=dec'2 ()
 in ( SEQDec(I(dec'1left,dec'2right), dec'1, dec'2) ) end
)
 in (LrTable.NT 31,(result,dec'1left,dec'2right),rest671) end
| (87,(_,(MlyValue.dec1' dec1'1,dec1'1left,dec1'1right))::rest671) => 
let val result=MlyValue.dec1(fn _ => let val dec1' as dec1'1=dec1'1 ()
 in ( dec1' ) end
)
 in (LrTable.NT 32,(result,dec1'1left,dec1'1right),rest671) end
| (88,(_,(_,SEMICOLONleft as SEMICOLON1left,SEMICOLON1right))::rest671
) => let val result=MlyValue.dec1(fn _ => (
 EMPTYDec(I(SEMICOLONleft,SEMICOLONleft)) ))
 in (LrTable.NT 32,(result,SEMICOLON1left,SEMICOLON1right),rest671)
 end
| (89,(_,(MlyValue.dec1 dec12,_,dec12right))::(_,(MlyValue.dec1 dec11,
dec11left,_))::rest671) => let val result=MlyValue.dec1(fn _ => let 
val dec11=dec11 ()
val dec12=dec12 ()
 in ( SEQDec(I(dec11left,dec12right), dec11, dec12) ) end
)
 in (LrTable.NT 32,(result,dec11left,dec12right),rest671) end
| (90,(_,(MlyValue.dec1'' dec1''1,dec1''1left,dec1''1right))::rest671)
 => let val result=MlyValue.dec1'(fn _ => let val dec1'' as dec1''1=
dec1''1 ()
 in ( dec1'' ) end
)
 in (LrTable.NT 33,(result,dec1''1left,dec1''1right),rest671) end
| (91,(_,(_,_,ENDright as END1right))::(_,(MlyValue.dec dec2,_,_))::_
::(_,(MlyValue.dec dec1,_,_))::(_,(_,LOCALleft as LOCAL1left,_))::
rest671) => let val result=MlyValue.dec1'(fn _ => let val dec1=dec1 ()
val dec2=dec2 ()
 in ( LOCALDec(I(LOCALleft,ENDright), dec1, dec2) ) end
)
 in (LrTable.NT 33,(result,LOCAL1left,END1right),rest671) end
| (92,(_,(MlyValue.valbind valbind1,_,valbindright as valbind1right))
::(_,(_,VALleft as VAL1left,_))::rest671) => let val result=
MlyValue.dec1''(fn _ => let val valbind as valbind1=valbind1 ()
 in (
 VALDec(I(VALleft,valbindright),
				 Seq(I(defaultPos,defaultPos), []), valbind) 
) end
)
 in (LrTable.NT 34,(result,VAL1left,valbind1right),rest671) end
| (93,(_,(MlyValue.valbind valbind1,_,valbindright as valbind1right))
::(_,(MlyValue.tyvarseq1 tyvarseq11,_,_))::(_,(_,VALleft as VAL1left,_
))::rest671) => let val result=MlyValue.dec1''(fn _ => let val 
tyvarseq1 as tyvarseq11=tyvarseq11 ()
val valbind as valbind1=valbind1 ()
 in ( VALDec(I(VALleft,valbindright), tyvarseq1, valbind) ) end
)
 in (LrTable.NT 34,(result,VAL1left,valbind1right),rest671) end
| (94,(_,(MlyValue.fvalbind fvalbind1,_,fvalbindright as 
fvalbind1right))::(_,(_,FUNleft as FUN1left,_))::rest671) => let val 
result=MlyValue.dec1''(fn _ => let val fvalbind as fvalbind1=fvalbind1
 ()
 in (
 FUNDec(I(FUNleft,fvalbindright),
				 Seq(I(defaultPos,defaultPos), []), fvalbind) 
) end
)
 in (LrTable.NT 34,(result,FUN1left,fvalbind1right),rest671) end
| (95,(_,(MlyValue.fvalbind fvalbind1,_,fvalbindright as 
fvalbind1right))::(_,(MlyValue.tyvarseq1 tyvarseq11,_,_))::(_,(_,
FUNleft as FUN1left,_))::rest671) => let val result=MlyValue.dec1''(
fn _ => let val tyvarseq1 as tyvarseq11=tyvarseq11 ()
val fvalbind as fvalbind1=fvalbind1 ()
 in ( FUNDec(I(FUNleft,fvalbindright), tyvarseq1, fvalbind)) end
)
 in (LrTable.NT 34,(result,FUN1left,fvalbind1right),rest671) end
| (96,(_,(MlyValue.typbind typbind1,_,typbindright as typbind1right))
::(_,(_,TYPEleft as TYPE1left,_))::rest671) => let val result=
MlyValue.dec1''(fn _ => let val typbind as typbind1=typbind1 ()
 in ( TYPEDec(I(TYPEleft,typbindright), typbind) ) end
)
 in (LrTable.NT 34,(result,TYPE1left,typbind1right),rest671) end
| (97,(_,(MlyValue.typbind typbind1,_,typbindright as typbind1right))
::(_,(_,EQTYPEleft as EQTYPE1left,_))::rest671) => let val result=
MlyValue.dec1''(fn _ => let val typbind as typbind1=typbind1 ()
 in ( EQTYPEDec(I(EQTYPEleft,typbindright), typbind) ) end
)
 in (LrTable.NT 34,(result,EQTYPE1left,typbind1right),rest671) end
| (98,(_,(MlyValue.typbind typbind1,_,typbindright as typbind1right))
::(_,(_,EQEQTYPEleft as EQEQTYPE1left,_))::rest671) => let val result=
MlyValue.dec1''(fn _ => let val typbind as typbind1=typbind1 ()
 in ( EQEQTYPEDec(I(EQEQTYPEleft,typbindright), typbind) ) end
)
 in (LrTable.NT 34,(result,EQEQTYPE1left,typbind1right),rest671) end
| (99,(_,(MlyValue.WITHTYPE_typbind_opt WITHTYPE_typbind_opt1,_,
WITHTYPE_typbind_optright as WITHTYPE_typbind_opt1right))::(_,(
MlyValue.datbind0 datbind01,_,_))::(_,(_,DATATYPEleft as DATATYPE1left
,_))::rest671) => let val result=MlyValue.dec1''(fn _ => let val 
datbind0 as datbind01=datbind01 ()
val WITHTYPE_typbind_opt as WITHTYPE_typbind_opt1=
WITHTYPE_typbind_opt1 ()
 in (
 DATATYPEDec(I(DATATYPEleft,WITHTYPE_typbind_optright),
				      datbind0, WITHTYPE_typbind_opt) 
) end
)
 in (LrTable.NT 34,(result,DATATYPE1left,WITHTYPE_typbind_opt1right),
rest671) end
| (100,(_,(MlyValue.WITHTYPE_typbind_opt WITHTYPE_typbind_opt1,_,
WITHTYPE_typbind_optright as WITHTYPE_typbind_opt1right))::(_,(
MlyValue.datbind1 datbind11,_,_))::(_,(_,DATATYPEleft as DATATYPE1left
,_))::rest671) => let val result=MlyValue.dec1''(fn _ => let val 
datbind1 as datbind11=datbind11 ()
val WITHTYPE_typbind_opt as WITHTYPE_typbind_opt1=
WITHTYPE_typbind_opt1 ()
 in (
 DATATYPEDec(I(DATATYPEleft,WITHTYPE_typbind_optright),
				      datbind1, WITHTYPE_typbind_opt) 
) end
)
 in (LrTable.NT 34,(result,DATATYPE1left,WITHTYPE_typbind_opt1right),
rest671) end
| (101,(_,(MlyValue.longtycon longtycon1,_,longtyconright as 
longtycon1right))::_::_::(_,(MlyValue.tycon tycon1,_,_))::(_,(_,
DATATYPEleft as DATATYPE1left,_))::rest671) => let val result=
MlyValue.dec1''(fn _ => let val tycon as tycon1=tycon1 ()
val longtycon as longtycon1=longtycon1 ()
 in (
 REPLICATIONDec(I(DATATYPEleft,longtyconright),
					 tycon, longtycon) 
) end
)
 in (LrTable.NT 34,(result,DATATYPE1left,longtycon1right),rest671) end
| (102,(_,(_,_,ENDright as END1right))::(_,(MlyValue.dec dec1,_,_))::_
::(_,(MlyValue.WITHTYPE_typbind_opt WITHTYPE_typbind_opt1,_,_))::(_,(
MlyValue.datbind datbind1,_,_))::(_,(_,ABSTYPEleft as ABSTYPE1left,_))
::rest671) => let val result=MlyValue.dec1''(fn _ => let val datbind
 as datbind1=datbind1 ()
val WITHTYPE_typbind_opt as WITHTYPE_typbind_opt1=
WITHTYPE_typbind_opt1 ()
val dec as dec1=dec1 ()
 in (
 ABSTYPEDec(I(ABSTYPEleft,ENDright), datbind,
				     WITHTYPE_typbind_opt, dec) 
) end
)
 in (LrTable.NT 34,(result,ABSTYPE1left,END1right),rest671) end
| (103,(_,(MlyValue.dconbind dconbind1,_,dconbindright as 
dconbind1right))::(_,(_,CONSTRUCTORleft as CONSTRUCTOR1left,_))::
rest671) => let val result=MlyValue.dec1''(fn _ => let val dconbind
 as dconbind1=dconbind1 ()
 in (
 CONSTRUCTORDec(I(CONSTRUCTORleft,dconbindright),
					 dconbind) )
 end
)
 in (LrTable.NT 34,(result,CONSTRUCTOR1left,dconbind1right),rest671)
 end
| (104,(_,(MlyValue.exbind exbind1,_,exbindright as exbind1right))::(_
,(_,EXCEPTIONleft as EXCEPTION1left,_))::rest671) => let val result=
MlyValue.dec1''(fn _ => let val exbind as exbind1=exbind1 ()
 in ( EXCEPTIONDec(I(EXCEPTIONleft,exbindright), exbind) ) end
)
 in (LrTable.NT 34,(result,EXCEPTION1left,exbind1right),rest671) end
| (105,(_,(MlyValue.strbind strbind1,_,strbindright as strbind1right))
::(_,(_,STRUCTUREleft as STRUCTURE1left,_))::rest671) => let val 
result=MlyValue.dec1''(fn _ => let val strbind as strbind1=strbind1 ()
 in ( STRUCTUREDec(I(STRUCTUREleft,strbindright), strbind) ) end
)
 in (LrTable.NT 34,(result,STRUCTURE1left,strbind1right),rest671) end
| (106,(_,(MlyValue.sigbind sigbind1,_,sigbindright as sigbind1right))
::(_,(_,SIGNATUREleft as SIGNATURE1left,_))::rest671) => let val 
result=MlyValue.dec1''(fn _ => let val sigbind as sigbind1=sigbind1 ()
 in ( SIGNATUREDec(I(SIGNATUREleft,sigbindright), sigbind) ) end
)
 in (LrTable.NT 34,(result,SIGNATURE1left,sigbind1right),rest671) end
| (107,(_,(MlyValue.funbind funbind1,_,funbindright as funbind1right))
::(_,(_,FUNCTORleft as FUNCTOR1left,_))::rest671) => let val result=
MlyValue.dec1''(fn _ => let val funbind as funbind1=funbind1 ()
 in ( FUNCTORDec(I(FUNCTORleft,funbindright), funbind) ) end
)
 in (LrTable.NT 34,(result,FUNCTOR1left,funbind1right),rest671) end
| (108,(_,(MlyValue.longstrid_list1 longstrid_list11,_,
longstrid_list1right as longstrid_list11right))::(_,(_,OPENleft as 
OPEN1left,_))::rest671) => let val result=MlyValue.dec1''(fn _ => let 
val longstrid_list1 as longstrid_list11=longstrid_list11 ()
 in (
 OPENMULTIDec(I(OPENleft,longstrid_list1right),
				       longstrid_list1) 
) end
)
 in (LrTable.NT 34,(result,OPEN1left,longstrid_list11right),rest671)
 end
| (109,(_,(MlyValue.STRING STRING1,_,STRINGright as STRING1right))::_
::(_,(MlyValue.ty ty1,_,_))::_::(_,(MlyValue.vid vid1,_,_))::(_,(
MlyValue.OP_opt OP_opt1,_,_))::_::(_,(_,PRIMITIVEleft as 
PRIMITIVE1left,_))::rest671) => let val result=MlyValue.dec1''(fn _
 => let val OP_opt as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val ty as ty1=ty1 ()
val STRING as STRING1=STRING1 ()
 in (
 PRIMITIVEVALDec(I(PRIMITIVEleft,STRINGright),
					  OP_opt, vid, ty, STRING) 
) end
)
 in (LrTable.NT 34,(result,PRIMITIVE1left,STRING1right),rest671) end
| (110,(_,(MlyValue.STRING STRING1,_,STRINGright as STRING1right))::_
::(_,(MlyValue.longtycon longtycon1,_,_))::(_,(MlyValue.tyvarseq 
tyvarseq1,_,_))::_::(_,(MlyValue.OF_ty_opt OF_ty_opt1,_,_))::(_,(
MlyValue.vid vid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::_::(_,(_,
PRIMITIVEleft as PRIMITIVE1left,_))::rest671) => let val result=
MlyValue.dec1''(fn _ => let val OP_opt as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val OF_ty_opt as OF_ty_opt1=OF_ty_opt1 ()
val tyvarseq as tyvarseq1=tyvarseq1 ()
val longtycon as longtycon1=longtycon1 ()
val STRING as STRING1=STRING1 ()
 in (
 PRIMITIVECONSTRUCTORDec(I(PRIMITIVEleft,STRINGright),
						  OP_opt, vid, OF_ty_opt,
						  tyvarseq, longtycon, STRING) 
) end
)
 in (LrTable.NT 34,(result,PRIMITIVE1left,STRING1right),rest671) end
| (111,(_,(MlyValue.STRING STRING1,_,STRINGright as STRING1right))::_
::(_,(MlyValue.sigexp sigexp1,_,_))::_::(_,(MlyValue.strid strid1,_,_)
)::_::(_,(_,PRIMITIVEleft as PRIMITIVE1left,_))::rest671) => let val 
result=MlyValue.dec1''(fn _ => let val strid as strid1=strid1 ()
val sigexp as sigexp1=sigexp1 ()
val STRING as STRING1=STRING1 ()
 in (
 PRIMITIVESTRUCTUREDec(I(PRIMITIVEleft,STRINGright),
						strid, sigexp, STRING) 
) end
)
 in (LrTable.NT 34,(result,PRIMITIVE1left,STRING1right),rest671) end
| (112,(_,(MlyValue.ty ty1,_,tyright as ty1right))::_::(_,(
MlyValue.tyvar tyvar1,_,_))::_::(_,(MlyValue.vid vid1,_,_))::(_,(
MlyValue.OP_opt OP_opt1,_,_))::(_,(_,OVERLOADleft as OVERLOAD1left,_))
::rest671) => let val result=MlyValue.dec1''(fn _ => let val OP_opt
 as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val tyvar as tyvar1=tyvar1 ()
val ty as ty1=ty1 ()
 in (
 OVERLOADDec(I(OVERLOADleft,tyright),
				      OP_opt, vid, tyvar, ty) 
) end
)
 in (LrTable.NT 34,(result,OVERLOAD1left,ty1right),rest671) end
| (113,(_,(MlyValue.longvid longvid1,_,longvidright as longvid1right))
::_::(_,(MlyValue.longtycon longtycon1,_,_))::_::(_,(MlyValue.vid vid1
,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,INSTANCEleft as 
INSTANCE1left,_))::rest671) => let val result=MlyValue.dec1''(fn _ => 
let val OP_opt as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val longtycon as longtycon1=longtycon1 ()
val longvid as longvid1=longvid1 ()
 in (
 INSTANCEDec(I(INSTANCEleft,longvidright),
				      OP_opt, vid, longtycon, longvid) 
) end
)
 in (LrTable.NT 34,(result,INSTANCE1left,longvid1right),rest671) end
| (114,(_,(MlyValue.longtycon longtycon1,_,longtyconright as 
longtycon1right))::_::(_,(MlyValue.scon scon1,_,_))::(_,(_,
INSTANCEleft as INSTANCE1left,_))::rest671) => let val result=
MlyValue.dec1''(fn _ => let val scon as scon1=scon1 ()
val longtycon as longtycon1=longtycon1 ()
 in (
 INSTANCESCONDec(I(INSTANCEleft,longtyconright),
					  scon, longtycon) 
) end
)
 in (LrTable.NT 34,(result,INSTANCE1left,longtycon1right),rest671) end
| (115,(_,(MlyValue.vid_list1 vid_list11,_,vid_list1right as 
vid_list11right))::(_,(MlyValue.d_opt d_opt1,_,_))::(_,(_,INFIXleft
 as INFIX1left,_))::rest671) => let val result=MlyValue.dec1''(fn _
 => let val d_opt as d_opt1=d_opt1 ()
val vid_list1 as vid_list11=vid_list11 ()
 in (
 INFIXMULTIDec(I(INFIXleft,vid_list1right),
					d_opt, vid_list1) )
 end
)
 in (LrTable.NT 34,(result,INFIX1left,vid_list11right),rest671) end
| (116,(_,(MlyValue.vid_list1 vid_list11,_,vid_list1right as 
vid_list11right))::(_,(MlyValue.d_opt d_opt1,_,_))::(_,(_,INFIXRleft
 as INFIXR1left,_))::rest671) => let val result=MlyValue.dec1''(fn _
 => let val d_opt as d_opt1=d_opt1 ()
val vid_list1 as vid_list11=vid_list11 ()
 in (
 INFIXRMULTIDec(I(INFIXRleft,vid_list1right),
					 d_opt, vid_list1) 
) end
)
 in (LrTable.NT 34,(result,INFIXR1left,vid_list11right),rest671) end
| (117,(_,(MlyValue.vid_list1 vid_list11,_,vid_list1right as 
vid_list11right))::(_,(_,NONFIXleft as NONFIX1left,_))::rest671) => 
let val result=MlyValue.dec1''(fn _ => let val vid_list1 as vid_list11
=vid_list11 ()
 in ( NONFIXMULTIDec(I(NONFIXleft,vid_list1right),
					 vid_list1) )
 end
)
 in (LrTable.NT 34,(result,NONFIX1left,vid_list11right),rest671) end
| (118,(_,(MlyValue.typbind typbind1,_,typbind1right))::(_,(_,
WITHTYPE1left,_))::rest671) => let val result=
MlyValue.WITHTYPE_typbind_opt(fn _ => let val typbind as typbind1=
typbind1 ()
 in ( SOME typbind ) end
)
 in (LrTable.NT 35,(result,WITHTYPE1left,typbind1right),rest671) end
| (119,rest671) => let val result=MlyValue.WITHTYPE_typbind_opt(fn _
 => ( NONE ))
 in (LrTable.NT 35,(result,defaultPos,defaultPos),rest671) end
| (120,(_,(MlyValue.vid_list1 vid_list11,_,vid_list11right))::(_,(
MlyValue.vid vid1,vid1left,_))::rest671) => let val result=
MlyValue.vid_list1(fn _ => let val vid as vid1=vid1 ()
val vid_list1 as vid_list11=vid_list11 ()
 in ( vid::vid_list1 ) end
)
 in (LrTable.NT 36,(result,vid1left,vid_list11right),rest671) end
| (121,(_,(MlyValue.vid vid1,vid1left,vid1right))::rest671) => let 
val result=MlyValue.vid_list1(fn _ => let val vid as vid1=vid1 ()
 in ( vid::[] ) end
)
 in (LrTable.NT 36,(result,vid1left,vid1right),rest671) end
| (122,(_,(MlyValue.longstrid_list1 longstrid_list11,_,
longstrid_list11right))::(_,(MlyValue.longstrid longstrid1,
longstrid1left,_))::rest671) => let val result=
MlyValue.longstrid_list1(fn _ => let val longstrid as longstrid1=
longstrid1 ()
val longstrid_list1 as longstrid_list11=longstrid_list11 ()
 in ( longstrid::longstrid_list1 ) end
)
 in (LrTable.NT 37,(result,longstrid1left,longstrid_list11right),
rest671) end
| (123,(_,(MlyValue.longstrid longstrid1,longstrid1left,
longstrid1right))::rest671) => let val result=MlyValue.longstrid_list1
(fn _ => let val longstrid as longstrid1=longstrid1 ()
 in ( longstrid::[] ) end
)
 in (LrTable.NT 37,(result,longstrid1left,longstrid1right),rest671)
 end
| (124,(_,(MlyValue.d d1,d1left,d1right))::rest671) => let val result=
MlyValue.d_opt(fn _ => let val d as d1=d1 ()
 in ( SOME d ) end
)
 in (LrTable.NT 38,(result,d1left,d1right),rest671) end
| (125,rest671) => let val result=MlyValue.d_opt(fn _ => ( NONE ))
 in (LrTable.NT 38,(result,defaultPos,defaultPos),rest671) end
| (126,(_,(MlyValue.AND_valbind_opt AND_valbind_opt1,_,
AND_valbind_optright as AND_valbind_opt1right))::(_,(MlyValue.exp exp1
,_,_))::_::(_,(MlyValue.pat pat1,patleft as pat1left,_))::rest671) => 
let val result=MlyValue.valbind(fn _ => let val pat as pat1=pat1 ()
val exp as exp1=exp1 ()
val AND_valbind_opt as AND_valbind_opt1=AND_valbind_opt1 ()
 in (
 PLAINValBind(I(patleft,AND_valbind_optright),
				       pat, exp, AND_valbind_opt) 
) end
)
 in (LrTable.NT 39,(result,pat1left,AND_valbind_opt1right),rest671)
 end
| (127,(_,(MlyValue.valbind valbind1,_,valbindright as valbind1right))
::(_,(_,RECleft as REC1left,_))::rest671) => let val result=
MlyValue.valbind(fn _ => let val valbind as valbind1=valbind1 ()
 in ( RECValBind(I(RECleft,valbindright), valbind) ) end
)
 in (LrTable.NT 39,(result,REC1left,valbind1right),rest671) end
| (128,(_,(MlyValue.valbind valbind1,_,valbind1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_valbind_opt(fn _ => let 
val valbind as valbind1=valbind1 ()
 in ( SOME valbind ) end
)
 in (LrTable.NT 40,(result,AND1left,valbind1right),rest671) end
| (129,rest671) => let val result=MlyValue.AND_valbind_opt(fn _ => (
 NONE ))
 in (LrTable.NT 40,(result,defaultPos,defaultPos),rest671) end
| (130,(_,(MlyValue.AND_fvalbind_opt AND_fvalbind_opt1,_,
AND_fvalbind_optright as AND_fvalbind_opt1right))::(_,(MlyValue.fmatch
 fmatch1,fmatchleft as fmatch1left,_))::rest671) => let val result=
MlyValue.fvalbind(fn _ => let val fmatch as fmatch1=fmatch1 ()
val AND_fvalbind_opt as AND_fvalbind_opt1=AND_fvalbind_opt1 ()
 in (
 FvalBind(I(fmatchleft,AND_fvalbind_optright),
				     fmatch, AND_fvalbind_opt) 
) end
)
 in (LrTable.NT 41,(result,fmatch1left,AND_fvalbind_opt1right),rest671
) end
| (131,(_,(MlyValue.fvalbind fvalbind1,_,fvalbind1right))::(_,(_,
AND1left,_))::rest671) => let val result=MlyValue.AND_fvalbind_opt(fn 
_ => let val fvalbind as fvalbind1=fvalbind1 ()
 in ( SOME fvalbind ) end
)
 in (LrTable.NT 42,(result,AND1left,fvalbind1right),rest671) end
| (132,rest671) => let val result=MlyValue.AND_fvalbind_opt(fn _ => (
 NONE ))
 in (LrTable.NT 42,(result,defaultPos,defaultPos),rest671) end
| (133,(_,(MlyValue.BAR_fmatch_opt BAR_fmatch_opt1,_,
BAR_fmatch_optright as BAR_fmatch_opt1right))::(_,(MlyValue.fmrule 
fmrule1,fmruleleft as fmrule1left,_))::rest671) => let val result=
MlyValue.fmatch(fn _ => let val fmrule as fmrule1=fmrule1 ()
val BAR_fmatch_opt as BAR_fmatch_opt1=BAR_fmatch_opt1 ()
 in (
 Fmatch(I(fmruleleft,BAR_fmatch_optright),
				 fmrule, BAR_fmatch_opt) 
) end
)
 in (LrTable.NT 43,(result,fmrule1left,BAR_fmatch_opt1right),rest671)
 end
| (134,(_,(MlyValue.fmatch fmatch1,_,fmatch1right))::(_,(_,BAR1left,_)
)::rest671) => let val result=MlyValue.BAR_fmatch_opt(fn _ => let val 
fmatch as fmatch1=fmatch1 ()
 in ( SOME fmatch ) end
)
 in (LrTable.NT 44,(result,BAR1left,fmatch1right),rest671) end
| (135,rest671) => let val result=MlyValue.BAR_fmatch_opt(fn _ => (
 NONE ))
 in (LrTable.NT 44,(result,defaultPos,defaultPos),rest671) end
| (136,(_,(MlyValue.exp exp1,_,expright as exp1right))::_::(_,(
MlyValue.fpat fpat1,fpatleft as fpat1left,_))::rest671) => let val 
result=MlyValue.fmrule(fn _ => let val fpat as fpat1=fpat1 ()
val exp as exp1=exp1 ()
 in ( Fmrule(I(fpatleft,expright), fpat, exp) ) end
)
 in (LrTable.NT 45,(result,fpat1left,exp1right),rest671) end
| (137,(_,(MlyValue.pat pat1,pat1left,pat1right))::rest671) => let 
val result=MlyValue.fpat(fn _ => let val pat as pat1=pat1 ()
 in ( pat ) end
)
 in (LrTable.NT 46,(result,pat1left,pat1right),rest671) end
| (138,(_,(MlyValue.AND_typbind_opt AND_typbind_opt1,_,
AND_typbind_optright as AND_typbind_opt1right))::(_,(MlyValue.tycon 
tycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1,tyvarseqleft as 
tyvarseq1left,_))::rest671) => let val result=MlyValue.typbind(fn _
 => let val tyvarseq as tyvarseq1=tyvarseq1 ()
val tycon as tycon1=tycon1 ()
val AND_typbind_opt as AND_typbind_opt1=AND_typbind_opt1 ()
 in (
 NEWTypBind(I(tyvarseqleft,AND_typbind_optright),
				     tyvarseq, tycon, AND_typbind_opt) 
) end
)
 in (LrTable.NT 47,(result,tyvarseq1left,AND_typbind_opt1right),
rest671) end
| (139,(_,(MlyValue.AND_typbind_opt AND_typbind_opt1,_,
AND_typbind_optright as AND_typbind_opt1right))::(_,(MlyValue.ty ty1,_
,_))::_::(_,(MlyValue.tycon tycon1,_,_))::(_,(MlyValue.tyvarseq 
tyvarseq1,tyvarseqleft as tyvarseq1left,_))::rest671) => let val 
result=MlyValue.typbind(fn _ => let val tyvarseq as tyvarseq1=
tyvarseq1 ()
val tycon as tycon1=tycon1 ()
val ty as ty1=ty1 ()
val AND_typbind_opt as AND_typbind_opt1=AND_typbind_opt1 ()
 in (
 EQUALTypBind(I(tyvarseqleft,AND_typbind_optright),
				  tyvarseq, tycon, ty, AND_typbind_opt) 
) end
)
 in (LrTable.NT 47,(result,tyvarseq1left,AND_typbind_opt1right),
rest671) end
| (140,(_,(MlyValue.typbind typbind1,_,typbind1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_typbind_opt(fn _ => let 
val typbind as typbind1=typbind1 ()
 in ( SOME typbind ) end
)
 in (LrTable.NT 48,(result,AND1left,typbind1right),rest671) end
| (141,rest671) => let val result=MlyValue.AND_typbind_opt(fn _ => (
 NONE ))
 in (LrTable.NT 48,(result,defaultPos,defaultPos),rest671) end
| (142,(_,(MlyValue.AND_datbind_opt AND_datbind_opt1,_,
AND_datbind_optright as AND_datbind_opt1right))::(_,(MlyValue.tycon 
tycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1,tyvarseqleft as 
tyvarseq1left,_))::rest671) => let val result=MlyValue.datbind(fn _
 => let val tyvarseq as tyvarseq1=tyvarseq1 ()
val tycon as tycon1=tycon1 ()
val AND_datbind_opt as AND_datbind_opt1=AND_datbind_opt1 ()
 in (
 OPENDatBind(I(tyvarseqleft,AND_datbind_optright),
				      tyvarseq, tycon, AND_datbind_opt) 
) end
)
 in (LrTable.NT 49,(result,tyvarseq1left,AND_datbind_opt1right),
rest671) end
| (143,(_,(MlyValue.AND_datbind_opt AND_datbind_opt1,_,
AND_datbind_optright as AND_datbind_opt1right))::(_,(MlyValue.conbind 
conbind1,_,_))::_::(_,(MlyValue.tycon tycon1,_,_))::(_,(
MlyValue.tyvarseq tyvarseq1,tyvarseqleft as tyvarseq1left,_))::rest671
) => let val result=MlyValue.datbind(fn _ => let val tyvarseq as 
tyvarseq1=tyvarseq1 ()
val tycon as tycon1=tycon1 ()
val conbind as conbind1=conbind1 ()
val AND_datbind_opt as AND_datbind_opt1=AND_datbind_opt1 ()
 in (
 CLOSEDDatBind(I(tyvarseqleft,AND_datbind_optright),
					tyvarseq, tycon, conbind,
					AND_datbind_opt)
) end
)
 in (LrTable.NT 49,(result,tyvarseq1left,AND_datbind_opt1right),
rest671) end
| (144,(_,(MlyValue.AND_datbind_opt AND_datbind_opt1,_,
AND_datbind_optright as AND_datbind_opt1right))::(_,(MlyValue.tycon 
tycon1,tyconleft as tycon1left,_))::rest671) => let val result=
MlyValue.datbind0(fn _ => let val tycon as tycon1=tycon1 ()
val AND_datbind_opt as AND_datbind_opt1=AND_datbind_opt1 ()
 in (
 OPENDatBind(I(tyconleft,AND_datbind_optright),
				      Seq(I(defaultPos,defaultPos), []),
				      tycon, AND_datbind_opt) 
) end
)
 in (LrTable.NT 50,(result,tycon1left,AND_datbind_opt1right),rest671)
 end
| (145,(_,(MlyValue.AND_datbind_opt AND_datbind_opt1,_,
AND_datbind_optright as AND_datbind_opt1right))::(_,(MlyValue.conbind 
conbind1,_,_))::_::(_,(MlyValue.tycon tycon1,tyconleft as tycon1left,_
))::rest671) => let val result=MlyValue.datbind0(fn _ => let val tycon
 as tycon1=tycon1 ()
val conbind as conbind1=conbind1 ()
val AND_datbind_opt as AND_datbind_opt1=AND_datbind_opt1 ()
 in (
 CLOSEDDatBind(I(tyconleft,AND_datbind_optright),
					Seq(I(defaultPos,defaultPos), []),
					tycon, conbind, AND_datbind_opt) 
) end
)
 in (LrTable.NT 50,(result,tycon1left,AND_datbind_opt1right),rest671)
 end
| (146,(_,(MlyValue.AND_datbind_opt AND_datbind_opt1,_,
AND_datbind_optright as AND_datbind_opt1right))::(_,(MlyValue.tycon 
tycon1,_,_))::(_,(MlyValue.tyvarseq1 tyvarseq11,tyvarseq1left as 
tyvarseq11left,_))::rest671) => let val result=MlyValue.datbind1(fn _
 => let val tyvarseq1 as tyvarseq11=tyvarseq11 ()
val tycon as tycon1=tycon1 ()
val AND_datbind_opt as AND_datbind_opt1=AND_datbind_opt1 ()
 in (
 OPENDatBind(I(tyvarseq1left,AND_datbind_optright),
				      tyvarseq1, tycon, AND_datbind_opt) 
) end
)
 in (LrTable.NT 51,(result,tyvarseq11left,AND_datbind_opt1right),
rest671) end
| (147,(_,(MlyValue.AND_datbind_opt AND_datbind_opt1,_,
AND_datbind_optright as AND_datbind_opt1right))::(_,(MlyValue.conbind 
conbind1,_,_))::_::(_,(MlyValue.tycon tycon1,_,_))::(_,(
MlyValue.tyvarseq1 tyvarseq11,tyvarseq1left as tyvarseq11left,_))::
rest671) => let val result=MlyValue.datbind1(fn _ => let val tyvarseq1
 as tyvarseq11=tyvarseq11 ()
val tycon as tycon1=tycon1 ()
val conbind as conbind1=conbind1 ()
val AND_datbind_opt as AND_datbind_opt1=AND_datbind_opt1 ()
 in (
 CLOSEDDatBind(I(tyvarseq1left,AND_datbind_optright),
					tyvarseq1, tycon, conbind,
					AND_datbind_opt) 
) end
)
 in (LrTable.NT 51,(result,tyvarseq11left,AND_datbind_opt1right),
rest671) end
| (148,(_,(MlyValue.datbind datbind1,_,datbind1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_datbind_opt(fn _ => let 
val datbind as datbind1=datbind1 ()
 in ( SOME datbind ) end
)
 in (LrTable.NT 52,(result,AND1left,datbind1right),rest671) end
| (149,rest671) => let val result=MlyValue.AND_datbind_opt(fn _ => (
 NONE ))
 in (LrTable.NT 52,(result,defaultPos,defaultPos),rest671) end
| (150,(_,(MlyValue.BAR_conbind_opt BAR_conbind_opt1,_,
BAR_conbind_optright as BAR_conbind_opt1right))::(_,(
MlyValue.OF_ty_opt OF_ty_opt1,_,_))::(_,(MlyValue.vid vid1,_,_))::(_,(
MlyValue.OP_opt OP_opt1,OP_optleft as OP_opt1left,_))::rest671) => 
let val result=MlyValue.conbind(fn _ => let val OP_opt as OP_opt1=
OP_opt1 ()
val vid as vid1=vid1 ()
val OF_ty_opt as OF_ty_opt1=OF_ty_opt1 ()
val BAR_conbind_opt as BAR_conbind_opt1=BAR_conbind_opt1 ()
 in (
 ConBind(I(OP_optleft,BAR_conbind_optright),
				  OP_opt, vid, OF_ty_opt, BAR_conbind_opt) 
) end
)
 in (LrTable.NT 53,(result,OP_opt1left,BAR_conbind_opt1right),rest671)
 end
| (151,(_,(MlyValue.conbind conbind1,_,conbind1right))::(_,(_,BAR1left
,_))::rest671) => let val result=MlyValue.BAR_conbind_opt(fn _ => let 
val conbind as conbind1=conbind1 ()
 in ( SOME conbind ) end
)
 in (LrTable.NT 54,(result,BAR1left,conbind1right),rest671) end
| (152,rest671) => let val result=MlyValue.BAR_conbind_opt(fn _ => (
 NONE ))
 in (LrTable.NT 54,(result,defaultPos,defaultPos),rest671) end
| (153,(_,(MlyValue.ty ty1,_,ty1right))::(_,(_,OF1left,_))::rest671)
 => let val result=MlyValue.OF_ty_opt(fn _ => let val ty as ty1=ty1 ()
 in ( SOME ty ) end
)
 in (LrTable.NT 55,(result,OF1left,ty1right),rest671) end
| (154,rest671) => let val result=MlyValue.OF_ty_opt(fn _ => ( NONE ))
 in (LrTable.NT 55,(result,defaultPos,defaultPos),rest671) end
| (155,(_,(MlyValue.AND_dconbind_opt AND_dconbind_opt1,_,
AND_dconbind_optright as AND_dconbind_opt1right))::(_,(
MlyValue.longtycon longtycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1,_
,_))::_::(_,(MlyValue.OF_ty_opt OF_ty_opt1,_,_))::(_,(MlyValue.vid 
vid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,OP_optleft as OP_opt1left,_))
::rest671) => let val result=MlyValue.dconbind(fn _ => let val OP_opt
 as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val OF_ty_opt as OF_ty_opt1=OF_ty_opt1 ()
val tyvarseq as tyvarseq1=tyvarseq1 ()
val longtycon as longtycon1=longtycon1 ()
val AND_dconbind_opt as AND_dconbind_opt1=AND_dconbind_opt1 ()
 in (
 NEWDconBind(I(OP_optleft,AND_dconbind_optright),
				      OP_opt, vid, OF_ty_opt, tyvarseq,
				      longtycon, AND_dconbind_opt) 
) end
)
 in (LrTable.NT 56,(result,OP_opt1left,AND_dconbind_opt1right),rest671
) end
| (156,(_,(MlyValue.AND_dconbind_opt AND_dconbind_opt1,_,
AND_dconbind_optright as AND_dconbind_opt1right))::(_,(
MlyValue.longvid longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_
::(_,(MlyValue.vid vid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,OP_opt1left
,_))::rest671) => let val result=MlyValue.dconbind(fn _ => let val 
OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val OP_opt2=OP_opt2 ()
val longvid as longvid1=longvid1 ()
val AND_dconbind_opt as AND_dconbind_opt1=AND_dconbind_opt1 ()
 in (
 EQUALDconBind(I(OP_opt1left,AND_dconbind_optright),
					OP_opt1, vid,
					OP_opt2, longvid, AND_dconbind_opt) 
) end
)
 in (LrTable.NT 56,(result,OP_opt1left,AND_dconbind_opt1right),rest671
) end
| (157,(_,(MlyValue.dconbind dconbind1,_,dconbind1right))::(_,(_,
AND1left,_))::rest671) => let val result=MlyValue.AND_dconbind_opt(fn 
_ => let val dconbind as dconbind1=dconbind1 ()
 in ( SOME dconbind ) end
)
 in (LrTable.NT 57,(result,AND1left,dconbind1right),rest671) end
| (158,rest671) => let val result=MlyValue.AND_dconbind_opt(fn _ => (
 NONE ))
 in (LrTable.NT 57,(result,defaultPos,defaultPos),rest671) end
| (159,(_,(MlyValue.AND_exbind_opt AND_exbind_opt1,_,
AND_exbind_optright as AND_exbind_opt1right))::(_,(MlyValue.OF_ty_opt 
OF_ty_opt1,_,_))::(_,(MlyValue.vid vid1,_,_))::(_,(MlyValue.OP_opt 
OP_opt1,OP_optleft as OP_opt1left,_))::rest671) => let val result=
MlyValue.exbind(fn _ => let val OP_opt as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val OF_ty_opt as OF_ty_opt1=OF_ty_opt1 ()
val AND_exbind_opt as AND_exbind_opt1=AND_exbind_opt1 ()
 in (
 NEWExBind(I(OP_optleft,AND_exbind_optright),
				    OP_opt, vid, OF_ty_opt, AND_exbind_opt) 
) end
)
 in (LrTable.NT 58,(result,OP_opt1left,AND_exbind_opt1right),rest671)
 end
| (160,(_,(MlyValue.AND_exbind_opt AND_exbind_opt1,_,
AND_exbind_optright as AND_exbind_opt1right))::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.vid
 vid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,OP_opt1left,_))::rest671) => 
let val result=MlyValue.exbind(fn _ => let val OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val OP_opt2=OP_opt2 ()
val longvid as longvid1=longvid1 ()
val AND_exbind_opt as AND_exbind_opt1=AND_exbind_opt1 ()
 in (
 EQUALExBind(I(OP_opt1left,AND_exbind_optright),
				      OP_opt1, vid,
				      OP_opt2, longvid, AND_exbind_opt) 
) end
)
 in (LrTable.NT 58,(result,OP_opt1left,AND_exbind_opt1right),rest671)
 end
| (161,(_,(MlyValue.exbind exbind1,_,exbind1right))::(_,(_,AND1left,_)
)::rest671) => let val result=MlyValue.AND_exbind_opt(fn _ => let val 
exbind as exbind1=exbind1 ()
 in ( SOME exbind ) end
)
 in (LrTable.NT 59,(result,AND1left,exbind1right),rest671) end
| (162,rest671) => let val result=MlyValue.AND_exbind_opt(fn _ => (
 NONE ))
 in (LrTable.NT 59,(result,defaultPos,defaultPos),rest671) end
| (163,(_,(_,UNDERBARleft as UNDERBAR1left,UNDERBARright as 
UNDERBAR1right))::rest671) => let val result=MlyValue.atpat(fn _ => (
 WILDCARDAtPat(I(UNDERBARleft,UNDERBARright)) ))
 in (LrTable.NT 60,(result,UNDERBAR1left,UNDERBAR1right),rest671) end
| (164,(_,(MlyValue.longvid' longvid'1,longvid'left as longvid'1left,
longvid'right as longvid'1right))::rest671) => let val result=
MlyValue.atpat(fn _ => let val longvid' as longvid'1=longvid'1 ()
 in (
 LONGVIDAtPat(I(longvid'left,longvid'right),
				       SANSOp, longvid') 
) end
)
 in (LrTable.NT 60,(result,longvid'1left,longvid'1right),rest671) end
| (165,(_,(MlyValue.longvid longvid1,_,longvidright as longvid1right))
::(_,(_,OPleft as OP1left,_))::rest671) => let val result=
MlyValue.atpat(fn _ => let val longvid as longvid1=longvid1 ()
 in (
 LONGVIDAtPat(I(OPleft,longvidright),
				       WITHOp, longvid) )
 end
)
 in (LrTable.NT 60,(result,OP1left,longvid1right),rest671) end
| (166,(_,(MlyValue.scon scon1,sconleft as scon1left,sconright as 
scon1right))::rest671) => let val result=MlyValue.atpat(fn _ => let 
val scon as scon1=scon1 ()
 in ( SCONAtPat(I(sconleft,sconright), scon) ) end
)
 in (LrTable.NT 60,(result,scon1left,scon1right),rest671) end
| (167,(_,(_,_,RBRACEright as RBRACE1right))::(_,(MlyValue.patrow_opt 
patrow_opt1,_,_))::(_,(_,LBRACEleft as LBRACE1left,_))::rest671) => 
let val result=MlyValue.atpat(fn _ => let val patrow_opt as 
patrow_opt1=patrow_opt1 ()
 in ( RECORDAtPat(I(LBRACEleft,RBRACEright), patrow_opt) ) end
)
 in (LrTable.NT 60,(result,LBRACE1left,RBRACE1right),rest671) end
| (168,(_,(_,_,RPARright as RPAR1right))::(_,(_,LPARleft as LPAR1left,
_))::rest671) => let val result=MlyValue.atpat(fn _ => (
 UNITAtPat(I(LPARleft,RPARright)) ))
 in (LrTable.NT 60,(result,LPAR1left,RPAR1right),rest671) end
| (169,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.pat_COMMA_list2
 pat_COMMA_list21,_,_))::(_,(_,LPARleft as LPAR1left,_))::rest671) => 
let val result=MlyValue.atpat(fn _ => let val pat_COMMA_list2 as 
pat_COMMA_list21=pat_COMMA_list21 ()
 in ( TUPLEAtPat(I(LPARleft,RPARright), pat_COMMA_list2) ) end
)
 in (LrTable.NT 60,(result,LPAR1left,RPAR1right),rest671) end
| (170,(_,(_,_,RBRACKright as RBRACK1right))::(_,(
MlyValue.pat_COMMA_list0 pat_COMMA_list01,_,_))::(_,(_,LBRACKleft as 
LBRACK1left,_))::rest671) => let val result=MlyValue.atpat(fn _ => 
let val pat_COMMA_list0 as pat_COMMA_list01=pat_COMMA_list01 ()
 in ( LISTAtPat(I(LBRACKleft,RBRACKright),
				    pat_COMMA_list0) )
 end
)
 in (LrTable.NT 60,(result,LBRACK1left,RBRACK1right),rest671) end
| (171,(_,(_,_,RBRACKright as RBRACK1right))::(_,(
MlyValue.pat_COMMA_list0 pat_COMMA_list01,_,_))::(_,(_,HASHBRACKleft
 as HASHBRACK1left,_))::rest671) => let val result=MlyValue.atpat(fn _
 => let val pat_COMMA_list0 as pat_COMMA_list01=pat_COMMA_list01 ()
 in (
 VECTORAtPat(I(HASHBRACKleft,RBRACKright),
				    pat_COMMA_list0) )
 end
)
 in (LrTable.NT 60,(result,HASHBRACK1left,RBRACK1right),rest671) end
| (172,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.pat_BAR_list2 
pat_BAR_list21,_,_))::(_,(_,LPARleft as LPAR1left,_))::rest671) => 
let val result=MlyValue.atpat(fn _ => let val pat_BAR_list2 as 
pat_BAR_list21=pat_BAR_list21 ()
 in ( ALTAtPat(I(LPARleft,RPARright),
				   pat_BAR_list2) ) end
)
 in (LrTable.NT 60,(result,LPAR1left,RPAR1right),rest671) end
| (173,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.pat pat1,_,_))
::(_,(_,LPARleft as LPAR1left,_))::rest671) => let val result=
MlyValue.atpat(fn _ => let val pat as pat1=pat1 ()
 in ( PARAtPat(I(LPARleft,RPARright), pat) ) end
)
 in (LrTable.NT 60,(result,LPAR1left,RPAR1right),rest671) end
| (174,(_,(MlyValue.pat_COMMA_list1 pat_COMMA_list11,
pat_COMMA_list11left,pat_COMMA_list11right))::rest671) => let val 
result=MlyValue.pat_COMMA_list0(fn _ => let val pat_COMMA_list1 as 
pat_COMMA_list11=pat_COMMA_list11 ()
 in ( pat_COMMA_list1 ) end
)
 in (LrTable.NT 61,(result,pat_COMMA_list11left,pat_COMMA_list11right)
,rest671) end
| (175,rest671) => let val result=MlyValue.pat_COMMA_list0(fn _ => (
 [] ))
 in (LrTable.NT 61,(result,defaultPos,defaultPos),rest671) end
| (176,(_,(MlyValue.pat_COMMA_list1 pat_COMMA_list11,_,
pat_COMMA_list11right))::_::(_,(MlyValue.pat pat1,pat1left,_))::
rest671) => let val result=MlyValue.pat_COMMA_list1(fn _ => let val 
pat as pat1=pat1 ()
val pat_COMMA_list1 as pat_COMMA_list11=pat_COMMA_list11 ()
 in ( pat::pat_COMMA_list1 ) end
)
 in (LrTable.NT 62,(result,pat1left,pat_COMMA_list11right),rest671)
 end
| (177,(_,(MlyValue.pat pat1,pat1left,pat1right))::rest671) => let 
val result=MlyValue.pat_COMMA_list1(fn _ => let val pat as pat1=pat1 
()
 in ( pat::[] ) end
)
 in (LrTable.NT 62,(result,pat1left,pat1right),rest671) end
| (178,(_,(MlyValue.pat_COMMA_list1 pat_COMMA_list11,_,
pat_COMMA_list11right))::_::(_,(MlyValue.pat pat1,pat1left,_))::
rest671) => let val result=MlyValue.pat_COMMA_list2(fn _ => let val 
pat as pat1=pat1 ()
val pat_COMMA_list1 as pat_COMMA_list11=pat_COMMA_list11 ()
 in ( pat::pat_COMMA_list1 ) end
)
 in (LrTable.NT 63,(result,pat1left,pat_COMMA_list11right),rest671)
 end
| (179,(_,(MlyValue.pat pat2,_,pat2right))::_::(_,(MlyValue.pat pat1,
pat1left,_))::rest671) => let val result=MlyValue.pat_BAR_list2(fn _
 => let val pat1=pat1 ()
val pat2=pat2 ()
 in ( [pat1,pat2] ) end
)
 in (LrTable.NT 64,(result,pat1left,pat2right),rest671) end
| (180,(_,(MlyValue.pat_BAR_list2 pat_BAR_list21,_,pat_BAR_list21right
))::_::(_,(MlyValue.pat pat1,pat1left,_))::rest671) => let val result=
MlyValue.pat_BAR_list2(fn _ => let val pat as pat1=pat1 ()
val pat_BAR_list2 as pat_BAR_list21=pat_BAR_list21 ()
 in ( pat::pat_BAR_list2 ) end
)
 in (LrTable.NT 64,(result,pat1left,pat_BAR_list21right),rest671) end
| (181,(_,(_,DOTSleft as DOTS1left,DOTSright as DOTS1right))::rest671)
 => let val result=MlyValue.patrow(fn _ => (
 WILDCARDPatRow(I(DOTSleft,DOTSright)) ))
 in (LrTable.NT 65,(result,DOTS1left,DOTS1right),rest671) end
| (182,(_,(MlyValue.COMMA_patrow_opt COMMA_patrow_opt1,_,
COMMA_patrow_optright as COMMA_patrow_opt1right))::(_,(MlyValue.pat 
pat1,_,_))::_::(_,(MlyValue.lab lab1,lableft as lab1left,_))::rest671)
 => let val result=MlyValue.patrow(fn _ => let val lab as lab1=lab1 ()
val pat as pat1=pat1 ()
val COMMA_patrow_opt as COMMA_patrow_opt1=COMMA_patrow_opt1 ()
 in (
 ROWPatRow(I(lableft,COMMA_patrow_optright),
				      lab, pat, COMMA_patrow_opt) 
) end
)
 in (LrTable.NT 65,(result,lab1left,COMMA_patrow_opt1right),rest671)
 end
| (183,(_,(MlyValue.COMMA_patrow_opt COMMA_patrow_opt1,_,
COMMA_patrow_optright as COMMA_patrow_opt1right))::(_,(
MlyValue.AS_pat_opt AS_pat_opt1,_,_))::(_,(MlyValue.COLON_ty_opt 
COLON_ty_opt1,_,_))::(_,(MlyValue.vid' vid'1,vid'left as vid'1left,_))
::rest671) => let val result=MlyValue.patrow(fn _ => let val vid' as 
vid'1=vid'1 ()
val COLON_ty_opt as COLON_ty_opt1=COLON_ty_opt1 ()
val AS_pat_opt as AS_pat_opt1=AS_pat_opt1 ()
val COMMA_patrow_opt as COMMA_patrow_opt1=COMMA_patrow_opt1 ()
 in (
 VIDPatRow(I(vid'left,COMMA_patrow_optright),
				    vid', COLON_ty_opt, AS_pat_opt,
				    COMMA_patrow_opt) 
) end
)
 in (LrTable.NT 65,(result,vid'1left,COMMA_patrow_opt1right),rest671)
 end
| (184,(_,(MlyValue.patrow patrow1,_,patrow1right))::(_,(_,COMMA1left,
_))::rest671) => let val result=MlyValue.COMMA_patrow_opt(fn _ => let 
val patrow as patrow1=patrow1 ()
 in ( SOME patrow ) end
)
 in (LrTable.NT 67,(result,COMMA1left,patrow1right),rest671) end
| (185,rest671) => let val result=MlyValue.COMMA_patrow_opt(fn _ => (
 NONE ))
 in (LrTable.NT 67,(result,defaultPos,defaultPos),rest671) end
| (186,(_,(MlyValue.ty ty1,_,ty1right))::(_,(_,COLON1left,_))::rest671
) => let val result=MlyValue.COLON_ty_opt(fn _ => let val ty as ty1=
ty1 ()
 in ( SOME ty ) end
)
 in (LrTable.NT 68,(result,COLON1left,ty1right),rest671) end
| (187,rest671) => let val result=MlyValue.COLON_ty_opt(fn _ => (
 NONE ))
 in (LrTable.NT 68,(result,defaultPos,defaultPos),rest671) end
| (188,(_,(MlyValue.pat pat1,_,pat1right))::(_,(_,AS1left,_))::rest671
) => let val result=MlyValue.AS_pat_opt(fn _ => let val pat as pat1=
pat1 ()
 in ( SOME pat ) end
)
 in (LrTable.NT 69,(result,AS1left,pat1right),rest671) end
| (189,rest671) => let val result=MlyValue.AS_pat_opt(fn _ => ( NONE )
)
 in (LrTable.NT 69,(result,defaultPos,defaultPos),rest671) end
| (190,(_,(MlyValue.patrow patrow1,patrow1left,patrow1right))::rest671
) => let val result=MlyValue.patrow_opt(fn _ => let val patrow as 
patrow1=patrow1 ()
 in ( SOME patrow ) end
)
 in (LrTable.NT 66,(result,patrow1left,patrow1right),rest671) end
| (191,rest671) => let val result=MlyValue.patrow_opt(fn _ => ( NONE )
)
 in (LrTable.NT 66,(result,defaultPos,defaultPos),rest671) end
| (192,(_,(MlyValue.atpat atpat1,atpatleft as atpat1left,atpatright
 as atpat1right))::rest671) => let val result=MlyValue.infpat(fn _ => 
let val atpat as atpat1=atpat1 ()
 in ( ATPATPat(I(atpatleft,atpatright), atpat) ) end
)
 in (LrTable.NT 70,(result,atpat1left,atpat1right),rest671) end
| (193,(_,(MlyValue.atpat atpat1,_,atpatright as atpat1right))::(_,(
MlyValue.infpat infpat1,infpatleft as infpat1left,_))::rest671) => 
let val result=MlyValue.infpat(fn _ => let val infpat as infpat1=
infpat1 ()
val atpat as atpat1=atpat1 ()
 in ( APPPat(I(infpatleft,atpatright), infpat, atpat) ) end
)
 in (LrTable.NT 70,(result,infpat1left,atpat1right),rest671) end
| (194,(_,(MlyValue.infpat infpat1,infpat1left,infpat1right))::rest671
) => let val result=MlyValue.pat(fn _ => let val infpat as infpat1=
infpat1 ()
 in ( infpat ) end
)
 in (LrTable.NT 71,(result,infpat1left,infpat1right),rest671) end
| (195,(_,(MlyValue.ty ty1,_,tyright as ty1right))::_::(_,(
MlyValue.pat pat1,patleft as pat1left,_))::rest671) => let val result=
MlyValue.pat(fn _ => let val pat as pat1=pat1 ()
val ty as ty1=ty1 ()
 in ( TYPEDPat(I(patleft,tyright), pat, ty) ) end
)
 in (LrTable.NT 71,(result,pat1left,ty1right),rest671) end
| (196,(_,(MlyValue.pat pat1,_,patright as pat1right))::(_,(_,NONleft
 as NON1left,_))::rest671) => let val result=MlyValue.pat(fn _ => let 
val pat as pat1=pat1 ()
 in ( NONPat(I(NONleft,patright), pat) ) end
)
 in (LrTable.NT 71,(result,NON1left,pat1right),rest671) end
| (197,(_,(MlyValue.pat pat2,_,pat2right))::_::(_,(MlyValue.pat pat1,
pat1left,_))::rest671) => let val result=MlyValue.pat(fn _ => let val 
pat1=pat1 ()
val pat2=pat2 ()
 in ( ASPat(I(pat1left,pat2right), pat1, pat2) ) end
)
 in (LrTable.NT 71,(result,pat1left,pat2right),rest671) end
| (198,(_,(MlyValue.atexp atexp1,_,atexpright as atexp1right))::_::(_,
(MlyValue.pat pat1,patleft as pat1left,_))::rest671) => let val result
=MlyValue.pat(fn _ => let val pat as pat1=pat1 ()
val atexp as atexp1=atexp1 ()
 in ( WHENPat(I(patleft,atexpright), pat, atexp) ) end
)
 in (LrTable.NT 71,(result,pat1left,atexp1right),rest671) end
| (199,(_,(_,_,ENDright as END1right))::(_,(MlyValue.valbind valbind1,
_,_))::_::(_,(MlyValue.pat pat1,patleft as pat1left,_))::rest671) => 
let val result=MlyValue.pat(fn _ => let val pat as pat1=pat1 ()
val valbind as valbind1=valbind1 ()
 in ( WITHVALPat(I(patleft,ENDright), pat, valbind) ) end
)
 in (LrTable.NT 71,(result,pat1left,END1right),rest671) end
| (200,(_,(_,_,ENDright as END1right))::(_,(MlyValue.fvalbind 
fvalbind1,_,_))::_::(_,(MlyValue.pat pat1,patleft as pat1left,_))::
rest671) => let val result=MlyValue.pat(fn _ => let val pat as pat1=
pat1 ()
val fvalbind as fvalbind1=fvalbind1 ()
 in ( WITHFUNPat(I(patleft,ENDright), pat, fvalbind) ) end
)
 in (LrTable.NT 71,(result,pat1left,END1right),rest671) end
| (201,(_,(MlyValue.tupty tupty1,tupty1left,tupty1right))::rest671)
 => let val result=MlyValue.ty(fn _ => let val tupty as tupty1=tupty1 
()
 in ( tupty ) end
)
 in (LrTable.NT 72,(result,tupty1left,tupty1right),rest671) end
| (202,(_,(MlyValue.ty ty1,_,tyright as ty1right))::_::(_,(
MlyValue.tupty tupty1,tuptyleft as tupty1left,_))::rest671) => let 
val result=MlyValue.ty(fn _ => let val tupty as tupty1=tupty1 ()
val ty as ty1=ty1 ()
 in ( ARROWTy(I(tuptyleft,tyright), tupty, ty) ) end
)
 in (LrTable.NT 72,(result,tupty1left,ty1right),rest671) end
| (203,(_,(MlyValue.ty_STAR_list ty_STAR_list1,ty_STAR_listleft as 
ty_STAR_list1left,ty_STAR_listright as ty_STAR_list1right))::rest671)
 => let val result=MlyValue.tupty(fn _ => let val ty_STAR_list as 
ty_STAR_list1=ty_STAR_list1 ()
 in (
 TUPLETy(I(ty_STAR_listleft,ty_STAR_listright),
				   ty_STAR_list) )
 end
)
 in (LrTable.NT 73,(result,ty_STAR_list1left,ty_STAR_list1right),
rest671) end
| (204,(_,(MlyValue.ty_STAR_list ty_STAR_list1,_,ty_STAR_list1right))
::_::(_,(MlyValue.consty consty1,consty1left,_))::rest671) => let val 
result=MlyValue.ty_STAR_list(fn _ => let val consty as consty1=consty1
 ()
val ty_STAR_list as ty_STAR_list1=ty_STAR_list1 ()
 in ( consty::ty_STAR_list ) end
)
 in (LrTable.NT 74,(result,consty1left,ty_STAR_list1right),rest671)
 end
| (205,(_,(MlyValue.consty consty1,consty1left,consty1right))::rest671
) => let val result=MlyValue.ty_STAR_list(fn _ => let val consty as 
consty1=consty1 ()
 in ( consty::[] ) end
)
 in (LrTable.NT 74,(result,consty1left,consty1right),rest671) end
| (206,(_,(MlyValue.atty atty1,atty1left,atty1right))::rest671) => 
let val result=MlyValue.consty(fn _ => let val atty as atty1=atty1 ()
 in ( atty ) end
)
 in (LrTable.NT 75,(result,atty1left,atty1right),rest671) end
| (207,(_,(MlyValue.longtycon longtycon1,_,longtyconright as 
longtycon1right))::(_,(MlyValue.tyseq tyseq1,tyseqleft as tyseq1left,_
))::rest671) => let val result=MlyValue.consty(fn _ => let val tyseq
 as tyseq1=tyseq1 ()
val longtycon as longtycon1=longtycon1 ()
 in ( TYCONTy(I(tyseqleft,longtyconright),
					  tyseq, longtycon) )
 end
)
 in (LrTable.NT 75,(result,tyseq1left,longtycon1right),rest671) end
| (208,(_,(MlyValue.tyvar tyvar1,tyvarleft as tyvar1left,tyvarright
 as tyvar1right))::rest671) => let val result=MlyValue.atty(fn _ => 
let val tyvar as tyvar1=tyvar1 ()
 in ( TYVARTy(I(tyvarleft,tyvarright), tyvar) ) end
)
 in (LrTable.NT 76,(result,tyvar1left,tyvar1right),rest671) end
| (209,(_,(_,_,RBRACEright as RBRACE1right))::(_,(MlyValue.tyrow_opt 
tyrow_opt1,_,_))::(_,(_,LBRACEleft as LBRACE1left,_))::rest671) => 
let val result=MlyValue.atty(fn _ => let val tyrow_opt as tyrow_opt1=
tyrow_opt1 ()
 in ( RECORDTy(I(LBRACEleft,RBRACEright), tyrow_opt) ) end
)
 in (LrTable.NT 76,(result,LBRACE1left,RBRACE1right),rest671) end
| (210,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.ty ty1,_,_))::(
_,(_,LPARleft as LPAR1left,_))::rest671) => let val result=
MlyValue.atty(fn _ => let val ty as ty1=ty1 ()
 in ( PARTy(I(LPARleft,RPARright), ty) ) end
)
 in (LrTable.NT 76,(result,LPAR1left,RPAR1right),rest671) end
| (211,(_,(MlyValue.longsigid longsigid1,_,longsigidright as 
longsigid1right))::(_,(_,PACKleft as PACK1left,_))::rest671) => let 
val result=MlyValue.atty(fn _ => let val longsigid as longsigid1=
longsigid1 ()
 in ( PACKTy(I(PACKleft,longsigidright), longsigid)) end
)
 in (LrTable.NT 76,(result,PACK1left,longsigid1right),rest671) end
| (212,(_,(MlyValue.COMMA_tyrow_opt COMMA_tyrow_opt1,_,
COMMA_tyrow_optright as COMMA_tyrow_opt1right))::(_,(MlyValue.ty ty1,_
,_))::_::(_,(MlyValue.lab lab1,lableft as lab1left,_))::rest671) => 
let val result=MlyValue.tyrow(fn _ => let val lab as lab1=lab1 ()
val ty as ty1=ty1 ()
val COMMA_tyrow_opt as COMMA_tyrow_opt1=COMMA_tyrow_opt1 ()
 in (
 ROWTyRow(I(lableft,COMMA_tyrow_optright),
				   lab, ty, COMMA_tyrow_opt) 
) end
)
 in (LrTable.NT 77,(result,lab1left,COMMA_tyrow_opt1right),rest671)
 end
| (213,(_,(MlyValue.tyrow tyrow1,_,tyrow1right))::(_,(_,COMMA1left,_))
::rest671) => let val result=MlyValue.COMMA_tyrow_opt(fn _ => let val 
tyrow as tyrow1=tyrow1 ()
 in ( SOME tyrow ) end
)
 in (LrTable.NT 79,(result,COMMA1left,tyrow1right),rest671) end
| (214,rest671) => let val result=MlyValue.COMMA_tyrow_opt(fn _ => (
 NONE ))
 in (LrTable.NT 79,(result,defaultPos,defaultPos),rest671) end
| (215,(_,(MlyValue.tyrow tyrow1,tyrow1left,tyrow1right))::rest671)
 => let val result=MlyValue.tyrow_opt(fn _ => let val tyrow as tyrow1=
tyrow1 ()
 in ( SOME tyrow ) end
)
 in (LrTable.NT 78,(result,tyrow1left,tyrow1right),rest671) end
| (216,rest671) => let val result=MlyValue.tyrow_opt(fn _ => ( NONE ))
 in (LrTable.NT 78,(result,defaultPos,defaultPos),rest671) end
| (217,(_,(MlyValue.consty consty1,constyleft as consty1left,
constyright as consty1right))::rest671) => let val result=
MlyValue.tyseq(fn _ => let val consty as consty1=consty1 ()
 in ( Seq(I(constyleft,constyright),
					      [consty]) ) end
)
 in (LrTable.NT 80,(result,consty1left,consty1right),rest671) end
| (218,rest671) => let val result=MlyValue.tyseq(fn _ => (
 Seq(I(defaultPos,defaultPos), []) ))
 in (LrTable.NT 80,(result,defaultPos,defaultPos),rest671) end
| (219,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.ty_COMMA_list2 
ty_COMMA_list21,_,_))::(_,(_,LPARleft as LPAR1left,_))::rest671) => 
let val result=MlyValue.tyseq(fn _ => let val ty_COMMA_list2 as 
ty_COMMA_list21=ty_COMMA_list21 ()
 in ( Seq(I(LPARleft,RPARright),
					      ty_COMMA_list2) ) end
)
 in (LrTable.NT 80,(result,LPAR1left,RPAR1right),rest671) end
| (220,(_,(MlyValue.ty_COMMA_list2 ty_COMMA_list21,_,
ty_COMMA_list21right))::_::(_,(MlyValue.ty ty1,ty1left,_))::rest671)
 => let val result=MlyValue.ty_COMMA_list2(fn _ => let val ty as ty1=
ty1 ()
val ty_COMMA_list2 as ty_COMMA_list21=ty_COMMA_list21 ()
 in ( ty::ty_COMMA_list2 ) end
)
 in (LrTable.NT 81,(result,ty1left,ty_COMMA_list21right),rest671) end
| (221,(_,(MlyValue.ty ty2,_,ty2right))::_::(_,(MlyValue.ty ty1,
ty1left,_))::rest671) => let val result=MlyValue.ty_COMMA_list2(fn _
 => let val ty1=ty1 ()
val ty2=ty2 ()
 in ( [ty1, ty2] ) end
)
 in (LrTable.NT 81,(result,ty1left,ty2right),rest671) end
| (222,(_,(MlyValue.tyvarseq1 tyvarseq11,tyvarseq11left,
tyvarseq11right))::rest671) => let val result=MlyValue.tyvarseq(fn _
 => let val tyvarseq1 as tyvarseq11=tyvarseq11 ()
 in ( tyvarseq1 ) end
)
 in (LrTable.NT 82,(result,tyvarseq11left,tyvarseq11right),rest671)
 end
| (223,rest671) => let val result=MlyValue.tyvarseq(fn _ => (
 Seq(I(defaultPos,defaultPos), []) ))
 in (LrTable.NT 82,(result,defaultPos,defaultPos),rest671) end
| (224,(_,(MlyValue.tyvar tyvar1,tyvarleft as tyvar1left,tyvarright
 as tyvar1right))::rest671) => let val result=MlyValue.tyvarseq1(fn _
 => let val tyvar as tyvar1=tyvar1 ()
 in ( Seq(I(tyvarleft,tyvarright), [tyvar])) end
)
 in (LrTable.NT 83,(result,tyvar1left,tyvar1right),rest671) end
| (225,(_,(_,_,RPARright as RPAR1right))::(_,(
MlyValue.tyvar_COMMA_list1 tyvar_COMMA_list11,_,_))::(_,(_,LPARleft
 as LPAR1left,_))::rest671) => let val result=MlyValue.tyvarseq1(fn _
 => let val tyvar_COMMA_list1 as tyvar_COMMA_list11=tyvar_COMMA_list11
 ()
 in ( Seq(I(LPARleft,RPARright),
					      tyvar_COMMA_list1) ) end
)
 in (LrTable.NT 83,(result,LPAR1left,RPAR1right),rest671) end
| (226,(_,(MlyValue.tyvar_COMMA_list1 tyvar_COMMA_list11,_,
tyvar_COMMA_list11right))::_::(_,(MlyValue.tyvar tyvar1,tyvar1left,_))
::rest671) => let val result=MlyValue.tyvar_COMMA_list1(fn _ => let 
val tyvar as tyvar1=tyvar1 ()
val tyvar_COMMA_list1 as tyvar_COMMA_list11=tyvar_COMMA_list11 ()
 in ( tyvar::tyvar_COMMA_list1 ) end
)
 in (LrTable.NT 84,(result,tyvar1left,tyvar_COMMA_list11right),rest671
) end
| (227,(_,(MlyValue.tyvar tyvar1,tyvar1left,tyvar1right))::rest671)
 => let val result=MlyValue.tyvar_COMMA_list1(fn _ => let val tyvar
 as tyvar1=tyvar1 ()
 in ( tyvar::[] ) end
)
 in (LrTable.NT 84,(result,tyvar1left,tyvar1right),rest671) end
| (228,(_,(_,_,ENDright as END1right))::(_,(MlyValue.dec dec1,_,_))::(
_,(_,STRUCTleft as STRUCT1left,_))::rest671) => let val result=
MlyValue.atstrexp(fn _ => let val dec as dec1=dec1 ()
 in ( STRUCTAtStrExp(I(STRUCTleft,ENDright), dec) ) end
)
 in (LrTable.NT 85,(result,STRUCT1left,END1right),rest671) end
| (229,(_,(MlyValue.longstrid longstrid1,longstridleft as 
longstrid1left,longstridright as longstrid1right))::rest671) => let 
val result=MlyValue.atstrexp(fn _ => let val longstrid as longstrid1=
longstrid1 ()
 in (
 LONGSTRIDAtStrExp(I(longstridleft,longstridright),
					    longstrid) 
) end
)
 in (LrTable.NT 85,(result,longstrid1left,longstrid1right),rest671)
 end
| (230,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.strexp strexp1,
_,_))::(_,(_,LPARleft as LPAR1left,_))::rest671) => let val result=
MlyValue.atstrexp(fn _ => let val strexp as strexp1=strexp1 ()
 in ( PARAtStrExp(I(LPARleft,RPARright), strexp) ) end
)
 in (LrTable.NT 85,(result,LPAR1left,RPAR1right),rest671) end
| (231,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.dec dec1,_,_))
::(_,(_,LPARleft as LPAR1left,_))::rest671) => let val result=
MlyValue.atstrexp(fn _ => let val dec as dec1=dec1 ()
 in ( DECAtStrExp(I(LPARleft,RPARright), dec) ) end
)
 in (LrTable.NT 85,(result,LPAR1left,RPAR1right),rest671) end
| (232,(_,(_,_,ENDright as END1right))::(_,(MlyValue.strexp strexp1,_,
_))::_::(_,(MlyValue.dec dec1,_,_))::(_,(_,LETleft as LET1left,_))::
rest671) => let val result=MlyValue.atstrexp(fn _ => let val dec as 
dec1=dec1 ()
val strexp as strexp1=strexp1 ()
 in ( LETAtStrExp(I(LETleft,ENDright), dec, strexp) ) end
)
 in (LrTable.NT 85,(result,LET1left,END1right),rest671) end
| (233,(_,(MlyValue.atstrexp atstrexp1,atstrexpleft as atstrexp1left,
atstrexpright as atstrexp1right))::rest671) => let val result=
MlyValue.appstrexp(fn _ => let val atstrexp as atstrexp1=atstrexp1 ()
 in ( ATSTREXPStrExp(I(atstrexpleft,atstrexpright),
					 atstrexp) )
 end
)
 in (LrTable.NT 86,(result,atstrexp1left,atstrexp1right),rest671) end
| (234,(_,(MlyValue.atstrexp atstrexp1,_,atstrexpright as 
atstrexp1right))::(_,(MlyValue.appstrexp appstrexp1,appstrexpleft as 
appstrexp1left,_))::rest671) => let val result=MlyValue.appstrexp(fn _
 => let val appstrexp as appstrexp1=appstrexp1 ()
val atstrexp as atstrexp1=atstrexp1 ()
 in (
 APPStrExp(I(appstrexpleft,atstrexpright),
				    appstrexp, atstrexp) 
) end
)
 in (LrTable.NT 86,(result,appstrexp1left,atstrexp1right),rest671) end
| (235,(_,(MlyValue.appstrexp appstrexp1,appstrexp1left,
appstrexp1right))::rest671) => let val result=MlyValue.strexp(fn _ => 
let val appstrexp as appstrexp1=appstrexp1 ()
 in ( appstrexp ) end
)
 in (LrTable.NT 87,(result,appstrexp1left,appstrexp1right),rest671)
 end
| (236,(_,(MlyValue.sigexp sigexp1,_,sigexpright as sigexp1right))::_
::(_,(MlyValue.strexp strexp1,strexpleft as strexp1left,_))::rest671)
 => let val result=MlyValue.strexp(fn _ => let val strexp as strexp1=
strexp1 ()
val sigexp as sigexp1=sigexp1 ()
 in (
 TRANSStrExp(I(strexpleft,sigexpright),
				      strexp, sigexp) )
 end
)
 in (LrTable.NT 87,(result,strexp1left,sigexp1right),rest671) end
| (237,(_,(MlyValue.sigexp sigexp1,_,sigexpright as sigexp1right))::_
::(_,(MlyValue.strexp strexp1,strexpleft as strexp1left,_))::rest671)
 => let val result=MlyValue.strexp(fn _ => let val strexp as strexp1=
strexp1 ()
val sigexp as sigexp1=sigexp1 ()
 in ( OPAQStrExp(I(strexpleft,sigexpright), strexp, sigexp)) end
)
 in (LrTable.NT 87,(result,strexp1left,sigexp1right),rest671) end
| (238,(_,(MlyValue.strexp strexp1,_,strexpright as strexp1right))::_
::(_,(MlyValue.strpat strpat1,_,_))::(_,(_,FCTleft as FCT1left,_))::
rest671) => let val result=MlyValue.strexp(fn _ => let val strpat as 
strpat1=strpat1 ()
val strexp as strexp1=strexp1 ()
 in ( FCTStrExp(I(FCTleft,strexpright), strpat, strexp) ) end
)
 in (LrTable.NT 87,(result,FCT1left,strexp1right),rest671) end
| (239,(_,(MlyValue.sigexp sigexp1,_,sigexpright as sigexp1right))::_
::(_,(MlyValue.infexp infexp1,_,_))::(_,(_,UNPACKleft as UNPACK1left,_
))::rest671) => let val result=MlyValue.strexp(fn _ => let val infexp
 as infexp1=infexp1 ()
val sigexp as sigexp1=sigexp1 ()
 in (
 UNPACKStrExp(I(UNPACKleft,sigexpright),
				       infexp, sigexp) )
 end
)
 in (LrTable.NT 87,(result,UNPACK1left,sigexp1right),rest671) end
| (240,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.sigexp sigexp1,
_,_))::_::(_,(MlyValue.strid strid1,_,_))::(_,(_,LPARleft as LPAR1left
,_))::rest671) => let val result=MlyValue.strpat(fn _ => let val strid
 as strid1=strid1 ()
val sigexp as sigexp1=sigexp1 ()
 in ( StrPat(I(LPARleft,RPARright), strid, sigexp) ) end
)
 in (LrTable.NT 88,(result,LPAR1left,RPAR1right),rest671) end
| (241,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.sigexp sigexp1,
_,_))::_::_::(_,(_,LPARleft as LPAR1left,_))::rest671) => let val 
result=MlyValue.strpat(fn _ => let val sigexp as sigexp1=sigexp1 ()
 in ( WILDCARDStrPat(I(LPARleft,RPARright), sigexp) ) end
)
 in (LrTable.NT 88,(result,LPAR1left,RPAR1right),rest671) end
| (242,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.spec spec1,_,_)
)::(_,(_,LPARleft as LPAR1left,_))::rest671) => let val result=
MlyValue.strpat(fn _ => let val spec as spec1=spec1 ()
 in ( SPECStrPat(I(LPARleft,RPARright), spec) ) end
)
 in (LrTable.NT 88,(result,LPAR1left,RPAR1right),rest671) end
| (243,(_,(MlyValue.strexp__AND_strbind_opt strexp__AND_strbind_opt1,_
,strexp__AND_strbind_optright as strexp__AND_strbind_opt1right))::_::(
_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_,_))::(_,(
MlyValue.strid strid1,stridleft as strid1left,_))::rest671) => let 
val result=MlyValue.strbind(fn _ => let val strid as strid1=strid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val strexp__AND_strbind_opt as strexp__AND_strbind_opt1=
strexp__AND_strbind_opt1 ()
 in (
 TRANSStrBind(I(stridleft,
					 strexp__AND_strbind_optright),
				       strid, COLON_sigexp_opt,
				       #1 strexp__AND_strbind_opt,
				       #2 strexp__AND_strbind_opt) 
) end
)
 in (LrTable.NT 89,(result,strid1left,strexp__AND_strbind_opt1right),
rest671) end
| (244,(_,(MlyValue.strexp__AND_strbind_opt strexp__AND_strbind_opt1,_
,strexp__AND_strbind_optright as strexp__AND_strbind_opt1right))::_::(
_,(MlyValue.sigexp sigexp1,_,_))::_::(_,(MlyValue.strid strid1,
stridleft as strid1left,_))::rest671) => let val result=
MlyValue.strbind(fn _ => let val strid as strid1=strid1 ()
val sigexp as sigexp1=sigexp1 ()
val strexp__AND_strbind_opt as strexp__AND_strbind_opt1=
strexp__AND_strbind_opt1 ()
 in (
 OPAQStrBind(I(stridleft,strexp__AND_strbind_optright),
				      strid, sigexp, #1 strexp__AND_strbind_opt,
				      #2 strexp__AND_strbind_opt) 
) end
)
 in (LrTable.NT 89,(result,strid1left,strexp__AND_strbind_opt1right),
rest671) end
| (245,(_,(MlyValue.strexp__AND_strbind_opt strexp__AND_strbind_opt1,_
,strexp__AND_strbind_optright as strexp__AND_strbind_opt1right))::_::(
_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_,_))::(_,(_,
UNDERBARleft as UNDERBAR1left,_))::rest671) => let val result=
MlyValue.strbind(fn _ => let val COLON_sigexp_opt as COLON_sigexp_opt1
=COLON_sigexp_opt1 ()
val strexp__AND_strbind_opt as strexp__AND_strbind_opt1=
strexp__AND_strbind_opt1 ()
 in (
 WILDCARDStrBind(I(UNDERBARleft,
					 strexp__AND_strbind_optright),
				       COLON_sigexp_opt,
				       #1 strexp__AND_strbind_opt,
				       #2 strexp__AND_strbind_opt) 
) end
)
 in (LrTable.NT 89,(result,UNDERBAR1left,strexp__AND_strbind_opt1right
),rest671) end
| (246,(_,(MlyValue.strbind strbind1,_,strbind1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_strbind_opt(fn _ => let 
val strbind as strbind1=strbind1 ()
 in ( SOME strbind ) end
)
 in (LrTable.NT 90,(result,AND1left,strbind1right),rest671) end
| (247,rest671) => let val result=MlyValue.AND_strbind_opt(fn _ => (
 NONE ))
 in (LrTable.NT 90,(result,defaultPos,defaultPos),rest671) end
| (248,(_,(MlyValue.AND_strbind_opt AND_strbind_opt1,_,
AND_strbind_opt1right))::(_,(MlyValue.appstrexp appstrexp1,
appstrexp1left,_))::rest671) => let val result=
MlyValue.strexp__AND_strbind_opt(fn _ => let val appstrexp as 
appstrexp1=appstrexp1 ()
val AND_strbind_opt as AND_strbind_opt1=AND_strbind_opt1 ()
 in ( ( appstrexp, AND_strbind_opt ) ) end
)
 in (LrTable.NT 91,(result,appstrexp1left,AND_strbind_opt1right),
rest671) end
| (249,(_,(MlyValue.sigexp__AND_strbind_opt sigexp__AND_strbind_opt1,_
,sigexp__AND_strbind_optright as sigexp__AND_strbind_opt1right))::_::(
_,(MlyValue.strexp strexp1,strexpleft as strexp1left,_))::rest671) => 
let val result=MlyValue.strexp__AND_strbind_opt(fn _ => let val strexp
 as strexp1=strexp1 ()
val sigexp__AND_strbind_opt as sigexp__AND_strbind_opt1=
sigexp__AND_strbind_opt1 ()
 in (
 ( TRANSStrExp(I(strexpleft,
					  sigexp__AND_strbind_optright),
					strexp, #1 sigexp__AND_strbind_opt)
			  , #2 sigexp__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 91,(result,strexp1left,sigexp__AND_strbind_opt1right),
rest671) end
| (250,(_,(MlyValue.sigexp__AND_strbind_opt sigexp__AND_strbind_opt1,_
,sigexp__AND_strbind_optright as sigexp__AND_strbind_opt1right))::_::(
_,(MlyValue.strexp strexp1,strexpleft as strexp1left,_))::rest671) => 
let val result=MlyValue.strexp__AND_strbind_opt(fn _ => let val strexp
 as strexp1=strexp1 ()
val sigexp__AND_strbind_opt as sigexp__AND_strbind_opt1=
sigexp__AND_strbind_opt1 ()
 in (
 ( OPAQStrExp(I(strexpleft,
					 sigexp__AND_strbind_optright),
				       strexp, #1 sigexp__AND_strbind_opt)
			  , #2 sigexp__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 91,(result,strexp1left,sigexp__AND_strbind_opt1right),
rest671) end
| (251,(_,(MlyValue.strexp__AND_strbind_opt strexp__AND_strbind_opt1,_
,strexp__AND_strbind_optright as strexp__AND_strbind_opt1right))::_::(
_,(MlyValue.strpat strpat1,_,_))::(_,(_,FCTleft as FCT1left,_))::
rest671) => let val result=MlyValue.strexp__AND_strbind_opt(fn _ => 
let val strpat as strpat1=strpat1 ()
val strexp__AND_strbind_opt as strexp__AND_strbind_opt1=
strexp__AND_strbind_opt1 ()
 in (
 ( FCTStrExp(I(FCTleft,strexp__AND_strbind_optright),
				      strpat, #1 strexp__AND_strbind_opt)
			  , #2 strexp__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 91,(result,FCT1left,strexp__AND_strbind_opt1right),
rest671) end
| (252,(_,(MlyValue.sigexp__AND_strbind_opt sigexp__AND_strbind_opt1,_
,sigexp__AND_strbind_optright as sigexp__AND_strbind_opt1right))::_::(
_,(MlyValue.infexp infexp1,_,_))::(_,(_,UNPACKleft as UNPACK1left,_))
::rest671) => let val result=MlyValue.strexp__AND_strbind_opt(fn _ => 
let val infexp as infexp1=infexp1 ()
val sigexp__AND_strbind_opt as sigexp__AND_strbind_opt1=
sigexp__AND_strbind_opt1 ()
 in (
 ( UNPACKStrExp(I(UNPACKleft,
					   sigexp__AND_strbind_optright),
					 infexp, #1 sigexp__AND_strbind_opt)
			  , #2 sigexp__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 91,(result,UNPACK1left,sigexp__AND_strbind_opt1right),
rest671) end
| (253,(_,(MlyValue.AND_strbind_opt AND_strbind_opt1,_,
AND_strbind_opt1right))::(_,(MlyValue.sigexp' sigexp'1,sigexp'1left,_)
)::rest671) => let val result=MlyValue.sigexp__AND_strbind_opt(fn _
 => let val sigexp' as sigexp'1=sigexp'1 ()
val AND_strbind_opt as AND_strbind_opt1=AND_strbind_opt1 ()
 in ( ( sigexp', AND_strbind_opt ) ) end
)
 in (LrTable.NT 92,(result,sigexp'1left,AND_strbind_opt1right),rest671
) end
| (254,(_,(MlyValue.sigexp__AND_strbind_opt sigexp__AND_strbind_opt1,_
,sigexp__AND_strbind_optright as sigexp__AND_strbind_opt1right))::_::(
_,(MlyValue.strpat strpat1,_,_))::(_,(_,FCTleft as FCT1left,_))::
rest671) => let val result=MlyValue.sigexp__AND_strbind_opt(fn _ => 
let val strpat as strpat1=strpat1 ()
val sigexp__AND_strbind_opt as sigexp__AND_strbind_opt1=
sigexp__AND_strbind_opt1 ()
 in (
 ( FCTSigExp(I(FCTleft,sigexp__AND_strbind_optright),
				      strpat, #1 sigexp__AND_strbind_opt)
			  , #2 sigexp__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 92,(result,FCT1left,sigexp__AND_strbind_opt1right),
rest671) end
| (255,(_,(MlyValue.rea__AND_strbind_opt rea__AND_strbind_opt1,_,
rea__AND_strbind_optright as rea__AND_strbind_opt1right))::_::(_,(
MlyValue.sigexp sigexp1,sigexpleft as sigexp1left,_))::rest671) => 
let val result=MlyValue.sigexp__AND_strbind_opt(fn _ => let val sigexp
 as sigexp1=sigexp1 ()
val rea__AND_strbind_opt as rea__AND_strbind_opt1=
rea__AND_strbind_opt1 ()
 in (
 ( WHEREREASigExp(I(sigexpleft,
					     rea__AND_strbind_optright),
					   sigexp, #1 rea__AND_strbind_opt)
			  , #2 rea__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 92,(result,sigexp1left,rea__AND_strbind_opt1right),
rest671) end
| (256,(_,(MlyValue.AND_rea_opt__AND_strbind_opt 
AND_rea_opt__AND_strbind_opt1,_,AND_rea_opt__AND_strbind_optright as 
AND_rea_opt__AND_strbind_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,VALleft as 
VAL1left,_))::rest671) => let val result=MlyValue.rea__AND_strbind_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_strbind_opt as AND_rea_opt__AND_strbind_opt1=
AND_rea_opt__AND_strbind_opt1 ()
 in (
 ( VALRea(I(VALleft,AND_rea_opt__AND_strbind_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_strbind_opt)
			  , #2 AND_rea_opt__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 93,(result,VAL1left,AND_rea_opt__AND_strbind_opt1right
),rest671) end
| (257,(_,(MlyValue.AND_rea_opt__AND_strbind_opt 
AND_rea_opt__AND_strbind_opt1,_,AND_rea_opt__AND_strbind_optright as 
AND_rea_opt__AND_strbind_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,FUNleft as 
FUN1left,_))::rest671) => let val result=MlyValue.rea__AND_strbind_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_strbind_opt as AND_rea_opt__AND_strbind_opt1=
AND_rea_opt__AND_strbind_opt1 ()
 in (
 ( FUNRea(I(FUNleft,AND_rea_opt__AND_strbind_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_strbind_opt)
			  , #2 AND_rea_opt__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 93,(result,FUN1left,AND_rea_opt__AND_strbind_opt1right
),rest671) end
| (258,(_,(MlyValue.AND_rea_opt__AND_strbind_opt 
AND_rea_opt__AND_strbind_opt1,_,AND_rea_opt__AND_strbind_optright as 
AND_rea_opt__AND_strbind_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,
CONSTRUCTORleft as CONSTRUCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_strbind_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_strbind_opt as AND_rea_opt__AND_strbind_opt1=
AND_rea_opt__AND_strbind_opt1 ()
 in (
 ( CONSTRUCTORRea(I(CONSTRUCTORleft,
					     AND_rea_opt__AND_strbind_optright),
					   OP_opt1, longvid1, OP_opt2, longvid2,
				           #1 AND_rea_opt__AND_strbind_opt)
			  , #2 AND_rea_opt__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 93,(result,CONSTRUCTOR1left,
AND_rea_opt__AND_strbind_opt1right),rest671) end
| (259,(_,(MlyValue.AND_rea_opt__AND_strbind_opt 
AND_rea_opt__AND_strbind_opt1,_,AND_rea_opt__AND_strbind_optright as 
AND_rea_opt__AND_strbind_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,EXCEPTIONleft
 as EXCEPTION1left,_))::rest671) => let val result=
MlyValue.rea__AND_strbind_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_strbind_opt as AND_rea_opt__AND_strbind_opt1=
AND_rea_opt__AND_strbind_opt1 ()
 in (
 ( EXCEPTIONRea(I(EXCEPTIONleft,
					   AND_rea_opt__AND_strbind_optright),
					 OP_opt1, longvid1, OP_opt2, longvid2,
					 #1 AND_rea_opt__AND_strbind_opt)
			  , #2 AND_rea_opt__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 93,(result,EXCEPTION1left,
AND_rea_opt__AND_strbind_opt1right),rest671) end
| (260,(_,(MlyValue.AND_rea_opt__AND_strbind_opt 
AND_rea_opt__AND_strbind_opt1,_,AND_rea_opt__AND_strbind_optright as 
AND_rea_opt__AND_strbind_opt1right))::(_,(MlyValue.ty ty1,_,_))::_::(_
,(MlyValue.longtycon longtycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1
,_,_))::(_,(_,TYPEleft as TYPE1left,_))::rest671) => let val result=
MlyValue.rea__AND_strbind_opt(fn _ => let val tyvarseq as tyvarseq1=
tyvarseq1 ()
val longtycon as longtycon1=longtycon1 ()
val ty as ty1=ty1 ()
val AND_rea_opt__AND_strbind_opt as AND_rea_opt__AND_strbind_opt1=
AND_rea_opt__AND_strbind_opt1 ()
 in (
 ( TYPERea(I(TYPEleft,
				      AND_rea_opt__AND_strbind_optright),
				    tyvarseq, longtycon, ty,
				    #1 AND_rea_opt__AND_strbind_opt)
			  , #2 AND_rea_opt__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 93,(result,TYPE1left,
AND_rea_opt__AND_strbind_opt1right),rest671) end
| (261,(_,(MlyValue.AND_rea_opt__AND_strbind_opt 
AND_rea_opt__AND_strbind_opt1,_,AND_rea_opt__AND_strbind_optright as 
AND_rea_opt__AND_strbind_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,STRUCTUREleft as 
STRUCTURE1left,_))::rest671) => let val result=
MlyValue.rea__AND_strbind_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_strbind_opt as AND_rea_opt__AND_strbind_opt1=
AND_rea_opt__AND_strbind_opt1 ()
 in (
 ( STRUCTURERea(I(STRUCTUREleft,
					   AND_rea_opt__AND_strbind_optright),
				         longstrid1, COLON_sigexp_opt,
					 longstrid2,
				         #1 AND_rea_opt__AND_strbind_opt)
			  , #2 AND_rea_opt__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 93,(result,STRUCTURE1left,
AND_rea_opt__AND_strbind_opt1right),rest671) end
| (262,(_,(MlyValue.AND_rea_opt__AND_strbind_opt 
AND_rea_opt__AND_strbind_opt1,_,AND_rea_opt__AND_strbind_optright as 
AND_rea_opt__AND_strbind_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,FUNCTORleft as 
FUNCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_strbind_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_strbind_opt as AND_rea_opt__AND_strbind_opt1=
AND_rea_opt__AND_strbind_opt1 ()
 in (
 ( FUNCTORRea(I(FUNCTORleft,
					 AND_rea_opt__AND_strbind_optright),
				       longstrid1, COLON_sigexp_opt, longstrid2,
				       #1 AND_rea_opt__AND_strbind_opt)
			  , #2 AND_rea_opt__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 93,(result,FUNCTOR1left,
AND_rea_opt__AND_strbind_opt1right),rest671) end
| (263,(_,(MlyValue.sigexp__AND_rea_opt__AND_strbind_opt 
sigexp__AND_rea_opt__AND_strbind_opt1,_,
sigexp__AND_rea_opt__AND_strbind_optright as 
sigexp__AND_rea_opt__AND_strbind_opt1right))::_::(_,(
MlyValue.strpat_list0 strpat_list01,_,_))::(_,(MlyValue.longsigid 
longsigid1,_,_))::(_,(_,SIGNATUREleft as SIGNATURE1left,_))::rest671)
 => let val result=MlyValue.rea__AND_strbind_opt(fn _ => let val 
longsigid as longsigid1=longsigid1 ()
val strpat_list0 as strpat_list01=strpat_list01 ()
val sigexp__AND_rea_opt__AND_strbind_opt as 
sigexp__AND_rea_opt__AND_strbind_opt1=
sigexp__AND_rea_opt__AND_strbind_opt1 ()
 in (
 ( SIGNATURERea
				(I(SIGNATUREleft,
				   sigexp__AND_rea_opt__AND_strbind_optright),
				 longsigid, strpat_list0,
				 #1 sigexp__AND_rea_opt__AND_strbind_opt,
				 #2 sigexp__AND_rea_opt__AND_strbind_opt)
			  , #3 sigexp__AND_rea_opt__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 93,(result,SIGNATURE1left,
sigexp__AND_rea_opt__AND_strbind_opt1right),rest671) end
| (264,(_,(MlyValue.AND_strbind_opt AND_strbind_opt1,
AND_strbind_opt1left,AND_strbind_opt1right))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_strbind_opt(fn _ => let val 
AND_strbind_opt as AND_strbind_opt1=AND_strbind_opt1 ()
 in ( ( NONE, AND_strbind_opt ) ) end
)
 in (LrTable.NT 94,(result,AND_strbind_opt1left,AND_strbind_opt1right)
,rest671) end
| (265,(_,(MlyValue.rea__AND_strbind_opt rea__AND_strbind_opt1,_,
rea__AND_strbind_opt1right))::(_,(_,AND1left,_))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_strbind_opt(fn _ => let val 
rea__AND_strbind_opt as rea__AND_strbind_opt1=rea__AND_strbind_opt1 ()
 in (
 ( SOME(#1 rea__AND_strbind_opt)
				  , #2 rea__AND_strbind_opt ) )
 end
)
 in (LrTable.NT 94,(result,AND1left,rea__AND_strbind_opt1right),
rest671) end
| (266,(_,(MlyValue.AND_rea_opt__AND_strbind_opt 
AND_rea_opt__AND_strbind_opt1,_,AND_rea_opt__AND_strbind_opt1right))::
(_,(MlyValue.appsigexp appsigexp1,appsigexp1left,_))::rest671) => let 
val result=MlyValue.sigexp__AND_rea_opt__AND_strbind_opt(fn _ => let 
val appsigexp as appsigexp1=appsigexp1 ()
val AND_rea_opt__AND_strbind_opt as AND_rea_opt__AND_strbind_opt1=
AND_rea_opt__AND_strbind_opt1 ()
 in (
 ( appsigexp
		          , #1 AND_rea_opt__AND_strbind_opt
			  , #2 AND_rea_opt__AND_strbind_opt ) 
) end
)
 in (LrTable.NT 95,(result,appsigexp1left,
AND_rea_opt__AND_strbind_opt1right),rest671) end
| (267,(_,(MlyValue.sigexp sigexp1,_,sigexp1right))::(_,(_,COLON1left,
_))::rest671) => let val result=MlyValue.COLON_sigexp_opt(fn _ => let 
val sigexp as sigexp1=sigexp1 ()
 in ( SOME sigexp ) end
)
 in (LrTable.NT 96,(result,COLON1left,sigexp1right),rest671) end
| (268,rest671) => let val result=MlyValue.COLON_sigexp_opt(fn _ => (
 NONE ))
 in (LrTable.NT 96,(result,defaultPos,defaultPos),rest671) end
| (269,(_,(_,ANYleft as ANY1left,ANYright as ANY1right))::rest671) => 
let val result=MlyValue.atsigexp(fn _ => (
 ANYAtSigExp(I(ANYleft,ANYright)) ))
 in (LrTable.NT 97,(result,ANY1left,ANY1right),rest671) end
| (270,(_,(_,_,ENDright as END1right))::(_,(MlyValue.spec spec1,_,_))
::(_,(_,SIGleft as SIG1left,_))::rest671) => let val result=
MlyValue.atsigexp(fn _ => let val spec as spec1=spec1 ()
 in ( SIGAtSigExp(I(SIGleft,ENDright), spec) ) end
)
 in (LrTable.NT 97,(result,SIG1left,END1right),rest671) end
| (271,(_,(MlyValue.longsigid longsigid1,longsigidleft as 
longsigid1left,longsigidright as longsigid1right))::rest671) => let 
val result=MlyValue.atsigexp(fn _ => let val longsigid as longsigid1=
longsigid1 ()
 in (
 LONGSIGIDAtSigExp(I(longsigidleft,longsigidright),
					    longsigid) 
) end
)
 in (LrTable.NT 97,(result,longsigid1left,longsigid1right),rest671)
 end
| (272,(_,(_,_,ENDright as END1right))::(_,(MlyValue.sigexp sigexp1,_,
_))::_::(_,(MlyValue.dec dec1,_,_))::(_,(_,LETleft as LET1left,_))::
rest671) => let val result=MlyValue.atsigexp(fn _ => let val dec as 
dec1=dec1 ()
val sigexp as sigexp1=sigexp1 ()
 in ( LETAtSigExp(I(LETleft,ENDright), dec, sigexp) ) end
)
 in (LrTable.NT 97,(result,LET1left,END1right),rest671) end
| (273,(_,(_,_,RPARright as RPAR1right))::(_,(MlyValue.sigexp sigexp1,
_,_))::(_,(_,LPARleft as LPAR1left,_))::rest671) => let val result=
MlyValue.atsigexp(fn _ => let val sigexp as sigexp1=sigexp1 ()
 in ( PARAtSigExp(I(LPARleft,RPARright), sigexp) ) end
)
 in (LrTable.NT 97,(result,LPAR1left,RPAR1right),rest671) end
| (274,(_,(MlyValue.atsigexp atsigexp1,atsigexpleft as atsigexp1left,
atsigexpright as atsigexp1right))::rest671) => let val result=
MlyValue.appsigexp(fn _ => let val atsigexp as atsigexp1=atsigexp1 ()
 in ( ATSIGEXPSigExp(I(atsigexpleft,atsigexpright),
					 atsigexp) )
 end
)
 in (LrTable.NT 98,(result,atsigexp1left,atsigexp1right),rest671) end
| (275,(_,(MlyValue.atstrexp atstrexp1,_,atstrexpright as 
atstrexp1right))::(_,(MlyValue.appsigexp appsigexp1,appsigexpleft as 
appsigexp1left,_))::rest671) => let val result=MlyValue.appsigexp(fn _
 => let val appsigexp as appsigexp1=appsigexp1 ()
val atstrexp as atstrexp1=atstrexp1 ()
 in (
 APPSigExp(I(appsigexpleft,atstrexpright),
				    appsigexp, atstrexp) 
) end
)
 in (LrTable.NT 98,(result,appsigexp1left,atstrexp1right),rest671) end
| (276,(_,(MlyValue.sigexp' sigexp'1,sigexp'1left,sigexp'1right))::
rest671) => let val result=MlyValue.sigexp(fn _ => let val sigexp' as 
sigexp'1=sigexp'1 ()
 in ( sigexp' ) end
)
 in (LrTable.NT 99,(result,sigexp'1left,sigexp'1right),rest671) end
| (277,(_,(MlyValue.sigexp sigexp1,_,sigexpright as sigexp1right))::_
::(_,(MlyValue.strpat strpat1,_,_))::(_,(_,FCTleft as FCT1left,_))::
rest671) => let val result=MlyValue.sigexp(fn _ => let val strpat as 
strpat1=strpat1 ()
val sigexp as sigexp1=sigexp1 ()
 in ( FCTSigExp(I(FCTleft,sigexpright), strpat, sigexp) ) end
)
 in (LrTable.NT 99,(result,FCT1left,sigexp1right),rest671) end
| (278,(_,(MlyValue.rea rea1,_,rearight as rea1right))::_::(_,(
MlyValue.sigexp sigexp1,sigexpleft as sigexp1left,_))::rest671) => 
let val result=MlyValue.sigexp(fn _ => let val sigexp as sigexp1=
sigexp1 ()
val rea as rea1=rea1 ()
 in ( WHEREREASigExp(I(sigexpleft,rearight),
					 sigexp, rea) ) end
)
 in (LrTable.NT 99,(result,sigexp1left,rea1right),rest671) end
| (279,(_,(MlyValue.appsigexp appsigexp1,appsigexp1left,
appsigexp1right))::rest671) => let val result=MlyValue.sigexp'(fn _
 => let val appsigexp as appsigexp1=appsigexp1 ()
 in ( appsigexp ) end
)
 in (LrTable.NT 100,(result,appsigexp1left,appsigexp1right),rest671)
 end
| (280,(_,(MlyValue.longstrid longstrid2,_,longstrid2right))::_::(_,(
MlyValue.longstrid longstrid1,_,_))::_::(_,(MlyValue.sigexp sigexp1,
sigexpleft as sigexp1left,_))::rest671) => let val result=
MlyValue.sigexp'(fn _ => let val sigexp as sigexp1=sigexp1 ()
val longstrid1=longstrid1 ()
val longstrid2=longstrid2 ()
 in (
 WHERELONGSTRIDSigExp(I(sigexpleft,longstrid2right),
					       sigexp, longstrid1, longstrid2) 
) end
)
 in (LrTable.NT 100,(result,sigexp1left,longstrid2right),rest671) end
| (281,(_,(MlyValue.sigexp__AND_sigbind_opt sigexp__AND_sigbind_opt1,_
,sigexp__AND_sigbind_optright as sigexp__AND_sigbind_opt1right))::_::(
_,(MlyValue.strpat_list0 strpat_list01,_,_))::(_,(MlyValue.sigid 
sigid1,sigidleft as sigid1left,_))::rest671) => let val result=
MlyValue.sigbind(fn _ => let val sigid as sigid1=sigid1 ()
val strpat_list0 as strpat_list01=strpat_list01 ()
val sigexp__AND_sigbind_opt as sigexp__AND_sigbind_opt1=
sigexp__AND_sigbind_opt1 ()
 in (
 SigBind(I(sigidleft,sigexp__AND_sigbind_optright),
				  sigid, strpat_list0,
				  #1 sigexp__AND_sigbind_opt,
				  #2 sigexp__AND_sigbind_opt) 
) end
)
 in (LrTable.NT 101,(result,sigid1left,sigexp__AND_sigbind_opt1right),
rest671) end
| (282,(_,(MlyValue.strpat_list1 strpat_list11,strpat_list11left,
strpat_list11right))::rest671) => let val result=MlyValue.strpat_list0
(fn _ => let val strpat_list1 as strpat_list11=strpat_list11 ()
 in ( strpat_list1 ) end
)
 in (LrTable.NT 102,(result,strpat_list11left,strpat_list11right),
rest671) end
| (283,rest671) => let val result=MlyValue.strpat_list0(fn _ => ( [] )
)
 in (LrTable.NT 102,(result,defaultPos,defaultPos),rest671) end
| (284,(_,(MlyValue.sigbind sigbind1,_,sigbind1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_sigbind_opt(fn _ => let 
val sigbind as sigbind1=sigbind1 ()
 in ( SOME sigbind ) end
)
 in (LrTable.NT 103,(result,AND1left,sigbind1right),rest671) end
| (285,rest671) => let val result=MlyValue.AND_sigbind_opt(fn _ => (
 NONE ))
 in (LrTable.NT 103,(result,defaultPos,defaultPos),rest671) end
| (286,(_,(MlyValue.AND_sigbind_opt AND_sigbind_opt1,_,
AND_sigbind_opt1right))::(_,(MlyValue.sigexp' sigexp'1,sigexp'1left,_)
)::rest671) => let val result=MlyValue.sigexp__AND_sigbind_opt(fn _
 => let val sigexp' as sigexp'1=sigexp'1 ()
val AND_sigbind_opt as AND_sigbind_opt1=AND_sigbind_opt1 ()
 in ( ( sigexp', AND_sigbind_opt ) ) end
)
 in (LrTable.NT 104,(result,sigexp'1left,AND_sigbind_opt1right),
rest671) end
| (287,(_,(MlyValue.sigexp__AND_sigbind_opt sigexp__AND_sigbind_opt1,_
,sigexp__AND_sigbind_optright as sigexp__AND_sigbind_opt1right))::_::(
_,(MlyValue.strpat strpat1,_,_))::(_,(_,FCTleft as FCT1left,_))::
rest671) => let val result=MlyValue.sigexp__AND_sigbind_opt(fn _ => 
let val strpat as strpat1=strpat1 ()
val sigexp__AND_sigbind_opt as sigexp__AND_sigbind_opt1=
sigexp__AND_sigbind_opt1 ()
 in (
 ( FCTSigExp(I(FCTleft,sigexp__AND_sigbind_optright),
				      strpat, #1 sigexp__AND_sigbind_opt)
			  , #2 sigexp__AND_sigbind_opt ) 
) end
)
 in (LrTable.NT 104,(result,FCT1left,sigexp__AND_sigbind_opt1right),
rest671) end
| (288,(_,(MlyValue.rea__AND_sigbind_opt rea__AND_sigbind_opt1,_,
rea__AND_sigbind_optright as rea__AND_sigbind_opt1right))::_::(_,(
MlyValue.sigexp sigexp1,sigexpleft as sigexp1left,_))::rest671) => 
let val result=MlyValue.sigexp__AND_sigbind_opt(fn _ => let val sigexp
 as sigexp1=sigexp1 ()
val rea__AND_sigbind_opt as rea__AND_sigbind_opt1=
rea__AND_sigbind_opt1 ()
 in (
 ( WHEREREASigExp(I(sigexpleft,
					     rea__AND_sigbind_optright),
					   sigexp, #1 rea__AND_sigbind_opt)
			  , #2 rea__AND_sigbind_opt ) 
) end
)
 in (LrTable.NT 104,(result,sigexp1left,rea__AND_sigbind_opt1right),
rest671) end
| (289,(_,(MlyValue.AND_rea_opt__AND_sigbind_opt 
AND_rea_opt__AND_sigbind_opt1,_,AND_rea_opt__AND_sigbind_optright as 
AND_rea_opt__AND_sigbind_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,VALleft as 
VAL1left,_))::rest671) => let val result=MlyValue.rea__AND_sigbind_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_sigbind_opt as AND_rea_opt__AND_sigbind_opt1=
AND_rea_opt__AND_sigbind_opt1 ()
 in (
 ( VALRea(I(VALleft,AND_rea_opt__AND_sigbind_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_sigbind_opt)
			  , #2 AND_rea_opt__AND_sigbind_opt ) 
) end
)
 in (LrTable.NT 105,(result,VAL1left,
AND_rea_opt__AND_sigbind_opt1right),rest671) end
| (290,(_,(MlyValue.AND_rea_opt__AND_sigbind_opt 
AND_rea_opt__AND_sigbind_opt1,_,AND_rea_opt__AND_sigbind_optright as 
AND_rea_opt__AND_sigbind_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,FUNleft as 
FUN1left,_))::rest671) => let val result=MlyValue.rea__AND_sigbind_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_sigbind_opt as AND_rea_opt__AND_sigbind_opt1=
AND_rea_opt__AND_sigbind_opt1 ()
 in (
 ( FUNRea(I(FUNleft,AND_rea_opt__AND_sigbind_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_sigbind_opt)
			  , #2 AND_rea_opt__AND_sigbind_opt ) 
) end
)
 in (LrTable.NT 105,(result,FUN1left,
AND_rea_opt__AND_sigbind_opt1right),rest671) end
| (291,(_,(MlyValue.AND_rea_opt__AND_sigbind_opt 
AND_rea_opt__AND_sigbind_opt1,_,AND_rea_opt__AND_sigbind_optright as 
AND_rea_opt__AND_sigbind_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,
CONSTRUCTORleft as CONSTRUCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_sigbind_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_sigbind_opt as AND_rea_opt__AND_sigbind_opt1=
AND_rea_opt__AND_sigbind_opt1 ()
 in (
 ( CONSTRUCTORRea(I(CONSTRUCTORleft,
					     AND_rea_opt__AND_sigbind_optright),
					   OP_opt1, longvid1, OP_opt2, longvid2,
				           #1 AND_rea_opt__AND_sigbind_opt)
			  , #2 AND_rea_opt__AND_sigbind_opt ) 
) end
)
 in (LrTable.NT 105,(result,CONSTRUCTOR1left,
AND_rea_opt__AND_sigbind_opt1right),rest671) end
| (292,(_,(MlyValue.AND_rea_opt__AND_sigbind_opt 
AND_rea_opt__AND_sigbind_opt1,_,AND_rea_opt__AND_sigbind_optright as 
AND_rea_opt__AND_sigbind_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,EXCEPTIONleft
 as EXCEPTION1left,_))::rest671) => let val result=
MlyValue.rea__AND_sigbind_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_sigbind_opt as AND_rea_opt__AND_sigbind_opt1=
AND_rea_opt__AND_sigbind_opt1 ()
 in (
 ( EXCEPTIONRea(I(EXCEPTIONleft,
					   AND_rea_opt__AND_sigbind_optright),
					 OP_opt1, longvid1, OP_opt2, longvid2,
					 #1 AND_rea_opt__AND_sigbind_opt)
			  , #2 AND_rea_opt__AND_sigbind_opt ) 
) end
)
 in (LrTable.NT 105,(result,EXCEPTION1left,
AND_rea_opt__AND_sigbind_opt1right),rest671) end
| (293,(_,(MlyValue.AND_rea_opt__AND_sigbind_opt 
AND_rea_opt__AND_sigbind_opt1,_,AND_rea_opt__AND_sigbind_optright as 
AND_rea_opt__AND_sigbind_opt1right))::(_,(MlyValue.ty ty1,_,_))::_::(_
,(MlyValue.longtycon longtycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1
,_,_))::(_,(_,TYPEleft as TYPE1left,_))::rest671) => let val result=
MlyValue.rea__AND_sigbind_opt(fn _ => let val tyvarseq as tyvarseq1=
tyvarseq1 ()
val longtycon as longtycon1=longtycon1 ()
val ty as ty1=ty1 ()
val AND_rea_opt__AND_sigbind_opt as AND_rea_opt__AND_sigbind_opt1=
AND_rea_opt__AND_sigbind_opt1 ()
 in (
 ( TYPERea(I(TYPEleft,
				      AND_rea_opt__AND_sigbind_optright),
				    tyvarseq, longtycon, ty,
				    #1 AND_rea_opt__AND_sigbind_opt)
			  , #2 AND_rea_opt__AND_sigbind_opt ) 
) end
)
 in (LrTable.NT 105,(result,TYPE1left,
AND_rea_opt__AND_sigbind_opt1right),rest671) end
| (294,(_,(MlyValue.AND_rea_opt__AND_sigbind_opt 
AND_rea_opt__AND_sigbind_opt1,_,AND_rea_opt__AND_sigbind_optright as 
AND_rea_opt__AND_sigbind_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,STRUCTUREleft as 
STRUCTURE1left,_))::rest671) => let val result=
MlyValue.rea__AND_sigbind_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_sigbind_opt as AND_rea_opt__AND_sigbind_opt1=
AND_rea_opt__AND_sigbind_opt1 ()
 in (
 ( STRUCTURERea(I(STRUCTUREleft,
					   AND_rea_opt__AND_sigbind_optright),
				         longstrid1, COLON_sigexp_opt,
					 longstrid2,
				         #1 AND_rea_opt__AND_sigbind_opt)
			  , #2 AND_rea_opt__AND_sigbind_opt ) 
) end
)
 in (LrTable.NT 105,(result,STRUCTURE1left,
AND_rea_opt__AND_sigbind_opt1right),rest671) end
| (295,(_,(MlyValue.AND_rea_opt__AND_sigbind_opt 
AND_rea_opt__AND_sigbind_opt1,_,AND_rea_opt__AND_sigbind_optright as 
AND_rea_opt__AND_sigbind_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,FUNCTORleft as 
FUNCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_sigbind_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_sigbind_opt as AND_rea_opt__AND_sigbind_opt1=
AND_rea_opt__AND_sigbind_opt1 ()
 in (
 ( FUNCTORRea(I(FUNCTORleft,
					 AND_rea_opt__AND_sigbind_optright),
				       longstrid1, COLON_sigexp_opt, longstrid2,
				       #1 AND_rea_opt__AND_sigbind_opt)
			  , #2 AND_rea_opt__AND_sigbind_opt ) 
) end
)
 in (LrTable.NT 105,(result,FUNCTOR1left,
AND_rea_opt__AND_sigbind_opt1right),rest671) end
| (296,(_,(MlyValue.sigexp__AND_rea_opt__AND_sigbind_opt 
sigexp__AND_rea_opt__AND_sigbind_opt1,_,
sigexp__AND_rea_opt__AND_sigbind_optright as 
sigexp__AND_rea_opt__AND_sigbind_opt1right))::_::(_,(
MlyValue.strpat_list0 strpat_list01,_,_))::(_,(MlyValue.longsigid 
longsigid1,_,_))::(_,(_,SIGNATUREleft as SIGNATURE1left,_))::rest671)
 => let val result=MlyValue.rea__AND_sigbind_opt(fn _ => let val 
longsigid as longsigid1=longsigid1 ()
val strpat_list0 as strpat_list01=strpat_list01 ()
val sigexp__AND_rea_opt__AND_sigbind_opt as 
sigexp__AND_rea_opt__AND_sigbind_opt1=
sigexp__AND_rea_opt__AND_sigbind_opt1 ()
 in (
 ( SIGNATURERea
				(I(SIGNATUREleft,
				   sigexp__AND_rea_opt__AND_sigbind_optright),
				 longsigid, strpat_list0,
				 #1 sigexp__AND_rea_opt__AND_sigbind_opt,
				 #2 sigexp__AND_rea_opt__AND_sigbind_opt)
			  , #3 sigexp__AND_rea_opt__AND_sigbind_opt ) 
) end
)
 in (LrTable.NT 105,(result,SIGNATURE1left,
sigexp__AND_rea_opt__AND_sigbind_opt1right),rest671) end
| (297,(_,(MlyValue.AND_sigbind_opt AND_sigbind_opt1,
AND_sigbind_opt1left,AND_sigbind_opt1right))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_sigbind_opt(fn _ => let val 
AND_sigbind_opt as AND_sigbind_opt1=AND_sigbind_opt1 ()
 in ( ( NONE, AND_sigbind_opt) ) end
)
 in (LrTable.NT 106,(result,AND_sigbind_opt1left,AND_sigbind_opt1right
),rest671) end
| (298,(_,(MlyValue.rea__AND_sigbind_opt rea__AND_sigbind_opt1,_,
rea__AND_sigbind_opt1right))::(_,(_,AND1left,_))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_sigbind_opt(fn _ => let val 
rea__AND_sigbind_opt as rea__AND_sigbind_opt1=rea__AND_sigbind_opt1 ()
 in (
 ( SOME(#1 rea__AND_sigbind_opt)
				  , #2 rea__AND_sigbind_opt ) )
 end
)
 in (LrTable.NT 106,(result,AND1left,rea__AND_sigbind_opt1right),
rest671) end
| (299,(_,(MlyValue.AND_rea_opt__AND_sigbind_opt 
AND_rea_opt__AND_sigbind_opt1,_,AND_rea_opt__AND_sigbind_opt1right))::
(_,(MlyValue.appsigexp appsigexp1,appsigexp1left,_))::rest671) => let 
val result=MlyValue.sigexp__AND_rea_opt__AND_sigbind_opt(fn _ => let 
val appsigexp as appsigexp1=appsigexp1 ()
val AND_rea_opt__AND_sigbind_opt as AND_rea_opt__AND_sigbind_opt1=
AND_rea_opt__AND_sigbind_opt1 ()
 in (
 ( appsigexp
		          , #1 AND_rea_opt__AND_sigbind_opt
			  , #2 AND_rea_opt__AND_sigbind_opt ) 
) end
)
 in (LrTable.NT 107,(result,appsigexp1left,
AND_rea_opt__AND_sigbind_opt1right),rest671) end
| (300,(_,(MlyValue.AND_rea_opt AND_rea_opt1,_,AND_rea_optright as 
AND_rea_opt1right))::(_,(MlyValue.longvid longvid2,_,_))::(_,(
MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid longvid1,_,_))
::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,VALleft as VAL1left,_))::
rest671) => let val result=MlyValue.rea(fn _ => let val OP_opt1=
OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt as AND_rea_opt1=AND_rea_opt1 ()
 in (
 VALRea(I(VALleft,AND_rea_optright),
				 OP_opt1, longvid1,
				 OP_opt2, longvid2, AND_rea_opt) 
) end
)
 in (LrTable.NT 108,(result,VAL1left,AND_rea_opt1right),rest671) end
| (301,(_,(MlyValue.AND_rea_opt AND_rea_opt1,_,AND_rea_optright as 
AND_rea_opt1right))::(_,(MlyValue.longvid longvid2,_,_))::(_,(
MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid longvid1,_,_))
::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,FUNleft as FUN1left,_))::
rest671) => let val result=MlyValue.rea(fn _ => let val OP_opt1=
OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt as AND_rea_opt1=AND_rea_opt1 ()
 in (
 FUNRea(I(FUNleft,AND_rea_optright),
				 OP_opt1, longvid1,
				 OP_opt2, longvid2, AND_rea_opt) 
) end
)
 in (LrTable.NT 108,(result,FUN1left,AND_rea_opt1right),rest671) end
| (302,(_,(MlyValue.AND_rea_opt AND_rea_opt1,_,AND_rea_optright as 
AND_rea_opt1right))::(_,(MlyValue.longvid longvid2,_,_))::(_,(
MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid longvid1,_,_))
::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,CONSTRUCTORleft as 
CONSTRUCTOR1left,_))::rest671) => let val result=MlyValue.rea(fn _ => 
let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt as AND_rea_opt1=AND_rea_opt1 ()
 in (
 CONSTRUCTORRea(I(CONSTRUCTORleft,AND_rea_optright),
					 OP_opt1, longvid1,
					 OP_opt2, longvid2, AND_rea_opt) 
) end
)
 in (LrTable.NT 108,(result,CONSTRUCTOR1left,AND_rea_opt1right),
rest671) end
| (303,(_,(MlyValue.AND_rea_opt AND_rea_opt1,_,AND_rea_optright as 
AND_rea_opt1right))::(_,(MlyValue.longvid longvid2,_,_))::(_,(
MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid longvid1,_,_))
::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,EXCEPTIONleft as 
EXCEPTION1left,_))::rest671) => let val result=MlyValue.rea(fn _ => 
let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt as AND_rea_opt1=AND_rea_opt1 ()
 in (
 EXCEPTIONRea(I(EXCEPTIONleft,AND_rea_optright),
					 OP_opt1, longvid1,
					 OP_opt2, longvid2, AND_rea_opt) 
) end
)
 in (LrTable.NT 108,(result,EXCEPTION1left,AND_rea_opt1right),rest671)
 end
| (304,(_,(MlyValue.AND_rea_opt AND_rea_opt1,_,AND_rea_optright as 
AND_rea_opt1right))::(_,(MlyValue.ty ty1,_,_))::_::(_,(
MlyValue.longtycon longtycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1,_
,_))::(_,(_,TYPEleft as TYPE1left,_))::rest671) => let val result=
MlyValue.rea(fn _ => let val tyvarseq as tyvarseq1=tyvarseq1 ()
val longtycon as longtycon1=longtycon1 ()
val ty as ty1=ty1 ()
val AND_rea_opt as AND_rea_opt1=AND_rea_opt1 ()
 in (
 TYPERea(I(TYPEleft,AND_rea_optright),
				  tyvarseq, longtycon, ty, AND_rea_opt) 
) end
)
 in (LrTable.NT 108,(result,TYPE1left,AND_rea_opt1right),rest671) end
| (305,(_,(MlyValue.AND_rea_opt AND_rea_opt1,_,AND_rea_optright as 
AND_rea_opt1right))::(_,(MlyValue.longstrid longstrid2,_,_))::_::(_,(
MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_,_))::(_,(
MlyValue.longstrid longstrid1,_,_))::(_,(_,STRUCTUREleft as 
STRUCTURE1left,_))::rest671) => let val result=MlyValue.rea(fn _ => 
let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt as AND_rea_opt1=AND_rea_opt1 ()
 in (
 STRUCTURERea(I(STRUCTUREleft,AND_rea_optright),
				       longstrid1, COLON_sigexp_opt, longstrid2,
				       AND_rea_opt) 
) end
)
 in (LrTable.NT 108,(result,STRUCTURE1left,AND_rea_opt1right),rest671)
 end
| (306,(_,(MlyValue.AND_rea_opt AND_rea_opt1,_,AND_rea_optright as 
AND_rea_opt1right))::(_,(MlyValue.longstrid longstrid2,_,_))::_::(_,(
MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_,_))::(_,(
MlyValue.longstrid longstrid1,_,_))::(_,(_,FUNCTORleft as FUNCTOR1left
,_))::rest671) => let val result=MlyValue.rea(fn _ => let val 
longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt as AND_rea_opt1=AND_rea_opt1 ()
 in (
 FUNCTORRea(I(FUNCTORleft,AND_rea_optright),
				     longstrid1, COLON_sigexp_opt, longstrid2,
				     AND_rea_opt) 
) end
)
 in (LrTable.NT 108,(result,FUNCTOR1left,AND_rea_opt1right),rest671)
 end
| (307,(_,(MlyValue.sigexp__AND_rea_opt sigexp__AND_rea_opt1,_,
sigexp__AND_rea_optright as sigexp__AND_rea_opt1right))::_::(_,(
MlyValue.strpat_list0 strpat_list01,_,_))::(_,(MlyValue.longsigid 
longsigid1,_,_))::(_,(_,SIGNATUREleft as SIGNATURE1left,_))::rest671)
 => let val result=MlyValue.rea(fn _ => let val longsigid as 
longsigid1=longsigid1 ()
val strpat_list0 as strpat_list01=strpat_list01 ()
val sigexp__AND_rea_opt as sigexp__AND_rea_opt1=sigexp__AND_rea_opt1 
()
 in (
 SIGNATURERea(I(SIGNATUREleft,
					 sigexp__AND_rea_optright),
				       longsigid, strpat_list0,
				       #1 sigexp__AND_rea_opt,
				       #2 sigexp__AND_rea_opt) 
) end
)
 in (LrTable.NT 108,(result,SIGNATURE1left,sigexp__AND_rea_opt1right),
rest671) end
| (308,(_,(MlyValue.rea rea1,_,rea1right))::(_,(_,AND1left,_))::
rest671) => let val result=MlyValue.AND_rea_opt(fn _ => let val rea
 as rea1=rea1 ()
 in ( SOME rea ) end
)
 in (LrTable.NT 109,(result,AND1left,rea1right),rest671) end
| (309,rest671) => let val result=MlyValue.AND_rea_opt(fn _ => ( NONE 
))
 in (LrTable.NT 109,(result,defaultPos,defaultPos),rest671) end
| (310,(_,(MlyValue.AND_rea_opt AND_rea_opt1,_,AND_rea_opt1right))::(_
,(MlyValue.appsigexp appsigexp1,appsigexp1left,_))::rest671) => let 
val result=MlyValue.sigexp__AND_rea_opt(fn _ => let val appsigexp as 
appsigexp1=appsigexp1 ()
val AND_rea_opt as AND_rea_opt1=AND_rea_opt1 ()
 in ( ( appsigexp, AND_rea_opt ) ) end
)
 in (LrTable.NT 110,(result,appsigexp1left,AND_rea_opt1right),rest671)
 end
| (311,(_,(MlyValue.strexp__AND_funbind_opt strexp__AND_funbind_opt1,_
,strexp__AND_funbind_optright as strexp__AND_funbind_opt1right))::_::(
_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_,_))::(_,(
MlyValue.strpat_list1 strpat_list11,_,_))::(_,(MlyValue.strid strid1,
stridleft as strid1left,_))::rest671) => let val result=
MlyValue.funbind(fn _ => let val strid as strid1=strid1 ()
val strpat_list1 as strpat_list11=strpat_list11 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val strexp__AND_funbind_opt as strexp__AND_funbind_opt1=
strexp__AND_funbind_opt1 ()
 in (
 TRANSFunBind(I(stridleft,
					 strexp__AND_funbind_optright),
				       strid, strpat_list1, COLON_sigexp_opt,
				       #1 strexp__AND_funbind_opt,
				       #2 strexp__AND_funbind_opt) 
) end
)
 in (LrTable.NT 111,(result,strid1left,strexp__AND_funbind_opt1right),
rest671) end
| (312,(_,(MlyValue.strexp__AND_funbind_opt strexp__AND_funbind_opt1,_
,strexp__AND_funbind_optright as strexp__AND_funbind_opt1right))::_::(
_,(MlyValue.sigexp sigexp1,_,_))::_::(_,(MlyValue.strpat_list1 
strpat_list11,_,_))::(_,(MlyValue.strid strid1,stridleft as strid1left
,_))::rest671) => let val result=MlyValue.funbind(fn _ => let val 
strid as strid1=strid1 ()
val strpat_list1 as strpat_list11=strpat_list11 ()
val sigexp as sigexp1=sigexp1 ()
val strexp__AND_funbind_opt as strexp__AND_funbind_opt1=
strexp__AND_funbind_opt1 ()
 in (
 OPAQFunBind(I(stridleft,strexp__AND_funbind_optright),
				      strid, strpat_list1, sigexp,
				      #1 strexp__AND_funbind_opt,
				      #2 strexp__AND_funbind_opt) 
) end
)
 in (LrTable.NT 111,(result,strid1left,strexp__AND_funbind_opt1right),
rest671) end
| (313,(_,(MlyValue.strpat strpat1,strpat1left,strpat1right))::rest671
) => let val result=MlyValue.strpat_list1(fn _ => let val strpat as 
strpat1=strpat1 ()
 in ( strpat::[] ) end
)
 in (LrTable.NT 112,(result,strpat1left,strpat1right),rest671) end
| (314,(_,(MlyValue.strpat_list1 strpat_list11,_,strpat_list11right))
::(_,(MlyValue.strpat strpat1,strpat1left,_))::rest671) => let val 
result=MlyValue.strpat_list1(fn _ => let val strpat as strpat1=strpat1
 ()
val strpat_list1 as strpat_list11=strpat_list11 ()
 in ( strpat::strpat_list1 ) end
)
 in (LrTable.NT 112,(result,strpat1left,strpat_list11right),rest671)
 end
| (315,(_,(MlyValue.funbind funbind1,_,funbind1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_funbind_opt(fn _ => let 
val funbind as funbind1=funbind1 ()
 in ( SOME funbind ) end
)
 in (LrTable.NT 113,(result,AND1left,funbind1right),rest671) end
| (316,rest671) => let val result=MlyValue.AND_funbind_opt(fn _ => (
 NONE ))
 in (LrTable.NT 113,(result,defaultPos,defaultPos),rest671) end
| (317,(_,(MlyValue.AND_funbind_opt AND_funbind_opt1,_,
AND_funbind_opt1right))::(_,(MlyValue.appstrexp appstrexp1,
appstrexp1left,_))::rest671) => let val result=
MlyValue.strexp__AND_funbind_opt(fn _ => let val appstrexp as 
appstrexp1=appstrexp1 ()
val AND_funbind_opt as AND_funbind_opt1=AND_funbind_opt1 ()
 in ( ( appstrexp, AND_funbind_opt ) ) end
)
 in (LrTable.NT 114,(result,appstrexp1left,AND_funbind_opt1right),
rest671) end
| (318,(_,(MlyValue.sigexp__AND_funbind_opt sigexp__AND_funbind_opt1,_
,sigexp__AND_funbind_optright as sigexp__AND_funbind_opt1right))::_::(
_,(MlyValue.strexp strexp1,strexpleft as strexp1left,_))::rest671) => 
let val result=MlyValue.strexp__AND_funbind_opt(fn _ => let val strexp
 as strexp1=strexp1 ()
val sigexp__AND_funbind_opt as sigexp__AND_funbind_opt1=
sigexp__AND_funbind_opt1 ()
 in (
 ( TRANSStrExp(I(strexpleft,
					  sigexp__AND_funbind_optright),
					strexp, #1 sigexp__AND_funbind_opt)
			  , #2 sigexp__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 114,(result,strexp1left,sigexp__AND_funbind_opt1right)
,rest671) end
| (319,(_,(MlyValue.sigexp__AND_funbind_opt sigexp__AND_funbind_opt1,_
,sigexp__AND_funbind_optright as sigexp__AND_funbind_opt1right))::_::(
_,(MlyValue.strexp strexp1,strexpleft as strexp1left,_))::rest671) => 
let val result=MlyValue.strexp__AND_funbind_opt(fn _ => let val strexp
 as strexp1=strexp1 ()
val sigexp__AND_funbind_opt as sigexp__AND_funbind_opt1=
sigexp__AND_funbind_opt1 ()
 in (
 ( OPAQStrExp(I(strexpleft,
					 sigexp__AND_funbind_optright),
				       strexp, #1 sigexp__AND_funbind_opt)
			  , #2 sigexp__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 114,(result,strexp1left,sigexp__AND_funbind_opt1right)
,rest671) end
| (320,(_,(MlyValue.strexp__AND_funbind_opt strexp__AND_funbind_opt1,_
,strexp__AND_funbind_optright as strexp__AND_funbind_opt1right))::_::(
_,(MlyValue.strpat strpat1,_,_))::(_,(_,FCTleft as FCT1left,_))::
rest671) => let val result=MlyValue.strexp__AND_funbind_opt(fn _ => 
let val strpat as strpat1=strpat1 ()
val strexp__AND_funbind_opt as strexp__AND_funbind_opt1=
strexp__AND_funbind_opt1 ()
 in (
 ( FCTStrExp(I(FCTleft,strexp__AND_funbind_optright),
				      strpat, #1 strexp__AND_funbind_opt)
			  , #2 strexp__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 114,(result,FCT1left,strexp__AND_funbind_opt1right),
rest671) end
| (321,(_,(MlyValue.sigexp__AND_funbind_opt sigexp__AND_funbind_opt1,_
,sigexp__AND_funbind_optright as sigexp__AND_funbind_opt1right))::_::(
_,(MlyValue.infexp infexp1,_,_))::(_,(_,UNPACKleft as UNPACK1left,_))
::rest671) => let val result=MlyValue.strexp__AND_funbind_opt(fn _ => 
let val infexp as infexp1=infexp1 ()
val sigexp__AND_funbind_opt as sigexp__AND_funbind_opt1=
sigexp__AND_funbind_opt1 ()
 in (
 ( UNPACKStrExp(I(UNPACKleft,
					   sigexp__AND_funbind_optright),
					 infexp, #1 sigexp__AND_funbind_opt)
			  , #2 sigexp__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 114,(result,UNPACK1left,sigexp__AND_funbind_opt1right)
,rest671) end
| (322,(_,(MlyValue.AND_funbind_opt AND_funbind_opt1,_,
AND_funbind_opt1right))::(_,(MlyValue.sigexp' sigexp'1,sigexp'1left,_)
)::rest671) => let val result=MlyValue.sigexp__AND_funbind_opt(fn _
 => let val sigexp' as sigexp'1=sigexp'1 ()
val AND_funbind_opt as AND_funbind_opt1=AND_funbind_opt1 ()
 in ( ( sigexp', AND_funbind_opt ) ) end
)
 in (LrTable.NT 115,(result,sigexp'1left,AND_funbind_opt1right),
rest671) end
| (323,(_,(MlyValue.sigexp__AND_funbind_opt sigexp__AND_funbind_opt1,_
,sigexp__AND_funbind_optright as sigexp__AND_funbind_opt1right))::_::(
_,(MlyValue.strpat strpat1,_,_))::(_,(_,FCTleft as FCT1left,_))::
rest671) => let val result=MlyValue.sigexp__AND_funbind_opt(fn _ => 
let val strpat as strpat1=strpat1 ()
val sigexp__AND_funbind_opt as sigexp__AND_funbind_opt1=
sigexp__AND_funbind_opt1 ()
 in (
 ( FCTSigExp(I(FCTleft,sigexp__AND_funbind_optright),
				      strpat, #1 sigexp__AND_funbind_opt)
			  , #2 sigexp__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 115,(result,FCT1left,sigexp__AND_funbind_opt1right),
rest671) end
| (324,(_,(MlyValue.rea__AND_funbind_opt rea__AND_funbind_opt1,_,
rea__AND_funbind_optright as rea__AND_funbind_opt1right))::_::(_,(
MlyValue.sigexp sigexp1,sigexpleft as sigexp1left,_))::rest671) => 
let val result=MlyValue.sigexp__AND_funbind_opt(fn _ => let val sigexp
 as sigexp1=sigexp1 ()
val rea__AND_funbind_opt as rea__AND_funbind_opt1=
rea__AND_funbind_opt1 ()
 in (
 ( WHEREREASigExp(I(sigexpleft,
					     rea__AND_funbind_optright),
					   sigexp, #1 rea__AND_funbind_opt)
			  , #2 rea__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 115,(result,sigexp1left,rea__AND_funbind_opt1right),
rest671) end
| (325,(_,(MlyValue.AND_rea_opt__AND_funbind_opt 
AND_rea_opt__AND_funbind_opt1,_,AND_rea_opt__AND_funbind_optright as 
AND_rea_opt__AND_funbind_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,VALleft as 
VAL1left,_))::rest671) => let val result=MlyValue.rea__AND_funbind_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_funbind_opt as AND_rea_opt__AND_funbind_opt1=
AND_rea_opt__AND_funbind_opt1 ()
 in (
 ( VALRea(I(VALleft,AND_rea_opt__AND_funbind_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_funbind_opt)
			  , #2 AND_rea_opt__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 116,(result,VAL1left,
AND_rea_opt__AND_funbind_opt1right),rest671) end
| (326,(_,(MlyValue.AND_rea_opt__AND_funbind_opt 
AND_rea_opt__AND_funbind_opt1,_,AND_rea_opt__AND_funbind_optright as 
AND_rea_opt__AND_funbind_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,FUNleft as 
FUN1left,_))::rest671) => let val result=MlyValue.rea__AND_funbind_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_funbind_opt as AND_rea_opt__AND_funbind_opt1=
AND_rea_opt__AND_funbind_opt1 ()
 in (
 ( FUNRea(I(FUNleft,AND_rea_opt__AND_funbind_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_funbind_opt)
			  , #2 AND_rea_opt__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 116,(result,FUN1left,
AND_rea_opt__AND_funbind_opt1right),rest671) end
| (327,(_,(MlyValue.AND_rea_opt__AND_funbind_opt 
AND_rea_opt__AND_funbind_opt1,_,AND_rea_opt__AND_funbind_optright as 
AND_rea_opt__AND_funbind_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,
CONSTRUCTORleft as CONSTRUCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_funbind_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_funbind_opt as AND_rea_opt__AND_funbind_opt1=
AND_rea_opt__AND_funbind_opt1 ()
 in (
 ( CONSTRUCTORRea(I(CONSTRUCTORleft,
					     AND_rea_opt__AND_funbind_optright),
					   OP_opt1, longvid1, OP_opt2, longvid2,
				           #1 AND_rea_opt__AND_funbind_opt)
			  , #2 AND_rea_opt__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 116,(result,CONSTRUCTOR1left,
AND_rea_opt__AND_funbind_opt1right),rest671) end
| (328,(_,(MlyValue.AND_rea_opt__AND_funbind_opt 
AND_rea_opt__AND_funbind_opt1,_,AND_rea_opt__AND_funbind_optright as 
AND_rea_opt__AND_funbind_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,EXCEPTIONleft
 as EXCEPTION1left,_))::rest671) => let val result=
MlyValue.rea__AND_funbind_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_funbind_opt as AND_rea_opt__AND_funbind_opt1=
AND_rea_opt__AND_funbind_opt1 ()
 in (
 ( EXCEPTIONRea(I(EXCEPTIONleft,
					   AND_rea_opt__AND_funbind_optright),
					 OP_opt1, longvid1, OP_opt2, longvid2,
					 #1 AND_rea_opt__AND_funbind_opt)
			  , #2 AND_rea_opt__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 116,(result,EXCEPTION1left,
AND_rea_opt__AND_funbind_opt1right),rest671) end
| (329,(_,(MlyValue.AND_rea_opt__AND_funbind_opt 
AND_rea_opt__AND_funbind_opt1,_,AND_rea_opt__AND_funbind_optright as 
AND_rea_opt__AND_funbind_opt1right))::(_,(MlyValue.ty ty1,_,_))::_::(_
,(MlyValue.longtycon longtycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1
,_,_))::(_,(_,TYPEleft as TYPE1left,_))::rest671) => let val result=
MlyValue.rea__AND_funbind_opt(fn _ => let val tyvarseq as tyvarseq1=
tyvarseq1 ()
val longtycon as longtycon1=longtycon1 ()
val ty as ty1=ty1 ()
val AND_rea_opt__AND_funbind_opt as AND_rea_opt__AND_funbind_opt1=
AND_rea_opt__AND_funbind_opt1 ()
 in (
 ( TYPERea(I(TYPEleft,
				      AND_rea_opt__AND_funbind_optright),
				    tyvarseq, longtycon, ty,
				    #1 AND_rea_opt__AND_funbind_opt)
			  , #2 AND_rea_opt__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 116,(result,TYPE1left,
AND_rea_opt__AND_funbind_opt1right),rest671) end
| (330,(_,(MlyValue.AND_rea_opt__AND_funbind_opt 
AND_rea_opt__AND_funbind_opt1,_,AND_rea_opt__AND_funbind_optright as 
AND_rea_opt__AND_funbind_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,STRUCTUREleft as 
STRUCTURE1left,_))::rest671) => let val result=
MlyValue.rea__AND_funbind_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_funbind_opt as AND_rea_opt__AND_funbind_opt1=
AND_rea_opt__AND_funbind_opt1 ()
 in (
 ( STRUCTURERea(I(STRUCTUREleft,
					   AND_rea_opt__AND_funbind_optright),
				         longstrid1, COLON_sigexp_opt,
					 longstrid2,
				         #1 AND_rea_opt__AND_funbind_opt)
			  , #2 AND_rea_opt__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 116,(result,STRUCTURE1left,
AND_rea_opt__AND_funbind_opt1right),rest671) end
| (331,(_,(MlyValue.AND_rea_opt__AND_funbind_opt 
AND_rea_opt__AND_funbind_opt1,_,AND_rea_opt__AND_funbind_optright as 
AND_rea_opt__AND_funbind_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,FUNCTORleft as 
FUNCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_funbind_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_funbind_opt as AND_rea_opt__AND_funbind_opt1=
AND_rea_opt__AND_funbind_opt1 ()
 in (
 ( FUNCTORRea(I(FUNCTORleft,
					 AND_rea_opt__AND_funbind_optright),
				       longstrid1, COLON_sigexp_opt, longstrid2,
				       #1 AND_rea_opt__AND_funbind_opt)
			  , #2 AND_rea_opt__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 116,(result,FUNCTOR1left,
AND_rea_opt__AND_funbind_opt1right),rest671) end
| (332,(_,(MlyValue.sigexp__AND_rea_opt__AND_funbind_opt 
sigexp__AND_rea_opt__AND_funbind_opt1,_,
sigexp__AND_rea_opt__AND_funbind_optright as 
sigexp__AND_rea_opt__AND_funbind_opt1right))::_::(_,(
MlyValue.strpat_list0 strpat_list01,_,_))::(_,(MlyValue.longsigid 
longsigid1,_,_))::(_,(_,SIGNATUREleft as SIGNATURE1left,_))::rest671)
 => let val result=MlyValue.rea__AND_funbind_opt(fn _ => let val 
longsigid as longsigid1=longsigid1 ()
val strpat_list0 as strpat_list01=strpat_list01 ()
val sigexp__AND_rea_opt__AND_funbind_opt as 
sigexp__AND_rea_opt__AND_funbind_opt1=
sigexp__AND_rea_opt__AND_funbind_opt1 ()
 in (
 ( SIGNATURERea
				(I(SIGNATUREleft,
				   sigexp__AND_rea_opt__AND_funbind_optright),
				 longsigid, strpat_list0,
				 #1 sigexp__AND_rea_opt__AND_funbind_opt,
				 #2 sigexp__AND_rea_opt__AND_funbind_opt)
			  , #3 sigexp__AND_rea_opt__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 116,(result,SIGNATURE1left,
sigexp__AND_rea_opt__AND_funbind_opt1right),rest671) end
| (333,(_,(MlyValue.AND_funbind_opt AND_funbind_opt1,
AND_funbind_opt1left,AND_funbind_opt1right))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_funbind_opt(fn _ => let val 
AND_funbind_opt as AND_funbind_opt1=AND_funbind_opt1 ()
 in ( ( NONE, AND_funbind_opt ) ) end
)
 in (LrTable.NT 117,(result,AND_funbind_opt1left,AND_funbind_opt1right
),rest671) end
| (334,(_,(MlyValue.rea__AND_funbind_opt rea__AND_funbind_opt1,_,
rea__AND_funbind_opt1right))::(_,(_,AND1left,_))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_funbind_opt(fn _ => let val 
rea__AND_funbind_opt as rea__AND_funbind_opt1=rea__AND_funbind_opt1 ()
 in (
 ( SOME(#1 rea__AND_funbind_opt)
			  , #2 rea__AND_funbind_opt ) )
 end
)
 in (LrTable.NT 117,(result,AND1left,rea__AND_funbind_opt1right),
rest671) end
| (335,(_,(MlyValue.AND_rea_opt__AND_funbind_opt 
AND_rea_opt__AND_funbind_opt1,_,AND_rea_opt__AND_funbind_opt1right))::
(_,(MlyValue.appsigexp appsigexp1,appsigexp1left,_))::rest671) => let 
val result=MlyValue.sigexp__AND_rea_opt__AND_funbind_opt(fn _ => let 
val appsigexp as appsigexp1=appsigexp1 ()
val AND_rea_opt__AND_funbind_opt as AND_rea_opt__AND_funbind_opt1=
AND_rea_opt__AND_funbind_opt1 ()
 in (
 ( appsigexp
		          , #1 AND_rea_opt__AND_funbind_opt
			  , #2 AND_rea_opt__AND_funbind_opt ) 
) end
)
 in (LrTable.NT 118,(result,appsigexp1left,
AND_rea_opt__AND_funbind_opt1right),rest671) end
| (336,(_,(MlyValue.spec1 spec11,spec11left,spec11right))::rest671)
 => let val result=MlyValue.spec(fn _ => let val spec1 as spec11=
spec11 ()
 in ( spec1 ) end
)
 in (LrTable.NT 119,(result,spec11left,spec11right),rest671) end
| (337,rest671) => let val result=MlyValue.spec(fn _ => (
 EMPTYSpec(I(defaultPos,defaultPos)) ))
 in (LrTable.NT 119,(result,defaultPos,defaultPos),rest671) end
| (338,(_,(MlyValue.spec1' spec1'1,spec1'1left,spec1'1right))::rest671
) => let val result=MlyValue.spec1(fn _ => let val spec1' as spec1'1=
spec1'1 ()
 in ( spec1' ) end
)
 in (LrTable.NT 120,(result,spec1'1left,spec1'1right),rest671) end
| (339,(_,(MlyValue.spec1' spec1'1,_,spec1'right as spec1'1right))::(_
,(MlyValue.spec1 spec11,spec1left as spec11left,_))::rest671) => let 
val result=MlyValue.spec1(fn _ => let val spec1 as spec11=spec11 ()
val spec1' as spec1'1=spec1'1 ()
 in ( SEQSpec(I(spec1left,spec1'right), spec1, spec1') ) end
)
 in (LrTable.NT 120,(result,spec11left,spec1'1right),rest671) end
| (340,(_,(_,SEMICOLONleft as SEMICOLON1left,SEMICOLON1right))::
rest671) => let val result=MlyValue.spec1(fn _ => (
 EMPTYSpec(I(SEMICOLONleft,SEMICOLONleft)) ))
 in (LrTable.NT 120,(result,SEMICOLON1left,SEMICOLON1right),rest671)
 end
| (341,(_,(MlyValue.longtycon_EQUALS_list2 longtycon_EQUALS_list21,_,
longtycon_EQUALS_list2right as longtycon_EQUALS_list21right))::_::(_,(
_,SHARINGleft as SHARING1left,_))::rest671) => let val result=
MlyValue.spec1(fn _ => let val longtycon_EQUALS_list2 as 
longtycon_EQUALS_list21=longtycon_EQUALS_list21 ()
 in (
 SHARINGTYPESpec(I(SHARINGleft,
					    longtycon_EQUALS_list2right),
					  EMPTYSpec(I(SHARINGleft,SHARINGleft)),
					  longtycon_EQUALS_list2) 
) end
)
 in (LrTable.NT 120,(result,SHARING1left,longtycon_EQUALS_list21right)
,rest671) end
| (342,(_,(MlyValue.longtycon_EQUALS_list2 longtycon_EQUALS_list21,_,
longtycon_EQUALS_list2right as longtycon_EQUALS_list21right))::_::_::(
_,(MlyValue.spec1 spec11,spec1left as spec11left,_))::rest671) => let 
val result=MlyValue.spec1(fn _ => let val spec1 as spec11=spec11 ()
val longtycon_EQUALS_list2 as longtycon_EQUALS_list21=
longtycon_EQUALS_list21 ()
 in (
 SHARINGTYPESpec(I(spec1left,
					    longtycon_EQUALS_list2right),
					  spec1, longtycon_EQUALS_list2) 
) end
)
 in (LrTable.NT 120,(result,spec11left,longtycon_EQUALS_list21right),
rest671) end
| (343,(_,(MlyValue.longsigid_EQUALS_list2 longsigid_EQUALS_list21,_,
longsigid_EQUALS_list2right as longsigid_EQUALS_list21right))::_::(_,(
_,SHARINGleft as SHARING1left,_))::rest671) => let val result=
MlyValue.spec1(fn _ => let val longsigid_EQUALS_list2 as 
longsigid_EQUALS_list21=longsigid_EQUALS_list21 ()
 in (
 SHARINGSIGNATURESpec(I(SHARINGleft,
						 longsigid_EQUALS_list2right),
					       EMPTYSpec(I(SHARINGleft,
							   SHARINGleft)),
					       longsigid_EQUALS_list2) 
) end
)
 in (LrTable.NT 120,(result,SHARING1left,longsigid_EQUALS_list21right)
,rest671) end
| (344,(_,(MlyValue.longsigid_EQUALS_list2 longsigid_EQUALS_list21,_,
longsigid_EQUALS_list2right as longsigid_EQUALS_list21right))::_::_::(
_,(MlyValue.spec1 spec11,spec1left as spec11left,_))::rest671) => let 
val result=MlyValue.spec1(fn _ => let val spec1 as spec11=spec11 ()
val longsigid_EQUALS_list2 as longsigid_EQUALS_list21=
longsigid_EQUALS_list21 ()
 in (
 SHARINGSIGNATURESpec(I(spec1left,
						 longsigid_EQUALS_list2right),
					       spec1, longsigid_EQUALS_list2) 
) end
)
 in (LrTable.NT 120,(result,spec11left,longsigid_EQUALS_list21right),
rest671) end
| (345,(_,(MlyValue.longstrid_EQUALS_list2 longstrid_EQUALS_list21,_,
longstrid_EQUALS_list2right as longstrid_EQUALS_list21right))::(_,(_,
SHARINGleft as SHARING1left,_))::rest671) => let val result=
MlyValue.spec1(fn _ => let val longstrid_EQUALS_list2 as 
longstrid_EQUALS_list21=longstrid_EQUALS_list21 ()
 in (
 SHARINGSpec(I(SHARINGleft,
					longstrid_EQUALS_list2right),
				      EMPTYSpec(I(SHARINGleft,SHARINGleft)),
				      longstrid_EQUALS_list2) 
) end
)
 in (LrTable.NT 120,(result,SHARING1left,longstrid_EQUALS_list21right)
,rest671) end
| (346,(_,(MlyValue.longstrid_EQUALS_list2 longstrid_EQUALS_list21,_,
longstrid_EQUALS_list2right as longstrid_EQUALS_list21right))::_::(_,(
MlyValue.spec1 spec11,spec1left as spec11left,_))::rest671) => let 
val result=MlyValue.spec1(fn _ => let val spec1 as spec11=spec11 ()
val longstrid_EQUALS_list2 as longstrid_EQUALS_list21=
longstrid_EQUALS_list21 ()
 in (
 SHARINGSpec(I(spec1left,longstrid_EQUALS_list2right),
				      spec1, longstrid_EQUALS_list2) 
) end
)
 in (LrTable.NT 120,(result,spec11left,longstrid_EQUALS_list21right),
rest671) end
| (347,(_,(MlyValue.valdesc valdesc1,_,valdescright as valdesc1right))
::(_,(_,VALleft as VAL1left,_))::rest671) => let val result=
MlyValue.spec1'(fn _ => let val valdesc as valdesc1=valdesc1 ()
 in ( VALSpec(I(VALleft,valdescright), valdesc) ) end
)
 in (LrTable.NT 121,(result,VAL1left,valdesc1right),rest671) end
| (348,(_,(MlyValue.valdesc valdesc1,_,valdescright as valdesc1right))
::(_,(_,FUNleft as FUN1left,_))::rest671) => let val result=
MlyValue.spec1'(fn _ => let val valdesc as valdesc1=valdesc1 ()
 in ( FUNSpec(I(FUNleft,valdescright), valdesc) ) end
)
 in (LrTable.NT 121,(result,FUN1left,valdesc1right),rest671) end
| (349,(_,(MlyValue.typdesc typdesc1,_,typdescright as typdesc1right))
::(_,(_,TYPEleft as TYPE1left,_))::rest671) => let val result=
MlyValue.spec1'(fn _ => let val typdesc as typdesc1=typdesc1 ()
 in ( TYPESpec(I(TYPEleft,typdescright), typdesc) ) end
)
 in (LrTable.NT 121,(result,TYPE1left,typdesc1right),rest671) end
| (350,(_,(MlyValue.typdesc typdesc1,_,typdescright as typdesc1right))
::(_,(_,EQTYPEleft as EQTYPE1left,_))::rest671) => let val result=
MlyValue.spec1'(fn _ => let val typdesc as typdesc1=typdesc1 ()
 in ( EQTYPESpec(I(EQTYPEleft,typdescright), typdesc) ) end
)
 in (LrTable.NT 121,(result,EQTYPE1left,typdesc1right),rest671) end
| (351,(_,(MlyValue.typdesc typdesc1,_,typdescright as typdesc1right))
::(_,(_,EQEQTYPEleft as EQEQTYPE1left,_))::rest671) => let val result=
MlyValue.spec1'(fn _ => let val typdesc as typdesc1=typdesc1 ()
 in ( EQEQTYPESpec(I(EQEQTYPEleft,typdescright), typdesc) ) end
)
 in (LrTable.NT 121,(result,EQEQTYPE1left,typdesc1right),rest671) end
| (352,(_,(MlyValue.WITHTYPE_typdesc_opt WITHTYPE_typdesc_opt1,_,
WITHTYPE_typdesc_optright as WITHTYPE_typdesc_opt1right))::(_,(
MlyValue.datdesc0 datdesc01,_,_))::(_,(_,DATATYPEleft as DATATYPE1left
,_))::rest671) => let val result=MlyValue.spec1'(fn _ => let val 
datdesc0 as datdesc01=datdesc01 ()
val WITHTYPE_typdesc_opt as WITHTYPE_typdesc_opt1=
WITHTYPE_typdesc_opt1 ()
 in (
 DATATYPESpec(I(DATATYPEleft,
					 WITHTYPE_typdesc_optright),
				       datdesc0, WITHTYPE_typdesc_opt) 
) end
)
 in (LrTable.NT 121,(result,DATATYPE1left,WITHTYPE_typdesc_opt1right),
rest671) end
| (353,(_,(MlyValue.WITHTYPE_typdesc_opt WITHTYPE_typdesc_opt1,_,
WITHTYPE_typdesc_optright as WITHTYPE_typdesc_opt1right))::(_,(
MlyValue.datdesc1 datdesc11,_,_))::(_,(_,DATATYPEleft as DATATYPE1left
,_))::rest671) => let val result=MlyValue.spec1'(fn _ => let val 
datdesc1 as datdesc11=datdesc11 ()
val WITHTYPE_typdesc_opt as WITHTYPE_typdesc_opt1=
WITHTYPE_typdesc_opt1 ()
 in (
 DATATYPESpec(I(DATATYPEleft,
					 WITHTYPE_typdesc_optright),
				       datdesc1, WITHTYPE_typdesc_opt) 
) end
)
 in (LrTable.NT 121,(result,DATATYPE1left,WITHTYPE_typdesc_opt1right),
rest671) end
| (354,(_,(MlyValue.longtycon longtycon1,_,longtyconright as 
longtycon1right))::_::_::(_,(MlyValue.tycon tycon1,_,_))::(_,(_,
DATATYPEleft as DATATYPE1left,_))::rest671) => let val result=
MlyValue.spec1'(fn _ => let val tycon as tycon1=tycon1 ()
val longtycon as longtycon1=longtycon1 ()
 in (
 REPLICATIONSpec(I(DATATYPEleft,longtyconright),
					  tycon, longtycon) 
) end
)
 in (LrTable.NT 121,(result,DATATYPE1left,longtycon1right),rest671)
 end
| (355,(_,(MlyValue.dcondesc dcondesc1,_,dcondescright as 
dcondesc1right))::(_,(_,CONSTRUCTORleft as CONSTRUCTOR1left,_))::
rest671) => let val result=MlyValue.spec1'(fn _ => let val dcondesc
 as dcondesc1=dcondesc1 ()
 in (
 CONSTRUCTORSpec(I(CONSTRUCTORleft,dcondescright),
					  dcondesc) )
 end
)
 in (LrTable.NT 121,(result,CONSTRUCTOR1left,dcondesc1right),rest671)
 end
| (356,(_,(MlyValue.exdesc exdesc1,_,exdescright as exdesc1right))::(_
,(_,EXCEPTIONleft as EXCEPTION1left,_))::rest671) => let val result=
MlyValue.spec1'(fn _ => let val exdesc as exdesc1=exdesc1 ()
 in ( EXCEPTIONSpec(I(EXCEPTIONleft,exdescright), exdesc) ) end
)
 in (LrTable.NT 121,(result,EXCEPTION1left,exdesc1right),rest671) end
| (357,(_,(MlyValue.strdesc strdesc1,_,strdescright as strdesc1right))
::(_,(_,STRUCTUREleft as STRUCTURE1left,_))::rest671) => let val 
result=MlyValue.spec1'(fn _ => let val strdesc as strdesc1=strdesc1 ()
 in ( STRUCTURESpec(I(STRUCTUREleft,strdescright), strdesc)) end
)
 in (LrTable.NT 121,(result,STRUCTURE1left,strdesc1right),rest671) end
| (358,(_,(MlyValue.sigdesc sigdesc1,_,sigdescright as sigdesc1right))
::(_,(_,SIGNATUREleft as SIGNATURE1left,_))::rest671) => let val 
result=MlyValue.spec1'(fn _ => let val sigdesc as sigdesc1=sigdesc1 ()
 in ( SIGNATURESpec(I(SIGNATUREleft,sigdescright), sigdesc)) end
)
 in (LrTable.NT 121,(result,SIGNATURE1left,sigdesc1right),rest671) end
| (359,(_,(MlyValue.fundesc fundesc1,_,fundescright as fundesc1right))
::(_,(_,FUNCTORleft as FUNCTOR1left,_))::rest671) => let val result=
MlyValue.spec1'(fn _ => let val fundesc as fundesc1=fundesc1 ()
 in ( FUNCTORSpec(I(FUNCTORleft,fundescright), fundesc)) end
)
 in (LrTable.NT 121,(result,FUNCTOR1left,fundesc1right),rest671) end
| (360,(_,(MlyValue.sigexp sigexp1,_,sigexpright as sigexp1right))::(_
,(_,INCLUDEleft as INCLUDE1left,_))::rest671) => let val result=
MlyValue.spec1'(fn _ => let val sigexp as sigexp1=sigexp1 ()
 in ( INCLUDESpec(I(INCLUDEleft,sigexpright), sigexp) ) end
)
 in (LrTable.NT 121,(result,INCLUDE1left,sigexp1right),rest671) end
| (361,(_,(MlyValue.ty ty1,_,tyright as ty1right))::_::(_,(
MlyValue.tyvar tyvar1,_,_))::_::(_,(MlyValue.vid vid1,_,_))::(_,(
MlyValue.OP_opt OP_opt1,_,_))::(_,(_,OVERLOADleft as OVERLOAD1left,_))
::rest671) => let val result=MlyValue.spec1'(fn _ => let val OP_opt
 as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val tyvar as tyvar1=tyvar1 ()
val ty as ty1=ty1 ()
 in (
 OVERLOADSpec(I(OVERLOADleft,tyright),
				       OP_opt, vid, tyvar, ty)
) end
)
 in (LrTable.NT 121,(result,OVERLOAD1left,ty1right),rest671) end
| (362,(_,(MlyValue.longvid longvid1,_,longvidright as longvid1right))
::_::(_,(MlyValue.longtycon longtycon1,_,_))::_::(_,(MlyValue.vid vid1
,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,INSTANCEleft as 
INSTANCE1left,_))::rest671) => let val result=MlyValue.spec1'(fn _ => 
let val OP_opt as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val longtycon as longtycon1=longtycon1 ()
val longvid as longvid1=longvid1 ()
 in (
 INSTANCESpec(I(INSTANCEleft,longvidright),
				       OP_opt, vid, longtycon, longvid) 
) end
)
 in (LrTable.NT 121,(result,INSTANCE1left,longvid1right),rest671) end
| (363,(_,(MlyValue.longtycon longtycon1,_,longtyconright as 
longtycon1right))::_::(_,(MlyValue.scon scon1,_,_))::(_,(_,
INSTANCEleft as INSTANCE1left,_))::rest671) => let val result=
MlyValue.spec1'(fn _ => let val scon as scon1=scon1 ()
val longtycon as longtycon1=longtycon1 ()
 in (
 INSTANCESCONSpec(I(INSTANCEleft,longtyconright),
					   scon, longtycon) 
) end
)
 in (LrTable.NT 121,(result,INSTANCE1left,longtycon1right),rest671)
 end
| (364,(_,(MlyValue.vid_list1 vid_list11,_,vid_list1right as 
vid_list11right))::(_,(MlyValue.d_opt d_opt1,_,_))::(_,(_,INFIXleft
 as INFIX1left,_))::rest671) => let val result=MlyValue.spec1'(fn _
 => let val d_opt as d_opt1=d_opt1 ()
val vid_list1 as vid_list11=vid_list11 ()
 in (
 INFIXMULTISpec(I(INFIXleft,vid_list1right), d_opt,
					 vid_list1) )
 end
)
 in (LrTable.NT 121,(result,INFIX1left,vid_list11right),rest671) end
| (365,(_,(MlyValue.vid_list1 vid_list11,_,vid_list1right as 
vid_list11right))::(_,(MlyValue.d_opt d_opt1,_,_))::(_,(_,INFIXRleft
 as INFIXR1left,_))::rest671) => let val result=MlyValue.spec1'(fn _
 => let val d_opt as d_opt1=d_opt1 ()
val vid_list1 as vid_list11=vid_list11 ()
 in (
 INFIXRMULTISpec(I(INFIXRleft,vid_list1right), d_opt,
					  vid_list1) 
) end
)
 in (LrTable.NT 121,(result,INFIXR1left,vid_list11right),rest671) end
| (366,(_,(MlyValue.vid_list1 vid_list11,_,vid_list1right as 
vid_list11right))::(_,(_,NONFIXleft as NONFIX1left,_))::rest671) => 
let val result=MlyValue.spec1'(fn _ => let val vid_list1 as vid_list11
=vid_list11 ()
 in ( NONFIXMULTISpec(I(NONFIXleft,vid_list1right),
					  vid_list1) 
) end
)
 in (LrTable.NT 121,(result,NONFIX1left,vid_list11right),rest671) end
| (367,(_,(MlyValue.typdesc typdesc1,_,typdesc1right))::(_,(_,
WITHTYPE1left,_))::rest671) => let val result=
MlyValue.WITHTYPE_typdesc_opt(fn _ => let val typdesc as typdesc1=
typdesc1 ()
 in ( SOME typdesc ) end
)
 in (LrTable.NT 122,(result,WITHTYPE1left,typdesc1right),rest671) end
| (368,rest671) => let val result=MlyValue.WITHTYPE_typdesc_opt(fn _
 => ( NONE ))
 in (LrTable.NT 122,(result,defaultPos,defaultPos),rest671) end
| (369,(_,(MlyValue.longtycon_EQUALS_list1 longtycon_EQUALS_list11,_,
longtycon_EQUALS_list11right))::_::(_,(MlyValue.longtycon longtycon1,
longtycon1left,_))::rest671) => let val result=
MlyValue.longtycon_EQUALS_list1(fn _ => let val longtycon as 
longtycon1=longtycon1 ()
val longtycon_EQUALS_list1 as longtycon_EQUALS_list11=
longtycon_EQUALS_list11 ()
 in ( longtycon::longtycon_EQUALS_list1 ) end
)
 in (LrTable.NT 123,(result,longtycon1left,
longtycon_EQUALS_list11right),rest671) end
| (370,(_,(MlyValue.longtycon longtycon1,longtycon1left,
longtycon1right))::rest671) => let val result=
MlyValue.longtycon_EQUALS_list1(fn _ => let val longtycon as 
longtycon1=longtycon1 ()
 in ( longtycon::[] ) end
)
 in (LrTable.NT 123,(result,longtycon1left,longtycon1right),rest671)
 end
| (371,(_,(MlyValue.longtycon_EQUALS_list1 longtycon_EQUALS_list11,_,
longtycon_EQUALS_list11right))::_::(_,(MlyValue.longtycon longtycon1,
longtycon1left,_))::rest671) => let val result=
MlyValue.longtycon_EQUALS_list2(fn _ => let val longtycon as 
longtycon1=longtycon1 ()
val longtycon_EQUALS_list1 as longtycon_EQUALS_list11=
longtycon_EQUALS_list11 ()
 in ( longtycon::longtycon_EQUALS_list1 ) end
)
 in (LrTable.NT 124,(result,longtycon1left,
longtycon_EQUALS_list11right),rest671) end
| (372,(_,(MlyValue.longsigid_EQUALS_list1 longsigid_EQUALS_list11,_,
longsigid_EQUALS_list11right))::_::(_,(MlyValue.longsigid longsigid1,
longsigid1left,_))::rest671) => let val result=
MlyValue.longsigid_EQUALS_list1(fn _ => let val longsigid as 
longsigid1=longsigid1 ()
val longsigid_EQUALS_list1 as longsigid_EQUALS_list11=
longsigid_EQUALS_list11 ()
 in ( longsigid::longsigid_EQUALS_list1 ) end
)
 in (LrTable.NT 125,(result,longsigid1left,
longsigid_EQUALS_list11right),rest671) end
| (373,(_,(MlyValue.longsigid longsigid1,longsigid1left,
longsigid1right))::rest671) => let val result=
MlyValue.longsigid_EQUALS_list1(fn _ => let val longsigid as 
longsigid1=longsigid1 ()
 in ( longsigid::[] ) end
)
 in (LrTable.NT 125,(result,longsigid1left,longsigid1right),rest671)
 end
| (374,(_,(MlyValue.longsigid_EQUALS_list1 longsigid_EQUALS_list11,_,
longsigid_EQUALS_list11right))::_::(_,(MlyValue.longsigid longsigid1,
longsigid1left,_))::rest671) => let val result=
MlyValue.longsigid_EQUALS_list2(fn _ => let val longsigid as 
longsigid1=longsigid1 ()
val longsigid_EQUALS_list1 as longsigid_EQUALS_list11=
longsigid_EQUALS_list11 ()
 in ( longsigid::longsigid_EQUALS_list1 ) end
)
 in (LrTable.NT 126,(result,longsigid1left,
longsigid_EQUALS_list11right),rest671) end
| (375,(_,(MlyValue.longstrid_EQUALS_list1 longstrid_EQUALS_list11,_,
longstrid_EQUALS_list11right))::_::(_,(MlyValue.longstrid longstrid1,
longstrid1left,_))::rest671) => let val result=
MlyValue.longstrid_EQUALS_list1(fn _ => let val longstrid as 
longstrid1=longstrid1 ()
val longstrid_EQUALS_list1 as longstrid_EQUALS_list11=
longstrid_EQUALS_list11 ()
 in ( longstrid::longstrid_EQUALS_list1 ) end
)
 in (LrTable.NT 127,(result,longstrid1left,
longstrid_EQUALS_list11right),rest671) end
| (376,(_,(MlyValue.longstrid longstrid1,longstrid1left,
longstrid1right))::rest671) => let val result=
MlyValue.longstrid_EQUALS_list1(fn _ => let val longstrid as 
longstrid1=longstrid1 ()
 in ( longstrid::[] ) end
)
 in (LrTable.NT 127,(result,longstrid1left,longstrid1right),rest671)
 end
| (377,(_,(MlyValue.longstrid_EQUALS_list1 longstrid_EQUALS_list11,_,
longstrid_EQUALS_list11right))::_::(_,(MlyValue.longstrid longstrid1,
longstrid1left,_))::rest671) => let val result=
MlyValue.longstrid_EQUALS_list2(fn _ => let val longstrid as 
longstrid1=longstrid1 ()
val longstrid_EQUALS_list1 as longstrid_EQUALS_list11=
longstrid_EQUALS_list11 ()
 in ( longstrid::longstrid_EQUALS_list1 ) end
)
 in (LrTable.NT 128,(result,longstrid1left,
longstrid_EQUALS_list11right),rest671) end
| (378,(_,(MlyValue.AND_valdesc_opt AND_valdesc_opt1,_,
AND_valdesc_optright as AND_valdesc_opt1right))::(_,(MlyValue.ty ty1,_
,_))::_::(_,(MlyValue.vid vid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,
OP_optleft as OP_opt1left,_))::rest671) => let val result=
MlyValue.valdesc(fn _ => let val OP_opt as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val ty as ty1=ty1 ()
val AND_valdesc_opt as AND_valdesc_opt1=AND_valdesc_opt1 ()
 in (
 NEWValDesc(I(OP_optleft,AND_valdesc_optright),
				  OP_opt, vid, ty, AND_valdesc_opt) 
) end
)
 in (LrTable.NT 129,(result,OP_opt1left,AND_valdesc_opt1right),rest671
) end
| (379,(_,(MlyValue.AND_valdesc_opt AND_valdesc_opt1,_,
AND_valdesc_optright as AND_valdesc_opt1right))::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.vid
 vid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,OP_opt1left,_))::rest671) => 
let val result=MlyValue.valdesc(fn _ => let val OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val OP_opt2=OP_opt2 ()
val longvid as longvid1=longvid1 ()
val AND_valdesc_opt as AND_valdesc_opt1=AND_valdesc_opt1 ()
 in (
 EQUALValDesc(I(OP_opt1left,AND_valdesc_optright),
				       OP_opt1, vid,
				       OP_opt2, longvid, AND_valdesc_opt) 
) end
)
 in (LrTable.NT 129,(result,OP_opt1left,AND_valdesc_opt1right),rest671
) end
| (380,(_,(MlyValue.valdesc valdesc1,_,valdesc1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_valdesc_opt(fn _ => let 
val valdesc as valdesc1=valdesc1 ()
 in ( SOME valdesc ) end
)
 in (LrTable.NT 130,(result,AND1left,valdesc1right),rest671) end
| (381,rest671) => let val result=MlyValue.AND_valdesc_opt(fn _ => (
 NONE ))
 in (LrTable.NT 130,(result,defaultPos,defaultPos),rest671) end
| (382,(_,(MlyValue.AND_typdesc_opt AND_typdesc_opt1,_,
AND_typdesc_optright as AND_typdesc_opt1right))::(_,(MlyValue.tycon 
tycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1,tyvarseqleft as 
tyvarseq1left,_))::rest671) => let val result=MlyValue.typdesc(fn _
 => let val tyvarseq as tyvarseq1=tyvarseq1 ()
val tycon as tycon1=tycon1 ()
val AND_typdesc_opt as AND_typdesc_opt1=AND_typdesc_opt1 ()
 in (
 NEWTypDesc(I(tyvarseqleft,AND_typdesc_optright),
				     tyvarseq, tycon, AND_typdesc_opt) 
) end
)
 in (LrTable.NT 131,(result,tyvarseq1left,AND_typdesc_opt1right),
rest671) end
| (383,(_,(MlyValue.AND_typdesc_opt AND_typdesc_opt1,_,
AND_typdesc_optright as AND_typdesc_opt1right))::(_,(MlyValue.ty ty1,_
,_))::_::(_,(MlyValue.tycon tycon1,_,_))::(_,(MlyValue.tyvarseq 
tyvarseq1,tyvarseqleft as tyvarseq1left,_))::rest671) => let val 
result=MlyValue.typdesc(fn _ => let val tyvarseq as tyvarseq1=
tyvarseq1 ()
val tycon as tycon1=tycon1 ()
val ty as ty1=ty1 ()
val AND_typdesc_opt as AND_typdesc_opt1=AND_typdesc_opt1 ()
 in (
 EQUALTypDesc(I(tyvarseqleft,AND_typdesc_optright),
				       tyvarseq, tycon, ty, AND_typdesc_opt) 
) end
)
 in (LrTable.NT 131,(result,tyvarseq1left,AND_typdesc_opt1right),
rest671) end
| (384,(_,(MlyValue.typdesc typdesc1,_,typdesc1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_typdesc_opt(fn _ => let 
val typdesc as typdesc1=typdesc1 ()
 in ( SOME typdesc ) end
)
 in (LrTable.NT 132,(result,AND1left,typdesc1right),rest671) end
| (385,rest671) => let val result=MlyValue.AND_typdesc_opt(fn _ => (
 NONE ))
 in (LrTable.NT 132,(result,defaultPos,defaultPos),rest671) end
| (386,(_,(MlyValue.AND_datdesc_opt AND_datdesc_opt1,_,
AND_datdesc_optright as AND_datdesc_opt1right))::(_,(MlyValue.tycon 
tycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1,tyvarseqleft as 
tyvarseq1left,_))::rest671) => let val result=MlyValue.datdesc(fn _
 => let val tyvarseq as tyvarseq1=tyvarseq1 ()
val tycon as tycon1=tycon1 ()
val AND_datdesc_opt as AND_datdesc_opt1=AND_datdesc_opt1 ()
 in (
 OPENDatDesc(I(tyvarseqleft,AND_datdesc_optright),
				      tyvarseq, tycon, AND_datdesc_opt) 
) end
)
 in (LrTable.NT 133,(result,tyvarseq1left,AND_datdesc_opt1right),
rest671) end
| (387,(_,(MlyValue.AND_datdesc_opt AND_datdesc_opt1,_,
AND_datdesc_optright as AND_datdesc_opt1right))::(_,(MlyValue.condesc 
condesc1,_,_))::_::(_,(MlyValue.tycon tycon1,_,_))::(_,(
MlyValue.tyvarseq tyvarseq1,tyvarseqleft as tyvarseq1left,_))::rest671
) => let val result=MlyValue.datdesc(fn _ => let val tyvarseq as 
tyvarseq1=tyvarseq1 ()
val tycon as tycon1=tycon1 ()
val condesc as condesc1=condesc1 ()
val AND_datdesc_opt as AND_datdesc_opt1=AND_datdesc_opt1 ()
 in (
 CLOSEDDatDesc(I(tyvarseqleft,AND_datdesc_optright),
				     tyvarseq, tycon, condesc, AND_datdesc_opt)
) end
)
 in (LrTable.NT 133,(result,tyvarseq1left,AND_datdesc_opt1right),
rest671) end
| (388,(_,(MlyValue.AND_datdesc_opt AND_datdesc_opt1,_,
AND_datdesc_optright as AND_datdesc_opt1right))::(_,(MlyValue.tycon 
tycon1,tyconleft as tycon1left,_))::rest671) => let val result=
MlyValue.datdesc0(fn _ => let val tycon as tycon1=tycon1 ()
val AND_datdesc_opt as AND_datdesc_opt1=AND_datdesc_opt1 ()
 in (
 OPENDatDesc(I(tyconleft,AND_datdesc_optright),
				      Seq(I(defaultPos,defaultPos), []),
				      tycon, AND_datdesc_opt) 
) end
)
 in (LrTable.NT 134,(result,tycon1left,AND_datdesc_opt1right),rest671)
 end
| (389,(_,(MlyValue.AND_datdesc_opt AND_datdesc_opt1,_,
AND_datdesc_optright as AND_datdesc_opt1right))::(_,(MlyValue.condesc 
condesc1,_,_))::_::(_,(MlyValue.tycon tycon1,tyconleft as tycon1left,_
))::rest671) => let val result=MlyValue.datdesc0(fn _ => let val tycon
 as tycon1=tycon1 ()
val condesc as condesc1=condesc1 ()
val AND_datdesc_opt as AND_datdesc_opt1=AND_datdesc_opt1 ()
 in (
 CLOSEDDatDesc(I(tyconleft,AND_datdesc_optright),
	  				Seq(I(defaultPos,defaultPos), []),
					tycon, condesc, AND_datdesc_opt) 
) end
)
 in (LrTable.NT 134,(result,tycon1left,AND_datdesc_opt1right),rest671)
 end
| (390,(_,(MlyValue.AND_datdesc_opt AND_datdesc_opt1,_,
AND_datdesc_optright as AND_datdesc_opt1right))::(_,(MlyValue.tycon 
tycon1,_,_))::(_,(MlyValue.tyvarseq1 tyvarseq11,tyvarseq1left as 
tyvarseq11left,_))::rest671) => let val result=MlyValue.datdesc1(fn _
 => let val tyvarseq1 as tyvarseq11=tyvarseq11 ()
val tycon as tycon1=tycon1 ()
val AND_datdesc_opt as AND_datdesc_opt1=AND_datdesc_opt1 ()
 in (
 OPENDatDesc(I(tyvarseq1left,AND_datdesc_optright),
				      tyvarseq1, tycon, AND_datdesc_opt) 
) end
)
 in (LrTable.NT 135,(result,tyvarseq11left,AND_datdesc_opt1right),
rest671) end
| (391,(_,(MlyValue.AND_datdesc_opt AND_datdesc_opt1,_,
AND_datdesc_optright as AND_datdesc_opt1right))::(_,(MlyValue.condesc 
condesc1,_,_))::_::(_,(MlyValue.tycon tycon1,_,_))::(_,(
MlyValue.tyvarseq1 tyvarseq11,tyvarseq1left as tyvarseq11left,_))::
rest671) => let val result=MlyValue.datdesc1(fn _ => let val tyvarseq1
 as tyvarseq11=tyvarseq11 ()
val tycon as tycon1=tycon1 ()
val condesc as condesc1=condesc1 ()
val AND_datdesc_opt as AND_datdesc_opt1=AND_datdesc_opt1 ()
 in (
 CLOSEDDatDesc(I(tyvarseq1left,AND_datdesc_optright),
	  				tyvarseq1, tycon, condesc,
					AND_datdesc_opt) 
) end
)
 in (LrTable.NT 135,(result,tyvarseq11left,AND_datdesc_opt1right),
rest671) end
| (392,(_,(MlyValue.datdesc datdesc1,_,datdesc1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_datdesc_opt(fn _ => let 
val datdesc as datdesc1=datdesc1 ()
 in ( SOME datdesc ) end
)
 in (LrTable.NT 136,(result,AND1left,datdesc1right),rest671) end
| (393,rest671) => let val result=MlyValue.AND_datdesc_opt(fn _ => (
 NONE ))
 in (LrTable.NT 136,(result,defaultPos,defaultPos),rest671) end
| (394,(_,(MlyValue.BAR_condesc_opt BAR_condesc_opt1,_,
BAR_condesc_optright as BAR_condesc_opt1right))::(_,(
MlyValue.OF_ty_opt OF_ty_opt1,_,_))::(_,(MlyValue.vid vid1,_,_))::(_,(
MlyValue.OP_opt OP_opt1,OP_optleft as OP_opt1left,_))::rest671) => 
let val result=MlyValue.condesc(fn _ => let val OP_opt as OP_opt1=
OP_opt1 ()
val vid as vid1=vid1 ()
val OF_ty_opt as OF_ty_opt1=OF_ty_opt1 ()
val BAR_condesc_opt as BAR_condesc_opt1=BAR_condesc_opt1 ()
 in (
 ConDesc(I(OP_optleft,BAR_condesc_optright),
				  OP_opt, vid, OF_ty_opt, BAR_condesc_opt) 
) end
)
 in (LrTable.NT 137,(result,OP_opt1left,BAR_condesc_opt1right),rest671
) end
| (395,(_,(MlyValue.condesc condesc1,_,condesc1right))::(_,(_,BAR1left
,_))::rest671) => let val result=MlyValue.BAR_condesc_opt(fn _ => let 
val condesc as condesc1=condesc1 ()
 in ( SOME condesc ) end
)
 in (LrTable.NT 138,(result,BAR1left,condesc1right),rest671) end
| (396,rest671) => let val result=MlyValue.BAR_condesc_opt(fn _ => (
 NONE ))
 in (LrTable.NT 138,(result,defaultPos,defaultPos),rest671) end
| (397,(_,(MlyValue.AND_dcondesc_opt AND_dcondesc_opt1,_,
AND_dcondesc_optright as AND_dcondesc_opt1right))::(_,(
MlyValue.longtycon longtycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1,_
,_))::_::(_,(MlyValue.OF_ty_opt OF_ty_opt1,_,_))::(_,(MlyValue.vid 
vid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,OP_optleft as OP_opt1left,_))
::rest671) => let val result=MlyValue.dcondesc(fn _ => let val OP_opt
 as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val OF_ty_opt as OF_ty_opt1=OF_ty_opt1 ()
val tyvarseq as tyvarseq1=tyvarseq1 ()
val longtycon as longtycon1=longtycon1 ()
val AND_dcondesc_opt as AND_dcondesc_opt1=AND_dcondesc_opt1 ()
 in (
 NEWDconDesc(I(OP_optleft,AND_dcondesc_optright),
				      OP_opt, vid, OF_ty_opt,
				      tyvarseq, longtycon, AND_dcondesc_opt) 
) end
)
 in (LrTable.NT 139,(result,OP_opt1left,AND_dcondesc_opt1right),
rest671) end
| (398,(_,(MlyValue.AND_dcondesc_opt AND_dcondesc_opt1,_,
AND_dcondesc_optright as AND_dcondesc_opt1right))::(_,(
MlyValue.longvid longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_
::(_,(MlyValue.vid vid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,OP_opt1left
,_))::rest671) => let val result=MlyValue.dcondesc(fn _ => let val 
OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val OP_opt2=OP_opt2 ()
val longvid as longvid1=longvid1 ()
val AND_dcondesc_opt as AND_dcondesc_opt1=AND_dcondesc_opt1 ()
 in (
 EQUALDconDesc(I(OP_opt1left,AND_dcondesc_optright),
					OP_opt1, vid,
					OP_opt2, longvid, AND_dcondesc_opt) 
) end
)
 in (LrTable.NT 139,(result,OP_opt1left,AND_dcondesc_opt1right),
rest671) end
| (399,(_,(MlyValue.dcondesc dcondesc1,_,dcondesc1right))::(_,(_,
AND1left,_))::rest671) => let val result=MlyValue.AND_dcondesc_opt(fn 
_ => let val dcondesc as dcondesc1=dcondesc1 ()
 in ( SOME dcondesc ) end
)
 in (LrTable.NT 140,(result,AND1left,dcondesc1right),rest671) end
| (400,rest671) => let val result=MlyValue.AND_dcondesc_opt(fn _ => (
 NONE ))
 in (LrTable.NT 140,(result,defaultPos,defaultPos),rest671) end
| (401,(_,(MlyValue.AND_exdesc_opt AND_exdesc_opt1,_,
AND_exdesc_optright as AND_exdesc_opt1right))::(_,(MlyValue.OF_ty_opt 
OF_ty_opt1,_,_))::(_,(MlyValue.vid vid1,_,_))::(_,(MlyValue.OP_opt 
OP_opt1,OP_optleft as OP_opt1left,_))::rest671) => let val result=
MlyValue.exdesc(fn _ => let val OP_opt as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val OF_ty_opt as OF_ty_opt1=OF_ty_opt1 ()
val AND_exdesc_opt as AND_exdesc_opt1=AND_exdesc_opt1 ()
 in (
 NEWExDesc(I(OP_optleft,AND_exdesc_optright),
	  			    OP_opt, vid, OF_ty_opt, AND_exdesc_opt) 
) end
)
 in (LrTable.NT 141,(result,OP_opt1left,AND_exdesc_opt1right),rest671)
 end
| (402,(_,(MlyValue.AND_exdesc_opt AND_exdesc_opt1,_,
AND_exdesc_optright as AND_exdesc_opt1right))::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.vid
 vid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,OP_opt1left,_))::rest671) => 
let val result=MlyValue.exdesc(fn _ => let val OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val OP_opt2=OP_opt2 ()
val longvid as longvid1=longvid1 ()
val AND_exdesc_opt as AND_exdesc_opt1=AND_exdesc_opt1 ()
 in (
 EQUALExDesc(I(OP_opt1left,AND_exdesc_optright),
				      OP_opt1, vid,
				      OP_opt2, longvid, AND_exdesc_opt) 
) end
)
 in (LrTable.NT 141,(result,OP_opt1left,AND_exdesc_opt1right),rest671)
 end
| (403,(_,(MlyValue.exdesc exdesc1,_,exdesc1right))::(_,(_,AND1left,_)
)::rest671) => let val result=MlyValue.AND_exdesc_opt(fn _ => let val 
exdesc as exdesc1=exdesc1 ()
 in ( SOME exdesc ) end
)
 in (LrTable.NT 142,(result,AND1left,exdesc1right),rest671) end
| (404,rest671) => let val result=MlyValue.AND_exdesc_opt(fn _ => (
 NONE ))
 in (LrTable.NT 142,(result,defaultPos,defaultPos),rest671) end
| (405,(_,(MlyValue.sigexp__AND_strdesc_opt sigexp__AND_strdesc_opt1,_
,sigexp__AND_strdesc_optright as sigexp__AND_strdesc_opt1right))::_::(
_,(MlyValue.strid strid1,stridleft as strid1left,_))::rest671) => let 
val result=MlyValue.strdesc(fn _ => let val strid as strid1=strid1 ()
val sigexp__AND_strdesc_opt as sigexp__AND_strdesc_opt1=
sigexp__AND_strdesc_opt1 ()
 in (
 NEWStrDesc(I(stridleft,sigexp__AND_strdesc_optright),
				     strid, #1 sigexp__AND_strdesc_opt,
				     #2 sigexp__AND_strdesc_opt) 
) end
)
 in (LrTable.NT 143,(result,strid1left,sigexp__AND_strdesc_opt1right),
rest671) end
| (406,(_,(MlyValue.AND_strdesc_opt AND_strdesc_opt1,_,
AND_strdesc_optright as AND_strdesc_opt1right))::(_,(
MlyValue.longstrid longstrid1,_,_))::_::(_,(MlyValue.COLON_sigexp_opt 
COLON_sigexp_opt1,_,_))::(_,(MlyValue.strid strid1,stridleft as 
strid1left,_))::rest671) => let val result=MlyValue.strdesc(fn _ => 
let val strid as strid1=strid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid as longstrid1=longstrid1 ()
val AND_strdesc_opt as AND_strdesc_opt1=AND_strdesc_opt1 ()
 in (
 EQUALStrDesc(I(stridleft,AND_strdesc_optright),
				       strid, COLON_sigexp_opt, longstrid,
				       AND_strdesc_opt) 
) end
)
 in (LrTable.NT 143,(result,strid1left,AND_strdesc_opt1right),rest671)
 end
| (407,(_,(MlyValue.strdesc strdesc1,_,strdesc1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_strdesc_opt(fn _ => let 
val strdesc as strdesc1=strdesc1 ()
 in ( SOME strdesc ) end
)
 in (LrTable.NT 144,(result,AND1left,strdesc1right),rest671) end
| (408,rest671) => let val result=MlyValue.AND_strdesc_opt(fn _ => (
 NONE ))
 in (LrTable.NT 144,(result,defaultPos,defaultPos),rest671) end
| (409,(_,(MlyValue.AND_strdesc_opt AND_strdesc_opt1,_,
AND_strdesc_opt1right))::(_,(MlyValue.sigexp' sigexp'1,sigexp'1left,_)
)::rest671) => let val result=MlyValue.sigexp__AND_strdesc_opt(fn _
 => let val sigexp' as sigexp'1=sigexp'1 ()
val AND_strdesc_opt as AND_strdesc_opt1=AND_strdesc_opt1 ()
 in ( ( sigexp', AND_strdesc_opt ) ) end
)
 in (LrTable.NT 145,(result,sigexp'1left,AND_strdesc_opt1right),
rest671) end
| (410,(_,(MlyValue.sigexp__AND_strdesc_opt sigexp__AND_strdesc_opt1,_
,sigexp__AND_strdesc_optright as sigexp__AND_strdesc_opt1right))::_::(
_,(MlyValue.strpat strpat1,_,_))::(_,(_,FCTleft as FCT1left,_))::
rest671) => let val result=MlyValue.sigexp__AND_strdesc_opt(fn _ => 
let val strpat as strpat1=strpat1 ()
val sigexp__AND_strdesc_opt as sigexp__AND_strdesc_opt1=
sigexp__AND_strdesc_opt1 ()
 in (
 ( FCTSigExp(I(FCTleft,sigexp__AND_strdesc_optright),
				      strpat, #1 sigexp__AND_strdesc_opt)
			  , #2 sigexp__AND_strdesc_opt ) 
) end
)
 in (LrTable.NT 145,(result,FCT1left,sigexp__AND_strdesc_opt1right),
rest671) end
| (411,(_,(MlyValue.rea__AND_strdesc_opt rea__AND_strdesc_opt1,_,
rea__AND_strdesc_optright as rea__AND_strdesc_opt1right))::_::(_,(
MlyValue.sigexp sigexp1,sigexpleft as sigexp1left,_))::rest671) => 
let val result=MlyValue.sigexp__AND_strdesc_opt(fn _ => let val sigexp
 as sigexp1=sigexp1 ()
val rea__AND_strdesc_opt as rea__AND_strdesc_opt1=
rea__AND_strdesc_opt1 ()
 in (
 ( WHEREREASigExp(I(sigexpleft,
					     rea__AND_strdesc_optright),
					   sigexp, #1 rea__AND_strdesc_opt)
			  , #2 rea__AND_strdesc_opt ) 
) end
)
 in (LrTable.NT 145,(result,sigexp1left,rea__AND_strdesc_opt1right),
rest671) end
| (412,(_,(MlyValue.AND_rea_opt__AND_strdesc_opt 
AND_rea_opt__AND_strdesc_opt1,_,AND_rea_opt__AND_strdesc_optright as 
AND_rea_opt__AND_strdesc_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,VALleft as 
VAL1left,_))::rest671) => let val result=MlyValue.rea__AND_strdesc_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_strdesc_opt as AND_rea_opt__AND_strdesc_opt1=
AND_rea_opt__AND_strdesc_opt1 ()
 in (
 ( VALRea(I(VALleft,AND_rea_opt__AND_strdesc_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_strdesc_opt)
			  , #2 AND_rea_opt__AND_strdesc_opt ) 
) end
)
 in (LrTable.NT 146,(result,VAL1left,
AND_rea_opt__AND_strdesc_opt1right),rest671) end
| (413,(_,(MlyValue.AND_rea_opt__AND_strdesc_opt 
AND_rea_opt__AND_strdesc_opt1,_,AND_rea_opt__AND_strdesc_optright as 
AND_rea_opt__AND_strdesc_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,FUNleft as 
FUN1left,_))::rest671) => let val result=MlyValue.rea__AND_strdesc_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_strdesc_opt as AND_rea_opt__AND_strdesc_opt1=
AND_rea_opt__AND_strdesc_opt1 ()
 in (
 ( FUNRea(I(FUNleft,AND_rea_opt__AND_strdesc_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_strdesc_opt)
			  , #2 AND_rea_opt__AND_strdesc_opt ) 
) end
)
 in (LrTable.NT 146,(result,FUN1left,
AND_rea_opt__AND_strdesc_opt1right),rest671) end
| (414,(_,(MlyValue.AND_rea_opt__AND_strdesc_opt 
AND_rea_opt__AND_strdesc_opt1,_,AND_rea_opt__AND_strdesc_optright as 
AND_rea_opt__AND_strdesc_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,
CONSTRUCTORleft as CONSTRUCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_strdesc_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_strdesc_opt as AND_rea_opt__AND_strdesc_opt1=
AND_rea_opt__AND_strdesc_opt1 ()
 in (
 ( CONSTRUCTORRea(I(CONSTRUCTORleft,
					     AND_rea_opt__AND_strdesc_optright),
					   OP_opt1, longvid1, OP_opt2, longvid2,
				           #1 AND_rea_opt__AND_strdesc_opt)
			  , #2 AND_rea_opt__AND_strdesc_opt ) 
) end
)
 in (LrTable.NT 146,(result,CONSTRUCTOR1left,
AND_rea_opt__AND_strdesc_opt1right),rest671) end
| (415,(_,(MlyValue.AND_rea_opt__AND_strdesc_opt 
AND_rea_opt__AND_strdesc_opt1,_,AND_rea_opt__AND_strdesc_optright as 
AND_rea_opt__AND_strdesc_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,EXCEPTIONleft
 as EXCEPTION1left,_))::rest671) => let val result=
MlyValue.rea__AND_strdesc_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_strdesc_opt as AND_rea_opt__AND_strdesc_opt1=
AND_rea_opt__AND_strdesc_opt1 ()
 in (
 ( EXCEPTIONRea(I(EXCEPTIONleft,
					   AND_rea_opt__AND_strdesc_optright),
					 OP_opt1, longvid1, OP_opt2, longvid2,
					 #1 AND_rea_opt__AND_strdesc_opt)
			  , #2 AND_rea_opt__AND_strdesc_opt ) 
) end
)
 in (LrTable.NT 146,(result,EXCEPTION1left,
AND_rea_opt__AND_strdesc_opt1right),rest671) end
| (416,(_,(MlyValue.AND_rea_opt__AND_strdesc_opt 
AND_rea_opt__AND_strdesc_opt1,_,AND_rea_opt__AND_strdesc_optright as 
AND_rea_opt__AND_strdesc_opt1right))::(_,(MlyValue.ty ty1,_,_))::_::(_
,(MlyValue.longtycon longtycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1
,_,_))::(_,(_,TYPEleft as TYPE1left,_))::rest671) => let val result=
MlyValue.rea__AND_strdesc_opt(fn _ => let val tyvarseq as tyvarseq1=
tyvarseq1 ()
val longtycon as longtycon1=longtycon1 ()
val ty as ty1=ty1 ()
val AND_rea_opt__AND_strdesc_opt as AND_rea_opt__AND_strdesc_opt1=
AND_rea_opt__AND_strdesc_opt1 ()
 in (
 ( TYPERea(I(TYPEleft,
				      AND_rea_opt__AND_strdesc_optright),
				    tyvarseq, longtycon, ty,
				    #1 AND_rea_opt__AND_strdesc_opt)
			  , #2 AND_rea_opt__AND_strdesc_opt ) 
) end
)
 in (LrTable.NT 146,(result,TYPE1left,
AND_rea_opt__AND_strdesc_opt1right),rest671) end
| (417,(_,(MlyValue.AND_rea_opt__AND_strdesc_opt 
AND_rea_opt__AND_strdesc_opt1,_,AND_rea_opt__AND_strdesc_optright as 
AND_rea_opt__AND_strdesc_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,STRUCTUREleft as 
STRUCTURE1left,_))::rest671) => let val result=
MlyValue.rea__AND_strdesc_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_strdesc_opt as AND_rea_opt__AND_strdesc_opt1=
AND_rea_opt__AND_strdesc_opt1 ()
 in (
 ( STRUCTURERea(I(STRUCTUREleft,
					   AND_rea_opt__AND_strdesc_optright),
				         longstrid1, COLON_sigexp_opt,
					 longstrid2,
				         #1 AND_rea_opt__AND_strdesc_opt)
			  , #2 AND_rea_opt__AND_strdesc_opt ) 
) end
)
 in (LrTable.NT 146,(result,STRUCTURE1left,
AND_rea_opt__AND_strdesc_opt1right),rest671) end
| (418,(_,(MlyValue.AND_rea_opt__AND_strdesc_opt 
AND_rea_opt__AND_strdesc_opt1,_,AND_rea_opt__AND_strdesc_optright as 
AND_rea_opt__AND_strdesc_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,FUNCTORleft as 
FUNCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_strdesc_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_strdesc_opt as AND_rea_opt__AND_strdesc_opt1=
AND_rea_opt__AND_strdesc_opt1 ()
 in (
 ( FUNCTORRea(I(FUNCTORleft,
					 AND_rea_opt__AND_strdesc_optright),
				       longstrid1, COLON_sigexp_opt, longstrid2,
				       #1 AND_rea_opt__AND_strdesc_opt)
			  , #2 AND_rea_opt__AND_strdesc_opt ) 
) end
)
 in (LrTable.NT 146,(result,FUNCTOR1left,
AND_rea_opt__AND_strdesc_opt1right),rest671) end
| (419,(_,(MlyValue.sigexp__AND_rea_opt__AND_strdesc_opt 
sigexp__AND_rea_opt__AND_strdesc_opt1,_,
sigexp__AND_rea_opt__AND_strdesc_optright as 
sigexp__AND_rea_opt__AND_strdesc_opt1right))::_::(_,(
MlyValue.strpat_list0 strpat_list01,_,_))::(_,(MlyValue.longsigid 
longsigid1,_,_))::(_,(_,SIGNATUREleft as SIGNATURE1left,_))::rest671)
 => let val result=MlyValue.rea__AND_strdesc_opt(fn _ => let val 
longsigid as longsigid1=longsigid1 ()
val strpat_list0 as strpat_list01=strpat_list01 ()
val sigexp__AND_rea_opt__AND_strdesc_opt as 
sigexp__AND_rea_opt__AND_strdesc_opt1=
sigexp__AND_rea_opt__AND_strdesc_opt1 ()
 in (
 ( SIGNATURERea
				(I(SIGNATUREleft,
				   sigexp__AND_rea_opt__AND_strdesc_optright),
				 longsigid, strpat_list0,
				 #1 sigexp__AND_rea_opt__AND_strdesc_opt,
				 #2 sigexp__AND_rea_opt__AND_strdesc_opt)
			  , #3 sigexp__AND_rea_opt__AND_strdesc_opt ) 
) end
)
 in (LrTable.NT 146,(result,SIGNATURE1left,
sigexp__AND_rea_opt__AND_strdesc_opt1right),rest671) end
| (420,(_,(MlyValue.AND_strdesc_opt AND_strdesc_opt1,
AND_strdesc_opt1left,AND_strdesc_opt1right))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_strdesc_opt(fn _ => let val 
AND_strdesc_opt as AND_strdesc_opt1=AND_strdesc_opt1 ()
 in ( ( NONE, AND_strdesc_opt ) ) end
)
 in (LrTable.NT 147,(result,AND_strdesc_opt1left,AND_strdesc_opt1right
),rest671) end
| (421,(_,(MlyValue.rea__AND_strdesc_opt rea__AND_strdesc_opt1,_,
rea__AND_strdesc_opt1right))::(_,(_,AND1left,_))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_strdesc_opt(fn _ => let val 
rea__AND_strdesc_opt as rea__AND_strdesc_opt1=rea__AND_strdesc_opt1 ()
 in (
 ( SOME(#1 rea__AND_strdesc_opt)
				  , #2 rea__AND_strdesc_opt ) )
 end
)
 in (LrTable.NT 147,(result,AND1left,rea__AND_strdesc_opt1right),
rest671) end
| (422,(_,(MlyValue.AND_rea_opt__AND_strdesc_opt 
AND_rea_opt__AND_strdesc_opt1,_,AND_rea_opt__AND_strdesc_opt1right))::
(_,(MlyValue.appsigexp appsigexp1,appsigexp1left,_))::rest671) => let 
val result=MlyValue.sigexp__AND_rea_opt__AND_strdesc_opt(fn _ => let 
val appsigexp as appsigexp1=appsigexp1 ()
val AND_rea_opt__AND_strdesc_opt as AND_rea_opt__AND_strdesc_opt1=
AND_rea_opt__AND_strdesc_opt1 ()
 in (
 ( appsigexp
		          , #1 AND_rea_opt__AND_strdesc_opt
			  , #2 AND_rea_opt__AND_strdesc_opt ) 
) end
)
 in (LrTable.NT 148,(result,appsigexp1left,
AND_rea_opt__AND_strdesc_opt1right),rest671) end
| (423,(_,(MlyValue.AND_sigdesc_opt AND_sigdesc_opt1,_,
AND_sigdesc_optright as AND_sigdesc_opt1right))::(_,(
MlyValue.strpat_list0 strpat_list01,_,_))::(_,(MlyValue.sigid sigid1,
sigidleft as sigid1left,_))::rest671) => let val result=
MlyValue.sigdesc(fn _ => let val sigid as sigid1=sigid1 ()
val strpat_list0 as strpat_list01=strpat_list01 ()
val AND_sigdesc_opt as AND_sigdesc_opt1=AND_sigdesc_opt1 ()
 in (
 NEWSigDesc(I(sigidleft,AND_sigdesc_optright),
				     sigid, strpat_list0, AND_sigdesc_opt) 
) end
)
 in (LrTable.NT 149,(result,sigid1left,AND_sigdesc_opt1right),rest671)
 end
| (424,(_,(MlyValue.sigexp__AND_sigdesc_opt sigexp__AND_sigdesc_opt1,_
,sigexp__AND_sigdesc_optright as sigexp__AND_sigdesc_opt1right))::_::(
_,(MlyValue.strpat_list0 strpat_list01,_,_))::(_,(MlyValue.sigid 
sigid1,sigidleft as sigid1left,_))::rest671) => let val result=
MlyValue.sigdesc(fn _ => let val sigid as sigid1=sigid1 ()
val strpat_list0 as strpat_list01=strpat_list01 ()
val sigexp__AND_sigdesc_opt as sigexp__AND_sigdesc_opt1=
sigexp__AND_sigdesc_opt1 ()
 in (
 EQUALSigDesc(I(sigidleft,
					 sigexp__AND_sigdesc_optright),
				       sigid, strpat_list0,
				       #1 sigexp__AND_sigdesc_opt,
				       #2 sigexp__AND_sigdesc_opt) 
) end
)
 in (LrTable.NT 149,(result,sigid1left,sigexp__AND_sigdesc_opt1right),
rest671) end
| (425,(_,(MlyValue.sigdesc sigdesc1,_,sigdesc1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_sigdesc_opt(fn _ => let 
val sigdesc as sigdesc1=sigdesc1 ()
 in ( SOME sigdesc ) end
)
 in (LrTable.NT 150,(result,AND1left,sigdesc1right),rest671) end
| (426,rest671) => let val result=MlyValue.AND_sigdesc_opt(fn _ => (
 NONE ))
 in (LrTable.NT 150,(result,defaultPos,defaultPos),rest671) end
| (427,(_,(MlyValue.AND_sigdesc_opt AND_sigdesc_opt1,_,
AND_sigdesc_opt1right))::(_,(MlyValue.sigexp' sigexp'1,sigexp'1left,_)
)::rest671) => let val result=MlyValue.sigexp__AND_sigdesc_opt(fn _
 => let val sigexp' as sigexp'1=sigexp'1 ()
val AND_sigdesc_opt as AND_sigdesc_opt1=AND_sigdesc_opt1 ()
 in ( ( sigexp', AND_sigdesc_opt ) ) end
)
 in (LrTable.NT 151,(result,sigexp'1left,AND_sigdesc_opt1right),
rest671) end
| (428,(_,(MlyValue.sigexp__AND_sigdesc_opt sigexp__AND_sigdesc_opt1,_
,sigexp__AND_sigdesc_optright as sigexp__AND_sigdesc_opt1right))::_::(
_,(MlyValue.strpat strpat1,_,_))::(_,(_,FCTleft as FCT1left,_))::
rest671) => let val result=MlyValue.sigexp__AND_sigdesc_opt(fn _ => 
let val strpat as strpat1=strpat1 ()
val sigexp__AND_sigdesc_opt as sigexp__AND_sigdesc_opt1=
sigexp__AND_sigdesc_opt1 ()
 in (
 ( FCTSigExp(I(FCTleft,sigexp__AND_sigdesc_optright),
				      strpat, #1 sigexp__AND_sigdesc_opt)
			  , #2 sigexp__AND_sigdesc_opt ) 
) end
)
 in (LrTable.NT 151,(result,FCT1left,sigexp__AND_sigdesc_opt1right),
rest671) end
| (429,(_,(MlyValue.rea__AND_sigdesc_opt rea__AND_sigdesc_opt1,_,
rea__AND_sigdesc_optright as rea__AND_sigdesc_opt1right))::_::(_,(
MlyValue.sigexp sigexp1,sigexpleft as sigexp1left,_))::rest671) => 
let val result=MlyValue.sigexp__AND_sigdesc_opt(fn _ => let val sigexp
 as sigexp1=sigexp1 ()
val rea__AND_sigdesc_opt as rea__AND_sigdesc_opt1=
rea__AND_sigdesc_opt1 ()
 in (
 ( WHEREREASigExp(I(sigexpleft,
					     rea__AND_sigdesc_optright),
					   sigexp, #1 rea__AND_sigdesc_opt)
			  , #2 rea__AND_sigdesc_opt ) 
) end
)
 in (LrTable.NT 151,(result,sigexp1left,rea__AND_sigdesc_opt1right),
rest671) end
| (430,(_,(MlyValue.AND_rea_opt__AND_sigdesc_opt 
AND_rea_opt__AND_sigdesc_opt1,_,AND_rea_opt__AND_sigdesc_optright as 
AND_rea_opt__AND_sigdesc_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,VALleft as 
VAL1left,_))::rest671) => let val result=MlyValue.rea__AND_sigdesc_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_sigdesc_opt as AND_rea_opt__AND_sigdesc_opt1=
AND_rea_opt__AND_sigdesc_opt1 ()
 in (
 ( VALRea(I(VALleft,AND_rea_opt__AND_sigdesc_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_sigdesc_opt)
			  , #2 AND_rea_opt__AND_sigdesc_opt ) 
) end
)
 in (LrTable.NT 152,(result,VAL1left,
AND_rea_opt__AND_sigdesc_opt1right),rest671) end
| (431,(_,(MlyValue.AND_rea_opt__AND_sigdesc_opt 
AND_rea_opt__AND_sigdesc_opt1,_,AND_rea_opt__AND_sigdesc_optright as 
AND_rea_opt__AND_sigdesc_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,FUNleft as 
FUN1left,_))::rest671) => let val result=MlyValue.rea__AND_sigdesc_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_sigdesc_opt as AND_rea_opt__AND_sigdesc_opt1=
AND_rea_opt__AND_sigdesc_opt1 ()
 in (
 ( FUNRea(I(FUNleft,AND_rea_opt__AND_sigdesc_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_sigdesc_opt)
			  , #2 AND_rea_opt__AND_sigdesc_opt ) 
) end
)
 in (LrTable.NT 152,(result,FUN1left,
AND_rea_opt__AND_sigdesc_opt1right),rest671) end
| (432,(_,(MlyValue.AND_rea_opt__AND_sigdesc_opt 
AND_rea_opt__AND_sigdesc_opt1,_,AND_rea_opt__AND_sigdesc_optright as 
AND_rea_opt__AND_sigdesc_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,
CONSTRUCTORleft as CONSTRUCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_sigdesc_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_sigdesc_opt as AND_rea_opt__AND_sigdesc_opt1=
AND_rea_opt__AND_sigdesc_opt1 ()
 in (
 ( CONSTRUCTORRea(I(CONSTRUCTORleft,
					     AND_rea_opt__AND_sigdesc_optright),
					   OP_opt1, longvid1, OP_opt2, longvid2,
				           #1 AND_rea_opt__AND_sigdesc_opt)
			  , #2 AND_rea_opt__AND_sigdesc_opt ) 
) end
)
 in (LrTable.NT 152,(result,CONSTRUCTOR1left,
AND_rea_opt__AND_sigdesc_opt1right),rest671) end
| (433,(_,(MlyValue.AND_rea_opt__AND_sigdesc_opt 
AND_rea_opt__AND_sigdesc_opt1,_,AND_rea_opt__AND_sigdesc_optright as 
AND_rea_opt__AND_sigdesc_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,EXCEPTIONleft
 as EXCEPTION1left,_))::rest671) => let val result=
MlyValue.rea__AND_sigdesc_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_sigdesc_opt as AND_rea_opt__AND_sigdesc_opt1=
AND_rea_opt__AND_sigdesc_opt1 ()
 in (
 ( EXCEPTIONRea(I(EXCEPTIONleft,
					   AND_rea_opt__AND_sigdesc_optright),
					 OP_opt1, longvid1, OP_opt2, longvid2,
					 #1 AND_rea_opt__AND_sigdesc_opt)
			  , #2 AND_rea_opt__AND_sigdesc_opt ) 
) end
)
 in (LrTable.NT 152,(result,EXCEPTION1left,
AND_rea_opt__AND_sigdesc_opt1right),rest671) end
| (434,(_,(MlyValue.AND_rea_opt__AND_sigdesc_opt 
AND_rea_opt__AND_sigdesc_opt1,_,AND_rea_opt__AND_sigdesc_optright as 
AND_rea_opt__AND_sigdesc_opt1right))::(_,(MlyValue.ty ty1,_,_))::_::(_
,(MlyValue.longtycon longtycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1
,_,_))::(_,(_,TYPEleft as TYPE1left,_))::rest671) => let val result=
MlyValue.rea__AND_sigdesc_opt(fn _ => let val tyvarseq as tyvarseq1=
tyvarseq1 ()
val longtycon as longtycon1=longtycon1 ()
val ty as ty1=ty1 ()
val AND_rea_opt__AND_sigdesc_opt as AND_rea_opt__AND_sigdesc_opt1=
AND_rea_opt__AND_sigdesc_opt1 ()
 in (
 ( TYPERea(I(TYPEleft,
				      AND_rea_opt__AND_sigdesc_optright),
				    tyvarseq, longtycon, ty,
				    #1 AND_rea_opt__AND_sigdesc_opt)
			  , #2 AND_rea_opt__AND_sigdesc_opt ) 
) end
)
 in (LrTable.NT 152,(result,TYPE1left,
AND_rea_opt__AND_sigdesc_opt1right),rest671) end
| (435,(_,(MlyValue.AND_rea_opt__AND_sigdesc_opt 
AND_rea_opt__AND_sigdesc_opt1,_,AND_rea_opt__AND_sigdesc_optright as 
AND_rea_opt__AND_sigdesc_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,STRUCTUREleft as 
STRUCTURE1left,_))::rest671) => let val result=
MlyValue.rea__AND_sigdesc_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_sigdesc_opt as AND_rea_opt__AND_sigdesc_opt1=
AND_rea_opt__AND_sigdesc_opt1 ()
 in (
 ( STRUCTURERea(I(STRUCTUREleft,
					   AND_rea_opt__AND_sigdesc_optright),
				         longstrid1, COLON_sigexp_opt,
					 longstrid2,
				         #1 AND_rea_opt__AND_sigdesc_opt)
			  , #2 AND_rea_opt__AND_sigdesc_opt ) 
) end
)
 in (LrTable.NT 152,(result,STRUCTURE1left,
AND_rea_opt__AND_sigdesc_opt1right),rest671) end
| (436,(_,(MlyValue.AND_rea_opt__AND_sigdesc_opt 
AND_rea_opt__AND_sigdesc_opt1,_,AND_rea_opt__AND_sigdesc_optright as 
AND_rea_opt__AND_sigdesc_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,FUNCTORleft as 
FUNCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_sigdesc_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_sigdesc_opt as AND_rea_opt__AND_sigdesc_opt1=
AND_rea_opt__AND_sigdesc_opt1 ()
 in (
 ( FUNCTORRea(I(FUNCTORleft,
					 AND_rea_opt__AND_sigdesc_optright),
				       longstrid1, COLON_sigexp_opt, longstrid2,
				       #1 AND_rea_opt__AND_sigdesc_opt)
			  , #2 AND_rea_opt__AND_sigdesc_opt ) 
) end
)
 in (LrTable.NT 152,(result,FUNCTOR1left,
AND_rea_opt__AND_sigdesc_opt1right),rest671) end
| (437,(_,(MlyValue.sigexp__AND_rea_opt__AND_sigdesc_opt 
sigexp__AND_rea_opt__AND_sigdesc_opt1,_,
sigexp__AND_rea_opt__AND_sigdesc_optright as 
sigexp__AND_rea_opt__AND_sigdesc_opt1right))::_::(_,(
MlyValue.strpat_list0 strpat_list01,_,_))::(_,(MlyValue.longsigid 
longsigid1,_,_))::(_,(_,SIGNATUREleft as SIGNATURE1left,_))::rest671)
 => let val result=MlyValue.rea__AND_sigdesc_opt(fn _ => let val 
longsigid as longsigid1=longsigid1 ()
val strpat_list0 as strpat_list01=strpat_list01 ()
val sigexp__AND_rea_opt__AND_sigdesc_opt as 
sigexp__AND_rea_opt__AND_sigdesc_opt1=
sigexp__AND_rea_opt__AND_sigdesc_opt1 ()
 in (
 ( SIGNATURERea
				(I(SIGNATUREleft,
				   sigexp__AND_rea_opt__AND_sigdesc_optright),
				 longsigid, strpat_list0,
				 #1 sigexp__AND_rea_opt__AND_sigdesc_opt,
				 #2 sigexp__AND_rea_opt__AND_sigdesc_opt)
			  , #3 sigexp__AND_rea_opt__AND_sigdesc_opt ) 
) end
)
 in (LrTable.NT 152,(result,SIGNATURE1left,
sigexp__AND_rea_opt__AND_sigdesc_opt1right),rest671) end
| (438,(_,(MlyValue.AND_sigdesc_opt AND_sigdesc_opt1,
AND_sigdesc_opt1left,AND_sigdesc_opt1right))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_sigdesc_opt(fn _ => let val 
AND_sigdesc_opt as AND_sigdesc_opt1=AND_sigdesc_opt1 ()
 in ( ( NONE, AND_sigdesc_opt) ) end
)
 in (LrTable.NT 153,(result,AND_sigdesc_opt1left,AND_sigdesc_opt1right
),rest671) end
| (439,(_,(MlyValue.rea__AND_sigdesc_opt rea__AND_sigdesc_opt1,_,
rea__AND_sigdesc_opt1right))::(_,(_,AND1left,_))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_sigdesc_opt(fn _ => let val 
rea__AND_sigdesc_opt as rea__AND_sigdesc_opt1=rea__AND_sigdesc_opt1 ()
 in (
 ( SOME(#1 rea__AND_sigdesc_opt)
				  , #2 rea__AND_sigdesc_opt ) )
 end
)
 in (LrTable.NT 153,(result,AND1left,rea__AND_sigdesc_opt1right),
rest671) end
| (440,(_,(MlyValue.AND_rea_opt__AND_sigdesc_opt 
AND_rea_opt__AND_sigdesc_opt1,_,AND_rea_opt__AND_sigdesc_opt1right))::
(_,(MlyValue.appsigexp appsigexp1,appsigexp1left,_))::rest671) => let 
val result=MlyValue.sigexp__AND_rea_opt__AND_sigdesc_opt(fn _ => let 
val appsigexp as appsigexp1=appsigexp1 ()
val AND_rea_opt__AND_sigdesc_opt as AND_rea_opt__AND_sigdesc_opt1=
AND_rea_opt__AND_sigdesc_opt1 ()
 in (
 ( appsigexp
		          , #1 AND_rea_opt__AND_sigdesc_opt
			  , #2 AND_rea_opt__AND_sigdesc_opt ) 
) end
)
 in (LrTable.NT 154,(result,appsigexp1left,
AND_rea_opt__AND_sigdesc_opt1right),rest671) end
| (441,(_,(MlyValue.sigexp__AND_fundesc_opt sigexp__AND_fundesc_opt1,_
,sigexp__AND_fundesc_optright as sigexp__AND_fundesc_opt1right))::_::(
_,(MlyValue.strpat_list0 strpat_list01,_,_))::(_,(MlyValue.strid 
strid1,stridleft as strid1left,_))::rest671) => let val result=
MlyValue.fundesc(fn _ => let val strid as strid1=strid1 ()
val strpat_list0 as strpat_list01=strpat_list01 ()
val sigexp__AND_fundesc_opt as sigexp__AND_fundesc_opt1=
sigexp__AND_fundesc_opt1 ()
 in (
 FunDesc(I(stridleft,sigexp__AND_fundesc_optright),
				  strid, strpat_list0,
				  #1 sigexp__AND_fundesc_opt,
				  #2 sigexp__AND_fundesc_opt) 
) end
)
 in (LrTable.NT 155,(result,strid1left,sigexp__AND_fundesc_opt1right),
rest671) end
| (442,(_,(MlyValue.fundesc fundesc1,_,fundesc1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_fundesc_opt(fn _ => let 
val fundesc as fundesc1=fundesc1 ()
 in ( SOME fundesc ) end
)
 in (LrTable.NT 156,(result,AND1left,fundesc1right),rest671) end
| (443,rest671) => let val result=MlyValue.AND_fundesc_opt(fn _ => (
 NONE ))
 in (LrTable.NT 156,(result,defaultPos,defaultPos),rest671) end
| (444,(_,(MlyValue.AND_fundesc_opt AND_fundesc_opt1,_,
AND_fundesc_opt1right))::(_,(MlyValue.sigexp' sigexp'1,sigexp'1left,_)
)::rest671) => let val result=MlyValue.sigexp__AND_fundesc_opt(fn _
 => let val sigexp' as sigexp'1=sigexp'1 ()
val AND_fundesc_opt as AND_fundesc_opt1=AND_fundesc_opt1 ()
 in ( ( sigexp', AND_fundesc_opt ) ) end
)
 in (LrTable.NT 157,(result,sigexp'1left,AND_fundesc_opt1right),
rest671) end
| (445,(_,(MlyValue.sigexp__AND_fundesc_opt sigexp__AND_fundesc_opt1,_
,sigexp__AND_fundesc_optright as sigexp__AND_fundesc_opt1right))::_::(
_,(MlyValue.strpat strpat1,_,_))::(_,(_,FCTleft as FCT1left,_))::
rest671) => let val result=MlyValue.sigexp__AND_fundesc_opt(fn _ => 
let val strpat as strpat1=strpat1 ()
val sigexp__AND_fundesc_opt as sigexp__AND_fundesc_opt1=
sigexp__AND_fundesc_opt1 ()
 in (
 ( FCTSigExp(I(FCTleft,sigexp__AND_fundesc_optright),
				      strpat, #1 sigexp__AND_fundesc_opt)
			  , #2 sigexp__AND_fundesc_opt ) 
) end
)
 in (LrTable.NT 157,(result,FCT1left,sigexp__AND_fundesc_opt1right),
rest671) end
| (446,(_,(MlyValue.rea__AND_fundesc_opt rea__AND_fundesc_opt1,_,
rea__AND_fundesc_optright as rea__AND_fundesc_opt1right))::_::(_,(
MlyValue.sigexp sigexp1,sigexpleft as sigexp1left,_))::rest671) => 
let val result=MlyValue.sigexp__AND_fundesc_opt(fn _ => let val sigexp
 as sigexp1=sigexp1 ()
val rea__AND_fundesc_opt as rea__AND_fundesc_opt1=
rea__AND_fundesc_opt1 ()
 in (
 ( WHEREREASigExp(I(sigexpleft,
					     rea__AND_fundesc_optright),
					   sigexp, #1 rea__AND_fundesc_opt)
			  , #2 rea__AND_fundesc_opt ) 
) end
)
 in (LrTable.NT 157,(result,sigexp1left,rea__AND_fundesc_opt1right),
rest671) end
| (447,(_,(MlyValue.AND_rea_opt__AND_fundesc_opt 
AND_rea_opt__AND_fundesc_opt1,_,AND_rea_opt__AND_fundesc_optright as 
AND_rea_opt__AND_fundesc_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,VALleft as 
VAL1left,_))::rest671) => let val result=MlyValue.rea__AND_fundesc_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_fundesc_opt as AND_rea_opt__AND_fundesc_opt1=
AND_rea_opt__AND_fundesc_opt1 ()
 in (
 ( VALRea(I(VALleft,AND_rea_opt__AND_fundesc_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_fundesc_opt)
			  , #2 AND_rea_opt__AND_fundesc_opt ) 
) end
)
 in (LrTable.NT 158,(result,VAL1left,
AND_rea_opt__AND_fundesc_opt1right),rest671) end
| (448,(_,(MlyValue.AND_rea_opt__AND_fundesc_opt 
AND_rea_opt__AND_fundesc_opt1,_,AND_rea_opt__AND_fundesc_optright as 
AND_rea_opt__AND_fundesc_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,FUNleft as 
FUN1left,_))::rest671) => let val result=MlyValue.rea__AND_fundesc_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_fundesc_opt as AND_rea_opt__AND_fundesc_opt1=
AND_rea_opt__AND_fundesc_opt1 ()
 in (
 ( FUNRea(I(FUNleft,AND_rea_opt__AND_fundesc_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_fundesc_opt)
			  , #2 AND_rea_opt__AND_fundesc_opt ) 
) end
)
 in (LrTable.NT 158,(result,FUN1left,
AND_rea_opt__AND_fundesc_opt1right),rest671) end
| (449,(_,(MlyValue.AND_rea_opt__AND_fundesc_opt 
AND_rea_opt__AND_fundesc_opt1,_,AND_rea_opt__AND_fundesc_optright as 
AND_rea_opt__AND_fundesc_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,
CONSTRUCTORleft as CONSTRUCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_fundesc_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_fundesc_opt as AND_rea_opt__AND_fundesc_opt1=
AND_rea_opt__AND_fundesc_opt1 ()
 in (
 ( CONSTRUCTORRea(I(CONSTRUCTORleft,
					     AND_rea_opt__AND_fundesc_optright),
					   OP_opt1, longvid1, OP_opt2, longvid2,
				           #1 AND_rea_opt__AND_fundesc_opt)
			  , #2 AND_rea_opt__AND_fundesc_opt ) 
) end
)
 in (LrTable.NT 158,(result,CONSTRUCTOR1left,
AND_rea_opt__AND_fundesc_opt1right),rest671) end
| (450,(_,(MlyValue.AND_rea_opt__AND_fundesc_opt 
AND_rea_opt__AND_fundesc_opt1,_,AND_rea_opt__AND_fundesc_optright as 
AND_rea_opt__AND_fundesc_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,EXCEPTIONleft
 as EXCEPTION1left,_))::rest671) => let val result=
MlyValue.rea__AND_fundesc_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_fundesc_opt as AND_rea_opt__AND_fundesc_opt1=
AND_rea_opt__AND_fundesc_opt1 ()
 in (
 ( EXCEPTIONRea(I(EXCEPTIONleft,
					   AND_rea_opt__AND_fundesc_optright),
					 OP_opt1, longvid1, OP_opt2, longvid2,
					 #1 AND_rea_opt__AND_fundesc_opt)
			  , #2 AND_rea_opt__AND_fundesc_opt ) 
) end
)
 in (LrTable.NT 158,(result,EXCEPTION1left,
AND_rea_opt__AND_fundesc_opt1right),rest671) end
| (451,(_,(MlyValue.AND_rea_opt__AND_fundesc_opt 
AND_rea_opt__AND_fundesc_opt1,_,AND_rea_opt__AND_fundesc_optright as 
AND_rea_opt__AND_fundesc_opt1right))::(_,(MlyValue.ty ty1,_,_))::_::(_
,(MlyValue.longtycon longtycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1
,_,_))::(_,(_,TYPEleft as TYPE1left,_))::rest671) => let val result=
MlyValue.rea__AND_fundesc_opt(fn _ => let val tyvarseq as tyvarseq1=
tyvarseq1 ()
val longtycon as longtycon1=longtycon1 ()
val ty as ty1=ty1 ()
val AND_rea_opt__AND_fundesc_opt as AND_rea_opt__AND_fundesc_opt1=
AND_rea_opt__AND_fundesc_opt1 ()
 in (
 ( TYPERea(I(TYPEleft,
				      AND_rea_opt__AND_fundesc_optright),
				    tyvarseq, longtycon, ty,
				    #1 AND_rea_opt__AND_fundesc_opt)
			  , #2 AND_rea_opt__AND_fundesc_opt ) 
) end
)
 in (LrTable.NT 158,(result,TYPE1left,
AND_rea_opt__AND_fundesc_opt1right),rest671) end
| (452,(_,(MlyValue.AND_rea_opt__AND_fundesc_opt 
AND_rea_opt__AND_fundesc_opt1,_,AND_rea_opt__AND_fundesc_optright as 
AND_rea_opt__AND_fundesc_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,STRUCTUREleft as 
STRUCTURE1left,_))::rest671) => let val result=
MlyValue.rea__AND_fundesc_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_fundesc_opt as AND_rea_opt__AND_fundesc_opt1=
AND_rea_opt__AND_fundesc_opt1 ()
 in (
 ( STRUCTURERea(I(STRUCTUREleft,
					   AND_rea_opt__AND_fundesc_optright),
				         longstrid1, COLON_sigexp_opt,
					 longstrid2,
				         #1 AND_rea_opt__AND_fundesc_opt)
			  , #2 AND_rea_opt__AND_fundesc_opt ) 
) end
)
 in (LrTable.NT 158,(result,STRUCTURE1left,
AND_rea_opt__AND_fundesc_opt1right),rest671) end
| (453,(_,(MlyValue.AND_rea_opt__AND_fundesc_opt 
AND_rea_opt__AND_fundesc_opt1,_,AND_rea_opt__AND_fundesc_optright as 
AND_rea_opt__AND_fundesc_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,FUNCTORleft as 
FUNCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_fundesc_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_fundesc_opt as AND_rea_opt__AND_fundesc_opt1=
AND_rea_opt__AND_fundesc_opt1 ()
 in (
 ( FUNCTORRea(I(FUNCTORleft,
					 AND_rea_opt__AND_fundesc_optright),
				       longstrid1, COLON_sigexp_opt, longstrid2,
				       #1 AND_rea_opt__AND_fundesc_opt)
			  , #2 AND_rea_opt__AND_fundesc_opt ) 
) end
)
 in (LrTable.NT 158,(result,FUNCTOR1left,
AND_rea_opt__AND_fundesc_opt1right),rest671) end
| (454,(_,(MlyValue.sigexp__AND_rea_opt__AND_fundesc_opt 
sigexp__AND_rea_opt__AND_fundesc_opt1,_,
sigexp__AND_rea_opt__AND_fundesc_optright as 
sigexp__AND_rea_opt__AND_fundesc_opt1right))::_::(_,(
MlyValue.strpat_list0 strpat_list01,_,_))::(_,(MlyValue.longsigid 
longsigid1,_,_))::(_,(_,SIGNATUREleft as SIGNATURE1left,_))::rest671)
 => let val result=MlyValue.rea__AND_fundesc_opt(fn _ => let val 
longsigid as longsigid1=longsigid1 ()
val strpat_list0 as strpat_list01=strpat_list01 ()
val sigexp__AND_rea_opt__AND_fundesc_opt as 
sigexp__AND_rea_opt__AND_fundesc_opt1=
sigexp__AND_rea_opt__AND_fundesc_opt1 ()
 in (
 ( SIGNATURERea
				(I(SIGNATUREleft,
				   sigexp__AND_rea_opt__AND_fundesc_optright),
				 longsigid, strpat_list0,
				 #1 sigexp__AND_rea_opt__AND_fundesc_opt,
				 #2 sigexp__AND_rea_opt__AND_fundesc_opt)
			  , #3 sigexp__AND_rea_opt__AND_fundesc_opt ) 
) end
)
 in (LrTable.NT 158,(result,SIGNATURE1left,
sigexp__AND_rea_opt__AND_fundesc_opt1right),rest671) end
| (455,(_,(MlyValue.AND_fundesc_opt AND_fundesc_opt1,
AND_fundesc_opt1left,AND_fundesc_opt1right))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_fundesc_opt(fn _ => let val 
AND_fundesc_opt as AND_fundesc_opt1=AND_fundesc_opt1 ()
 in ( ( NONE, AND_fundesc_opt ) ) end
)
 in (LrTable.NT 159,(result,AND_fundesc_opt1left,AND_fundesc_opt1right
),rest671) end
| (456,(_,(MlyValue.rea__AND_fundesc_opt rea__AND_fundesc_opt1,_,
rea__AND_fundesc_opt1right))::(_,(_,AND1left,_))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_fundesc_opt(fn _ => let val 
rea__AND_fundesc_opt as rea__AND_fundesc_opt1=rea__AND_fundesc_opt1 ()
 in (
 ( SOME(#1 rea__AND_fundesc_opt),
			    #2 rea__AND_fundesc_opt ) )
 end
)
 in (LrTable.NT 159,(result,AND1left,rea__AND_fundesc_opt1right),
rest671) end
| (457,(_,(MlyValue.AND_rea_opt__AND_fundesc_opt 
AND_rea_opt__AND_fundesc_opt1,_,AND_rea_opt__AND_fundesc_opt1right))::
(_,(MlyValue.appsigexp appsigexp1,appsigexp1left,_))::rest671) => let 
val result=MlyValue.sigexp__AND_rea_opt__AND_fundesc_opt(fn _ => let 
val appsigexp as appsigexp1=appsigexp1 ()
val AND_rea_opt__AND_fundesc_opt as AND_rea_opt__AND_fundesc_opt1=
AND_rea_opt__AND_fundesc_opt1 ()
 in (
 ( appsigexp
		          , #1 AND_rea_opt__AND_fundesc_opt
			  , #2 AND_rea_opt__AND_fundesc_opt ) 
) end
)
 in (LrTable.NT 160,(result,appsigexp1left,
AND_rea_opt__AND_fundesc_opt1right),rest671) end
| (458,(_,(MlyValue.imp1 imp11,imp11left,imp11right))::rest671) => 
let val result=MlyValue.imp(fn _ => let val imp1 as imp11=imp11 ()
 in ( imp1 ) end
)
 in (LrTable.NT 161,(result,imp11left,imp11right),rest671) end
| (459,rest671) => let val result=MlyValue.imp(fn _ => (
 EMPTYImp(I(defaultPos,defaultPos)) ))
 in (LrTable.NT 161,(result,defaultPos,defaultPos),rest671) end
| (460,(_,(MlyValue.imp1' imp1'1,imp1'1left,imp1'1right))::rest671)
 => let val result=MlyValue.imp1(fn _ => let val imp1' as imp1'1=
imp1'1 ()
 in ( imp1' ) end
)
 in (LrTable.NT 162,(result,imp1'1left,imp1'1right),rest671) end
| (461,(_,(MlyValue.imp1' imp1'1,_,imp1'right as imp1'1right))::(_,(
MlyValue.imp1 imp11,imp1left as imp11left,_))::rest671) => let val 
result=MlyValue.imp1(fn _ => let val imp1 as imp11=imp11 ()
val imp1' as imp1'1=imp1'1 ()
 in ( SEQImp(I(imp1left,imp1'right), imp1, imp1') ) end
)
 in (LrTable.NT 162,(result,imp11left,imp1'1right),rest671) end
| (462,(_,(_,SEMICOLONleft as SEMICOLON1left,SEMICOLON1right))::
rest671) => let val result=MlyValue.imp1(fn _ => (
 EMPTYImp(I(SEMICOLONleft,SEMICOLONleft)) ))
 in (LrTable.NT 162,(result,SEMICOLON1left,SEMICOLON1right),rest671)
 end
| (463,(_,(MlyValue.valitem valitem1,_,valitemright as valitem1right))
::(_,(_,VALleft as VAL1left,_))::rest671) => let val result=
MlyValue.imp1'(fn _ => let val valitem as valitem1=valitem1 ()
 in ( VALImp(I(VALleft,valitemright), valitem) ) end
)
 in (LrTable.NT 163,(result,VAL1left,valitem1right),rest671) end
| (464,(_,(MlyValue.valitem valitem1,_,valitemright as valitem1right))
::(_,(_,FUNleft as FUN1left,_))::rest671) => let val result=
MlyValue.imp1'(fn _ => let val valitem as valitem1=valitem1 ()
 in ( FUNImp(I(FUNleft,valitemright), valitem) ) end
)
 in (LrTable.NT 163,(result,FUN1left,valitem1right),rest671) end
| (465,(_,(MlyValue.typitem typitem1,_,typitemright as typitem1right))
::(_,(_,TYPEleft as TYPE1left,_))::rest671) => let val result=
MlyValue.imp1'(fn _ => let val typitem as typitem1=typitem1 ()
 in ( TYPEImp(I(TYPEleft,typitemright), typitem) ) end
)
 in (LrTable.NT 163,(result,TYPE1left,typitem1right),rest671) end
| (466,(_,(MlyValue.datitem datitem1,_,datitemright as datitem1right))
::(_,(_,DATATYPEleft as DATATYPE1left,_))::rest671) => let val result=
MlyValue.imp1'(fn _ => let val datitem as datitem1=datitem1 ()
 in ( DATATYPEImp(I(DATATYPEleft,datitemright), datitem) ) end
)
 in (LrTable.NT 163,(result,DATATYPE1left,datitem1right),rest671) end
| (467,(_,(MlyValue.dconitem dconitem1,_,dconitemright as 
dconitem1right))::(_,(_,CONSTRUCTORleft as CONSTRUCTOR1left,_))::
rest671) => let val result=MlyValue.imp1'(fn _ => let val dconitem as 
dconitem1=dconitem1 ()
 in (
 CONSTRUCTORImp(I(CONSTRUCTORleft,dconitemright),
					  dconitem) )
 end
)
 in (LrTable.NT 163,(result,CONSTRUCTOR1left,dconitem1right),rest671)
 end
| (468,(_,(MlyValue.exitem exitem1,_,exitemright as exitem1right))::(_
,(_,EXCEPTIONleft as EXCEPTION1left,_))::rest671) => let val result=
MlyValue.imp1'(fn _ => let val exitem as exitem1=exitem1 ()
 in ( EXCEPTIONImp(I(EXCEPTIONleft,exitemright), exitem) ) end
)
 in (LrTable.NT 163,(result,EXCEPTION1left,exitem1right),rest671) end
| (469,(_,(MlyValue.stritem stritem1,_,stritemright as stritem1right))
::(_,(_,STRUCTUREleft as STRUCTURE1left,_))::rest671) => let val 
result=MlyValue.imp1'(fn _ => let val stritem as stritem1=stritem1 ()
 in ( STRUCTUREImp(I(STRUCTUREleft,stritemright), stritem)) end
)
 in (LrTable.NT 163,(result,STRUCTURE1left,stritem1right),rest671) end
| (470,(_,(MlyValue.sigitem sigitem1,_,sigitemright as sigitem1right))
::(_,(_,SIGNATUREleft as SIGNATURE1left,_))::rest671) => let val 
result=MlyValue.imp1'(fn _ => let val sigitem as sigitem1=sigitem1 ()
 in ( SIGNATUREImp(I(SIGNATUREleft,sigitemright), sigitem)) end
)
 in (LrTable.NT 163,(result,SIGNATURE1left,sigitem1right),rest671) end
| (471,(_,(MlyValue.funitem funitem1,_,funitemright as funitem1right))
::(_,(_,FUNCTORleft as FUNCTOR1left,_))::rest671) => let val result=
MlyValue.imp1'(fn _ => let val funitem as funitem1=funitem1 ()
 in ( FUNCTORImp(I(FUNCTORleft,funitemright), funitem)) end
)
 in (LrTable.NT 163,(result,FUNCTOR1left,funitem1right),rest671) end
| (472,(_,(MlyValue.AND_valitem_opt AND_valitem_opt1,_,
AND_valitem_optright as AND_valitem_opt1right))::(_,(MlyValue.vid vid1
,_,_))::(_,(MlyValue.OP_opt OP_opt1,OP_optleft as OP_opt1left,_))::
rest671) => let val result=MlyValue.valitem(fn _ => let val OP_opt as 
OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val AND_valitem_opt as AND_valitem_opt1=AND_valitem_opt1 ()
 in (
 PLAINValItem(I(OP_optleft,AND_valitem_optright),
				       OP_opt, vid, AND_valitem_opt) 
) end
)
 in (LrTable.NT 164,(result,OP_opt1left,AND_valitem_opt1right),rest671
) end
| (473,(_,(MlyValue.AND_valitem_opt AND_valitem_opt1,_,
AND_valitem_optright as AND_valitem_opt1right))::(_,(MlyValue.ty ty1,_
,_))::_::(_,(MlyValue.vid vid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,
OP_optleft as OP_opt1left,_))::rest671) => let val result=
MlyValue.valitem(fn _ => let val OP_opt as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val ty as ty1=ty1 ()
val AND_valitem_opt as AND_valitem_opt1=AND_valitem_opt1 ()
 in (
 DESCValItem(I(OP_optleft,AND_valitem_optright),
				      OP_opt, vid, ty, AND_valitem_opt) 
) end
)
 in (LrTable.NT 164,(result,OP_opt1left,AND_valitem_opt1right),rest671
) end
| (474,(_,(MlyValue.valitem valitem1,_,valitem1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_valitem_opt(fn _ => let 
val valitem as valitem1=valitem1 ()
 in ( SOME valitem ) end
)
 in (LrTable.NT 165,(result,AND1left,valitem1right),rest671) end
| (475,rest671) => let val result=MlyValue.AND_valitem_opt(fn _ => (
 NONE ))
 in (LrTable.NT 165,(result,defaultPos,defaultPos),rest671) end
| (476,(_,(MlyValue.AND_typitem_opt AND_typitem_opt1,_,
AND_typitem_optright as AND_typitem_opt1right))::(_,(MlyValue.tycon 
tycon1,tyconleft as tycon1left,_))::rest671) => let val result=
MlyValue.typitem(fn _ => let val tycon as tycon1=tycon1 ()
val AND_typitem_opt as AND_typitem_opt1=AND_typitem_opt1 ()
 in (
 PLAINTypItem(I(tyconleft,AND_typitem_optright),
				       tycon, AND_typitem_opt) 
) end
)
 in (LrTable.NT 166,(result,tycon1left,AND_typitem_opt1right),rest671)
 end
| (477,(_,(MlyValue.AND_typitem_opt AND_typitem_opt1,_,
AND_typitem_optright as AND_typitem_opt1right))::(_,(MlyValue.tycon 
tycon1,_,_))::(_,(MlyValue.tyvarseq1 tyvarseq11,tyvarseq1left as 
tyvarseq11left,_))::rest671) => let val result=MlyValue.typitem(fn _
 => let val tyvarseq1 as tyvarseq11=tyvarseq11 ()
val tycon as tycon1=tycon1 ()
val AND_typitem_opt as AND_typitem_opt1=AND_typitem_opt1 ()
 in (
 DESCTypItem(I(tyvarseq1left,AND_typitem_optright),
				      tyvarseq1, tycon, AND_typitem_opt) 
) end
)
 in (LrTable.NT 166,(result,tyvarseq11left,AND_typitem_opt1right),
rest671) end
| (478,(_,(MlyValue.typitem typitem1,_,typitem1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_typitem_opt(fn _ => let 
val typitem as typitem1=typitem1 ()
 in ( SOME typitem ) end
)
 in (LrTable.NT 167,(result,AND1left,typitem1right),rest671) end
| (479,rest671) => let val result=MlyValue.AND_typitem_opt(fn _ => (
 NONE ))
 in (LrTable.NT 167,(result,defaultPos,defaultPos),rest671) end
| (480,(_,(MlyValue.AND_datitem_opt AND_datitem_opt1,_,
AND_datitem_optright as AND_datitem_opt1right))::(_,(MlyValue.tycon 
tycon1,tyconleft as tycon1left,_))::rest671) => let val result=
MlyValue.datitem(fn _ => let val tycon as tycon1=tycon1 ()
val AND_datitem_opt as AND_datitem_opt1=AND_datitem_opt1 ()
 in (
 PLAINDatItem(I(tyconleft,AND_datitem_optright),
				      tycon, AND_datitem_opt) 
) end
)
 in (LrTable.NT 168,(result,tycon1left,AND_datitem_opt1right),rest671)
 end
| (481,(_,(MlyValue.AND_datitem_opt AND_datitem_opt1,_,
AND_datitem_optright as AND_datitem_opt1right))::(_,(MlyValue.conitem 
conitem1,_,_))::_::(_,(MlyValue.tycon tycon1,tyconleft as tycon1left,_
))::rest671) => let val result=MlyValue.datitem(fn _ => let val tycon
 as tycon1=tycon1 ()
val conitem as conitem1=conitem1 ()
val AND_datitem_opt as AND_datitem_opt1=AND_datitem_opt1 ()
 in (
 DESCDatItem(I(tyconleft,AND_datitem_optright),
				      Seq(I(defaultPos,defaultPos), []),
				      tycon, conitem, AND_datitem_opt) 
) end
)
 in (LrTable.NT 168,(result,tycon1left,AND_datitem_opt1right),rest671)
 end
| (482,(_,(MlyValue.AND_datitem_opt AND_datitem_opt1,_,
AND_datitem_optright as AND_datitem_opt1right))::(_,(MlyValue.conitem 
conitem1,_,_))::_::(_,(MlyValue.tycon tycon1,_,_))::(_,(
MlyValue.tyvarseq1 tyvarseq11,tyvarseq1left as tyvarseq11left,_))::
rest671) => let val result=MlyValue.datitem(fn _ => let val tyvarseq1
 as tyvarseq11=tyvarseq11 ()
val tycon as tycon1=tycon1 ()
val conitem as conitem1=conitem1 ()
val AND_datitem_opt as AND_datitem_opt1=AND_datitem_opt1 ()
 in (
 DESCDatItem(I(tyvarseq1left,AND_datitem_optright),
				      tyvarseq1, tycon, conitem,
				      AND_datitem_opt) 
) end
)
 in (LrTable.NT 168,(result,tyvarseq11left,AND_datitem_opt1right),
rest671) end
| (483,(_,(MlyValue.datitem datitem1,_,datitem1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_datitem_opt(fn _ => let 
val datitem as datitem1=datitem1 ()
 in ( SOME datitem ) end
)
 in (LrTable.NT 169,(result,AND1left,datitem1right),rest671) end
| (484,rest671) => let val result=MlyValue.AND_datitem_opt(fn _ => (
 NONE ))
 in (LrTable.NT 169,(result,defaultPos,defaultPos),rest671) end
| (485,(_,(MlyValue.BAR_conitem_opt BAR_conitem_opt1,_,
BAR_conitem_optright as BAR_conitem_opt1right))::(_,(
MlyValue.OF_ty_opt OF_ty_opt1,_,_))::(_,(MlyValue.vid vid1,_,_))::(_,(
MlyValue.OP_opt OP_opt1,OP_optleft as OP_opt1left,_))::rest671) => 
let val result=MlyValue.conitem(fn _ => let val OP_opt as OP_opt1=
OP_opt1 ()
val vid as vid1=vid1 ()
val OF_ty_opt as OF_ty_opt1=OF_ty_opt1 ()
val BAR_conitem_opt as BAR_conitem_opt1=BAR_conitem_opt1 ()
 in (
 ConItem(I(OP_optleft,BAR_conitem_optright),
				  OP_opt, vid, OF_ty_opt, BAR_conitem_opt) 
) end
)
 in (LrTable.NT 170,(result,OP_opt1left,BAR_conitem_opt1right),rest671
) end
| (486,(_,(MlyValue.conitem conitem1,_,conitem1right))::(_,(_,BAR1left
,_))::rest671) => let val result=MlyValue.BAR_conitem_opt(fn _ => let 
val conitem as conitem1=conitem1 ()
 in ( SOME conitem ) end
)
 in (LrTable.NT 171,(result,BAR1left,conitem1right),rest671) end
| (487,rest671) => let val result=MlyValue.BAR_conitem_opt(fn _ => (
 NONE ))
 in (LrTable.NT 171,(result,defaultPos,defaultPos),rest671) end
| (488,(_,(MlyValue.AND_dconitem_opt AND_dconitem_opt1,_,
AND_dconitem_optright as AND_dconitem_opt1right))::(_,(MlyValue.vid 
vid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,OP_optleft as OP_opt1left,_))
::rest671) => let val result=MlyValue.dconitem(fn _ => let val OP_opt
 as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val AND_dconitem_opt as AND_dconitem_opt1=AND_dconitem_opt1 ()
 in (
 PLAINDconItem(I(OP_optleft,AND_dconitem_optright),
					OP_opt, vid, AND_dconitem_opt) 
) end
)
 in (LrTable.NT 172,(result,OP_opt1left,AND_dconitem_opt1right),
rest671) end
| (489,(_,(MlyValue.AND_dconitem_opt AND_dconitem_opt1,_,
AND_dconitem_optright as AND_dconitem_opt1right))::(_,(
MlyValue.longtycon longtycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1,_
,_))::_::(_,(MlyValue.OF_ty_opt OF_ty_opt1,_,_))::(_,(MlyValue.vid 
vid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,OP_optleft as OP_opt1left,_))
::rest671) => let val result=MlyValue.dconitem(fn _ => let val OP_opt
 as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val OF_ty_opt as OF_ty_opt1=OF_ty_opt1 ()
val tyvarseq as tyvarseq1=tyvarseq1 ()
val longtycon as longtycon1=longtycon1 ()
val AND_dconitem_opt as AND_dconitem_opt1=AND_dconitem_opt1 ()
 in (
 DESCDconItem(I(OP_optleft,AND_dconitem_optright),
				       OP_opt, vid, OF_ty_opt,
				       tyvarseq, longtycon, AND_dconitem_opt) 
) end
)
 in (LrTable.NT 172,(result,OP_opt1left,AND_dconitem_opt1right),
rest671) end
| (490,(_,(MlyValue.dconitem dconitem1,_,dconitem1right))::(_,(_,
AND1left,_))::rest671) => let val result=MlyValue.AND_dconitem_opt(fn 
_ => let val dconitem as dconitem1=dconitem1 ()
 in ( SOME dconitem ) end
)
 in (LrTable.NT 173,(result,AND1left,dconitem1right),rest671) end
| (491,rest671) => let val result=MlyValue.AND_dconitem_opt(fn _ => (
 NONE ))
 in (LrTable.NT 173,(result,defaultPos,defaultPos),rest671) end
| (492,(_,(MlyValue.AND_exitem_opt AND_exitem_opt1,_,
AND_exitem_optright as AND_exitem_opt1right))::(_,(MlyValue.vid vid1,_
,_))::(_,(MlyValue.OP_opt OP_opt1,OP_optleft as OP_opt1left,_))::
rest671) => let val result=MlyValue.exitem(fn _ => let val OP_opt as 
OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val AND_exitem_opt as AND_exitem_opt1=AND_exitem_opt1 ()
 in (
 PLAINExItem(I(OP_optleft,AND_exitem_optright),
	  			      OP_opt, vid, AND_exitem_opt) 
) end
)
 in (LrTable.NT 174,(result,OP_opt1left,AND_exitem_opt1right),rest671)
 end
| (493,(_,(MlyValue.AND_exitem_opt AND_exitem_opt1,_,
AND_exitem_optright as AND_exitem_opt1right))::(_,(MlyValue.ty ty1,_,_
))::_::(_,(MlyValue.vid vid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,
OP_optleft as OP_opt1left,_))::rest671) => let val result=
MlyValue.exitem(fn _ => let val OP_opt as OP_opt1=OP_opt1 ()
val vid as vid1=vid1 ()
val ty as ty1=ty1 ()
val AND_exitem_opt as AND_exitem_opt1=AND_exitem_opt1 ()
 in (
 DESCExItem(I(OP_optleft,AND_exitem_optright),
	  			     OP_opt, vid, ty, AND_exitem_opt) 
) end
)
 in (LrTable.NT 174,(result,OP_opt1left,AND_exitem_opt1right),rest671)
 end
| (494,(_,(MlyValue.exitem exitem1,_,exitem1right))::(_,(_,AND1left,_)
)::rest671) => let val result=MlyValue.AND_exitem_opt(fn _ => let val 
exitem as exitem1=exitem1 ()
 in ( SOME exitem ) end
)
 in (LrTable.NT 175,(result,AND1left,exitem1right),rest671) end
| (495,rest671) => let val result=MlyValue.AND_exitem_opt(fn _ => (
 NONE ))
 in (LrTable.NT 175,(result,defaultPos,defaultPos),rest671) end
| (496,(_,(MlyValue.AND_stritem_opt AND_stritem_opt1,_,
AND_stritem_optright as AND_stritem_opt1right))::(_,(MlyValue.strid 
strid1,stridleft as strid1left,_))::rest671) => let val result=
MlyValue.stritem(fn _ => let val strid as strid1=strid1 ()
val AND_stritem_opt as AND_stritem_opt1=AND_stritem_opt1 ()
 in (
 PLAINStrItem(I(stridleft,AND_stritem_optright),
				       strid, AND_stritem_opt) 
) end
)
 in (LrTable.NT 176,(result,strid1left,AND_stritem_opt1right),rest671)
 end
| (497,(_,(MlyValue.sigexp__AND_stritem_opt sigexp__AND_stritem_opt1,_
,sigexp__AND_stritem_optright as sigexp__AND_stritem_opt1right))::_::(
_,(MlyValue.strid strid1,stridleft as strid1left,_))::rest671) => let 
val result=MlyValue.stritem(fn _ => let val strid as strid1=strid1 ()
val sigexp__AND_stritem_opt as sigexp__AND_stritem_opt1=
sigexp__AND_stritem_opt1 ()
 in (
 DESCStrItem(I(stridleft,sigexp__AND_stritem_optright),
				      strid, #1 sigexp__AND_stritem_opt,
				      #2 sigexp__AND_stritem_opt) 
) end
)
 in (LrTable.NT 176,(result,strid1left,sigexp__AND_stritem_opt1right),
rest671) end
| (498,(_,(MlyValue.stritem stritem1,_,stritem1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_stritem_opt(fn _ => let 
val stritem as stritem1=stritem1 ()
 in ( SOME stritem ) end
)
 in (LrTable.NT 177,(result,AND1left,stritem1right),rest671) end
| (499,rest671) => let val result=MlyValue.AND_stritem_opt(fn _ => (
 NONE ))
 in (LrTable.NT 177,(result,defaultPos,defaultPos),rest671) end
| (500,(_,(MlyValue.AND_stritem_opt AND_stritem_opt1,_,
AND_stritem_opt1right))::(_,(MlyValue.sigexp' sigexp'1,sigexp'1left,_)
)::rest671) => let val result=MlyValue.sigexp__AND_stritem_opt(fn _
 => let val sigexp' as sigexp'1=sigexp'1 ()
val AND_stritem_opt as AND_stritem_opt1=AND_stritem_opt1 ()
 in ( ( sigexp', AND_stritem_opt ) ) end
)
 in (LrTable.NT 178,(result,sigexp'1left,AND_stritem_opt1right),
rest671) end
| (501,(_,(MlyValue.sigexp__AND_stritem_opt sigexp__AND_stritem_opt1,_
,sigexp__AND_stritem_optright as sigexp__AND_stritem_opt1right))::_::(
_,(MlyValue.strpat strpat1,_,_))::(_,(_,FCTleft as FCT1left,_))::
rest671) => let val result=MlyValue.sigexp__AND_stritem_opt(fn _ => 
let val strpat as strpat1=strpat1 ()
val sigexp__AND_stritem_opt as sigexp__AND_stritem_opt1=
sigexp__AND_stritem_opt1 ()
 in (
 ( FCTSigExp(I(FCTleft,sigexp__AND_stritem_optright),
				      strpat, #1 sigexp__AND_stritem_opt)
			  , #2 sigexp__AND_stritem_opt ) 
) end
)
 in (LrTable.NT 178,(result,FCT1left,sigexp__AND_stritem_opt1right),
rest671) end
| (502,(_,(MlyValue.rea__AND_stritem_opt rea__AND_stritem_opt1,_,
rea__AND_stritem_optright as rea__AND_stritem_opt1right))::_::(_,(
MlyValue.sigexp sigexp1,sigexpleft as sigexp1left,_))::rest671) => 
let val result=MlyValue.sigexp__AND_stritem_opt(fn _ => let val sigexp
 as sigexp1=sigexp1 ()
val rea__AND_stritem_opt as rea__AND_stritem_opt1=
rea__AND_stritem_opt1 ()
 in (
 ( WHEREREASigExp(I(sigexpleft,
					     rea__AND_stritem_optright),
					   sigexp, #1 rea__AND_stritem_opt)
			  , #2 rea__AND_stritem_opt ) 
) end
)
 in (LrTable.NT 178,(result,sigexp1left,rea__AND_stritem_opt1right),
rest671) end
| (503,(_,(MlyValue.AND_rea_opt__AND_stritem_opt 
AND_rea_opt__AND_stritem_opt1,_,AND_rea_opt__AND_stritem_optright as 
AND_rea_opt__AND_stritem_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,VALleft as 
VAL1left,_))::rest671) => let val result=MlyValue.rea__AND_stritem_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_stritem_opt as AND_rea_opt__AND_stritem_opt1=
AND_rea_opt__AND_stritem_opt1 ()
 in (
 ( VALRea(I(VALleft,AND_rea_opt__AND_stritem_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_stritem_opt)
			  , #2 AND_rea_opt__AND_stritem_opt ) 
) end
)
 in (LrTable.NT 179,(result,VAL1left,
AND_rea_opt__AND_stritem_opt1right),rest671) end
| (504,(_,(MlyValue.AND_rea_opt__AND_stritem_opt 
AND_rea_opt__AND_stritem_opt1,_,AND_rea_opt__AND_stritem_optright as 
AND_rea_opt__AND_stritem_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,FUNleft as 
FUN1left,_))::rest671) => let val result=MlyValue.rea__AND_stritem_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_stritem_opt as AND_rea_opt__AND_stritem_opt1=
AND_rea_opt__AND_stritem_opt1 ()
 in (
 ( FUNRea(I(FUNleft,AND_rea_opt__AND_stritem_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_stritem_opt)
			  , #2 AND_rea_opt__AND_stritem_opt ) 
) end
)
 in (LrTable.NT 179,(result,FUN1left,
AND_rea_opt__AND_stritem_opt1right),rest671) end
| (505,(_,(MlyValue.AND_rea_opt__AND_stritem_opt 
AND_rea_opt__AND_stritem_opt1,_,AND_rea_opt__AND_stritem_optright as 
AND_rea_opt__AND_stritem_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,
CONSTRUCTORleft as CONSTRUCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_stritem_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_stritem_opt as AND_rea_opt__AND_stritem_opt1=
AND_rea_opt__AND_stritem_opt1 ()
 in (
 ( CONSTRUCTORRea(I(CONSTRUCTORleft,
					     AND_rea_opt__AND_stritem_optright),
					   OP_opt1, longvid1, OP_opt2, longvid2,
				           #1 AND_rea_opt__AND_stritem_opt)
			  , #2 AND_rea_opt__AND_stritem_opt ) 
) end
)
 in (LrTable.NT 179,(result,CONSTRUCTOR1left,
AND_rea_opt__AND_stritem_opt1right),rest671) end
| (506,(_,(MlyValue.AND_rea_opt__AND_stritem_opt 
AND_rea_opt__AND_stritem_opt1,_,AND_rea_opt__AND_stritem_optright as 
AND_rea_opt__AND_stritem_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,EXCEPTIONleft
 as EXCEPTION1left,_))::rest671) => let val result=
MlyValue.rea__AND_stritem_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_stritem_opt as AND_rea_opt__AND_stritem_opt1=
AND_rea_opt__AND_stritem_opt1 ()
 in (
 ( EXCEPTIONRea(I(EXCEPTIONleft,
					   AND_rea_opt__AND_stritem_optright),
					 OP_opt1, longvid1, OP_opt2, longvid2,
					 #1 AND_rea_opt__AND_stritem_opt)
			  , #2 AND_rea_opt__AND_stritem_opt ) 
) end
)
 in (LrTable.NT 179,(result,EXCEPTION1left,
AND_rea_opt__AND_stritem_opt1right),rest671) end
| (507,(_,(MlyValue.AND_rea_opt__AND_stritem_opt 
AND_rea_opt__AND_stritem_opt1,_,AND_rea_opt__AND_stritem_optright as 
AND_rea_opt__AND_stritem_opt1right))::(_,(MlyValue.ty ty1,_,_))::_::(_
,(MlyValue.longtycon longtycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1
,_,_))::(_,(_,TYPEleft as TYPE1left,_))::rest671) => let val result=
MlyValue.rea__AND_stritem_opt(fn _ => let val tyvarseq as tyvarseq1=
tyvarseq1 ()
val longtycon as longtycon1=longtycon1 ()
val ty as ty1=ty1 ()
val AND_rea_opt__AND_stritem_opt as AND_rea_opt__AND_stritem_opt1=
AND_rea_opt__AND_stritem_opt1 ()
 in (
 ( TYPERea(I(TYPEleft,
				      AND_rea_opt__AND_stritem_optright),
				    tyvarseq, longtycon, ty,
				    #1 AND_rea_opt__AND_stritem_opt)
			  , #2 AND_rea_opt__AND_stritem_opt ) 
) end
)
 in (LrTable.NT 179,(result,TYPE1left,
AND_rea_opt__AND_stritem_opt1right),rest671) end
| (508,(_,(MlyValue.AND_rea_opt__AND_stritem_opt 
AND_rea_opt__AND_stritem_opt1,_,AND_rea_opt__AND_stritem_optright as 
AND_rea_opt__AND_stritem_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,STRUCTUREleft as 
STRUCTURE1left,_))::rest671) => let val result=
MlyValue.rea__AND_stritem_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_stritem_opt as AND_rea_opt__AND_stritem_opt1=
AND_rea_opt__AND_stritem_opt1 ()
 in (
 ( STRUCTURERea(I(STRUCTUREleft,
					   AND_rea_opt__AND_stritem_optright),
				         longstrid1, COLON_sigexp_opt,
					 longstrid2,
				         #1 AND_rea_opt__AND_stritem_opt)
			  , #2 AND_rea_opt__AND_stritem_opt ) 
) end
)
 in (LrTable.NT 179,(result,STRUCTURE1left,
AND_rea_opt__AND_stritem_opt1right),rest671) end
| (509,(_,(MlyValue.AND_rea_opt__AND_stritem_opt 
AND_rea_opt__AND_stritem_opt1,_,AND_rea_opt__AND_stritem_optright as 
AND_rea_opt__AND_stritem_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,FUNCTORleft as 
FUNCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_stritem_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_stritem_opt as AND_rea_opt__AND_stritem_opt1=
AND_rea_opt__AND_stritem_opt1 ()
 in (
 ( FUNCTORRea(I(FUNCTORleft,
					 AND_rea_opt__AND_stritem_optright),
				       longstrid1, COLON_sigexp_opt, longstrid2,
				       #1 AND_rea_opt__AND_stritem_opt)
			  , #2 AND_rea_opt__AND_stritem_opt ) 
) end
)
 in (LrTable.NT 179,(result,FUNCTOR1left,
AND_rea_opt__AND_stritem_opt1right),rest671) end
| (510,(_,(MlyValue.sigexp__AND_rea_opt__AND_stritem_opt 
sigexp__AND_rea_opt__AND_stritem_opt1,_,
sigexp__AND_rea_opt__AND_stritem_optright as 
sigexp__AND_rea_opt__AND_stritem_opt1right))::_::(_,(
MlyValue.strpat_list0 strpat_list01,_,_))::(_,(MlyValue.longsigid 
longsigid1,_,_))::(_,(_,SIGNATUREleft as SIGNATURE1left,_))::rest671)
 => let val result=MlyValue.rea__AND_stritem_opt(fn _ => let val 
longsigid as longsigid1=longsigid1 ()
val strpat_list0 as strpat_list01=strpat_list01 ()
val sigexp__AND_rea_opt__AND_stritem_opt as 
sigexp__AND_rea_opt__AND_stritem_opt1=
sigexp__AND_rea_opt__AND_stritem_opt1 ()
 in (
 ( SIGNATURERea
				(I(SIGNATUREleft,
				   sigexp__AND_rea_opt__AND_stritem_optright),
				 longsigid, strpat_list0,
				 #1 sigexp__AND_rea_opt__AND_stritem_opt,
				 #2 sigexp__AND_rea_opt__AND_stritem_opt)
			  , #3 sigexp__AND_rea_opt__AND_stritem_opt ) 
) end
)
 in (LrTable.NT 179,(result,SIGNATURE1left,
sigexp__AND_rea_opt__AND_stritem_opt1right),rest671) end
| (511,(_,(MlyValue.AND_stritem_opt AND_stritem_opt1,
AND_stritem_opt1left,AND_stritem_opt1right))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_stritem_opt(fn _ => let val 
AND_stritem_opt as AND_stritem_opt1=AND_stritem_opt1 ()
 in ( ( NONE, AND_stritem_opt ) ) end
)
 in (LrTable.NT 180,(result,AND_stritem_opt1left,AND_stritem_opt1right
),rest671) end
| (512,(_,(MlyValue.rea__AND_stritem_opt rea__AND_stritem_opt1,_,
rea__AND_stritem_opt1right))::(_,(_,AND1left,_))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_stritem_opt(fn _ => let val 
rea__AND_stritem_opt as rea__AND_stritem_opt1=rea__AND_stritem_opt1 ()
 in (
 ( SOME(#1 rea__AND_stritem_opt)
				  , #2 rea__AND_stritem_opt ) )
 end
)
 in (LrTable.NT 180,(result,AND1left,rea__AND_stritem_opt1right),
rest671) end
| (513,(_,(MlyValue.AND_rea_opt__AND_stritem_opt 
AND_rea_opt__AND_stritem_opt1,_,AND_rea_opt__AND_stritem_opt1right))::
(_,(MlyValue.appsigexp appsigexp1,appsigexp1left,_))::rest671) => let 
val result=MlyValue.sigexp__AND_rea_opt__AND_stritem_opt(fn _ => let 
val appsigexp as appsigexp1=appsigexp1 ()
val AND_rea_opt__AND_stritem_opt as AND_rea_opt__AND_stritem_opt1=
AND_rea_opt__AND_stritem_opt1 ()
 in (
 ( appsigexp
		          , #1 AND_rea_opt__AND_stritem_opt
			  , #2 AND_rea_opt__AND_stritem_opt ) 
) end
)
 in (LrTable.NT 181,(result,appsigexp1left,
AND_rea_opt__AND_stritem_opt1right),rest671) end
| (514,(_,(MlyValue.AND_sigitem_opt AND_sigitem_opt1,_,
AND_sigitem_optright as AND_sigitem_opt1right))::(_,(MlyValue.sigid 
sigid1,sigidleft as sigid1left,_))::rest671) => let val result=
MlyValue.sigitem(fn _ => let val sigid as sigid1=sigid1 ()
val AND_sigitem_opt as AND_sigitem_opt1=AND_sigitem_opt1 ()
 in (
 PLAINSigItem(I(sigidleft,AND_sigitem_optright),
				       sigid, AND_sigitem_opt) 
) end
)
 in (LrTable.NT 182,(result,sigid1left,AND_sigitem_opt1right),rest671)
 end
| (515,(_,(MlyValue.AND_sigitem_opt AND_sigitem_opt1,_,
AND_sigitem_optright as AND_sigitem_opt1right))::(_,(
MlyValue.strpat_list1 strpat_list11,_,_))::(_,(MlyValue.sigid sigid1,
sigidleft as sigid1left,_))::rest671) => let val result=
MlyValue.sigitem(fn _ => let val sigid as sigid1=sigid1 ()
val strpat_list1 as strpat_list11=strpat_list11 ()
val AND_sigitem_opt as AND_sigitem_opt1=AND_sigitem_opt1 ()
 in (
 DESCSigItem(I(sigidleft,AND_sigitem_optright),
				      sigid, strpat_list1, AND_sigitem_opt) 
) end
)
 in (LrTable.NT 182,(result,sigid1left,AND_sigitem_opt1right),rest671)
 end
| (516,(_,(MlyValue.sigitem sigitem1,_,sigitem1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_sigitem_opt(fn _ => let 
val sigitem as sigitem1=sigitem1 ()
 in ( SOME sigitem ) end
)
 in (LrTable.NT 183,(result,AND1left,sigitem1right),rest671) end
| (517,rest671) => let val result=MlyValue.AND_sigitem_opt(fn _ => (
 NONE ))
 in (LrTable.NT 183,(result,defaultPos,defaultPos),rest671) end
| (518,(_,(MlyValue.AND_funitem_opt AND_funitem_opt1,_,
AND_funitem_optright as AND_funitem_opt1right))::(_,(MlyValue.strid 
strid1,stridleft as strid1left,_))::rest671) => let val result=
MlyValue.funitem(fn _ => let val strid as strid1=strid1 ()
val AND_funitem_opt as AND_funitem_opt1=AND_funitem_opt1 ()
 in (
 PLAINFunItem(I(stridleft,AND_funitem_optright),
				      strid, AND_funitem_opt) 
) end
)
 in (LrTable.NT 184,(result,strid1left,AND_funitem_opt1right),rest671)
 end
| (519,(_,(MlyValue.sigexp__AND_funitem_opt sigexp__AND_funitem_opt1,_
,sigexp__AND_funitem_optright as sigexp__AND_funitem_opt1right))::_::(
_,(MlyValue.strpat_list0 strpat_list01,_,_))::(_,(MlyValue.strid 
strid1,stridleft as strid1left,_))::rest671) => let val result=
MlyValue.funitem(fn _ => let val strid as strid1=strid1 ()
val strpat_list0 as strpat_list01=strpat_list01 ()
val sigexp__AND_funitem_opt as sigexp__AND_funitem_opt1=
sigexp__AND_funitem_opt1 ()
 in (
 DESCFunItem(I(stridleft,sigexp__AND_funitem_optright),
				      strid, strpat_list0,
				      #1 sigexp__AND_funitem_opt,
				      #2 sigexp__AND_funitem_opt) 
) end
)
 in (LrTable.NT 184,(result,strid1left,sigexp__AND_funitem_opt1right),
rest671) end
| (520,(_,(MlyValue.funitem funitem1,_,funitem1right))::(_,(_,AND1left
,_))::rest671) => let val result=MlyValue.AND_funitem_opt(fn _ => let 
val funitem as funitem1=funitem1 ()
 in ( SOME funitem ) end
)
 in (LrTable.NT 185,(result,AND1left,funitem1right),rest671) end
| (521,rest671) => let val result=MlyValue.AND_funitem_opt(fn _ => (
 NONE ))
 in (LrTable.NT 185,(result,defaultPos,defaultPos),rest671) end
| (522,(_,(MlyValue.AND_funitem_opt AND_funitem_opt1,_,
AND_funitem_opt1right))::(_,(MlyValue.sigexp' sigexp'1,sigexp'1left,_)
)::rest671) => let val result=MlyValue.sigexp__AND_funitem_opt(fn _
 => let val sigexp' as sigexp'1=sigexp'1 ()
val AND_funitem_opt as AND_funitem_opt1=AND_funitem_opt1 ()
 in ( ( sigexp', AND_funitem_opt ) ) end
)
 in (LrTable.NT 186,(result,sigexp'1left,AND_funitem_opt1right),
rest671) end
| (523,(_,(MlyValue.sigexp__AND_funitem_opt sigexp__AND_funitem_opt1,_
,sigexp__AND_funitem_optright as sigexp__AND_funitem_opt1right))::_::(
_,(MlyValue.strpat strpat1,_,_))::(_,(_,FCTleft as FCT1left,_))::
rest671) => let val result=MlyValue.sigexp__AND_funitem_opt(fn _ => 
let val strpat as strpat1=strpat1 ()
val sigexp__AND_funitem_opt as sigexp__AND_funitem_opt1=
sigexp__AND_funitem_opt1 ()
 in (
 ( FCTSigExp(I(FCTleft,sigexp__AND_funitem_optright),
				      strpat, #1 sigexp__AND_funitem_opt)
			  , #2 sigexp__AND_funitem_opt ) 
) end
)
 in (LrTable.NT 186,(result,FCT1left,sigexp__AND_funitem_opt1right),
rest671) end
| (524,(_,(MlyValue.rea__AND_funitem_opt rea__AND_funitem_opt1,_,
rea__AND_funitem_optright as rea__AND_funitem_opt1right))::_::(_,(
MlyValue.sigexp sigexp1,sigexpleft as sigexp1left,_))::rest671) => 
let val result=MlyValue.sigexp__AND_funitem_opt(fn _ => let val sigexp
 as sigexp1=sigexp1 ()
val rea__AND_funitem_opt as rea__AND_funitem_opt1=
rea__AND_funitem_opt1 ()
 in (
 ( WHEREREASigExp(I(sigexpleft,
					     rea__AND_funitem_optright),
					   sigexp, #1 rea__AND_funitem_opt)
			  , #2 rea__AND_funitem_opt ) 
) end
)
 in (LrTable.NT 186,(result,sigexp1left,rea__AND_funitem_opt1right),
rest671) end
| (525,(_,(MlyValue.AND_rea_opt__AND_funitem_opt 
AND_rea_opt__AND_funitem_opt1,_,AND_rea_opt__AND_funitem_optright as 
AND_rea_opt__AND_funitem_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,VALleft as 
VAL1left,_))::rest671) => let val result=MlyValue.rea__AND_funitem_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_funitem_opt as AND_rea_opt__AND_funitem_opt1=
AND_rea_opt__AND_funitem_opt1 ()
 in (
 ( VALRea(I(VALleft,AND_rea_opt__AND_funitem_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_funitem_opt)
			  , #2 AND_rea_opt__AND_funitem_opt ) 
) end
)
 in (LrTable.NT 187,(result,VAL1left,
AND_rea_opt__AND_funitem_opt1right),rest671) end
| (526,(_,(MlyValue.AND_rea_opt__AND_funitem_opt 
AND_rea_opt__AND_funitem_opt1,_,AND_rea_opt__AND_funitem_optright as 
AND_rea_opt__AND_funitem_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,FUNleft as 
FUN1left,_))::rest671) => let val result=MlyValue.rea__AND_funitem_opt
(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_funitem_opt as AND_rea_opt__AND_funitem_opt1=
AND_rea_opt__AND_funitem_opt1 ()
 in (
 ( FUNRea(I(FUNleft,AND_rea_opt__AND_funitem_optright),
				   OP_opt1, longvid1, OP_opt2, longvid2,
				   #1 AND_rea_opt__AND_funitem_opt)
			  , #2 AND_rea_opt__AND_funitem_opt ) 
) end
)
 in (LrTable.NT 187,(result,FUN1left,
AND_rea_opt__AND_funitem_opt1right),rest671) end
| (527,(_,(MlyValue.AND_rea_opt__AND_funitem_opt 
AND_rea_opt__AND_funitem_opt1,_,AND_rea_opt__AND_funitem_optright as 
AND_rea_opt__AND_funitem_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,
CONSTRUCTORleft as CONSTRUCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_funitem_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_funitem_opt as AND_rea_opt__AND_funitem_opt1=
AND_rea_opt__AND_funitem_opt1 ()
 in (
 ( CONSTRUCTORRea(I(CONSTRUCTORleft,
					     AND_rea_opt__AND_funitem_optright),
					   OP_opt1, longvid1, OP_opt2, longvid2,
				           #1 AND_rea_opt__AND_funitem_opt)
			  , #2 AND_rea_opt__AND_funitem_opt ) 
) end
)
 in (LrTable.NT 187,(result,CONSTRUCTOR1left,
AND_rea_opt__AND_funitem_opt1right),rest671) end
| (528,(_,(MlyValue.AND_rea_opt__AND_funitem_opt 
AND_rea_opt__AND_funitem_opt1,_,AND_rea_opt__AND_funitem_optright as 
AND_rea_opt__AND_funitem_opt1right))::(_,(MlyValue.longvid longvid2,_,
_))::(_,(MlyValue.OP_opt OP_opt2,_,_))::_::(_,(MlyValue.longvid 
longvid1,_,_))::(_,(MlyValue.OP_opt OP_opt1,_,_))::(_,(_,EXCEPTIONleft
 as EXCEPTION1left,_))::rest671) => let val result=
MlyValue.rea__AND_funitem_opt(fn _ => let val OP_opt1=OP_opt1 ()
val longvid1=longvid1 ()
val OP_opt2=OP_opt2 ()
val longvid2=longvid2 ()
val AND_rea_opt__AND_funitem_opt as AND_rea_opt__AND_funitem_opt1=
AND_rea_opt__AND_funitem_opt1 ()
 in (
 ( EXCEPTIONRea(I(EXCEPTIONleft,
					   AND_rea_opt__AND_funitem_optright),
					 OP_opt1, longvid1, OP_opt2, longvid2,
					 #1 AND_rea_opt__AND_funitem_opt)
			  , #2 AND_rea_opt__AND_funitem_opt ) 
) end
)
 in (LrTable.NT 187,(result,EXCEPTION1left,
AND_rea_opt__AND_funitem_opt1right),rest671) end
| (529,(_,(MlyValue.AND_rea_opt__AND_funitem_opt 
AND_rea_opt__AND_funitem_opt1,_,AND_rea_opt__AND_funitem_optright as 
AND_rea_opt__AND_funitem_opt1right))::(_,(MlyValue.ty ty1,_,_))::_::(_
,(MlyValue.longtycon longtycon1,_,_))::(_,(MlyValue.tyvarseq tyvarseq1
,_,_))::(_,(_,TYPEleft as TYPE1left,_))::rest671) => let val result=
MlyValue.rea__AND_funitem_opt(fn _ => let val tyvarseq as tyvarseq1=
tyvarseq1 ()
val longtycon as longtycon1=longtycon1 ()
val ty as ty1=ty1 ()
val AND_rea_opt__AND_funitem_opt as AND_rea_opt__AND_funitem_opt1=
AND_rea_opt__AND_funitem_opt1 ()
 in (
 ( TYPERea(I(TYPEleft,
				      AND_rea_opt__AND_funitem_optright),
				    tyvarseq, longtycon, ty,
				    #1 AND_rea_opt__AND_funitem_opt)
			  , #2 AND_rea_opt__AND_funitem_opt ) 
) end
)
 in (LrTable.NT 187,(result,TYPE1left,
AND_rea_opt__AND_funitem_opt1right),rest671) end
| (530,(_,(MlyValue.AND_rea_opt__AND_funitem_opt 
AND_rea_opt__AND_funitem_opt1,_,AND_rea_opt__AND_funitem_optright as 
AND_rea_opt__AND_funitem_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,STRUCTUREleft as 
STRUCTURE1left,_))::rest671) => let val result=
MlyValue.rea__AND_funitem_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_funitem_opt as AND_rea_opt__AND_funitem_opt1=
AND_rea_opt__AND_funitem_opt1 ()
 in (
 ( STRUCTURERea(I(STRUCTUREleft,
					   AND_rea_opt__AND_funitem_optright),
				         longstrid1, COLON_sigexp_opt,
					 longstrid2,
				         #1 AND_rea_opt__AND_funitem_opt)
			  , #2 AND_rea_opt__AND_funitem_opt ) 
) end
)
 in (LrTable.NT 187,(result,STRUCTURE1left,
AND_rea_opt__AND_funitem_opt1right),rest671) end
| (531,(_,(MlyValue.AND_rea_opt__AND_funitem_opt 
AND_rea_opt__AND_funitem_opt1,_,AND_rea_opt__AND_funitem_optright as 
AND_rea_opt__AND_funitem_opt1right))::(_,(MlyValue.longstrid 
longstrid2,_,_))::_::(_,(MlyValue.COLON_sigexp_opt COLON_sigexp_opt1,_
,_))::(_,(MlyValue.longstrid longstrid1,_,_))::(_,(_,FUNCTORleft as 
FUNCTOR1left,_))::rest671) => let val result=
MlyValue.rea__AND_funitem_opt(fn _ => let val longstrid1=longstrid1 ()
val COLON_sigexp_opt as COLON_sigexp_opt1=COLON_sigexp_opt1 ()
val longstrid2=longstrid2 ()
val AND_rea_opt__AND_funitem_opt as AND_rea_opt__AND_funitem_opt1=
AND_rea_opt__AND_funitem_opt1 ()
 in (
 ( FUNCTORRea(I(FUNCTORleft,
					 AND_rea_opt__AND_funitem_optright),
				       longstrid1, COLON_sigexp_opt, longstrid2,
				       #1 AND_rea_opt__AND_funitem_opt)
			  , #2 AND_rea_opt__AND_funitem_opt ) 
) end
)
 in (LrTable.NT 187,(result,FUNCTOR1left,
AND_rea_opt__AND_funitem_opt1right),rest671) end
| (532,(_,(MlyValue.sigexp__AND_rea_opt__AND_funitem_opt 
sigexp__AND_rea_opt__AND_funitem_opt1,_,
sigexp__AND_rea_opt__AND_funitem_optright as 
sigexp__AND_rea_opt__AND_funitem_opt1right))::_::(_,(
MlyValue.strpat_list0 strpat_list01,_,_))::(_,(MlyValue.longsigid 
longsigid1,_,_))::(_,(_,SIGNATUREleft as SIGNATURE1left,_))::rest671)
 => let val result=MlyValue.rea__AND_funitem_opt(fn _ => let val 
longsigid as longsigid1=longsigid1 ()
val strpat_list0 as strpat_list01=strpat_list01 ()
val sigexp__AND_rea_opt__AND_funitem_opt as 
sigexp__AND_rea_opt__AND_funitem_opt1=
sigexp__AND_rea_opt__AND_funitem_opt1 ()
 in (
 ( SIGNATURERea
				(I(SIGNATUREleft,
				   sigexp__AND_rea_opt__AND_funitem_optright),
				 longsigid, strpat_list0,
				 #1 sigexp__AND_rea_opt__AND_funitem_opt,
				 #2 sigexp__AND_rea_opt__AND_funitem_opt)
			  , #3 sigexp__AND_rea_opt__AND_funitem_opt ) 
) end
)
 in (LrTable.NT 187,(result,SIGNATURE1left,
sigexp__AND_rea_opt__AND_funitem_opt1right),rest671) end
| (533,(_,(MlyValue.AND_funitem_opt AND_funitem_opt1,
AND_funitem_opt1left,AND_funitem_opt1right))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_funitem_opt(fn _ => let val 
AND_funitem_opt as AND_funitem_opt1=AND_funitem_opt1 ()
 in ( ( NONE, AND_funitem_opt ) ) end
)
 in (LrTable.NT 188,(result,AND_funitem_opt1left,AND_funitem_opt1right
),rest671) end
| (534,(_,(MlyValue.rea__AND_funitem_opt rea__AND_funitem_opt1,_,
rea__AND_funitem_opt1right))::(_,(_,AND1left,_))::rest671) => let val 
result=MlyValue.AND_rea_opt__AND_funitem_opt(fn _ => let val 
rea__AND_funitem_opt as rea__AND_funitem_opt1=rea__AND_funitem_opt1 ()
 in (
 ( SOME(#1 rea__AND_funitem_opt),
			    #2 rea__AND_funitem_opt ) )
 end
)
 in (LrTable.NT 188,(result,AND1left,rea__AND_funitem_opt1right),
rest671) end
| (535,(_,(MlyValue.AND_rea_opt__AND_funitem_opt 
AND_rea_opt__AND_funitem_opt1,_,AND_rea_opt__AND_funitem_opt1right))::
(_,(MlyValue.appsigexp appsigexp1,appsigexp1left,_))::rest671) => let 
val result=MlyValue.sigexp__AND_rea_opt__AND_funitem_opt(fn _ => let 
val appsigexp as appsigexp1=appsigexp1 ()
val AND_rea_opt__AND_funitem_opt as AND_rea_opt__AND_funitem_opt1=
AND_rea_opt__AND_funitem_opt1 ()
 in (
 ( appsigexp
		          , #1 AND_rea_opt__AND_funitem_opt
			  , #2 AND_rea_opt__AND_funitem_opt ) 
) end
)
 in (LrTable.NT 189,(result,appsigexp1left,
AND_rea_opt__AND_funitem_opt1right),rest671) end
| (536,(_,(MlyValue.ann1 ann11,ann11left,ann11right))::rest671) => 
let val result=MlyValue.ann0(fn _ => let val ann1 as ann11=ann11 ()
 in ( ann1 ) end
)
 in (LrTable.NT 190,(result,ann11left,ann11right),rest671) end
| (537,rest671) => let val result=MlyValue.ann0(fn _ => (
 EMPTYAnn(I(defaultPos,defaultPos)) ))
 in (LrTable.NT 190,(result,defaultPos,defaultPos),rest671) end
| (538,(_,(MlyValue.STRING STRING1,_,STRINGright as STRING1right))::_
::(_,(MlyValue.imp imp1,_,_))::(_,(_,IMPORTleft as IMPORT1left,_))::
rest671) => let val result=MlyValue.ann1(fn _ => let val imp as imp1=
imp1 ()
val STRING as STRING1=STRING1 ()
 in ( IMPORTAnn(I(IMPORTleft,STRINGright),
					    imp, STRING) ) end
)
 in (LrTable.NT 191,(result,IMPORT1left,STRING1right),rest671) end
| (539,(_,(MlyValue.strid strid1,_,stridright as strid1right))::(_,(_,
PREBOUNDleft as PREBOUND1left,_))::rest671) => let val result=
MlyValue.ann1(fn _ => let val strid as strid1=strid1 ()
 in ( PREBOUNDAnn(I(PREBOUNDleft,stridright),
					      strid) ) end
)
 in (LrTable.NT 191,(result,PREBOUND1left,strid1right),rest671) end
| (540,(_,(MlyValue.ann1 ann12,_,ann12right))::(_,(MlyValue.ann1 ann11
,ann11left,_))::rest671) => let val result=MlyValue.ann1(fn _ => let 
val ann11=ann11 ()
val ann12=ann12 ()
 in ( SEQAnn(I(ann11left,ann12right),
					 ann11, ann12) ) end
)
 in (LrTable.NT 191,(result,ann11left,ann12right),rest671) end
| (541,(_,(_,SEMICOLONleft as SEMICOLON1left,SEMICOLON1right))::
rest671) => let val result=MlyValue.ann1(fn _ => (
 EMPTYAnn(I(SEMICOLONleft,SEMICOLONleft)) ))
 in (LrTable.NT 191,(result,SEMICOLON1left,SEMICOLON1right),rest671)
 end
| (542,(_,(MlyValue.dec' dec'1,dec'left as dec'1left,dec'right as 
dec'1right))::rest671) => let val result=MlyValue.program(fn _ => let 
val dec' as dec'1=dec'1 ()
 in ( DECProgram(I(dec'left,dec'right),
				     dec', NONE) ) end
)
 in (LrTable.NT 192,(result,dec'1left,dec'1right),rest671) end
| (543,(_,(MlyValue.program_opt' program_opt'1,_,program_opt'right as 
program_opt'1right))::_::(_,(MlyValue.dec' dec'1,dec'left as dec'1left
,_))::rest671) => let val result=MlyValue.program(fn _ => let val dec'
 as dec'1=dec'1 ()
val program_opt' as program_opt'1=program_opt'1 ()
 in (
 DECProgram(I(dec'left,program_opt'right),
				     dec', program_opt') 
) end
)
 in (LrTable.NT 192,(result,dec'1left,program_opt'1right),rest671) end
| (544,(_,(MlyValue.program_opt' program_opt'1,_,program_opt'right as 
program_opt'1right))::_::(_,(MlyValue.exp exp1,expleft as exp1left,_))
::rest671) => let val result=MlyValue.program(fn _ => let val exp as 
exp1=exp1 ()
val program_opt' as program_opt'1=program_opt'1 ()
 in (
 EXPProgram(I(expleft,program_opt'right),
				     exp, program_opt') 
) end
)
 in (LrTable.NT 192,(result,exp1left,program_opt'1right),rest671) end
| (545,(_,(MlyValue.program program1,program1left,program1right))::
rest671) => let val result=MlyValue.program_opt(fn _ => let val 
program as program1=program1 ()
 in ( SOME program ) end
)
 in (LrTable.NT 193,(result,program1left,program1right),rest671) end
| (546,rest671) => let val result=MlyValue.program_opt(fn _ => ( NONE 
))
 in (LrTable.NT 193,(result,defaultPos,defaultPos),rest671) end
| (547,(_,(MlyValue.program_opt program_opt1,program_opt1left,
program_opt1right))::rest671) => let val result=MlyValue.program_opt'(
fn _ => let val program_opt as program_opt1=program_opt1 ()
 in ( program_opt ) end
)
 in (LrTable.NT 194,(result,program_opt1left,program_opt1right),
rest671) end
| (548,(_,(MlyValue.program_opt' program_opt'1,_,program_opt'1right))
::(_,(_,SEMICOLON1left,_))::rest671) => let val result=
MlyValue.program_opt'(fn _ => let val program_opt' as program_opt'1=
program_opt'1 ()
 in ( program_opt' ) end
)
 in (LrTable.NT 194,(result,SEMICOLON1left,program_opt'1right),rest671
) end
| (549,(_,(MlyValue.program_opt program_opt1,_,program_optright as 
program_opt1right))::(_,(MlyValue.ann0 ann01,ann0left as ann01left,_))
::rest671) => let val result=MlyValue.component(fn _ => let val ann0
 as ann01=ann01 ()
val program_opt as program_opt1=program_opt1 ()
 in (
 Component(I(ann0left,program_optright),
					    ann0, program_opt) )
 end
)
 in (LrTable.NT 195,(result,ann01left,program_opt1right),rest671) end
| _ => raise (mlyAction i392)
end
val void = MlyValue.VOID
val extract = fn a => (fn MlyValue.component x => x
| _ => let exception ParseInternal
	in raise ParseInternal end) a ()
end
end
structure Tokens : Parser_TOKENS =
struct
type svalue = ParserData.svalue
type ('a,'b) token = ('a,'b) Token.token
fun EOF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 0,(
ParserData.MlyValue.VOID,p1,p2))
fun ABSTYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 1,(
ParserData.MlyValue.VOID,p1,p2))
fun AND (p1,p2) = Token.TOKEN (ParserData.LrTable.T 2,(
ParserData.MlyValue.VOID,p1,p2))
fun ANDALSO (p1,p2) = Token.TOKEN (ParserData.LrTable.T 3,(
ParserData.MlyValue.VOID,p1,p2))
fun AS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 4,(
ParserData.MlyValue.VOID,p1,p2))
fun CASE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 5,(
ParserData.MlyValue.VOID,p1,p2))
fun DO (p1,p2) = Token.TOKEN (ParserData.LrTable.T 6,(
ParserData.MlyValue.VOID,p1,p2))
fun DATATYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 7,(
ParserData.MlyValue.VOID,p1,p2))
fun ELSE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 8,(
ParserData.MlyValue.VOID,p1,p2))
fun END (p1,p2) = Token.TOKEN (ParserData.LrTable.T 9,(
ParserData.MlyValue.VOID,p1,p2))
fun EXCEPTION (p1,p2) = Token.TOKEN (ParserData.LrTable.T 10,(
ParserData.MlyValue.VOID,p1,p2))
fun FN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 11,(
ParserData.MlyValue.VOID,p1,p2))
fun FUN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 12,(
ParserData.MlyValue.VOID,p1,p2))
fun HANDLE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 13,(
ParserData.MlyValue.VOID,p1,p2))
fun IF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 14,(
ParserData.MlyValue.VOID,p1,p2))
fun IN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 15,(
ParserData.MlyValue.VOID,p1,p2))
fun INFIX (p1,p2) = Token.TOKEN (ParserData.LrTable.T 16,(
ParserData.MlyValue.VOID,p1,p2))
fun INFIXR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 17,(
ParserData.MlyValue.VOID,p1,p2))
fun LET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 18,(
ParserData.MlyValue.VOID,p1,p2))
fun LOCAL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 19,(
ParserData.MlyValue.VOID,p1,p2))
fun NONFIX (p1,p2) = Token.TOKEN (ParserData.LrTable.T 20,(
ParserData.MlyValue.VOID,p1,p2))
fun OF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 21,(
ParserData.MlyValue.VOID,p1,p2))
fun OP (p1,p2) = Token.TOKEN (ParserData.LrTable.T 22,(
ParserData.MlyValue.VOID,p1,p2))
fun OPEN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 23,(
ParserData.MlyValue.VOID,p1,p2))
fun ORELSE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 24,(
ParserData.MlyValue.VOID,p1,p2))
fun RAISE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 25,(
ParserData.MlyValue.VOID,p1,p2))
fun REC (p1,p2) = Token.TOKEN (ParserData.LrTable.T 26,(
ParserData.MlyValue.VOID,p1,p2))
fun THEN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 27,(
ParserData.MlyValue.VOID,p1,p2))
fun TYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 28,(
ParserData.MlyValue.VOID,p1,p2))
fun VAL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 29,(
ParserData.MlyValue.VOID,p1,p2))
fun WITH (p1,p2) = Token.TOKEN (ParserData.LrTable.T 30,(
ParserData.MlyValue.VOID,p1,p2))
fun WITHTYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 31,(
ParserData.MlyValue.VOID,p1,p2))
fun WHILE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 32,(
ParserData.MlyValue.VOID,p1,p2))
fun LPAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 33,(
ParserData.MlyValue.VOID,p1,p2))
fun RPAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 34,(
ParserData.MlyValue.VOID,p1,p2))
fun LBRACK (p1,p2) = Token.TOKEN (ParserData.LrTable.T 35,(
ParserData.MlyValue.VOID,p1,p2))
fun RBRACK (p1,p2) = Token.TOKEN (ParserData.LrTable.T 36,(
ParserData.MlyValue.VOID,p1,p2))
fun LBRACE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 37,(
ParserData.MlyValue.VOID,p1,p2))
fun RBRACE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 38,(
ParserData.MlyValue.VOID,p1,p2))
fun COMMA (p1,p2) = Token.TOKEN (ParserData.LrTable.T 39,(
ParserData.MlyValue.VOID,p1,p2))
fun COLON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 40,(
ParserData.MlyValue.VOID,p1,p2))
fun SEMICOLON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 41,(
ParserData.MlyValue.VOID,p1,p2))
fun DOTS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 42,(
ParserData.MlyValue.VOID,p1,p2))
fun UNDERBAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 43,(
ParserData.MlyValue.VOID,p1,p2))
fun BAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 44,(
ParserData.MlyValue.VOID,p1,p2))
fun EQUALS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 45,(
ParserData.MlyValue.VOID,p1,p2))
fun DARROW (p1,p2) = Token.TOKEN (ParserData.LrTable.T 46,(
ParserData.MlyValue.VOID,p1,p2))
fun ARROW (p1,p2) = Token.TOKEN (ParserData.LrTable.T 47,(
ParserData.MlyValue.VOID,p1,p2))
fun HASH (p1,p2) = Token.TOKEN (ParserData.LrTable.T 48,(
ParserData.MlyValue.VOID,p1,p2))
fun CONSTRUCTOR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 49,(
ParserData.MlyValue.VOID,p1,p2))
fun NON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 50,(
ParserData.MlyValue.VOID,p1,p2))
fun WITHFUN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 51,(
ParserData.MlyValue.VOID,p1,p2))
fun WITHVAL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 52,(
ParserData.MlyValue.VOID,p1,p2))
fun DOT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 53,(
ParserData.MlyValue.VOID,p1,p2))
fun HASHBRACK (p1,p2) = Token.TOKEN (ParserData.LrTable.T 54,(
ParserData.MlyValue.VOID,p1,p2))
fun ANY (p1,p2) = Token.TOKEN (ParserData.LrTable.T 55,(
ParserData.MlyValue.VOID,p1,p2))
fun FCT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 56,(
ParserData.MlyValue.VOID,p1,p2))
fun PACK (p1,p2) = Token.TOKEN (ParserData.LrTable.T 57,(
ParserData.MlyValue.VOID,p1,p2))
fun UNPACK (p1,p2) = Token.TOKEN (ParserData.LrTable.T 58,(
ParserData.MlyValue.VOID,p1,p2))
fun IMPORT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 59,(
ParserData.MlyValue.VOID,p1,p2))
fun FROM (p1,p2) = Token.TOKEN (ParserData.LrTable.T 60,(
ParserData.MlyValue.VOID,p1,p2))
fun PRIMITIVE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 61,(
ParserData.MlyValue.VOID,p1,p2))
fun OVERLOAD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 62,(
ParserData.MlyValue.VOID,p1,p2))
fun INSTANCE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 63,(
ParserData.MlyValue.VOID,p1,p2))
fun PREBOUND (p1,p2) = Token.TOKEN (ParserData.LrTable.T 64,(
ParserData.MlyValue.VOID,p1,p2))
fun EQEQTYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 65,(
ParserData.MlyValue.VOID,p1,p2))
fun EQTYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 66,(
ParserData.MlyValue.VOID,p1,p2))
fun FUNCTOR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 67,(
ParserData.MlyValue.VOID,p1,p2))
fun INCLUDE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 68,(
ParserData.MlyValue.VOID,p1,p2))
fun SHARING (p1,p2) = Token.TOKEN (ParserData.LrTable.T 69,(
ParserData.MlyValue.VOID,p1,p2))
fun SIG (p1,p2) = Token.TOKEN (ParserData.LrTable.T 70,(
ParserData.MlyValue.VOID,p1,p2))
fun SIGNATURE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 71,(
ParserData.MlyValue.VOID,p1,p2))
fun STRUCT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 72,(
ParserData.MlyValue.VOID,p1,p2))
fun STRUCTURE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 73,(
ParserData.MlyValue.VOID,p1,p2))
fun WHERE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 74,(
ParserData.MlyValue.VOID,p1,p2))
fun COLONGREATER (p1,p2) = Token.TOKEN (ParserData.LrTable.T 75,(
ParserData.MlyValue.VOID,p1,p2))
fun ZERO (p1,p2) = Token.TOKEN (ParserData.LrTable.T 76,(
ParserData.MlyValue.VOID,p1,p2))
fun DIGIT (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 77,(
ParserData.MlyValue.DIGIT (fn () => i),p1,p2))
fun NUMERIC (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 78,(
ParserData.MlyValue.NUMERIC (fn () => i),p1,p2))
fun INT (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 79,(
ParserData.MlyValue.INT (fn () => i),p1,p2))
fun WORD (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 80,(
ParserData.MlyValue.WORD (fn () => i),p1,p2))
fun REAL (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 81,(
ParserData.MlyValue.REAL (fn () => i),p1,p2))
fun STRING (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 82,(
ParserData.MlyValue.STRING (fn () => i),p1,p2))
fun CHAR (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 83,(
ParserData.MlyValue.CHAR (fn () => i),p1,p2))
fun ALPHA (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 84,(
ParserData.MlyValue.ALPHA (fn () => i),p1,p2))
fun SYMBOL (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 85,(
ParserData.MlyValue.SYMBOL (fn () => i),p1,p2))
fun STAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 86,(
ParserData.MlyValue.VOID,p1,p2))
fun TYVAR (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 87,(
ParserData.MlyValue.TYVAR (fn () => i),p1,p2))
fun ETYVAR (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 88,(
ParserData.MlyValue.ETYVAR (fn () => i),p1,p2))
end
end
(* src # 115 ../frontend-sml/DerivedForms.sml *)
(*
 * Standard ML derived forms
 *
 * Definition, Appendix A
 *
 * Extensions and modifications:
 *   - predefined ids are taken out of a pseudo structure with empty name
 *   - recursive expressions:
 *	rec pat => exp     ==>     let val rec x as pat = exp in x end
 *     where x is a fresh identifier.
 *   - exception declarations have been made a derived form:
 *	exception exbind          ==>  constructor exbind'
 *	vid <of ty> <and exbind>  ==>  vid <of ty> : exn <and exbind'>
 *   - abstype has been made a derived form:
 *	abstype datbind <withtype tybind> with dec end
 *	  ==>
 *	<type typbind> local datatype datbind in type typbind' dec end
 *     where typbind' contains a binding t = t for each tycon t bound in
 *     datbind. Note that this results in a different treatment of equality.
 *   - include takes longsigids:
 *	include longsigid_1 ... longsigid_n
 *	==>
 *	include longsigid_1 ; ... ; include longsigid_n
 *   - derived forms for primitive declarations similar to specifications:
 *   - where constraints have been made a derived form of intersection:
 *	sigexp where type tyvarseq strid_1....strid_n.tycon = ty
 *	==>
 *      sigexp where sig structure strid_1 :
 *			...
 *			   sig structure strid_n :
 *			      sig type tyvarseq tycon = ty end
 *			   end
 *			...
 *		     end
 *
 *	sigexp where strid_1....strid_n.strid = longstrid
 *	==>
 *      sigexp where sig structure strid_1 :
 *			...
 *			   sig structure strid_n :
 *			      sig structure strid = longstrid end
 *			   end
 *			...
 *		     end
 *
 * We did NOT introduce a sharing signature ... and signature ... derived form
 * similar to types, because we consider that one completely broken.
 *
 * Notes:
 * - Two phrases named Fmatch and Fmrule have been added to factorize FvalBind.
 * - A phrase named TyReaDesc has been added to factorize type
 *   realisation signature expressions.
 * - In Fvalbinds we do not enforce that all optional type annotations are
 *   syntactically identical (as the Definition enforces, although this seems
 *   to be a mistake).
 * - The Definition is somewhat inaccurate about the derived forms of Exp
 *   [Definition, Appendix A, Figure 15] in that most forms are actually AtExp
 *   derived forms, as can be seen from the full grammar [Definition,
 *   Appendix B, Figure 20]. To achieve consistency, the equivalent forms must
 *   be put in parentheses in some case.
 * - The same goes for pattern derived forms [Definition, Appendix A, Figure 16;
 *   Appendix B, Figure 22].
 *)


structure DerivedForms :> DERIVED_FORMS =
  struct

    (* Import *)

    structure Grammar = InputGrammar
    structure G       = Grammar
    structure E       = ParsingError

    type Info      = Grammar.Info

    type Lab       = Grammar.Lab
    type VId       = Grammar.VId
    type StrId     = Grammar.StrId
    type LongVId   = Grammar.LongVId
    type LongTyCon = Grammar.LongTyCon
    type LongStrId = Grammar.LongStrId
    type LongSigId = Grammar.LongSigId

    type Op        = Grammar.Op
    type AtExp     = Grammar.AtExp
    type AppExp    = Grammar.Exp
    type InfExp    = Grammar.Exp
    type Exp       = Grammar.Exp
    type ExpRow    = Grammar.ExpRow
    type Match     = Grammar.Match
    type Mrule     = Grammar.Mrule
    type Dec       = Grammar.Dec
    type ValBind   = Grammar.ValBind
    type FvalBind  = Grammar.FvalBind
    type ExBind    = Grammar.DconBind
    type Fmatch    = Grammar.Match
    type Fmrule    = Grammar.Mrule
    type Fpat      = Grammar.Pat
    type TypBind   = Grammar.TypBind
    type DatBind   = Grammar.DatBind
    type AtPat     = Grammar.AtPat
    type PatRow    = Grammar.PatRow
    type Pat       = Grammar.Pat
    type Ty        = Grammar.Ty
    type TyVarSeq  = Grammar.TyVarSeq
    type AtStrExp  = Grammar.AtStrExp
    type AppStrExp = Grammar.StrExp
    type StrExp    = Grammar.StrExp
    type StrPat    = Grammar.StrPat
    type StrBind   = Grammar.StrBind
    type FunBind   = Grammar.StrBind
    type AppSigExp = Grammar.SigExp
    type SigExp    = Grammar.SigExp
    type Spec      = Grammar.Spec
    type ValDesc   = Grammar.ValDesc
    type TypDesc   = Grammar.TypDesc
    type DatDesc   = Grammar.DatDesc
    type ExDesc    = Grammar.DconDesc
    type FunDesc   = Grammar.StrDesc
    type Imp       = Grammar.Imp
    type ValItem   = Grammar.ValItem
    type TypItem   = Grammar.TypItem
    type DatItem   = Grammar.DatItem
    type ExItem    = Grammar.DconItem
    type FunItem   = Grammar.StrItem
    type Program   = Grammar.Program


    (* Additional types *)

    type AppExp = Exp
    type InfExp = Exp

    type Fmatch = Match
    type Fmrule = Mrule
    type Fpat   = Pat

    type TyReaDesc = (G.Info * G.TyVarSeq * G.LongTyCon * G.Ty) list

    (* Some helpers *)

    fun strid_PREBOUND(I)	= G.StrId(I, StrId.fromString "")
    fun longstrid_PREBOUND(I)	= G.SHORTLong(I, strid_PREBOUND(I))
    fun longvid(I, vid)		= G.DOTLong(I, longstrid_PREBOUND(I), vid)
    fun longtycon(I, tycon)	= G.DOTLong(I, longstrid_PREBOUND(I), tycon)

    fun vid_NIL(I)		= G.VId(I, VId.fromString "nil")
    fun vid_CONS(I)		= G.VId(I, VId.fromString "::")
    fun longvid_NIL(I)		= longvid(I, vid_NIL(I))
    fun longvid_CONS(I)		= longvid(I, vid_CONS(I))

    fun LONGVIDExp(I, longvid)	= G.ATEXPExp(I, G.LONGVIDAtExp(I, G.WITHOp,
								  longvid))
    fun LONGVIDPat(I, longvid)	= G.ATPATPat(I, G.LONGVIDAtPat(I, G.WITHOp,
								  longvid))
    fun VIDExp(I, vid)		= LONGVIDExp(I, G.SHORTLong(I, vid))
    fun VIDPat(I, vid)		= LONGVIDPat(I, G.SHORTLong(I, vid))

    fun NILExp(I)		= LONGVIDExp(I, longvid_NIL(I))
    fun CONSExp(I)		= LONGVIDExp(I, longvid_CONS(I))
    fun NILPat(I)		= LONGVIDPat(I, longvid_NIL(I))
    fun CONSPat(I)		= LONGVIDPat(I, longvid_CONS(I))

    fun tycon_EXN(I)		= G.TyCon(I, TyCon.fromString "exn")
    fun longtycon_EXN(I)	= longtycon(I, tycon_EXN(I))


    (* Functions to handle rewriting of withtype declarations *)

    fun equalTyCon(G.TyCon(_,tycon1), G.TyCon(_,tycon2)) = tycon1 = tycon2
    fun equalTyVar(G.TyVar(_,tyvar1), G.TyVar(_,tyvar2)) = tyvar1 = tyvar2

    fun lookupTyCon(tycon, G.NEWTypBind(i, tyvarseq, tycon', typbind_opt)) =
	    E.error(i, E.WithtypeInvalid)

      | lookupTyCon(tycon, G.EQUALTypBind(_,tyvarseq,tycon', ty, typbind_opt)) =
	    if equalTyCon(tycon, tycon') then
		(tyvarseq, ty)
	    else
	  	lookupTyCon(tycon, Option.valOf typbind_opt)
		(* may raise Option *)


    fun replaceTy (G.Seq(_,tyvars), G.Seq(_,tys)) (ty as G.TYVARTy(i, tyvar)) =
	let
	    fun loop(tyvar'::tyvars', ty'::tys') =
		    if equalTyVar(tyvar, tyvar') then
			ty'
		    else
			loop(tyvars', tys')
	      | loop([], _) =
		    ty
	      | loop(_, []) =
		    E.error(i, E.WithtypeArityMismatch)
	in
	    loop(tyvars, tys)
	end

      | replaceTy tyvarseq_tyseq (G.RECORDTy(I, tyrow_opt)) =
	    G.RECORDTy(I, Option.map (replaceTyRow tyvarseq_tyseq) tyrow_opt)

      | replaceTy tyvarseq_tyseq (G.TUPLETy(I, tys)) =
	    G.TUPLETy(I, List.map (replaceTy tyvarseq_tyseq) tys)

      | replaceTy tyvarseq_tyseq (G.TYCONTy(I, tyseq', tycon)) =
	    G.TYCONTy(I, replaceTySeq tyvarseq_tyseq tyseq', tycon)

      | replaceTy tyvarseq_tyseq (G.ARROWTy(I, ty1, ty2)) =
	    G.ARROWTy(I, replaceTy tyvarseq_tyseq ty1,
			 replaceTy tyvarseq_tyseq ty2)

      | replaceTy tyvarseq_tyseq (ty as G.PACKTy _) =
	    ty

      | replaceTy tyvarseq_tyseq (G.PARTy(I, ty)) =
	    G.PARTy(I, replaceTy tyvarseq_tyseq ty)

    and replaceTyRow tyvarseq_tyseq (G.ROWTyRow(I, lab, ty, tyrow_opt)) =
	    G.ROWTyRow(I, lab, replaceTy tyvarseq_tyseq ty, 
			  Option.map (replaceTyRow tyvarseq_tyseq) tyrow_opt)

    and replaceTySeq tyvarseq_tyseq (G.Seq(I, tys)) =	  
	    G.Seq(I, List.map (replaceTy tyvarseq_tyseq) tys)


    fun rewriteTy typbind (ty as G.TYVARTy _) = ty

      | rewriteTy typbind (G.RECORDTy(I, tyrow_opt)) =
	    G.RECORDTy(I, Option.map (rewriteTyRow typbind) tyrow_opt)

      | rewriteTy typbind (G.TUPLETy(I, tys)) =
	    G.TUPLETy(I, List.map (rewriteTy typbind) tys)

      | rewriteTy typbind (ty as G.TYCONTy(I, tyseq, longtycon as G.DOTLong _))=
	    G.TYCONTy(I, rewriteTySeq typbind tyseq, longtycon)

      | rewriteTy typbind (ty as G.TYCONTy(I, tyseq,
					  longtycon as G.SHORTLong(_, tycon))) =
	let 
	    val tyseq' = rewriteTySeq typbind tyseq
	in
	    let
		val (tyvarseq', ty') = lookupTyCon(tycon, typbind)
	    in
		replaceTy (tyvarseq',tyseq') ty'
	    end
	    handle Option => G.TYCONTy(I, tyseq', longtycon)
	end

      | rewriteTy typbind (G.ARROWTy(I, ty1, ty2)) =
	    G.ARROWTy(I, rewriteTy typbind ty1, rewriteTy typbind ty2)

      | rewriteTy typbind (ty as G.PACKTy _) =
	    ty

      | rewriteTy typbind (G.PARTy(I, ty)) =
	    G.PARTy(I, rewriteTy typbind ty)

    and rewriteTyRow typbind (G.ROWTyRow(I, lab, ty, tyrow_opt)) =
	    G.ROWTyRow(I, lab, rewriteTy typbind ty,
			  Option.map (rewriteTyRow typbind) tyrow_opt)

    and rewriteTySeq typbind (G.Seq(I, tys)) =
	    G.Seq(I, List.map (rewriteTy typbind) tys)

    fun rewriteConBind typbind (G.ConBind(I, op_opt, vid, ty_opt, conbind_opt))=
	    G.ConBind(I, op_opt, vid,
			 Option.map (rewriteTy typbind) ty_opt,
			 Option.map (rewriteConBind typbind) conbind_opt)

    fun rewriteDatBind typbind (G.CLOSEDDatBind(I, tyvarseq, tycon, conbind,
							      datbind_opt)) =
	    G.CLOSEDDatBind(I, tyvarseq, tycon, rewriteConBind typbind conbind,
			       Option.map (rewriteDatBind typbind) datbind_opt)
      | rewriteDatBind typbind (G.OPENDatBind(I, tyvarseq, tycon,
							      datbind_opt)) =
	    G.OPENDatBind(I, tyvarseq, tycon,
			     Option.map (rewriteDatBind typbind) datbind_opt)


    fun toTy tyvar = G.TYVARTy(G.infoTyVar tyvar, tyvar)

    fun toTypBind(G.NEWTypDesc(I, tyvarseq, tycon, typdesc_opt)) =
	    G.NEWTypBind(I, tyvarseq, tycon, Option.map toTypBind typdesc_opt)

      | toTypBind(G.EQUALTypDesc(I, tyvarseq, tycon, ty, typdesc_opt)) =
	    G.EQUALTypBind(I, tyvarseq, tycon, ty,
			      Option.map toTypBind typdesc_opt)

    (* Functions to handle rewriting of withtype specifications *)

    fun rewriteConDesc typbind (G.ConDesc(I, op_opt, vid, ty_opt, condesc_opt))=
	    G.ConDesc(I, op_opt, vid,
			 Option.map (rewriteTy typbind) ty_opt,
			 Option.map (rewriteConDesc typbind) condesc_opt)

    fun rewriteDatDesc typbind (G.CLOSEDDatDesc(I, tyvarseq, tycon, condesc,
							      datdesc_opt)) =
	    G.CLOSEDDatDesc(I, tyvarseq, tycon, rewriteConDesc typbind condesc,
			       Option.map (rewriteDatDesc typbind) datdesc_opt)
      | rewriteDatDesc typbind (G.OPENDatDesc(I, tyvarseq, tycon,
							      datdesc_opt)) =
	    G.OPENDatDesc(I, tyvarseq, tycon,
			     Option.map (rewriteDatDesc typbind) datdesc_opt)


    (* Rewriting of abstype *)

    fun toTy tyvar = G.TYVARTy(G.infoTyVar tyvar, tyvar)

    fun redeclare ( G.CLOSEDDatBind(I, tyvarseq, tycon, _, datbind_opt)
		  | G.OPENDatBind(I, tyvarseq, tycon, datbind_opt)) =
	let
	    val G.Seq(I',tyvarseq') = tyvarseq
	    val tyseq     = G.Seq(I', List.map toTy tyvarseq')
	    val I_tycon   = G.infoTyCon tycon
	    val longtycon = G.SHORTLong(I_tycon, tycon)
	    val ty        = G.TYCONTy(I_tycon, tyseq,longtycon)
	in
	    G.EQUALTypBind(I, tyvarseq, tycon, ty,
			      Option.map redeclare datbind_opt)
	end



    (* Patterns *)

    fun UNITAtPat(I) = G.TUPLEAtPat(I, [])

    val TUPLEAtPat   = G.TUPLEAtPat
    val WITHFUNPat   = G.WITHFUNPat

    fun LISTAtPat(I, pats) =
	let
	    fun toPatList []          = NILPat(I)
	      | toPatList(pat::pats') =
		G.APPPat(I, CONSPat(I), TUPLEAtPat(I, [pat,toPatList pats']))
	in
	    G.PARAtPat(I, toPatList pats)
	end


    fun VIDPatRow(I, vid as G.VId(I',vid'), ty_opt, pat_opt, patrow_opt) =
	let
	    val lab    = G.Lab(I', Lab.fromString(VId.toString vid'))
	    val vidPat = VIDPat(I', vid)
	    val pat1   = case ty_opt
			   of NONE    => vidPat
			    | SOME ty => G.TYPEDPat(I, vidPat, ty)
	    val pat    = case pat_opt
			   of NONE      => pat1
			    | SOME pat' => G.ASPat(I, pat1, pat')
	in
	    G.ROWPatRow(I, lab, pat, patrow_opt)
	end



    (* Expressions *)

    fun UNITAtExp(I) = G.TUPLEAtExp(I, [])

    val TUPLEAtExp   = G.TUPLEAtExp
    val HASHAtExp    = G.HASHAtExp
    val CASEExp      = G.CASEExp
    val IFExp        = G.IFExp
    val ORELSEExp    = G.ORELSEExp
    val ANDALSOExp   = G.ANDALSOExp
    val WHILEExp     = G.WHILEExp
    val SEQAtExp     = G.SEQAtExp

    fun LETAtExp(I, dec, [exp]) = G.LETAtExp(I, dec, exp)
      | LETAtExp(I, dec,  exps) =
	    G.LETAtExp(I, dec, G.ATEXPExp(I, SEQAtExp(I, exps)))

    fun LISTAtExp(I, exps) =
	let
	    fun toExpList []          = NILExp(I)
	      | toExpList(exp::exps') =
		  G.APPExp(I, CONSExp(I), TUPLEAtExp(I, [exp, toExpList exps']))
	in
	    G.PARAtExp(I, toExpList exps)
	end

    fun RECExp(I, pat, exp) =
	let
	    val I'      = G.infoPat pat
	    val vid     = G.VId(I', VId.invent())
	    val asPat   = G.ASPat(I', VIDPat(I', vid), pat)
	    val valbind = G.RECValBind(I, G.PLAINValBind(I, asPat, exp, NONE))
	    val dec     = G.VALDec(I, G.Seq(I',[]), valbind)
	in
	    G.ATEXPExp(I, G.LETAtExp(I, dec, VIDExp(I', vid)))
	end


    fun VIDExpRow(I, vid as G.VId(I',vid'), ty_opt, exprow_opt) =
	let
	    val lab    = G.Lab(I', Lab.fromString(VId.toString vid'))
	    val vidExp = VIDExp(I', vid)
	    val exp    = case ty_opt
			   of NONE    => vidExp
			    | SOME ty => G.TYPEDExp(I, vidExp, ty)
	in
	    G.ROWExpRow(I, lab, exp, exprow_opt)
	end


    (* Types *)

    fun TUPLETy(I, [ty]) = ty
      | TUPLETy(I,  tys) = G.TUPLETy(I, tys)


    (* Declarations *)

    val FUNDec       = G.FUNDec
    val EXCEPTIONDec = G.CONSTRUCTORDec
    val FUNCTORDec   = G.STRUCTUREDec
    val FvalBind     = G.FvalBind
    val EQUALExBind  = G.EQUALDconBind
    val Fmatch       = G.Match
    val Fmrule       = G.Mrule

    fun Fpat p       = p


    fun DATATYPEDec(I, datbind, NONE)         = G.DATATYPEDec(I, datbind)
      | DATATYPEDec(I, datbind, SOME typbind) =
	let
	    val datbind' = rewriteDatBind typbind datbind
	in
	    G.SEQDec(I, G.DATATYPEDec(G.infoDatBind datbind, datbind'),
			G.TYPEDec(G.infoTypBind typbind, typbind))
	end

    fun ABSTYPEDec(I, datbind, NONE, dec) =
	let
	    val datatypeDec = G.DATATYPEDec(I, datbind)
	    val typeDec     = G.TYPEDec(I, redeclare datbind)
	in
	    G.LOCALDec(I, datatypeDec, G.SEQDec(I, typeDec, dec))
	end

      | ABSTYPEDec(I, datbind, SOME typbind, dec) =
	let
	    val I'          = G.infoTypBind typbind
	    val datbind'    = rewriteDatBind typbind datbind
	    val datatypeDec = G.DATATYPEDec(I, datbind')
	    val typeDec     = G.TYPEDec(I, redeclare datbind')
	in
	    G.SEQDec(I, G.TYPEDec(I', typbind),
			G.LOCALDec(I, datatypeDec, G.SEQDec(I, typeDec, dec)))
	end


    fun OPENMULTIDec(I, [])                    = G.EMPTYDec(I)
      | OPENMULTIDec(I, longstrid::longstrids) =
	    G.SEQDec(I, G.OPENDec(I,longstrid), OPENMULTIDec(I,longstrids))

    fun INFIXMULTIDec(I, _, [])          = G.EMPTYDec(I)
      | INFIXMULTIDec(I, NONE, longvids) = INFIXMULTIDec(I, SOME 0, longvids)
      | INFIXMULTIDec(I, SOME d, longvid::longvids) =
	    G.SEQDec(I, G.INFIXDec(I, d, longvid),
			INFIXMULTIDec(I, SOME d, longvids))

    fun INFIXRMULTIDec(I, _, [])          = G.EMPTYDec(I)
      | INFIXRMULTIDec(I, NONE, longvids) = INFIXRMULTIDec(I, SOME 0, longvids)
      | INFIXRMULTIDec(I, SOME d, longvid::longvids) =
	    G.SEQDec(I, G.INFIXRDec(I, d, longvid),
			INFIXRMULTIDec(I, SOME d, longvids))

    fun NONFIXMULTIDec(I, [])                = G.EMPTYDec(I)
      | NONFIXMULTIDec(I, longvid::longvids) =
	    G.SEQDec(I, G.NONFIXDec(I,longvid), NONFIXMULTIDec(I,longvids))


    fun NEWExBind(I, op_opt, vid, ty_opt, dconbind_opt) =
	    G.NEWDconBind(I, op_opt, vid, ty_opt,
			     G.Seq(I,[]), longtycon_EXN(I), dconbind_opt)
 

    (* Structure bindings *)

    fun TRANSStrBind(I, strid, NONE, strexp, strbind_opt) =
	    G.StrBind(I, strid, strexp, strbind_opt)

      | TRANSStrBind(I, strid, SOME sigexp, strexp, strbind_opt) =
	    G.StrBind(I, strid, G.TRANSStrExp(I, strexp, sigexp), strbind_opt)

    fun OPAQStrBind(I, strid, sigexp, strexp, strbind_opt) =
	    G.StrBind(I, strid, G.OPAQStrExp(I, strexp, sigexp), strbind_opt)

    fun WILDCARDStrBind(I, sigexp_opt, strexp, strbind_opt) =
	    TRANSStrBind(I, G.StrId(I, StrId.invent()),
			 sigexp_opt, strexp, strbind_opt)


    (* Structure expressions *)

    val DECAtStrExp = G.STRUCTAtStrExp
    val STRIDStrPat = G.StrPat

    fun FCTStrExp(I, strpat as G.StrPat(I1, G.StrId(I2, strid'), sigexp),
		     strexp) =
	if StrId.toString strid' <> "" then
	    G.FCTStrExp(I, strpat, strexp)
	else
	let
	    val I3     = G.infoStrExp strexp
	    val strid  = G.StrId(I2, StrId.invent())

	    val dec    = G.OPENDec(I3, G.SHORTLong(I3, strid))
	    val letexp = G.ATSTREXPStrExp(I3, G.LETAtStrExp(I3, dec, strexp))
	in
	    G.FCTStrExp(I, G.StrPat(I1, strid, sigexp), letexp)
	end

    fun WILDCARDStrPat(I, sigexp) =
	    G.StrPat(I, G.StrId(I, StrId.invent()), sigexp)

    fun SPECStrPat(I, spec) =
	let
	    val I' = G.infoSpec spec
	in
	    G.StrPat(I, G.StrId(I, StrId.fromString ""),
		     G.ATSIGEXPSigExp(I', G.SIGAtSigExp(I', spec)))
	end


    (* Functor bindings *)

    fun FunBind(I, strid, strpats, strexp, funbind_opt) =
	let
	    val I' = G.infoStrExp strexp

	    fun buildStrExp       []         = strexp
	      | buildStrExp(strpat::strpats) =
		    FCTStrExp(Source.over(G.infoStrPat strpat, I'),
			      strpat, buildStrExp strpats)
	in
	    G.StrBind(I, strid, buildStrExp strpats, funbind_opt)
	end

    fun TRANSFunBind(I, strid, strpats, NONE, strexp, funbind_opt) =
	    FunBind(I, strid, strpats, strexp, funbind_opt)

      | TRANSFunBind(I, strid, strpats, SOME sigexp, strexp, funbind_opt) =
	    FunBind(I, strid, strpats, G.TRANSStrExp(I, strexp, sigexp),
		       funbind_opt)

    fun OPAQFunBind(I, strid, strpats, sigexp, strexp, funbind_opt) =
	    FunBind(I, strid, strpats, G.OPAQStrExp(I, strexp, sigexp),
		       funbind_opt)


    (* Specifications *)

    val FUNSpec       = G.VALSpec
    val SHARINGSpec   = G.SHARINGSpec
    val EXCEPTIONSpec = G.CONSTRUCTORSpec
    val FUNCTORSpec   = G.STRUCTURESpec
    val EQUALExDesc   = G.EQUALDconDesc

    fun DATATYPESpec(I, datdesc, NONE)         = G.DATATYPESpec(I, datdesc)
      | DATATYPESpec(I, datdesc, SOME typdesc) =
	let
	    val datdesc' = rewriteDatDesc (toTypBind typdesc) datdesc
	in
	    G.SEQSpec(I, G.DATATYPESpec(G.infoDatDesc datdesc, datdesc'),
			 G.TYPESpec(G.infoTypDesc typdesc, typdesc))
	end

    fun INCLUDEMULTISpec(I, [])             = G.EMPTYSpec(I)
      | INCLUDEMULTISpec(I, longsigid::longsigids') =
	let
	    val sigexp = G.ATSIGEXPSigExp(I, G.LONGSIGIDAtSigExp(I, longsigid))
	    val spec1  = G.INCLUDESpec(I, sigexp)
	in
	    G.SEQSpec(I, spec1, INCLUDEMULTISpec(I, longsigids'))
	end

    fun INFIXMULTISpec(I, _, [])          = G.EMPTYSpec(I)
      | INFIXMULTISpec(I, NONE, longvids) = INFIXMULTISpec(I, SOME 0, longvids)
      | INFIXMULTISpec(I, SOME d, longvid::longvids) =
	    G.SEQSpec(I, G.INFIXSpec(I, d, longvid),
			 INFIXMULTISpec(I, SOME d, longvids))

    fun INFIXRMULTISpec(I, _, [])          = G.EMPTYSpec(I)
      | INFIXRMULTISpec(I, NONE, longvids) = INFIXRMULTISpec(I, SOME 0,longvids)
      | INFIXRMULTISpec(I, SOME d, longvid::longvids) =
	    G.SEQSpec(I, G.INFIXRSpec(I, d, longvid),
			 INFIXRMULTISpec(I, SOME d, longvids))

    fun NONFIXMULTISpec(I, [])                = G.EMPTYSpec(I)
      | NONFIXMULTISpec(I, longvid::longvids) =
	    G.SEQSpec(I, G.NONFIXSpec(I,longvid), NONFIXMULTISpec(I,longvids))


    fun NEWExDesc(I, op_opt, vid, ty_opt, dcondesc_opt) =
	    G.NEWDconDesc(I, op_opt, vid, ty_opt, G.Seq(I,[]),
			  longtycon_EXN(I), dcondesc_opt)

    fun FunDesc(I, strid, strpats, sigexp, fundesc_opt) =
	let
	    val I' = G.infoSigExp sigexp

	    fun buildSigExp       []         = sigexp
	      | buildSigExp(strpat::strpats) =
		    FCTSigExp(Source.over(G.infoStrPat strpat, I'),
			      strpat, buildSigExp strpats)
	in
	    G.NEWStrDesc(I, strid, buildSigExp strpats, fundesc_opt)
	end


    (* Signature expressions *)

    and FCTSigExp(I, strpat as G.StrPat(I1, G.StrId(I2, strid'), sigexp1),
		     sigexp) =
	if StrId.toString strid' <> "" then
	    G.FCTSigExp(I, strpat, sigexp)
	else
	let
	    val I3     = G.infoSigExp sigexp
	    val strid  = G.StrId(I2, StrId.invent())

	    val dec    = G.OPENDec(I3, G.SHORTLong(I3, strid))
	    val letexp = G.ATSIGEXPSigExp(I3, G.LETAtSigExp(I3, dec, sigexp))
	in
	    G.FCTSigExp(I, G.StrPat(I1, strid, sigexp1), letexp)
	end


    datatype Rea =
	  VALRea         of Info * Op * LongVId * Op * LongVId * Rea option
	| CONSTRUCTORRea of Info * Op * LongVId * Op * LongVId * Rea option
	| TYPERea        of Info * TyVarSeq * LongTyCon * Ty * Rea option
	| STRUCTURERea   of Info * LongStrId * SigExp option * LongStrId
							     * Rea option
	| SIGNATURERea   of Info * LongSigId * StrPat list * AppSigExp
							   * Rea option

    val FUNRea       = VALRea
    val EXCEPTIONRea = CONSTRUCTORRea
    val FUNCTORRea   = STRUCTURERea


    fun buildValSpec (op_opt1, op_opt2, longvid) (I, vid) =
	    G.VALSpec(I, G.EQUALValDesc(I, op_opt1, vid,
					   op_opt2, longvid, NONE))
    fun buildDconSpec (op_opt1, op_opt2, longvid) (I, vid) =
	    G.CONSTRUCTORSpec(I, G.EQUALDconDesc(I, op_opt1, vid,
						    op_opt2, longvid, NONE))
    fun buildTypSpec (tyvarseq, ty) (I, tycon) =
	    G.TYPESpec(I, G.EQUALTypDesc(I, tyvarseq, tycon, ty, NONE))
    fun buildStrSpec (sigexp_opt, longstrid) (I, strid) =
	    G.STRUCTURESpec(I, G.EQUALStrDesc(I, strid, sigexp_opt,
						 longstrid, NONE))
    fun buildSigSpec (strpats, sigexp) (I, sigid) =
	    G.SIGNATURESpec(I, G.EQUALSigDesc(I, sigid, strpats, sigexp, NONE))


    fun buildSigExp(buildInnerSpec, I, longid, rea_opt) =
	let
	    val (strids,id) = G.explodeLong longid

	    fun buildSpec      []        = buildInnerSpec(I, id)
	      | buildSpec(strid::strids) =
		  G.STRUCTURESpec(I,
			G.NEWStrDesc(I, strid, buildSigExp strids, NONE))

	    and buildSigExp strids =
		  G.ATSIGEXPSigExp(I,
			G.SIGAtSigExp(I, buildSpec strids))
	in
	    ( buildSigExp strids, rea_opt )
	end


    fun Rea(VALRea(I, op_opt1, longvid1, op_opt2, longvid2, rea_opt)) =
	    buildSigExp(buildValSpec(op_opt1, op_opt2, longvid2),
			I, longvid1, rea_opt)
      | Rea(CONSTRUCTORRea(I, op_opt1, longvid1, op_opt2, longvid2, rea_opt)) =
	    buildSigExp(buildDconSpec(op_opt1, op_opt2, longvid2),
			I, longvid1, rea_opt)
      | Rea(TYPERea(I, tyvarseq, longtycon, ty, rea_opt)) =
	    buildSigExp(buildTypSpec(tyvarseq, ty), I, longtycon, rea_opt)
      | Rea(STRUCTURERea(I, longstrid1, sigexp_opt, longstrid2, rea_opt)) =
	    buildSigExp(buildStrSpec(sigexp_opt, longstrid2),
			I, longstrid1, rea_opt)
      | Rea(SIGNATURERea(I, longsigid, strpats, sigexp, rea_opt)) =
	    buildSigExp(buildSigSpec(strpats, sigexp), I, longsigid, rea_opt)

    fun WHEREREASigExp'(I, sigexp, NONE)     = sigexp
      | WHEREREASigExp'(I, sigexp, SOME rea) =
	let
	    val (sigexp2,rea_opt) = Rea rea
	    val  I'               = Source.over(I, G.infoSigExp sigexp2)
	    val  sigexp'          = G.WHERESigExp(I', sigexp, sigexp2)
	in
	    WHEREREASigExp'(I, sigexp', rea_opt)
	end

    fun WHEREREASigExp(I, sigexp, rea) = WHEREREASigExp'(I, sigexp, SOME rea)


    fun WHERELONGSTRIDSigExp(I, sigexp, longstrid1, longstrid2) =
	let
	    val I' = Source.over(G.infoLong longstrid1, G.infoLong longstrid2)
	in
	    WHEREREASigExp(I, sigexp,
			   STRUCTURERea(I', longstrid1, NONE, longstrid2, NONE))
	end



    (* Imports *)

    val FUNImp       = G.VALImp
    val EXCEPTIONImp = G.CONSTRUCTORImp
    val FUNCTORImp   = G.STRUCTUREImp
    val PLAINExItem  = G.PLAINDconItem
    val PLAINFunItem = G.PLAINStrItem

    fun DESCExItem(I, op_opt, vid, ty, dconitem_opt) =
	    G.DESCDconItem(I, op_opt, vid, SOME ty, G.Seq(I,[]),
			      longtycon_EXN(I), dconitem_opt)

    fun DESCFunItem(I, strid, strpats, sigexp, funitem_opt) =
	let
	    val I' = G.infoSigExp sigexp

	    fun buildSigExp       []         = sigexp
	      | buildSigExp(strpat::strpats) =
		    FCTSigExp(Source.over(G.infoStrPat strpat, I'),
			      strpat, buildSigExp strpats)
	in
	    G.DESCStrItem(I, strid, buildSigExp strpats, funitem_opt)
	end


    (* Programs *)

    fun DECProgram(I, dec, program_opt) =
	    G.Program(I, dec, program_opt)

    fun EXPProgram(I, exp, program_opt) =
	let
	    val longvid = G.SHORTLong(I, G.VId(I, VId.fromString "it"))
	    val pat     = G.ATPATPat(I, G.LONGVIDAtPat(I, G.SANSOp, longvid))
	    val valbind = G.PLAINValBind(I, pat, exp, NONE)
	    val dec     = G.VALDec(I, G.Seq(I, []), valbind)
	in
	    G.Program(I, dec, program_opt)
	end

  end
(* src # 116 ../frontend-sml/LEXER_ERROR.sig *)
signature LEXER_ERROR =
  sig

    type token
    type error

    exception Error of (int * int) * error
    exception EOF   of (int * int) -> token

    val error :	(int * int) * error -> 'a

  end
(* src # 117 ../frontend-sml/LexerError.sml *)
functor LexerError(structure Tokens: Parser_TOKENS
		   type error) : LEXER_ERROR =
  struct

    type token = (Tokens.svalue, int) Tokens.token
    type error = error

    exception Error of (int * int) * error
    exception EOF   of (int * int) -> token

    fun error pos_e = raise Error pos_e

  end
(* src # 118 ../frontend-sml/Lexer.lex.sml *)
 functor Lexer(structure Tokens:     Parser_TOKENS
			structure LexerError: LEXER_ERROR
			  where type token = (Tokens.svalue,int) Tokens.token
			  where type error = ParsingError.error)=
   struct
    structure UserDeclarations =
      struct
(*
 * Standard ML lexical analysis
 *
 * Definition, sections 2.1-2.5, 3.1
 *
 * Extensions and modifications:
 *   - more liberal constant prefixes (allow 0xw)
 *   - binary int and word constants (0b010, 0wb010)
 *   - longids have been moved to the context-free grammar,
 *     so the LONGID token is substituted by a DOT token
 *   - #[ keyword for vector expressions
 *   - CONSTRUCTOR keyword for constructor declarations
 *   - NON keyword added for negated patterns
 *   - WITHVAL and WITHFUN keywords for bindings inside pattern
 *   - FCT keyword for functor expressions and signatures
 *   - ANY keyword for top signature
 *   - PACK and UNPACK keyword for first class structures
 *   - IMPORT and FROM keywords added
 *   - PRIMITIVE, OVERLOAD, INSTANCE, PREBOUND, and EQEQTYPE keywords added
 *
 * Notes:
 *   Since all lexical classes must be disjoint:
 *   - There is no single class ID, use ALPHA|SYMBOL|STAR|EQUALS.
 *   - There is no class LAB, use ALPHA|SYMBOL|NUMERIC|DIGIT|STAR.
 *   - ID does not contain `=' and `*', those are EQUALS and STAR.
 *   - INT does not contain positive decimal integers without leading 0,
 *     and single DIGIT integers, those are in NUMERIC, DIGIT, and ZERO.
 *   - NUMERIC does not contain single digit numbers, those are in DIGIT.
 *   - DIGIT does not contain 0, that is ZERO.
 *
 *   The parser uses a global variable to recognise nested comments, so it is
 *   not reentrant.
 *)


    open Misc
    open Tokens

    structure E = ParsingError

    val error = LexerError.error


  (* Types to match structure LEXER.UserDeclaration *)

    type ('a,'b) token = ('a,'b) Tokens.token
    type pos           = int
    type svalue        = Tokens.svalue
    type lexresult     = (svalue, pos) token


  (* Source positions *)

    fun toLRPos(yypos, yytext) =
	let
	    val yypos = yypos - 2	(* bug in ML-Lex... *)
	in
	    (yypos, yypos + String.size yytext)
	end


  (* Handling nested comments *)

    val nesting = ref [] : int list ref

    fun nest yypos = nesting := yypos :: !nesting
    fun unnest ()  = ( nesting := List.tl(!nesting) ; List.null(!nesting) )

    fun eof() =
	case !nesting
	  of []    => raise LexerError.EOF(fn i => Tokens.EOF i)
	   | i0::_ =>
		raise LexerError.EOF(fn(i1,i2) =>
					error((i0,i2), E.UnclosedComment))



  (* Some helpers to create tokens *)

    open Tokens


    fun token(TOKEN, yypos, yytext) =
        TOKEN(toLRPos(yypos, yytext))

    fun tokenOf(TOKEN, toVal, yypos, yytext) =
	let
	    val i as (l,r) = toLRPos(yypos, yytext)
	in
	    TOKEN(toVal(yytext,i), l, r)
	end


    fun error'(yypos, yytext, e) = error(toLRPos(yypos, yytext), e)



  (* Convert identifiers and constants *)

    datatype radix = datatype StringCvt.radix

    fun toId(s,i) = s

    fun toDigit(s,i) = Char.ord(String.sub(s,0)) - Char.ord #"0"

    fun toInt(s,i) =
	case String.sub(s,0)
	  of #"~" => ~(toInt(String.extract(s,1,NONE), i))
	   | #"0" => (if String.size s = 1 then 0 else
		      case String.sub(s,1)
			of #"b" => toInt'(String.extract(s,2,NONE), BIN, i)
			 | #"x" => toInt'(String.extract(s,2,NONE), HEX, i)
			 |   _  => toInt'(s, DEC, i)
		     )
	   |   _  => toInt'(s, DEC, i)

    and toInt'(s,b,i) = Option.valOf(StringCvt.scanString (LargeInt.scan b) s)
			handle Overflow => error(i, E.IntTooLarge)

    fun toWord(s,i) =
	case (String.sub(s,1), String.sub(s,2))
	  of ( (#"b",_) | (_,#"b") ) => toWord'(String.extract(s,3,NONE), BIN,i)
	   | ( (#"x",_) | (_,#"x") ) => toWord'(String.extract(s,3,NONE), HEX,i)
	   |            _            => toWord'(String.extract(s,2,NONE), DEC,i)

    and toWord'(s,b,i) = Option.valOf(StringCvt.scanString (LargeWord.scan b) s)
			 handle Overflow => error(i, E.WordTooLarge)

    fun toReal(s,i)    = Option.valOf(StringCvt.scanString LargeReal.scan s)
			 handle Overflow => error(i, E.RealTooLarge)


    fun toString(s,i) =
	let
            fun base(s,b,m) =
		WideChar.chr(Option.valOf(StringCvt.scanString (Int.scan b) s))
		handle (Chr | Overflow) =>
			 error(i, E.EscapeCharTooLarge m)

	    fun dec s     = base(s, DEC, false)
	    fun unicode s = base(s, HEX, true)

	    fun convert(k,cs) =
		case String.sub(s,k)
		  of #"\"" => WideString.implode(List.rev cs)
		   | #"\\" => escape(k+1,cs)
		   |   c   => convert(k+1, Char_toWide(c)::cs)

	    and escape(k,cs) =
		case String.sub(s,k)
		  of #"a"  => convert(k+1, #"\a"::cs)
		   | #"b"  => convert(k+1, #"\b"::cs)
		   | #"t"  => convert(k+1, #"\t"::cs)
		   | #"n"  => convert(k+1, #"\n"::cs)
		   | #"v"  => convert(k+1, #"\v"::cs)
		   | #"f"  => convert(k+1, #"\f"::cs)
		   | #"r"  => convert(k+1, #"\r"::cs)
		   | #"\"" => convert(k+1, #"\""::cs)
		   | #"\\" => convert(k+1, #"\\"::cs)
		   | #"^"  => let val c = String.sub(s,k+1) in
				  convert(k+2, WideChar.chr(Char.ord c -
							    Char.ord #"0")::cs)
			      end

		   | #"u"  => let val s' = String.extract(s, k+1, SOME 4) in
				  convert(k+5, unicode s' :: cs)
			      end

		   |   c   => if Char.isDigit c then
				  let val s' = String.extract(s, k, SOME 3) in
				      convert(k+3, dec s' :: cs)
				  end
			      else if Char.isSpace c then
				   gap(k+1, cs)
			      else raise Crash.Crash "Lexer.toString: \
						     \invalid escape sequence"

	    and gap(k, cs) =
		    if String.sub(s,k) = #"\\" then
			convert(k+1, cs)
		    else
			gap(k+1, cs)

	in
	    convert(1,[])
	end


    fun toChar(s, i) =
	let
	    val s'  = String.substring(s, 1, String.size s - 1)
	    val ss' = toString(s', i)
	in
	    if WideString.size ss' = 1 then
		WideString.sub(ss', 0)
	    else
		error(i, E.CharLengthInvalid ss')
	end

end (* end of user routines *)
exception LexError (* raised if illegal leaf action tried *)
structure Internal =
	struct

datatype yyfinstate = N of int
type statedata = {fin : yyfinstate list, trans: int Vector.vector}
(* transition & final state table *)
val tab = let
fun decode s k =
  let val k' = k + k
      val hi = Char.ord(String.sub(s, k'))
      val lo = Char.ord(String.sub(s, k' + 1))
  in hi * 256 + lo end
val s = [ 
 (0,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (1,256, 
"\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\001\058\001\059\001\058\001\058\001\058\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\001\058\000\216\001\046\001\033\000\216\000\216\000\216\001\031\
\\001\029\001\028\001\027\000\216\001\026\001\024\001\021\000\216\
\\001\009\001\007\001\007\001\007\001\007\001\007\001\007\001\007\
\\001\007\001\007\001\005\001\004\000\216\001\002\000\216\000\216\
\\000\216\000\027\000\027\000\027\000\027\000\027\000\027\000\027\
\\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\
\\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\
\\000\027\000\027\000\027\001\001\000\216\001\000\000\216\000\217\
\\000\216\000\201\000\027\000\187\000\178\000\159\000\146\000\027\
\\000\140\000\123\000\027\000\027\000\116\000\027\000\110\000\100\
\\000\096\000\027\000\089\000\066\000\059\000\053\000\050\000\029\
\\000\027\000\027\000\027\000\026\000\025\000\024\000\006\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\
\\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005"
),
 (3,256, 
"\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\065\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\063\001\060\001\061\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\
\\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060"
),
 (6,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\007\000\000\000\007\000\007\000\007\000\007\000\000\
\\000\000\000\000\000\007\000\007\000\000\000\007\000\000\000\007\
\\000\019\000\008\000\008\000\008\000\008\000\008\000\008\000\008\
\\000\008\000\008\000\007\000\000\000\007\000\007\000\007\000\007\
\\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\007\000\000\000\007\000\000\
\\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\007\000\000\000\007\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (7,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\007\000\000\000\007\000\007\000\007\000\007\000\000\
\\000\000\000\000\000\007\000\007\000\000\000\007\000\000\000\007\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\007\000\000\000\007\000\007\000\007\000\007\
\\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\007\000\000\000\007\000\000\
\\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\007\000\000\000\007\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (8,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\013\000\000\
\\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\
\\000\008\000\008\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\009\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\009\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (9,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\
\\000\012\000\012\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\010\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (10,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\
\\000\011\000\011\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (12,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\
\\000\012\000\012\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (13,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\014\
\\000\014\000\014\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (14,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\014\
\\000\014\000\014\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\015\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\015\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (15,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\
\\000\018\000\018\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (16,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\
\\000\017\000\017\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (18,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\
\\000\018\000\018\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (19,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\013\000\000\
\\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\
\\000\008\000\008\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\009\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\022\000\000\000\000\000\009\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\020\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (20,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\
\\000\021\000\021\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\021\000\021\000\021\000\021\000\021\000\021\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\021\000\021\000\021\000\021\000\021\000\021\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (22,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\023\000\023\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (27,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (29,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\043\000\030\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (30,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\031\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (31,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\032\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (32,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\040\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\036\000\028\000\033\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (33,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\034\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (34,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\035\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (36,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\037\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (37,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\038\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (38,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\039\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (40,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\041\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (41,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\042\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (43,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\047\000\028\000\028\
\\000\028\000\044\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (44,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\045\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (45,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\046\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (47,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\048\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (48,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\049\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (50,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\051\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (51,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\052\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (53,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\054\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (54,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\055\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (55,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\056\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (56,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\057\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (57,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\058\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (59,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\063\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\060\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (60,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\061\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (61,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\062\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (63,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\064\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (64,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\065\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (66,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\083\000\075\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\067\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (67,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\068\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (68,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\069\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (69,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\070\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (70,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\071\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (71,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\072\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (72,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\073\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (73,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\074\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (75,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\076\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (76,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\077\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (77,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\078\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (78,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\079\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (79,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\080\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (80,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\081\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (81,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\082\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (83,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\084\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (84,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\085\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (85,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\086\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (86,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\087\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (87,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\088\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (89,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\092\000\028\000\028\000\028\000\090\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (90,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\091\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (92,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\093\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (93,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\094\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (94,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\095\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (96,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\097\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (97,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\098\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (98,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\099\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (100,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\109\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\106\000\028\000\101\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (101,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\102\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (102,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\103\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (103,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\104\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (104,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\105\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (106,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\107\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (107,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\108\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (110,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\111\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (111,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\112\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (112,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\113\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (113,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\114\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (114,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\115\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (116,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\121\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\117\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (117,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\118\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (118,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\119\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (119,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\120\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (121,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\122\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (123,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\139\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\134\000\124\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (124,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\129\000\028\000\028\000\125\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (125,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\126\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (126,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\127\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (127,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\128\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (129,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\130\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (130,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\131\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (131,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\132\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (132,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\133\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (134,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\135\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (135,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\136\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (136,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\137\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (137,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\138\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (140,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\141\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (141,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\142\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (142,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\143\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (143,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\144\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (144,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\145\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (146,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\157\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\156\000\028\
\\000\028\000\028\000\153\000\028\000\028\000\147\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (147,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\148\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (148,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\149\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (149,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\150\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (150,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\151\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (151,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\152\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (153,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\154\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (154,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\155\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (157,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\158\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (159,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\175\000\028\000\173\000\028\
\\000\028\000\168\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\160\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (160,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\161\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (161,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\162\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (162,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\163\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (163,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\164\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (164,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\165\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (165,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\166\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (166,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\167\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (168,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\169\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (169,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\170\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (170,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\171\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (171,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\172\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (173,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\174\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (175,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\176\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (176,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\177\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (178,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\180\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\179\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (180,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\181\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (181,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\182\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (182,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\183\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (183,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\184\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (184,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\185\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (185,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\186\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (187,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\198\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\188\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (188,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\189\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (189,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\190\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (190,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\191\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (191,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\192\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (192,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\193\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (193,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\194\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (194,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\195\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (195,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\196\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (196,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\197\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (198,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\199\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (199,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\200\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (201,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\210\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\203\000\028\
\\000\028\000\028\000\028\000\202\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (203,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\205\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\204\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (205,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\206\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (206,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\207\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (207,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\208\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (208,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\209\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (210,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\211\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (211,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\212\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (212,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\213\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (213,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\214\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (214,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\028\
\\000\000\000\028\000\028\000\028\000\028\000\215\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\
\\000\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (217,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\218\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (218,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\250\000\000\000\000\
\\000\000\000\242\000\000\000\000\000\000\000\000\000\000\000\234\
\\000\219\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (219,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\220\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (220,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\228\000\000\000\000\
\\000\000\000\221\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (221,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\222\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (222,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\223\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (223,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\224\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (224,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\225\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (225,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\226\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (226,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\227\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (228,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\229\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (229,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\230\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (230,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\231\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (231,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\232\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (232,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\233\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (234,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\235\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (235,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\236\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (236,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\237\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (237,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\238\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (238,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\239\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (239,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\240\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (240,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\241\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (242,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\243\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (243,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\244\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (244,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\245\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (245,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\246\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (246,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\247\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (247,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\248\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (248,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\249\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (250,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\251\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (251,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\252\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (252,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\253\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (253,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\254\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (254,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\255\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (258,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\007\000\000\000\007\000\007\000\007\000\007\000\000\
\\000\000\000\000\000\007\000\007\000\000\000\007\000\000\000\007\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\007\000\000\000\007\000\007\001\003\000\007\
\\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\007\000\000\000\007\000\000\
\\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\007\000\000\000\007\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (261,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\007\000\000\000\007\000\007\000\007\000\007\000\000\
\\000\000\000\000\000\007\000\007\000\000\000\007\000\000\000\007\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\007\000\000\000\007\000\007\001\006\000\007\
\\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\007\000\000\000\007\000\000\
\\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\007\000\000\000\007\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (263,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\013\000\000\
\\001\008\001\008\001\008\001\008\001\008\001\008\001\008\001\008\
\\001\008\001\008\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\009\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\009\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (265,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\013\000\000\
\\001\020\001\020\001\020\001\020\001\020\001\020\001\020\001\020\
\\001\020\001\020\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\009\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\001\018\000\000\000\000\000\009\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\014\
\\001\010\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (266,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\013\001\013\001\013\001\013\001\013\001\013\001\013\001\013\
\\001\013\001\013\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\013\001\013\001\013\001\013\001\013\001\013\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\013\001\013\001\013\001\013\001\013\001\013\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\011\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (267,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\012\001\012\001\012\001\012\001\012\001\012\001\012\001\012\
\\001\012\001\012\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\012\001\012\001\012\001\012\001\012\001\012\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\012\001\012\001\012\001\012\001\012\001\012\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (269,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\013\001\013\001\013\001\013\001\013\001\013\001\013\001\013\
\\001\013\001\013\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\013\001\013\001\013\001\013\001\013\001\013\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\013\001\013\001\013\001\013\001\013\001\013\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (270,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\017\001\017\001\017\001\017\001\017\001\017\001\017\001\017\
\\001\017\001\017\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\001\015\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\011\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (271,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\016\001\016\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (273,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\017\001\017\001\017\001\017\001\017\001\017\001\017\001\017\
\\001\017\001\017\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (274,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\019\001\019\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\015\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (275,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\019\001\019\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (276,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\013\000\000\
\\001\020\001\020\001\020\001\020\001\020\001\020\001\020\001\020\
\\001\020\001\020\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\009\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\009\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (277,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\001\022\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (278,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\001\023\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (280,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\007\000\000\000\007\000\007\000\007\000\007\000\000\
\\000\000\000\000\000\007\000\007\000\000\000\007\000\000\000\007\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\007\000\000\000\007\000\007\001\025\000\007\
\\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\007\000\000\000\007\000\000\
\\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\007\000\000\000\007\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (285,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\001\030\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (287,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\032\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\032\001\032\001\032\001\032\001\032\001\032\001\032\001\032\
\\001\032\001\032\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\032\001\032\001\032\001\032\001\032\001\032\001\032\
\\001\032\001\032\001\032\001\032\001\032\001\032\001\032\001\032\
\\001\032\001\032\001\032\001\032\001\032\001\032\001\032\001\032\
\\001\032\001\032\001\032\000\000\000\000\000\000\000\000\001\032\
\\000\000\001\032\001\032\001\032\001\032\001\032\001\032\001\032\
\\001\032\001\032\001\032\001\032\001\032\001\032\001\032\001\032\
\\001\032\001\032\001\032\001\032\001\032\001\032\001\032\001\032\
\\001\032\001\032\001\032\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (289,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\007\001\035\000\007\000\007\000\007\000\007\000\000\
\\000\000\000\000\000\007\000\007\000\000\000\007\000\000\000\007\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\007\000\000\000\007\000\007\000\007\000\007\
\\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\001\034\000\007\000\000\000\007\000\000\
\\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\007\000\000\000\007\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (291,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\035\001\035\001\045\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\036\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\000\000\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035"
),
 (292,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\044\001\044\001\044\001\044\001\044\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\044\000\000\001\035\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\042\001\042\001\042\001\042\001\042\001\042\001\042\001\042\
\\001\042\001\042\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\001\035\000\000\001\041\000\000\
\\000\000\001\035\001\035\000\000\000\000\000\000\001\035\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\001\035\000\000\
\\000\000\000\000\001\035\000\000\001\035\001\037\001\035\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (293,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\038\001\038\001\038\001\038\001\038\001\038\001\038\001\038\
\\001\038\001\038\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\038\001\038\001\038\001\038\001\038\001\038\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\038\001\038\001\038\001\038\001\038\001\038\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (294,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\039\001\039\001\039\001\039\001\039\001\039\001\039\001\039\
\\001\039\001\039\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\039\001\039\001\039\001\039\001\039\001\039\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\039\001\039\001\039\001\039\001\039\001\039\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (295,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\040\001\040\001\040\001\040\001\040\001\040\001\040\001\040\
\\001\040\001\040\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\040\001\040\001\040\001\040\001\040\001\040\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\040\001\040\001\040\001\040\001\040\001\040\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (296,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\035\001\035\001\035\001\035\001\035\001\035\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\035\001\035\001\035\001\035\001\035\001\035\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (297,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (298,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\043\001\043\001\043\001\043\001\043\001\043\001\043\001\043\
\\001\043\001\043\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (299,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\035\001\035\001\035\001\035\001\035\001\035\001\035\001\035\
\\001\035\001\035\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (300,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\044\001\044\001\044\001\044\001\044\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\044\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\001\035\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (302,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\047\001\047\001\057\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\048\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\000\000\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047"
),
 (304,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\056\001\056\001\056\001\056\001\056\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\056\000\000\001\047\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\054\001\054\001\054\001\054\001\054\001\054\001\054\001\054\
\\001\054\001\054\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\001\047\000\000\001\053\000\000\
\\000\000\001\047\001\047\000\000\000\000\000\000\001\047\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\001\047\000\000\
\\000\000\000\000\001\047\000\000\001\047\001\049\001\047\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (305,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\050\001\050\001\050\001\050\001\050\001\050\001\050\001\050\
\\001\050\001\050\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\050\001\050\001\050\001\050\001\050\001\050\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\050\001\050\001\050\001\050\001\050\001\050\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (306,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\051\001\051\001\051\001\051\001\051\001\051\001\051\001\051\
\\001\051\001\051\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\051\001\051\001\051\001\051\001\051\001\051\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\051\001\051\001\051\001\051\001\051\001\051\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (307,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\052\001\052\001\052\001\052\001\052\001\052\001\052\001\052\
\\001\052\001\052\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\052\001\052\001\052\001\052\001\052\001\052\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\052\001\052\001\052\001\052\001\052\001\052\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (308,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\047\001\047\001\047\001\047\001\047\001\047\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\047\001\047\001\047\001\047\001\047\001\047\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (309,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (310,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\055\001\055\001\055\001\055\001\055\001\055\001\055\001\055\
\\001\055\001\055\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (311,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\047\001\047\001\047\001\047\001\047\001\047\001\047\001\047\
\\001\047\001\047\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (312,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\056\001\056\001\056\001\056\001\056\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\056\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\001\047\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (314,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\059\001\059\001\059\001\059\001\059\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\001\059\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (317,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\001\062\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
 (319,256, 
"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\001\064\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
),
(0, 0, "")]
fun f(n, i, x) = (n, Vector.tabulate(i, decode x)) 
val s = map f (rev (tl (rev s))) 
exception LexHackingError 
fun look ((j,x)::r, i) = if i = j then x else look(r, i) 
  | look ([], i) = raise LexHackingError
fun g {fin=x, trans=i} = {fin=x, trans=look(s,i)} 
in Vector.fromList(map g 
[{fin = [], trans = 0},
{fin = [], trans = 1},
{fin = [], trans = 1},
{fin = [], trans = 3},
{fin = [], trans = 3},
{fin = [(N 594)], trans = 0},
{fin = [(N 577),(N 594)], trans = 6},
{fin = [(N 577)], trans = 7},
{fin = [(N 436)], trans = 8},
{fin = [], trans = 9},
{fin = [], trans = 10},
{fin = [(N 483)], trans = 10},
{fin = [(N 483)], trans = 12},
{fin = [], trans = 13},
{fin = [(N 483)], trans = 14},
{fin = [], trans = 15},
{fin = [], trans = 16},
{fin = [(N 483)], trans = 16},
{fin = [(N 483)], trans = 18},
{fin = [(N 436)], trans = 19},
{fin = [], trans = 20},
{fin = [(N 436)], trans = 20},
{fin = [], trans = 22},
{fin = [(N 436)], trans = 22},
{fin = [(N 48),(N 594)], trans = 0},
{fin = [(N 46),(N 577),(N 594)], trans = 7},
{fin = [(N 44),(N 594)], trans = 0},
{fin = [(N 574),(N 594)], trans = 27},
{fin = [(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 29},
{fin = [(N 574)], trans = 30},
{fin = [(N 574)], trans = 31},
{fin = [(N 380),(N 574)], trans = 32},
{fin = [(N 574)], trans = 33},
{fin = [(N 574)], trans = 34},
{fin = [(N 405),(N 574)], trans = 27},
{fin = [(N 574)], trans = 36},
{fin = [(N 574)], trans = 37},
{fin = [(N 574)], trans = 38},
{fin = [(N 397),(N 574)], trans = 27},
{fin = [(N 574)], trans = 40},
{fin = [(N 574)], trans = 41},
{fin = [(N 388),(N 574)], trans = 27},
{fin = [(N 574)], trans = 43},
{fin = [(N 574)], trans = 44},
{fin = [(N 574)], trans = 45},
{fin = [(N 375),(N 574)], trans = 27},
{fin = [(N 574)], trans = 47},
{fin = [(N 574)], trans = 48},
{fin = [(N 369),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 50},
{fin = [(N 574)], trans = 51},
{fin = [(N 363),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 53},
{fin = [(N 574)], trans = 54},
{fin = [(N 574)], trans = 55},
{fin = [(N 574)], trans = 56},
{fin = [(N 574)], trans = 57},
{fin = [(N 359),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 59},
{fin = [(N 574)], trans = 60},
{fin = [(N 574)], trans = 61},
{fin = [(N 352),(N 574)], trans = 27},
{fin = [(N 574)], trans = 63},
{fin = [(N 574)], trans = 64},
{fin = [(N 347),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 66},
{fin = [(N 574)], trans = 67},
{fin = [(N 574)], trans = 68},
{fin = [(N 574)], trans = 69},
{fin = [(N 574)], trans = 70},
{fin = [(N 332),(N 574)], trans = 71},
{fin = [(N 574)], trans = 72},
{fin = [(N 574)], trans = 73},
{fin = [(N 342),(N 574)], trans = 27},
{fin = [(N 574)], trans = 75},
{fin = [(N 315),(N 574)], trans = 76},
{fin = [(N 574)], trans = 77},
{fin = [(N 574)], trans = 78},
{fin = [(N 574)], trans = 79},
{fin = [(N 574)], trans = 80},
{fin = [(N 574)], trans = 81},
{fin = [(N 325),(N 574)], trans = 27},
{fin = [(N 574)], trans = 83},
{fin = [(N 574)], trans = 84},
{fin = [(N 574)], trans = 85},
{fin = [(N 574)], trans = 86},
{fin = [(N 574)], trans = 87},
{fin = [(N 311),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 89},
{fin = [(N 574)], trans = 90},
{fin = [(N 303),(N 574)], trans = 27},
{fin = [(N 574)], trans = 92},
{fin = [(N 574)], trans = 93},
{fin = [(N 574)], trans = 94},
{fin = [(N 299),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 96},
{fin = [(N 574)], trans = 97},
{fin = [(N 574)], trans = 98},
{fin = [(N 293),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 100},
{fin = [(N 574)], trans = 101},
{fin = [(N 574)], trans = 102},
{fin = [(N 574)], trans = 103},
{fin = [(N 574)], trans = 104},
{fin = [(N 288),(N 574)], trans = 27},
{fin = [(N 276),(N 574)], trans = 106},
{fin = [(N 574)], trans = 107},
{fin = [(N 281),(N 574)], trans = 27},
{fin = [(N 273),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 110},
{fin = [(N 574)], trans = 111},
{fin = [(N 263),(N 574)], trans = 112},
{fin = [(N 574)], trans = 113},
{fin = [(N 574)], trans = 114},
{fin = [(N 270),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 116},
{fin = [(N 574)], trans = 117},
{fin = [(N 574)], trans = 118},
{fin = [(N 574)], trans = 119},
{fin = [(N 259),(N 574)], trans = 27},
{fin = [(N 574)], trans = 121},
{fin = [(N 253),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 123},
{fin = [(N 228),(N 574)], trans = 124},
{fin = [(N 574)], trans = 125},
{fin = [(N 574)], trans = 126},
{fin = [(N 242),(N 574)], trans = 127},
{fin = [(N 249),(N 574)], trans = 27},
{fin = [(N 574)], trans = 129},
{fin = [(N 574)], trans = 130},
{fin = [(N 574)], trans = 131},
{fin = [(N 574)], trans = 132},
{fin = [(N 236),(N 574)], trans = 27},
{fin = [(N 574)], trans = 134},
{fin = [(N 574)], trans = 135},
{fin = [(N 574)], trans = 136},
{fin = [(N 574)], trans = 137},
{fin = [(N 225),(N 574)], trans = 27},
{fin = [(N 218),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 140},
{fin = [(N 574)], trans = 141},
{fin = [(N 574)], trans = 142},
{fin = [(N 574)], trans = 143},
{fin = [(N 574)], trans = 144},
{fin = [(N 215),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 146},
{fin = [(N 574)], trans = 147},
{fin = [(N 200),(N 574)], trans = 148},
{fin = [(N 574)], trans = 149},
{fin = [(N 574)], trans = 150},
{fin = [(N 574)], trans = 151},
{fin = [(N 208),(N 574)], trans = 27},
{fin = [(N 574)], trans = 153},
{fin = [(N 574)], trans = 154},
{fin = [(N 196),(N 574)], trans = 27},
{fin = [(N 191),(N 574)], trans = 27},
{fin = [(N 574)], trans = 157},
{fin = [(N 188),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 159},
{fin = [(N 574)], trans = 160},
{fin = [(N 574)], trans = 161},
{fin = [(N 574)], trans = 162},
{fin = [(N 574)], trans = 163},
{fin = [(N 574)], trans = 164},
{fin = [(N 574)], trans = 165},
{fin = [(N 574)], trans = 166},
{fin = [(N 184),(N 574)], trans = 27},
{fin = [(N 574)], trans = 168},
{fin = [(N 574)], trans = 169},
{fin = [(N 574)], trans = 170},
{fin = [(N 574)], trans = 171},
{fin = [(N 174),(N 574)], trans = 27},
{fin = [(N 574)], trans = 173},
{fin = [(N 167),(N 574)], trans = 27},
{fin = [(N 574)], trans = 175},
{fin = [(N 574)], trans = 176},
{fin = [(N 163),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 178},
{fin = [(N 158),(N 574)], trans = 27},
{fin = [(N 574)], trans = 180},
{fin = [(N 574)], trans = 181},
{fin = [(N 574)], trans = 182},
{fin = [(N 574)], trans = 183},
{fin = [(N 574)], trans = 184},
{fin = [(N 574)], trans = 185},
{fin = [(N 155),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 187},
{fin = [(N 574)], trans = 188},
{fin = [(N 574)], trans = 189},
{fin = [(N 574)], trans = 190},
{fin = [(N 574)], trans = 191},
{fin = [(N 574)], trans = 192},
{fin = [(N 574)], trans = 193},
{fin = [(N 574)], trans = 194},
{fin = [(N 574)], trans = 195},
{fin = [(N 574)], trans = 196},
{fin = [(N 146),(N 574)], trans = 27},
{fin = [(N 574)], trans = 198},
{fin = [(N 574)], trans = 199},
{fin = [(N 134),(N 574)], trans = 27},
{fin = [(N 574),(N 594)], trans = 201},
{fin = [(N 129),(N 574)], trans = 27},
{fin = [(N 574)], trans = 203},
{fin = [(N 126),(N 574)], trans = 27},
{fin = [(N 114),(N 574)], trans = 205},
{fin = [(N 574)], trans = 206},
{fin = [(N 574)], trans = 207},
{fin = [(N 574)], trans = 208},
{fin = [(N 122),(N 574)], trans = 27},
{fin = [(N 574)], trans = 210},
{fin = [(N 574)], trans = 211},
{fin = [(N 574)], trans = 212},
{fin = [(N 574)], trans = 213},
{fin = [(N 574)], trans = 214},
{fin = [(N 110),(N 574)], trans = 27},
{fin = [(N 577),(N 594)], trans = 7},
{fin = [(N 42),(N 594)], trans = 217},
{fin = [], trans = 218},
{fin = [], trans = 219},
{fin = [], trans = 220},
{fin = [], trans = 221},
{fin = [], trans = 222},
{fin = [], trans = 223},
{fin = [], trans = 224},
{fin = [], trans = 225},
{fin = [], trans = 226},
{fin = [(N 102)], trans = 0},
{fin = [], trans = 228},
{fin = [], trans = 229},
{fin = [], trans = 230},
{fin = [], trans = 231},
{fin = [], trans = 232},
{fin = [(N 90)], trans = 0},
{fin = [], trans = 234},
{fin = [], trans = 235},
{fin = [], trans = 236},
{fin = [], trans = 237},
{fin = [], trans = 238},
{fin = [], trans = 239},
{fin = [], trans = 240},
{fin = [(N 79)], trans = 0},
{fin = [], trans = 242},
{fin = [], trans = 243},
{fin = [], trans = 244},
{fin = [], trans = 245},
{fin = [], trans = 246},
{fin = [], trans = 247},
{fin = [], trans = 248},
{fin = [(N 68)], trans = 0},
{fin = [], trans = 250},
{fin = [], trans = 251},
{fin = [], trans = 252},
{fin = [], trans = 253},
{fin = [], trans = 254},
{fin = [(N 57)], trans = 0},
{fin = [(N 40),(N 594)], trans = 0},
{fin = [(N 38),(N 594)], trans = 0},
{fin = [(N 33),(N 577),(N 594)], trans = 258},
{fin = [(N 36),(N 577)], trans = 7},
{fin = [(N 31),(N 594)], trans = 0},
{fin = [(N 26),(N 577),(N 594)], trans = 261},
{fin = [(N 29),(N 577)], trans = 7},
{fin = [(N 409),(N 412),(N 436),(N 594)], trans = 263},
{fin = [(N 412),(N 436)], trans = 263},
{fin = [(N 407),(N 436),(N 594)], trans = 265},
{fin = [], trans = 266},
{fin = [], trans = 267},
{fin = [(N 455)], trans = 267},
{fin = [(N 436)], trans = 269},
{fin = [], trans = 270},
{fin = [], trans = 271},
{fin = [(N 455)], trans = 271},
{fin = [(N 455)], trans = 273},
{fin = [], trans = 274},
{fin = [(N 436)], trans = 275},
{fin = [(N 436)], trans = 276},
{fin = [(N 20),(N 594)], trans = 277},
{fin = [], trans = 278},
{fin = [(N 24)], trans = 0},
{fin = [(N 577),(N 594)], trans = 280},
{fin = [(N 18),(N 577)], trans = 7},
{fin = [(N 15),(N 594)], trans = 0},
{fin = [(N 13),(N 577),(N 594)], trans = 7},
{fin = [(N 11),(N 594)], trans = 0},
{fin = [(N 9),(N 594)], trans = 285},
{fin = [(N 580)], trans = 0},
{fin = [(N 569),(N 594)], trans = 287},
{fin = [(N 569)], trans = 287},
{fin = [(N 4),(N 577),(N 594)], trans = 289},
{fin = [(N 7)], trans = 0},
{fin = [], trans = 291},
{fin = [], trans = 292},
{fin = [], trans = 293},
{fin = [], trans = 294},
{fin = [], trans = 295},
{fin = [], trans = 296},
{fin = [], trans = 297},
{fin = [], trans = 298},
{fin = [], trans = 299},
{fin = [], trans = 300},
{fin = [(N 564)], trans = 0},
{fin = [(N 592),(N 594)], trans = 302},
{fin = [], trans = 302},
{fin = [], trans = 304},
{fin = [], trans = 305},
{fin = [], trans = 306},
{fin = [], trans = 307},
{fin = [], trans = 308},
{fin = [], trans = 309},
{fin = [], trans = 310},
{fin = [], trans = 311},
{fin = [], trans = 312},
{fin = [(N 523)], trans = 0},
{fin = [(N 2),(N 594)], trans = 314},
{fin = [(N 2)], trans = 314},
{fin = [(N 588)], trans = 0},
{fin = [(N 588)], trans = 317},
{fin = [(N 586)], trans = 0},
{fin = [(N 588)], trans = 319},
{fin = [(N 583)], trans = 0},
{fin = [(N 590)], trans = 0}])
end
structure StartStates =
	struct
	datatype yystartstate = STARTSTATE of int

(* start state definitions *)

val COMMENT = STARTSTATE 3;
val INITIAL = STARTSTATE 1;

end
type result = UserDeclarations.lexresult
	exception LexerError (* raised if illegal leaf action tried *)
end

fun makeLexer yyinput =
let	val yygone0=1
	val yyb = ref "\n" 		(* buffer *)
	val yybl = ref 1		(*buffer length *)
	val yybufpos = ref 1		(* location of next character to use *)
	val yygone = ref yygone0	(* position in file of beginning of buffer *)
	val yydone = ref false		(* eof found yet? *)
	val yybegin = ref 1		(*Current 'start state' for lexer *)

	val YYBEGIN = fn (Internal.StartStates.STARTSTATE x) =>
		 yybegin := x

fun lex () : Internal.result =
let fun continue() = lex() in
  let fun scan (s,AcceptingLeaves : Internal.yyfinstate list list,l,i0) =
	let fun action (i,nil) = raise LexError
	| action (i,nil::l) = action (i-1,l)
	| action (i,(node::acts)::l) =
		case node of
		    Internal.N yyk => 
			(let val yytext = substring(!yyb,i0,i-i0)
			     val yypos = i0+ !yygone
			open UserDeclarations Internal.StartStates
 in (yybufpos := i; case yyk of 

			(* Application actions *)

  102 => ( token(PRIMITIVE, yypos, yytext) )
| 11 => ( token(RPAR,      yypos, yytext) )
| 110 => ( token(ABSTYPE,   yypos, yytext) )
| 114 => ( token(AND,       yypos, yytext) )
| 122 => ( token(ANDALSO,   yypos, yytext) )
| 126 => ( token(ANY,       yypos, yytext) )
| 129 => ( token(AS,        yypos, yytext) )
| 13 => ( token(STAR,      yypos, yytext) )
| 134 => ( token(CASE,      yypos, yytext) )
| 146 => ( token(CONSTRUCTOR,yypos, yytext) )
| 15 => ( token(COMMA,     yypos, yytext) )
| 155 => ( token(DATATYPE,  yypos, yytext) )
| 158 => ( token(DO,        yypos, yytext) )
| 163 => ( token(ELSE,      yypos, yytext) )
| 167 => ( token(END,       yypos, yytext) )
| 174 => ( token(EQTYPE,    yypos, yytext) )
| 18 => ( token(ARROW,     yypos, yytext) )
| 184 => ( token(EXCEPTION, yypos, yytext) )
| 188 => ( token(FCT,       yypos, yytext) )
| 191 => ( token(FN,        yypos, yytext) )
| 196 => ( token(FROM,      yypos, yytext) )
| 2 => ( continue() )
| 20 => ( token(DOT,       yypos, yytext) )
| 200 => ( token(FUN,       yypos, yytext) )
| 208 => ( token(FUNCTOR,   yypos, yytext) )
| 215 => ( token(HANDLE,    yypos, yytext) )
| 218 => ( token(IF,        yypos, yytext) )
| 225 => ( token(IMPORT,    yypos, yytext) )
| 228 => ( token(IN,        yypos, yytext) )
| 236 => ( token(INCLUDE,   yypos, yytext) )
| 24 => ( token(DOTS,      yypos, yytext) )
| 242 => ( token(INFIX,     yypos, yytext) )
| 249 => ( token(INFIXR,    yypos, yytext) )
| 253 => ( token(LET,       yypos, yytext) )
| 259 => ( token(LOCAL,     yypos, yytext) )
| 26 => ( token(COLON,     yypos, yytext) )
| 263 => ( token(NON,       yypos, yytext) )
| 270 => ( token(NONFIX,    yypos, yytext) )
| 273 => ( token(OF,        yypos, yytext) )
| 276 => ( token(OP,        yypos, yytext) )
| 281 => ( token(OPEN,      yypos, yytext) )
| 288 => ( token(ORELSE,    yypos, yytext) )
| 29 => ( token(COLONGREATER, yypos, yytext) )
| 293 => ( token(PACK,      yypos, yytext) )
| 299 => ( token(RAISE,     yypos, yytext) )
| 303 => ( token(REC,       yypos, yytext) )
| 31 => ( token(SEMICOLON, yypos, yytext) )
| 311 => ( token(SHARING,   yypos, yytext) )
| 315 => ( token(SIG,       yypos, yytext) )
| 325 => ( token(SIGNATURE, yypos, yytext) )
| 33 => ( token(EQUALS,    yypos, yytext) )
| 332 => ( token(STRUCT,    yypos, yytext) )
| 342 => ( token(STRUCTURE, yypos, yytext) )
| 347 => ( token(THEN,      yypos, yytext) )
| 352 => ( token(TYPE,      yypos, yytext) )
| 359 => ( token(UNPACK,    yypos, yytext) )
| 36 => ( token(DARROW,    yypos, yytext) )
| 363 => ( token(VAL,       yypos, yytext) )
| 369 => ( token(WHERE,     yypos, yytext) )
| 375 => ( token(WHILE,     yypos, yytext) )
| 38 => ( token(LBRACK,    yypos, yytext) )
| 380 => ( token(WITH,      yypos, yytext) )
| 388 => ( token(WITHFUN,   yypos, yytext) )
| 397 => ( token(WITHTYPE,  yypos, yytext) )
| 4 => ( token(HASH,      yypos, yytext) )
| 40 => ( token(RBRACK,    yypos, yytext) )
| 405 => ( token(WITHVAL,   yypos, yytext) )
| 407 => ( token  (ZERO,              yypos, yytext) )
| 409 => ( tokenOf(DIGIT,   toDigit,  yypos, yytext) )
| 412 => ( tokenOf(NUMERIC, toInt,    yypos, yytext) )
| 42 => ( token(UNDERBAR,  yypos, yytext) )
| 436 => ( tokenOf(INT,     toInt,    yypos, yytext) )
| 44 => ( token(LBRACE,    yypos, yytext) )
| 455 => ( tokenOf(WORD,    toWord,   yypos, yytext) )
| 46 => ( token(BAR,       yypos, yytext) )
| 48 => ( token(RBRACE,    yypos, yytext) )
| 483 => ( tokenOf(REAL,    toReal,   yypos, yytext) )
| 523 => ( tokenOf(STRING,  toString, yypos, yytext) )
| 564 => ( tokenOf(CHAR,    toChar,   yypos, yytext) )
| 569 => ( tokenOf(TYVAR,   toId,     yypos, yytext) )
| 57 => ( token(EQEQTYPE,  yypos, yytext) )
| 574 => ( tokenOf(ALPHA,   toId,     yypos, yytext) )
| 577 => ( tokenOf(SYMBOL,  toId,     yypos, yytext) )
| 580 => ( nest(yypos-2) ; YYBEGIN COMMENT ; continue() )
| 583 => ( nest(yypos-2) ; continue() )
| 586 => ( if unnest() then YYBEGIN INITIAL else () ;
			     continue() )
| 588 => ( continue() )
| 590 => ( continue() )
| 592 => ( error'(yypos, yytext, E.InvalidString) )
| 594 => ( error'(yypos, yytext,
				    E.InvalidChar(String.sub(yytext,0))) )
| 68 => ( token(INSTANCE,  yypos, yytext) )
| 7 => ( token(HASHBRACK, yypos, yytext) )
| 79 => ( token(OVERLOAD,  yypos, yytext) )
| 9 => ( token(LPAR,      yypos, yytext) )
| 90 => ( token(PREBOUND,  yypos, yytext) )
| _ => raise Internal.LexerError

		) end )

	val {fin,trans} = Vector.sub(Internal.tab, s)
	val NewAcceptingLeaves = fin::AcceptingLeaves
	in if l = !yybl then
	     if trans = #trans(Vector.sub(Internal.tab,0))
	       then action(l,NewAcceptingLeaves
) else	    let val newchars= if !yydone then "" else yyinput 1024
	    in if (size newchars)=0
		  then (yydone := true;
		        if (l=i0) then UserDeclarations.eof ()
		                  else action(l,NewAcceptingLeaves))
		  else (if i0=l then yyb := newchars
		     else yyb := substring(!yyb,i0,l-i0)^newchars;
		     yygone := !yygone+i0;
		     yybl := size (!yyb);
		     scan (s,AcceptingLeaves,l-i0,0))
	    end
	  else let val NewChar = Char.ord(String.sub(!yyb,l))
		val NewState = Vector.sub(trans, NewChar)
		in if NewState=0 then action(l,NewAcceptingLeaves)
		else scan(NewState,NewAcceptingLeaves,l+1,i0)
	end
	end
(*
	val start= if substring(!yyb,!yybufpos-1,1)="\n"
then !yybegin+1 else !yybegin
*)
	in scan(!yybegin (* start *),nil,!yybufpos,!yybufpos)
    end
end
  in lex
  end
end
(* src # 119 ../frontend-sml/CountPosLexer.sml *)
functor CountPosLexer(
	structure Lexer: LEXER
	where type UserDeclarations.pos = int
	where type ('a,'b) UserDeclarations.token = ('a,'b) LrParser.Token.token
	structure LexerError: LEXER_ERROR
	where type token =
		(Lexer.UserDeclarations.svalue, int) LrParser.Token.token
	val error : Source.region * LexerError.error -> 'a
) : LEXER =
  struct

    structure UserDeclarations =
      struct
	open Lexer.UserDeclarations
	type pos = Source.pos
      end

    fun makeLexer yyinput =
	let
	    val lin  = ref 1
	    val col  = ref 0
	    val pos  = ref 0
	    val buf  = ref ""	(* current buffer *)
	    val buf' = ref ""	(* next buffer *)
	    val off  = ref 0	(* offset to start of current buffer *)
	    val off' = ref 0	(* offset for next buffer *)

	    fun count(i, i', lin, col) =
		if i = i' then
		    (lin,col)
		else (case String.sub(!buf, i)
		    of #"\n" => count(i+1, i', lin+1, 0)
		     | #"\t" => count(i+1, i', lin, col+8-(col mod 8))
		     |  _    => count(i+1, i', lin, col+1)
		) handle Subscript =>
		let
		    val n = String.size(!buf)
		in
		    buf  := !buf' ;
		    buf' := ""    ;
		    off  := !off' ;
		    count(0, i'-n, lin, col)
		end

	    fun transform(pos1, pos2) =
		let
		    val n0 = !off
		    val pos1' as (l1,c1) = count(!pos-n0, pos1-n0, !lin, !col)
		    val n0 = !off
		    val pos2' as (l2,c2) = count(pos1-n0, pos2-n0, l1, c1)
		in
		    lin := l2 ;
		    col := c2 ;
		    pos := pos2 ;
		    (pos1',pos2')
		end

	    fun yyinput' n =
		let
		    val s = yyinput n
		in
		    buf' := s ;
		    off' := !off + String.size(!buf) ;
		    s
		end

	    val lexer = Lexer.makeLexer yyinput'
	in
	    fn () =>
		let
		    val LrParser.Token.TOKEN(term, (svalue,pos1,pos2)) =
			lexer() handle LexerError.EOF f =>
			let val pos = !off'+String.size(!buf') in f(pos,pos) end
		    val (pos1', pos2') = transform(pos1, pos2)
		in
		    LrParser.Token.TOKEN(term, (svalue, pos1', pos2'))
		end
		handle LexerError.Error(position, e) =>
		    error(transform position, e)
	end

  end
(* src # 120 ../frontend-sml/PARSING_PHASE.sig *)
signature PARSING_PHASE =
  sig
    structure C : CONTEXT       = EmptyContext
    structure I : SOURCE        = Source
    structure O : INPUT_GRAMMAR = InputGrammar

    val translate : C.t -> I.source -> InputGrammar.Component
  end
(* src # 121 ../frontend-sml/ParsingPhase.sml *)
structure ParsingPhase :> PARSING_PHASE =
  struct

    (* Import *)

    structure C = EmptyContext
    structure I = Source
    structure O = InputGrammar
    structure E = ParsingError


    (* Build Yacc parser *)

    structure LrVals = LrVals(structure Token        = LrParser.Token
			      structure DerivedForms = DerivedForms)

    structure LexerError = LexerError(structure Tokens = LrVals.Tokens
				      type error       = ParsingError.error)

    structure Lexer  = Lexer (structure Tokens     = LrVals.Tokens
			      structure LexerError = LexerError)

    structure Lexer' = CountPosLexer(structure Lexer      = Lexer
				     structure LexerError = LexerError
				     val error            = ParsingError.error)

    structure Parser = Join  (structure LrParser   = LrParser
			      structure ParserData = LrVals.ParserData
			      structure Lex        = Lexer')


    (* The actual parsing function *)

    fun parse source =
	let
	    val yyread = ref false
	    fun yyinput _ =
		if !yyread then
		    ""
		else
		    ( yyread := true; Source.toString source )

	    val lexer = Parser.makeLexer yyinput

	    fun onError(s, pos1, pos2) = E.error((pos1,pos2), E.SyntaxError s)
	in
	    #1 (Parser.parse(0, lexer, onError, ()))
	end

    fun translate() = parse

  end
(* src # 122 ../frontend-sml/BIND_ENV0.sig *)
signature BIND_ENV0 =
  sig

    val E0 :	BindEnv.Env

  end
(* src # 123 ../frontend-sml/BindEnv0.sml *)
structure BindEnv0 :> BIND_ENV0 =
  struct

    open BindEnv
    open Prebound

    structure P = Prebound

    val i = Source.nowhere

    (* Prebound *)

    val E = new()

    (* Type environment *)

    val E_empty = new()
    val E_bool  = new()
    val E_list  = new()
    val E_ref   = new()

    val _ = insertVal(E_bool, VId.fromString "false", (i,valstamp_false,C 0))
    val _ = insertVal(E_bool, VId.fromString "true",  (i,valstamp_true, C 0))
    val _ = insertVal(E_list, VId.fromString "nil",   (i,valstamp_nil,  C 0))
    val _ = insertVal(E_list, VId.fromString "::",    (i,valstamp_cons, C 1))
    val _ = insertVal(E_ref,  VId.fromString "ref",   (i,valstamp_ref,  R))

    val _ = insertTy(E, TyCon.fromString "bool",   (i, typstamp_bool,  E_bool))
    val _ = insertTy(E, TyCon.fromString "int",    (i, typstamp_int,   E_empty))
    val _ = insertTy(E, TyCon.fromString "word",   (i, typstamp_word,  E_empty))
    val _ = insertTy(E, TyCon.fromString "real",   (i, typstamp_real,  E_empty))
    val _ = insertTy(E, TyCon.fromString "char",   (i, typstamp_char,  E_empty))
    val _ = insertTy(E, TyCon.fromString "string", (i, typstamp_string,E_empty))
    val _ = insertTy(E, TyCon.fromString "vector", (i, typstamp_vec,   E_empty))
    val _ = insertTy(E, TyCon.fromString "list",   (i, typstamp_list,  E_list))
    val _ = insertTy(E, TyCon.fromString "ref",    (i, typstamp_ref,   E_ref))
    val _ = insertTy(E, TyCon.fromString "exn",    (i, typstamp_exn,   E_empty))

    (* Value environment *)

    val _ = union(E, E_bool)
    val _ = union(E, E_list)
    val _ = union(E, E_ref)

    val _ = insertVal(E, VId.fromString "Match", (i, valstamp_match, C 0))
    val _ = insertVal(E, VId.fromString "Bind",  (i, valstamp_bind,  C 0))

    (* Global *)

    val E0 = new()

    val _  = insertStr(E0, StrId.fromString "", (i, Stamp.new(), E))

  end
(* src # 124 ../backend-common/LABEL_SORT.sig *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature LABEL_SORT =
    sig
	type 'a t

	datatype arity =
	    Rec
	  | Tup of int

	val sort: 'a t list -> 'a t list * arity
    end
(* src # 125 ../backend-common/MakeLabelSort.sml *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

functor MakeLabelSort(type 'a t val get: 'a t -> Label.t) :> LABEL_SORT
    where type 'a t = 'a t =
    struct
	type 'a t = 'a t

	datatype arity =
	    Rec
	  | Tup of int

	fun split nil = (nil, nil)
	  | split (xs as [_]) = (xs, nil)
	  | split (x1::x2::xr) =
	    let
		val (xr1, xr2) = split xr
	    in
		(x1::xr1, x2::xr2)
	    end

	fun labelLess (x1, x2) = Label.compare (get x1, get x2)

	fun merge (xs as x::xr, ys as y::yr) =
	    (case labelLess (x, y) of
		 LESS => x::merge (xr, ys)
	       | EQUAL => raise Crash.Crash "MakeLabelSort.merge"
	       | GREATER => y::merge (xs, yr))
	  | merge (nil, ys) = ys
	  | merge (xs, nil) = xs

	fun sort' nil = nil
	  | sort' (xs as [_]) = xs
	  | sort' xs =
	    let
		val (ys, zs) = split xs
	    in
		merge (sort' ys, sort' zs)
	    end

	fun isTuple (x::xr, i) =
	    if get x = Label.fromInt i then isTuple (xr, i + 1)
	    else NONE
	  | isTuple (nil, i) = SOME (i - 1)

	fun sort xs =
	    let
		val xs' = sort' xs
	    in
		case isTuple (xs', 1) of
		    SOME i => (xs', Tup i)
		  | NONE => (xs', Rec)
	    end
    end
(* src # 126 ../backend-common/LabelSort.sml *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure LabelSort =
    MakeLabelSort(type 'a t = Label.t * 'a
		  fun get (label, _) = label)
(* src # 127 ../backend-common/FLAT_GRAMMAR.sig *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature FLAT_GRAMMAR =
    sig
	(* Literals *)

	datatype lit = datatype IntermediateGrammar.lit

	(* Identifiers *)

	type stamp = Stamp.t
	type name = Name.t

	datatype id = datatype IntermediateGrammar.id

	type label = Label.t

	(* Expressions and Declarations *)

	type shared = int ref

	type isToplevel = bool

	datatype conArity =
	    Nullary
	  | Unary
	  | Tuple of int
	  | Record of label list

	datatype funFlag =
	    PrintName of string
	  | AuxiliaryOf of stamp

	datatype 'a args =
	    OneArg of 'a
	  | TupArgs of 'a list
	  | RecArgs of (label * 'a) list
	    (* sorted, all labels distinct, no tuple *)

	datatype livenessInfo =
	    Unknown
	  | LoopStart   (* internal *)
	  | LoopEnd   (* internal *)
	  | Use of StampSet.t   (* internal *)
	  | Kill of StampSet.t

	type id_info = IntermediateInfo.id_info
	type stm_info = {region: Source.region, liveness: livenessInfo ref}
	type exp_info = {region: Source.region, typ: Type.t}

	datatype test =
	    LitTest of lit
	  | TagTest of label
	  | TagAppTest of label * id args * conArity
	    (* args may only be TupArgs if conArity is Tuple;
	     * args may only be RecArgs if conArity is Record *)
	  | ConTest of id
	  | ConAppTest of id * id args * conArity
	    (* args may only be TupArgs if conArity is Tuple;
	     * args may only be RecArgs if conArity is Record *)
	  | RefAppTest of id
	  | TupTest of id list
	  | RecTest of (label * id) list
	    (* sorted, all labels distinct, no tuple *)
	  | LabTest of label * id
	  | VecTest of id list

	datatype stm =
	    ValDec of stm_info * id * exp * isToplevel
	  | RecDec of stm_info * (id * exp) list * isToplevel
	    (* all ids distinct *)
	  | EvalStm of stm_info * exp
	  | RaiseStm of stm_info * id
	  | ReraiseStm of stm_info * id
	  (* the following must always be last *)
	  | HandleStm of stm_info * body * id * body * body * shared
	  | EndHandleStm of stm_info * shared
	  | TestStm of stm_info * id * test * body * body
	  | SharedStm of stm_info * body * shared   (* used at least twice *)
	  | ReturnStm of stm_info * exp
	  | IndirectStm of stm_info * body option ref
	  | ExportStm of stm_info * exp
	and exp =
	    LitExp of exp_info * lit
	  | PrimExp of exp_info * string
	  | NewExp of exp_info * conArity
	  | VarExp of exp_info * id
	  | TagExp of exp_info * label * conArity
	  | ConExp of exp_info * id * conArity
	  | RefExp of exp_info
	  | TupExp of exp_info * id list
	  | RecExp of exp_info * (label * id) list
	    (* sorted, all labels distinct, no tuple *)
	  | SelExp of exp_info * label
	  | VecExp of exp_info * id list
	  | FunExp of exp_info * stamp * funFlag list * id args * body
	  | AppExp of exp_info * id * id args
	  | SelAppExp of exp_info * label * id
	  | TagAppExp of exp_info * label * id args * conArity
	    (* args may only be TupArgs if conArity is Tuple;
	     * args may only be RecArgs if conArity is Record *)
	  | ConAppExp of exp_info * id * id args * conArity
	    (* args may only be TupArgs if conArity is Tuple;
	     * args may only be RecArgs if conArity is Record *)
	  | RefAppExp of exp_info * id
	  | PrimAppExp of exp_info * string * id list
	  | AdjExp of exp_info * id * id
	withtype body = stm list

	type sign = IntermediateGrammar.sign
	type component = (id * sign * Url.t) list * (body * sign)
	type t = component

	val infoStm: stm -> stm_info
    end
(* src # 128 ../backend-common/FlatGrammar.sml *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure FlatGrammar: FLAT_GRAMMAR =
    (*--** the above signature constraint should be opaque, but SML/NJ bombs *)
    struct
	(* Literals *)

	datatype lit = datatype IntermediateGrammar.lit

	(* Identifiers *)

	type stamp = Stamp.t
	type name = Name.t

	datatype id = datatype IntermediateGrammar.id

	type label = Label.t

	(* Expressions and Declarations *)

	type shared = int ref

	type isToplevel = bool

	datatype conArity =
	    Nullary
	  | Unary
	  | Tuple of int
	  | Record of label list

	datatype funFlag =
	    PrintName of string
	  | AuxiliaryOf of stamp

	datatype 'a args =
	    OneArg of 'a
	  | TupArgs of 'a list
	  | RecArgs of (label * 'a) list
	    (* sorted, all labels distinct, no tuple *)

	datatype livenessInfo =
	    Unknown
	  | LoopStart   (* internal *)
	  | LoopEnd   (* internal *)
	  | Use of StampSet.t   (* internal *)
	  | Kill of StampSet.t

	type id_info = IntermediateInfo.id_info
	type stm_info = {region: Source.region, liveness: livenessInfo ref}
	type exp_info = {region: Source.region, typ: Type.t}

	datatype test =
	    LitTest of lit
	  | TagTest of label
	  | TagAppTest of label * id args * conArity
	    (* args may only be TupArgs if conArity is Tuple;
	     * args may only be RecArgs if conArity is Record *)
	  | ConTest of id
	  | ConAppTest of id * id args * conArity
	    (* args may only be TupArgs if conArity is Tuple;
	     * args may only be RecArgs if conArity is Record *)
	  | RefAppTest of id
	  | TupTest of id list
	  | RecTest of (label * id) list
	    (* sorted, all labels distinct, no tuple *)
	  | LabTest of label * id
	  | VecTest of id list

	datatype stm =
	    ValDec of stm_info * id * exp * isToplevel
	  | RecDec of stm_info * (id * exp) list * isToplevel
	    (* all ids distinct *)
	  | EvalStm of stm_info * exp
	  | RaiseStm of stm_info * id
	  | ReraiseStm of stm_info * id
	  (* the following must always be last *)
	  | HandleStm of stm_info * body * id * body * body * shared
	  | EndHandleStm of stm_info * shared
	  | TestStm of stm_info * id * test * body * body
	  | SharedStm of stm_info * body * shared   (* used at least twice *)
	  | ReturnStm of stm_info * exp
	  | IndirectStm of stm_info * body option ref
	  | ExportStm of stm_info * exp
	and exp =
	    LitExp of exp_info * lit
	  | PrimExp of exp_info * string
	  | NewExp of exp_info * conArity
	  | VarExp of exp_info * id
	  | TagExp of exp_info * label * conArity
	  | ConExp of exp_info * id * conArity
	  | RefExp of exp_info
	  | TupExp of exp_info * id list
	  | RecExp of exp_info * (label * id) list
	    (* sorted, all labels distinct, no tuple *)
	  | SelExp of exp_info * label
	  | VecExp of exp_info * id list
	  | FunExp of exp_info * stamp * funFlag list * id args * body
	  | AppExp of exp_info * id * id args
	  | SelAppExp of exp_info * label * id
	  | TagAppExp of exp_info * label * id args * conArity
	    (* args may only be TupArgs if conArity is Tuple;
	     * args may only be RecArgs if conArity is Record *)
	  | ConAppExp of exp_info * id * id args * conArity
	    (* args may only be TupArgs if conArity is Tuple;
	     * args may only be RecArgs if conArity is Record *)
	  | RefAppExp of exp_info * id
	  | PrimAppExp of exp_info * string * id list
	  | AdjExp of exp_info * id * id
	withtype body = stm list

	type sign = IntermediateGrammar.sign
	type component = (id * sign * Url.t) list * (body * sign)
	type t = component

	fun infoStm (ValDec (info, _, _, _)) = info
	  | infoStm (RecDec (info, _, _)) = info
	  | infoStm (EvalStm (info, _)) = info
	  | infoStm (RaiseStm (info, _)) = info
	  | infoStm (ReraiseStm (info, _)) = info
	  | infoStm (HandleStm (info, _, _, _, _, _)) = info
	  | infoStm (EndHandleStm (info, _)) = info
	  | infoStm (TestStm (info, _, _, _, _)) = info
	  | infoStm (SharedStm (info, _, _)) = info
	  | infoStm (ReturnStm (info, _)) = info
	  | infoStm (IndirectStm (info, _)) = info
	  | infoStm (ExportStm (info, _)) = info
    end
(* src # 129 ../backend-common/OUTPUT_FLAT_GRAMMAR.sig *)
(*
 * Authors:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature OUTPUT_FLAT_GRAMMAR =
    sig
	structure I: FLAT_GRAMMAR = FlatGrammar

	val outputComponent: I.component -> string
    end
(* src # 130 ../backend-common/OutputFlatGrammar.sml *)
(*
 * Authors:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure OutputFlatGrammar :> OUTPUT_FLAT_GRAMMAR =
    struct
	structure I = FlatGrammar

	open I

	datatype format =
	    SEQ of format list
	  | S of string
	  | IN
	  | EX
	  | NL
	  | ID of id
	  | CO of string
	  | NULL
	  | SEP of format * format list

	fun format f =
	    let
		val indent = ref 0
		fun format' (SEQ fs) = String.concat (List.map format' fs)
		  | format' (S s) = s
		  | format' IN = (indent := !indent + 1; "")
		  | format' EX = (indent := !indent - 1; "")
		  | format' NL =
		    "\n" ^ String.concat (List.tabulate
					  (!indent, fn _ => "  "))
		  | format' (ID (Id (_, stamp, Name.InId))) =
		    "$" ^ Stamp.toString stamp
		  | format' (ID (Id (_, stamp, Name.ExId s))) =
		    s ^ "$" ^ Stamp.toString stamp
		  | format' (CO s) = "   (* " ^ s ^ " *)"
		  | format' NULL = ""
		  | format' (SEP (f, f1::fr)) =
		    List.foldl (fn (fi, rest) => rest ^ format' f ^ format' fi)
		    (format' f1) fr
		  | format' (SEP (_, nil)) = ""
	    in
		format' f
	    end

	local
	    val count = ref 0
	in
	    fun gen () =
		let
		    val n = !count + 1
		in
		    count := n; n
		end
	end

	fun insert (x, ys as (y::yr)): int list =
	    if x < y then x::ys else y::insert (x, yr)
	  | insert (x, nil) = [x]

	val sort = StampSet.fold insert nil

	fun outputLiveness (ref (Unknown | LoopStart | LoopEnd)) = NULL
	  | outputLiveness (ref (Use set)) =
	    if StampSet.isEmpty set then SEQ [S "(* use *)", NL]
	    else
		SEQ [S (List.foldl (fn (stamp, s) =>
				    s ^ " " ^ Stamp.toString stamp)
			"(* use" (sort set)), S " *)", NL]
	  | outputLiveness (ref (Kill set)) =
	    if StampSet.isEmpty set then SEQ [S "(* kill *)", NL]
	    else
		SEQ [S (List.foldl (fn (stamp, s) =>
				    s ^ " " ^ Stamp.toString stamp)
			"(* kill" (sort set)), S "*)", NL]

	fun outputInfo ({liveness, ...}: stm_info) = outputLiveness liveness

	fun outputLit (WordLit w) = "word " ^ LargeWord.toString w
	  | outputLit (IntLit i) = "int " ^ LargeInt.toString i
	  | outputLit (CharLit c) = "char " ^ Char.toCString c
	  | outputLit (StringLit s) = "string \"" ^ String.toCString s ^ "\""
	  | outputLit (RealLit r) = "real " ^ (*LargeReal.toString*) r

	fun outputTag Nullary = S "tag0"
	  | outputTag Unary = S "tag1"
	  | outputTag (Tuple _ | Record _) = S "tag+"

	fun outputCon Nullary = S "con0"
	  | outputCon Unary = S "con1"
	  | outputCon (Tuple _ | Record _) = S "con+"

	fun outputArgs (OneArg id) = ID id
	  | outputArgs (TupArgs ids) =
	    SEQ [S "(", SEP (S ", ", List.map ID ids), S ")"]
	  | outputArgs (RecArgs labelIdList) =
	    SEQ [S "{", SEP (S ", ",
			     List.map (fn (label, id) =>
				       SEQ [S (Label.toString label ^ "="),
					    ID id]) labelIdList),
		 S "}"]

	fun outputTest (LitTest lit) = S (outputLit lit)
	  | outputTest (TagTest label) =
	    SEQ [outputTag Nullary, S " ", S (Label.toString label)]
	  | outputTest (TagAppTest (label, args, conArity)) =
	    SEQ [S "(", outputTag conArity, S " ", S (Label.toString label),
		 S ") ", outputArgs args]
	  | outputTest (ConTest id) =
	    SEQ [outputCon Nullary, S " ", ID id]
	  | outputTest (ConAppTest (id, args, conArity)) =
	    SEQ [S "(", outputCon conArity, S " ", ID id, S ") ",
		 outputArgs args]
	  | outputTest (RefAppTest id) = SEQ [S "ref ", ID id]
	  | outputTest (TupTest ids) =
	    SEQ [S "(", SEP (S ", ", List.map ID ids), S ")"]
	  | outputTest (RecTest labelIdList) =
	    SEQ [S "{", SEP (S ", ",
			     List.map (fn (label, id) =>
				       SEQ [S (Label.toString label ^ "="),
					    ID id]) labelIdList),
		 S "}"]
	  | outputTest (LabTest (label, id)) =
	    SEQ [S ("{" ^ Label.toString label ^ "="), ID id, S "...}"]
	  | outputTest (VecTest ids) =
	    SEQ [S "#[", SEP (S ", ", List.map ID ids), S "]"]

	fun outputStm (ValDec (_, id, exp, isToplevel)) =
	    SEQ [S "val ", ID id, S " = ", IN, outputExp exp, EX,
		 if isToplevel then CO "toplevel" else NULL]
	  | outputStm (RecDec (_, idExpList, isToplevel)) =
	    SEQ [S "rec", IN, if isToplevel then CO "toplevel" else NULL,
		 SEQ (List.map (fn (id, exp) =>
				SEQ [NL, S "val ", ID id, S " = ",
				     IN, outputExp exp, EX]) idExpList), EX]
	  | outputStm (EvalStm (_, exp)) =
	    SEQ [S "eval ", IN, outputExp exp, EX]
	  | outputStm (HandleStm (_, body1, id, body2, body3, shared)) =
	    (shared := gen ();
	     SEQ [S "try", CO (Int.toString (!shared)), IN, NL,
		  outputBody body1, EX, NL,
		  S "catch ", ID id, IN, NL, outputBody body2, EX, NL,
		  S "cont", IN, NL, outputBody body3, EX])
	  | outputStm (EndHandleStm (_, ref i)) =
	    S ("(* leave " ^ Int.toString i ^ " *)")
	  | outputStm (TestStm (_, id, test, body1, body2)) =
	    SEQ [S "case ", ID id, S " of ", IN, outputTest test, NL,
		 outputBody body1, EX, NL, S "else", IN, NL, outputBody body2,
		 EX]
	  | outputStm (RaiseStm (_, id)) = SEQ [S "raise ", ID id]
	  | outputStm (ReraiseStm (_, id)) = SEQ [S "reraise ", ID id]
	  | outputStm (SharedStm (_, body, shared as ref 0)) =
	    (shared := gen ();
	     SEQ [S ("label " ^ (Int.toString (!shared)) ^ ":"), NL,
		  outputBody body])
	  | outputStm (SharedStm (_, _, ref i)) =
	    SEQ [S ("goto " ^ (Int.toString i))]
	  | outputStm (ReturnStm (_, exp)) =
	    SEQ [S "return ", IN, outputExp exp, EX]
	  | outputStm (IndirectStm (_, ref bodyOpt)) =
	    SEQ [S "indirect", NL, outputBody (valOf bodyOpt)]
	  | outputStm (ExportStm (_, exp)) =
	    SEQ [S "export ", IN, outputExp exp, EX]
	and outputExp (LitExp (_, lit)) = S (outputLit lit)
	  | outputExp (PrimExp (_, s)) = S ("prim \"" ^ s ^ "\"")
	  | outputExp (NewExp (_, conArity)) = outputCon conArity
	  | outputExp (VarExp (_, id)) = ID id
	  | outputExp (TagExp (_, label, conArity)) =
	    SEQ [outputTag conArity, S " ", S (Label.toString label)]
	  | outputExp (ConExp (_, id, conArity)) =
	    SEQ [outputCon conArity, S " ", ID id]
	  | outputExp (RefExp _) = SEQ [S "ref"]
	  | outputExp (TupExp (_, ids)) =
	    SEQ [S "(", SEP (S ", ", List.map ID ids), S ")"]
	  | outputExp (RecExp (_, labelIdList)) =
	    SEQ [S "{", SEP (S ", ",
			     List.map (fn (label, id) =>
				       SEQ [S (Label.toString label ^ "="),
					    ID id]) labelIdList),
		 S "}"]
	  | outputExp (SelExp (_, label)) =
	    SEQ [S ("#" ^ Label.toString label)]
	  | outputExp (VecExp (_, ids)) =
	    SEQ [S "#[", SEP (S ", ", List.map ID ids), S "]"]
	  | outputExp (FunExp (_, _, _, args, body)) =
	    SEQ [NL, S "fn ", outputArgs args, S " =>",
		 IN, NL, outputBody body, EX]
	  | outputExp (AppExp (_, id, args)) =
	    SEQ [ID id, S " ", outputArgs args]
	  | outputExp (SelAppExp (_, label, id)) =
	    SEQ [S ("#" ^ Label.toString label ^ " "), ID id]
	  | outputExp (TagAppExp (_, label, args, conArity)) =
	    SEQ [S "(", outputTag conArity, S " ", S (Label.toString label),
		 S ") ", outputArgs args]
	  | outputExp (ConAppExp (_, id, args, conArity)) =
	    SEQ [S "(", outputCon conArity, S " ", ID id, S ") ",
		 outputArgs args]
	  | outputExp (RefAppExp (_, id)) =
	    SEQ [S "ref ", ID id]
	  | outputExp (PrimAppExp (_, s, ids)) =
	    SEQ [S (s ^ " "), SEP (S ", ", List.map ID ids)]
	  | outputExp (AdjExp (_, id1, id2)) =
	    SEQ [S "adj ", ID id1, S ", ", ID id2]
	and outputBody stms =
	    SEP (NL,
		 List.map (fn stm =>
			   SEQ [outputInfo (infoStm stm), outputStm stm]) stms)

	fun outputComponent (importList, (body, _)) =
	    format (SEQ [SEQ (List.map
			      (fn (id, _, url) =>
			       SEQ [S "import ", ID id,
				    S (" from " ^ Url.toString url ^ "\n")])
			      importList), outputBody body, NL])
    end
(* src # 131 ../backend-common/INTERMEDIATE_AUX.sig *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature INTERMEDIATE_AUX =
    sig
	structure I: INTERMEDIATE_GRAMMAR = IntermediateGrammar
	structure O: FLAT_GRAMMAR = FlatGrammar

	val id_info: I.exp_info -> I.id_info
	val exp_info: Source.region * Type.t -> I.exp_info

	val freshId: I.exp_info -> I.id

	val idEq: I.id * I.id -> bool

	val occursInMatches: I.match list * I.id -> bool

	val patternVariablesOf: I.pat -> I.id list

	type subst = (I.id * I.id) list

	val substDec: I.dec * subst -> I.dec
	val substExp: I.exp * subst -> I.exp
	val substPat: I.pat * subst -> I.pat

	val separateAlt: I.pat -> I.pat

	val makeConArity: I.exp_info * bool -> O.conArity
    end
(* src # 132 ../backend-common/IntermediateAux.sml *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure IntermediateAux :> INTERMEDIATE_AUX =
    struct
	structure I = IntermediateGrammar
	open I

	fun id_info ({region, ...}: exp_info): id_info = {region = region}
	fun exp_info (region, typ): exp_info = {region = region, typ = typ}

	fun freshId (info: exp_info) =
	    Id (id_info info, Stamp.new (), Name.InId)

	fun idEq (Id (_, stamp1, _), Id (_, stamp2, _)) = stamp1 = stamp2

	fun occursInDec (ValDec (_, pat, exp), id) =
	    occursInPat (pat, id) orelse occursInExp (exp, id)
	  | occursInDec (RecDec (_, decs), id) =
	    List.exists (fn dec => occursInDec (dec, id)) decs
	and occursInExp (LitExp (_, _), _) = false
	  | occursInExp (PrimExp (_, _), _) = false
	  | occursInExp (NewExp (_, _), _) = false
	  | occursInExp (VarExp (_, ShortId (_, id)), id') = idEq (id, id')
	  | occursInExp (VarExp (_, LongId (_, _, _)), _) = false
	  | occursInExp (TagExp (_, _, _), _) = false
	  | occursInExp (ConExp (_, _, _), _) = false
	  | occursInExp (RefExp _, _) = false
	  | occursInExp (TupExp (_, exps), id) =
	    List.exists (fn exp => occursInExp (exp, id)) exps
	  | occursInExp (RowExp (_, expFields), id) =
	    List.exists (fn Field (_, _, exp) => occursInExp (exp, id))
	    expFields
	  | occursInExp (SelExp (_, _), _) = false
	  | occursInExp (VecExp (_, exps), id) =
	    List.exists (fn exp => occursInExp (exp, id)) exps
	  | occursInExp (FunExp (_, matches), id) =
	    occursInMatches (matches, id)
	  | occursInExp (AppExp (_, exp1, exp2), id) =
	    occursInExp (exp1, id) orelse occursInExp (exp2, id)
	  | occursInExp (AdjExp (_, exp1, exp2), id) =
	    occursInExp (exp1, id) orelse occursInExp (exp2, id)
	  | occursInExp (UpExp (_, exp), id) = occursInExp (exp, id)
	  | occursInExp (AndExp (_, exp1, exp2), id) =
	    occursInExp (exp1, id) orelse occursInExp (exp2, id)
	  | occursInExp (OrExp (_, exp1, exp2), id) =
	    occursInExp (exp1, id) orelse occursInExp (exp2, id)
	  | occursInExp (IfExp (_, exp1, exp2, exp3), id) =
	    occursInExp (exp1, id) orelse occursInExp (exp2, id) orelse
	    occursInExp (exp3, id)
	  | occursInExp (WhileExp (_, exp1, exp2), id) =
	    occursInExp (exp1, id) orelse occursInExp (exp2, id)
	  | occursInExp (SeqExp (_, exps), id) =
	    List.exists (fn exp => occursInExp (exp, id)) exps
	  | occursInExp (CaseExp (_, exp, matches), id) =
	    occursInExp (exp, id) orelse occursInMatches (matches, id)
	  | occursInExp (RaiseExp (_, exp), id) = occursInExp (exp, id)
	  | occursInExp (HandleExp (_, exp, matches), id) =
	    occursInExp (exp, id) orelse occursInMatches (matches, id)
	  | occursInExp (LetExp (_, decs, exp), id) =
	    List.exists (fn dec => occursInDec (dec, id)) decs orelse
	    occursInExp (exp, id)
	and occursInMatches (matches, id) =
	    List.exists (fn Match (_, pat, exp) =>
		       occursInPat (pat, id) orelse occursInExp (exp, id))
	    matches
	and occursInPat (WildPat _, _) = false
	  | occursInPat (LitPat (_, _), _) = false
	  | occursInPat (VarPat (_, _), _) = false
	  | occursInPat (TagPat (_, _, _), _) = false
	  | occursInPat (ConPat (_, _, _), _) = false
	  | occursInPat (RefPat _, id) = false
	  | occursInPat (TupPat (_, pats), id) =
	    List.exists (fn pat => occursInPat (pat, id)) pats
	  | occursInPat (RowPat (_, patFields), id) =
	    List.exists (fn Field (_, _, pat) => occursInPat (pat, id))
	    patFields
	  | occursInPat (VecPat (_, pats), id) =
	    List.exists (fn pat => occursInPat (pat, id)) pats
	  | occursInPat (AppPat (_, pat1, pat2), id) =
	    occursInPat (pat1, id) orelse occursInPat (pat2, id)
	  | occursInPat (AsPat (_, pat1, pat2), id) =
	    occursInPat (pat1, id) orelse occursInPat (pat2, id)
	  | occursInPat (AltPat (_, pats), id) =
	    List.exists (fn pat => occursInPat (pat, id)) pats
	  | occursInPat (NegPat (_, pat), id) = occursInPat (pat, id)
	  | occursInPat (GuardPat (_, pat, exp), id) =
	    occursInPat (pat, id) orelse occursInExp (exp, id)
	  | occursInPat (WithPat (_, pat, decs), id) =
	    occursInPat (pat, id) orelse
	    List.exists (fn dec => occursInDec (dec, id)) decs

	local
	    fun patternVariablesOf' (WildPat _, ids) = ids
	      | patternVariablesOf' (LitPat (_, _), ids) = ids
	      | patternVariablesOf' (VarPat (_, id), ids) = id::ids
	      | patternVariablesOf' (TagPat (_, _, _), ids) = ids
	      | patternVariablesOf' (ConPat (_, _, _), ids) = ids
	      | patternVariablesOf' (RefPat _, ids) = ids
	      | patternVariablesOf' (TupPat (_, pats), ids) =
		foldr patternVariablesOf' ids pats
	      | patternVariablesOf' (RowPat (_, fieldPats), ids) =
		foldr (fn (Field (_, _, pat), ids) =>
		       patternVariablesOf' (pat, ids)) ids fieldPats
	      | patternVariablesOf' (VecPat (_, pats), ids) =
		foldr patternVariablesOf' ids pats
	      | patternVariablesOf' (AppPat (_, pat1, pat2), ids) =
		patternVariablesOf' (pat1, patternVariablesOf' (pat2, ids))
	      | patternVariablesOf' (AsPat (_, pat1, pat2), ids) =
		patternVariablesOf' (pat1, patternVariablesOf' (pat2, ids))
	      | patternVariablesOf' (AltPat (_, pat::_), ids) =
		patternVariablesOf' (pat, ids)
	      | patternVariablesOf' (AltPat (_, nil), ids) = ids
	      | patternVariablesOf' (NegPat (_, _), ids) = ids
	      | patternVariablesOf' (GuardPat (_, pat, _), ids) =
		patternVariablesOf' (pat, ids)
	      | patternVariablesOf' (WithPat (_, pat, decs), ids) =
		patternVariablesOf' (pat, foldr declaredVariables ids decs)
	    and declaredVariables (ValDec (_, pat, _), ids) =
		patternVariablesOf' (pat, ids)
	      | declaredVariables (RecDec (_, decs), ids) =
		foldr declaredVariables ids decs
	in
	    fun patternVariablesOf pat = patternVariablesOf' (pat, nil)
	end

	type subst = (id * id) list

	fun lookup ((Id (_, stamp, _), id')::subst, id0 as Id (_, stamp0, _)) =
	    if stamp = stamp0 then id'
	    else lookup (subst, id0)
	  | lookup (nil, id0) = id0

	fun substLongId (ShortId (info, id), subst) =
	    ShortId (info, lookup (subst, id))
	  | substLongId (longid as LongId (_, _, _), _) = longid

	fun substDecs (dec::decr, subst) =
	    substDec (dec, subst)::substDecs (decr, subst)
	  | substDecs (nil, _) = nil
	and substDec (ValDec (info, pat, exp), subst) =
	    ValDec (info, substPat (pat, subst), substExp (exp, subst))
	  | substDec (RecDec (info, decs), subst) =
	    RecDec (info, List.map (fn dec => substDec (dec, subst)) decs)
	and substExp (exp as LitExp (_, _), _) = exp
	  | substExp (exp as PrimExp (_, _), _) = exp
	  | substExp (exp as NewExp (_, _), _) = exp
	  | substExp (VarExp (info, longid), subst) =
	    VarExp (info, substLongId (longid, subst))
	  | substExp (exp as TagExp (_, _, _), _) = exp
	  | substExp (exp as ConExp (_, _, _), _) = exp
	  | substExp (exp as RefExp _, _) = exp
	  | substExp (TupExp (info, exps), subst) =
	    TupExp (info, List.map (fn exp => substExp (exp, subst)) exps)
	  | substExp (RowExp (info, expFields), subst) =
	    RowExp (info,
		    List.map (fn Field (info, label, exp) =>
			      Field (info, label, substExp (exp, subst)))
		    expFields)
	  | substExp (exp as SelExp (_, _), _) = exp
	  | substExp (VecExp (info, exps), subst) =
	    VecExp (info, List.map (fn exp => substExp (exp, subst)) exps)
	  | substExp (FunExp (info, matches), subst) =
	    FunExp (info, substMatches (matches, subst))
	  | substExp (AppExp (info, exp1, exp2), subst) =
	    AppExp (info, substExp (exp1, subst), substExp (exp2, subst))
	  | substExp (AdjExp (info, exp1, exp2), subst) =
	    AdjExp (info, substExp (exp1, subst), substExp (exp2, subst))
	  | substExp (UpExp (info, exp), subst) =
	    UpExp (info, substExp (exp, subst))
	  | substExp (AndExp (info, exp1, exp2), subst) =
	    AndExp (info, substExp (exp1, subst), substExp (exp2, subst))
	  | substExp (OrExp (info, exp1, exp2), subst) =
	    OrExp (info, substExp (exp1, subst), substExp (exp2, subst))
	  | substExp (IfExp (info, exp1, exp2, exp3), subst) =
	    IfExp (info, substExp (exp1, subst),
		   substExp (exp2, subst), substExp (exp3, subst))
	  | substExp (WhileExp (info, exp1, exp2), subst) =
	    WhileExp (info, substExp (exp1, subst), substExp (exp2, subst))
	  | substExp (SeqExp (info, exps), subst) =
	    SeqExp (info, List.map (fn exp => substExp (exp, subst)) exps)
	  | substExp (CaseExp (info, exp, matches), subst) =
	    CaseExp (info, substExp (exp, subst),
		     substMatches (matches, subst))
	  | substExp (RaiseExp (info, exp), subst) =
	    RaiseExp (info, substExp (exp, subst))
	  | substExp (HandleExp (info, exp, matches), subst) =
	    HandleExp (info, substExp (exp, subst),
		       substMatches (matches, subst))
	  | substExp (LetExp (info, decs, exp), subst) =
	    LetExp (info, substDecs (decs, subst), substExp (exp, subst))
	and substMatches (matches, subst) =
	    List.map (fn Match (info, pat, exp) =>
		      Match (info, substPat (pat, subst),
			     substExp (exp, subst))) matches
	and substPat (pat as WildPat _, _) = pat
	  | substPat (pat as LitPat (_, _), _) = pat
	  | substPat (pat as VarPat (_, _), _) = pat
	  | substPat (pat as TagPat (_, _, _), _) = pat
	  | substPat (ConPat (info, longid, isNAry), subst) =
	    ConPat (info, substLongId (longid, subst), isNAry)
	  | substPat (pat as RefPat _, subst) = pat
	  | substPat (TupPat (info, pats), subst) =
	    TupPat (info, List.map (fn pat => substPat (pat, subst)) pats)
	  | substPat (RowPat (info, patFields), subst) =
	    RowPat (info,
		    List.map (fn Field (info, label, pat) =>
			      Field (info, label, substPat (pat, subst)))
		    patFields)
	  | substPat (VecPat (info, pats), subst) =
	    VecPat (info, List.map (fn pat => substPat (pat, subst)) pats)
	  | substPat (AppPat (info, pat1, pat2), subst) =
	    AppPat (info, substPat (pat1, subst), substPat (pat2, subst))
	  | substPat (AsPat (info, pat1, pat2), subst) =
	    AsPat (info, substPat (pat1, subst), substPat (pat2, subst))
	  | substPat (AltPat (info, pats), subst) =
	    AltPat (info, List.map (fn pat => substPat (pat, subst)) pats)
	  | substPat (NegPat (info, pat), subst) =
	    NegPat (info, substPat (pat, subst))
	  | substPat (GuardPat (info, pat, exp), subst) =
	    GuardPat (info, substPat (pat, subst), substExp (exp, subst))
	  | substPat (WithPat (info, pat, decs), subst) =
	    WithPat (info, substPat (pat, subst), substDecs (decs, subst))

	(* If the same test occurs in two patterns at the same position,
	 * then these may be merged by the pattern matching compiler.
	 * In this process, a global substitution is built such that the
	 * identifiers bound at each pattern position are all mapped to
	 * common identifiers.
	 * In the presence of disjunctive patterns, such a substitution can
	 * in general only be made consistent with all pattern bindings by
	 * first uniquely renaming, then binding all the original identifiers
	 * by `with' declarations.  `with' declarations are not affected by
	 * the substitution because they are never merged.
	 *
	 * `separateAlt' moves all bindings to `with' declarations.  These
	 * are placed right at the end of each alternative pattern to allow
	 * for a maximum of merging possibilities.
	 * In principle, it is sufficient to do so only within disjunctive
	 * patterns.  If we apply this on the toplevel as well however,
	 * we need not substitute into the right hand side of a match.
	 *)

	fun separateAlt pat =
	    let
		val (pat', subst) = relax (pat, nil)
		val decs =
		    List.map
		    (fn (id, id', info) =>
		     let
			 val info' = id_info info
			 val exp = VarExp (info, ShortId (info', id'))
		     in
			 ValDec (info', VarPat (info, id), exp)
		     end) subst
	    in
		case decs of
		    nil => pat'
		  | _::_ => WithPat (infoPat pat', pat', decs)
	    end
	and relax (pat as WildPat _, subst) = (pat, subst)
	  | relax (pat as LitPat (_, _), subst) = (pat, subst)
	  | relax (VarPat (info, id), subst) =
	    let
		val id' = freshId info
	    in
		(VarPat (info, id'), (id, id', info)::subst)
	    end
	  | relax (pat as TagPat (_, _, _), subst) = (pat, subst)
	  | relax (pat as ConPat (_, _, _), subst) = (pat, subst)
	  | relax (pat as RefPat _, subst) = (pat, subst)
	  | relax (TupPat (info, pats), subst) =
	    let
		val (pats', subst') =
		    List.foldr (fn (pat, (pats, subst)) =>
				let
				    val (pat', subst') = relax (pat, subst)
				in
				    (pat'::pats, subst')
				end) (nil, subst) pats
	    in
		(TupPat (info, pats'), subst')
	    end
	  | relax (RowPat (info, patFields), subst) =
	    let
		val (patFields', subst') =
		    List.foldr
		    (fn (Field (info, label, pat), (patFields, subst)) =>
		     let
			 val (pat', subst') = relax (pat, subst)
		     in
			 (Field (info, label, pat')::patFields, subst')
		     end) (nil, subst) patFields
	    in
		(RowPat (info, patFields'), subst')
	    end
	  | relax (VecPat (info, pats), subst) =
	    let
		val (pats', subst') =
		    List.foldr (fn (pat, (pats, subst)) =>
				let
				    val (pat', subst') = relax (pat, subst)
				in
				    (pat'::pats, subst')
				end) (nil, subst) pats
	    in
		(VecPat (info, pats'), subst')
	    end
	  | relax (AppPat (info, pat1, pat2), subst) =
	    let
		val (pat1', subst') = relax (pat1, subst)
		val (pat2', subst'') = relax (pat2, subst')
	    in
		(AppPat (info, pat1', pat2'), subst'')
	    end
	  | relax (AsPat (info, pat1, pat2), subst) =
	    let
		val (pat1', subst') = relax (pat1, subst)
		val (pat2', subst'') = relax (pat2, subst')
	    in
		(AsPat (info, pat1', pat2'), subst'')
	    end
	  | relax (AltPat (info, pats), subst) =
	    (AltPat (info, List.map separateAlt pats), subst)
	  | relax (NegPat (info, pat), subst) =
	    (NegPat (info, separateAlt pat), subst)
	  | relax (GuardPat (info, pat, exp), subst) =
	    let
		val (pat', subst') = relax (pat, subst)
		val subst'' = List.map (fn (id1, id2, _) => (id1, id2)) subst'
	    in
		(GuardPat (info, pat', substExp (exp, subst'')), subst')
	    end
	  | relax (WithPat (info, pat, decs), subst) =
	    let
		val (pat', subst') = relax (pat, subst)
		val subst'' = List.map (fn (id1, id2, _) => (id1, id2)) subst'
	    in
		(WithPat (info, pat', substDecs (decs, subst'')), subst')
	    end

	structure O = FlatGrammar
	open O

	local
	    fun parseRow row =
		if Type.isEmptyRow row then
		    if Type.isUnknownRow row then
			raise Crash.Crash "IntermediateAus.parseRow 1"
		    else nil
		else
		    case Type.headRow row of
			(label, [typ]) =>
			    (label, typ)::parseRow (Type.tailRow row)
		      | (_, _) =>
			    raise Crash.Crash "IntermediateAux.parseRow 2"
	in
	    fun makeConArity ({typ, ...}: I.exp_info, isNAry) =
		if Type.isArrow typ then
		    if isNAry then
			let
			    val (argTyp, _) = Type.asArrow typ
			in
			    if Type.isTuple argTyp then
				Tuple (List.length (Type.asTuple argTyp))
			    else if Type.isProd argTyp then
				case LabelSort.sort
					(parseRow (Type.asProd argTyp)) of
				    (_, LabelSort.Tup i) => Tuple i
				  | (labelTypList, LabelSort.Rec) =>
					Record (List.map #1 labelTypList)
			    else Unary
			end
		    else Unary
		else Nullary
	end
    end
(* src # 133 ../backend-common/SIMPLIFY_MATCH.sig *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature SIMPLIFY_MATCH =
    sig
	structure I: INTERMEDIATE_GRAMMAR = IntermediateGrammar
	structure O: FLAT_GRAMMAR = FlatGrammar

	datatype selector =
	    LABEL of Label.t
	  | LONGID of Stamp.t * Label.t list
	type pos = selector list
	type typ = Type.t

	datatype test =
	    LitTest of I.lit
	  | TagTest of Label.t
	  | TagAppTest of Label.t * typ O.args * O.conArity
	  | ConTest of I.longid
	  | ConAppTest of I.longid * typ O.args * O.conArity
	  | RefAppTest of typ
	  | TupTest of typ list
	  | RecTest of (Label.t * typ) list
	    (* sorted, all labels distinct, no tuple *)
	  | LabTest of Label.t * typ
	  | VecTest of typ list
	  | GuardTest of mapping * I.exp
	  | DecTest of mapping * I.dec list
	withtype mapping = (pos * I.id) list

	val longidToSelector: I.longid -> selector

	datatype testGraph =
	    Node of pos * test * testGraph ref * testGraph ref * nodeStatus ref
	  | Leaf of O.body * O.body option ref
	  | Default
	and nodeStatus =
	    Initial
	  | Raw of testGraph list * testGraph list
	  | Cooked of (pos * test) list * (pos * test) list
	  | Optimized of (pos * test) list * (pos * test) list
	  | Translated of O.body

	val posToString: pos -> string
	val testToString: test -> string
	val graphToString: testGraph * int -> string
	val mappingToString: mapping -> string

	type consequent = (Source.region * O.body option ref)

	val buildGraph: (Source.region * I.pat * O.body) list * O.body ->
	    testGraph * consequent list

	val buildFunArgs: (Source.region * I.pat * O.body) list * O.body ->
	    O.id O.args * testGraph * mapping * consequent list
    end
(* src # 134 ../backend-common/SimplifyMatch.sml *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure SimplifyMatch :> SIMPLIFY_MATCH =
    struct
	structure I = IntermediateGrammar
	structure O = FlatGrammar

	open I
	open IntermediateAux

	(* Tests *)

	datatype selector =
	    LABEL of Label.t
	  | LONGID of Stamp.t * Label.t list
	type pos = selector list
	type typ = Type.t

	datatype test =
	    LitTest of I.lit
	  | TagTest of Label.t
	  | TagAppTest of Label.t * typ O.args * O.conArity
	  | ConTest of I.longid
	  | ConAppTest of I.longid * typ O.args * O.conArity
	  | RefAppTest of typ
	  | TupTest of typ list
	  | RecTest of (Label.t * typ) list
	    (* sorted, all labels distinct, no tuple *)
	  | LabTest of Label.t * typ
	  | VecTest of typ list
	  | GuardTest of mapping * I.exp
	  | DecTest of mapping * I.dec list
	withtype mapping = (pos * id) list

	(* Test Sequences *)

	datatype testSeqElem =
	    Test of pos * test
	  | Neg of testSeq
	  | Alt of testSeq list
	withtype testSeq = testSeqElem list

	(* Test Sequence Construction *)

	fun typPat pat = #typ (infoPat pat)

	local
	    fun longidToSelector' (ShortId (_, Id (_, stamp, _))) =
		(stamp, nil)
	      | longidToSelector' (LongId (_, longid, Lab (_, label))) =
		let
		    val (stamp, labels) = longidToSelector' longid
		in
		    (stamp, label::labels)
		end
	in
	    fun longidToSelector longid =
		let
		    val (stamp, labels) = longidToSelector' longid
		in
		    LONGID (stamp, List.rev labels)
		end
	end

	local
	    fun parseRow row =
		if Type.isEmptyRow row then (nil, Type.isUnknownRow row)
		else
		    let
			val (rest, hasDots) = parseRow (Type.tailRow row)
		    in
			case Type.headRow row of
			    (label, [typ]) => ((label, typ)::rest, hasDots)
			  | (_, _) =>
				raise Crash.Crash "SimplifyMatch.parseRow"
		    end
	in
	    fun getRow typ =
		let
		    val (labelTypList, hasDots) =
			if Type.isProd typ then parseRow (Type.asProd typ)
			else
			    (Misc.List_mapi (fn (i, typ) =>
					     (Label.fromInt (i + 1), typ))
			     (Type.asTuple typ), false)
		    val (labelTypList', arity) = LabelSort.sort labelTypList
		in
		    (labelTypList', arity, hasDots)
		end
	end

	fun makeAppArgs (TupPat (_, pats), true, pos) =
	    (Misc.List_mapi (fn (i, pat) =>
			     (LABEL (Label.fromInt (i + 1))::pos, pat)) pats,
	     O.TupArgs (List.map typPat pats))
	  | makeAppArgs (pat as RowPat (info, patFields), true, pos) =
	    (case getRow (#typ info) of
		 (_, _, true) => ([(pos, pat)], O.OneArg (#typ info))
	       | (labelTypList, LabelSort.Tup _, false) =>
		     (List.map (fn Field (_, Lab (_, label), pat) =>
				(LABEL label::pos, pat)) patFields,
		      O.TupArgs (List.map #2 labelTypList))
	       | (labelTypList, LabelSort.Rec, false) =>
		     (List.map (fn Field (_, Lab (_, label), pat) =>
				(LABEL label::pos, pat)) patFields,
		      O.RecArgs labelTypList))
	  | makeAppArgs (pat, _, pos) = ([(pos, pat)], O.OneArg (typPat pat))

	fun makeTestSeq (WildPat _, _, rest, mapping) = (rest, mapping)
	  | makeTestSeq (LitPat (_, lit), pos, rest, mapping) =
	    (Test (pos, LitTest lit)::rest, mapping)
	  | makeTestSeq (VarPat (_, id), pos, rest, mapping) =
	    (rest, (pos, id)::mapping)
	  | makeTestSeq (TagPat (_, Lab (_, label), _), pos, rest, mapping) =
	    (Test (pos, TagTest label)::rest, mapping)
	  | makeTestSeq (AppPat (_, TagPat (info, Lab (_, label), isNAry),
				 pat), pos, rest, mapping) =
	    let
		val (posPatList, args) =
		    makeAppArgs (pat, isNAry, LABEL label::pos)
		val typ = Type.inArrow (typPat pat, #typ info)
		val info' = exp_info (Source.nowhere, typ)
		val conArity = makeConArity (info', isNAry)
	    in
		List.foldl (fn ((pos, pat), (rest, mapping)) =>
			    makeTestSeq (pat, pos, rest, mapping))
		(Test (pos, TagAppTest (label, args, conArity))::rest, mapping)
		posPatList
	    end
	  | makeTestSeq (ConPat (_, longid, _), pos, rest, mapping) =
	    (Test (pos, ConTest longid)::rest, mapping)
	  | makeTestSeq (AppPat (_, ConPat (info, longid, isNAry), pat),
			 pos, rest, mapping) =
	    let
		val (posPatList, args) =
		    makeAppArgs (pat, isNAry, longidToSelector longid::pos)
		val typ = Type.inArrow (typPat pat, #typ info)
		val info' = exp_info (Source.nowhere, typ)
		val conArity = makeConArity (info', isNAry)
	    in
		List.foldl (fn ((pos, pat), (rest, mapping)) =>
			    makeTestSeq (pat, pos, rest, mapping))
		(Test (pos, ConAppTest (longid, args, conArity))::rest,
		 mapping) posPatList
	    end
	  | makeTestSeq (AppPat (_, RefPat _, pat), pos, rest, mapping) =
	    makeTestSeq (pat, LABEL (Label.fromString "ref")::pos,
			 Test (pos, RefAppTest (typPat pat))::rest, mapping)
	  | makeTestSeq (TupPat (_, pats), pos, rest, mapping) =
	    Misc.List_foldli
	    (fn (i, pat, (rest, mapping)) =>
	     makeTestSeq (pat, LABEL (Label.fromInt (i + 1))::pos,
			  rest, mapping))
	    (Test (pos, TupTest (List.map typPat pats))::rest, mapping) pats
	  | makeTestSeq (RowPat (info, patFields), pos, rest, mapping) =
	    List.foldl (fn (Field (_, Lab (_, label), pat), (rest, mapping)) =>
			makeTestSeq (pat, LABEL label::pos, rest, mapping))
	    (case getRow (#typ info) of
		 (labelTypList, _, true) =>
		     List.foldl (fn ((label, typ), rest) =>
				 Test (pos, LabTest (label, typ))::rest)
		     rest labelTypList
	       | (labelTypList, LabelSort.Tup _, false) =>
		     Test (pos, TupTest (List.map #2 labelTypList))::rest
	       | (labelTypList, LabelSort.Rec, false) =>
		     Test (pos, RecTest labelTypList)::rest, mapping) patFields
	  | makeTestSeq (VecPat (_, pats), pos, rest, mapping) =
	    Misc.List_foldli
	    (fn (i, pat, (rest, mapping)) =>
	     makeTestSeq (pat, LABEL (Label.fromInt (i + 1))::pos,
			  rest, mapping))
	    (Test (pos, VecTest (List.map typPat pats))::rest, mapping)
	    pats
	  | makeTestSeq (AsPat (_, pat1, pat2), pos, rest, mapping) =
	    let
		val (rest', mapping') = makeTestSeq (pat1, pos, rest, mapping)
	    in
		makeTestSeq (pat2, pos, rest', mapping')
	    end
	  | makeTestSeq (AltPat (_, pats), pos, rest, mapping) =
	    (Alt (List.map (fn pat =>
			    let
				val (rest', _) =
				    makeTestSeq (pat, pos, nil, mapping)
			    in
				List.rev rest'
			    end) pats)::rest, mapping)
	  | makeTestSeq (NegPat (_, pat), pos, rest, mapping) =
	    let
		val (rest', _) = makeTestSeq (pat, pos, nil, mapping)
	    in
		(Neg (List.rev rest')::rest, mapping)
	    end
	  | makeTestSeq (GuardPat (_, pat, exp), pos, rest, mapping) =
	    let
		val (rest', mapping') = makeTestSeq (pat, pos, rest, mapping)
	    in
		(Test (pos, GuardTest (mapping', exp))::rest', mapping')
	    end
	  | makeTestSeq (WithPat (_, pat, decs), pos, rest, mapping) =
	    let
		val (rest', mapping') = makeTestSeq (pat, pos, rest, mapping)
	    in
		(Test (pos, DecTest (mapping', decs))::rest', mapping')
	    end
	  | makeTestSeq ((RefPat _ | AppPat (_, _, _)), _, _, _) =
	    raise Crash.Crash "SimplifyMatch.makeTestSeq"

	(* Test Graphs *)

	datatype testGraph =
	    Node of pos * test * testGraph ref * testGraph ref * nodeStatus ref
	  | Leaf of O.body * O.body option ref
	  | Default
	and nodeStatus =
	    Initial
	  | Raw of testGraph list * testGraph list
	  | Cooked of (pos * test) list * (pos * test) list
	  | Optimized of (pos * test) list * (pos * test) list
	  | Translated of O.body

	(* Debugging *)

	fun posToString' (LABEL l::rest) =
	    Label.toString l ^ "." ^ posToString' rest
	  | posToString' (LONGID _::rest) =
	    "<longid>." ^ posToString' rest
	  | posToString' nil = "<e>"

	fun posToString pos = posToString' (List.rev pos)

	fun indent 0 = ""
	  | indent n = "  " ^ indent (n - 1)

	fun testToString (LitTest _) = "lit"
	  | testToString (TagTest label | TagAppTest (label, O.OneArg _, _)) =
	    "tag " ^ Label.toString label
	  | testToString (TagAppTest (label, O.TupArgs typs, _)) =
	    "tag tup " ^ Int.toString (List.length typs)
	  | testToString (TagAppTest (label, O.RecArgs labelTypList, _)) =
	    "tag rec"
	  | testToString (ConTest _ | ConAppTest (_, O.OneArg _, _)) = "con"
	  | testToString (ConAppTest (_, O.TupArgs typs, _)) =
	    "con tup " ^ Int.toString (List.length typs)
	  | testToString (ConAppTest (_, O.RecArgs labelTypList, _)) =
	    "con rec"
	  | testToString (RefAppTest _) = "ref"
	  | testToString (TupTest typs) =
	    "tup " ^ Int.toString (List.length typs)
	  | testToString (RecTest labelTyplist) = "rec"
	  | testToString (LabTest (label, _)) = "lab " ^ Label.toString label
	  | testToString (VecTest typs) =
	    "vec " ^ Int.toString (List.length typs)
	  | testToString (GuardTest (_, _)) = "guard"
	  | testToString (DecTest (_, decs)) =
	    "dec " ^ Int.toString (List.length decs)

	fun graphToString (Node (pos, test, ref thenGraph, ref elseGraph, _),
			   level) =
	    indent level ^
	    posToString pos ^ ": " ^
	    testToString test ^ "\n" ^
	    graphToString (thenGraph, level + 1) ^
	    graphToString (elseGraph, level + 1)
	  | graphToString (Leaf (_, _), level) = indent level ^ "leaf\n"
	  | graphToString (Default, level) = indent level ^ "default\n"

	fun mappingToString' ((pos, _)::mapping) =
	    " " ^ posToString pos ^ mappingToString' mapping
	  | mappingToString' nil = ""

	fun mappingToString mapping =
	    "dom(mapping) =" ^ mappingToString' mapping ^ "\n"

	fun testSeqToString' (Test (pos, test)::rest) =
	    posToString pos ^ ": " ^ testToString test ^ "\n" ^
	    testSeqToString' rest
	  | testSeqToString' (Neg testSeq::rest) =
	    "<neg>\n" ^ testSeqToString' testSeq ^ "</neg>\n" ^
	    testSeqToString' rest
	  | testSeqToString' (Alt testSeqs::rest) =
	    List.foldr (fn (testSeq, s) =>
			"<alt>\n" ^ testSeqToString' testSeq ^ s)
	    "</alt>\n" testSeqs ^
	    testSeqToString' rest
	  | testSeqToString' nil = ""

	fun testSeqToString testSeq =
	    "<seq>\n" ^ testSeqToString' testSeq ^ "</seq>\n"

	(* Construction of Backtracking Test Trees *)

	fun argsEq (O.OneArg _, O.OneArg _) = true
	  | argsEq (O.TupArgs _, O.TupArgs _) = true
	  | argsEq (O.RecArgs _, O.RecArgs _) = true
	  | argsEq (_, _) = false

	fun testEq (LitTest lit1, LitTest lit2) = lit1 = lit2
	  | testEq (TagTest label1, TagTest label2) = label1 = label2
	  | testEq (TagAppTest (label1, args1, _),
		    TagAppTest (label2, args2, _)) =
	    label1 = label2 andalso argsEq (args1, args2)
	  | testEq (ConTest longid1, ConTest longid2) =
	    longidToSelector longid1 = longidToSelector longid2
	  | testEq (ConAppTest (longid1, args1, _),
		    ConAppTest (longid2, args2, _)) =
	    longidToSelector longid1 = longidToSelector longid2 andalso
	    argsEq (args1, args2)
	  | testEq (TupTest _, TupTest _) = true
	  | testEq (RecTest _, RecTest _) = true
	  | testEq (VecTest typs1, VecTest typs2) =
	    List.length typs1 = List.length typs2
	  | testEq (_, _) = false

	fun areParallelTests (LitTest lit1, LitTest lit2) = lit1 <> lit2
	  | areParallelTests (VecTest typs1, VecTest typs2) =
	    List.length typs1 <> List.length typs2
	  | areParallelTests (_, _) = false

	local
	    fun findTest (Node (pos', test', thenTreeRef, elseTreeRef, _),
			  pos, test) =
		if pos = pos' then
		    if testEq (test, test') then SOME thenTreeRef
		    else if areParallelTests (test, test') then
			findTest (!elseTreeRef, pos, test)
		    else NONE
		else NONE
	      | findTest (_, _, _) = NONE
	in
	    fun mergeIntoTree (nil, thenTree, _) = thenTree
	      | mergeIntoTree (Test (pos, test)::testSeqRest,
			       thenTree, elseTree) =
		(case findTest (elseTree, pos, test) of
		     SOME treeRef =>
			 let
			     val newTree = mergeIntoTree (testSeqRest,
							  thenTree, !treeRef)
			 in
			     treeRef := newTree; elseTree
			 end
		   | NONE =>
			 let
			     val newThenTree =
				 mergeIntoTree (testSeqRest, thenTree, Default)
			 in
			     Node (pos, test, ref newThenTree, ref elseTree,
				   ref Initial)
			 end)
	      | mergeIntoTree (Neg testSeq::testSeqRest, thenTree, elseTree) =
		mergeIntoTree (testSeq, elseTree,
			       mergeIntoTree (testSeqRest, thenTree, elseTree))
	      | mergeIntoTree (Alt testSeqs::testSeqRest, thenTree, elseTree) =
		let
		    val newThenTree =
			mergeIntoTree (testSeqRest, thenTree, Default)
		in
		    List.foldr (fn (testSeq, elseTree) =>
				mergeIntoTree (testSeq, newThenTree, elseTree))
		    elseTree testSeqs
		end
	end

	(* Elimination of Backtracking, Producing a Test Graph *)

	fun propagateElses (Node (_, _, thenTreeRef, elseTreeRef, _),
			    defaultTree) =
	    (case !elseTreeRef of
		 Default => elseTreeRef := defaultTree
	       | elseTree => propagateElses (elseTree, defaultTree);
	     case !thenTreeRef of
		 Default => thenTreeRef := defaultTree
	       | thenTree => propagateElses (thenTree, !elseTreeRef))
	  | propagateElses (Leaf (_, _), _) = ()
	  | propagateElses (Default, _) =
	    raise Crash.Crash "SimplifyMatch.propagateElses"

	(* Optimization of the Test Graph *)

	local
	    fun union (NONE, gs) = gs
	      | union (SOME g, gr) = g::gr

	    fun computeRaw (graph as Node (_, _, ref thenGraph, ref elseGraph,
					   status as ref Initial),
			    prevTrueOpt, prevFalseOpt) =
		(status := Raw (union (prevTrueOpt, nil),
				union (prevFalseOpt, nil));
		 computeRaw (thenGraph, SOME graph, NONE);
		 computeRaw (elseGraph, NONE, SOME graph))
	      | computeRaw (Node (_, _, _, _, status as
				  ref (Raw (trueGraphs, falseGraphs))),
			    prevTrueOpt, prevFalseOpt) =
		status := Raw (union (prevTrueOpt, trueGraphs),
			       union (prevFalseOpt, falseGraphs))
	      | computeRaw (_, _, _) = ()

	    fun testSetMember (pos, test, (pos', test')::testSetRest) =
		pos = pos' andalso testEq (test, test')
		orelse testSetMember (pos, test, testSetRest)
	      | testSetMember (_, _, nil) = false

	    fun testSetIntersect ((pos, test)::testSetRest, testSet') =
		if testSetMember (pos, test, testSet') then
		    (pos, test)::(testSetIntersect (testSetRest, testSet'))
		else testSetIntersect (testSetRest, testSet')
	      | testSetIntersect (nil, _) = nil

	    fun getSets (status as ref (Raw (trueGraphs, falseGraphs))) =
		let
		    val sets = (makePosTestList (trueGraphs, true),
				makePosTestList (falseGraphs, false))
		in
		    status := Cooked sets; sets
		end
	      | getSets (ref (Cooked sets)) = sets
	      | getSets (ref (Optimized sets)) = sets
	      | getSets (ref _) = raise Crash.Crash "SimplifyMatch.getSets"
	    and makePosTestList (graphs, isTrue) =
		List.foldr
		(fn (graph, posTestList) =>
		 case graph of
		     Node (pos, test, _, _, status) =>
			 let
			     val (trueSet, falseSet) = getSets status
			 in
			     if isTrue then
				 testSetIntersect
				 ((pos, test)::trueSet, falseSet)
			     else
				 testSetIntersect
				 (trueSet, (pos, test)::falseSet)
			 end
		   | _ => raise Crash.Crash "SimplifyMatch.cook")
		nil graphs

	    fun disentailed (pos, test, (pos', test')::rest) =
		pos = pos' andalso areParallelTests (test, test')
		orelse disentailed (pos, test, rest)
	      | disentailed (_, _, nil) = false

	    fun optimize (ref (Node (_, _, _, _, ref (Optimized (_, _))))) = ()
	      | optimize (graphRef as
			  ref (Node (pos, test, thenGraphRef, elseGraphRef,
				     status))) =
		let
		    val sets as (trueSet, falseSet) = getSets status
		in
		    if testSetMember (pos, test, trueSet) then
			(graphRef := !thenGraphRef; optimize graphRef)
		    else if testSetMember (pos, test, falseSet)
			orelse disentailed (pos, test, trueSet) then
			(graphRef := !elseGraphRef; optimize graphRef)
		    else
			(status := Optimized sets;
			 optimize thenGraphRef;
			 optimize elseGraphRef)
		end
	      | optimize (ref (Leaf (_, _))) = ()
	      | optimize (ref _) = raise Crash.Crash "SimplifyMatch.optimize"
	in
	    fun optimizeGraph graph =
		let
		    val _ = computeRaw (graph, NONE, NONE)
		    val graphRef = ref graph
		in
		    optimize graphRef; !graphRef
		end
	end

	type consequent = (Source.region * O.body option ref)

	fun buildGraph (matches, elseExp) =
	    let
		val (graph, consequents) =
		    List.foldr (fn ((region, pat, thenExp),
				    (elseTree, consequents)) =>
				let
				    val pat' = separateAlt pat
				    val (testSeq, _) =
					makeTestSeq (pat', nil, nil, nil)
				    val r = ref NONE
				    val leaf = Leaf (thenExp, r)
				in
				    (mergeIntoTree (List.rev testSeq,
						    leaf, elseTree),
				     (region, r)::consequents)
				end) (Default, nil) matches
		val elseGraph = Leaf (elseExp, ref NONE)
	    in
		case graph of
		    Default =>
			(elseGraph, consequents)
		  | _ =>
			(propagateElses (graph, elseGraph);
			 (optimizeGraph graph, consequents))
	    end

	(*
	 * Check whether the match rules of a function define
	 * a cartesian n-ary function; if they do, represent
	 * the cartesian arity explicitly.
	 *
	 * Preconditions:
	 * 1) No pattern binds the whole argument value to a variable.
	 * 2) No side effect can be performed by a GuardPat or WithPat
	 *    before the tuple or record is deconstructed (since in the
	 *    presence of by-need futures, the latter may also have
	 *    side effects).
	 *)

	local
	    datatype arity =
		ONE
	      | TUP of typ list
	      | REC of (Label.t * typ) list

	    exception MustBeUnary

	    local
		fun convert row =
		    if Type.isEmptyRow row then
			if Type.isUnknownRow row then raise MustBeUnary
			else nil
		    else
			(case Type.headRow row of
			     (label, [typ]) => (label, typ)
			   | (_, _) => raise MustBeUnary)::
			convert (Type.tailRow row)
	    in
		fun typToArity typ =
		    if Type.isTuple typ then TUP (Type.asTuple typ)
		    else if Type.isProd typ then
			(case LabelSort.sort (convert (Type.asProd typ)) of
			     (labelTypList, LabelSort.Tup _) =>
				 TUP (List.map #2 labelTypList)
			   | (labelTypList, LabelSort.Rec) => REC labelTypList)
			handle MustBeUnary => ONE
		else ONE
	    end

	    exception BindsAll     (* precondition 1 not satisfied *)
	    exception SideEffect   (* precondition 2 not satisfied *)
	    exception NotNAry

	    fun deconstructs (WildPat _) = false
	      | deconstructs (LitPat _) = raise NotNAry
	      | deconstructs (VarPat (_, _)) = raise BindsAll
	      | deconstructs (TagPat (_, _, _)) = raise NotNAry
	      | deconstructs (ConPat (_, _, _)) = raise NotNAry
	      | deconstructs (RefPat _) = raise NotNAry
	      | deconstructs (TupPat (_, _)) = true
	      | deconstructs (RowPat (_, _)) = true
	      | deconstructs (VecPat (_, _)) = raise NotNAry
	      | deconstructs (AppPat (_, _, _)) = raise NotNAry
	      | deconstructs (AsPat (_, pat1, pat2)) =
		deconstructs pat1 orelse deconstructs pat2
	      | deconstructs (AltPat (_, pats)) = List.exists deconstructs pats
	      | deconstructs (NegPat (_, pat)) = deconstructs pat
	      | deconstructs (GuardPat (_, pat, _)) =
		deconstructs pat orelse raise SideEffect
	      | deconstructs (WithPat (_, pat, _)) =
		deconstructs pat orelse raise SideEffect

	    fun checkMatches matches =
		(List.foldl (fn ((_, pat, _), b) =>
			     deconstructs pat orelse b) false matches)
		handle (BindsAll | SideEffect | NotNAry) => false

	    fun process (ONE, graph, consequents, info) =
		let
		    val id = freshId info
		in
		    (O.OneArg id, graph, [(nil, id)], consequents)
		end
	      | process (TUP typs, Node (nil, TupTest _, ref graph, _, _),
			 consequents, _) =
		let
		    val ids =
			List.map (fn typ =>
				  freshId (exp_info (Source.nowhere, typ)))
			typs
		    val labelIdList =
			Misc.List_mapi (fn (i, id) =>
					(Label.fromInt (i + 1), id)) ids
		    val mapping =
			List.foldr (fn ((label, id), mapping) =>
				    ([LABEL label], id)::mapping)
			nil labelIdList
		in
		    (O.TupArgs ids, graph, mapping, consequents)
		end
	      | process (REC labelTypList,
			 Node (nil, RecTest _, ref graph, _, _),
			 consequents, _) =
		let
		    val labelIdList =
			List.map (fn (label, typ) =>
				  (label,
				   freshId (exp_info (Source.nowhere, typ))))
			labelTypList
		    val mapping =
			List.foldr (fn ((label, id), mapping) =>
				    ([LABEL label], id)::mapping)
			nil labelIdList
		in
		    (O.RecArgs labelIdList, graph, mapping, consequents)
		end
	      | process (_, _, _, _) =
		raise Crash.Crash "SimplifyMatch.process"
	in
	    fun buildFunArgs (matches as (_, pat, _)::_, errStms) =
		let
		    val arity =
			if checkMatches matches then typToArity (typPat pat)
			else ONE
		    val (graph, consequents) = buildGraph (matches, errStms)
		in
		    process (arity, graph, consequents, infoPat pat)
		end
	      | buildFunArgs (nil, _) =
		raise Crash.Crash "SimplifyMatch.buildFunArgs"
	end
    end
(* src # 135 ../backend-common/SIMPLIFY_REC.sig *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature SIMPLIFY_REC =
    sig
	structure I: INTERMEDIATE_GRAMMAR = IntermediateGrammar

	type constraint = I.longid * I.longid
	type binding = I.id * I.exp
	type alias = I.id * I.id * I.exp_info

	val derec: I.dec list -> constraint list * binding list * alias list
    end
(* src # 136 ../backend-common/SimplifyRec.sml *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure SimplifyRec :> SIMPLIFY_REC =
    struct
	structure I = IntermediateGrammar

	open I
	open IntermediateAux

	type constraint = longid * longid
	type binding = id * exp
	type alias = id * id * exp_info

	datatype pat =
	    WildPat of pat_info
	  | LitPat of pat_info * lit
	  | VarPat of pat_info * id
	  | TagPat of pat_info * lab * pat option * bool
	  | ConPat of pat_info * longid * pat option * bool
	  | RefPat of pat_info * pat
	  | TupPat of pat_info * pat list
	  | RowPat of pat_info * pat field list
	  | VecPat of pat_info * pat list
	  | AsPat of pat_info * id * pat

	fun infoPat (WildPat info) = info
	  | infoPat (LitPat (info, _)) = info
	  | infoPat (VarPat (info, _)) = info
	  | infoPat (TagPat (info, _, _, _)) = info
	  | infoPat (ConPat (info, _, _, _)) = info
	  | infoPat (RefPat (info, _)) = info
	  | infoPat (TupPat (info, _)) = info
	  | infoPat (RowPat (info, _)) = info
	  | infoPat (VecPat (info, _)) = info
	  | infoPat (AsPat (info, _, _)) = info

	structure FieldSort =
	    MakeLabelSort(type 'a t = 'a field
			  fun get (Field (_, Lab (_, label), _)) = label)

	fun select (Field (_, Lab (_, s), x)::fieldr, s') =
	    if s = s' then SOME x else select (fieldr, s')
	  | select (nil, _) = NONE

	fun unalias (WildPat _) = (nil, NONE)
	  | unalias (VarPat (_, id)) = ([id], NONE)
	  | unalias (AsPat (_, id, pat)) =
	    let
		val (ids, patOpt) = unalias pat
	    in
		(id::ids, patOpt)
	    end
	  | unalias pat = (nil, SOME pat)

	fun mkRefTyp typ =
	    Type.inArrow (typ, Type.inApply (PreboundType.typ_ref, typ))

	fun patToExp (WildPat info) =
	    let
		val id = freshId info
	    in
		(VarPat (info, id), VarExp (info, ShortId (id_info info, id)))
	    end
	  | patToExp (pat as LitPat (info, lit)) = (pat, LitExp (info, lit))
	  | patToExp (pat as VarPat (info, id)) =
	    (pat, VarExp (info, ShortId (id_info info, id)))
	  | patToExp (pat as TagPat (info, lab, NONE, _)) =
	    (pat, TagExp (info, lab, false))
	  | patToExp (TagPat (info, lab, SOME pat, isNAry)) =
	    let
		val (pat', exp') = patToExp pat
		val info' =
		    exp_info (#region info,
			      Type.inArrow (#typ (infoPat pat), #typ info))
	    in
		(TagPat (info, lab, SOME pat', isNAry),
		 AppExp (info, TagExp (info', lab, isNAry), exp'))
	    end
	  | patToExp (pat as ConPat (info, longid, NONE, _)) =
	    (pat, ConExp (info, longid, false))
	  | patToExp (ConPat (info, longid, SOME pat, isNAry)) =
	    let
		val (pat', exp') = patToExp pat
		val info' =
		    exp_info (#region info,
			      Type.inArrow (#typ (infoPat pat), #typ info))
	    in
		(ConPat (info, longid, SOME pat', isNAry),
		 AppExp (info, ConExp (info', longid, isNAry), exp'))
	    end
	  | patToExp (RefPat (info, pat)) =
	    let
		val (pat', exp') = patToExp pat
		val info' =
		    exp_info (#region info, mkRefTyp (#typ (infoPat pat)))
	    in
		(RefPat (info, pat'), AppExp (info, RefExp info', exp'))
	    end
	  | patToExp (TupPat (info, pats)) =
	    let
		val (pats', exps') = ListPair.unzip (List.map patToExp pats)
	    in
		(TupPat (info, pats'), TupExp (info, exps'))
	    end
	  | patToExp (RowPat (info, patFields)) =
	    let
		val (patFields', expFields') =
		    List.foldr (fn (Field (info, label, pat),
				    (patFields, expFields)) =>
				let
				    val (pat', exp) = patToExp pat
				in
				    (Field (info, label, pat')::patFields,
				     Field (info, label, exp)::expFields)
				end) (nil, nil) patFields
	    in
		(RowPat (info, patFields'), RowExp (info, expFields'))
	    end
	  | patToExp (VecPat (info, pats)) =
	    let
		val (pats', exps') = ListPair.unzip (List.map patToExp pats)
	    in
		(VecPat (info, pats'), VecExp (info, exps'))
	    end
	  | patToExp (pat as AsPat (info, id, _)) =
	    (pat, VarExp (info, ShortId (id_info info, id)))

	fun derec' (WildPat _, exp) = (nil, [(nil, exp)])
	  | derec' (LitPat (info, lit1), LitExp (_, lit2)) =
	    if lit1 = lit2 then (nil, nil)
	    else Error.error (#region info, "pattern never matches")
	  | derec' (VarPat (_, id), exp) = (nil, [([id], exp)])
	  | derec' (TagPat (info, Lab (_, label1), NONE, _),
		    TagExp (_, Lab (_, label2), false)) =
	    if label1 = label2 then (nil, nil)
	    else Error.error (#region info, "pattern never matches")
	  | derec' (TagPat (info, Lab (_, label1), SOME pat, _),
		    AppExp (_, TagExp (_, Lab (_, label2), true), exp)) =
	    let
		val (constraints, idsExpList) = derec' (pat, exp)
	    in
		if label1 = label2 then (constraints, idsExpList)
		else Error.error (#region info, "pattern never matches")
	    end
	  | derec' (ConPat (_, longid1, NONE, _),
		    ConExp (_, longid2, false)) =
	    ([(longid1, longid2)], nil)
	  | derec' (ConPat (_, longid1, SOME pat, _),
		    AppExp (_, ConExp (_, longid2, true), exp)) =
	    let
		val (constraints, idsExpList) = derec' (pat, exp)
	    in
		((longid1, longid2)::constraints, idsExpList)
	    end
	  | derec' (RefPat (_, pat), AppExp (_, RefExp _, exp)) =
	    derec' (pat, exp)
	  | derec' (TupPat (_, pats), TupExp (_, exps)) =
	    ListPair.foldr (fn (pat, exp, (cr, idsExpr)) =>
			    let
				val (cs, idsExps) = derec' (pat, exp)
			    in
				(cs @ cr, idsExps @ idsExpr)
			    end) (nil, nil) (pats, exps)
	  | derec' (TupPat (_, pats), RowExp (_, expFields)) =
	    (case FieldSort.sort expFields of
		 (expFields', FieldSort.Tup _) =>
		     ListPair.foldr
		     (fn (pat, Field (_, _, exp), (cr, idsExpr)) =>
		      let
			  val (cs, idsExps) = derec' (pat, exp)
		      in
			  (cs @ cr, idsExps @ idsExpr)
		      end) (nil, nil) (pats, expFields')
	       | (_, FieldSort.Rec) =>
		     raise Crash.Crash
			 "SimplifyRec.derec' 1 type inconsistency")
	  | derec' (RowPat (_, _), TupExp (_, _)) =
	    raise Crash.Crash "SimplifyRec.derec' 2 type inconsistency"
	  | derec' (RowPat (_, patFields), RowExp (_, expFields)) =
	    let
		val (expFields', _) = FieldSort.sort expFields
	    in
		ListPair.foldr
		(fn (Field (_, _, pat), Field (_, _, exp), (cr, idsExpr)) =>
		 let
		     val (cs, idsExps) = derec' (pat, exp)
		 in
		     (cs @ cr, idsExpr @ idsExpr)
		 end) (nil, nil) (patFields, expFields')
	    end
	  | derec' (VecPat (_, pats), VecExp (_, exps)) =
	    ListPair.foldr (fn (pat, exp, (cr, idsExpr)) =>
			    let
				val (cs, idsExps) = derec' (pat, exp)
			    in
				(cs @ cr, idsExps @ idsExpr)
			    end) (nil, nil) (pats, exps)
	  | derec' (pat as AsPat (_, _, _), exp) =
	    let
		val (ids, patOpt) = unalias pat
	    in
		case patOpt of
		    NONE =>
			(nil, [(ids, exp)])
		  | SOME pat' =>
			let
			    val (pat'', exp') = patToExp pat'
			    val (constraints, idsExpList) = derec' (pat'', exp)
			in
			    (constraints, (ids, exp')::idsExpList)
			end
	    end
	  | derec' (pat, _) =
	    raise Crash.Crash "SimplifyRec.derec' 3 internal error"

	fun unify (WildPat _, pat2) = (nil, pat2)
	  | unify (pat1, WildPat _) = (nil, pat1)
	  | unify (pat1 as LitPat (info, lit1), LitPat (_, lit2)) =
	    if lit1 = lit2 then (nil, pat1)
	    else Error.error (#region info, "pattern never matches")
	  | unify (VarPat (info, id), pat2) = (nil, AsPat (info, id, pat2))
	  | unify (pat1, VarPat (info, id)) = (nil, AsPat (info, id, pat1))
	  | unify (pat1 as TagPat (info, Lab (_, label), NONE, _),
		   TagPat (_, Lab (_, label'), NONE, _)) =
	    if label = label' then (nil, pat1)
	    else Error.error (#region info, "pattern never matches")
	  | unify (TagPat (info, lab as Lab (_, label), SOME pat1, isNAry),
		   TagPat (_, Lab (_, label'), SOME pat2, _)) =
	    let
		val (constraints, pat) = unify (pat1, pat2)
	    in
		if label = label' then
		    (constraints, TagPat (info, lab, SOME pat, isNAry))
		else Error.error (#region info, "pattern never matches")
	    end
	  | unify (pat1 as ConPat (_, longid, NONE, _),
		   ConPat (_, longid', NONE, _)) =
	    ([(longid, longid')], pat1)
	  | unify (ConPat (info, longid, SOME pat1, isNAry),
		   ConPat (_, longid', SOME pat2, _)) =
	    let
		val (constraints, pat) = unify (pat1, pat2)
	    in
		((longid, longid')::constraints,
		 ConPat (info, longid, SOME pat, isNAry))
	    end
	  | unify (RefPat (info, pat1), RefPat (_, pat2)) =
	    let
		val (constraints, pat) = unify (pat1, pat2)
	    in
		(constraints, RefPat (info, pat))
	    end
	  | unify (TupPat (info, pats1), TupPat (_, pats2)) =
	    let
		val (constraints, pats) =
		    ListPair.foldr (fn (pat1, pat2, (cr, patr)) =>
				    let
					val (cs, pat) = unify (pat1, pat2)
				    in
					(cs @ cr, pat::patr)
				    end) (nil, nil) (pats1, pats2)
	    in
		(constraints, TupPat (info, pats))
	    end
	  | unify (RowPat (info, patFields1), RowPat (_, patFields2)) =
	    let
		val (constraints, patFields) =
		    ListPair.foldr (fn (Field (info, label, pat1),
					Field (_, _, pat2), (cr, patFieldr)) =>
				    let
					val (cs, pat) = unify (pat1, pat2)
				    in
					(cs @ cr,
					 Field (info, label, pat)::patFieldr)
				    end) (nil, nil) (patFields1, patFields2)
	    in
		(constraints, RowPat (info, patFields))
	    end
	  | unify (VecPat (info, pats1), VecPat (_, pats2)) =
	    if length pats1 = length pats2 then
		let
		    val (constraints, pats) =
			ListPair.foldr (fn (pat1, pat2, (cr, patr)) =>
					let
					    val (cs, pat) = unify (pat1, pat2)
					in
					    (cs @ cr, pat::patr)
					end) (nil, nil) (pats1, pats2)
		in
		    (constraints, VecPat (info, pats))
		end
	    else Error.error (#region info, "pattern never matches")
	  | unify (AsPat (info, id, pat1), pat2) =
	    let
		val (constraints, pat) = unify (pat1, pat2)
	    in
		(constraints, AsPat (info, id, pat))
	    end
	  | unify (pat1, pat2 as AsPat (_, _, _)) = unify (pat2, pat1)
	  | unify (pat, _) =
	    Error.error (#region (infoPat pat), "pattern never matches")

	fun parseRow row =
	    if Type.isEmptyRow row then
		if Type.isUnknownRow row then
		    raise Crash.Crash "SimplifyRec.parseRow type inconsistency"
		else nil
	    else
		case Type.headRow row of
		    (label, [typ]) => (label, typ)::parseRow (Type.tailRow row)
		  | (_, _) => raise Crash.Crash "SimplifyRec.parseRow"

	fun getField (Field (_, _, pat)) = pat

	fun preprocess (I.WildPat info) = (nil, WildPat info)
	  | preprocess (I.LitPat (info, lit)) = (nil, LitPat (info, lit))
	  | preprocess (I.VarPat (info, id)) = (nil, VarPat (info, id))
	  | preprocess (I.TagPat (info, label, isNAry)) =
	    (nil, TagPat (info, label, NONE, isNAry))
	  | preprocess (I.AppPat (_, I.TagPat (info, label, isNAry), pat)) =
	    let
		val (constraints, pat') = preprocess pat
	    in
		(constraints, TagPat (info, label, SOME pat', isNAry))
	    end
	  | preprocess (I.ConPat (info, longid, isNAry)) =
	    (nil, ConPat (info, longid, NONE, isNAry))
	  | preprocess (I.AppPat (_, I.ConPat (info, longid, isNAry), pat)) =
	    let
		val (constraints, pat') = preprocess pat
	    in
		(constraints, ConPat (info, longid, SOME pat', isNAry))
	    end
	  | preprocess (I.AppPat (_, I.RefPat info, pat)) =
	    let
		val (constraints, pat') = preprocess pat
	    in
		(constraints, RefPat (info, pat'))
	    end
	  | preprocess (I.TupPat (info, pats)) =
	    let
		val (constraints, pats) =
		    List.foldr (fn (pat, (cr, patr)) =>
				let
				    val (cs, pat) = preprocess pat
				in
				    (cs @ cr, pat::patr)
				end) (nil, nil) pats
	    in
		(constraints, TupPat (info, pats))
	    end
	  | preprocess (I.RowPat (info, patFields)) =
	    let
		val typ = #typ info
		val labelTypList =
		    if Type.isTuple typ then
			Misc.List_mapi (fn (i, typ) =>
					(Label.fromInt (i + 1), typ))
			(Type.asTuple typ)
		    else parseRow (Type.asProd typ)
		fun adjoin (labelTyp as (label, _), patFields as
			    (Field (_, Lab (_, label'), _)::rest)) =
		    if label = label' then patFields
		    else adjoin (labelTyp, rest)
		  | adjoin ((label, typ), nil) =
		    let
			val info = {region = Source.nowhere}
		    in
			[Field (info, Lab (info, label),
				I.WildPat (exp_info (Source.nowhere, typ)))]
		    end
		val patFields' =
		    List.foldr adjoin patFields labelTypList
		val (patFields'', arity) = FieldSort.sort patFields'
		val (constraints, patFields''') =
		    List.foldr (fn (Field (info, label, pat), (cr, fieldr)) =>
				let
				    val (cs, pat') = preprocess pat
				in
				    (cs @ cr,
				     Field (info, label, pat')::fieldr)
				end) (nil, nil) patFields''
		val pat' =
		    case arity of
			FieldSort.Tup i =>
			    TupPat (info, List.map getField patFields''')
		      | FieldSort.Rec =>
			    RowPat (info, patFields''')
	    in
		(constraints, pat')
	    end
	  | preprocess (I.VecPat (info, pats)) =
	    let
		val (constraints, pats) =
		    List.foldr (fn (pat, (cr, patr)) =>
				let
				    val (cs, pat) = preprocess pat
				in
				    (cs @ cr, pat::patr)
				end) (nil, nil) pats
	    in
		(constraints, VecPat (info, pats))
	    end
	  | preprocess (I.AsPat (_, pat1, pat2)) =
	    let
		val (constraints1, pat1') = preprocess pat1
		val (constraints2, pat2') = preprocess pat2
		val (constraints3, pat') = unify (pat1', pat2')
	    in
		(constraints1 @ constraints2 @ constraints3, pat')
	    end
	  | preprocess (I.AltPat (info, _)) =
	    Error.error (#region info,
			 "alternative pattern not allowed in val rec")
	  | preprocess (I.NegPat (info, _)) =
	    Error.error (#region info,
			 "negated pattern not allowed in val rec")
	  | preprocess (I.GuardPat (info, _, _)) =
	    Error.error (#region info,
			 "guard pattern not allowed in val rec")
	  | preprocess (I.WithPat (info, _, _)) =
	    Error.error (#region info,
			 "with pattern not allowed in val rec")
	  | preprocess (I.RefPat _ | I.AppPat (_, _, _)) =
	    raise Crash.Crash "SimplifyRec.preprocess"

	fun derec (ValDec (_, pat, exp)::decr) =
	    let
		val (constraints, pat') = preprocess pat
		val (constraints', idsExpList) = derec' (pat', exp)
		val (idExpList, aliases) =
		    List.foldr (fn ((ids, exp), (rest, subst)) =>
				let
				    val toId = List.hd ids
				    val info = infoExp exp
				in
				    ((toId, exp)::rest,
				     List.foldr
				     (fn (fromId, subst) =>
				      (fromId, toId, info)::subst)
				     subst (List.tl ids))
				end) (nil, nil) idsExpList
		val (constraints'', idExpList', aliases') = derec decr
	    in
		(constraints @ constraints' @ constraints'',
		 idExpList @ idExpList', aliases @ aliases')
	    end
	  | derec (RecDec (_, decs)::decr) =
	    let
		val (constraints, idExpList, aliases) = derec decs
		val (constraints', idExpList', aliases') = derec decr
	    in
		(constraints @ constraints',
		 idExpList @ idExpList', aliases @ aliases')
	    end
	  | derec nil = (nil, nil, nil)
    end
(* src # 137 ../backend-common/FLATTENING_PHASE.sig *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature FLATTENING_PHASE =
    sig
	structure C: CONTEXT = EmptyContext
	structure I: INTERMEDIATE_GRAMMAR = IntermediateGrammar
	structure O: FLAT_GRAMMAR = FlatGrammar

	val translate: C.t -> I.t -> O.t
    end
(* src # 138 ../backend-common/FlatteningPhase.sml *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure FlatteningPhase :> FLATTENING_PHASE =
    struct
	structure C = EmptyContext
	structure I = IntermediateGrammar
	structure O = FlatGrammar

	open I
	open IntermediateAux
	open SimplifyMatch

	val id_Match = Id ({region = Source.nowhere},
			   Prebound.valstamp_match,
			   Prebound.valname_match)
	val id_Bind = Id ({region = Source.nowhere},
			  Prebound.valstamp_bind,
			  Prebound.valname_bind)

	val label_true = Label.fromString "true"
	val label_false = Label.fromString "false"

	fun exp_true info =
	    TagExp (info, Lab ({region = #region info}, label_true), false)
	fun exp_false info =
	    TagExp (info, Lab ({region = #region info}, label_false), false)

	fun lookup (pos, (pos', id)::mappingRest) =
	    if pos = pos' then id
	    else lookup (pos, mappingRest)
	  | lookup (pos, nil) =
	    raise Crash.Crash "FlatteningPhase.lookup"

	fun mappingsToSubst (mapping0, mapping) =
	    List.map (fn (pos, id) => (id, lookup (pos, mapping))) mapping0

	(* Translation *)

	fun stmInfo region = {region = region, liveness = ref O.Unknown}

	fun share nil = nil
	  | share (stms as [O.SharedStm (_, _, _)]) = stms
	  | share stms =
	    [O.SharedStm (stmInfo Source.nowhere, stms, ref 0)]

	datatype continuation =
	    Decs of dec list * continuation
	  | Goto of O.body
	  | Share of O.body option ref * continuation

	fun translateLongid (ShortId (_, id)) = (nil, id)
	  | translateLongid (LongId (info, longid, Lab (_, label))) =
	    let
		val (stms, id) = translateLongid longid
		val id' = Id (info, Stamp.new (), Name.InId)
		val info' = exp_info (#region info, Type.unknown Type.STAR)
		    (*--** missing type for longid translation *)
		val stm =
		    O.ValDec (stmInfo (#region info), id',
			      O.SelAppExp (info', label, id), false)
	    in
		(stms @ [stm], id')
	    end

	fun decsToIdExpList (O.ValDec (_, id, exp', _)::rest, region) =
	    (id, exp')::decsToIdExpList (rest, region)
	  | decsToIdExpList (O.IndirectStm (_, ref bodyOpt)::rest, region) =
	    decsToIdExpList (valOf bodyOpt, region) @
	    decsToIdExpList (rest, region)
	  | decsToIdExpList (_::_, region) =
	    Error.error (region, "not admissible")
	  | decsToIdExpList (nil, _) = nil

	fun translateIf (info: exp_info, id, thenStms, elseStms, errStms) =
	    [O.TestStm (stmInfo (#region info), id,
			O.TagTest label_true, thenStms,
			[O.TestStm (stmInfo (#region info), id,
				    O.TagTest label_false,
				    elseStms, errStms)])]

	fun translateCont (Decs (dec::decr, cont)) =
	    translateDec (dec, Decs (decr, cont))
	  | translateCont (Decs (nil, cont)) = translateCont cont
	  | translateCont (Goto stms) = stms
	  | translateCont (Share (r as ref NONE, cont)) =
	    let
		val stms = share (translateCont cont)
	    in
		r := SOME stms; stms
	    end
	  | translateCont (Share (ref (SOME stms), _)) = stms
	and translateDec (ValDec (info, VarPat (_, id), exp), cont) =
	    let
		fun declare exp' =
		    O.ValDec (stmInfo (#region info), id, exp', false)
	    in
		translateExp (exp, declare, cont)
	    end
	  | translateDec (ValDec (info, pat, exp), cont) =
	    let
		val matches = [(#region info, pat, translateCont cont)]
	    in
		simplifyCase (#region info, exp, matches, id_Bind, false)
	    end
	  | translateDec (RecDec (info, decs), cont) =
	    let
		val (constraints, idExpList, aliases) = SimplifyRec.derec decs
		val aliasDecs =
		    List.map (fn (fromId, toId, info) =>
			      let
				  val toExp = O.VarExp (info, toId)
			      in
				  O.ValDec (stmInfo (#region (infoId fromId)),
					    fromId, toExp, false)
			      end) aliases
		val subst = List.map (fn (id1, id2, _) => (id1, id2)) aliases
		val decs' =
		    List.foldr
		    (fn ((id, exp), decs) =>
		     translateExp (substExp (exp, subst),
				   fn exp' =>
				   O.ValDec (stmInfo (#region (infoExp exp)),
					     id, exp', false),
				   Goto decs)) nil idExpList
		val idExpList' = decsToIdExpList (decs', #region info)
		val rest =
		    O.RecDec (stmInfo (#region info), idExpList', false)::
		    aliasDecs @ translateCont cont
		val errStms =
		    share [O.RaiseStm (stmInfo (#region info), id_Bind)]
	    in
		List.foldr
		(fn ((longid1, longid2), rest) =>
		 let
		     val (stms1, id1) = translateLongid longid1
		     val (stms2, id2) = translateLongid longid2
		 in
		     (*--** the following ConTest has wrong arity *)
		     stms1 @ stms2 @
		     [O.TestStm (stmInfo (#region info), id1,
				 O.ConTest id2, rest, errStms)]
		 end) rest constraints
	    end
	and unfoldTerm (VarExp (_, longid), cont) =
	    let
		val (stms, id) = translateLongid longid
	    in
		(stms @ translateCont cont, id)
	    end
	  | unfoldTerm (exp, cont) =
	    let
		val info = infoExp exp
		val id' = freshId info
		fun declare exp' =
		    O.ValDec (stmInfo (#region info), id', exp', false)
		val stms = translateExp (exp, declare, cont)
	    in
		(stms, id')
	    end
	and unfoldArgs (TupExp (_, exps), rest, true) =
	    let
		val (stms, ids) =
		    List.foldr (fn (exp, (stms, ids)) =>
				let
				    val (stms', id) =
					unfoldTerm (exp, Goto stms)
				in
				    (stms', id::ids)
				end) (rest, nil) exps
	    in
		(stms, O.TupArgs ids)
	    end
	  | unfoldArgs (RowExp (_, expFields), rest, true) =
	    let
		val (stms, labelIdList) =
		    List.foldr (fn (Field (_, Lab (_, label), exp),
				    (stms, labelIdList)) =>
				    let
					val (stms', id) =
					    unfoldTerm (exp, Goto stms)
				    in
					(stms', (label, id)::labelIdList)
				    end) (rest, nil) expFields
	    in
		case LabelSort.sort labelIdList of
		    (labelIdList', LabelSort.Tup _) =>
			(stms, O.TupArgs (List.map #2 labelIdList'))
		  | (labelIdList', LabelSort.Rec) =>
			(stms, O.RecArgs labelIdList')
	    end
	  | unfoldArgs (exp, rest, _) =
	    let
		val (stms, id) = unfoldTerm (exp, Goto rest)
	    in
		(stms, O.OneArg id)
	    end
	and translateExp (LitExp (info, lit), f, cont) =
	    f (O.LitExp (info, lit))::translateCont cont
	  | translateExp (PrimExp (info, s), f, cont) =
	    f (O.PrimExp (info, s))::translateCont cont
	  | translateExp (NewExp (info, isNAry), f, cont) =
	    f (O.NewExp (info, makeConArity (info, isNAry)))::
	    translateCont cont
	  | translateExp (VarExp (info, longid), f, cont) =
	    let
		val (stms, id) = translateLongid longid
	    in
		stms @ f (O.VarExp (info, id))::translateCont cont
	    end
	  | translateExp (TagExp (info, Lab (_, label), isNAry), f, cont) =
	    f (O.TagExp (info, label, makeConArity (info, isNAry)))::
	    translateCont cont
	  | translateExp (ConExp (info, longid, isNAry), f, cont) =
	    let
		val (stms, id) = translateLongid longid
	    in
		stms @ f (O.ConExp (info, id, makeConArity (info, isNAry)))::
		translateCont cont
	    end
	  | translateExp (RefExp info, f, cont) =
	    f (O.RefExp info)::translateCont cont
	  | translateExp (TupExp (info, exps), f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (stmInfo (#region info), r)]
		val (stms, ids) =
		    List.foldr (fn (exp, (stms, ids)) =>
				let
				    val (stms', id) =
					unfoldTerm (exp, Goto stms)
				in
				    (stms', id::ids)
				end) (rest, nil) exps
	    in
		r := SOME (f (O.TupExp (info, ids))::translateCont cont);
		stms
	    end
	  | translateExp (RowExp (info, expFields), f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (stmInfo (#region info), r)]
		val (stms, fields) =
		    List.foldr (fn (Field (_, Lab (_, label), exp),
				    (stms, fields)) =>
				let
				    val (stms', id) =
					unfoldTerm (exp, Goto stms)
				in
				    (stms', (label, id)::fields)
				end) (rest, nil) expFields
		val exp' =
		    case LabelSort.sort fields of
			(fields', LabelSort.Tup _) =>
			    O.TupExp (info, List.map #2 fields')
		      | (fields', LabelSort.Rec) =>
			    O.RecExp (info, fields')
	    in
		r := SOME (f exp'::translateCont cont);
		stms
	    end
	  | translateExp (SelExp (info, Lab (_, label)), f, cont) =
	    f (O.SelExp (info, label))::translateCont cont
	  | translateExp (VecExp (info, exps), f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (stmInfo (#region info), r)]
		val (stms, ids) =
		    List.foldr (fn (exp, (stms, ids)) =>
				let
				    val (stms', id) =
					unfoldTerm (exp, Goto stms)
				in
				    (stms', id::ids)
				end) (rest, nil) exps
	    in
		r := SOME (f (O.VecExp (info, ids))::translateCont cont);
		stms
	    end
	  | translateExp (FunExp (info, matches), f, cont) =
	    let
		val region = #region (infoMatch (List.hd matches))
		fun return exp' = O.ReturnStm (stmInfo region, exp')
		val matches' =
		    List.map (fn Match (_, pat, exp) =>
			      (#region (infoExp exp), pat,
			       translateExp (exp, return, Goto nil))) matches
		val errStms = [O.RaiseStm (stmInfo region, id_Match)]
		val (args, graph, mapping, consequents) =
		    buildFunArgs (matches', errStms)
		val body = translateGraph (graph, mapping)
	    in
		checkReachability consequents;
		f (O.FunExp (info, Stamp.new (), nil, args, body))::
		translateCont cont
	    end
	  | translateExp (AppExp (info, TagExp (info', Lab (_, label), isNAry),
				  exp2), f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (stmInfo (#region info), r)]
		val (stms, args) = unfoldArgs (exp2, rest, isNAry)
		val conArity = makeConArity (info', isNAry)
	    in
		r := SOME (f (O.TagAppExp (info, label, args, conArity))::
			   translateCont cont);
		stms
	    end
	  | translateExp (AppExp (info, ConExp (info', longid, isNAry), exp2),
			  f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (stmInfo (#region info), r)]
		val (stms2, args) = unfoldArgs (exp2, rest, isNAry)
		val (stms1, id1) = translateLongid longid
		val conArity = makeConArity (info', isNAry)
	    in
		r := SOME (f (O.ConAppExp (info, id1, args, conArity))::
			   translateCont cont);
		stms1 @ stms2
	    end
	  | translateExp (AppExp (info, RefExp _, exp2), f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (stmInfo (#region info), r)]
		val (stms2, id) = unfoldTerm (exp2, Goto rest)
	    in
		(r := SOME (f (O.RefAppExp (info, id))::translateCont cont);
		 stms2)
	    end
	  | translateExp (AppExp (info, SelExp (_, Lab (_, label)), exp2),
			  f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (stmInfo (#region info), r)]
		val (stms2, id2) = unfoldTerm (exp2, Goto rest)
	    in
		(r := SOME (f (O.SelAppExp (info, label, id2))::
			    translateCont cont);
		 stms2)
	    end
	  | translateExp (AppExp (info, exp1, exp2), f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (stmInfo (#region info), r)]
		val (stms2, args) = unfoldArgs (exp2, rest, true)
		val (stms1, id1) = unfoldTerm (exp1, Goto stms2)
	    in
		r := SOME (f (O.AppExp (info, id1, args))::
			   translateCont cont);
		stms1
	    end
	  | translateExp (AdjExp (info, exp1, exp2), f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (stmInfo (#region info), r)]
		val (stms2, id2) = unfoldTerm (exp2, Goto rest)
		val (stms1, id1) = unfoldTerm (exp1, Goto stms2)
	    in
		r := SOME (f (O.AdjExp (info, id1, id2))::translateCont cont);
		stms1
	    end
	  | translateExp (UpExp (_, exp), f, cont) =
	    translateExp (exp, f, cont)   (*--** UpExp *)
	  | translateExp (AndExp (info, exp1, exp2), f, cont) =
	    translateExp (IfExp (info, exp1, exp2, exp_false info), f, cont)
	  | translateExp (OrExp (info, exp1, exp2), f, cont) =
	    translateExp (IfExp (info, exp1, exp_true info, exp2), f, cont)
	  | translateExp (IfExp (_, exp1, exp2, exp3), f, cont) =
	    let
		val cont' = Share (ref NONE, cont)
		val stms2 = translateExp (exp2, f, cont')
		val stms3 = translateExp (exp3, f, cont')
	    in
		simplifyIf (exp1, stms2, stms3)
	    end
	  | translateExp (WhileExp (info, exp1, exp2), f, cont) =
	    let
		val r = ref NONE
		val cont' = Goto [O.IndirectStm (stmInfo (#region info), r)]
		fun eval exp' =
		    O.EvalStm (stmInfo (#region (infoExp exp2)), exp')
		val info' = infoExp exp1
		val id = freshId info'
		val trueBody = translateExp (exp2, eval, cont')
		val falseBody = translateExp (TupExp (info, nil), f, cont)
		val errorBody =
		    [O.RaiseStm (stmInfo (#region info'), id_Match)]
		val stms1 =
		    translateIf (info', id, trueBody, falseBody, errorBody)
		val stms2 =
		    translateDec (ValDec (id_info info',
					  VarPat (info', id), exp1),
				  Goto stms1)
		val stms = share stms2
	    in
		r := SOME stms; stms
	    end
	  | translateExp (SeqExp (_, exps), f, cont) =
	    let
		val isLast = ref true
		fun translate (exp, stms) =
		    if !isLast then
			(case stms of
			     nil => ()
			   | _::_ =>
			     raise Crash.Crash "FlatteningPhase.translateExp";
			 isLast := false; translateExp (exp, f, cont))
		    else
			translateExp
			(exp,
			 fn exp' =>
			 O.EvalStm (stmInfo (#region (infoExp exp)), exp'),
			 Goto stms)
	    in
		List.foldr (fn (exp, stms) => translate (exp, stms)) nil exps
	    end
	  | translateExp (CaseExp (info, exp, matches), f, cont) =
	    let
		val cont' = Share (ref NONE, cont)
		val matches' =
		    List.map (fn Match (_, pat, exp) =>
			      (#region (infoExp exp), pat,
			       translateExp (exp, f, cont')))
		    matches
	    in
		simplifyCase (#region info, exp, matches', id_Match, false)
	    end
	  | translateExp (RaiseExp (info, exp), _, _) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (stmInfo (#region info), r)]
		val (stms, id) = unfoldTerm (exp, Goto rest)
	    in
		r := SOME [O.RaiseStm (stmInfo (#region info), id)];
		stms
	    end
	  | translateExp (HandleExp (info, exp, matches), f, cont) =
	    let
		val info' = infoExp exp
		val id' = freshId info'
		val shared = ref 0
		val cont' =
		    Goto [O.EndHandleStm (stmInfo (#region info), shared)]
		fun f' exp' =
		    O.ValDec (stmInfo (#region info'), id', exp', false)
		val tryBody = translateExp (exp, f', cont')
		val catchInfo = exp_info (#region info, PreboundType.typ_exn)
		val catchId = freshId catchInfo
		val catchVarExp =
		    VarExp (catchInfo, ShortId (id_info catchInfo, catchId))
		val matches' =
		    List.map (fn Match (_, pat, exp) =>
			      (#region (infoExp exp), pat,
			       translateExp (exp, f', cont')))
		    matches
		val catchBody =
		    simplifyCase (#region info, catchVarExp, matches',
				  catchId, true)
		val info'' = id_info info'
		val contBody =
		    translateExp  (VarExp (info', ShortId (info'', id')),
				   f, cont)
	    in
		[O.HandleStm (stmInfo (#region info), tryBody,
			      catchId, catchBody, contBody, shared)]
	    end
	  | translateExp (LetExp (_, decs, exp), f, cont) =
	    let
		val stms = translateExp (exp, f, cont)
	    in
		translateCont (Decs (decs, Goto stms))
	    end
	and simplifyIf (AndExp (_, exp1, exp2), thenStms, elseStms) =
	    let
		val elseStms' = share elseStms
		val thenStms' = simplifyIf (exp2, thenStms, elseStms')
	    in
		simplifyIf (exp1, thenStms', elseStms')
	    end
	  | simplifyIf (OrExp (_, exp1, exp2), thenStms, elseStms) =
	    let
		val thenStms' = share thenStms
		val elseStms' = simplifyIf (exp2, thenStms', elseStms)
	    in
		simplifyIf (exp1, thenStms', elseStms')
	    end
	  | simplifyIf (exp, thenStms, elseStms) =
	    let
		val info = infoExp exp
		val r = ref NONE
		val rest = [O.IndirectStm (stmInfo (#region info), r)]
		val (stms, id) = unfoldTerm (exp, Goto rest)
		val errStms = [O.RaiseStm (stmInfo (#region info), id_Match)]
		val stms1 = translateIf (info, id, thenStms, elseStms, errStms)
	    in
		r := SOME stms1;
		stms
	    end
	and checkReachability consequents =
	    List.app (fn (region, ref bodyOpt) =>
		      if isSome bodyOpt then ()
		      else Error.warn (region, "unreachable expression"))
	    consequents
	and simplifyCase (region, exp, matches, raiseId, isReraise) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (stmInfo region, r)]
		val (stms, id) = unfoldTerm (exp, Goto rest)
		val errStms =
		    if isReraise then
			[O.ReraiseStm (stmInfo region, raiseId)]
		    else [O.RaiseStm (stmInfo region, raiseId)]
		val (graph, consequents) = buildGraph (matches, errStms)
	    in
		r := SOME (translateGraph (graph, [(nil, id)]));
		checkReachability consequents;
		stms
	    end
	and translateGraph (Node (pos, test, ref thenGraph, ref elseGraph,
				  status as ref (Optimized (_, _))), mapping) =
	    let
		val stms =
		    share (translateNode (pos, test, thenGraph, elseGraph,
					  mapping))
	    in
		status := Translated stms; stms
	    end
	  | translateGraph (Node (_, _, _, _, ref (Translated stms)), _) = stms
	  | translateGraph (Leaf (stms, stmsOptRef as ref NONE), _) =
	    let
		val stms' = share stms
	    in
		stmsOptRef := SOME stms'; stms'
	    end
	  | translateGraph (Leaf (_, ref (SOME stms)), _) = stms
	  | translateGraph (_, _) =
	    raise Crash.Crash "FlatteningPhase.translateGraph"
	and translateNode (pos, GuardTest (mapping0, exp),
			   thenGraph, elseGraph, mapping) =
	    let
		val info = infoExp exp
		val r = ref NONE
		val rest = [O.IndirectStm (stmInfo (#region info), r)]
		val subst = mappingsToSubst (mapping0, mapping)
		val (stms, id) = unfoldTerm (substExp (exp, subst), Goto rest)
		val thenStms = translateGraph (thenGraph, mapping)
		val elseStms = translateGraph (elseGraph, mapping)
		val errStms = [O.RaiseStm (stmInfo (#region info), id_Match)]
		val stms1 = translateIf (info, id, thenStms, elseStms, errStms)
	    in
		r := SOME stms1;
		stms
	    end
	  | translateNode (pos, DecTest (mapping0, decs),
			   thenGraph, _, mapping) =
	    let
		val thenStms = translateGraph (thenGraph, mapping)
		val subst = mappingsToSubst (mapping0, mapping)
		val cont = Decs (List.map (fn dec => substDec (dec, subst))
				 decs, Goto thenStms)
	    in
		translateCont cont
	    end
	  | translateNode (pos, test, thenGraph, elseGraph, mapping) =
	    let
		val id = lookup (pos, mapping)
		val (stms, test', mapping') =
		    translateTest (test, pos, mapping)
	    in
		stms @ [O.TestStm (stmInfo Source.nowhere, id, test',
				   translateGraph (thenGraph, mapping'),
				   translateGraph (elseGraph, mapping'))]
	    end
	and translateTypArgs (O.OneArg typ, pos, mapping) =
	    let
		val id = freshId (exp_info (Source.nowhere, typ))
	    in
		(O.OneArg id, (pos, id)::mapping)
	    end
	  | translateTypArgs (O.TupArgs typs, pos, mapping) =
	    let
		val ids =
		    List.map (fn typ =>
			      freshId (exp_info (Source.nowhere, typ))) typs
	    in
		(O.TupArgs ids,
		 Misc.List_foldri
		 (fn (i, id, mapping) =>
		  (LABEL (Label.fromInt (i + 1))::pos, id)::mapping)
		 mapping ids)
	    end
	  | translateTypArgs (O.RecArgs labelTypList, pos, mapping) =
	    let
		val labelIdList =
		    List.map
		    (fn (label, typ) =>
		     (label, freshId (exp_info (Source.nowhere, typ))))
		    labelTypList
	    in
		(O.RecArgs labelIdList,
		 List.foldr (fn ((label, id), mapping) =>
			     (LABEL label::pos, id)::mapping)
		 mapping labelIdList)
	    end
	and translateTest (LitTest lit, _, mapping) =
	    (nil, O.LitTest lit, mapping)
	  | translateTest (TagTest label, _, mapping) =
	    (nil, O.TagTest label, mapping)
	  | translateTest (TagAppTest (label, args, conArity), pos, mapping) =
	    let
		val (idArgs, mapping') =
		    translateTypArgs (args, LABEL label::pos, mapping)
	    in
		(nil, O.TagAppTest (label, idArgs, conArity), mapping')
	    end
	  | translateTest (ConTest longid, _, mapping) =
	    let
		val (stms, id) = translateLongid longid
	    in
		(stms, O.ConTest id, mapping)
	    end
	  | translateTest (ConAppTest (longid, args, conArity), pos, mapping) =
	    let
		val (stms, id) = translateLongid longid
		val (idArgs, mapping') =
		    translateTypArgs (args, longidToSelector longid::pos,
				      mapping)
	    in
		(stms, O.ConAppTest (id, idArgs, conArity), mapping')
	    end
	  | translateTest (RefAppTest typ, pos, mapping) =
	    let
		val id = freshId (exp_info (Source.nowhere, typ))
		val mapping' =
		    (LABEL (Label.fromString "ref")::pos, id)::mapping
	    in
		(nil, O.RefAppTest id, mapping')
	    end
	  | translateTest (TupTest typs, pos, mapping) =
	    let
		val ids =
		    List.map (fn typ =>
			      freshId (exp_info (Source.nowhere, typ))) typs
		val mapping' =
		    Misc.List_foldli
		    (fn (i, id, mapping) =>
		     (LABEL (Label.fromInt (i + 1))::pos, id)::mapping)
		    mapping ids
	    in
		(nil, O.TupTest ids, mapping')
	    end
	  | translateTest (RecTest labelTypList, pos, mapping) =
	    let
		val labelIdList =
		    List.map (fn (label, typ) =>
			      (label,
			       freshId (exp_info (Source.nowhere, typ))))
		    labelTypList
		val mapping' =
		    ListPair.foldr (fn ((label, _), (_, i), mapping) =>
				    (LABEL label::pos, i)::mapping)
		    mapping (labelTypList, labelIdList)
	    in
		(nil, O.RecTest labelIdList, mapping')
	    end
	  | translateTest (LabTest (label, typ), pos, mapping) =
	    let
		val id = freshId (exp_info (Source.nowhere, typ))
		val mapping' = ((LABEL label::pos), id)::mapping
	    in
		(nil, O.LabTest (label, id), mapping')
	    end
	  | translateTest (VecTest typs, pos, mapping) =
	    let
		val ids =
		    List.map (fn typ =>
			      freshId (exp_info (Source.nowhere, typ))) typs
		val mapping' =
		    Misc.List_foldli
		    (fn (i, id, mapping) =>
		     (LABEL (Label.fromInt (i + 1))::pos, id)::mapping)
		    mapping ids
	    in
		(nil, O.VecTest ids, mapping')
	    end
	  | translateTest ((GuardTest (_, _) | DecTest (_, _)), _, _) =
	    raise Crash.Crash "FlatteningPhase.translateTest"

	fun translate () (imports, (exportExp, sign)) =
	    let
		fun export exp =
		    O.ExportStm (stmInfo (#region (infoExp exportExp)), exp)
	    in
		(imports, (translateExp (exportExp, export, Goto nil), sign))
	    end
    end
(* src # 139 ../backend-common/LIVENESS_ANALYSIS_PHASE.sig *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999-2000
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature LIVENESS_ANALYSIS_PHASE =
    sig
	structure I: FLAT_GRAMMAR = FlatGrammar

	val annotate: I.component -> unit
    end

(* src # 140 ../backend-common/LivenessAnalysisPhase.sml *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(*
 * The `Use' set of a statement is the set of stamps that
 * have already been initialized when the statement is reached
 * and that are still going to be referenced within or after it.
 *
 * Dead code elimination for defining occurrences without using occurrences:
 *    stm = ValDec (... stamp ...): stamp \in Kill(Cont(stm))
 *    stm = RecDec (... stamp ...): stamp \in Kill(Cont(stm))   (*--** check *)
 *    stm = HandleStm (... stamp ... catchBody ...): stamp \in Kill(catchBody)
 *    stm = TestStm (... stamp ... thenBody ...): stamp \in Kill(thenBody)
 *)

structure LivenessAnalysisPhase :> LIVENESS_ANALYSIS_PHASE =
    struct
	structure I = FlatGrammar
	open I

	datatype 'a lazyCopy =
	    Orig of 'a
	  | Copy of 'a

	fun lazyValOf (Orig x) = x
	  | lazyValOf (Copy x) = x

	fun processArgs (OneArg id, lset, x) = x (lset, id)
	  | processArgs (TupArgs ids, lset, x) =
	    List.foldl (fn (id, lset) => x (lset, id)) lset ids
	  | processArgs (RecArgs labIdList, lset, x) =
	    List.foldl (fn ((_, id), lset) => x (lset, id)) lset labIdList

	(* Compute `Use' Sets *)

	fun del (lset as (Orig set), Id (_, stamp, _)) =
	    if StampSet.member (set, stamp) then
		let
		    val set' = StampSet.clone set
		in
		    StampSet.delete (set', stamp);
		    Copy set'
		end
	    else lset
	  | del (lset as (Copy set), Id (_, stamp, _)) =
	    (StampSet.delete (set, stamp); lset)

	fun delList (lset, ids) =
	    List.foldl (fn (id, lset) => del (lset, id)) lset ids

	fun ins (lset as (Orig set), Id (_, stamp, _)) =
	    if StampSet.member (set, stamp) then lset
	    else
		let
		    val set' = StampSet.clone set
		in
		    StampSet.insert (set', stamp);
		    Copy set'
		end
	  | ins (lset as (Copy set), Id (_, stamp, _)) =
	    (StampSet.insert (set, stamp); lset)

	fun insList (lset, ids) =
	    List.foldl (fn (id, lset) => ins (lset, id)) lset ids

	fun union (Orig set, set') =
	    let
		val set'' = StampSet.clone set
	    in
		StampSet.union (set'', set');
		Copy set''
	    end
	  | union (lset as (Copy set), set') =
	    (StampSet.union (set, set'); lset)

	fun scanTest (LitTest _, lset) = lset
	  | scanTest (TagTest _, lset) = lset
	  | scanTest (TagAppTest (_, args, _), lset) =
	    processArgs (args, lset, del)
	  | scanTest (ConTest id, lset) = ins (lset, id)
	  | scanTest (ConAppTest (id, args, _), lset) =
	    processArgs (args, ins (lset, id), del)
	  | scanTest (RefAppTest id, lset) = del (lset, id)
	  | scanTest (TupTest ids, lset) = delList (lset, ids)
	  | scanTest (RecTest labIdList, lset) =
	    List.foldl (fn ((_, id), lset) => del (lset, id)) lset labIdList
	  | scanTest (LabTest (_, id), lset) = del (lset, id)
	  | scanTest (VecTest ids, lset) = delList (lset, ids)

	fun setInfo ({liveness = r as ref (Unknown | LoopStart | LoopEnd),
		      ...}: stm_info, set) =
	    r := Use set
	  | setInfo ({liveness = ref (Use _), ...}, _) = ()
	  | setInfo ({liveness = ref (Kill _), ...}, _) =
	    raise Crash.Crash "LivenessAnalysisPhase.setInfo"

	(* Annotate the `Use' set at each statement *)

	fun scanBody (ValDec (i, id, exp, _)::stms, initial) =
	    let
		val lset = scanBody (stms, initial)
		val set = lazyValOf (scanExp (exp, del (lset, id)))
	    in
		setInfo (i, set);
		Orig set
	    end
	  | scanBody (RecDec (i, idExpList, _)::stms, initial) =
	    let
		val lset = scanBody (stms, initial)
		val lset' =
		    List.foldl (fn ((_, exp), lset) => scanExp (exp, lset))
		    lset idExpList
		val set = lazyValOf lset'
		val _ = setInfo (i, set)
		val set' = StampSet.clone set
	    in
		List.app (fn (Id (_, stamp, _), _) =>
			  StampSet.delete (set', stamp)) idExpList;
		Copy set'
	    end
	  | scanBody (EvalStm (i, exp)::stms, initial) =
	    let
		val lset = scanBody (stms, initial)
		val set = lazyValOf (scanExp (exp, lset))
	    in
		setInfo (i, set);
		Orig set
	    end
	  | scanBody ([RaiseStm (i, Id (_, stamp, _))], _) =
	    let
		val set = StampSet.new ()
		val _ = StampSet.insert (set, stamp)
	    in
		setInfo (i, set);
		Orig set
	    end
	  | scanBody ([ReraiseStm (i, Id (_, stamp, _))], _) =
	    let
		val set = StampSet.new ()
		val _ = StampSet.insert (set, stamp)
	    in
		setInfo (i, set);
		Orig set
	    end
	  | scanBody ([HandleStm (i, body1, id, body2, body3, _)], initial) =
	    let
		val lset3 = scanBody (body3, initial)
		val lset2 = scanBody (body2, lset3)
		val lset1 = scanBody (body1, lset2)
		val set = lazyValOf (del (lset1, id))
	    in
		setInfo (i, set);
		Orig set
	    end
	  | scanBody ([EndHandleStm (i, _)], initial) =
	    let
		val set = lazyValOf initial
	    in
		setInfo (i, set);
		Orig set
	    end
	  | scanBody ([TestStm (i, id, test, body1, body2)], initial) =
	    let
		val initial' = Orig (lazyValOf initial)
		val lset1 = scanTest (test, scanBody (body1, initial'))
		val lset2 = scanTest (test, scanBody (body2, initial'))
		val lset1' = union (lset1, lazyValOf (ins (lset2, id)))
		val set = lazyValOf lset1'
	    in
		setInfo (i, set);
		Orig set
	    end
	  | scanBody ([SharedStm (i as {liveness = r as ref Unknown, ...},
				  body, _)], initial) =
	    let
		val _ = r := LoopStart
		val set = lazyValOf (scanBody (body, initial))
	    in
		setInfo (i, set);
		Orig set
	    end
	  | scanBody ([SharedStm (i as {liveness = r as ref LoopStart, ...},
				  body, _)], initial) =
	    (r := LoopEnd; scanBody (body, initial))
	  | scanBody ([SharedStm ({liveness = r as ref LoopEnd, ...},
				  _, _)], initial) =
	    Copy (StampSet.new ())   (*--** or initial? *)
	  | scanBody ([SharedStm ({liveness = ref (Use set'), ...},
				  _, _)], _) = Orig set'
	  | scanBody ([SharedStm ({liveness = ref (Kill _), ...}, _, _)], _) =
	    raise Crash.Crash "LivenessAnalysisPhase.scanStm 1"
	  | scanBody ([ReturnStm (i, exp)], _) =
	    let
		val set = lazyValOf (scanExp (exp, Copy (StampSet.new ())))
	    in
		setInfo (i, set);
		Orig set
	    end
	  | scanBody ([IndirectStm (i, ref bodyOpt)], initial) =
	    let
		val set = lazyValOf (scanBody (valOf bodyOpt, initial))
	    in
		setInfo (i, set);
		Orig set
	    end
	  | scanBody ([ExportStm (i, exp)], _) =
	    let
		val set = lazyValOf (scanExp (exp, Copy (StampSet.new ())))
	    in
		setInfo (i, set);
		Orig set
	    end
	  | scanBody (nil, initial) = initial
	  | scanBody (_, _) =
	    raise Crash.Crash "LivenessAnalysisPhase.scanStm 2"
	and scanExp (LitExp (_, _), lset) = lset
	  | scanExp (PrimExp (_, _), lset) = lset
	  | scanExp (NewExp (_, _), lset) = lset
	  | scanExp (VarExp (_, id), lset) = ins (lset, id)
	  | scanExp (TagExp (_, _, _), lset) = lset
	  | scanExp (ConExp (_, id, _), lset) = ins (lset, id)
	  | scanExp (RefExp _, lset) = lset
	  | scanExp (TupExp (_, ids), lset) = insList (lset, ids)
	  | scanExp (RecExp (_, labIdList), lset) =
	    List.foldl (fn ((_, id), lset) => ins (lset, id)) lset labIdList
	  | scanExp (SelExp (_, _), lset) = lset
	  | scanExp (VecExp (_, ids), lset) = insList (lset, ids)
	  | scanExp (FunExp (_, _, _, args, body), lset) =
	    let
		val set =
		    lazyValOf (scanBody (body, Copy (StampSet.new ())))
	    in
		processArgs (args, union (lset, set), del)
	    end
	  | scanExp (AppExp (_, id, args), lset) =
	    processArgs (args, ins (lset, id), ins)
	  | scanExp (SelAppExp (_, _, id), lset) = ins (lset, id)
	  | scanExp (TagAppExp (_, _, args, _), lset) =
	    processArgs (args, lset, ins)
	  | scanExp (ConAppExp (_, id, args, _), lset) =
	    processArgs (args, ins (lset, id), ins)
	  | scanExp (RefAppExp (_, id), lset) = ins (lset, id)
	  | scanExp (PrimAppExp (_, _, ids), lset) = insList (lset, ids)
	  | scanExp (AdjExp (_, id1, id2), lset) = ins (ins (lset, id1), id2)

	(* Compute `Def' and `Kill' sets *)

	fun processArgs (OneArg id, set, x) = x (set, id)
	  | processArgs (TupArgs ids, set, x) =
	    List.app (fn id => x (set, id)) ids
	  | processArgs (RecArgs labIdList, set, x) =
	    List.app (fn (_, id) => x (set, id)) labIdList

	fun ins (set, Id (_, stamp, _)) = StampSet.insert (set, stamp)

	fun insList (set, ids) = List.app (fn id => ins (set, id)) ids

	fun initTest (LitTest _, _) = ()
	  | initTest (TagTest _, _) = ()
	  | initTest (TagAppTest (_, args, _), set) =
	    processArgs (args, set, ins)
	  | initTest (ConTest _, _) = ()
	  | initTest (ConAppTest (_, args, _), set) =
	    processArgs (args, set, ins)
	  | initTest (RefAppTest id, set) = ins (set, id)
	  | initTest (TupTest ids, set) = insList (set, ids)
	  | initTest (RecTest labIdList, set) =
	    List.app (fn (_, id) => ins (set, id)) labIdList
	  | initTest (LabTest (_, id), set) = ins (set, id)
	  | initTest (VecTest ids, set) = insList (set, ids)

	fun initStm (ValDec (_, id, exp, _), set) =
	    (ins (set, id); initExp exp)
	  | initStm (RecDec (_, idExpList, _), set) =
	    List.app (fn (id, exp) => (ins (set, id); initExp exp)) idExpList
	  | initStm (EvalStm (_, exp), _) = initExp exp
	  | initStm (RaiseStm (_, _), _) = ()
	  | initStm (ReraiseStm (_, _), _) = ()
	  | initStm (HandleStm (_, body1, id, body2, body3, _), set) =
	    let
		val set' = StampSet.clone set
	    in
		ins (set', id);
		initBody (body1, StampSet.clone set);
		initBody (body2, set');
		initBody (body3, set)
	    end
	  | initStm (EndHandleStm (_, _), _) = ()
	  | initStm (TestStm (_, _, test, body1, body2), set) =
	    let
		val set' = StampSet.clone set
	    in
		initTest (test, set'); initBody (body1, set');
		initBody (body2, set)
	    end
	  | initStm (SharedStm ({liveness = ref (Kill _), ...}, _, _), _) = ()
	  | initStm (SharedStm (_, body, _), set) = initBody (body, set)
	  | initStm (ReturnStm (_, exp), _) = initExp exp
	  | initStm (IndirectStm (_, ref bodyOpt), set) =
	    initBody (valOf bodyOpt, set)
	  | initStm (ExportStm (_, _), _) = ()
	and initExp (FunExp (_, _, _, args, body)) =
	    let
		val set = StampSet.new ()
	    in
		processArgs (args, set, ins); initBody (body, set)
	    end
	  | initExp _ = ()
	and initBody (stm::stms, defSet) =
	    (case #liveness (infoStm stm) of
		 ref (Unknown | LoopStart | LoopEnd) =>
		     raise Crash.Crash "LivenessAnalysisPhase.initBody"
	       | r as ref (Use useSet) =>
		     let
			 val killSet = StampSet.new ()
		     in
			 StampSet.app
			 (fn stamp =>
			  if StampSet.member (useSet, stamp) then ()
			  else StampSet.insert (killSet, stamp)) defSet;
			 StampSet.app
			 (fn stamp => StampSet.delete (defSet, stamp)) killSet;
			 initStm (stm, defSet);
			 r := Kill killSet;
			 initBody (stms, defSet)
		     end
	       | ref (Kill _) => ())
	  | initBody (nil, _) = ()

	fun annotate (_, (body, _)) =
	    (scanBody (body, Copy (StampSet.new ()));
	     initBody (body, StampSet.new ()))
    end
(* src # 141 ../backend-mozart/OzifyFlatGrammar.sml *)
(*
 * Authors:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 1999
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)


structure OzifyFlatGrammar :> CODE where type t = string * FlatGrammar.t =
    struct
	open FlatGrammar

	type t = string * FlatGrammar.t

	local
	    val count = ref 0
	in
	    fun gen () =
		let
		    val n = !count + 1
		in
		    count := n; n
		end
	end

	val output = TextIO.output
	val output1 = TextIO.output1

	fun f (q, s) = (output (q, s); output1 (q, #"("))
	fun m q = output1 (q, #" ")
	fun r q = output1 (q, #")")

	fun outputBool (q, b) = output (q, Bool.toString b)
	fun outputInt (q, n) = output (q, Int.toString n)
	fun outputLargeInt (q, n) = output (q, LargeInt.toString n)
	fun outputLargeWord (q, w) = outputLargeInt (q, LargeWord.toLargeInt w)
	fun outputLargeReal (q, x) = output (q, (*LargeReal.toString*) x)
	fun outputAtom (q, s) =
	    (output1 (q, #"'");
	     output (q, String.toCString s);
	     output1(q, #"'"))

	fun outputStamp (q, stamp) =
	    if stamp = Prebound.valstamp_false then outputAtom (q, "false")
	    else if stamp = Prebound.valstamp_true then outputAtom (q, "true")
	    else if stamp = Prebound.valstamp_nil then outputAtom (q, "nil")
	    else if stamp = Prebound.valstamp_cons then outputAtom (q, "cons")
	    else if stamp = Prebound.valstamp_ref then outputAtom (q, "ref")
	    else if stamp = Prebound.valstamp_match then outputAtom (q, "Match")
	    else if stamp = Prebound.valstamp_bind then outputAtom (q, "Bind")
	    else output (q, Stamp.toString stamp)

	fun outputOption _ (q, NONE) =
	    (f (q, "none"); r q)
	  | outputOption outputX (q, SOME x) =
	    (f (q, "some"); outputX (q, x); r q)

	fun appTail f (x::xr) = (f (x, xr); appTail f xr)
	  | appTail _ nil = ()

	fun outputList _ (q, nil) = output(q, "nil")
	  | outputList outputX (q, xs) =
	    (output1 (q, #"[");
	     appTail (fn (x, xr) =>
		      (outputX (q, x); case xr of nil => () | _ =>  m q)) xs;
	     output1 (q, #"]"))

	fun outputChar (q, c) = output (q, Int.toString (Char.ord c))

	fun outputString (q, s) =
	    outputList outputChar (q, String.explode s)

	fun outputPair (outputA, outputB) (q, (a, b)) =
	    (output1 (q, #"("); outputA (q, a);
	     output1 (q, #"#"); outputB (q, b); output1 (q, #")"))

	local
	    fun outputRegion (q, ((ll, lc), (rl, rc))) =
		(output (q, Int.toString ll); output1 (q, #"#");
		 output (q, Int.toString lc); output1 (q, #"#");
		 output (q, Int.toString rl); output1 (q, #"#");
		 output (q, Int.toString rc))
	in
	    fun outputIdInfo (q, info: id_info) =
		outputRegion (q, #region info)

	    fun outputStmInfo (q, info: stm_info) =
		outputRegion (q, #region info)

	    fun outputExpInfo (q, info: exp_info) =
		outputRegion (q, #region info)
	end

	fun outputLit (q, WordLit w) =
	    (f (q, "wordLit"); outputLargeWord (q, w); r q)
	  | outputLit (q, IntLit n) =
	    (f (q, "intLit"); outputLargeInt (q, n); r q)
	  | outputLit (q, CharLit c) =
	    (f (q, "charLit"); outputChar (q, c); r q)
	  | outputLit (q, StringLit s) =
	    (f (q, "stringLit"); outputString (q, s); r q)
	  | outputLit (q, RealLit x) =
	    (f (q, "realLit"); outputLargeReal (q, x); r q)

	fun outputLabel (q, label) =
	    case Label.toInt label of
		SOME i => outputInt (q, i)
	      | NONE => outputAtom (q, Label.toString label)

	fun outputId (q, Id (info, stamp, name)) =
	    (f (q, "id"); outputIdInfo (q, info); m q;
	     outputStamp (q, stamp); m q;
	     case name of
		 Name.ExId s => (f (q, "exId"); outputAtom (q, s); r q)
	       | Name.InId => output (q, "inId");
	     r q)

	fun outputArgs outputX (q, OneArg id) =
	    (f (q, "oneArg"); outputX (q, id); r q)
	  | outputArgs outputX (q, TupArgs ids) =
	    (f (q, "tupArgs"); outputList outputX (q, ids); r q)
	  | outputArgs outputX (q, RecArgs labelIdList) =
	    (f (q, "recArgs");
	     outputList (outputPair (outputLabel, outputX)) (q, labelIdList);
	     r q)

	fun outputConArity (q, Nullary) = output (q, "nullary")
	  | outputConArity (q, Unary) = output (q, "unary")
	  | outputConArity (q, Tuple i) =
	    (f (q, "tuple"); output (q, Int.toString i); r q)
	  | outputConArity (q, Record labels) =
	    (f (q, "record"); outputList outputLabel (q, labels); r q)

	fun outputTest (q, LitTest lit) =
	    (f (q, "litTest"); outputLit (q, lit); r q)
	  | outputTest (q, TagTest label) =
	    (f (q, "tagTest"); outputLabel (q, label); r q)
	  | outputTest (q, TagAppTest (label, args, conArity)) =
	    (f (q, "tagAppTest"); outputLabel (q, label); m q;
	     outputArgs outputId (q, args); m q;
	     outputConArity (q, conArity); r q)
	  | outputTest (q, ConTest id) =
	    (f (q, "conTest"); outputId (q, id); r q)
	  | outputTest (q, ConAppTest (id, args, conArity)) =
	    (f (q, "conAppTest"); outputId (q, id); m q;
	     outputArgs outputId (q, args); m q;
	     outputConArity (q, conArity); r q)
	  | outputTest (q, RefAppTest id) =
	    (f (q, "refAppTest"); outputId (q, id); r q)
	  | outputTest (q, TupTest ids) =
	    (f (q, "tupTest"); outputList outputId (q, ids); r q)
	  | outputTest (q, RecTest labelIdList) =
	    (f (q, "recTest");
	     outputList (outputPair (outputLabel, outputId)) (q, labelIdList);
	     r q)
	  | outputTest (q, LabTest (label, id)) =
	    (f (q, "labTest"); outputLabel (q, label); m q; outputId (q, id);
	     r q)
	  | outputTest (q, VecTest ids) =
	    (f (q, "vecTest"); outputList outputId (q, ids); r q)

	fun outputFunFlag (q, PrintName s) =
	    (f (q, "printName"); outputAtom (q, s); r q)
	  | outputFunFlag (q, AuxiliaryOf stamp) =
	    (f (q, "auxiliaryOf"); outputStamp (q, stamp); r q)

	fun outputStm (q, ValDec (info, id, exp, isToplevel)) =
	    (f (q, "valDec"); outputStmInfo (q, info); m q;
	     outputId (q, id); m q; outputExp (q, exp); m q;
	     outputBool (q, isToplevel); r q)
	  | outputStm (q, RecDec (info, idExpList, isToplevel)) =
	    (f (q, "recDec"); outputStmInfo (q, info); m q;
	     outputList (outputPair (outputId, outputExp)) (q, idExpList); m q;
	     outputBool (q, isToplevel); r q)
	  | outputStm (q, EvalStm (info, exp)) =
	    (f (q, "evalStm"); outputStmInfo (q, info); m q;
	     outputExp (q, exp); r q)
	  | outputStm (q, HandleStm (info, body1, id, body2, body3, shared)) =
	    (shared := gen ();
	     f (q, "handleStm"); outputStmInfo (q, info); m q;
	     outputBody (q, body1); m q; outputId (q, id); m q;
	     outputBody (q, body2); m q; outputBody (q, body3); m q;
	     outputInt (q, !shared); r q)
	  | outputStm (q, EndHandleStm (info, ref i)) =
	    (f (q, "endHandleStm"); outputStmInfo (q, info); m q;
	     outputInt (q, i); r q)
	  | outputStm (q, TestStm (info, id, test, body1, body2)) =
	    (f (q, "testStm"); outputStmInfo (q, info); m q;
	     outputId (q, id); m q; outputTest (q, test); m q;
	     outputBody (q, body1); m q; outputBody (q, body2); r q)
	  | outputStm (q, RaiseStm (info, id)) =
	    (f (q, "raiseStm"); outputStmInfo (q, info); m q;
	     outputId (q, id); r q)
	  | outputStm (q, ReraiseStm (info, id)) =
	    (f (q, "reraiseStm"); outputStmInfo (q, info); m q;
	     outputId (q, id); r q)
	  | outputStm (q, SharedStm (info, body, shared)) =
	    (if !shared = 0 then
		 (shared := gen ();
		  f (q, "sharedStm"); outputStmInfo (q, info); m q;
		  outputBody (q, body); m q)
	     else
		 f (q, "refStm");
	     outputInt (q, !shared); r q)
	  | outputStm (q, ReturnStm (info, exp)) =
	    (f (q, "returnStm"); outputStmInfo (q, info); m q;
	     outputExp (q, exp); r q)
	  | outputStm (q, IndirectStm (_, ref bodyOpt)) =
	    (output (q, "/* indirect */");
	     List.app (fn stm => (m q; outputStm (q, stm))) (valOf bodyOpt))
	  | outputStm (q, ExportStm (info, exp)) =
	    (f (q, "exportStm"); outputStmInfo (q, info); m q;
	     outputExp (q, exp); r q)
	and outputExp (q, LitExp (info, lit)) =
	    (f (q, "litExp"); outputExpInfo (q, info); m q;
	     outputLit (q, lit); r q)
	  | outputExp (q, PrimExp (info, string)) =
	    (f (q, "primExp"); outputExpInfo (q, info); m q;
	     outputAtom (q, string); r q)
	  | outputExp (q, NewExp (info, conArity)) =
	    (f (q, "newExp"); outputExpInfo (q, info); m q;
	     outputConArity (q, conArity); r q)
	  | outputExp (q, VarExp (info, id)) =
	    (f (q, "varExp"); outputExpInfo (q, info); m q;
	     outputId (q, id); r q)
	  | outputExp (q, TagExp (info, label, conArity)) =
	    (f (q, "tagExp"); outputExpInfo (q, info); m q;
	     outputLabel (q, label); m q; outputConArity (q, conArity); r q)
	  | outputExp (q, ConExp (info, id, conArity)) =
	    (f (q, "conExp"); outputExpInfo (q, info); m q;
	     outputId (q, id); m q; outputConArity (q, conArity); r q)
	  | outputExp (q, RefExp info) =
	    (f (q, "refExp"); outputExpInfo (q, info); r q)
	  | outputExp (q, TupExp (info, ids)) =
	    (f (q, "tupExp"); outputExpInfo (q, info); m q;
	     outputList outputId (q, ids); r q)
	  | outputExp (q, RecExp (info, labelIdList)) =
	    (f (q, "recExp"); outputExpInfo (q, info); m q;
	     outputList (outputPair (outputLabel, outputId)) (q, labelIdList);
	     r q)
	  | outputExp (q, VecExp (info, ids)) =
	    (f (q, "vecExp"); outputExpInfo (q, info); m q;
	     outputList outputId (q, ids); r q)
	  | outputExp (q, SelExp (info, label)) =
	    (f (q, "selExp"); outputExpInfo (q, info); m q;
	     outputLabel (q, label); r q)
	  | outputExp (q, FunExp (info, stamp, flags, args, body)) =
	    (f (q, "funExp"); outputExpInfo (q, info); m q;
	     outputStamp (q, stamp); m q;
	     outputList outputFunFlag (q, flags); m q;
	     outputArgs outputId (q, args); m q; outputBody (q, body); r q)
	  | outputExp (q, AppExp (info, id, args)) =
	    (f (q, "appExp"); outputExpInfo (q, info); m q;
	     outputId (q, id); m q; outputArgs outputId (q, args); r q)
	  | outputExp (q, SelAppExp (info, label, id)) =
	    (f (q, "selAppExp"); outputExpInfo (q, info); m q;
	     outputLabel (q, label); m q; outputId (q, id); r q)
	  | outputExp (q, TagAppExp (info, label, args, conArity)) =
	    (f (q, "tagAppExp"); outputExpInfo (q, info); m q;
	     outputLabel (q, label); m q; outputArgs outputId (q, args); m q;
	     outputConArity (q, conArity); r q)
	  | outputExp (q, ConAppExp (info, id, args, conArity)) =
	    (f (q, "conAppExp"); outputExpInfo (q, info); m q;
	     outputId (q, id); m q; outputArgs outputId (q, args); m q;
	     outputConArity (q, conArity); r q)
	  | outputExp (q, RefAppExp (info, id)) =
	    (f (q, "refAppExp"); outputExpInfo (q, info); m q;
	     outputId (q, id); r q)
	  | outputExp (q, PrimAppExp (info, string, ids)) =
	    (f (q, "primAppExp"); outputExpInfo (q, info); m q;
	     outputAtom (q, string); m q; outputList outputId (q, ids); r q)
	  | outputExp (q, AdjExp (info, id1, id2)) =
	    (f (q, "adjExp"); outputExpInfo (q, info); m q;
	     outputId (q, id1); m q; outputId (q, id2); r q)
	and outputBody (q, stms) = outputList outputStm (q, stms)

	fun externalize (q, (filename, (importList, (stms, _)))) =
	    (outputString (q, filename);
	     output1 (q, #"#");
	     outputList (fn (q, (id, _, url)) =>
			 outputPair (outputId, outputString)
			 (q, (id, Url.toString url))) (q, importList);
	     output1 (q, #"#");
	     outputList outputStm (q, stms))
    end
(* src # 142 ../backend-mozart/MozartGenerationPhase.sml *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2000
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure MozartEngine =
    MakeEngine (val cmd = "/bin/sh"
		val args = ["stoc-mozart.exe"]
(*--** for debugging:
		val args = ["stoc-mozart.exe", "--debug"]
 *)
		structure Code = OzifyFlatGrammar)

structure MozartTargetContext :> CONTEXT where type t = MozartEngine.t =
    struct
	type t = MozartEngine.t

	fun clone engine = engine
    end

structure MozartTarget :> TARGET
    where C = MozartTargetContext
    where type t = string * FlatGrammar.t =
    struct
	structure C = MozartTargetContext

	type t = string * FlatGrammar.t

	fun apply engine component =
	    raise Crash.Crash "MozartTarget.eval: not implemented"

	fun save engine filename component =
	    MozartEngine.saveValue engine filename
	    (MozartEngine.buildFunctor engine component)
    end

structure MozartGenerationContext :> CONTEXT where type t = string =
    struct
	type t = string

	fun clone s = s
    end

structure MozartGenerationPhase (*:> PHASE
    where C = MozartGenerationContext
    where I = FlatGrammar
    where O = MozartTarget*) =
    (*--** if I insert the above, SML/NJ crashes when compiling top/Main.sml *)
    struct
	structure C = MozartGenerationContext
	structure I = FlatGrammar
	structure O = MozartTarget

	fun translate inFilename component = (inFilename, component)
    end
(* src # 143 ../backend-com+/IL.sig *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature IL =
    sig
	type id = string

	type dottedname = id list

	(* Class Attributes *)

	type isPublic = bool

	type classVisibility = isPublic

	datatype classInheritance =
	    AbstractClass
	  | InterfaceClass
	  | SealedClass
	  | ValueClass
	  | RegularClass

	type classAttr = classVisibility * classInheritance

	(* Method Attributes *)

	datatype memberVisibility =
	    Private
	  | Assembly
	  | Public
	  | FamilyAndAssembly
	  | Family
	  | FamilyOrAssembly
	datatype methKind =
	    Static
	  | Instance
	  | Abstract
	  | Virtual
	  | Final

	type methAttr = memberVisibility * methKind

	(* Field Attributes *)

	type static = bool
	type initonly = bool

	type fieldAttr = memberVisibility * static * initonly

	(* Types *)

	datatype ty =
	    ClassTy of dottedname
	  | ValueClassTy of dottedname
	  | ArrayTy of ty
	  | CharTy
	  | VoidTy
	  | BoolTy
	  | Int32Ty
	  | Float32Ty
	  | UnsignedInt32Ty

	(* Instructions *)

	type label = int

	type isInstance = bool

	datatype cond =
	    EQ
	  | GE
	  | GE_UN
	  | GT
	  | GT_UN
	  | LE
	  | LE_UN
	  | LT
	  | LT_UN
	  | NE_UN
	  | TRUE
	  | FALSE

	datatype instr =
	    Add
	  | AddOvf
	  | And
	  | B of cond * label
	  | Br of label
	  | Call of isInstance * dottedname * id * ty list * ty
	  | Callvirt of dottedname * id * ty list * ty
	  | Castclass of dottedname
	  | Ceq
	  | Cgt
	  | CgtUn
	  | Clt
	  | CltUn
	  | Comment of string
	  | Div
	  | DivUn
	  | Dup
	  | Isinst of dottedname
	  | Label of label
	  | Ldarg of int
	  | LdcI4 of int
	  | LdcR4 of string
	  | LdelemRef
	  | Ldfld of dottedname * id * ty
	  | Ldlen
	  | Ldloc of int
	  | Ldnull
	  | Ldsfld of dottedname * id * ty
	  | Ldstr of string
	  | Leave of label
	  | Newarr of ty
	  | Newobj of dottedname * ty list
	  | Mul
	  | Neg
	  | Not
	  | Or
	  | Pop
	  | Rem
	  | RemUn
	  | Ret
	  | Rethrow
	  | Shl
	  | Shr
	  | ShrUn
	  | Starg of int
	  | StelemRef
	  | Stfld of dottedname * id * ty
	  | Stloc of int
	  | Stsfld of dottedname * id * ty
	  | Sub
	  | SubOvf
	  | Switch of label list
	  | Tail
	  | Throw
	  | Try of label * label * dottedname * label * label
	  | Xor

	(* Top-Level Declarations *)

	type extends = dottedname
	type implements = dottedname list

	type locals = ty list * bool   (* initialize *)

	datatype classDecl =
	    Field of id * fieldAttr * ty
	  | Method of id * methAttr * ty list * ty * locals * instr list

	type isEntrypoint = bool

	datatype decl =
	    Class of
	    dottedname * classAttr * extends * implements * classDecl list
	  | GlobalMethod of
	    id * isPublic * ty list * ty * isEntrypoint * locals * instr list

	type program = decl list

	val outputProgram: TextIO.outstream * program -> unit
    end
(* src # 144 ../backend-com+/IL.sml *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure IL :> IL =
    struct
	type id = string

	type dottedname = id list

	(* Class Attributes *)

	type isPublic = bool

	type classVisibility = isPublic

	datatype classInheritance =
	    AbstractClass
	  | InterfaceClass
	  | SealedClass
	  | ValueClass
	  | RegularClass

	type classAttr = classVisibility * classInheritance

	(* Method Attributes *)

	datatype memberVisibility =
	    Private
	  | Assembly
	  | Public
	  | FamilyAndAssembly
	  | Family
	  | FamilyOrAssembly
	datatype methKind =
	    Static
	  | Instance
	  | Abstract
	  | Virtual
	  | Final

	type methAttr = memberVisibility * methKind

	(* Field Attributes *)

	type static = bool
	type initonly = bool

	type fieldAttr = memberVisibility * static * initonly

	(* Types *)

	datatype ty =
	    ClassTy of dottedname
	  | ValueClassTy of dottedname
	  | ArrayTy of ty
	  | CharTy
	  | VoidTy
	  | BoolTy
	  | Int32Ty
	  | Float32Ty
	  | UnsignedInt32Ty

	(* Instructions *)

	type label = int

	type isInstance = bool

	datatype cond =
	    EQ
	  | GE
	  | GE_UN
	  | GT
	  | GT_UN
	  | LE
	  | LE_UN
	  | LT
	  | LT_UN
	  | NE_UN
	  | TRUE
	  | FALSE

	datatype instr =
	    Add
	  | AddOvf
	  | And
	  | B of cond * label
	  | Br of label
	  | Call of isInstance * dottedname * id * ty list * ty
	  | Callvirt of dottedname * id * ty list * ty
	  | Castclass of dottedname
	  | Ceq
	  | Cgt
	  | CgtUn
	  | Clt
	  | CltUn
	  | Comment of string
	  | Div
	  | DivUn
	  | Dup
	  | Isinst of dottedname
	  | Label of label
	  | Ldarg of int
	  | LdcI4 of int
	  | LdcR4 of string
	  | LdelemRef
	  | Ldfld of dottedname * id * ty
	  | Ldlen
	  | Ldloc of int
	  | Ldnull
	  | Ldsfld of dottedname * id * ty
	  | Ldstr of string
	  | Leave of label
	  | Newarr of ty
	  | Newobj of dottedname * ty list
	  | Mul
	  | Neg
	  | Not
	  | Or
	  | Pop
	  | Rem
	  | RemUn
	  | Ret
	  | Rethrow
	  | Shl
	  | Shr
	  | ShrUn
	  | Starg of int
	  | StelemRef
	  | Stfld of dottedname * id * ty
	  | Stloc of int
	  | Stsfld of dottedname * id * ty
	  | Sub
	  | SubOvf
	  | Switch of label list
	  | Tail
	  | Throw
	  | Try of label * label * dottedname * label * label
	  | Xor

	(* Top-Level Declarations *)

	type extends = dottedname
	type implements = dottedname list

	type locals = ty list * bool   (* initialize *)

	datatype classDecl =
	    Field of id * fieldAttr * ty
	  | Method of id * methAttr * ty list * ty * locals * instr list

	type isEntrypoint = bool

	datatype decl =
	    Class of
	    dottedname * classAttr * extends * implements * classDecl list
	  | GlobalMethod of
	    id * isPublic * ty list * ty * isEntrypoint * locals * instr list

	type program = decl list

	(* Output to File *)

	val output = TextIO.output
	val output1 = TextIO.output1

	val outputId = output

	(* Compute Stack Size *)

	structure Map =
	    MakeHashImpMap(type t = label
			   fun hash label = label)

	val size = ref 0
	val maxSize = ref 0
	val map: int Map.t ref = ref (Map.new ())
	val returnSize = ref 0

	fun pop n =
	    if !size = ~1 then ()
	    else
		let
		    val i = !size - n
		in
		    if i < 0 then
			raise Crash.Crash ("stack underflow by " ^
					   Int.toString (~i))
		    else size := i
		end

	fun push n =
	    if !size = ~1 then ()
	    else
		let
		    val i = !size + n
		in
		    size := i;
		    if i > !maxSize then maxSize := i else ()
		end

	fun branch label =
	    if !size = ~1 then
		case Map.lookup (!map, label) of
		    SOME n => size := n
		  | NONE => ()
	    else
		case Map.lookup (!map, label) of
		    SOME n =>
			if !size = n then ()
			else
			    raise Crash.Crash ("inconsistent stack size " ^
					       "for label " ^
					       Int.toString label ^ ": " ^
					       Int.toString (!size) ^ " <> " ^
					       Int.toString n)
		  | NONE => Map.insertDisjoint (!map, label, !size)

	fun catch label = Map.insertDisjoint (!map, label, 1)

	fun invalidate () = size := ~1

	fun return () =
	    if !size = ~1 orelse !size = !returnSize then ()
	    else
		raise Crash.Crash ("non-empty stack on return: " ^
				   Int.toString (!size) ^ " <> " ^
				   Int.toString (!returnSize))

	fun eval (Add | AddOvf) = (pop 2; push 1)
	  | eval And = (pop 2; push 1)
	  | eval (B ((TRUE | FALSE), label)) = (pop 1; branch label)
	  | eval (B (_, label)) = (pop 2; branch label)
	  | eval (Br label) = (branch label; invalidate ())
	  | eval (Call (isInstance, _, _, tys, ty)) =
	    (pop ((if isInstance then 1 else 0) + List.length tys);
	     case ty of VoidTy => () | _ => push 1)
	  | eval (Callvirt (_, _, tys, ty)) =
	    (pop (List.length tys + 1);
	     case ty of VoidTy => () | _ => push 1)
	  | eval (Castclass _) = (pop 1; push 1)
	  | eval (Ceq | Cgt | CgtUn | Clt | CltUn) = (pop 2; push 1)
	  | eval (Comment _) = ()
	  | eval (Div | DivUn) = (pop 2; push 1)
	  | eval Dup = (pop 1; push 2)
	  | eval (Isinst _) = (pop 1; push 1)
	  | eval (Label label) = branch label
	  | eval (Ldarg _) = push 1
	  | eval (LdcI4 _) = push 1
	  | eval (LdcR4 _) = push 1
	  | eval LdelemRef = (pop 2; push 1)
	  | eval (Ldfld (_, _, _)) = (pop 1; push 1)
	  | eval Ldlen = (pop 1; push 1)
	  | eval (Ldloc _) = push 1
	  | eval Ldnull = push 1
	  | eval (Ldsfld (_, _, _)) = push 1
	  | eval (Ldstr _) = push 1
	  | eval (Leave label) = (branch label; invalidate ())
	  | eval (Newarr _) = (pop 1; push 1)
	  | eval (Newobj (_, tys)) = (pop (List.length tys); push 1)
	  | eval Mul = (pop 2; push 1)
	  | eval Neg = (pop 2; push 1)
	  | eval Not = (pop 2; push 1)
	  | eval Or = (pop 2; push 1)
	  | eval Pop = pop 1
	  | eval (Rem | RemUn) = (pop 2; push 1)
	  | eval Ret = (return (); invalidate ())
	  | eval Rethrow = invalidate ()
	  | eval (Shl | Shr | ShrUn) = (pop 2; push 1)
	  | eval (Starg _) = pop 2
	  | eval StelemRef = pop 3
	  | eval (Stfld (_, _, _)) = pop 2
	  | eval (Stloc _) = pop 1
	  | eval (Stsfld (_, _, _)) = pop 1
	  | eval (Sub | SubOvf) = (pop 2; push 1)
	  | eval (Switch labels) = (pop 1; List.app branch labels)
	  | eval Tail = ()
	  | eval Throw = (pop 1; invalidate ())
	  | eval (Try (tryLabel, _, _, catchLabel, _)) =
	    (branch tryLabel; catch catchLabel)
	  | eval Xor = (pop 2; push 1)

	fun outputMaxStack (q, instrs, ty) =
	    (size := 0; maxSize := 0; map := Map.new ();
	     returnSize := (case ty of VoidTy => 0 | _ => 1);
	     List.app eval instrs;
	     output (q, ".maxstack "); output (q, Int.toString (!maxSize));
	     output (q, "\n"))
	    handle Crash.Crash s => output (q, "//--** " ^ s ^ "\n.maxstack 1024\n")

	(* Output IL Syntax *)

	fun outputDottedname (q, [id]) = outputId (q, id)
	  | outputDottedname (q, id::idr) =
	    (outputId (q, id); output1 (q, #"."); outputDottedname (q, idr))
	  | outputDottedname (_, nil) = raise Crash.Crash "IL.outputDottedname"

	fun outputClassAttr (q, (isPublic, inheritance)) =
	    (if isPublic then output (q, "public ")
	     else output (q, "private ");
	     case inheritance of
		 AbstractClass => output (q, "abstract ")
	       | InterfaceClass => output (q, "interface ")
	       | SealedClass => output (q, "sealed ")
	       | ValueClass => output (q, "value ")
	       | RegularClass => ())

	fun outputMemberVisibility (q, Private) = output (q, "private ")
	  | outputMemberVisibility (q, Assembly) = output (q, "assembly ")
	  | outputMemberVisibility (q, Public) = output (q, "public ")
	  | outputMemberVisibility (q, FamilyAndAssembly) =
	    output (q, "famandassem ")
	  | outputMemberVisibility (q, Family) = output (q, "family ")
	  | outputMemberVisibility (q, FamilyOrAssembly) =
	    output (q, "famorassem ")

	fun outputMethKind (q, Static) = output (q, "static ")
	  | outputMethKind (q, Instance) = ()
	  | outputMethKind (q, Abstract) = output (q, "abstract virtual ")
	  | outputMethKind (q, Virtual) = output (q, "virtual ")
	  | outputMethKind (q, Final) = output (q, "final virtual ")

	fun outputMethAttr (q, (vis, kind)) =
	    (outputMemberVisibility (q, vis);
	     outputMethKind (q, kind))

	fun outputFieldAttr (q, (vis, static, initonly)) =
	    (outputMemberVisibility (q, vis);
	     if static then output (q, "static ") else ();
	     if initonly then output (q, "initonly ") else ())

	fun outputTy (q, ClassTy dottedname) =
	    (output (q, "class "); outputDottedname (q, dottedname))
	  | outputTy (q, ValueClassTy dottedname) =
	    (output (q, "value class "); outputDottedname (q, dottedname))
	  | outputTy (q, ArrayTy ty) = (outputTy (q, ty); output (q, "[]"))
	  | outputTy (q, CharTy) = output (q, "wchar")
	  | outputTy (q, VoidTy) = output (q, "void")
	  | outputTy (q, BoolTy) = output (q, "bool")
	  | outputTy (q, Int32Ty) = output (q, "int32")
	  | outputTy (q, Float32Ty) = output (q, "float32")
	  | outputTy (q, UnsignedInt32Ty) = output (q, "unsigned int32")

	fun outputTys (q, [ty]) = outputTy (q, ty)
	  | outputTys (q, ty::tyr) =
	    (outputTy (q, ty); output (q, ", "); outputTys (q, tyr))
	  | outputTys (q, nil) = ()

	fun outputLabel (q, i) = output (q, "L" ^ Int.toString i)

	fun outputLabels (q, [label]) = outputLabel (q, label)
	  | outputLabels (q, label::labelr) =
	    (outputLabel (q, label); output (q, ", ");
	     outputLabels (q, labelr))
	  | outputLabels (q, nil) = ()

	fun intToString i =
	    if i < 0 then "-" ^ Int.toString (~i)
	    else Int.toString i

	local
	    fun toOct i = String.str (Char.chr (i mod 8 + Char.ord #"0"))

	    fun charToCString #"\\" = "\\\\"
	      | charToCString #"\"" = "\\\""
	      | charToCString #"\a" = "\\a"
	      | charToCString #"\b" = "\\b"
	      | charToCString #"\t" = "\\t"
	      | charToCString #"\n" = "\\n"
	      | charToCString #"\v" = "\\v"
	      | charToCString #"\f" = "\\f"
	      | charToCString #"\r" = "\\r"
	      | charToCString c =
		let
		    val i = Char.ord c
		in
		    if i < 32 then "\\0" ^ toOct (i div 8) ^ toOct i
		    else String.str c
		end
	in
	    fun stringToCString s =
		List.foldr (fn (c, rest) => charToCString c ^ rest) ""
		(explode s)
	end

	fun outputInstr (q, Add) = output (q, "add")
	  | outputInstr (q, AddOvf) = output (q, "add.ovf")
	  | outputInstr (q, And) = output (q, "and")
	  | outputInstr (q, B (EQ, label)) =   (*--** short form? *)
	    (output (q, "beq "); outputLabel (q, label))
	  | outputInstr (q, B (GE, label)) =   (*--** short form? *)
	    (output (q, "bge "); outputLabel (q, label))
	  | outputInstr (q, B (GE_UN, label)) =   (*--** short form? *)
	    (output (q, "bge.un "); outputLabel (q, label))
	  | outputInstr (q, B (GT, label)) =   (*--** short form? *)
	    (output (q, "bgt "); outputLabel (q, label))
	  | outputInstr (q, B (GT_UN, label)) =   (*--** short form? *)
	    (output (q, "bgt.un "); outputLabel (q, label))
	  | outputInstr (q, B (LE, label)) =   (*--** short form? *)
	    (output (q, "ble "); outputLabel (q, label))
	  | outputInstr (q, B (LE_UN, label)) =   (*--** short form? *)
	    (output (q, "ble.un "); outputLabel (q, label))
	  | outputInstr (q, B (LT, label)) =   (*--** short form? *)
	    (output (q, "blt "); outputLabel (q, label))
	  | outputInstr (q, B (LT_UN, label)) =   (*--** short form? *)
	    (output (q, "blt.un "); outputLabel (q, label))
	  | outputInstr (q, B (NE_UN, label)) =   (*--** short form? *)
	    (output (q, "bne.un "); outputLabel (q, label))
	  | outputInstr (q, B (TRUE, label)) =   (*--** short form? *)
	    (output (q, "brtrue "); outputLabel (q, label))
	  | outputInstr (q, B (FALSE, label)) =   (*--** short form? *)
	    (output (q, "brfalse "); outputLabel (q, label))
	  | outputInstr (q, Br label) =   (*--** short form? *)
	    (output (q, "br "); outputLabel (q, label))
	  | outputInstr (q, Call (isInstance, dottedname, id, tys, ty)) =
	    (output (q, "call ");
	     if isInstance then output (q, "instance ") else ();
	     outputTy (q, ty); output1 (q, #" ");
	     outputDottedname (q, dottedname); output (q, "::");
	     outputId (q, id); output1 (q, #"(");
	     outputTys (q, tys); output1 (q, #")"))
	  | outputInstr (q, Callvirt (dottedname, id, tys, ty)) =
	    (output (q, "callvirt instance ");
	     outputTy (q, ty); output1 (q, #" ");
	     outputDottedname (q, dottedname); output (q, "::");
	     outputId (q, id); output1 (q, #"(");
	     outputTys (q, tys); output1 (q, #")"))
	  | outputInstr (q, Castclass dottedname) =
	    (output (q, "castclass "); outputDottedname (q, dottedname))
	  | outputInstr (q, Ceq) = output (q, "ceq")
	  | outputInstr (q, Cgt) = output (q, "cgt")
	  | outputInstr (q, CgtUn) = output (q, "cgt.un")
	  | outputInstr (q, Clt) = output (q, "clt")
	  | outputInstr (q, CltUn) = output (q, "clt.un")
	  | outputInstr (q, Comment s) = output (q, "// " ^ s)
	  | outputInstr (q, Div) = output (q, "div")
	  | outputInstr (q, DivUn) = output (q, "div.un")
	  | outputInstr (q, Dup) = output (q, "dup")
	  | outputInstr (q, Isinst dottedname) =
	    (output (q, "isinst "); outputDottedname (q, dottedname))
	  | outputInstr (q, Label label) =
	    (outputLabel (q, label); output1 (q, #":"))
	  | outputInstr (q, Ldarg i) =
	    (output (q, "ldarg");
	     if i < 4 then (output1 (q, #"."); output (q, Int.toString i))
	     else if i < 256 then
		 (output (q, ".s "); output (q, Int.toString i))
	     else (output1 (q, #" "); output (q, Int.toString i)))
	  | outputInstr (q, LdcI4 i) =
	    (output (q, "ldc.i4");
	     if i >= 0 andalso i <= 8 then
		 (output1 (q, #"."); output (q, Int.toString i))
	     else if i = ~1 then output (q, ".M1")
	     else if i >= ~128 andalso i <= 127 then
		 (output (q, ".s "); output (q, intToString i))
	     else (output1 (q, #" "); output (q, intToString i)))
	  | outputInstr (q, LdcR4 r) =
	    (output (q, "ldc.r4 "); output (q, r))
	  | outputInstr (q, LdelemRef) = output (q, "ldelem.ref")
	  | outputInstr (q, Ldfld (dottedname, id, ty)) =
	    (output (q, "ldfld "); outputTy (q, ty); output1 (q, #" ");
	     outputDottedname (q, dottedname); output (q, "::");
	     outputId (q, id))
	  | outputInstr (q, Ldlen) = output (q, "ldlen")
	  | outputInstr (q, Ldloc i) =
	    (output (q, "ldloc");
	     if i < 4 then (output1 (q, #"."); output (q, Int.toString i))
	     else if i < 256 then
		 (output (q, ".s "); output (q, Int.toString i))
	     else (output1 (q, #" "); output (q, Int.toString i)))
	  | outputInstr (q, Ldnull) = output (q, "ldnull")
	  | outputInstr (q, Ldsfld (dottedname, id, ty)) =
	    (output (q, "ldsfld "); outputTy (q, ty); output1 (q, #" ");
	     outputDottedname (q, dottedname); output (q, "::");
	     outputId (q, id))
	  | outputInstr (q, Ldstr s) =
	    (output (q, "ldstr \""); output (q, stringToCString s);
	     output1 (q, #"\""))
	  | outputInstr (q, Leave label) =   (*--** short form? *)
	    (output (q, "leave "); outputLabel (q, label))
	  | outputInstr (q, Newarr ty) =
	    (output (q, "newarr "); outputTy (q, ty))
	  | outputInstr (q, Newobj (dottedname, tys)) =
	    (output (q, "newobj instance void ");
	     outputDottedname (q, dottedname);
	     output (q, "::.ctor("); outputTys (q, tys); output1 (q, #")"))
	  | outputInstr (q, Mul) = output (q, "mul")
	  | outputInstr (q, Neg) = output (q, "neg")
	  | outputInstr (q, Not) = output (q, "not")
	  | outputInstr (q, Or) = output (q, "or")
	  | outputInstr (q, Pop) = output (q, "pop")
	  | outputInstr (q, Rem) = output (q, "rem")
	  | outputInstr (q, RemUn) = output (q, "rem.un")
	  | outputInstr (q, Ret) = output (q, "ret")
	  | outputInstr (q, Rethrow) = output (q, "rethrow")
	  | outputInstr (q, Shl) = output (q, "shl")
	  | outputInstr (q, Shr) = output (q, "shr")
	  | outputInstr (q, ShrUn) = output (q, "shr.un")
	  | outputInstr (q, Starg i) =
	    (output (q, "starg");
	     if i < 4 then (output1 (q, #"."); output (q, Int.toString i))
	     else if i < 256 then
		 (output (q, ".s "); output (q, Int.toString i))
	     else (output1 (q, #" "); output (q, Int.toString i)))
	  | outputInstr (q, StelemRef) = output (q, "stelem.ref")
	  | outputInstr (q, Stfld (dottedname, id, ty)) =
	    (output (q, "stfld "); outputTy (q, ty); output1 (q, #" ");
	     outputDottedname (q, dottedname); output (q, "::");
	     outputId (q, id))
	  | outputInstr (q, Stloc i) =
	    (output (q, "stloc");
	     if i < 4 then (output1 (q, #"."); output (q, Int.toString i))
	     else if i < 256 then
		 (output (q, ".s "); output (q, Int.toString i))
	     else (output1 (q, #" "); output (q, Int.toString i)))
	  | outputInstr (q, Stsfld (dottedname, id, ty)) =
	    (output (q, "stsfld "); outputTy (q, ty); output1 (q, #" ");
	     outputDottedname (q, dottedname); output (q, "::");
	     outputId (q, id))
	  | outputInstr (q, Sub) = output (q, "sub")
	  | outputInstr (q, SubOvf) = output (q, "sub.ovf")
	  | outputInstr (q, Switch labels) =
	    (output (q, "switch("); outputLabels (q, labels);
	     output1 (q, #")"))
	  | outputInstr (q, Tail) = output (q, "tail.")
	  | outputInstr (q, Throw) = output (q, "throw")
	  | outputInstr (q, Try (label1, label2, dottedname, label3, label4)) =
	    (output (q, ".try "); outputLabel (q, label1);
	     output (q, " to "); outputLabel (q, label2);
	     output (q, " catch "); outputDottedname (q, dottedname);
	     output (q, " handler "); outputLabel (q, label3);
	     output (q, " to "); outputLabel (q, label4))
	  | outputInstr (q, Xor) = output (q, "xor")

	fun outputInstrs (q, (instr as Try (_, _, _, _, _))::instrr, trys) =
	    outputInstrs (q, instrr, trys @ [instr])
	  | outputInstrs (q, instr::instrr, trys) =
	    (output (q, "  "); outputInstr (q, instr); output1 (q, #"\n");
	     outputInstrs (q, instrr, trys))
	  | outputInstrs (q, nil, instr::instrr) =
	    (output (q, "  "); outputInstr (q, instr); output1 (q, #"\n");
	     outputInstrs (q, nil, instrr))
	  | outputInstrs (_, nil, nil) = ()

	local
	    fun outputLocals' (q, ty::tyr) =
		(output (q, ", "); outputTy (q, ty); outputLocals' (q, tyr))
	      | outputLocals' (q, nil) = ()
	in
	    fun outputLocals (q, (ty1::tyr, zeroinit)) =
		(output (q, ".locals("); outputTy (q, ty1);
		 outputLocals' (q, tyr); output (q, ")\n");
		 if zeroinit then output (q, ".zeroinit\n") else ())
	      | outputLocals (_, (nil, _)) = ()
	end

	fun outputClassDecl (q, Field (id, attr, ty)) =
	    (output (q, ".field "); outputFieldAttr (q, attr);
	     outputTy (q, ty); output1 (q, #" "); outputId (q, id);
	     output1 (q, #"\n"))
	  | outputClassDecl (q, Method (id, attr, tys, ty, locals, instrs)) =
	    (output (q, ".method "); outputMethAttr (q, attr);
	     outputTy (q, ty); output1 (q, #" "); outputId (q, id);
	     output1 (q, #"("); outputTys (q, tys); output (q, ") {\n");
	     outputMaxStack (q, instrs, ty);
	     outputLocals (q, locals); outputInstrs (q, instrs, nil);
	     output (q, "}\n"))

	fun outputClassDecls (q, decl::declr) =
	    (outputClassDecl (q, decl); outputClassDecls (q, declr))
	  | outputClassDecls (_, nil) = ()

	fun splitNamespace [id] = (nil, id)
	  | splitNamespace (id::idr) =
	    let
		val (namespace, id') = splitNamespace idr
	    in
		(id::namespace, id')
	    end
	  | splitNamespace nil = raise Crash.Crash "IL.splitNamespace"

	local
	    fun outputDottednames (q, dottedname::dottednames) =
		(output (q, ", "); outputDottedname (q, dottedname);
		 outputDottednames (q, dottednames))
	      | outputDottednames (_, nil) = ()
	in
	    fun outputImplements (q, dottedname::dottednames) =
		(output (q, "implements "); outputDottedname (q, dottedname);
		 outputDottednames (q, dottednames))
	      | outputImplements (_, nil) = ()
	end

	fun outputDecl (q, Class (name, attr, super, interfaces, members)) =
	    let
		val (namespace, id) = splitNamespace name
	    in
		case namespace of
		    nil => ()
		  | _::_ =>
			(output (q, ".namespace ");
			 outputDottedname (q, namespace);
			 output (q, " {\n"));
		output (q, ".class "); outputClassAttr (q, attr);
		outputId (q, id); output (q, " extends ");
		outputDottedname (q, super);
		outputImplements (q, interfaces);
		output (q, " {\n"); outputClassDecls (q, members);
		output (q, "}\n");
		case namespace of
		    nil => ()
		  | _::_ => output (q, "}\n")
	    end
	  | outputDecl (q, GlobalMethod (id, isPublic, tys, ty, isEntrypoint,
					 locals, instrs)) =
	    (output (q, ".method ");
	     output (q, if isPublic then "public " else "private ");
	     outputTy (q, ty); output1 (q, #" "); outputId (q, id);
	     output1 (q, #"("); outputTys (q, tys); output (q, ") {\n");
	     if isEntrypoint then output (q, ".entrypoint\n") else ();
	     outputMaxStack (q, instrs, ty);
	     outputLocals (q, locals); outputInstrs (q, instrs, nil);
	     output (q, "}\n"))

	fun outputProgram (q, [decl]) = outputDecl (q, decl)
	  | outputProgram (q, decl::declr) =
	    (outputDecl (q, decl); output1 (q, #"\n");
	     outputProgram (q, declr))
	  | outputProgram (_, nil) = ()
    end
(* src # 145 ../backend-com+/StockWerk.sml *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure StockWerk =
    struct
	val Prebound         = ["StockWerk", "Prebound"]
	val Komponist        = ["StockWerk", "Komponist"]
	val ExceptionWrapper = ["StockWerk", "ExceptionWrapper"]
	val RecordArity      = ["StockWerk", "RecordArity"]
	val StockWert        = ["StockWerk", "StockWert"]
	val Word             = ["StockWerk", "Word"]
	val Int              = ["StockWerk", "Int"]
	val Char             = ["StockWerk", "Char"]
	val String           = ["StockWerk", "String"]
	val Real             = ["StockWerk", "Real"]
	val NongenerativeCon = ["StockWerk", "NongenerativeCon"]
	val GenerativeCon    = ["StockWerk", "GenerativeCon"]
	val ConVal           = ["StockWerk", "ConVal"]
	val RefCon           = ["StockWerk", "RefCon"]
	val Ref              = ["StockWerk", "Ref"]
	val Tuple2           = ["StockWerk", "Tuple2"]
	val Tuple3           = ["StockWerk", "Tuple3"]
	val Tuple4           = ["StockWerk", "Tuple4"]
	val Tuple            = ["StockWerk", "Tuple"]
	val Record           = ["StockWerk", "Record"]
	val Vector           = ["StockWerk", "Vector"]
	val Transient        = ["StockWerk", "Transient"]
	val Promise          = ["StockWerk", "Promise"]
	val Future           = ["StockWerk", "Future"]
	val ByNeed           = ["StockWerk", "ByNeed"]
	val IntSelector      = ["StockWerk", "IntSelector"]
	val StringSelector   = ["StockWerk", "StringSelector"]
	val Procedure        = ["StockWerk", "Procedure"]
	val Procedure0       = ["StockWerk", "Procedure0"]
	val Procedure2       = ["StockWerk", "Procedure2"]
	val Procedure3       = ["StockWerk", "Procedure3"]
	val Procedure4       = ["StockWerk", "Procedure4"]

	val PreboundTy         = IL.ClassTy Prebound
	val KomponistTy        = IL.ClassTy Komponist
	val ExceptionWrapperTy = IL.ClassTy ExceptionWrapper
	val RecordArityTy      = IL.ClassTy RecordArity
	val StockWertTy        = IL.ClassTy StockWert
	val WordTy             = IL.ClassTy Word
	val IntTy              = IL.ClassTy Int
	val CharTy             = IL.ClassTy Char
	val StringTy           = IL.ClassTy String
	val RealTy             = IL.ClassTy Real
	val NongenerativeConTy = IL.ClassTy NongenerativeCon
	val GenerativeConTy    = IL.ClassTy GenerativeCon
	val ConValTy           = IL.ClassTy ConVal
	val RefConTy           = IL.ClassTy RefCon
	val RefTy              = IL.ClassTy Ref
	val Tuple2Ty           = IL.ClassTy Tuple2
	val Tuple3Ty           = IL.ClassTy Tuple3
	val Tuple4Ty           = IL.ClassTy Tuple4
	val TupleTy            = IL.ClassTy Tuple
	val RecordTy           = IL.ClassTy Record
	val VectorTy           = IL.ClassTy Vector
	val TransientTy        = IL.ClassTy Transient
	val PromiseTy          = IL.ClassTy Promise
	val FutureTy           = IL.ClassTy Future
	val ByNeedTy           = IL.ClassTy ByNeed
	val IntSelectorTy      = IL.ClassTy IntSelector
	val StringSelectorTy   = IL.ClassTy StringSelector
	val ProcedureTy        = IL.ClassTy Procedure
	val Procedure0Ty       = IL.ClassTy Procedure0
	val Procedure2Ty       = IL.ClassTy Procedure2
	val Procedure3Ty       = IL.ClassTy Procedure3
	val Procedure4Ty       = IL.ClassTy Procedure4
    end
(* src # 146 ../backend-com+/BUILTINS.sig *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature BUILTINS =
    sig
	val lookup: string -> IL.id * IL.ty
    end
(* src # 147 ../backend-com+/Builtins.sml *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure Builtins :> BUILTINS =
    struct
	structure Map = MakeHashImpMap(StringHashKey)

	val builtinTable =
	    let
		val map: (string * IL.ty) Map.t = Map.new ()
		val ty = StockWerk.StockWertTy
	    in
		Map.insert (map, "=", ("eq", ty));
		Map.insert (map, "<>", ("ne", ty));
		Map.insert (map, "~", ("Int$uminus", ty));
		Map.insert (map, "+", ("Int$plus", ty));
		Map.insert (map, "-", ("Int$minus", ty));
		Map.insert (map, "*", ("Int$times", ty));
		Map.insert (map, "div", ("Int$div", ty));
		Map.insert (map, "mod", ("Int$mod", ty));
		Map.insert (map, "<", ("Int$lt", ty));
		Map.insert (map, ">", ("Int$gt", ty));
		Map.insert (map, "<=", ("Int$le", ty));
		Map.insert (map, ">=", ("Int$ge", ty));
		Map.insert (map, ":=", ("General$assign", ty));
		Map.insert (map, "Char.<=", ("Char$le", ty));
		Map.insert (map, "String.^", ("String$conc", ty));
		Map.insert (map, "Word.+", ("Word$plus", ty));
		Map.insert (map, "Word.-", ("Word$minus", ty));
		Map.insert (map, "Word.*", ("Word$times", ty));
		Map.insert (map, "Word.<<", ("Word$shl", ty));
		Map.insert (map, "Word.>>", ("Word$lsr", ty));
		Map.insert (map, "Word.~>>", ("Word$asr", ty));
		Map.insert (map, "Word.fromInt'", ("Word$fromInt2", ty));
		map
	    end

	fun lookup name =
	    case Map.lookup (builtinTable, name) of
		SOME (id, ty) => (id, ty)
	      | NONE =>
		    (String.map (fn c => if c = #"." then #"$" else c) name,
		     StockWerk.StockWertTy)
    end
(* src # 148 ../backend-com+/CODE_STORE.sig *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(*
 * The procedures in this structure may be called according to
 * the following grammar:
 *
 *    <file> ::= init { <method> } close
 *
 *    <method> ::= defineClass
 *              |  defineMethod { <method> } closeMethod
 *              |  emit
 *              |  emitId
 *              |  declareLocal
 *              |  kill
 *              |  saveRegState { <method> } restoreRegState
 *
 * Methods may be defined in classes before the corresponding
 * invocation of defineClass.  All classes must have been defined
 * when calling close.
 *)

signature CODE_STORE =
    sig
	type class = FlatGrammar.stamp

	val className: class -> IL.dottedname

	type savedRegState

	val init: IL.dottedname -> unit
	val defineClass: class * IL.extends * IL.implements -> unit
	val defineMethod: class * IL.id * FlatGrammar.id list -> unit
	val emit: IL.instr -> unit
	val emitId: FlatGrammar.id -> unit
	val declareLocal: FlatGrammar.id -> unit
	val kill: StampSet.t -> unit
	val saveRegState: unit -> savedRegState
	val restoreRegState: savedRegState -> unit
	val closeMethod: unit -> unit
	val close: unit -> IL.program
    end
(* src # 149 ../backend-com+/CodeStore.sml *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

structure CodeStore :> CODE_STORE =
    struct
	open IL

	type stamp = Stamp.t

	datatype id = datatype FlatGrammar.id

	datatype reg =
	    SFld of index
	  | Fld of index
	  | Arg of index
	  | Loc of index
	  | Prebound of IL.id * IL.ty
	withtype index = int

	type class = stamp

	structure Map = StampMap
	structure ScopedMap = MakeHashScopedImpMap(Stamp)

	type classAttrState = (extends * implements) option ref
	type scope = reg ScopedMap.t
	type classDeclsState = classDecl list ref
	type regState = scope * index ref * index ref * index list ref
	type savedRegState = index list
	type instrsState = IL.instr list ref

	val namespace: dottedname ref = ref nil
	val classes: (classAttrState * scope * classDeclsState) Map.t ref =
	    ref (Map.new ())
	val env: (class * IL.id * int * regState * instrsState) list ref =
	    ref nil

	val global = Stamp.new ()
	val preboundScope =
	    let
		open Prebound
		val scope = ScopedMap.new ()
		val ty = StockWerk.StockWertTy
	    in
		ScopedMap.insert (scope, valstamp_false, Prebound ("false", ty));
		ScopedMap.insert (scope, valstamp_true, Prebound ("true", ty));
		ScopedMap.insert (scope, valstamp_nil, Prebound ("nil", ty));
		ScopedMap.insert (scope, valstamp_cons, Prebound ("cons", ty));
		ScopedMap.insert (scope, valstamp_ref, Prebound ("ref", ty));
		ScopedMap.insert (scope, valstamp_match, Prebound ("General$Match", ty));
		ScopedMap.insert (scope, valstamp_bind, Prebound ("General$Bind", ty));
		scope
	    end

	fun className class = !namespace @ ["P" ^ Stamp.toString class]
	fun sfldName i = "V" ^ Int.toString i
	fun fldName i = "G" ^ Int.toString i

	fun init dottedname =
	    (namespace := dottedname;
	     classes := Map.new ();
	     env := [(global, "main", 0,
		      (ScopedMap.clone preboundScope, ref 0, ref 0, ref nil),
		      ref nil)])

	fun defineClass (stamp, extends, implements) =
	    let
		val classAttr = SOME (extends, implements)
		val ctor =
		    Method (".ctor", (Public, Instance),
			    nil, VoidTy, (nil, false),
			    [Ldarg 0,
			     Tail, Call (true, extends, ".ctor", nil, VoidTy),
			     Ret])
	    in
		case Map.lookup (!classes, stamp) of
		    SOME (classAttrRef, _, classDeclsRef) =>
			if Option.isSome (!classAttrRef) then
			    raise Crash.Crash "CodeStore.defineClass"
			else
			    (classAttrRef := classAttr;
			     classDeclsRef := ctor::(!classDeclsRef))
		  | NONE =>
			Map.insertDisjoint (!classes, stamp,
					    (ref classAttr,
					     ScopedMap.clone preboundScope,
					     ref [ctor]))
	    end

	fun defineMethod (stamp, id, args) =
	    let
		val (scope, classDeclsRef) =
		    case Map.lookup (!classes, stamp) of
			SOME (_, scope, classDeclsRef) =>
			    (scope, classDeclsRef)
		      | NONE =>
			    let
				val scope = ScopedMap.clone preboundScope
				val classDeclsRef = ref nil
			    in
				Map.insertDisjoint
				(!classes, stamp,
				 (ref NONE, scope, classDeclsRef));
				(scope, classDeclsRef)
			    end
	    in
		ScopedMap.insertScope scope;
		List.foldl (fn (Id (_, stamp, _), i) =>
			    (ScopedMap.insertDisjoint (scope, stamp, Arg i);
			     i + 1)) 1 args;
		env := (stamp, id, List.length args,
			(scope, ref 0, ref 0, ref nil), ref nil)::(!env)
	    end

	fun emit instr =
	    let
		val (_, _, _, _, instrsRef) = List.hd (!env)
	    in
		instrsRef := instr::(!instrsRef)
	    end

	local
	    fun currentClosure () =
		let
		    val (stamp, _, _, _, _) = List.hd (!env)
		in
		    className stamp
		end

	    fun lookup ((_, _, _, (scope, ri, _, _), _)::envr, stamp) =
		(case ScopedMap.lookup (scope, stamp) of
		     SOME reg => reg
		   | NONE =>
			 let
			     val i = !ri
			     val reg = Fld i
			 in   (*--** generate SFld? *)
			     lookup (envr, stamp);
			     ScopedMap.insertDisjoint (scope, stamp, reg);
			     ri := i + 1;
			     reg
			 end)
	      | lookup (nil, stamp) =
		raise Crash.Crash ("CodeStore.lookup: " ^ Stamp.toString stamp)
	in
	    fun emitStamp stamp =
		case lookup (!env, stamp) of
		    SFld i =>
			emit (Ldsfld (currentClosure (), sfldName i,
				      StockWerk.StockWertTy))
		  | Fld i =>
			(emit (Ldarg 0);
			 emit (Ldfld (currentClosure (), fldName i,
				      StockWerk.StockWertTy)))
		  | Loc i => emit (Ldloc i)
		  | Arg i => emit (Ldarg i)
		  | Prebound (id, ty) =>
			emit (Ldsfld (StockWerk.Prebound, id, ty))
	end

	fun emitId (Id (_, stamp, _)) =
	    (emit (Comment ("load " ^ Stamp.toString stamp));
	     emitStamp stamp)

	fun declareLocal (Id (_, stamp, _)) =
	    let
		val (_, _, _, (scope, _, ri, indicesRef), _) = List.hd (!env)
	    in
		emit (Comment ("store " ^ Stamp.toString stamp));
		case ScopedMap.lookup (scope, stamp) of
		    SOME (Loc i) => emit (Stloc i)
		  | SOME _ => raise Crash.Crash "CodeStore.declareLocal"
		  | NONE =>
			let
			    val i =
				case indicesRef of
				    ref nil => !ri before ri := !ri + 1
				  | ref (index::rest) =>
					index before indicesRef := rest
			in
			    ScopedMap.insertDisjoint (scope, stamp, Loc i);
			    emit (Stloc i)
			end
	    end

	fun kill set =
	    let
		val (_, _, _, (scope, _, _, indicesRef), _) = List.hd (!env)
	    in
		StampSet.app
		(fn stamp =>
		 case ScopedMap.lookup (scope, stamp) of
		     SOME (Loc i) =>
			 (emit (Comment ("kill " ^ Stamp.toString stamp));
			  indicesRef := i::(!indicesRef))
		    | _ => emit (Comment ("nonlocal " ^ Stamp.toString stamp)))
		set
	    end

	fun saveRegState () =
	    let
		val (_, _, _, (_, _, _, ref indices), _) = hd (!env)
	    in
		indices
	    end

	fun restoreRegState indices =
	    let
		val (_, _, _, (_, _, _, indicesRef), _) = hd (!env)
	    in
		indicesRef := indices
	    end

	fun args n = List.tabulate (n, fn _ => StockWerk.StockWertTy)

	fun closeMethod () =
	    case !env of
		(stamp, id, narg, (scope, _, ref nloc, _), ref instrs)::envr =>
		    let
			val (_, _, classDeclsRef) =
			    Map.lookupExistent (!classes, stamp)
			val delta = ScopedMap.splitScope scope
			val className' = className stamp
			val _ = env := envr
			val method =
			    Method (id, (Public, Virtual),
				    args narg, StockWerk.StockWertTy,
				    (args nloc, false), List.rev instrs)
			val newClassDecls =
			    ScopedMap.foldi
			    (fn (stamp, reg, classDecls) =>
			     case reg of
				 SFld i =>
				     (emit Dup;
				      emitStamp stamp;
				      emit (Stsfld (className', sfldName i,
						    StockWerk.StockWertTy));
				      ScopedMap.insertDisjoint (scope, stamp,
								reg);
				      Field (sfldName i, (Public, true, false),
					     StockWerk.StockWertTy)::classDecls)
			       | Fld i =>
				     (emit Dup;
				      emitStamp stamp;
				      emit (Stfld (className', fldName i,
						   StockWerk.StockWertTy));
				      ScopedMap.insertDisjoint (scope, stamp,
								reg);
				      Field (fldName i, (Public, false, false),
					     StockWerk.StockWertTy)::classDecls)
			   | _ => classDecls) (!classDeclsRef) delta
		    in
			classDeclsRef := method::newClassDecls
		    end
	      | nil => raise Crash.Crash "CodeStore.closeMethod"

	fun close () =
	    let
		val mainMethod =
		    case !env of
			[(_, id, 0, (_, _, ref n, _), ref instrs)] =>
			    Class (["Main"], (true, SealedClass),
				   ["System", "Object"], nil,
				   [Method (id, (Public, Static),
					    [StockWerk.KomponistTy],
					    StockWerk.StockWertTy,
					    (args n, false),
					    List.rev instrs)])
		      | _ => raise Crash.Crash "CodeStore.close"
	    in
		Map.foldi
		(fn (stamp, (ref classAttr, scope, ref classDecls), program) =>
		 let
		     val (extends, implements) = Option.valOf classAttr
		 in
		     Class (className stamp, (true, SealedClass),
			    extends, implements, classDecls)::program
		 end) [mainMethod] (!classes)
	    end
    end
(* src # 150 ../backend-com+/CODE_GEN_PHASE.sig *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

signature CODE_GEN_PHASE =
    sig
	structure I: FLAT_GRAMMAR = FlatGrammar
	structure O: IL = IL

	val genComponent: I.component -> O.program
    end
(* src # 151 ../backend-com+/CodeGenPhase.sml *)
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(*
 * Optimierungsideen:
 *
 * Voraussetzung: Fuer Pickling/Marshaling muss erkannt werden, welche
 * Referenzen Code auf andere Closures macht.  Idee: Code wird nicht
 * in assemblierter Form in ein PEFile geschrieben (denn Code kann nicht
 * reflektiert werden), sondern in Zwischendarstellung als StockWert
 * gespeichert (bei jeder Closure in einem statischen Feld).
 * Bei Serialisierung wird der transitive Abschluss aller Closures
 * gebildet.  Closures werden ausserdem mit ihrer Definition
 * rausgeschrieben (also mit den Werten ihrer statischen Felder).
 * Bei Deserialisierung eines Token wird (bei Bedarf) der zugehoerige
 * Code in Zwischendarstellung assembliert (eine Form von JITting).
 *
 * Dann kann folgende Optimierung durchgefuehrt werden:
 *
 * Die freien Variablen werden klassifiziert nach statischen und
 * dynamischen freien Variablen (statisch = auf toplevel definiert,
 * also die V-Register in Mozart; dynamisch = nicht auf toplevel
 * definiert, also die G-Register in Mozart) und entsprechend in
 * statischen oder Instanzenfeldern gespeichert.
 *
 * Literale und RecordArities sollen auch in V-Registern gespeichert
 * werden, zaehlen also auch als `statische freie Variablen'.  V-Register
 * werden als zum Code gehoerig betrachtet.
 *
 * Vorteile:
 * -- Da sich alle Instanzen von Prozeduren die statischen freien
 *    Variablen teilen, wird die (wiederholte) Ausfuehrung einer
 *    Prozedurdefinition effizienter.
 * -- Der Heapverbrauch sinkt, da Literale nur einmal geboxt werden
 *    muessen.
 * Nachteile:
 * -- Es muss der Overhead in Kauf genommen werden, dass der Code
 *    jeder Prozedur in zwei Darstellungen gespeichert wird.
 *)

(*
 * Anzahl der generierten Klassen reduzieren:
 *
 * Eine Toplevel-Prozedur, die ausschliesslich an Designatorposition von
 * Applikationen verwendet wird, heisst Hilfsprozedur (Auxiliary).  Berechne
 * den Dominanzgraphen des Aufrufgraphen der Toplevel-Prozeduren.  Jede
 * dominierende nicht-Hilfsprozedur, die ausschliesslich Hilfsprozeduren
 * unter sich hat, kann die Definitionen ihrer Hilfsprozeduren in ihrer
 * eigenen Klasse aufnehmen.
 *
 * Entsprechend dominierte Hilfsprozeduren sollen mit dem Flag AuxiliaryOf
 * annotiert werden.
 *)

structure CodeGenPhase :> CODE_GEN_PHASE =
    struct
	structure I = FlatGrammar
	structure O = IL

	structure System =
	    struct
		val Object = ["System", "Object"]
		val ObjectTy = O.ClassTy Object
		val Int32 = ["System", "Int32"]
		val Int32Ty = O.ClassTy Int32
		val String = ["System", "String"]
		val StringTy = O.ClassTy String
	    end

	open I
	open O
	open CodeStore

	local
	    val count = ref 0
	in
	    fun newLabel () =
		let
		    val n = !count + 1
		in
		    count := n; n
		end
	end

	fun emitRegion (s, ((a, b), _)) =
	    emit (Comment (s ^ " at " ^ Int.toString a ^ "." ^ Int.toString b))

	fun emitRecordArity labelIdList =
	    (emit (LdcI4 (List.length labelIdList));
	     emit (Newarr System.ObjectTy);
	     Misc.List_appi (fn (i, (label, _)) =>
			     (emit Dup; emit (LdcI4 i);
			      case Label.toInt label of
				  SOME i =>
				      (emit (LdcI4 i);
				       emit (Newobj (System.Int32, [Int32Ty])))
				| NONE =>
				      emit (Ldstr (Label.toString label));
			      emit (StelemRef))) labelIdList;
	     emit (Call (false, StockWerk.RecordArity, "MakeRecordArity",
			 [ArrayTy System.ObjectTy], StockWerk.RecordArityTy)))

	datatype expMode =
	    PREPARE
	  | FILL
	  | BOTH

	fun idEq (Id (_, stamp1, _), Id (_, stamp2, _)) = stamp1 = stamp2

	fun genTestInt (dottedname, ty, i, elseLabel) =
	    (emit Dup; emit (Isinst dottedname); emit (B (FALSE, elseLabel));
	     emit Dup; emit (Castclass dottedname);
	     emit (Ldfld (dottedname, "Value", ty)); emit (LdcI4 i);
	     emit (B (NE_UN, elseLabel)); emit Pop)

	fun genTest (LitTest (WordLit w), elseLabel) =
	    genTestInt (StockWerk.Word, Int32Ty, LargeWord.toInt w, elseLabel)
	  | genTest (LitTest (IntLit i), elseLabel) =
	    genTestInt (StockWerk.Int, Int32Ty, Int.fromLarge i, elseLabel)
	  | genTest (LitTest (CharLit c), elseLabel) =
	    genTestInt (StockWerk.Char, CharTy, Char.ord c, elseLabel)
	  | genTest (LitTest (StringLit s), elseLabel) =
	    (emit Dup; emit (Isinst StockWerk.String);
	     emit (B (FALSE, elseLabel));
	     emit Dup; emit (Castclass StockWerk.String);
	     emit (Ldfld (StockWerk.String, "Value", System.StringTy));
	     emit (Ldstr s);
	     emit (Call (false, System.String, "Equals",
			 [System.StringTy, System.StringTy], BoolTy));
	     emit (B (FALSE, elseLabel)); emit Pop)
	  | genTest (LitTest (RealLit s), elseLabel) =
	    (emit Dup; emit (Isinst StockWerk.Real);
	     emit (B (FALSE, elseLabel));
	     emit Dup; emit (Castclass StockWerk.Real);
	     emit (Ldfld (StockWerk.Real, "Value", Float32Ty));
	     emit (LdcR4 s); emit (B (NE_UN, elseLabel)); emit Pop)
	  | genTest (TagTest _, _) =   (*--** not implemented *)
	    raise Crash.Crash "CodeGenPhase.genTest: TagTest"
	  | genTest (TagAppTest (_, _, _), _) =   (*--** not implemented *)
	    raise Crash.Crash "CodeGenPhase.genTest: TagAppTest"
	  | genTest (ConTest id, elseLabel) =
	    (emit Dup; emitId id; emit (B (NE_UN, elseLabel)); emit Pop)
	  | genTest (ConAppTest (id, args, _), elseLabel) =
	    (emit Dup; emit (Isinst StockWerk.ConVal);
	     emit (B (FALSE, elseLabel));
	     emit (Castclass StockWerk.ConVal); emit Dup;
	     emit (Ldfld (StockWerk.ConVal, "Con", StockWerk.StockWertTy));
	     emitId id; emit (B (NE_UN, elseLabel));
	     emit (Ldfld (StockWerk.ConVal, "Val", StockWerk.StockWertTy));
	     case args of   (*--** support other args *)
		 OneArg id => declareLocal id
	       | (TupArgs _ | RecArgs _) =>
		     raise Crash.Crash "CodeGenPhase.genTest: ConAppTest")
	  | genTest (RefAppTest id, elseLabel) =
	    (emit Dup; emit (Isinst StockWerk.Ref);
	     emit (B (FALSE, elseLabel));
	     emit (Castclass StockWerk.Ref);
	     emit (Call (true, StockWerk.Ref, "Access", nil,
			 StockWerk.StockWertTy));
	     declareLocal id)
	  | genTest (TupTest nil, elseLabel) =
	    (emit Dup;
	     emit (Ldsfld (StockWerk.Prebound, "unit", StockWerk.StockWertTy));
	     emit (B (NE_UN, elseLabel)); emit Pop)
	  | genTest (TupTest [id1, id2], elseLabel) =
	    (emit Dup; emit (Isinst StockWerk.Tuple2);
	     emit (B (FALSE, elseLabel));
	     emit (Castclass StockWerk.Tuple2); emit Dup;
	     emit (Ldfld (StockWerk.Tuple2, "Value1", StockWerk.StockWertTy));
	     declareLocal id1;
	     emit (Ldfld (StockWerk.Tuple2, "Value2", StockWerk.StockWertTy));
	     declareLocal id2)
	  | genTest (TupTest [id1, id2, id3], elseLabel) =
	    (emit Dup; emit (Isinst StockWerk.Tuple3);
	     emit (B (FALSE, elseLabel));
	     emit (Castclass StockWerk.Tuple3); emit Dup;
	     emit (Ldfld (StockWerk.Tuple3, "Value1", StockWerk.StockWertTy));
	     declareLocal id1; emit Dup;
	     emit (Ldfld (StockWerk.Tuple3, "Value2", StockWerk.StockWertTy));
	     declareLocal id2;
	     emit (Ldfld (StockWerk.Tuple3, "Value3", StockWerk.StockWertTy));
	     declareLocal id3)
	  | genTest (TupTest [id1, id2, id3, id4], elseLabel) =
	    (emit Dup; emit (Isinst StockWerk.Tuple4);
	     emit (B (FALSE, elseLabel));
	     emit (Castclass StockWerk.Tuple4); emit Dup;
	     emit (Ldfld (StockWerk.Tuple4, "Value1", StockWerk.StockWertTy));
	     declareLocal id1; emit Dup;
	     emit (Ldfld (StockWerk.Tuple4, "Value2", StockWerk.StockWertTy));
	     declareLocal id2; emit Dup;
	     emit (Ldfld (StockWerk.Tuple4, "Value3", StockWerk.StockWertTy));
	     declareLocal id3;
	     emit (Ldfld (StockWerk.Tuple4, "Value4", StockWerk.StockWertTy));
	     declareLocal id4)
	  | genTest (TupTest ids, elseLabel) =
	    (emit Dup; emit (Isinst StockWerk.Tuple);
	     emit (B (FALSE, elseLabel));
	     emit (Castclass StockWerk.Tuple);
	     emit (Ldfld (StockWerk.Tuple, "Values",
			  ArrayTy StockWerk.StockWertTy));
	     Misc.List_appi (fn (i, id) =>
			     (emit Dup; emit (LdcI4 i); emit LdelemRef;
			      declareLocal id)) ids;
	     emit Pop)
	  | genTest (RecTest labelIdList, elseLabel) =
	    (emit Dup; emit (Isinst StockWerk.Record);
	     emit (B (FALSE, elseLabel));
	     emit (Castclass StockWerk.Record);
	     emit (Ldfld (StockWerk.Record, "Values",
			  ArrayTy StockWerk.StockWertTy));
	     Misc.List_appi (fn (i, (_, id)) =>
			     (emit Dup; emit (LdcI4 i); emit LdelemRef;
			      declareLocal id)) labelIdList;
	     emit Pop)
	  | genTest (LabTest (label, id), elseLabel) =
	    (emit Dup; emit (Isinst StockWerk.Record);
	     emit (B (FALSE, elseLabel));
	     case Label.toInt label of
		 SOME i =>
		     (emit (LdcI4 i);
		      emit (Call (true, StockWerk.StockWert, "CondSelect",
				  [Int32Ty], StockWerk.StockWertTy)))
	       | NONE =>
		     (emit (Ldstr (Label.toString label));
		      emit (Call (true, StockWerk.StockWert, "CondSelect",
				  [System.StringTy], StockWerk.StockWertTy)));
	     declareLocal id)
	  | genTest (VecTest ids, elseLabel) =
	    let
		val thenLabel = newLabel ()
	    in
		emit Dup; emit (Isinst StockWerk.Vector);
		emit (B (FALSE, elseLabel));
		emit (Castclass StockWerk.Vector); emit Dup;
		emit (Ldfld (StockWerk.Vector, "Values",
			     ArrayTy StockWerk.StockWertTy));
		emit Dup; emit Ldlen; emit (LdcI4 (List.length ids));
		emit (B (EQ, thenLabel)); emit Pop; emit (Br elseLabel);
		emit (Label thenLabel);
		Misc.List_appi (fn (i, id) =>
				(emit Dup; emit (LdcI4 i); emit LdelemRef;
				 declareLocal id)) ids;
		emit Pop
	    end

	fun genLit (WordLit w) =
	    (emit (LdcI4 (LargeWord.toInt w));
	     emit (Newobj (StockWerk.Word, [Int32Ty])))
	  | genLit (IntLit i) =
	    (emit (LdcI4 (Int.fromLarge i));
	     emit (Newobj (StockWerk.Int, [Int32Ty])))
	  | genLit (CharLit c) =
	    (emit (LdcI4 (Char.ord c));
	     emit (Newobj (StockWerk.Char, [CharTy])))
	  | genLit (StringLit s) =
	    (emit (Ldstr s);
	     emit (Newobj (StockWerk.String, [System.StringTy])))
	  | genLit (RealLit s) =
	    (emit (LdcR4 s);
	     emit (Newobj (StockWerk.Real, [Float32Ty])))

	(*--** in EvalStm and declarations of unused variables,
	 * remove all of exp but side-effects *)

	fun genStm (ValDec (_, id, exp, _)) =
	    (genExp (exp, BOTH); declareLocal id)
	  | genStm (RecDec (_, idExpList, _)) =
	    (List.app (fn (id, exp) =>
		       (genExp (exp, PREPARE); declareLocal id)) idExpList;
	     List.app (fn (id, exp) =>
		       (emitId id; genExp (exp, FILL))) idExpList)
	  | genStm (EvalStm (_, exp)) = (genExp (exp, BOTH); emit Pop)
	  | genStm (HandleStm (_, tryBody, id, catchBody, contBody, shared)) =
	    let
		val label1 = newLabel ()
		val label2 = newLabel ()
		val label3 = newLabel ()
	    in
		shared := label3;
		emit (Try (label1, label2, StockWerk.ExceptionWrapper,
			   label2, label3));
		emit (Label label1); genBody tryBody;
		emit (Label label2);
		emit (Ldfld (StockWerk.ExceptionWrapper, "Value",
			     StockWerk.StockWertTy));
		declareLocal id; genBody catchBody;
		emit (Label label3); genBody contBody
	    end
	  | genStm (EndHandleStm (_, shared)) = emit (Leave (!shared))
	  | genStm (stm as TestStm (_, id, _, _, _)) =
	    let
		val (testBodyList, elseBody) = gatherTests ([stm], id)
	    in
		genTestStm (id, testBodyList, fn () => genBody elseBody)
	    end
	  | genStm (RaiseStm (info, id)) =
	    let
		val ((line, _), (_, _)) = #region info
	    in
		emitId id; emit (LdcI4 line);
		emit (Newobj (StockWerk.ExceptionWrapper,
			      [StockWerk.StockWertTy, Int32Ty]));
		emit Throw
	    end
	  | genStm (ReraiseStm (_, _)) = emit Rethrow
	  | genStm (SharedStm (_, body, shared as ref 0)) =
	    let
		val label = newLabel ()
	    in
		emit (Label label); shared := label; genBody body
	    end
	  | genStm (SharedStm (_, _, ref i)) = emit (Br i)
	  | genStm (ReturnStm (_, exp)) = (genExp (exp, BOTH); emit Ret)
	  | genStm (IndirectStm (_, ref bodyOpt)) = genBody (valOf bodyOpt)
	  | genStm (ExportStm (_, exp)) = (genExp (exp, BOTH); emit Ret)
	and gatherTests ([TestStm (_, id, test, thenBody, elseBody)], id') =
	    if idEq (id, id') then
		let
		    val (testBodyList, elseBody') = gatherTests (elseBody, id')
		in
		    ((test, thenBody)::testBodyList, elseBody')
		end
	    else (nil, elseBody)
	  | gatherTests (body, _) = (nil, body)
	and genTestStm (_, nil, elseBodyFun) = elseBodyFun ()
	  | genTestStm (id, testBodyList, elseBodyFun) =
	    let
		val retryLabel = newLabel ()
		val falseLabel = newLabel ()
	    in
		emitId id; emit (Label retryLabel);
		List.app (fn (test, body) =>
			  let
			      val elseLabel = newLabel ()
			      val regState = saveRegState ()
			  in
			      genTest (test, elseLabel); genBody body;
			      emit (Label elseLabel); restoreRegState regState
			  end) testBodyList;
		emit Dup; emit (Isinst StockWerk.Transient);
		emit (B (FALSE, falseLabel));
		emit (Callvirt (StockWerk.StockWert, "Await", nil,
				StockWerk.StockWertTy));
		emit (Br retryLabel); emit (Label falseLabel);
		emit Pop; elseBodyFun ()
	    end
	and genExp (LitExp (_, lit), PREPARE) = genLit lit
	  | genExp (PrimExp (_, name), PREPARE) =
	    let
		val (id, ty) = Builtins.lookup name
	    in
		emit (Ldsfld (StockWerk.Prebound, id, ty))
	    end
	  | genExp (NewExp (_, _), PREPARE) =
	    emit (Newobj (StockWerk.GenerativeCon, nil))
	  | genExp (VarExp (_, id), PREPARE) = emitId id
	  | genExp (TagExp (_, _, _), _) =   (*--** not implemented *)
	    raise Crash.Crash "CodeGenPhase.genExp: TagExp"
	  | genExp (ConExp (_, id as Id (_, stamp, _), _), PREPARE) = emitId id
	  | genExp (RefExp _, PREPARE) =
	    emit (Ldsfld (StockWerk.Prebound, "ref", StockWerk.StockWertTy))
	  | genExp (TupExp (_, nil), PREPARE) =
	    emit (Ldsfld (StockWerk.Prebound, "unit", StockWerk.StockWertTy))
	  | genExp (TupExp (_, nil), FILL) = ()
	  | genExp (TupExp (_, nil), BOTH) =
	    emit (Ldsfld (StockWerk.Prebound, "unit", StockWerk.StockWertTy))
	  | genExp (TupExp (_, [id1, id2]), PREPARE) =
	    emit (Newobj (StockWerk.Tuple2, nil))
	  | genExp (TupExp (_, [id1, id2]), FILL) =
	    (emit Dup; emitId id1;
	     emit (Stfld (StockWerk.Tuple2, "Value1", StockWerk.StockWertTy));
	     emitId id2;
	     emit (Stfld (StockWerk.Tuple2, "Value2", StockWerk.StockWertTy)))
	  | genExp (TupExp (_, [id1, id2]), BOTH) =
	    (emit (Newobj (StockWerk.Tuple2, nil));
	     emit Dup; emitId id1;
	     emit (Stfld (StockWerk.Tuple2, "Value1", StockWerk.StockWertTy));
	     emit Dup; emitId id2;
	     emit (Stfld (StockWerk.Tuple2, "Value2", StockWerk.StockWertTy)))
	  | genExp (TupExp (_, [id1, id2, id3]), PREPARE) =
	    emit (Newobj (StockWerk.Tuple3, nil))
	  | genExp (TupExp (_, [id1, id2, id3]), FILL) =
	    (emit Dup; emitId id1;
	     emit (Stfld (StockWerk.Tuple3, "Value1", StockWerk.StockWertTy));
	     emit Dup; emitId id2;
	     emit (Stfld (StockWerk.Tuple3, "Value2", StockWerk.StockWertTy));
	     emitId id3;
	     emit (Stfld (StockWerk.Tuple3, "Value3", StockWerk.StockWertTy)))
	  | genExp (TupExp (_, [id1, id2, id3]), BOTH) =
	    (emit (Newobj (StockWerk.Tuple3, nil));
	     emit Dup; emitId id1;
	     emit (Stfld (StockWerk.Tuple3, "Value1", StockWerk.StockWertTy));
	     emit Dup; emitId id2;
	     emit (Stfld (StockWerk.Tuple3, "Value2", StockWerk.StockWertTy));
	     emit Dup; emitId id3;
	     emit (Stfld (StockWerk.Tuple3, "Value3", StockWerk.StockWertTy)))
	  | genExp (TupExp (_, [id1, id2, id3, id4]), PREPARE) =
	    emit (Newobj (StockWerk.Tuple4, nil))
	  | genExp (TupExp (_, [id1, id2, id3, id4]), FILL) =
	    (emit Dup; emitId id1;
	     emit (Stfld (StockWerk.Tuple4, "Value1", StockWerk.StockWertTy));
	     emit Dup; emitId id2;
	     emit (Stfld (StockWerk.Tuple4, "Value2", StockWerk.StockWertTy));
	     emit Dup; emitId id3;
	     emit (Stfld (StockWerk.Tuple4, "Value3", StockWerk.StockWertTy));
	     emitId id4;
	     emit (Stfld (StockWerk.Tuple4, "Value4", StockWerk.StockWertTy)))
	  | genExp (TupExp (_, [id1, id2, id3, id4]), BOTH) =
	    (emit (Newobj (StockWerk.Tuple4, nil));
	     emit Dup; emitId id1;
	     emit (Stfld (StockWerk.Tuple4, "Value1", StockWerk.StockWertTy));
	     emit Dup; emitId id2;
	     emit (Stfld (StockWerk.Tuple4, "Value2", StockWerk.StockWertTy));
	     emit Dup; emitId id3;
	     emit (Stfld (StockWerk.Tuple4, "Value3", StockWerk.StockWertTy));
	     emit Dup; emitId id4;
	     emit (Stfld (StockWerk.Tuple4, "Value4", StockWerk.StockWertTy)))
	  | genExp (TupExp (_, ids), PREPARE) =
	    (emit (LdcI4 (List.length ids));
	     emit (Newarr StockWerk.StockWertTy);
	     emit (Newobj (StockWerk.Tuple, [ArrayTy StockWerk.StockWertTy])))
	  | genExp (TupExp (_, ids), FILL) =
	    (emit (Ldfld (StockWerk.Tuple, "Values",
			  ArrayTy StockWerk.StockWertTy));
	     Misc.List_appi (fn (i, id) =>
			     (emit Dup; emit (LdcI4 i); emitId id;
			      emit StelemRef)) ids;
	     emit Pop)
	  | genExp (TupExp (_, ids), BOTH) =
	    (emit (LdcI4 (List.length ids));
	     emit (Newarr StockWerk.StockWertTy);
	     Misc.List_appi (fn (i, id) =>
			     (emit Dup; emit (LdcI4 i); emitId id;
			      emit StelemRef)) ids;
	     emit (Newobj (StockWerk.Tuple, [ArrayTy StockWerk.StockWertTy])))
	  | genExp (RecExp (_, labelIdList), PREPARE) =
	    (emitRecordArity labelIdList;
	     emit (LdcI4 (List.length labelIdList));
	     emit (Newarr StockWerk.StockWertTy);
	     emit (Newobj (StockWerk.Record, [StockWerk.RecordArityTy,
					      ArrayTy StockWerk.StockWertTy])))
	  | genExp (RecExp (_, labelIdList), FILL) =
	    (emit (Ldfld (StockWerk.Record, "Values",
			  ArrayTy StockWerk.StockWertTy));
	     Misc.List_appi (fn (i, (_, id)) =>
			     (emit Dup; emit (LdcI4 i); emitId id;
			      emit StelemRef)) labelIdList;
	     emit Pop)
	  | genExp (RecExp (_, labelIdList), BOTH) =
	    (emitRecordArity labelIdList;
	     emit (LdcI4 (List.length labelIdList));
	     emit (Newarr StockWerk.StockWertTy);
	     Misc.List_appi (fn (i, (_, id)) =>
			     (emit Dup; emit (LdcI4 i); emitId id;
			      emit StelemRef)) labelIdList;
	     emit (Newobj (StockWerk.Record, [StockWerk.RecordArityTy,
					      ArrayTy StockWerk.StockWertTy])))
	  | genExp (SelExp (_, label), BOTH) =
	    (case Label.toInt label of
		 SOME i =>
		     (emit (LdcI4 i);
		      emit (Newobj (StockWerk.IntSelector, [Int32Ty])))
	       | NONE =>
		     (emit (Ldstr (Label.toString label));
		      emit (Newobj (StockWerk.StringSelector,
				    [System.StringTy]))))
	  | genExp (VecExp (_, ids), PREPARE) =
	    (emit (LdcI4 (List.length ids));
	     emit (Newarr StockWerk.StockWertTy);
	     emit (Newobj (StockWerk.Vector, [ArrayTy StockWerk.StockWertTy])))
	  | genExp (VecExp (_, ids), FILL) =
	    (emit (Ldfld (StockWerk.Vector, "Values",
			  ArrayTy StockWerk.StockWertTy));
	     Misc.List_appi (fn (i, id) =>
			     (emit Dup; emit (LdcI4 i); emitId id;
			      emit StelemRef)) ids;
	     emit Pop)
	  | genExp (FunExp (info, stamp, _, args, body), PREPARE) =
	    (emitRegion ("FunExp", #region info);
	     emit (Newobj (className stamp, nil));
	     case args of
		 TupArgs nil =>
		     defineClass (stamp, StockWerk.Procedure0, nil)
	       | TupArgs [_, _] =>
		     defineClass (stamp, StockWerk.Procedure2, nil)
	       | TupArgs [_, _, _] =>
		     defineClass (stamp, StockWerk.Procedure3, nil)
	       | TupArgs [_, _, _, _] =>
		     defineClass (stamp, StockWerk.Procedure4, nil)
	       | _ =>
		     defineClass (stamp, StockWerk.Procedure, nil))
	  | genExp (FunExp (_, stamp, _, args, body), FILL) =
	    (case args of
		 OneArg id =>
		     (defineMethod (stamp, "Apply", [id]);
		      genBody body; closeMethod ())
	       | TupArgs nil =>
		     (defineMethod (stamp, "Apply0", nil);
		      genBody body; closeMethod ())
	       | TupArgs (ids as [_, _]) =>
		     (defineMethod (stamp, "Apply2", ids);
		      genBody body; closeMethod ())
	       | TupArgs (ids as [_, _, _]) =>
		     (defineMethod (stamp, "Apply3", ids);
		      genBody body; closeMethod ())
	       | TupArgs (ids as [_, _, _, _]) =>
		     (defineMethod (stamp, "Apply4", ids);
		      genBody body; closeMethod ())
	       | _ =>
		     let
			 val info = {region = Source.nowhere}
			 val id = Id (info, Stamp.new (), Name.InId)
			 val test =
			     case args of
				 OneArg _ =>
				     raise Crash.Crash
					 "CodeGenPhase.genExp: FunExp"
			       | TupArgs ids => TupTest ids
			       | RecArgs labelIdList => RecTest labelIdList
			 fun elseBodyFun () =
			     (emit (Ldsfld (StockWerk.Prebound,
					    "General$Match",
					    StockWerk.StockWertTy));
			      emit (Newobj (StockWerk.ExceptionWrapper,
					    [StockWerk.StockWertTy]));
			      emit Throw)
		     in
			 defineMethod (stamp, "Apply", [id]);
			 genTestStm (id, [(test, body)], elseBodyFun);
			 closeMethod ()
		     end;
	     emit Pop)
	  | genExp (AppExp (_, id1, OneArg id2), BOTH) =
	    (emitId id1; emitId id2;
	     emit (Callvirt (StockWerk.StockWert, "Apply",
			     [StockWerk.StockWertTy], StockWerk.StockWertTy)))
	  | genExp (AppExp (_, id, TupArgs nil), BOTH) =
	    (emitId id;
	     emit (Callvirt (StockWerk.StockWert, "Apply0",
			     nil, StockWerk.StockWertTy)))
	  | genExp (AppExp (_, id, TupArgs [id1, id2]), BOTH) =
	    (emitId id; emitId id1; emitId id2;
	     emit (Callvirt (StockWerk.StockWert, "Apply2",
			     [StockWerk.StockWertTy, StockWerk.StockWertTy],
			     StockWerk.StockWertTy)))
	  | genExp (AppExp (_, id, TupArgs [id1, id2, id3]), BOTH) =
	    (emitId id; emitId id1; emitId id2; emitId id3;
	     emit (Callvirt (StockWerk.StockWert, "Apply3",
			     [StockWerk.StockWertTy, StockWerk.StockWertTy,
			      StockWerk.StockWertTy], StockWerk.StockWertTy)))
	  | genExp (AppExp (_, id, TupArgs [id1, id2, id3, id4]), BOTH) =
	    (emitId id; emitId id1; emitId id2; emitId id3; emitId id4;
	     emit (Callvirt (StockWerk.StockWert, "Apply4",
			     [StockWerk.StockWertTy, StockWerk.StockWertTy,
			      StockWerk.StockWertTy, StockWerk.StockWertTy],
			     StockWerk.StockWertTy)))
	  | genExp (AppExp (info, id, TupArgs ids), BOTH) =
	    (emitId id; genExp (TupExp (info, ids), BOTH);
	     emit (Callvirt (StockWerk.StockWert, "Apply",
			     [StockWerk.StockWertTy], StockWerk.StockWertTy)))
	  | genExp (AppExp (info, id, RecArgs labelIdList), BOTH) =
	    (emitId id; genExp (RecExp (info, labelIdList), BOTH);
	     emit (Callvirt (StockWerk.StockWert, "Apply",
			     [StockWerk.StockWertTy], StockWerk.StockWertTy)))
	  | genExp (SelAppExp (_, label, id), BOTH) =
	    (emitId id;
	     case Label.toInt label of
		 SOME i =>
		     (emit (LdcI4 i);
		      emit (Callvirt (StockWerk.StockWert, "Select", [Int32Ty],
				      StockWerk.StockWertTy)))
	       | NONE =>
		     (emit (Ldstr (Label.toString label));
		      emit (Callvirt (StockWerk.StockWert, "Select",
				      [System.StringTy],
				      StockWerk.StockWertTy))))
	  | genExp (TagAppExp (_, _, _, _), _) =   (*--** not implemented *)
	    raise Crash.Crash "CodeGenPhase.genExp: TagAppExp"
	  | genExp (ConAppExp (_, id, _, _), PREPARE) =
	    (emitId id;
	     emit (Newobj (StockWerk.ConVal, [StockWerk.StockWertTy])))
	  | genExp (ConAppExp (_, _, args, _), FILL) =
	    (genArgs args;
	     emit (Stfld (StockWerk.ConVal, "Val", StockWerk.StockWertTy)))
	  | genExp (RefAppExp (_, _), PREPARE) =
	    emit (Newobj (StockWerk.Ref, nil))
	  | genExp (RefAppExp (_, id), FILL) =
	    (emitId id;
	     emit (Call (true, StockWerk.Ref, "Assign",
			 [StockWerk.StockWertTy], VoidTy)))
	  | genExp (PrimAppExp (_, name, ids), BOTH) =   (*--** not impl'd *)
	    raise Crash.Crash "CodeGenPhase.genExp: PrimAppExp"
	  | genExp (AdjExp (_, id1, id2), BOTH) =   (*--** not implemented *)
	    raise Crash.Crash "CodeGenPhase.genExp: AdjExp"
	  | genExp (exp, PREPARE) =
	    raise Crash.Crash "CodeGenPhase.genExp: not admissible"
	  | genExp (_, FILL) = emit Pop
	  | genExp (exp, BOTH) =
	    (genExp (exp, PREPARE); emit Dup; genExp (exp, FILL))
	and genArgs (OneArg id) = emitId id
	  | genArgs (TupArgs ids) =
	    let
		val info = {region = Source.nowhere,
			    typ = Type.unknown Type.STAR}   (*--** type *)
	    in
		genExp (TupExp (info, ids), BOTH)
	    end
	  | genArgs (RecArgs labelIdList) =
	    let
		val info = {region = Source.nowhere,
			    typ = Type.unknown Type.STAR}   (*--** type *)
	    in
		genExp (RecExp (info, labelIdList), BOTH)
	    end
	and genBody (stm::stms) =
	    (case #liveness (infoStm stm) of
		 ref (Kill set) => kill set
	       | ref _ => ();
	     genStm stm; genBody stms)
	  | genBody nil = ()

	fun genComponent (component as (imports, (body, _))) =
	    (LivenessAnalysisPhase.annotate component;
	     init ["Test"];
	     List.app (fn (id, _, url) =>
		       (emit (Ldarg 0);
			emit (Ldstr (Url.toString url));
			emit (Call (true, StockWerk.Komponist, "Import",
				    [System.StringTy], StockWerk.StockWertTy));
			declareLocal id)) imports;
	     genBody body; close())
    end
(* src # 152 ../top/MAIN.sig *)
signature MAIN =
  sig

    val parseString :		string -> InputGrammar.t
    val parseFile :		string -> InputGrammar.t

    val abstractString :	string -> AbstractGrammar.t
    val abstractFile :		string -> AbstractGrammar.t

    val elabString :		string -> TypedGrammar.t
    val elabFile :		string -> TypedGrammar.t

    val translateString :	string -> IntermediateGrammar.t
    val translateFile :		string -> IntermediateGrammar.t

    val flattenString :		string -> FlatGrammar.component
    val flattenFile :		string -> FlatGrammar.component

    val debugStringToStdOut :	string -> unit
    val debugFileToStdOut :	string -> unit

    val debugStringToFile :	string * string -> unit
    val debugFileToFile :	string * string -> unit

    val ozifyStringToStdOut :	string -> unit
    val ozifyFileToStdOut :	string -> unit

    val ozifyStringToFile :	string * string -> unit
    val ozifyFileToFile :	string * string -> unit

    val compileForMozart :	string * string -> IntermediateGrammar.sign

    val comifyStringToStdOut :	string -> unit
    val comifyFileToStdOut :	string -> unit

    val comifyStringToFile :	string * string -> unit
    val comifyFileToFile :	string * string -> unit

  end
(* src # 153 ../top/Main.sml *)
structure Main :> MAIN =
  struct

    fun processString process source =
	process source
	handle exn as Crash.Crash message =>
	    ( TextIO.output(TextIO.stdErr, "CRASH: " ^ message ^ "\n")
	    ; raise exn
	    )

    fun processFile process name =
	let
	    val file   = TextIO.openIn name
	    val source = TextIO.inputAll file
	    val _      = TextIO.closeIn file
	in
	    processString process source
	end

    fun toFile process name s =
	let
	    val file = TextIO.openOut name
	in
	    process file s handle x => ( TextIO.closeOut file ; raise x ) ;
	    TextIO.closeOut file
	end

    fun parse' x     = ParsingPhase.translate () x
    fun abstract' x  = AbstractionPhase.translate (BindEnv.clone BindEnv0.E0) x
    fun elab' x      = ElaborationPhase.translate (Env.clone Env0.E0) x
    fun translate' x = TranslationPhase.translate () x
    fun flatten' x   = FlatteningPhase.translate () x
    fun ilify' x     = CodeGenPhase.genComponent x

    val parse        = parse' o Source.fromString
    val abstract     = abstract' o parse
    val elab         = elab' o abstract
    val translate    = translate' o elab
    val flatten      = flatten' o translate
    val ilify        = ilify' o flatten

    fun debug outstream s =
	let
	    val x = flatten s
	    val _ = LivenessAnalysisPhase.annotate x
	    val s' = OutputFlatGrammar.outputComponent x
	in
	    TextIO.output (outstream, s')
	end

    fun ozify outstream inFilename s =
	let
	    val component = flatten s
	in
	    OzifyFlatGrammar.externalize (outstream, (inFilename, component));
	    TextIO.output1 (outstream, #"\n")
	end

    fun mozartify inFilename outFilename s =
	let
	    val component as (_, (_, exportSign)) = flatten s
	    val engine = MozartEngine.start ()
	in
	    MozartTarget.save engine outFilename
	    (MozartGenerationPhase.translate inFilename component);
	    exportSign
	end

    fun comify outstream s =
	let
	    val component = ilify s
	in
	    IL.outputProgram (outstream, component);
	    TextIO.output1 (outstream, #"\n")
	end

    val parseString		= processString parse
    val parseFile		= processFile parse

    val abstractString		= processString abstract
    val abstractFile		= processFile abstract

    val elabString		= processString elab
    val elabFile		= processFile elab

    val translateString		= processString translate
    val translateFile		= processFile translate

    val flattenString		= processString flatten
    val flattenFile		= processFile flatten

    val debugStringToStdOut	= processString (debug TextIO.stdOut)
    val debugFileToStdOut	= processFile (debug TextIO.stdOut)

    fun debugStringToFile(s,n)	= processString (toFile debug n) s
    fun debugFileToFile(n1,n2)	= processFile (toFile debug n2) n1

    val ozifyStringToStdOut	= processString (ozify TextIO.stdOut "")
    fun ozifyFileToStdOut(n)	= processFile (ozify TextIO.stdOut n) n

    fun ozifyStringToFile(s,n)	= processString (toFile ozify n) s
    fun ozifyFileToFile(n1,n2)	= processFile (toFile ozify n2) n1

    fun compileForMozart(n1,n2)	= processFile (mozartify n1 n2) n1

    val comifyStringToStdOut	= processString (comify TextIO.stdOut)
    val comifyFileToStdOut	= processFile (comify TextIO.stdOut)

    fun comifyStringToFile(s,n)	= processString (toFile comify n) s
    fun comifyFileToFile(n1,n2)	= processFile (toFile comify n2) n1

  end
