(*
 * Author:
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Andreas Rossberg, 2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure TypedInfo
       structure TypedGrammar		from "TypedGrammar"
import structure IntermediateGrammar	from "../common/IntermediateGrammar"
import structure EmptyContext		from "../infrastructure/EmptyContext"

import structure Stamp			from "../common/Stamp"
import structure Fixity			from "../../lib/rtt/Fixity"
import structure Name			from "../../lib/rtt/Name"
import structure Label			from "../../lib/rtt/Label"
import structure Path			from "../../lib/rtt/Path"
import structure Type			from "../../lib/rtt/Type"
import structure Inf			from "../../lib/rtt/Inf"
import structure PervasiveType		from "../../lib/rtt/PervasiveType"
import structure PathMap		from "../../lib/rtt/PathMap"

import structure NameTranslation	from "NameTranslation"
import structure LabelTranslation	from "LabelTranslation"
import structure PathTranslation	from "PathTranslation"
import structure TypeTranslation	from "TypeTranslation"
import structure InfTranslation		from "InfTranslation"
import structure FixityTranslation	from "FixityTranslation"
import structure PervasiveTypeTranslation from "PervasiveTypeTranslation"

import structure TranslationEnv		from "TranslationEnv"
import structure Assert                 from "../../lib/utility/Assert"
import structure Crash			from "../infrastructure/Crash"
import structure Error			from "../infrastructure/Error"
import structure Source			from "../infrastructure/Source"
import structure StampMap		from "../common/StampMap"
import structure StringMap		from "../infrastructure/StringMap"
import signature SWITCHES		from "../infrastructure/SWITCHES-sig"
import signature TRANSLATION_PHASE	from "TRANSLATION_PHASE-sig"

functor MkTranslationPhase(Switches: SWITCHES) : TRANSLATION_PHASE =
struct

    structure C = TranslationEnv
    structure I = TypedGrammar
    structure O = IntermediateGrammar

    open TypedInfo

  (* UNFINISHED... *)

    fun unfinished i funname casename =
	Error.error(i, "Translation." ^ funname ^ ": " ^ casename ^
		       " not implemented yet")

  (* Helpers *)

    fun idToFld idToX (x' as O.Id(i,_,n)) =
	let
	    val i' = nonInfo(#region i)
	in
	    O.Fld(i', O.Lab(i', Label.fromName n), idToX x')
	end

    (*DEBUG helpers

    fun prStamp name z =
	(print name; print " = ";
	 print(Stamp.toString z);
	 print "\n")

    fun prLab name l =
	(print name; print " = ";
	 print(Label.toString l);
	 print "\n")

    fun prPath name p =
	(print name; print " = ";
	 PrettyPrint.output(TextIO.stdOut, PPPath.ppPath p, 76 - size name);
	 print "\n")

    fun prTyp name t =
	(print name; print " = ";
	 PrettyPrint.output(TextIO.stdOut, PPType.ppTyp t, 76 - size name);
	 print "\n")

    fun prInf name j =
	(print name; print " = ";
	 PrettyPrint.output(TextIO.stdOut, PPInf.ppInf j, 76 - size name);
	 print "\n")

    *)


  (* Names and labels *)

    open NameTranslation

    fun trValLabel a = Label.fromName(trValName(Label.toName a))
    fun trTypLabel a = Label.fromName(trTypName(Label.toName a))
    fun trModLabel a = Label.fromName(trModName(Label.toName a))
    fun trInfLabel a = Label.fromName(trInfName(Label.toName a))


  (* Types for annotating RTT code *)

    open PervasiveType
    open InfTranslation
    open TypeTranslation
    open PervasiveTypeTranslation
    open PathTranslation
    open LabelTranslation
    open FixityTranslation

    val typ_unit	= Type.tuple #[]
    val var_poly	= Type.newVar(Type.starKind())
    val typ_poly	= Type.all(var_poly, Type.var var_poly)

    fun typ(E, modlab, lab) =
	if not(!Switches.Language.supportRtt) then typ_poly else
	let
	    val x  = TranslationEnv.lookupPervasive E
	    val j0 = #inf(I.infoId x)
	    val j1 = Inf.lookupMod(Inf.asSig' j0, modlab)
	    val t  = Inf.lookupTyp'(Inf.asSig' j1, lab)
	in
	    t
	end

    fun typ_lab E	= typ(E, modlab_label,  typlab_lab)
    fun typ_path E	= typ(E, modlab_path,   typlab_path)
    fun typ_typ E	= typ(E, modlab_type,   typlab_typ)
    fun typ_var E	= typ(E, modlab_type,   typlab_var)
    fun typ_row E	= typ(E, modlab_type,   typlab_row)
    fun typ_kind E	= typ(E, modlab_type,   typlab_kind)
    fun typ_inf E	= typ(E, modlab_inf,    typlab_inf)
    fun typ_sig E	= typ(E, modlab_inf,    typlab_sig)
    fun typ_ikind E	= typ(E, modlab_inf,    typlab_kind)
    fun typ_rea E	= typ(E, modlab_inf,    typlab_rea)
    fun typ_fix E	= typ(E, modlab_fixity, typlab_fix)
    fun typ_assoc E	= typ(E, modlab_fixity, typlab_assoc)


  (* Transformation of type info *)

    val infHash  = Inf.Map.new() : Type.t Inf.Map.t
		(*UNFINISHED: remove this global variable! *)

    (* A proper translation of interface kinds would require
     * polymorphic kinds and record kinds, because we have first
     * class signatures!
     * Example:
     *   fun(X:{interface I}) -> fun(Y:X.I) -> something
     * A faithful translation of this type would be something like
     *   Fun k -> fun x:{I:*} -> fun x':{I:k} -> something
     * where Fun denotes big lambda and {I:..} is a record kind.
     * We don't try this but use SealExp as an (unsound) approximation.
     *)

    fun ikindToKind k = Type.starKind()

    fun infToTyp(E,j) =
	case Inf.Map.lookup(infHash, j) of
	  SOME t => t
	| NONE   =>
	    let
		val t = infToTyp'(E,j)
	    in
		Inf.Map.insert(infHash, j, t);
		t
	    end

    and infToTyp'(E,j) =
	if Inf.isTop' j then
	    (* [any] = top *)
	    typ_unit
	else if Inf.isCon' j then
	    (* [p] = p *)
	    let
		val p = Inf.asCon' j
		val k = Inf.kind j
	    in
		Type.con(p, ikindToKind k)
	    end
	else if Inf.isSig' j then
	    (* [sig items end] = {[items]} *)
	    let
		val s     = Inf.asSig' j
		val items = Inf.items s
	    in
		Type.prod(List.foldr (itemToRow E) (Type.unknownRow()) items)
	    end
	else if Inf.isArrow' j then
	    (* [fct(x:j1) -> j2] = [j1] -> [j2] *)
	    let
		val (p,j1,j2) = Inf.asArrow' j
	    in
		Type.arrow(infToTyp(E,j1), infToTyp(E,j2))
	    end
	else if Inf.isLambda j then
	    (* [\x:j1 . j2] = [j2] *)
	    let
		val (p,j1,j2) = Inf.asLambda j
	    in
		infToTyp(E,j2)
	    end
	else if Inf.isApply j then
	    (* [j1(x:j2)] = [j1] *)
	    let
		val (j1,m) = Inf.asApply j
	    in
		infToTyp(E,j1)
	    end
	else
	    raise Crash.Crash "TranslationPhase.infToTyp: unknown inf"

    and itemToRow E (item,r) =
	if Inf.isValItem item then
	    let
		val (l,t) = Inf.asValItem item
	    in
		Type.extendRow(trValLabel l, t, r)
	    end
	else if Inf.isTypItem item then
	    let
		val (p,k) = Inf.asTypItem item
		val  t    = typ_typ E handle TranslationEnv.Pervasive =>
			    (Error.warn(Source.nowhere,
					"RTT types not available everywhere");
			     typ_poly) (* for bootstrapping *)
	    in
		Type.extendRow(trTypLabel(Path.toLab p), t, r)
	    end
	else if Inf.isModItem item then
	    let
		val (p,j) = Inf.asModItem item
	    in
		Type.extendRow(trModLabel(Path.toLab p), infToTyp(E,j), r)
	    end
	else if Inf.isInfItem item then
	    let
		val (p,k) = Inf.asInfItem item
		val  t    = typ_inf E handle TranslationEnv.Pervasive =>
			    (Error.warn(Source.nowhere,
					"RTT types not available everywhere");
			     typ_poly) (* for bootstrapping *)
	    in
		Type.extendRow(trInfLabel(Path.toLab p), t, r)
	    end
	else (* fixity or hidden *)
	    r


  (* Identifiers and operations for RTT code *)

    (* We have to insert x before we can call infToTyp! *)

    fun updatePervasive(E, x as I.Id(i,z,n)) =
	if n <> name_pervasive then () else
	    TranslationEnv.insertPervasive(E,x)

    fun updatePervasive'(E, x as I.Id(i,z,n) : I.modid) =
	if n <> name_pervasive then () else
	let
	    val i' = typInfo(#region i, infToTyp(E, #inf i))
	    val y  = O.ShortId(i', O.Id(i', z, trModName n))
	in
	    TranslationEnv.insertPervasive'(E,y)
	end

    fun access modlab (E, lab) =
	let
	    val r       = Source.nowhere
	    val modlab' = trModLabel modlab
	    val lab'    = trValLabel lab
	    val longid0 = TranslationEnv.lookupPervasive' E
(*DEBUG*)handle e => (Error.warn(Source.nowhere, Label.toString modlab ^ "." ^ Label.toString lab);raise e)
	    val t0      = #typ(O.infoLongid longid0)
	    val t1      = Type.lookupRow(Type.asProd t0, modlab')
	    val longid1 = O.LongId(typInfo(r,t1), longid0,
				   O.Lab(nonInfo r, modlab'))
	    val t2      = Type.lookupRow(Type.asProd t1, lab)
	    val longid2 = O.LongId(typInfo(r,t2), longid1,
				   O.Lab(nonInfo r, lab'))
	in
	    O.VarExp(typInfo(r,t2), longid2)
	end

    fun call modlab (E, lab, exp2) =
	let
	    val r       = #region(O.infoExp exp2)
	    val modlab' = trModLabel modlab
	    val lab'    = trValLabel lab
	    val longid0 = TranslationEnv.lookupPervasive' E
(*DEBUG*)handle e => (Error.warn(Source.nowhere, Label.toString modlab ^ "." ^ Label.toString lab);raise e)
	    val t0      = #typ(O.infoLongid longid0)
	    val t1      = Type.lookupRow(Type.asProd t0, modlab')
	    val longid1 = O.LongId(typInfo(r,t1), longid0,
				   O.Lab(nonInfo r, modlab'))
	    val t2      = Type.lookupRow(Type.asProd t1, lab)
	    val longid2 = O.LongId(typInfo(r,t2), longid1,
				   O.Lab(nonInfo r, lab'))
	    val exp1    = O.VarExp(typInfo(r,t2), longid2)
	    val (t3,t4) = Type.asArrow t2
	in
	    (*ASSERT Type.equal(t3,#typ(infoExp exp2)) *)
	    O.AppExp(typInfo(r,t4), exp1, exp2)
	end

    val callFix			= call modlab_fixity
    val accessFix		= access modlab_fixity
    val callLab			= call modlab_label
    val callPath		= call modlab_path
    val callTyp			= call modlab_type
    val callPervType		= call modlab_pervasiveType
    val accessPervType		= access modlab_pervasiveType
    val callInf			= call modlab_inf
    fun callPervInf x		= (*UNFINISHED*)
				  (unfinished(Source.nowhere) "callPervInf" "";
				   callInf x)


  (* Primitive types and expressions *)

    fun trLazy e = O.LazyExp(O.infoExp e, e)

    fun trUnit r =
	O.TupExp(typInfo(r, typ_unit), #[])
    fun trInt(r, n) =
	O.LitExp(typInfo(r, typ_int), O.IntLit(LargeInt.fromInt n))
    fun trString(r, s) =
	O.LitExp(typInfo(r, typ_string), O.StringLit(String.toWide s))

    fun trTuple(r, es) =
	O.TupExp(typInfo(r, Type.tuple(Vector.map (#typ o O.infoExp) es)), es)
    fun trVector(r, t, es) =
	O.VecExp(typInfo(r, Type.apply(typ_vec, t)), es)

    fun trAssoc(E, r, Fixity.LEFT)    = accessFix(E, lab_left)
      | trAssoc(E, r, Fixity.RIGHT)   = accessFix(E, lab_right)
      | trAssoc(E, r, Fixity.NEITHER) =	accessFix(E, lab_neither)

    fun trFix(E, r, Fixity.NONFIX) =
	accessFix(E, lab_nonfix)
      | trFix(E, r, Fixity.PREFIX n) =
	callFix(E, lab_prefix, trInt(r,n))
      | trFix(E, r, Fixity.POSTFIX n) =
	callFix(E, lab_postfix, trInt(r,n))
      | trFix(E, r, Fixity.INFIX(n,a)) =
	callFix(E, lab_infix, trTuple(r, #[trInt(r,n), trAssoc(E,r,a)]))

    fun trLab(E, r, l) =
	callLab(E, lab_fromString, trString(r, Label.toString l))
    fun trPath(E, r, n) =
	callPath(E, lab_fromString, trString(r, Name.toString n))
    fun trPath'(E, r) =
	callPath(E, lab_invent, trUnit r)

    fun trKind(E, r, k) =
	if Type.isExtKind k then
	    callTyp(E, lab_extKind, trUnit r)
	else if Type.isStarKind k then
	    callTyp(E, lab_starKind, trUnit r)
	else if Type.isArrowKind k then
	    let
		val (k1,k2) = Type.asArrowKind k
		val  k1'    = trKind(E, r, k1)
		val  k2'    = trKind(E, r, k2)
	    in
		callTyp(E, lab_arrowKind, trTuple(r, #[k1',k2']))
	    end
	else
	    raise Crash.Crash "TranslationPhase.trKind"


  (* Literals *)

    fun trLit(I.IntLit n)		= O.IntLit n
      | trLit(I.WordLit w)		= O.WordLit w
      | trLit(I.CharLit c)		= O.CharLit c
      | trLit(I.StringLit s)		= O.StringLit s
      | trLit(I.RealLit x)		= O.RealLit x


  (* Identifiers *)

    fun trValInfo(E,i)			= i
    fun trTypInfo(E, {region,typ})	= {region=region, typ=typ_typ E}
    fun trVarInfo(E, {region,var})	= {region=region, typ=typ_var E}
    fun trModInfo(E, {region,inf})	= {region=region, typ=infToTyp(E,inf)}
    fun trInfInfo(E, {region,inf})	= {region=region, typ=typ_inf E}

    fun trVallab(I.Lab(i,l))		= O.Lab(i, trValLabel l)
    fun trTyplab(I.Lab(i,l))		= O.Lab(i, trTypLabel l)
    fun trModlab(I.Lab(i,l))		= O.Lab(i, trModLabel l)
    fun trInflab(I.Lab(i,l))		= O.Lab(i, trInfLabel l)

    exception VirtualModule

    fun trValid(E, I.Id(i,z,n))		= O.Id(trValInfo(E,i), z, trValName n)
    fun trTypid(E, I.Id(i,z,n))		= O.Id(trTypInfo(E,i), z, trTypName n)
    fun trVarid(E, I.Id(i,z,n))		= O.Id(trVarInfo(E,i), z, trTypName n)
    fun trInfid(E, I.Id(i,z,n))		= O.Id(trInfInfo(E,i), z, trInfName n)
    fun trModid(E, I.Id(i,z,n))		= if TranslationEnv.memberMod(E, z)
					  then raise VirtualModule
					  else O.Id(trModInfo(E,i), z,
						    trModName n)

    fun trModlongid(E, I.ShortId(i,x)) =
	O.ShortId(trModInfo(E,i), trModid(E,x))
      | trModlongid(E, I.LongId(i,y,l))	=
	O.LongId(trModInfo(E,i), trModlongid(E,y), trModlab l)

    fun trVallongid(E, I.ShortId(i,x)) =
	O.ShortId(trValInfo(E,i), trValid(E,x))
      | trVallongid(E, I.LongId(i,y,l))	=
	O.LongId(trValInfo(E,i), trModlongid(E,y), trVallab l)

    fun trTyplongid(E, I.ShortId(i,x)) =
	O.ShortId(trTypInfo(E,i), trTypid(E,x))
      | trTyplongid(E, I.LongId(i,y,l)) =
	O.LongId(trTypInfo(E,i), trModlongid(E,y), trTyplab l)

    fun trInflongid(E, I.ShortId(i,x)) =
	O.ShortId(trInfInfo(E,i), trInfid(E,x))
      | trInflongid(E, I.LongId(i,y,l))	=
	O.LongId(trInfInfo(E,i), trModlongid(E,y), trInflab l)


  (* Ids bound inside interfaces *)

    fun idToExp x' = let val i'=O.infoId x' in O.VarExp(i',O.ShortId(i',x')) end
    fun idToPat x' = O.VarPat(O.infoId x', x')
    fun longidToExp y' = O.VarExp(O.infoLongid y', y')


    fun trVirtModid(E, I.Id(i,z,n) : I.modid) =
	O.Id(typInfo(#region i, typ_inf E), z, trModName n)

    fun trVirtModlongid(E, I.ShortId(i,x)) = idToExp(trVirtModid(E, x))
      | trVirtModlongid(E, I.LongId(i,y, I.Lab(_,l)) : I.modlongid) =
	(* [y.l] = Inf.lookupMod(Inf.asSig'[y], Label.fromString "l") *)
	let
	    val r  = #region i
	    val e1 = callInf(E, lab_asSig', trVirtModlongid(E, y))
	    val e2 = trLab(E, r, l)
	in
	    callInf(E, lab_lookupMod, trTuple(r, #[e1,e2]))
	end

    fun trVirtTyplongid(E, I.ShortId(i,x)) = raise Assert.failure
      | trVirtTyplongid(E, I.LongId(i,y, I.Lab(_,l)) : I.typlongid) =
	(* [y.l] = Inf.lookupTyp'(Inf.asSig'[y], Label.fromString "l") *)
	let
	    val r  = #region i
	    val e1 = callInf(E, lab_asSig', trVirtModlongid(E, y))
	    val e2 = trLab(E, r, l)
	in
	    callInf(E, lab_lookupTyp', trTuple(r, #[e1,e2]))
	end

    fun trVirtInflongid(E, I.ShortId(i,x)) = raise Assert.failure
      | trVirtInflongid(E, I.LongId(i,y, I.Lab(_,l)) : I.inflongid) =
	(* [y.l] = Inf.lookupInf'(Inf.asSig'[y], Label.fromString "l") *)
	let
	    val r  = #region i
	    val e1 = callInf(E, lab_asSig', trVirtModlongid(E, y))
	    val e2 = trLab(E, r, l)
	in
	    callInf(E, lab_lookupInf', trTuple(r, #[e1,e2]))
	end


  (* Extract bound ids from declarations. *)

    fun idsId'(x as O.Id(_,_,Name.ExId s), xs')	= StringMap.insert(xs',s,x)
      | idsId'(x, xs')				= ()

    fun idsDecs(E, ds, xs')		= Vector.app(fn d => idsDec(E,d,xs')) ds
    and idsDec(E, I.ValDec(_,p,_), xs')	= idsPat(E,p,xs')
      | idsDec(E, I.TypDec(_,x,_), xs')	= idsId'(trTypid(E,x), xs')
      | idsDec(E, I.ModDec(_,x,_), xs')	= (idsId'(trModid(E,x), xs')
(*DEBUG*)handle VirtualModule => (Error.warn(#region(I.infoId x), Name.toString(I.name x) ^"[" ^ Stamp.toString(I.stamp x) ^ "] 10\n"); raise VirtualModule))
      | idsDec(E, I.InfDec(_,x,_), xs')	= idsId'(trInfid(E,x), xs')
      | idsDec(E, I.VarDec(_,_,d), xs')	= idsDec(E,d,xs')
      | idsDec(E, I.RecDec(_,ds), xs')	= idsDecs(E,ds,xs')
      | idsDec(E, (I.FixDec _
		  |I.LocalDec _), xs')	= ()

    and idsPats(E, ps, xs')		= Vector.app(fn p => idsPat(E,p,xs')) ps
    and idsPat(E, (I.JokPat(_)
		  |I.LitPat(_,_)), xs')	= ()
      | idsPat(E, I.VarPat(_,x), xs')	= idsId'(trValid(E,x), xs')
      | idsPat(E, (I.TagPat(_,_,_,p)
		  |I.ConPat(_,_,p)
		  |I.RefPat(_,p)
		  |I.StrictPat(_,p)
		  |I.AltPat(_,p,_)
		  |I.NegPat(_,p)
		  |I.GuardPat(_,p,_)
		  |I.AnnPat(_,p,_)),
		  xs')			= idsPat(E,p,xs')
      | idsPat(E, (I.TupPat(_,ps)
		  |I.VecPat(_,ps)),
		  xs')			= idsPats(E,ps,xs')
      | idsPat(E, I.ProdPat(_,r), xs')	= idsRow(E,r,xs')
      | idsPat(E, I.AsPat(_,p1,p2),xs')	= (idsPat(E,p1,xs') ; idsPat(E,p2,xs'))
      | idsPat(E, I.WithPat(_,p,ds),xs')= (idsPat(E,p,xs') ; idsDecs(E,ds,xs'))

    and idsRow(E, I.Row(_,fs,_), xs')	= Vector.app(fn f => idsFld(E,f,xs')) fs
    and idsFld(E, I.Fld(_,_,p),xs')	= idsPat(E,p,xs')

    fun ids(E, ds) =
	let
	    val xs' = StringMap.new()
	in
	    idsDecs(E,ds,xs');
	    Vector.fromList(StringMap.fold op:: [] xs')
	end


  (* Expressions *)

    fun trExps(E, es)			= Vector.map (fn e => trExp(E,e)) es
    and trExp(E, I.LitExp(i,l))		= O.LitExp(i, trLit l)
      | trExp(E, I.VarExp(i,y))		= (O.VarExp(i, trVallongid(E, y))
(* may happen with functor derived form...
(*DEBUG*)handle VirtualModule => (Error.warn(#region i, "15\n"); raise VirtualModule))
*))
      | trExp(E, I.PrimExp(i,s,t))	= O.PrimExp(i, s)
      | trExp(E, I.NewExp(i,t))		= O.NewExp(i)
      | trExp(E, I.TagExp(i,l,_,e))	= O.TagExp(i, trVallab l, trExp(E,e))
      | trExp(E, I.ConExp(i,y,e))	= (O.ConExp(i, trVallongid(E,y),
						   trExp(E,e))
(*DEBUG*)handle VirtualModule => (Error.warn(#region i, "16\n"); raise VirtualModule))
      | trExp(E, I.RefExp(i,e))		= O.RefExp(i, trExp(E,e))
      | trExp(E, I.StrictExp(i,e))	= O.StrictExp(i, trExp(E,e))
      | trExp(E, I.TupExp(i,es))	= O.TupExp(i, trExps(E,es))
      | trExp(E, I.ProdExp(i,r))	= O.ProdExp(i, trExpRow(E,r))
      | trExp(E, I.UpdExp(i,e,r))	= trUpdExp(i, trExp(E,e), trExpRow(E,r))
      | trExp(E, I.SelExp(i,l,e))	= O.SelExp(i, trVallab l, trExp(E,e))
      | trExp(E, I.VecExp(i,es))	= O.VecExp(i, trExps(E,es))
      | trExp(E, I.FunExp(i,ms))	= O.FunExp(i, trMats(E,ms))
      | trExp(E, I.AppExp(i,e1,e2))	= O.AppExp(i, trExp(E,e1), trExp(E,e2))
      | trExp(E, I.AndExp(i,e1,e2))	= O.AndExp(i, trExp(E,e1), trExp(E,e2))
      | trExp(E, I.OrExp(i,e1,e2))	= O.OrExp(i, trExp(E,e1), trExp(E,e2))
      | trExp(E, I.IfExp(i,e1,e2,e3))	= O.IfExp(i, trExp(E,e1), trExp(E,e2),
								  trExp(E,e3))
      | trExp(E, I.SeqExp(i,e1,e2))	= O.SeqExp(i, trExp(E,e1), trExp(E,e2))
      | trExp(E, I.CaseExp(i,e,ms))	= O.CaseExp(i, trExp(E,e), trMats(E,ms))
      | trExp(E, I.FailExp(i))		= O.FailExp(i)
      | trExp(E, I.LazyExp(i,e))	= O.LazyExp(i, trExp(E,e))
      | trExp(E, I.SpawnExp(i,e))	= O.SpawnExp(i, trExp(E,e))
      | trExp(E, I.RaiseExp(i,e))	= O.RaiseExp(i, trExp(E,e))
      | trExp(E, I.HandleExp(i,e,ms))	= O.HandleExp(i,trExp(E,e),trMats(E,ms))
      | trExp(E, I.AnnExp(i,e,t))	= trExp(E,e)
      | trExp(E, I.LetExp(i,ds,e))	= O.LetExp(i, trDecs(E,ds), trExp(E,e))
      | trExp(E, I.PackExp(i,m))	= trMod(E,m)

    and trExpRow(E, I.Row(i,fs,_))	= trExpFlds(E,fs)
    and trExpFlds(E, fs)		= Vector.map (trExpFld E) fs
    and trExpFld E (I.Fld(i,l,e))	= O.Fld(i, trVallab l, trExp(E,e))

    and trUpdExp(i,e',r') =
	(* [{ e where r}] = let val x = [e] in {[e]', [r]} *)
	let
	    val i'  = O.infoExp e'
	    val i'' = nonInfo(#region i')
	    val x'  = O.Id(i', Stamp.new(), Name.InId)
	    val d'  = O.ValDec(i'', O.VarPat(i',x'), e')
	    val r'' = trUpdExp'(Type.asProd'(#typ i'), i'', idToExp x', r',
				Vector.toList r')
	in
	    O.LetExp(i, #[d'], O.ProdExp(i, r''))
	end

    and trUpdExp'(tr,i,e',r',fs) =
	if Type.isEmptyRow tr then	(* check for unknown necessary? *)
	    Vector.fromList fs
	else let
	    val (l,t) = Type.hdRow tr
	    val  tr'  = Type.tlRow tr
	    val  fs'  = if Vector.exists (fn O.Fld(_, O.Lab(_,l'),_) => l=l') r'
			then fs else
			let val l' = O.Lab(i,l)
			    val i' = typInfo(#region i, t)
			in O.Fld(i, l', O.SelExp(i',l',e')) :: fs end
	in
	    trUpdExp'(tr',i,e',r',fs')
	end


  (* Matches and Patterns *)

    and trMats(E, ms)			= Vector.map (trMat E) ms
    and trMat E (I.Mat(i,p,e))		= O.Mat(i, trPat(E,p), trExp(E,e))

    and trPats(E, ps)			= Vector.map (fn p => trPat(E,p)) ps
    and trPat(E, I.JokPat(i))		= O.JokPat(i)
      | trPat(E, I.LitPat(i,l))		= O.LitPat(i, trLit l)
      | trPat(E, I.VarPat(i,x))		= O.VarPat(i, trValid(E,x))
      | trPat(E, I.TagPat(i,l,_,p))	= O.TagPat(i, trVallab l, trPat(E,p))
      | trPat(E, I.ConPat(i,y,p))	= (O.ConPat(i, trVallongid(E,y),
						      trPat(E,p))
(*DEBUG*)handle VirtualModule => (Error.warn(#region i, "17\n"); raise VirtualModule))
      | trPat(E, I.RefPat(i,p))		= O.RefPat(i, trPat(E,p))
      | trPat(E, I.StrictPat(i,p))	= O.StrictPat(i, trPat(E,p))
      | trPat(E, I.TupPat(i,ps))	= O.TupPat(i, trPats(E,ps))
      | trPat(E, I.ProdPat(i,r))	= O.ProdPat(i, trPatRow(E,r))
      | trPat(E, I.VecPat(i,ps))	= O.VecPat(i, trPats(E,ps))
      | trPat(E, I.AsPat(i,p1,p2))	= O.AsPat(i, trPat(E,p1), trPat(E,p2))
      | trPat(E, I.AltPat(i,p1,p2))	= O.AltPat(i, trPat(E,p1), trPat(E,p2))
      | trPat(E, I.NegPat(i,p))		= O.NegPat(i, trPat(E,p))
      | trPat(E, I.GuardPat(i,p,e))	= O.GuardPat(i, trPat(E,p), trExp(E,e))
      | trPat(E, I.AnnPat(i,p,t))	= trPat(E,p)
      | trPat(E, I.WithPat(i,p,ds))	= O.WithPat(i, trPat(E,p), trDecs(E,ds))

    and trPatRow(E, I.Row(i,fs,b))	= trPatFlds(E,fs)
    and trPatFlds(E, fs)		= Vector.map (trPatFld E) fs
    and trPatFld E (I.Fld(i,l,p))	= O.Fld(i, trVallab l, trPat(E,p))


  (* Modules *)

    and trMod(E, I.VarMod(i,y)) =
	(* [y] = [y] *)
(	O.VarExp(trModInfo(E,i), trModlongid(E,y))
(* may happen with functor derived form...
(*DEBUG*)handle VirtualModule => (Error.warn(#region i, "11\n"); raise VirtualModule))
*))
      | trMod(E, I.StrMod(i,ds)) =
	(* [struct decs end] = let [decs] in {<flds>} *)
	let
	    val i'   = trModInfo(E,i)
	    val ds'  = trDecs(E,ds)
	    val ids' = ids(E,ds)
	    val fs'  = Vector.map (idToFld idToExp) ids'
	in
	    O.LetExp(i', ds', O.ProdExp(i',fs'))
	end

      | trMod(E, I.SelMod(i,l,m)) =
	(* [m.l] = #[l]([m]) *)
	O.SelExp(trModInfo(E,i), trModlab l, trMod(E,m))

      | trMod(E, I.FunMod(i,x,j,m)) =
	(* [fun (x:j) -> m] = fun [x] -> [m] *)
	let
	    val r  = #region(I.infoId x)
	    val e' = trMod(E,m)
	    val p' = idToPat(trModid(E,x))
(*DEBUG*)handle VirtualModule => (Error.warn(r, Name.toString(I.name x) ^"[" ^ Stamp.toString(I.stamp x) ^ "] 2\n"); raise VirtualModule)
	    val m' = O.Mat(nonInfo r,p',e')
	in
	    O.FunExp(trModInfo(E,i), #[m'])
	end

      | trMod(E, I.AppMod(i,m1,m2)) =
	(* [m1 m2] = unseal (x (seal [m2 : j11])) *)
(* Does not work, because of implicit quantifier removal through subtyping...
   (typechecking of intermediate would fail)
	let
	    val i1        = I.infoMod m1
	    val i2        = I.infoMod m2
	    val t1        = infToTyp(E, #inf i1)
	    val (t11,t12) = Type.asArrow t1

	    val e1'       = trMod(E,m1)
	    val e2'       = trMod(E,m2)
	    val e3'       = O.SealExp(typInfo(#region i2,t11), e2')
	    val e'        = O.AppExp(typInfo(#region i,t12), e1', e3')
	in
	    O.UnsealExp(trModInfo(E,i), e')
	end
*)
	let
	    val i1        = I.infoMod m1
	    val i2        = I.infoMod m2
	    val r2        = #region i2
	    val j1        = #inf i1
	    val j2        = #inf i2
	    val t1        = infToTyp(E,j1)
	    val e1'       = trMod(E,m1)

	    val (t11,t12) = Type.asArrow t1
	    val j2'       = Inf.narrow(j2, #2(Inf.asArrow' j1))
(*DEBUG*)handle e => (Error.warn(#region i, "4\n"); raise e)
	    val e2'       = trTransCoerceMod(E, r2, m2, j2')

	    val e3'       = O.SealExp(typInfo(r2,t11), e2')
	    val e'        = O.AppExp(typInfo(#region i,t12), e1', e3')
	in
	    O.UnsealExp(trModInfo(E,i), e')
	end

      | trMod(E, I.AnnMod(i,m,j)) =
	(* [m : j] = let x1 = [m] in [x1 : j1 :> x2 = j2] *)
	trTransCoerceMod(E,#region i,m,#inf i)

      | trMod(E, I.SealMod(i,m,j)) =
	(* [m :> j] = let x1 = [m]; x2 = [j] in seal [x1 : j1 :> x2 = j2] *)
	trOpaqCoerceMod(E,i,m,j)

      | trMod(E, I.LetMod(i,ds,m)) =
	(* [let decs in m] = let [decs] in [m] *)
	O.LetExp(trModInfo(E,i), trDecs(E,ds), trMod(E,m))

      | trMod(E, I.UnpackMod(i,e,j)) =
	(* [unpack e : j] = e *)
	trExp(E,e)

      | trMod(E, I.PrimMod(i,"ByNeed",j)) =
	(* [prim "ByNeed" : (interface I; module F : any -> I) -> I]
	 * = fun {[I]=_, [F]=x} -> lazy x()
	 *)
	(let
	    val  i'      = trModInfo(E,i)
	    val  r       = #region i'
	    val  i0'     = nonInfo r
	    val  t       = #typ i'
	    val (t1,t2)  = Type.asArrow t
	    val (l1,t11) = findFld(isModName, Type.asProd t1)
	    val (l2,t12) = findFld(isInfName, Type.asProd t1)
	    val  x'      = O.Id(typInfo(r,t11), Stamp.new(), Name.InId)
	    val  p'      = O.ProdPat(typInfo(r,t1),
				#[O.Fld(i0', O.Lab(i0',l2),
					O.JokPat(typInfo(r,t12))),
				  O.Fld(i0', O.Lab(i0',l1), idToPat x')])
	    val  e'      = trLazy(O.AppExp(typInfo(r,t2), idToExp x', trUnit r))
	in
	    O.FunExp(i', #[O.Mat(nonInfo r, p', e')])
	end
	handle Type.Type => raise Crash.Crash "trPrimMod: ByNeed")

      | trMod(E, I.PrimMod(i,"Reflect",j)) =
	(* [prim "Reflect" : (interface I; module X : I) -> (x : Value.t)]
	 * = fun {[X]=x1,...} -> {[x]=x1}
	 *)
	(let
	    val  i'      = trModInfo(E,i)
	    val  r       = #region i'
	    val  i0'     = nonInfo r
	    val  t       = #typ i'
	    val (t1,t2)  = Type.asArrow t
	    val (l1,t11) = findFld(isModName, Type.asProd t1)
	    val (l2,t21) = findFld(isValName, Type.asProd t2)
	    val  x1'     = O.Id(typInfo(r,t11), Stamp.new(), Name.InId)
	    val  p'      = O.ProdPat(typInfo(r,t1),
				     #[O.Fld(i0',O.Lab(i0',l1), idToPat x1')])
	    val  e'      = O.ProdExp(typInfo(r,t2),
				     #[O.Fld(i0',O.Lab(i0',l2), idToExp x1')])
	in
	    O.FunExp(i', #[O.Mat(nonInfo r, p', e')])
	end
	handle Type.Type => raise Crash.Crash "trPrimMod: Reflect")

      | trMod(E, I.PrimMod(i,"Unreflect",j)) =
	(* [prim "Unreflect" : (x : Value.t; interface I) -> I]
	 * = fun {[x]=x1, [I]=x2} -> x1
	 *)
	(let
	    val  i'      = trModInfo(E,i)
	    val  r       = #region i'
	    val  i0'     = nonInfo r
	    val  t       = #typ i'
	    val (t1,t2)  = Type.asArrow t
	    val (l1,t11) = findFld(isValName, Type.asProd t1)
	    val (l2,t21) = findFld(isInfName, Type.asProd t2)
	    val  x1'     = O.Id(typInfo(r,t11), Stamp.new(), Name.InId)
	    val  x2'     = O.Id(typInfo(r,t21), Stamp.new(), Name.InId)
	    val  p'      = O.ProdPat(typInfo(r,t1),
				#[O.Fld(i0', O.Lab(i0',l1), idToPat x1'),
				  O.Fld(i0', O.Lab(i0',l2), idToPat x2')])
	    val  e'      = idToExp x1'
	in
	    O.FunExp(i', #[O.Mat(nonInfo r, p', e')])
	end
	handle Type.Type => raise Crash.Crash "trPrimMod: Reflect")

      | trMod(E, I.PrimMod(i,"ReflectSig",j)) =
	(* [prim "ReflectSig" : (interface I) -> (x : Inf.t)]
	 * = fun {[I]=x1} -> {[x]=x1}
	 *)
	(let
	    val  i'      = trModInfo(E,i)
	    val  r       = #region i'
	    val  i0'     = nonInfo r
	    val  t       = #typ i'
	    val (t1,t2)  = Type.asArrow t
	    val (l1,t11) = findFld(isInfName, Type.asProd t1)
	    val (l2,t21) = findFld(isValName, Type.asProd t2)
	    val  x1'     = O.Id(typInfo(r,t11), Stamp.new(), Name.InId)
	    val  p'      = O.ProdPat(typInfo(r,t1),
				     #[O.Fld(i0',O.Lab(i0',l1), idToPat x1')])
	    val  e'      = O.ProdExp(typInfo(r,t2),
				     #[O.Fld(i0',O.Lab(i0',l2), idToExp x1')])
	in
	    O.FunExp(i', #[O.Mat(nonInfo r, p', e')])
	end
	handle Type.Type => raise Crash.Crash "trPrimMod: Reflect")

      | trMod(E, I.PrimMod(i,"UnreflectSig",j)) =
	(* [prim "UnreflectSig" : (x : Inf.t) -> (interface I)]
	 * = fun {[x]=x1} -> {[I]=x1}
	 *)
	(let
	    val  i'      = trModInfo(E,i)
	    val  r       = #region i'
	    val  i0'     = nonInfo r
	    val  t       = #typ i'
	    val (t1,t2)  = Type.asArrow t
	    val (l1,t11) = findFld(isInfName, Type.asProd t1)
	    val (l2,t21) = findFld(isValName, Type.asProd t2)
	    val  x1'     = O.Id(typInfo(r,t11), Stamp.new(), Name.InId)
	    val  p'      = O.ProdPat(typInfo(r,t1),
				     #[O.Fld(i0',O.Lab(i0',l1), idToPat x1')])
	    val  e'      = O.ProdExp(typInfo(r,t2),
				     #[O.Fld(i0',O.Lab(i0',l2), idToExp x1')])
	in
	    O.FunExp(i', #[O.Mat(nonInfo r, p', e')])
	end
	handle Type.Type => raise Crash.Crash "trPrimMod: Reflect")

      | trMod(E, I.PrimMod(i,"Pack",j)) =
	(* [prim "Pack" : (interface I; module X : I) -> (x : package)]
	 * = fun {[X]=x1,[I]=x2} ->
	 *   let (x3,_) = Inf.instance(Path.invent(), x2) in
	 *   {[x'] = seal (CoerceOpaq (???,x3) x1, x3)}
	 *)
	(*UNFINISHED: sealing of RTTs*)
	(let
	    val  i'      = trModInfo(E,i)
	    val  r       = #region i'
	    val  i0'     = nonInfo r
	    val  t       = #typ i'
	    val (t1,t2)  = Type.asArrow t
	    val (l1,t11) = findFld(isModName, Type.asProd t1)
	    val (l2,t12) = findFld(isInfName, Type.asProd t1)
	    val (l3,t21) = findFld(isValName, Type.asProd t2)
	    val  x1'     = O.Id(typInfo(r,t11), Stamp.new(), Name.InId)
	    val  x2'     = O.Id(typInfo(r,t12), Stamp.new(), Name.InId)
	    val  p'      = O.ProdPat(typInfo(r,t1),
				#[O.Fld(i0', O.Lab(i0',l1), idToPat x1'),
				  O.Fld(i0', O.Lab(i0',l2), idToPat x2')])
	in
	    if not(!Switches.Language.supportRtt) then
		let
		    val  e1' = O.SealExp(typInfo(r,t21), 
				O.TupExp(typInfo(r,Type.tuple #[t11,t12]),
					 #[idToExp x1', idToExp x2']))
		    val  e'  = O.ProdExp(typInfo(r,t2),
				#[O.Fld(i0', O.Lab(i0',l3), e1')])
		in
		    O.FunExp(i', #[O.Mat(nonInfo r, p', e')])
		end
	    else
		let
		    val  x3' = O.Id(typInfo(r,t12), Stamp.new(), Name.InId)
		    val  d'  = O.ValDec(nonInfo r,
				O.TupPat(typInfo(r, Type.tuple #[typ_inf E,
								 typ_rea E]),
					 #[idToPat x3',
					   O.JokPat(typInfo(r, typ_rea E))]),
				callInf(E, lab_instance,
				   trTuple(r, #[trPath'(E, r), idToExp x2'])))
		    val  e1' = O.SealExp(typInfo(r,t21), 
				O.TupExp(typInfo(r,Type.tuple #[t11,t12]),
					 #[idToExp x1', idToExp x3']))
		    val  i2  = typInfo(r,t2)
		    val  e2' = O.ProdExp(i2, #[O.Fld(i0', O.Lab(i0',l3), e1')])
		    val  e'  = O.LetExp(i2, #[d'], e2')
		in
		    O.FunExp(i', #[O.Mat(nonInfo r, p', e')])
		end
	end
	handle Type.Type => raise Crash.Crash "trPrimMod: Pack")

      | trMod(E, I.PrimMod(i,"Unpack",j)) =
	(* [prim "Unpack" : (x : package; interface I) -> I]
	 * = fn {[x]=x1,[S]=x2} ->
	 *   let (x11,x12) = unseal x1 in
	 *   Inf.match(x12,x2);
	 *   x11
	 *)
	(let
	    val  i'      = trModInfo(E,i)
	    val  r       = #region i'
	    val  i0'     = nonInfo r
	    val  t       = #typ i'
	    val (t1,t2)  = Type.asArrow t
	    val (l1,t11) = findFld(isValName, Type.asProd t1)
	    val (l2,t12) = findFld(isInfName, Type.asProd t1)
	    val  x1'     = O.Id(typInfo(r,t11), Stamp.new(), Name.InId)
	    val  x2'     = O.Id(typInfo(r,t12), Stamp.new(), Name.InId)
	    val  p'      = O.ProdPat(typInfo(r,t1),
				#[O.Fld(i0', O.Lab(i0',l1), idToPat x1'),
				  O.Fld(i0', O.Lab(i0',l2), idToPat x2')])

	    val  i1'     = typInfo(r, Type.tuple #[t2, typ_inf E])
	    val  i2'     = typInfo(r, t2)
	    val  x11'    = O.Id(i2', Stamp.new(), Name.InId)
	    val  x12'    = O.Id(typInfo(r, typ_inf E), Stamp.new(), Name.InId)
	    val  p1'     = O.TupPat(i1', #[idToPat x11', idToPat x12'])
	    val  e1'     = O.UnsealExp(i1', idToExp x1')
	    val  d'      = O.ValDec(nonInfo r, p1', e1')
	in
	    if not(!Switches.Language.supportRtt) then
		let

		    val  e1' = idToExp x11'
		    val  e'  = O.LetExp(i2', #[d'], e1')
		in
		    O.FunExp(i', #[O.Mat(nonInfo r, p', e')])
		end
	    else
		let
		    val  e1'  = callInf(E, lab_match,
				  trTuple(r, #[idToExp x12', idToExp x2']))
		    val  e2'  = idToExp x11'
		    val  e'   = O.LetExp(i2', #[d'], O.SeqExp(i2', e1', e2'))
		in
		    O.FunExp(i', #[O.Mat(nonInfo r, p', e')])
		end
	end
	handle Type.Type => raise Crash.Crash "trPrimMod: Unpack")

      | trMod(E, I.PrimMod(i,s,j)) =
	(* [prim s : j] = prim s *)
	O.PrimExp(trModInfo(E,i), s)


    and findFld(isXName, r) =
	let
	    val (l,t) = Type.hdRow r handle Type.Row =>
			raise Crash.Crash "TranslationPhase.findFld"
	in
	    if isXName(Label.toName l) then
		(l,t)
	    else
		findFld(isXName, Type.tlRow r)
	end


  (* Signature coercions *)

    (*
     * We use the following transformation rules:
     *
     *	[x1 : j1 :> x2 = any] = fail
     *	[x1 : j1 :> x2 = c] = ...
     *	[x1 : sig item1* end :> x2 = sig item2* end] =
     *	   let x2' = Inf.asSig x2 in struct [x1 . item1 :> x2' . item2]* end
     *	[x1 : fct(x11:j11)->j12 :> x2 = fct(x21:j21)->j22] =
     *	   fct(y:j21) => let z = x1(seal [y : j21 :> _ = j11])
     *                       x3 = x2 y
     *                   in unseal [z : j12 :> x3 = j22]
     *  [x1 : (x1':j1) :> x2 = j2] = [x1 : j1 :> x2 = j2]
     *  [x1 : j1 :> x2 = (x2':j2)] = [x1 : j1 :> x2 = j2]
     *
     *	[x1 . val y:t1 :> x2 . val y:t2] = val y = x1.y
     *	[x1 . constructor y:t1 :> x2 . val y:t2] = val y = x1.y
     *  [x1 . type y:k1 :> x2 . type y:k2 = t2] =
     *     type y = lazy Inf.lookupTyp(x2,"y")
     *	[x1 . structure y:j1 :> x2 . structure y:j2] =
     *	   structure y = [x1.y : j1 :> x2.y = j2]
     *  [x1 . interface y:k1 :> x2 . interface y:k2 = j2] =
     *     interface y = lazy Inf.lookupInf(x2,"y")
     *
     * Here in [x1 : j1 :> x2 = j2] the structure is bound to x1 and has
     * signature j1, while the runtime representation of interface j2 is
     * bound to x2.
     *
     * Note that the contravariant coercion of a functor argument is always
     * transparent and so no interface representation is needed. We can thus
     * pass whatever we want for x2, it remains unused.
     *
     * Moreover, we apply the optimization that - if the transformation is the
     * identity function - the coercion is a no-op.
     *)

    and trTransCoerceMod(E,r,m,j2) =
	(* [m : j] = let val x1 = [m]
	 *           in [x1 : j1 :> _ = j2]
	 *)
	let
	    val i0  = nonInfo r
	    val e1' = trMod(E,m)
	    val i1  = O.infoExp e1'
	    val x1' = O.Id(i1, Stamp.new(), Name.InId)
	    val x1  = O.ShortId(i1, x1')
	    val j1  = #inf(I.infoMod m)
	in
	    case coerceMod(E, r, x1,j1,NONE,j2,j2, false)
	      of NONE    => e1'
	       | SOME e' =>
		 let
		     val d' = O.ValDec(i0, O.VarPat(i1,x1'), e1')
		 in
		     O.LetExp(typInfo(r, #typ(O.infoExp e')), #[d'], e')
		 end
	end

    and trOpaqCoerceMod(E,i,m,j) =
	(* [m :> j] = let val x1 = [m]
	 *                val x2 = lazy [j]
	 *            in seal [x1 : j1 :> x2 = j2]
	 *)
	if not(!Switches.Language.supportRtt) then
	    let
		val j1  = #inf(I.infoMod m)
		val j2  = #inf i
		val j2' = Inf.narrow(j1,j2)
(*DEBUG*)handle e as Inf.Mismatch _ => (Error.warn(#region i,"match5\n");raise e)
	    in
		O.SealExp(trModInfo(E,i), trTransCoerceMod(E, #region i, m,j2'))
	    end
	else let
	    val r   = #region i
	    val i0  = nonInfo r
	    val i'  = trModInfo(E,i)

	    val e1' = trMod(E,m)
	    val i1  = O.infoExp e1'
	    val x1' = O.Id(i1, Stamp.new(), Name.InId)
	    val x1  = O.ShortId(i1, x1')
	    val j1  = #inf(I.infoMod m)

	    val e2' = trInf(E,j)
	    val i2  = typInfo(r, typ_inf E)
	    val x2' = O.Id(i2, Stamp.new(), Name.InId)
	    val x2  = O.ShortId(i2, x2')
	    val j2  = #inf i
	    val j2' = Inf.narrow(j1,j2)
(*DEBUG*)handle e as Inf.Mismatch _ => (Error.warn(r,"match1\n");raise e)
	in
	    case coerceMod(E, r, x1,j1,SOME x2,j2,j2', false)
	      of NONE    => O.SealExp(i', e1')
	       | SOME e' =>
		 let
		     val d1' = O.ValDec(i0, O.VarPat(i1,x1'), e1')
		     val d2' = O.ValDec(i0, O.VarPat(i2,x2'), trLazy e2')
		 in
		     O.LetExp(i', #[d1',d2'], O.SealExp(i', e'))
		 end
	end

    and coerceMod(E, r, x1,j1,x2o,j2,j2', isntIdentity) =
	(* [x1 : j1 :> x2 = j2]
	 * Generates a coercion for the module bound to x1 at runtime, which
	 * has interface j1, to interface j2, which is bound to x2 at runtime.
	 * j2' is the transparent (matched) version of j2, ie. the result of
	 * Inf.match(j1,j2). x2 may be absent (indicated by _ in the rules
	 * below) if we are doing a transparent coercion.
	 *)
	if Inf.isTop' j2 then
	    (* [x1 : j1 :> x2 = any] = () *)
	    if Inf.isTop' j1 then
		NONE
	    else
		SOME(trUnit r)
	else if Inf.isCon' j2 then
	    if Option.isNone x2o then
	    (* [x1 : p1 :> _ = p2] = () *)
		(*UNFINISHED: this should not be...*)
		(* Note: If we match transparently and have two constructors
		 * then they are necessarily the same at runtime.
		 * However, it is not necessarily the case during translation
		 * because we do transparent coercions for functor sig arguments
		 * even in the opaque case, so that no proper substitution has
		 * been performed to equalize them. Example:
		 *   fct(signature S) -> ()  :>  fct(signature S) -> ()
		 * So we cannot put in an assertion here!
		(*ASSERT assert Path.equal(#2 j1, #2 j2) => *)
		if not(Path.equal(#2(Inf.asCon' j1), #2(Inf.asCon' j2')))
		then raise Assert.failure else
		 *)
		NONE
	    else
	    (* [x1 : j1 :> x2 = p] = ???? *)
	    (*UNFINISHED: do runtime sealing (__perv.Coerce.Opaque?) *)
		NONE
	else if Inf.isSig' j2 andalso Inf.isSig' j1 then
	    (* [x1 : sig item1* end :> x2 = sig item2* end] =
	     *     let x3 = lazy Inf.asSig x2 in
	     *     struct [x1 . item1 :> x3 . item2]* end
	     * [x1 : sig item1* end :> _ = sig item2* end] =
	     *     struct [x1 . item1 :> _ . item2]* end
	     *)
	    let
		val s1  = Inf.asSig' j1
		val s2  = Inf.asSig' j2
		val s2' = Inf.asSig' j2'
		val i3  = typInfo(r, typ_sig E)
		val x3' = O.Id(i3, Stamp.new(), Name.InId)
		val x3o = Option.map (fn _ => O.ShortId(i3, x3')) x2o
		val (isntIdentity',flds,row) =
		    coerceStr(E, r, x1,s1, x3o, List.rev(Inf.items s2), s2',
			      isntIdentity, [], Type.unknownRow())
	    in
		if isntIdentity'
		orelse List.length(Inf.items s1)<>List.length(Inf.items s2) then
		    let
			val e = O.ProdExp(typInfo(r,Type.prod row), flds)
		    in
			SOME(
			    case x2o of NONE => e | SOME x2 =>
			    let
				val e1 = callInf(E, lab_asSig,
						O.VarExp(O.infoLongid x2, x2))
				val e2 = trLazy e1
				val d1 = O.ValDec(nonInfo r, idToPat x3', e2)
			    in
				O.LetExp(O.infoExp e, #[d1], e)
			    end)
		    end
		else
		    NONE
	    end
	else if Inf.isArrow' j2 andalso Inf.isArrow' j1 then
	    (* [x1 : fct(x11:j11)->j12 :> x2 = fct(x21:j21)->j22] =
	     *     fct(x3:j21) =>
	     *        let x4 = (unseal x1)(seal [x3 : j21 :> _ = j11])
	     *            x5 = Inf.realise([rea x3 : j22] (*UNFINISHED*), j22)
	     *        in unseal [x4 : j12 :> x5 = j22]
	     * [x1 : fct(x11:j11)->j12 :> _ = fct(x21:j21)->j22] =
	     *     fct(x3:j21) =>
	     *        let x4 = (unseal x1)(seal [x3 : j21 :> _ = j11])
	     *        in unseal [x4 : j12 :> _ = j22]
	     *)
	    let
		val (p1,j11,j12)  = Inf.asArrow' j1
		val (p2,j21,j22)  = Inf.asArrow' j2
		val (_,j21',j22') = Inf.asArrow' j2'

		val  rea          = Inf.match(j21',j11)
(*DEBUG*)handle e as Inf.Mismatch _ => (Error.warn(r,"match2\n");raise e)
		val  j11'         = Inf.narrow(j21',j11)
		val  _            = PathMap.insert(#mod_rea rea, p1,
						   Inf.mod(p2,j11'))
		val  j12'         = Inf.realise(rea, j12)
		val  j22'         = Inf.narrow(j12',j22')
(*DEBUG*)handle e as Inf.Mismatch _ => (Error.warn(r,"match3\n");raise e)

		val i11 = typInfo(r, infToTyp(E,j11'))
		val i12 = typInfo(r, infToTyp(E,j12'))
		val i21 = typInfo(r, infToTyp(E,j21'))
		val i22 = typInfo(r, infToTyp(E,j22'))
		val i1  = typInfo(r, Type.arrow(#typ i11, #typ i12))
		val i2  = typInfo(r, Type.arrow(#typ i21, #typ i22))
		val i'  = nonInfo r

		val i5  = typInfo(r, typ_inf E)
		val x3' = O.Id(i21, Stamp.new(), Name.InId)
		val x4' = O.Id(i12, Stamp.new(), Name.InId)
		val x5' = O.Id(i5, Stamp.new(), Name.InId)
		val x3  = O.ShortId(i21, x3')
		val x4  = O.ShortId(i12, x4')
		val x5o = Option.map (fn _ => O.ShortId(i5, x5')) x2o
		val isntIdentity' = isntIdentity orelse not(Inf.isEmptyRea rea)
	    in
		case (coerceMod(E, r, x3,j21', NONE,j11,j11', false),
		      coerceMod(E, r, x4,j12', x5o,j22',j22', isntIdentity))
		 of (NONE, NONE) =>
		     (* Optimized: unseal x1 *)
			if isntIdentity orelse not(Inf.isEmptyRea rea)
			then SOME(O.UnsealExp(i2, longidToExp x1))
			else NONE
		  | (SOME e1, NONE) =>
		     (* Optimized:
		      * unseal (unseal x1)(seal [x3 : j21 :> _ = j11]) *)
		     let
			val e3 = O.SealExp(i11, e1)
			val e4 = O.AppExp(i12,O.UnsealExp(i1,longidToExp x1),e3)
			val e  = O.UnsealExp(i22, e4)
		     in
			SOME(O.FunExp(i2, #[O.Mat(i', idToPat x3', e)]))
		     end
		  | (e1o, SOME e2) =>
		    let
			val e3 = case e1o of SOME e1 => O.SealExp(i11, e1)
					   | NONE => O.SealExp(i11, idToExp x3')
			val e4 = O.AppExp(i12,O.UnsealExp(i1,longidToExp x1),e3)
			val e6 = O.UnsealExp(i22, e2)
			val d1 = O.ValDec(i', idToPat x4', e4)
			val ds = case x2o of NONE => #[d1] | SOME x2 =>
				 let
				     val e51 = callInf(E, lab_asArrow,
						       longidToExp x2)
				     val l   = Label.fromInt 3
				     val e52 = O.SelExp(typInfo(r, typ_inf E),
							O.Lab(i',l), e51)
				     val e5  = trLazy e52
				     (*UNFINISHED: realise *)
				     val d2  = O.ValDec(i', idToPat x5', e5)
				 in
				     #[d1,d2]
				 end
			val e  = O.LetExp(O.infoExp e6, ds, e6)
		    in
			SOME(O.FunExp(i2, #[O.Mat(i', idToPat x3', e)]))
		    end
	    end
	else
	    raise Assert.failure

    and coerceStr(E, r, x1,s1, x2o,[],s2', isntIdentity, flds, row) =
	    (isntIdentity, Vector.fromList flds, row)
      | coerceStr(E, r, x1,s1, x2o,item::items,s2', isntIdentity, flds, row) =
	(* [x1 . item1 :> x2 . item2]
	 * Generates a coercion for the field item1 of the structure bound to
	 * x1 at runtime, to the form item2 as found in the interface s2, which
	 * is bound to x2 at runtime.
	 * s2' is the transparent (matched) version of s2, ie. the result of
	 * Inf.match(s1,s2). x2 may be absent (indicated by _ in the rules
	 * below) if we are doing a transparent coercion.
	 *)
	if Inf.isValItem item then
	    (* [x1 . val y:t1 :> x2 . val y:t2] = val y = x1.y
	     *)
	    let
		val (l,_)  = Inf.asValItem item
		val  t1    = Inf.lookupVal(s1,l)
		val  t2    = Inf.lookupVal(s2',l)
		val  i'    = nonInfo r
		val  l'    = trValLabel l
		val  ll'   = O.Lab(i',l')
		val  y1    = O.LongId(typInfo(r,t1), x1, ll')
		val  exp   = O.VarExp(typInfo(r,t2), y1)
		val isntIdentity' = isntIdentity orelse not(Type.equal(t1,t2))
	    in
		coerceStr(E, r, x1,s1, x2o,items,s2', isntIdentity',
			  O.Fld(i',ll',exp)::flds, Type.extendRow(l',t2,row))
	    end
	else if Inf.isTypItem item then
	    (* [x1 . type y:k1 :> x2 . type y:k2 = t2] =
	     *     type y = lazy Inf.lookupTyp'(x2, Label.fromString "y")
	     * [x1 . type y:k1 :> _ . type y:k2 = t2] =
	     *     type y = x1.y
	     *)
	    let
		val (p,k) = Inf.asTypItem item
		val  l    = Path.toLab p
		val  i'   = nonInfo r
		val  t'   = typ_typ E
		val  i    = typInfo(r,t')
		val  l'   = trTypLabel l
		val  ll'  = O.Lab(i',l')
		val (isntIdentity',exp) =
		    case x2o of NONE =>
			let
			    val y  = O.LongId(i, x1, ll')
			    val e  = O.VarExp(O.infoLongid y, y)
			in
			    (isntIdentity, e)
			end
		    | SOME x2 =>
			let
			    val e1 = O.VarExp(O.infoLongid x2, x2)
			    val e2 = trLab(E, r, l)
			    val e3 = trTuple(r, #[e1,e2])
			    val e  = trLazy(callInf(E, lab_lookupTyp', e3))
			in
			    (true, e)
			end
	    in
		coerceStr(E, r, x1,s1, x2o,items,s2', isntIdentity',
			  O.Fld(i',ll',exp)::flds, Type.extendRow(l',t',row))
	    end
	else if Inf.isModItem item then
	    (*	[x1 . structure y:j1 :> x2 . structure y:j2] =
	     *	   structure y =
	     *         let x3 = lazy Inf.lookupMod(x2, Label.fromString "y")
	     *         in [x1.y : j1 :> x3 = j2]
	     *	[x1 . structure y:j1 :> _ . structure y:j2] =
	     *	   structure y = [x1.y : j1 :> _ = j2]
	     *)
	    let
		val (p,j2)    = Inf.asModItem item
		val    l      = Path.toLab p
		val    j1     = Inf.lookupMod(s1,l)
		val    j2'    = Inf.lookupMod(s2',l)
		val    t1     = infToTyp(E,j1)
		val    i1     = typInfo(r,t1)
		val    i'     = nonInfo r
		val    l'     = trModLabel l
		val    ll'    = O.Lab(i', l')
		val    y1     = O.LongId(i1,x1,ll')
		val (x3o,mkE) = case x2o of NONE => (NONE, fn e=>e) | SOME x2 =>
				let
				    val i3 = typInfo(r, typ_inf E)
				    val x3 = O.Id(i3, Stamp.new(), Name.InId)
				in
				   (SOME(O.ShortId(i3,x3)),
				    fn e0 =>
				    let
					val e1 = O.VarExp(O.infoLongid x2, x2)
					val e2 = trLab(E, r, l)
					val e3 = trTuple(r, #[e1,e2])
					val e  = trLazy(
						  callInf(E, lab_lookupMod, e3))
					val d  = O.ValDec(i', idToPat x3, e)
				    in
					O.LetExp(O.infoExp e0, #[d], e0)
				    end)
				end
		val (isntIdentity',exp) =
		    case coerceMod(E, r, y1,j1, x3o,j2,j2', isntIdentity)
		      of NONE     => (isntIdentity, O.VarExp(i1,y1))
		       | SOME exp => (true, mkE exp)
		val t' = #typ(O.infoExp exp)
	    in
		coerceStr(E, r, x1,s1, x2o,items,s2', isntIdentity',
			  O.Fld(i',ll',exp)::flds, Type.extendRow(l',t',row))
	    end
	else if Inf.isInfItem item then
	    (*  [x1 . interface y:k1 :> x2 . interface y:k2 = j2] =
	     *     interface y = lazy Inf.lookupInf'(x2, Label.fromString "y")
	     *  [x1 . interface y:k1 :> _ . interface y:k2 = j2] =
	     *     interface y = x1.y
	     *)
	    let
		val (p,k) = Inf.asInfItem item
		val  l    = Path.toLab p
		val  i'   = nonInfo r
		val  t'   = typ_inf E
		val  i    = typInfo(r,t')
		val  l'   = trInfLabel l
		val  ll'  = O.Lab(i',l')
		val (isntIdentity',exp) =
		    case x2o of NONE =>
			let
			    val y  = O.LongId(i, x1, ll')
			    val e  = O.VarExp(O.infoLongid y, y)
			in
			    (isntIdentity, e)
			end
		    | SOME x2 =>
			let
			    val e1 = O.VarExp(O.infoLongid x2, x2)
			    val e2 = trLab(E, r, l)
			    val e3 = trTuple(r, #[e1,e2])
			    val e  = trLazy(callInf(E, lab_lookupInf', e3))
			in
			    (true, e)
			end
	    in
		coerceStr(E, r, x1,s1, x2o,items,s2', isntIdentity',
			  O.Fld(i',ll',exp)::flds, Type.extendRow(l',t',row))
	    end
	else (* fixity *)
	    coerceStr(E, r, x1,s1, x2o,items,s2', isntIdentity, flds, row)



  (* Types *)

    (* The code generated to produce runtime types and interfaces very much
     * mirrors what happens in the elaborator. However, most of it is lazy.
     *)

    and trTyp(E, t) =
	if not(!Switches.Language.supportRtt) then
	    O.FailExp(trTypInfo(E, I.infoTyp t))
	else
	    trTyp'(E, t)

    and trTyp'(E, I.JokTyp _) =
	raise Crash.Crash "TranslationPhase.trTyp: JokTyp"

      | trTyp'(E, I.VarTyp(i, I.Id(_,z,n))) =
	(* [a] = Type.var{[a]} *)
	let
	    val x' = O.Id(typInfo(#region i, typ_var E), z, trTypName n)
	in
	    callTyp(E, lab_var, idToExp x')
	end

      | trTyp'(E, I.PrimTyp(i,s)) =
	(* [prim s] = PervasiveType.lookup s *)
	callPervType(E, lab_lookup, trString(#region i, s))

      | trTyp'(E, I.ConTyp(i,y)) =
	(* [y] = $y *)
	(let
	    val y' = trTyplongid(E,y)
	in
	    O.VarExp(O.infoLongid y', y')
	end
	handle VirtualModule => trVirtTyplongid(E,y))

      | trTyp'(E, I.FunTyp(i,x,t)) =
	(* [fn x => t] = let val $x = Type.newVar <<kind x>>
	 *               in Type.lambda($x,[t]) end
	 *)
	trBindTyp(E, lab_lambda, i, x, t,
		  #1(Type.asArrowKind(Type.kind(#typ i))))

      | trTyp'(E, I.AppTyp(i,t1,t2)) =
	(* [t1 t2] = Type.apply([t1],[t2]) *)
	let
	    val e1' = trTyp'(E,t1)
	    val e2' = trTyp'(E,t2)
	in
	    callTyp(E, lab_apply, trTuple(#region i, #[e1',e2']))
	end

      | trTyp'(E, I.TupTyp(i,ts)) =
	(* [(t1,...,tn)] = Type.tuple #[t1,...,tn] *)
	let
	    val es' = Vector.map (fn t => trTyp'(E,t)) ts
	in
	    callTyp(E, lab_tuple, trVector(#region i, typ_typ E, es'))
	end

      | trTyp'(E, I.ProdTyp(i,r)) =
	(* [{r}] = Type.prod[r] *)
	callTyp(E, lab_prod, trTypRow(E,r))

      | trTyp'(E, I.SumTyp(i,r)) =
	(* [<r>] = Type.sum[r] *)
	callTyp(E, lab_sum, trTypRow(E,r))

      | trTyp'(E, I.ArrTyp(i,t1,t2)) =
	(* [t1 -> t2] = Type.arrow([t1],[t2]) *)
	let
	    val e1' = trTyp'(E,t1)
	    val e2' = trTyp'(E,t2)
	in
	    callTyp(E, lab_arrow, trTuple(#region i, #[e1',e2']))
	end

      | trTyp'(E, I.AllTyp(i,x,t)) =
	(* [forall x => t] = let val $x = Type.newVar <<kind x>>
	 *                   in Type.all($x,[t]) end
	 *)
	trBindTyp(E, lab_all, i,x,t, Type.kindVar(#1(Type.asAll(#typ i))))

      | trTyp'(E, I.ExTyp(i,x,t)) =
	(* [exists x => t] = let val $x = Type.newVar <<kind x>>
	 *                   in Type.exists($x,[t]) end
	 *)
	trBindTyp(E,lab_exist, i,x,t, Type.kindVar(#1(Type.asExist(#typ i))))

      | trTyp'(E, I.PackTyp(i,j)) =
	(* [pack j] = Type.pack[j] *)
	(*UNFINISHED*)
	unfinished (#region i) "trTyp" "runtime package types"

      | trTyp'(E, I.SingTyp(i,y)) =
	(* [sing y] = Type.sing[y] *)
	(*UNFINISHED*)
	unfinished (#region i) "trTyp" "runtime singleton types"

      | trTyp'(E, I.AbsTyp(i, isExtensible)) =
	raise Crash.Crash "TranslationPhase.trTyp: AbsTyp"

    and trTypRep(E, x, t) =
	if not(!Switches.Language.supportRtt) then
	    O.FailExp(trTypInfo(E, I.infoTyp t))
	else
	    let
		val r  = #region(I.infoId x)
		val p' = trPath(E, r, I.name x)
	    in
		case trTypRep'(E,p',t)
		  of NONE    => trTyp'(E,t)
		   | SOME e' => e'
	    end

    and trTypRep'(E, p', I.FunTyp(i,x,t)) = trTypRep'(E, p', t)

      | trTypRep'(E, p', I.AbsTyp(i, isExtensible)) =
	(* [abstract]_p = Type.con(p, <<kind>>) *)
	let
	    val r   = #region i
	    val e1' = trKind(E, r, Type.kind(#typ i))
	in
	    SOME(callTyp(E, lab_con, trTuple(r, #[p',e1'])))
	end

      | trTypRep'(E, p', t) = NONE

    and trTypRow(E, I.Row(i,fs,b)) =
	(* [f1,...,fn]     = [f1](...[fn](Type.emptyRow())...)
	 * [f1,...,fn,...] = [f1](...[fn](Type.unknownRow())...) *)
	let
	    val a  = if b then lab_unknownRow else lab_emptyRow
	    val e' = callTyp(E, a, trUnit(#region i))
	in
	    Vector.foldl (trTypFld E) e' fs
	end

    and trTypFld E (I.Fld(i1, I.Lab(i2,l), t), e3') =
	(* [a:t]_e3 = Type.extendRow(Label.fromString "a", [t], e3) *)
	let
	    val r   = #region i1
	    val e1' = trLab(E, #region i2, l)
	    val e2' = trTyp'(E,t)
	in
	    callTyp(E, lab_extendRow, trTuple(r, #[e1',e2',e3']))
	end

    and trBindTyp(E,a,i,x,t,k) =
	let
	    val r  = #region i
	    val x' = trVarid(E,x)
	    val d' = O.ValDec(nonInfo r, idToPat x',
			      callTyp(E, lab_newVar, trKind(E,r,k)))
	    val e' = callTyp(E, a, trTuple(r, #[idToExp x', trTyp'(E,t)]))
	in
	    O.LetExp(O.infoExp e', #[d'], e')
	end


  (* Interfaces *)

    and trInf(E, j) =
	if not(!Switches.Language.supportRtt) then
	    (* [j]_E = fail *)
	    O.FailExp(trInfInfo(E, I.infoInf j))
	else
	    trInf'(E, j)

    and trInf'(E, I.TopInf(i)) =
	(* [any]_E = Inf.top() *)
	let
	    val r = #region i
	in
	    callInf(E, lab_top, trUnit r)
	end

      | trInf'(E, I.PrimInf(i,s)) =
	(* [prim s]_E = PervasiveInf.lookup s *)
	let
	    val r = #region i
	in
	    callPervInf(E, lab_lookup, trString(r, s))
	end

      | trInf'(E, I.ConInf(i,y)) =
	(* [y]_E = [y]_E *)
	(let
	    val y' = trInflongid(E,y)
	in
	    O.VarExp(O.infoLongid y', y')
	end
	handle VirtualModule => trVirtInflongid(E,y))

      | trInf'(E, I.SigInf(i,ss)) =
	(* [sig ss end]_E = let val s = Inf.emptySig()
	 *                      [ss]_E,s
	 *                  in Inf.sig s end
	 *)
	let
	    val r   = #region i
	    val i'  = typInfo(r, typ_sig E)
	    val s'  = O.Id(i', Stamp.new(), Name.InId)
	    val e0' = callInf(E, lab_emptySig, trUnit r)
	    val d'  = O.ValDec(nonInfo r, O.VarPat(i',s'), e0')
	    val ss' = trSpecs(E, idToExp s', ss)
	    val e'  = callInf(E, lab_sig, idToExp s')
	in
	    O.LetExp(typInfo(r, typ_inf E), Vector.append(#[d'], ss'), e')
	end

      | trInf'(E, I.FunInf(i,x,j1,j2)) =
	(* [fn(x:j1) => j2]_E = let val x0 = Path.invent()
	 *                          val x$ = [j1]_E
	 *                          val x2 = [j2]_E+{x}
	 *                      in Inf.lambda(x0,x$,x2) end
	 *)
	trBindInf(E, lab_lambda, i,x,j1,j2)

      | trInf'(E, I.AppInf(i,j,m)) =
	(* [j m]_E = Inf.apply([j],[m]) *)
	let
	    val r   = #region i
	    val e1' = trInf'(E,j)
	    val e2' = trInfMod(E,m)
	in
	    callInf(E, lab_apply, trTuple(r, #[e1',e2']))
	end

      | trInf'(E, I.InterInf(i,j1,j2)) =
	(* [j1 where j2]_E = Inf.infimum([j1]_E, [j2]_E)
	 *)
	let
	    val r   = #region i
	    val e1' = trInf'(E,j1)
	    val e2' = trInf'(E,j2)
	in
	    callInf(E, lab_infimum, trTuple(r, #[e1',e2']))
	end

      | trInf'(E, I.ArrInf(i,x,j1,j2)) =
	(* [fct(x:j1) -> j2]_E = let val x0 = Path.invent()
	 *                           val x$ = [j1]_E
	 *                           val x2 = [j2]_E+{x}
	 *                       in Inf.arrow(x0,x$,x2) end
	 *)
	trBindInf(E, lab_arrow, i,x,j1,j2)

      | trInf'(E, I.LetInf(i,ds,j)) =
	(* [let ds in j end]_E = let [ds] in [j]_E end *)
	let
	    val e' = trInf'(E,j)
	    val t  = #typ(O.infoExp e')
	in
	    O.LetExp(typInfo(#region i,t), trDecs(E,ds), e')
	end

      | trInf'(E, I.SingInf(i, (I.AnnMod(_,_,j) | I.SealMod(_,_,j)))) =
	(*UNFINISHED, quick hack to make it possible to bootstrap with RTTs *)
	(* [sing (m : j)]_E = [j]_E *)
	trInf'(E, j)

      | trInf'(E, I.SingInf(i,m)) =
	(* [sing m] = Inf.sing [m] *)
	let
	    val e' = trInfMod(E,m)
	in
	    callInf(E, lab_sing, e')
	end

      | trInf'(E, I.AbsInf(i)) =
	raise Crash.Crash "TranslationPhase.trInf: AbsInf"

    and trInfRep(E, x, j) =
	if not(!Switches.Language.supportRtt) then
	    O.FailExp(trInfInfo(E, I.infoInf j))
	else
	    (* [j]_E,p = [j]_E,id,p *)
	    let
		val p' = trPath(E, #region(I.infoId x), I.name x)
	    in
		case trInfRep'(E, fn k' => k', p', j)
		  of NONE    => trInf'(E, j)
		   | SOME e' => e'
	    end

    and trInfRep'(E, mkKind, p', I.FunInf(i,x,j1,j2)) =
	(* [fn(x:j1) => j2]_E,MkKind,p =
	 *       [j2]_E+{x},(fn k => MkKind <let val p  = Path.invent()
	 *                                       val x$ = [j1]_E
	 *                                   in Inf.depKind(p,x$,<k>) end>),
	 *            p
	 *)
	let
	    fun mkKind' k' =
		let
		    val r   = #region(I.infoId x)
		    val i'  = nonInfo(#region i)
		    val i1' = typInfo(r, typ_path E)
		    val p'  = O.Id(i1', Stamp.new(), Name.InId)
		    val e1' = trPath'(E, r)
		    val d1' = O.ValDec(i', O.VarPat(i1',p'), e1')

		    val x'  = trModid(E,x)
(*DEBUG*)handle VirtualModule => (Error.warn(#region i, Name.toString(I.name x) ^"[" ^ Stamp.toString(I.stamp x) ^ "] 3\n"); raise VirtualModule)
		    val i2' = typInfo(r, typ_inf E)
		    val d2' = O.ValDec(i', O.VarPat(i2',x'), trInf(E, j1))

		    val e'  = callInf(E, lab_depKind,
				      trTuple(#region i,
					      #[idToExp p', idToExp x', k']))
		in
		    mkKind(O.LetExp(O.infoExp e', #[d1',d2'], e'))
		end
	in
	    TranslationEnv.insertMod(E, I.stamp x);
	    case trInfRep'(E, mkKind', p', j2)
	      of NONE => (TranslationEnv.deleteMod(E, I.stamp x); NONE)
	       | some => some
	end

      | trInfRep'(E, mkKind, p', I.AbsInf(i)) =
	(* [abstract]_E,MkKind,p = Inf.con(p, MkKind<Inf.groundKind()>)
	 *)
	let
	    val r   = #region i
	    val e1' = mkKind(callInf(E, lab_groundKind, trUnit r))
	    val e'  = callInf(E, lab_con, trTuple(r, #[p',e1']))
	in
	    SOME e'
	end

      | trInfRep'(E, mkKind, p', j) = NONE

    and trBindInf(E, a, i,x,j1,j2) =
	(* [fct(x:j1) -> j2]_E = let val x0 = Path.invent()
	 *                           val x$ = [j1]_E
	 *                           val x2 = [j2]_E+{x}
	 *                       in Inf.a(x0,x$,x2) end
	 *)
	let
	    val r   = #region i
	    val i'  = nonInfo r
	    val i0' = typInfo(#region(I.infoId x), typ_path E)
	    val x0' = O.Id(i0', Stamp.new(), Name.InId)
	    val e0' = trPath'(E, r)
	    val d0' = O.ValDec(i', O.VarPat(i0',x0'), e0')

	    val z   = I.stamp x
	    val e1' = trInf'(E, j1)
	    val i1' = typInfo(#region(I.infoId x), typ_inf E)
	    val x'  = O.Id(i1', z, trModName(I.name x))
	    val d1' = O.ValDec(i', O.VarPat(i1',x'), e1')

	    val _   = TranslationEnv.insertMod(E, z)
	    val e2' = trInf'(E, j2)
	    val i2' = typInfo(#region(I.infoInf j2), typ_inf E)
	    val x2' = O.Id(i2', Stamp.new(), Name.InId)
	    val d2' = O.ValDec(i', O.VarPat(i2',x2'), e2')

	    val e'  = callInf(E, a,
			      trTuple(r, #[idToExp x0',idToExp x',idToExp x2']))
	in
	    O.LetExp(O.infoExp e', #[d0',d1',d2'], e')
	end

    and trInfMod(E, m) =
	(*UNFINISHED*)
	(*DEBUG*)
	let
	    val r = #region(I.infoMod m)
	    val s = case m of I.VarMod _    => "VarMod"
			    | I.PrimMod _   => "PrimMod"
			    | I.StrMod _    => "StrMod"
			    | I.SelMod _    => "SelMod"
			    | I.FunMod _    => "FunMod"
			    | I.AppMod _    => "AppMod"
			    | I.AnnMod _    => "AnnMod"
			    | I.SealMod _   => "SealMod"
			    | I.LetMod _    => "LetMod"
			    | I.UnpackMod _ => "UnpackMod"
	in
	    unfinished r "trInfMod" ("runtime singleton interfaces (" ^ s ^ ")")
	end


  (* Declarations *)

    and trDecs(E, ds)       = Vector.rev(Vector.fromList(trDecs'(E, ds, [])))
    and trDecs'(E, ds, ds') = Vector.foldl (trDec E) ds' ds

    and trDec E (I.ValDec(i,p,e), ds') =
	(* [val p = e] = val [p] = [e] *)
	(let
	    val d' = O.ValDec(i, trPat(E,p), trExp(E,e))
	in
	    d' :: ds'
	end handle VirtualModule =>
	(*UNFINISHED: ugly hack to deal with inf lets *)
	    ds'
	)

      | trDec E (I.TypDec(i,x,t), ds') =
	(* [type x = t] = val $x = lazy [t]_(Path.fromLab(Label.fromString "x"))
	 *)
	let
	    val e' = trTypRep(E, x, t)
	    val d' = O.ValDec(i, idToPat(trTypid(E,x)), trLazy e')
	in
	    d' :: ds'
	end

      | trDec E (I.ModDec(i,x,m), ds') =
	(* [module x = m] = val x$ = seal [m] *)
(	let
	    val  _      = updatePervasive(E,x)
	    val  i1     = I.infoId x
	    val (e',x') = (trMod(E,m), trModid(E,x)) handle VirtualModule =>
			  (*UNFINISHED: ugly hack to deal with inf lets *)
			  case m of I.VarMod(i,y) =>
			      (trVirtModlongid(E,y), trVirtModid(E,x))
			      before TranslationEnv.insertMod(E, I.stamp x)
			  | _ => raise VirtualModule
	    val d' = O.ValDec(i, idToPat x', O.SealExp(O.infoId x', e'))
	in
	    updatePervasive'(E,x);
	    d' :: ds'
	end
(*DEBUG*)handle VirtualModule => (Error.warn(#region(I.infoId x), Name.toString(I.name x) ^"[" ^ Stamp.toString(I.stamp x) ^ "] 4\n"); raise VirtualModule))

      | trDec E (I.InfDec(i,x,j), ds') =
	(* [interface x = j] =
	 *       val $x = lazy [j]_(Path.fromLab(Label.fromString "x"))
	 *)
	let
	    val e' = trInfRep(E,x,j)
	    val d' = O.ValDec(i, idToPat(trInfid(E,x)), trLazy e')
	in
	    d' :: ds'
	end

      | trDec E (I.RecDec(i,ds), ds') =
	(* [rec ds] = [ds]'
	 *            val x = lazy Type.fix #[[ds]'']
	 *            val x1 = lazy case x of () -> x1'
	 *            ...
	 *            val xn = lazy case x of () -> xn'
	 *            rec [ds]
	 *)
	let
	    val r    = #region i
	    val map  = StampMap.new()
	    val _    = freshTypids (E,map) ds
	    val ds1' = trLHSRecDecs'(E,map, ds, ds')
	    val d3'  = O.RecDec(i, trRecDecs(E,ds))
	in
	    if List.null ds1' orelse not(!Switches.Language.supportRtt) then
		d3' :: ds1'
	    else let
		val es'  = Vector.fromList(trRHSRecDecs(E,map, ds))
		val t'   = typ_typ E
		val i0'  = i
		val i1'  = typInfo(r,t')
		val i2'  = typInfo(r, typ_unit)
		val x'   = O.Id(i2', Stamp.new(), Name.InId)
		val xx'  = idToExp x'
		val p'   = O.TupPat(i2', #[])
		val e'   = callTyp(E, lab_fix,
				   trVector(r, Type.tuple #[t',t'], es'))
		val d2'  = O.ValDec(i0', idToPat x', trLazy e')
	    in
		StampMap.foldi
		    (fn(z1, (_, x2' as O.Id(i,z2,n)), ds') =>
			let
			    val x1' = O.Id(i,z1,n)
			    val m'  = O.Mat(i0', p', idToExp x2')
			    val e'  = O.CaseExp(i1', xx', #[m'])
			    val d'  = O.ValDec(i0', idToPat x1', trLazy e')
			in
			    d' :: ds'
			end
		    ) (d3' :: d2' :: ds1') map
	    end
	end

      | trDec E (I.FixDec(i,x,q), ds')	= ds'
      | trDec E (I.VarDec(i,x,d), ds')	= trDec E (d, ds')
      | trDec E (I.LocalDec(i,ds), ds')	= trDecs'(E, ds, ds')


    and freshTypids E_map ds = Vector.app (freshTypid E_map) ds
    and freshTypid (E,map) (I.TypDec(_, I.Id(i,z,n), t)) =
	let
	    val x = I.Id(i,Stamp.new(),n)
	in
	    StampMap.insert(map, z, (x, trTypid(E,x)))
	end
      | freshTypid E_map (I.RecDec(_,ds)) = freshTypids E_map ds
      | freshTypid E_map  _               = ()

    and trRecDecs(E, ds) = Vector.rev(Vector.fromList(trRecDecs'(E,ds,[])))
    and trRecDecs'(E, ds, ds') = Vector.foldl (trRecDec E) ds' ds

    and trRecDec E (I.TypDec(i,x,t), ds')	= ds'
      | trRecDec E (I.RecDec(i,ds), ds')	= trRecDecs'(E, ds, ds')
      | trRecDec E (d,ds')			= trDec E (d,ds')


    and trLHSRecDecs'(E,map, ds, ds') = Vector.foldl (trLHSRecDec(E,map)) ds' ds
    and trLHSRecDec (E,map) (I.TypDec(i,x,t), ds') =
	(* [type x = t]' = val $x' = Type.unknown(<<kind>>) *)
	let
	    val r  = #region i
	    val x' = if not(!Switches.Language.supportRtt)
		     then trTypid(E,x)
		     else #2(StampMap.lookupExistent(map, I.stamp x))
	    val e' = if not(!Switches.Language.supportRtt)
		     then O.FailExp(trTypInfo(E, I.infoTyp t))
		     else callTyp(E, lab_unknown,
				  trKind(E, r, Type.kind(#typ(I.infoTyp t))))
	    val d' = O.ValDec(nonInfo r, idToPat x', e')
	in
	    d' :: ds'
        end

      | trLHSRecDec (E,map) (I.RecDec(i,ds), ds') =
	(* [rec ds]' = [ds]' *)
	trLHSRecDecs'(E,map, ds, ds') @ ds'

      | trLHSRecDec (E,map) (d, ds') = ds'

    and trRHSRecDecs(E,map, ds) = Vector.foldl (trRHSRecDec(E,map)) [] ds
    and trRHSRecDec (E,map) (I.TypDec(i,x1,t), es') =
	(* [type x = t]'' = ($x', [t[x'/x]]) *)
	let
	    val x2' = #2(StampMap.lookupExistent(map, I.stamp x1))
	    val e1' = idToExp x2'
	    val e2' = trTypRep(E,x1, renameTyp map t)
	    val e'  = trTuple(#region i, #[e1',e2'])
	in
	    e' :: es'
	end

      | trRHSRecDec (E,map) (I.RecDec(i,ds), es') =
	(* [rec ds]'' = [ds]'' *)
	trRHSRecDecs(E,map, ds) @ es'

      | trRHSRecDec (E,map) (d, es') = es'

    and renameTyp map (t as (I.JokTyp _ | I.VarTyp _ | I.PrimTyp _ |
			     I.SingTyp _| I.AbsTyp _ )) = t
      | renameTyp map (I.ConTyp(i,y))     = I.ConTyp(i, renameTyplongid map y)
      | renameTyp map (I.FunTyp(i,a,t))   = I.FunTyp(i,a, renameTyp map t)
      | renameTyp map (I.AppTyp(i,t1,t2)) =
	   I.AppTyp(i, renameTyp map t1, renameTyp map t2)
      | renameTyp map (I.TupTyp(i,ts))    =
	   I.TupTyp(i, Vector.map (renameTyp map) ts)
      | renameTyp map (I.ProdTyp(i,r))    = I.ProdTyp(i, renameRow map r)
      | renameTyp map (I.SumTyp(i,r))     = I.SumTyp(i, renameRow map r)
      | renameTyp map (I.ArrTyp(i,t1,t2)) =
	   I.ArrTyp(i, renameTyp map t1, renameTyp map t2)
      | renameTyp map (I.AllTyp(i,a,t))   = I.AllTyp(i,a, renameTyp map t)
      | renameTyp map (I.ExTyp(i,a,t))    = I.ExTyp(i,a, renameTyp map t)
      | renameTyp map (I.PackTyp(i,j))    =
	   unfinished (#region i) "renameTyp" "package type"

    and renameRow map (I.Row(i,fs,b)) = I.Row(i,Vector.map (renameFld map) fs,b)
    and renameFld map (I.Fld(i,a,t))  = I.Fld(i, a, renameTyp map t)

    and renameTyplongid map (y as I.LongId _) = y
      | renameTyplongid map (I.ShortId(i,x))  = I.ShortId(i, renameTypid map x)
    and renameTypid map (x as I.Id(i,z,n))    = case StampMap.lookup(map,z)
						  of NONE     => x
						   | SOME xx' => #1 xx'


  (* Specifications *)

    and trSpecs(E, s', ss) =
	Vector.rev(Vector.fromList(trSpecs'(E,s',ss,[])))
    and trSpecs'(E, s', ss, ds') = Vector.foldl (trSpec (E,s')) ds' ss

    and trSpec (E,s') (I.FixSpec(i, I.Lab(i1,l), I.Fix(i2,f)), ds') =
	(* [fixity x : f]_E,s =
	 *    val _ = Inf.extendFix(s, Label.fromString[{x}], [f])
	 *)
	let
	    val r   = #region i
	    val ll' = trLab(E, #region i1, l)
	    val f'  = trFix(E, #region i2, f)
	    val e'  = callInf(E, lab_extendFix, trTuple(r, #[s',ll',f']))
	    val d'  = O.ValDec(nonInfo r, O.JokPat(O.infoExp e'), e')
	in
	    d' :: ds'
	end

      | trSpec (E,s') (I.ValSpec(i,x,t), ds') =
	(* [val x : t]_E,s =
	 *    val _ = Inf.extendVal(s, Label.fromString[x], lazy [t]_E)
	 *)
	let
	    val r   = #region i
	    val ll' = trLab(E, #region(I.infoId x), Label.fromName(I.name x))
	    val t'  = trLazy(trTyp'(E,t))
	    val e'  = callInf(E, lab_extendVal, trTuple(r, #[s',ll',t']))
	    val d'  = O.ValDec(nonInfo r, O.JokPat(O.infoExp e'), e')
	in
	    d' :: ds'
	end

      | trSpec (E,s') (I.TypSpec(i,x,t), ds') =
	(* [type x = t]_E,s =
	 *    val  p = Path.fromString "x"
	 *    val $x = lazy [t]_E,p
	 *    val  _ = Inf.extendTyp(s, p, Type.singKind $x)
	 *)
	let
	    val r   = #region i
	    val i'  = nonInfo r

 	    val r0  = #region(I.infoId x)
	    val p'  = O.Id(typInfo(r0, typ_path E), Stamp.new(), Name.InId)
	    val pp' = idToExp p'
	    val e0' = trPath(E, r0, I.name x)
	    val d0' = O.ValDec(nonInfo r0, idToPat p', e0')

	    val x'  = trTypid(E,x)
	    val xx' = idToExp x'
	    val to' = trTypRep'(E,pp', t)
	    val e1' = case to' of NONE    => trTyp'(E, t)
			        | SOME t' => t'
	    val d1' = O.ValDec(i', idToPat x', trLazy e1')

	    val lab = case to' of SOME _ => lab_kind	(* generative *)
				| NONE   => lab_singKind
	    val k'  = callTyp(E, lab, xx')
	    val e2' = callInf(E, lab_extendTyp, trTuple(r, #[s',pp',k']))
	    val d2' = O.ValDec(nonInfo r, O.JokPat(O.infoExp e2'), e2')
	in
	    d2' :: d1' :: d0' :: ds'
	end

      | trSpec (E,s') (I.ModSpec(i,x,j), ds') =
	(* [module x : j]_E,s =
	 *    val x$ = [j]_E
	 *    val _  = Inf.extendMod(s, Path.fromString "x", x$)
	 * E' = E+{x}
	 *)
	let
	    val r   = #region i
	    val z   = I.stamp x
	    val e1' = trInf'(E, j)
	    val i'  = typInfo(#region(I.infoInf j), typ_inf E)
	    val x'  = O.Id(i', z, trModName(I.name x))
	    val d1' = O.ValDec(nonInfo r, O.VarPat(i',x'), e1')

 	    val r0  = #region(I.infoId x)
	    val p'  = trPath(E, r0, I.name x)
	    val j'  = idToExp x'
	    val e2' = callInf(E, lab_extendMod, trTuple(r, #[s',p',j']))
	    val d2' = O.ValDec(nonInfo r, O.JokPat(O.infoExp e2'), e2')
	in
	    TranslationEnv.insertMod(E, z);
	    d2' :: d1' :: ds'
	end

      | trSpec (E,s') (I.InfSpec(i,x,j), ds') =
	(* [interface x = j]_E,s =
	 *    val p  = Path.fromString "x"
	 *    val $x = lazy [j]_E,p
	 *    val _  = Inf.extendInf(s, p, lazy Inf.singKind x$)
	 *)
	let
	    val r   = #region i

 	    val r0  = #region(I.infoId x)
	    val p'  = O.Id(typInfo(r0, typ_path E), Stamp.new(), Name.InId)
	    val pp' = idToExp p'
	    val e0' = trPath(E, r0, I.name x)
	    val d0' = O.ValDec(nonInfo r0, idToPat p', e0')

	    val x'  = trInfid(E,x)
	    val xx' = idToExp x'
	    val jo' = trInfRep'(E, fn k' => k', pp', j)
	    val e1' = case jo' of NONE    => trInf'(E, j)
			        | SOME j' => j'
	    val r1  = #region(O.infoExp e1')
	    val d1' = O.ValDec(nonInfo r1, idToPat x', trLazy e1')

	    val lab = case jo' of SOME _ => lab_kind	(* generative *)
				| NONE   => lab_singKind
	    val k'  = callInf(E, lab, xx')
	    val e2' = callInf(E, lab_extendInf, trTuple(r, #[s',pp',k']))
	    val d2' = O.ValDec(nonInfo r, O.JokPat(typInfo(r, typ_unit)), e2')
	in
	    d2' :: d1' :: d0' :: ds'
	end

      | trSpec (E,s') (I.RecSpec(i,ss), ds') =
	(* [rec ss] =
	 *    [ss]'
	 *    val _ = Type.fix #[[ss]'']
	 *)
	let
	    val r    = #region i
	    val ds1' = trLHSRecSpecs'(E, s', ss, ds')
	    val es'  = Vector.fromList(trRHSRecSpecs(E, s', ss))
	    val t'   = typ_typ E
	    val e'   = callTyp(E, lab_fix,
			       trVector(r, Type.tuple #[t',t'], es'))
	    val d2'  = O.ValDec(nonInfo r, O.JokPat(typInfo(r, typ_unit)), e')
	in
	    if not(!Switches.Language.supportRtt)
	    then ds1'
	    else d2' :: ds1'
	end

      | trSpec (E,s') (I.ExtSpec(i,j), ds') =
	unfinished (#region i) "trSpec" "signature extension"
	    

    and trLHSRecSpecs'(E, s', ss, ds') =
	Vector.foldl (trLHSRecSpec (E,s')) ds' ss
    and trLHSRecSpec (E,s') (I.TypSpec(i,x,t), ds') =
	(* [type x = t]_E,s = val $x = Type.unknown(<<kind>>) *)
	let
	    val r  = #region i
	    val x' = trTypid(E,x)
	    val e' = callTyp(E, lab_unknown,
			     trKind(E, r, Type.kind(#typ(I.infoTyp t))))
	    val d' = O.ValDec(nonInfo r, idToPat x', e')
	in
	    d' :: ds'
	end

      | trLHSRecSpec (E,s') (I.RecSpec(i,ss), ds') =
	(* [rec ss]' = [ds]' *)
	trLHSRecSpecs'(E, s', ss, ds') @ ds'

      | trLHSRecSpec (E,s') (_, ds') =
	raise Crash.Crash "TranslationPhase.trLHSRecSpec: invalid spec"

    and trRHSRecSpecs(E, s', ss) = Vector.foldl (trRHSRecSpec (E,s')) [] ss
    and trRHSRecSpec (E,s') (I.TypSpec(i,x,t), es') =
	(* [type x = t]_E,s =
	 *    let val p = Path.fromString[x] in
	 *    Inf.extendTyp(s, p, Type.singKind $x);
	 *    ($x, lazy [t]_E)
	 *)
	let
	    val r   = #region i
	    val i'  = nonInfo r

 	    val r0  = #region(I.infoId x)
	    val p'  = O.Id(typInfo(r0, typ_path E), Stamp.new(), Name.InId)
	    val pp' = idToExp p'
	    val e0' = trPath(E, r0, I.name x)
	    val d'  = O.ValDec(nonInfo r0, idToPat p', e0')

	    val x'  = trTypid(E,x)
	    val xx' = idToExp x'
	    val to' = trTypRep'(E, pp', t)
	    val lab = case to' of SOME _ => lab_kind	(* generative *)
				| NONE   => lab_singKind
	    val k'  = callTyp(E, lab, xx')
	    val e1' = callInf(E, lab_extendTyp, trTuple(r, #[s',pp',k']))

	    val t'  = case to' of NONE    => trTyp'(E, t)
				| SOME t' => t'
	    val e2' = trTuple(r, #[xx', (*trLazy*) t'])

	    val i'  = O.infoExp e2'
	    val e'  = O.LetExp(i', #[d'], O.SeqExp(i', e1', e2'))
	in
	    e' :: es'
	end

      | trRHSRecSpec (E,s') (I.RecSpec(i,ss), es') =
	(* [rec ss]'' = [ss]'' *)
	trRHSRecSpecs(E, s', ss) @ es'

      | trRHSRecSpec (E,s') (_, es') =
	raise Crash.Crash "TranslationPhase.trRHSRecSpec: invalid spec"


  (* Imports and annotations *)

    fun idToDec(x' as O.Id(i,_,n), y) =
	let
	    val i' = nonInfo(#region i)
	    val y' = O.LongId(i, y, O.Lab(i', Label.fromName n))
	in
	    O.ValDec(i', idToPat x', O.VarExp(i, y'))
	end

    fun trAnns(E, a_s) =
	let
	    val (rxjus',ds') = Vector.foldl (trAnn E) ([],[]) a_s
	    val  xjus'       = Vector.rev(Vector.fromList rxjus')
	    val  ds''        = Vector.rev(Vector.fromList ds')
	in
	    ( xjus', ds'' )
	end

    and trAnn E (I.ImpAnn(i,is,u), (xjus',ds')) =
	let
	    val r    = #region i
	    val s    = #sign i
	    val t    = Type.unknown(Type.starKind())
		       (* to allow import of pervasive *)
	    val i'   = typInfo(r,t)
	    val x'   = O.Id(i', Stamp.new(), Name.InId)
	    val ds'' = trImps(E, is, O.ShortId(i',x'), ds')
	    val _    = Type.unify(t, infToTyp(E, Inf.sign s))
	    val _    = Inf.compressSig s
	in
	    ( (x',Inf.sign s,u)::xjus', ds'' )
	end

    and trImps(E, is, y, ds')             = Vector.foldl (trImp (E,y)) ds' is
    and trImp (E,y) (I.FixImp(i,x,d),ds') = ds'
      | trImp (E,y) (I.ValImp(i,x,d),ds') = idToDec(trValid(E,x), y) :: ds'
      | trImp (E,y) (I.TypImp(i,x,d),ds') = idToDec(trTypid(E,x), y) :: ds'
      | trImp (E,y) (I.ModImp(i,x,d),ds') = ((updatePervasive(E,x);
					     idToDec(trModid(E,x), y) :: ds'
					     before updatePervasive'(E,x))
(*DEBUG*)handle VirtualModule => (Error.warn(#region i, Name.toString(I.name x) ^"[" ^ Stamp.toString(I.stamp x) ^ "] 5\n"); raise VirtualModule)
)
      | trImp (E,y) (I.InfImp(i,x,d),ds') = idToDec(trInfid(E,x), y) :: ds'
      | trImp (E,y) (I.RecImp(i,is), ds') = trImps(E, is, y, ds')


  (* Components *)

    fun trComp(E, I.Comp(i,a_s,ds)) =
	let
	    val (xjus',ds1') = trAnns(E,a_s)
	    val  ds2'        = trDecs(E,ds)
	    val  ds'         = Vector.append(ds1',ds2')
	    val  ids'        = ids(E,ds)
	    val  fs'         = Vector.map (idToFld (fn x' => x')) ids'
	    val  s           = #sign i
	    val  _           = Inf.compressSig s
	in
	    ( xjus', ds', fs', Inf.sign s )
	end

    fun translate E (desc, comp) =
	let
	    val _     = Inf.Map.deleteAll infHash
	    val comp' = trComp(E, comp)
	in
	    comp'
	end
(*DEBUG
handle Inf.Mismatch m =>
(Error.warn(Source.nowhere, "UNHANDLED in TRANSLATION:\n");
ElaborationError.error(#region(I.infoComp comp), ElaborationError.AnnModMismatch m))
*)
end
