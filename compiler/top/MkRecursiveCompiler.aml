(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt and Andreas Rossberg, 1999-2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure IO                 from "../../lib/system/IO"
import structure BinIO              from "../../lib/system/BinIO"
import structure TextIO             from "../../lib/system/TextIO"
import structure OS                 from "../../lib/system/OS"
import structure Config             from "../../lib/system/Config"
import structure Url                from "../../lib/system/Url"
import signature COMPONENT_MANAGER  from "../../lib/system/COMPONENT_MANAGER-sig"
import structure Component          from "../../lib/system/Component"
import structure MkHashImpMap       from "../../lib/utility/MkHashImpMap"
import structure Path               from "../../lib/rtt/Path"
import structure Inf                from "../../lib/rtt/Inf"

import structure Crash              from "../infrastructure/Crash"
import structure Source             from "../infrastructure/Source"
import structure Target             from "../infrastructure/Target"
import signature COMPILER           from "COMPILER-sig"
import signature RECURSIVE_COMPILER from "RECURSIVE_COMPILER-sig"

type sig_loader = Source.desc * Url.t -> Inf.sign

functor MkRecursiveCompiler(structure ComponentManager: COMPONENT_MANAGER
				where type component = Component.t
			    structure Compiler: COMPILER
			    val extension: string): RECURSIVE_COMPILER =
    struct
	structure Switches = Compiler.Switches

	exception Error = Compiler.Error

	type context = Compiler.context
	val empty = Compiler.empty

	val extension = extension

	fun error message =
	    (TextIO.output (TextIO.stdErr, "### error: " ^ message ^ "\n");
	     raise Error)
	fun warn message =
	    TextIO.output (TextIO.stdErr, "### warning: " ^ message ^ "\n")

	fun trace message =
	    if !Switches.Global.traceComponentAccess then
		TextIO.print ("### " ^ message ^ "\n")
	    else ()

	local
	    val homeRef: string option ref = ref NONE
	in
	    fun home () =
		case !homeRef of
		    NONE =>
			let
			    val home =
				case Config.homeDir of
				    SOME s => s ^ "/"
				  | NONE =>
					(warn ("could not determine " ^
					       "installation directory");
					 "")
			in
			    homeRef := SOME home; home
			end
		  | SOME home => home
	end

	fun resolveWrtCwd url =
	    let
		val base =
		    Url.setScheme (Url.fromString (OS.FileSys.getDir () ^ "/"),
				   SOME "file")
	    in
		Url.resolve base url
	    end

	fun parseUrl url =
	    case (Url.getScheme url, Url.getAuthority url) of
		(NONE, NONE) =>
		    Url.toStringRaw url
	      | (SOME "file", NONE) =>
		    Url.toStringRaw (Url.setScheme (url, NONE))
	      | (SOME "x-alice", NONE) =>
		    home () ^
		    Url.toStringRaw (Url.setScheme (Url.makeRelativePath url,
						    NONE))
	      | _ => raise Crash.Crash "MkBatchCompiler.parseUrl"

	fun readFile filename =
	    let
		val file   = TextIO.openIn filename handle IO.Io {...} =>
				error("could not open " ^ filename)
		val source = TextIO.inputAll file handle IO.Io {...} =>
				error("error reading " ^ filename)
		val _      = TextIO.closeIn file
	    in
		source
	    end

	local
	    val implicitImportRef = ref NONE	(* poor man's laziness *)
	in
	    fun implicitImport() =
		case !implicitImportRef
		  of SOME s => s
		   | NONE =>
		case !Switches.Language.implicitImportFile
		  of NONE => ""
		   | SOME url =>
		let
		    val s = String.map (fn #"\n" => #" " | c => c)
				       (readFile(parseUrl(Url.fromString url)))
		in
		    implicitImportRef := SOME s;
		    s
		end
	end

	fun isBaseSig desc =   (*--** only needed for .NET backend *)
	    case Source.url desc of
		SOME url =>
		    parseUrl url =
		    parseUrl (resolveWrtCwd (Url.fromString (home () ^
							     "Base.asig")))
	      | NONE => false

	fun processBasic process (desc, s) =
	    let
	        val prefix = if not(!Switches.Language.implicitImport)
			     orelse isBaseSig desc
			     then ""
			     else implicitImport()
	    in
		process(desc, prefix ^ "\n" ^ s)
	    end

	fun processString process source =
	    processBasic process (Source.stringDesc, source)

	fun processFile process filename =
	    let
		val url = resolveWrtCwd (Url.fromString filename)
	    in
		processBasic process (Source.urlDesc url,
				      readFile (parseUrl url))
	    end

	local
	    fun compileSign' (desc, s) =
		let
		    val sigFilename = Url.toStringRaw (valOf (Source.url desc))
		    val _ = trace ("reading signature from " ^ sigFilename)
		    val s' = implicitImport() ^ "\n" ^ s
		    val (_, target) =
			Compiler.compile (Compiler.empty, desc,
					  Source.fromString s')
		    val _ = trace "done"
		    val inf' =
			case target of
			    Target.COMPONENT {component, ...} =>
				valOf (Component.inf (component ()))
			  | Target.FOREIGN {inf, ...} => inf
		    val inf = Inf.asSingKind
			      (#2 (Inf.asInfItem
				   (List.hd (Inf.items (Inf.asSig inf')))))
			      handle e as ( Inf.Interface | Inf.Kind | Inf.Item
					  | List.Empty | Option.Option) =>
				 error ("signature file " ^ sigFilename ^
					" does not contain a proper\
					\ signature declaration")
		in
		    inf
		end
	in
	    fun compileSign filename = processFile compileSign' filename
	end

	local
	    fun compile' outFilename (desc, s) =
		case Compiler.compile (empty, desc, Source.fromString s) of
		    (_, Target.COMPONENT {component, ...}) =>
			let
			    val component = component ()
			in
			    Component.save (outFilename, component);
			    valOf (Component.inf component)
			end
		  | (_, Target.FOREIGN {save, inf}) =>
			(save outFilename;
			 inf)

	    val fileStack: string list ref = ref nil
	in
	    fun compileFileToFile' (sourceFilename, targetFilename) =
		(trace ("compiling file " ^ sourceFilename);
		 fileStack := sourceFilename::(!fileStack);
		 processFile (compile' targetFilename) sourceFilename
		 before (trace ("wrote file " ^ targetFilename);
			 case fileStack of
			     ref (_::(rest as resumeFilename::_)) =>
				 (fileStack := rest;
				  trace ("resuming compilation of " ^
					 resumeFilename))
			   | ref [_] => fileStack := nil
			   | ref nil => ()))
	end

	(* Define signature acquisition via recursive compiler invocation *)

	fun existsFile filename = (*--** use OS.FileSys.access *)
	    (BinIO.closeIn (BinIO.openIn filename); true)
	    handle IO.Io {...} => false

	fun pathCeil filename =
	    let
		val fro = "." ^ extension
		val n = String.size filename
		val m = String.size fro
	    in
		if n > m andalso String.substring (filename, n - m, m) = fro
		then filename
		else filename ^ fro
	    end

	fun pathFloor filename =
	    let
		val fro = "." ^ extension
		val n = String.size filename
		val m = String.size fro
	    in
		if n > m andalso String.substring (filename, n - m, m) = fro
		then String.substring (filename, 0, n - m)
		else filename
	    end

	fun urlCeil url =
	    case List.rev (Url.getPath url) of
		last::rest => Url.setPath (url, List.rev (pathCeil last::rest))
	      | nil => url

	(* Try to find a compiled component or source file - search order:
	 *
	 * A              component known to composer, get signature
	 * ceil(A)        component known to composer, get signature
	 * A              pickled component, read signature from pickle
	 * ceil(A)        pickled component, read signature from pickle
	 * -- from here on only if Switches.Global.recursiveCompilation
	 * floor(A).asig  compile as signature for native component
	 * floor(A).aml   compile as new component, write to ceil(A)
	 * floor(A).sml   compile as new component, write to ceil(A)
	 * floor(A).sig   compile as new component, write to ceil(A)
	 *
	 * where ceil(A) = A, if A has the component extension, else A.ozf
	 * where floor(A) = A, if A has not component extension,
	 *                  else A without the component extension
	 *)

	structure UrlMap = MkHashImpMap(Url)

	val sigTable: Inf.sign UrlMap.t = UrlMap.new ()

	fun loadSig url = Component.inf (ComponentManager.link url)

	fun acquireSig (desc, url) =
	    let
		val url' =
		    case Source.url desc of
			SOME base => Url.resolve base url
		      | NONE => resolveWrtCwd url
	    in
		case UrlMap.lookup (sigTable, urlCeil url') of
		    SOME sign => sign
		  | NONE =>
		    let
			val inf = valOf (loadSig url')
			    handle exn as (Component.Failure (_, _) |
					   Option.Option) =>
				acquireFromSigFile (url', exn)
			val _ = trace ("loaded signature from " ^
				       Url.toString url')
			val sign = Inf.asSig inf
			    handle Inf.Interface =>
				error ("higher-order content found in " ^
				       Url.toString url)
		    in
			UrlMap.insert (sigTable, urlCeil url', sign);
			sign
		    end
	    end
	and acquireFromSigFile (url, exn) =
	    let
		val targetFilename = parseUrl url
		val sigFilename = pathFloor targetFilename ^ ".asig"
	    in
		if existsFile sigFilename then
		    compileSign sigFilename
		else if !Switches.Global.recursiveCompilation then
		    acquireFromSource targetFilename
		else
		    error ((case exn of
				Component.Failure (_, IO.Io {...}) =>
				    "could not locate component "
			      | Option.Option => "no signature found in "
			      | _ => "unknown error while accessing ") ^
			   parseUrl url)
	    end
	and acquireFromSource targetFilename =
	    case acquireFromSource' (targetFilename, ".aml") of
		SOME inf => inf
	      | NONE =>
	    case acquireFromSource' (targetFilename, ".sml") of
		SOME inf => inf
	      | NONE =>
	    case acquireFromSource' (targetFilename, ".sig") of
		SOME inf => inf
	      | NONE =>
	    error ("could not locate source for " ^ targetFilename)
	and acquireFromSource' (targetFilename, to) =
	    let
		val sourceFilename = pathFloor targetFilename ^ to
	    in
		if existsFile sourceFilename then
		    SOME (compileFileToFile' (sourceFilename,
					     pathCeil targetFilename))
		else NONE
	    end

	local
	    fun compile' context (desc, s) =
		Compiler.compile (context, desc, Source.fromString s)
	in
	    val compileFileToFile = ignore o compileFileToFile'

	    fun compileFile context sourceFilename =
		processFile (compile' context) sourceFilename

	    fun compileString context sourceText =
		processString (compile' context) sourceText
	end
    end
