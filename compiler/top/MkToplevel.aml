(*
 * Authors:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt and Andreas Rossberg, 2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure TextIO from "../../lib/system/TextIO"
import structure OS     from "../../lib/system/OS"

import structure Error                from "../infrastructure/Error"
import structure MkOptionParser       from "MkOptionParser"
import signature RECURSIVE_COMPILER   from "RECURSIVE_COMPILER-sig"
import signature INTERACTIVE_TOPLEVEL from "INTERACTIVE_TOPLEVEL-sig"


functor MkToplevel(RecursiveCompiler: RECURSIVE_COMPILER) :
    INTERACTIVE_TOPLEVEL =
struct
    structure OptionParser = MkOptionParser(RecursiveCompiler.Switches)

    fun usage() = TextIO.output(TextIO.stdErr, "Usage: alice [options]\n" ^
						OptionParser.helpText)

    val header     = "Stockhausen Operette 2\n"
    val prompt     = "> "
    val contPrompt = "  "

    val useFiles: string list ref = ref nil

    fun use filename =
	let
	    val new = Hole.hole ()
	    val old = Ref.exchange (useFiles, new)
	in
	    Hole.fill (new, old @ [filename])
	end

    fun readInput() =
	case readInput' prompt of [] => NONE
				| ss => SOME(String.concat ss)

    and readInput' prompt =
	let
	    val _    = TextIO.print prompt
	    val line = TextIO.inputLine(TextIO.stdIn)
	    val size = String.size line
	in
	    if size = 0 then
		[]
	    else if size > 1 andalso String.sub(line, size-2) = #";" then
		[line]
	    else
		line :: readInput' contPrompt
	end

    fun eval compile (source, compilerContext, targetContext) =
	let
	    val (compilerContext, target) = compile compilerContext source
	in
	    RecursiveCompiler.Target.apply targetContext target;
	    (compilerContext, targetContext)
	end
	handle RecursiveCompiler.Error => (compilerContext, targetContext)
	     | exn =>
		   (TextIO.output (TextIO.stdErr,
				   "uncaught exception " ^
				   General.exnName exn ^ "\n");
		    (compilerContext, targetContext))   (*--** is this cool or what? *)

    val evalString = eval RecursiveCompiler.compileString
    val evalFile   = eval RecursiveCompiler.compileFile

    fun loop(compilerContext, targetContext) =
	case readInput() of
	    SOME source =>
		loopUses(evalString(source, compilerContext, targetContext))
	  | NONE => TextIO.print "\n"
    and loopUses (compilerContext, targetContext) =
	let
	    val new = Hole.hole ()
	    val old = Ref.exchange (useFiles, new)
	in
	    case old of
		filename::rest =>
		    (Hole.fill (new, rest);
		     loopUses (evalFile (filename,
					 compilerContext, targetContext)))
	      | nil =>
		    (Hole.fill (new, nil);
		     loop (compilerContext, targetContext))
	end

    fun main'(_::_) = (usage(); OS.Process.failure)
      | main' nil =
	let
	    open RecursiveCompiler.Switches
	    val dumpSig = !Debug.dumpElaborationSig
	    val _ = Debug.dumpElaborationSig := false
	    val (compilerContext, targetContext) =
		evalString("", RecursiveCompiler.empty,
			       RecursiveCompiler.Target.C.new())
	in
	    Debug.dumpElaborationSig := dumpSig;
	    Language.implicitImport  := false;
	    loop(compilerContext, targetContext);
	    OS.Process.success
	end

    fun main arguments =
	let
	    open RecursiveCompiler.Switches
	in
	    Debug.dumpPhases := false;
	    Language.reexportImport := true;
	    main'(OptionParser.parse arguments)
	end
end
