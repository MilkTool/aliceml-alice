(*
 * Authors:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt and Andreas Rossberg, 2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure TextIO               from "../../lib/system/TextIO"
import structure OS                   from "../../lib/system/OS"
import structure Url                  from "../../lib/utility/Url"

import structure Crash                from "../infrastructure/Crash"
import structure Error                from "../infrastructure/Error"
import structure Target               from "../infrastructure/Target"
import structure MkOptionParser       from "MkOptionParser"
import signature RECURSIVE_COMPILER   from "RECURSIVE_COMPILER-sig"
import signature INTERACTIVE_TOPLEVEL from "INTERACTIVE_TOPLEVEL-sig"


functor MkToplevel(RecursiveCompiler: RECURSIVE_COMPILER) :
    INTERACTIVE_TOPLEVEL =
struct
    structure OptionParser = MkOptionParser(RecursiveCompiler.Switches)

    fun usage() = TextIO.output(TextIO.stdErr, "Usage: alice [options]\n" ^
						OptionParser.helpText)

    val banner     = "Alice (Stockhausen Operette 3 draft scores)\n"
    val prompt     = "- "
    val contPrompt = "  "

    val useFiles: string list ref = ref nil

    fun use filename =
	let
	    val new = Hole.hole ()
	    val old = Ref.exchange (useFiles, new)
	in
	    Hole.fill (new, old @ [filename])
	end

    fun readInput() =
	case readInput' prompt of [] => NONE
				| ss => SOME(String.concat ss)

    and readInput' prompt =
	let
	    val _    = TextIO.print prompt
	    val line = TextIO.inputLine(TextIO.stdIn)
	    val size = String.size line
	in
	    if size = 0 then
		[]
	    else if size > 1 andalso String.sub(line, size-2) = #";" then
		[line]
	    else
		line :: readInput' contPrompt
	end

    fun baseUrl () =
	Url.setScheme (Url.fromString (OS.FileSys.getDir () ^ "/"),
		       SOME "file")

    fun eval compile (source, context) =
	(case compile context source of
	     (context, Target.COMPONENT {eval, ...}) =>
		 (eval (baseUrl ()); context)
	   | (_, Target.FOREIGN _) =>
		 raise Crash.Crash
		     "MkToplevel.eval: cross-compilation not supported")
	handle RecursiveCompiler.Error => context
	     | exn =>
		   (TextIO.output (TextIO.stdErr,
				   "uncaught exception " ^
				   General.exnName exn ^ "\n");
		    context)   (*--** is this cool or what? *)

    val evalString = eval RecursiveCompiler.compileString
    val evalFile   = eval RecursiveCompiler.compileFile

    fun loop context =
	case readInput() of
	    SOME source => loopUses(evalString(source, context))
	  | NONE => TextIO.print "\n"
    and loopUses context =
	let
	    val new = Hole.hole ()
	    val old = Ref.exchange (useFiles, new)
	in
	    case old of
		filename::rest =>
		    (Hole.fill (new, rest);
		     loopUses (evalFile (filename, context)))
	      | nil =>
		    (Hole.fill (new, nil);
		     loop context)
	end

    fun main'(_::_) = (usage(); OS.Process.failure)
      | main' nil =
	let
	    open RecursiveCompiler.Switches
	    val dumpSig = !Debug.dumpElaborationSig
	    val _ = Debug.dumpElaborationSig := false
	    val context = evalString("", RecursiveCompiler.empty)
	in
	    Debug.dumpElaborationSig := dumpSig;
	    Language.implicitImport  := false;
	    loop context;
	    OS.Process.success
	end

    fun defaults () = (* override defaults from MkSwitches here *)
	RecursiveCompiler.Switches.Language.implicitImportFile :=
	    SOME "x-alice:/alice.import"

    fun main arguments =
	let
	    val _ = TextIO.print banner
	    open RecursiveCompiler.Switches
	in
	    defaults ();
	    Debug.dumpElaborationSig := true;
	    Debug.dumpPhases := false;
	    Language.allowUnclosedComponents := true;
	    Language.reexportImport := true;
	    Global.traceComponentAccess := true;
	    main'(OptionParser.parse arguments)
	end
end
