(*
 * Authors:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *   Andreas Rossberg <rossberg@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt and Andreas Rossberg, 2000
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(*
 * Mmh, how about parameterization of Phases over error output formatting...?
 * And shouldn't the Composer also be applied here?
 * Problem is, this requires applicative functors with extended paths.
 *)

import structure Source   from "../infrastructure/Source"
import structure Error    from "../infrastructure/Error"
import signature SWITCHES from "../infrastructure/SWITCHES-sig"
import signature PHASE    from "../infrastructure/PHASE-sig"
import signature TARGET   from "../infrastructure/TARGET-sig"
import signature COMPILER from "COMPILER-sig"


functor MkCompiler(
	structure Switches:         SWITCHES
	structure Target:           TARGET
	structure FrontendSpecific: PHASE where type I.t = Source.t
	structure FrontendCommon:   PHASE where type I.t = FrontendSpecific.O.t
	structure BackendCommon:    PHASE where type I.t = FrontendCommon.O.t
	structure BackendSpecific:  PHASE where type I.t = BackendCommon.O.t
					  where type O.t = Target.t
       ) :> COMPILER (*TODO where Target = Target*)
	    where type Target.t     = Target.t
	    where type Target.C.t   = Target.C.t
	    where type Target.Sig.t = Target.Sig.t =
struct
    structure Switches = Switches
    structure Target = Target

    exception Error

    type context =
	{ feSpec : FrontendSpecific.C.t
	, feComm : FrontendCommon.C.t
	, beComm : BackendCommon.C.t
	, beSpec : BackendSpecific.C.t
	}

    val empty =
	{ feSpec = FrontendSpecific.C.new()
	, feComm = FrontendCommon.C.new()
	, beComm = BackendCommon.C.new()
	, beSpec = BackendSpecific.C.new()
	}

    fun clone {feSpec,feComm,beComm,beSpec} =
	{ feSpec = FrontendSpecific.C.clone feSpec
	, feComm = FrontendCommon.C.clone feComm
	, beComm = BackendCommon.C.clone beComm
	, beSpec = BackendSpecific.C.clone beSpec
	}

    fun compile(C, desc, source) =
	let
	    val C' = clone C
	    val rep = FrontendSpecific.translate (#feSpec C') (desc, source)
	    val rep = FrontendCommon.translate (#feComm C') (desc, rep)
	    val rep = BackendCommon.translate (#beComm C') (desc, rep)
	    val target = BackendSpecific.translate (#beSpec C') (desc, rep)
	in
	    (C', target)
	end
	handle Error.Error _ => raise Error
end
