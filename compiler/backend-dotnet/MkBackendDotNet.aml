
(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2000-2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure OS             from "../../lib/system/OS"
import structure Source         from "../infrastructure/Source"
import structure Error          from "../infrastructure/Error"
import signature SWITCHES       from "../infrastructure/SWITCHES-sig"
import signature PHASE          from "../infrastructure/PHASE-sig"
import structure EmptyContext   from "../infrastructure/EmptyContext"
import structure MkTracingPhase from "../infrastructure/MkTracingPhase"
import structure Target         from "../infrastructure/Target"
import structure FlatGrammar    from "../backend-common/FlatGrammar"
import structure IL             from "IL"
import structure CodeGenPhase   from "CodeGenPhase"

functor MkBackendDotNet(structure Switches: SWITCHES): PHASE =
    let
	fun inf (_, exportInf) = exportInf

	fun save program filename =
	    let
		val ilFilename = filename ^ ".il"
		val ilasm =
		    "ilasm /quiet /dll \"" ^ ilFilename ^
		    "\" /out=\"" ^ filename ^ "\""
	    in
		IL.outputProgram (ilFilename, program);
		if OS.Process.system ilasm = OS.Process.success then ()
		else
		    raise Error.Error (Source.nowhere,
				       "invocation of `" ^ ilasm ^ "' failed")
	    end
    in
	MkTracingPhase(structure Phase =
			   struct
			       structure C = EmptyContext
			       structure I = FlatGrammar
			       structure O = Target

			       fun translate () x =
				   let
				       val program =
					   CodeGenPhase.translate () x
				   in
				       Target.FOREIGN {save = save program,
						       inf = inf program}
				   end
			   end
		       structure Switches = Switches
		       val name = "Code Generation")
    end
