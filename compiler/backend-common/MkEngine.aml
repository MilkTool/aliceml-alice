(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2000
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

functor MakeEngine(val cmd: unit -> string * string list
		   structure Code: CODE) :> ENGINE where type code = Code.t =
    struct
	type t = Unix.proc option ref
	type code = Code.t
	type value = int

	exception Format of string

	val valueToString = Int.toString

	fun start () = ref (SOME (Unix.execute (cmd ())))

	fun instream proc = #1 (Unix.streamsOf (valOf (!proc)))
	fun outstream proc = #2 (Unix.streamsOf (valOf (!proc)))

	datatype arg =
	    CODE of Code.t
	  | VALUE of value
	  | STRING of string

	fun sendCommand (proc, command, args) =
	    let
		val q = outstream proc
	    in
		TextIO.output (q, "Command: " ^ command ^ "\n");
		List.app (fn arg =>
			  (TextIO.output (q, "Argument: ");
			   case arg of
			       CODE code =>
				   Code.externalize (q, code)
			     | VALUE value =>
				   TextIO.output (q, valueToString value)
			     | STRING string =>
				   TextIO.output (q, string);
			   TextIO.output1 (q, #"\n"))) args;
		TextIO.output1 (q, #"\n");
		TextIO.flushOut q
	    end

	local
	    fun split (#":"::cs) = SOME (nil, cs)
	      | split (c::cs) =
		(case split cs of
		     SOME (name, value) => SOME (c::name, value)
		   | NONE => NONE)
	      | split nil = NONE
	in
	    fun parseResult proc =
		case TextIO.inputLine (instream proc) of
		    "\n" => nil
		  | s =>
			case String.sub (s, 0) of
			    #"%" => (TextIO.print s; parseResult proc)
			  | _ =>
			case split (String.explode s) of
			    SOME ([#"D", #"e", #"b", #"u", #"g"], s) =>
				(TextIO.print (String.implode s);
				 parseResult proc)
			  | SOME (name, value) =>
				(String.implode name, String.implode value)::
				parseResult proc
			  | NONE =>
				(TextIO.print s; parseResult proc)
	end

	fun stop proc =
	    (sendCommand (proc, "stop", nil);
	     case parseResult proc of
		 [("Result", _)] => ()
	       | _ => raise Format "stop: result expected";
	     TextIO.closeOut (outstream proc);
	     proc := NONE)

	fun buildFunctor proc code =
	    (sendCommand (proc, "buildFunctor", [CODE code]);
	     case parseResult proc of
		 [("Result", s)] => valOf (Int.fromString s)
	       | _ => raise Format "buildFunctor: result expected")

	fun saveValue proc filename value =
	    (sendCommand (proc, "saveValue", [STRING filename, VALUE value]);
	     case parseResult proc of
		 [("Result", _)] => ()
	       | _ => raise Format "saveValue: result expected")
    end
