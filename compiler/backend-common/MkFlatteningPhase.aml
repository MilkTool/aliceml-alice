(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999-2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import structure Signature            from "../../lib/system/Signature"
import structure Assert               from "../../lib/utility/Assert"
import structure GlobalStamp          from "../../lib/utility/GlobalStamp"
import structure Url                  from "../../lib/utility/Url"
import structure Name                 from "../../lib/rtt/Name"
import structure Label                from "../../lib/rtt/Label"
import structure Type                 from "../../lib/rtt/Type"
import structure PervasiveType        from "../../lib/rtt/PervasiveType"
import structure Crash                from "../infrastructure/Crash"
import structure Source               from "../infrastructure/Source"
import structure Error                from "../infrastructure/Error"
import signature CONTEXT              from "../infrastructure/CONTEXT-sig"
import structure EmptyContext         from "../infrastructure/EmptyContext"
import structure Stamp                from "../common/Stamp"
import signature INTERMEDIATE_GRAMMAR from "../common/INTERMEDIATE_GRAMMAR-sig"
import structure IntermediateGrammar  from "../common/IntermediateGrammar"

import structure LabelSort            from "LabelSort"
import structure Arity                from "Arity"
import signature FLAT_GRAMMAR         from "FLAT_GRAMMAR-sig"
import structure FlatGrammar          from "FlatGrammar"
import structure IntermediateAux      from "IntermediateAux"
import structure SimplifyMatch        from "SimplifyMatch"
import structure SimplifyRec          from "SimplifyRec"
import signature SWITCHES             from "../infrastructure/SWITCHES-sig"
import signature FLATTENING_PHASE     from "FLATTENING_PHASE-sig"

functor MkFlatteningPhase(val loadSign:
			      Source.desc * Url.t -> FlatGrammar.sign
			  structure Switches: SWITCHES) :>
    FLATTENING_PHASE =
    struct
	structure C = EmptyContext
	structure I = IntermediateGrammar
	structure O = FlatGrammar

	open I
	open IntermediateAux
	open SimplifyMatch

	local
	    fun lookup' (pos, (pos', id)::mappingRest) =
		if pos = pos' then SOME id
		else lookup' (pos, mappingRest)
	      | lookup' (pos, nil) = NONE
	in
	    fun lookup (pos, mapping) =
		case lookup' (pos, mapping) of
		    SOME id => id
		  | NONE => raise Crash.Crash "MkFlatteningPhase.lookup"

	    fun adjoin (pos, mapping) =
		case lookup' (pos, mapping) of
		    SOME id => (O.IdDef id, mapping)
		  | NONE =>
			let
			    val id = O.freshId {region = Source.nowhere}
			in
			    (O.IdDef id, (pos, id)::mapping)
			end
	end

	fun mappingsToSubst (mapping0, mapping) =
	    List.map (fn (pos, Id (_, stamp1, _)) =>
		      case lookup (pos, mapping) of
			  O.Id (_, stamp2, _) => (stamp1, stamp2)) mapping0

	fun stm_info region = {region = region, liveness = ref O.Unknown}

	fun share nil = nil
	  | share (stms as [O.SharedStm (_, _, _)]) = stms
	  | share (stms as stm::_) =
	    [O.SharedStm (stm_info (#region (O.infoStm stm)), stms,
			  Stamp.new ())]

	datatype continuation =
	    Decs of dec list * continuation
	  | Goto of O.body
	  | Share of O.body option ref * continuation
	  | EndTry of Source.region * continuation
	  | EndHandle of Source.region * continuation

	(* Matching arity up with args *)

	fun testArity (args as O.OneArg _, Arity.Unary, app, body) =
	    app (args, body)
	  | testArity (O.OneArg idDef, Arity.Tuple n, app, body) =
	    let
		val ids =
		    Vector.tabulate
		    (n, fn _ => O.freshId {region = Source.nowhere})
		val stm =
		    O.ValDec (stm_info Source.nowhere, idDef,
			      O.TupExp ({region = Source.nowhere}, ids))
	    in
		app (O.TupArgs (Vector.map O.IdDef ids), stm::body)
	    end
	  | testArity (O.OneArg idDef, Arity.Product labels, app, body) =
	    let
		val labelIdVec =
		    Vector.map (fn label =>
				(label, O.freshId {region = Source.nowhere}))
		    labels
		val stm =
		    O.ValDec (stm_info Source.nowhere, idDef,
			      O.ProdExp ({region = Source.nowhere},
					 labelIdVec))
		val labelIdDefVec =
		    Vector.map (fn (label, id) => (label, O.IdDef id))
		    labelIdVec
	    in
		app (O.ProdArgs labelIdDefVec, stm::body)
	    end
	  | testArity (args as O.TupArgs _, Arity.Tuple _, app, body) =
	    app (args, body)
	  | testArity (args as O.ProdArgs _, Arity.Product _, app, body) =
	    app (args, body)
	  | testArity (_, _, _, _) =
	    raise Crash.Crash "MkFlatteningPhase.testArity"

	fun tagTest (label, n, args, arity, body) =
	    testArity (args, arity,
		       fn (args, body) => O.TagTests #[(label, n, args, body)],
		       body)

	fun conTest (con, args, arity, body) =
	    testArity (args, arity,
		       fn (args, body) => O.ConTests #[(con, args, body)],
		       body)

	fun expArity (args as O.OneArg _, Arity.Unary, info, app) =
	    (nil, app args)
	  | expArity (O.OneArg id, Arity.Tuple n, info: id_info, app) =
	    let
		val ids =
		    Vector.tabulate
		    (n, fn _ => O.freshId {region = Source.nowhere})
		val idDefs = Vector.map O.IdDef ids
	    in
		([O.TupDec (stm_info (#region info), idDefs, id)],
		 app (O.TupArgs ids))
	    end
	  | expArity (O.OneArg id, Arity.Product labels, info, app) =
	    let
		val labelIdVec =
		    Vector.map (fn label =>
			      (label, O.freshId {region = Source.nowhere}))
		    labels
		val labelIdDefVec =
		    Vector.map (fn (label, id) => (label, O.IdDef id))
		    labelIdVec
	    in
		([O.ProdDec (stm_info (#region info), labelIdDefVec, id)],
		 app (O.ProdArgs labelIdVec))
	    end
	  | expArity (args as O.TupArgs _, Arity.Tuple _, _, app) =
	    (nil, app args)
	  | expArity (args as O.ProdArgs _, Arity.Product _, _, app) =
	    (nil, app args)
	  | expArity (_, _, _, _) =
	    raise Crash.Crash "MkFlatteningPhase.expArity"

	fun tagExp (info, label, n, args, arity) =
	    expArity (args, arity, info,
		      fn args => O.TagExp (id_info info, label, n, args))

	fun conExp (info, id, args, arity) =
	    expArity (args, arity, info,
		      fn args => O.ConExp (id_info info, id, args))

	(* Translation *)

	fun translateId (Id (info, stamp, name)) =
	    O.Id (id_info info, stamp, name)

	fun translateLongid (ShortId (info, id)) =
	    (nil, translateId id, #typ info)
	  | translateLongid (LongId ({region, typ}, longid, Lab (_, label))) =
	    let
		val (stms, id, innerTyp) = translateLongid longid
		val info = {region = region}
		val id' = O.Id (info, Stamp.new (), Name.InId)
		val (prod, n) = labelToIndex (innerTyp, label)
		val stm =
		    O.ValDec (stm_info region, O.IdDef id',
			      O.LazySelAppExp (info, prod, label, n, id))
	    in
		(stms @ [stm], id', typ)
	    end

	fun decsToIdDefExpList (O.ValDec (_, idDef, exp')::rest, region) =
	    (idDef, exp')::decsToIdDefExpList (rest, region)
	  | decsToIdDefExpList (O.IndirectStm (_, ref bodyOpt)::rest, region) =
	    decsToIdDefExpList (valOf bodyOpt, region) @
	    decsToIdDefExpList (rest, region)
	  | decsToIdDefExpList (_::_, region) =
	    Error.error (region, "not admissible")
	  | decsToIdDefExpList (nil, _) = nil

	fun recToHoles ((idDef, exp)::rest, region, unallocated) =
	    let
		val toAllocate = getUsedVars (exp, unallocated)
		val decs =
		    case idDef of
			O.IdDef id =>
			    if IdSet.member (toAllocate, id)
			       orelse not (IdSet.member (unallocated, id))
			    then
				let
				    val id' = O.freshId {region = region}
				in
				    [O.ValDec (stm_info region, O.IdDef id',
					       exp),
				     O.ValDec (stm_info region, O.Wildcard,
					       O.PrimAppExp ({region = region},
							     "Hole.fill",
							     #[id, id']))]
				end
			    else
				(IdSet.delete (unallocated, id);
				 [O.ValDec (stm_info region, idDef, exp)])
		      | O.Wildcard => [O.ValDec (stm_info region, idDef, exp)]
	    in
		IdSet.fold
		(fn (id as O.Id (info, _, _), rest) =>
		 (IdSet.delete (unallocated, id);
		  O.ValDec (stm_info (#region info), O.IdDef id,
			    O.PrimAppExp (info, "Hole.hole", #[]))::rest))
		decs toAllocate
		::recToHoles (rest, region, unallocated)
	    end
	  | recToHoles (nil, _, unallocated) =
	    (Assert.assert (IdSet.isEmpty unallocated); nil)

	fun translateIf (info: exp_info, id, thenStms, elseStms, errStms) =
	    [O.TestStm (stm_info (#region info), id,
			O.TagTests #[(PervasiveType.lab_true, 1,
				      O.TupArgs #[], thenStms),
				     (PervasiveType.lab_false, 0,
				      O.TupArgs #[], elseStms)], errStms)]

	fun raisePrim (region, name) =
	    let
		val info = {region = region}
		val id = O.freshId info
	    in
		[O.ValDec (stm_info region, O.IdDef id,
			   O.PrimExp (info, name)),
		 O.RaiseStm (stm_info region, id)]
	    end

	fun translateCont (Decs (dec::decr, cont)) =
	    translateDec (dec, Decs (decr, cont))
	  | translateCont (Decs (nil, cont)) = translateCont cont
	  | translateCont (Goto stms) = stms
	  | translateCont (Share (r as ref NONE, cont)) =
	    let
		val stms = share (translateCont cont)
	    in
		r := SOME stms; stms
	    end
	  | translateCont (Share (ref (SOME stms), _)) = stms
	  | translateCont (EndTry (region, cont)) =
	    [O.EndTryStm (stm_info region, translateCont cont)]
	  | translateCont (EndHandle (region, cont)) =
	    [O.EndHandleStm (stm_info region, translateCont cont)]
	and translateDec (ValDec (info, VarPat (_, id as Id (_, _, name)),
				  NewExp info'), cont) =
	    O.ValDec (stm_info (#region info),
		      O.IdDef (translateId id),
		      O.NewExp (id_info info', name))::translateCont cont
	  | translateDec (ValDec (info, VarPat (_, id), exp), cont) =
	    let
		fun declare exp' =
		    O.ValDec (stm_info (#region info),
			      O.IdDef (translateId id), exp')
	    in
		translateExp (exp, declare, cont)
	    end
	  | translateDec (ValDec (info, pat, exp), cont) =
	    let
		val matches = #[(#region info, pat, translateCont cont)]
		val info = {region = #region info, typ = PervasiveType.typ_exn}
	    in
		simplifyCase (#region info, exp, matches,
			      PrimExp (info, "General.Bind"))
	    end
	  | translateDec (RecDec (info, decs), cont) =
	    let
		val (constraints, idExpList, aliases) =
		    SimplifyRec.derec (Vector.toList decs)
		val aliasDecs =
		    List.map (fn (fromId, toId, info) =>
			      O.ValDec (stm_info (#region info),
					O.IdDef (translateId fromId),
					O.VarExp (id_info info,
						  translateId toId))) aliases
		val subst =
		    List.map (fn (Id (_, stamp1, _), Id (_, stamp2, _), _) =>
			      (stamp1, stamp2)) aliases
		val decs' =
		    List.foldr
		    (fn ((id, exp), decs) =>
		     translateExp (substExp (exp, subst),
				   fn exp' =>
				   O.ValDec (stm_info
					     (*--** AR: needed to add this
					      * annotation due to strange
					      * bug appearing in build 3 :-( *)
					     (#region ((infoExp:
							I.exp -> I.exp_info)
						       exp)),
					     O.IdDef (translateId id), exp'),
				   Goto decs)) nil idExpList
		val idDefExpList' = decsToIdDefExpList (decs', #region info)
		val unallocated = IdSet.new ()
		val _ =
		    List.app (fn (idDef, _) =>
			      case idDef of
				  O.IdDef id => IdSet.insert (unallocated, id)
				| O.Wildcard => ()) idDefExpList'
		val rest =
		    List.concat (recToHoles (idDefExpList', #region info,
					     unallocated)) @
		    aliasDecs @ translateCont cont
		val errStms = share (raisePrim (#region info, "General.Bind"))
	    in
		List.foldr
		(fn ((longid1, longid2), rest) =>
		 let
		     val (stms1, id1, _) = translateLongid longid1
		     val (stms2, id2, _) = translateLongid longid2
		     val id1' = O.freshId {region = #region info}
		 in
		     stms1 @ stms2 @
		     O.ValDec (stm_info (#region info), O.IdDef id1',
			       O.ConExp ({region = #region info}, O.Con id1,
					 O.TupArgs #[]))::
		     [O.TestStm (stm_info (#region info), id1',
				 O.ConTests #[(O.Con id2, O.TupArgs #[],
					       rest)], errStms)]
		 end) rest constraints
	    end
	and unfoldTerm (VarExp (_, longid), cont) =
	    let
		val (stms, id, _) = translateLongid longid
	    in
		(stms @ translateCont cont, id)
	    end
	  | unfoldTerm (exp, cont) =
	    let
		val info = infoExp exp
		val id' = O.freshId (id_info info)
		fun declare exp' =
		    O.ValDec (stm_info (#region info), O.IdDef id', exp')
		val stms = translateExp (exp, declare, cont)
	    in
		(stms, id')
	    end
	and unfoldArgs (TupExp (_, exps), rest) =
	    let
		val (stms, ids) =
		    Vector.foldr (fn (exp, (stms, ids)) =>
				  let
				      val (stms', id) =
					  unfoldTerm (exp, Goto stms)
				  in
				      (stms', id::ids)
				  end) (rest, nil) exps
	    in
		(stms, O.TupArgs (Vector.fromList ids))
	    end
	  | unfoldArgs (ProdExp (_, expFlds), rest) =
	    let
		val (stms, labelIdList) =
		    Vector.foldr (fn (Fld (_, Lab (_, label), exp),
				      (stms, labelIdList)) =>
				  let
				      val (stms', id) =
					  unfoldTerm (exp, Goto stms)
				  in
				      (stms', (label, id)::labelIdList)
				  end) (rest, nil) expFlds
	    in
		case LabelSort.sort labelIdList of
		    (labelIdVec, LabelSort.Tup _) =>
			(stms, O.TupArgs (Vector.map #2 labelIdVec))
		  | (labelIdVec, LabelSort.Prod) =>
			(stms, O.ProdArgs labelIdVec)
	    end
	  | unfoldArgs (exp, rest) =
	    let
		val (stms, id) = unfoldTerm (exp, Goto rest)
	    in
		(stms, O.OneArg id)
	    end
	and unfoldStrict (info, exp, cont) =
	    let
		val (stms, id) = unfoldTerm (exp, cont)
	    in
		(O.PrimAppExp (id_info info, "Future.await", #[id]), stms)
	    end
	and translateExp (LitExp (info, lit), f, cont) =
	    f (O.LitExp (id_info info, translateLit lit))::translateCont cont
	  | translateExp (PrimExp (info, name), f, cont) =
	    f (O.PrimExp (id_info info, name))::translateCont cont
	  | translateExp (NewExp info, f, cont) =
	    f (O.NewExp (id_info info, Name.InId))::translateCont cont
	  | translateExp (VarExp (info, longid), f, cont) =
	    let
		val (stms, id, _) = translateLongid longid
	    in
		stms @ f (O.VarExp (id_info info, id))::translateCont cont
	    end
	  | translateExp (TagExp (info, Lab (_, label),
				  StrictExp (info', exp)),
			  f, cont) =
	    (case typToArity (#typ (infoExp exp)) of
		 Arity.Unary =>   (* explicitly force the argument *)
		     let
			 val r = ref NONE
			 val rest =
			     [O.IndirectStm (stm_info (#region info), r)]
			 val (exp', stms) =
			     unfoldStrict (info', exp, Goto rest)
			 val id = O.freshId (id_info info)
			 val stm =
			     O.ValDec (stm_info (#region info),
				       O.IdDef id, exp')
			 val (_, n) = labelToIndex (#typ info, label)
			 val exp'' =
			     O.TagExp (id_info info, label, n, O.OneArg id)
		     in
			 r := SOME (stm::f exp''::translateCont cont);
			 stms
		     end
	       | arity =>
		     let
			 val r = ref NONE
			 val rest =
			     [O.IndirectStm (stm_info (#region info), r)]
			 val (stms, args) = unfoldArgs (exp, rest)
			 val (_, n) = labelToIndex (#typ info, label)
			 val (stms', exp') =
			     tagExp (info, label, n, args, arity)
		     in
			 r := SOME (stms' @ f exp'::translateCont cont);
			 stms
		     end)
	  | translateExp (TagExp (info, Lab (_, label), exp), f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (stm_info (#region info), r)]
		val (stms, id) = unfoldTerm (exp, Goto rest)
		val (_, n) = labelToIndex (#typ info, label)
		val exp' = O.TagExp (id_info info, label, n, O.OneArg id)
	    in
		r := SOME (f exp'::translateCont cont);
		stms
	    end
	  | translateExp (ConExp (info, longid, StrictExp (info', exp)),
			  f, cont) =
	    (case typToArity (#typ (infoExp exp)) of
		 Arity.Unary =>   (* explicitly force the argument *)
		     let
			 val r = ref NONE
			 val rest =
			     [O.IndirectStm (stm_info (#region info), r)]
			 val (exp', stms2) =
			     unfoldStrict (info', exp, Goto rest)
			 val argId = O.freshId (id_info info)
			 val stm =
			     O.ValDec (stm_info (#region info),
				       O.IdDef argId, exp')
			 val (stms1, conId, _) = translateLongid longid
			 val exp'' =
			     O.ConExp (id_info info, O.Con conId,
				       O.OneArg argId)
		     in
			 r := SOME (stm::f exp''::translateCont cont);
			 stms1 @ stms2
		     end
	       | arity =>
		     let
			 val r = ref NONE
			 val rest =
			     [O.IndirectStm (stm_info (#region info), r)]
			 val (stms2, args) = unfoldArgs (exp, rest)
			 val (stms1, id1, _) = translateLongid longid
			 val (stms', exp') =
			     conExp (info, O.Con id1, args, arity)
		     in
			 r := SOME (stms' @ f exp'::translateCont cont);
			 stms1 @ stms2
		     end)
	  | translateExp (ConExp (info, longid, exp), f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (stm_info (#region info), r)]
		val (stms2, argId) = unfoldTerm (exp, Goto rest)
		val (stms1, conId, _) = translateLongid longid
		val exp' = O.ConExp (id_info info, O.Con conId, O.OneArg argId)
	    in
		r := SOME (f exp'::translateCont cont);
		stms1 @ stms2
	    end
	  | translateExp (RefExp (info, exp), f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (stm_info (#region info), r)]
		val (stms2, id) = unfoldTerm (exp, Goto rest)
	    in
		(r := SOME (f (O.RefExp (id_info info, id))::
			    translateCont cont);
		 stms2)
	    end
	  | translateExp (StrictExp (info, exp), f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (stm_info (#region info), r)]
		val (stms, id) = unfoldTerm (exp, Goto rest)
	    in
		(r := SOME (f (O.PrimAppExp (id_info info, "Future.await",
					     #[id]))::translateCont cont);
		 stms)
	    end
	  | translateExp (TupExp (info, exps), f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (stm_info (#region info), r)]
		val (stms, ids) =
		    Vector.foldr (fn (exp, (stms, ids)) =>
				  let
				      val (stms', id) =
					  unfoldTerm (exp, Goto stms)
				  in
				      (stms', id::ids)
				  end) (rest, nil) exps
	    in
		r := SOME (f (O.TupExp (id_info info, Vector.fromList ids))::
			   translateCont cont);
		stms
	    end
	  | translateExp (ProdExp (info, expFlds), f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (stm_info (#region info), r)]
		val (stms, fields) =
		    Vector.foldr (fn (Fld (_, Lab (_, label), exp),
				      (stms, fields)) =>
				  let
				      val (stms', id) =
					  unfoldTerm (exp, Goto stms)
				  in
				      (stms', (label, id)::fields)
				  end) (rest, nil) expFlds
		val exp' =
		    case LabelSort.sort fields of
			(fields', LabelSort.Tup _) =>
			    O.TupExp (id_info info, Vector.map #2 fields')
		      | (fields', LabelSort.Prod) =>
			    O.ProdExp (id_info info, fields')
	    in
		r := SOME (f exp'::translateCont cont); stms
	    end
	  | translateExp (SelExp (info, Lab (_, label), exp), f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (stm_info (#region info), r)]
		val (stms2, id2) = unfoldTerm (exp, Goto rest)
		val (prod, n) = labelToIndex (#typ (infoExp exp), label)
	    in
		(r := SOME (f (O.SelAppExp (id_info info, prod, label, n,
					    id2))::translateCont cont);
		 stms2)
	    end
	  | translateExp (VecExp (info, exps), f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (stm_info (#region info), r)]
		val (stms, ids) =
		    Vector.foldr (fn (exp, (stms, ids)) =>
				  let
				      val (stms', id) =
					  unfoldTerm (exp, Goto stms)
				  in
				      (stms', id::ids)
				  end) (rest, nil) exps
	    in
		r := SOME (f (O.VecExp (id_info info, (Vector.fromList ids)))::
			   translateCont cont);
		stms
	    end
	  | translateExp (FunExp (info, mats), f, cont) =
	    let
		val mats' =
		    Vector.map (fn Mat (info, pat, exp) =>
				let
				    val region = #region info
				    fun return exp' =
					O.ReturnStm (stm_info region, exp')
				in
				    (#region (infoExp exp), pat,
				     translateExp (exp, return, Goto nil))
				end) mats
		val region = #1 (Vector.sub (mats', 0))
		val errStms = raisePrim (region, "General.Match")
		val (args, graph, mapping, consequents) =
		    buildFunArgs (mats', errStms)
		val (body, _) = translateGraph (graph, mapping, #region info)
	    in
		checkReachability consequents;
		f (O.FunExp (id_info info, Stamp.new (), nil, args, body))::
		translateCont cont
	    end
	  | translateExp (AppExp (info, exp1, exp2), f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (stm_info (#region info), r)]
		val (stms2, args) = unfoldArgs (exp2, rest)
		val (stms1, id1) = unfoldTerm (exp1, Goto stms2)
	    in
		r := SOME (f (O.VarAppExp (id_info info, id1, args))::
			   translateCont cont);
		stms1
	    end
	  | translateExp (AndExp (info, exp1, exp2), f, cont) =
	    let
		val region = #region info
		val argTyp = Type.tuple #[]
		val strictTyp = Type.apply (PervasiveType.typ_strict, argTyp)
		val exp3 =
		    TagExp (info, Lab (id_info info, PervasiveType.lab_false),
			    StrictExp ({region = region, typ = strictTyp},
				       TupExp ({region = region, typ = argTyp},
					       #[])))
	    in
		translateExp (IfExp (info, exp1, exp2, exp3), f, cont)
	    end
	  | translateExp (OrExp (info, exp1, exp2), f, cont) =
	    let
		val region = #region info
		val argTyp = Type.tuple #[]
		val strictTyp = Type.apply (PervasiveType.typ_strict, argTyp)
		val exp3 =
		    TagExp (info, Lab (id_info info, PervasiveType.lab_true),
			    StrictExp ({region = region, typ = strictTyp},
				       TupExp ({region = region, typ = argTyp},
					       #[])))
	    in
		translateExp (IfExp (info, exp1, exp3, exp2), f, cont)
	    end
	  | translateExp (IfExp (_, exp1, exp2, exp3), f, cont) =
	    let
		val cont' = Share (ref NONE, cont)
		val stms2 = translateExp (exp2, f, cont')
		val stms3 = translateExp (exp3, f, cont')
	    in
		simplifyIf (exp1, stms2, stms3)
	    end
	  | translateExp (SeqExp (_, exp1, exp2), f, cont) =
	    let
		val stms2 = translateExp (exp2, f, cont)
	    in
		translateExp
		(exp1, fn exp' => O.ValDec (stm_info (#region (infoExp exp1)),
					    O.Wildcard, exp'),
		 Goto stms2)
	    end
	  | translateExp (CaseExp (info, exp, mats), f, cont) =
	    let
		val cont' = Share (ref NONE, cont)
		val matches' =
		    Vector.map (fn Mat (_, pat, exp) =>
				(#region (infoExp exp), pat,
				 translateExp (exp, f, cont'))) mats
		val info = {region = #region info, typ = PervasiveType.typ_exn}
	    in
		simplifyCase (#region info, exp, matches',
			      PrimExp (info, "General.Match"))
	    end
	  | translateExp (RaiseExp (info, exp), _, _) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (stm_info (#region info), r)]
		val (stms, id) = unfoldTerm (exp, Goto rest)
	    in
		r := SOME [O.RaiseStm (stm_info (#region info), id)]; stms
	    end
	  | translateExp (HandleExp (info, exp, mats), f, cont) =
	    let
		val info' = infoExp exp
		val id' = freshIntermediateId info'
		val contBody =
		    share (translateExp (VarExp (info', ShortId (info', id')),
					 f, cont))
		fun f' exp' =
		    O.ValDec (stm_info (#region info'),
			      O.IdDef (translateId id'), exp')
		val tryCont = EndTry (#region info, Goto contBody)
		val tryBody = translateExp (exp, f', tryCont)
		val exnInfo = {region = #region info,
			       typ = PervasiveType.typ_exn}
		val packageId = freshIntermediateId exnInfo
		val exnId = freshIntermediateId exnInfo
		val exnVarExp = VarExp (exnInfo, ShortId (exnInfo, exnId))
		val handleCont = EndHandle (#region info, Goto contBody)
		val matches' =
		    Vector.map (fn Mat (_, pat, exp) =>
				(#region (infoExp exp), pat,
				 translateExp (exp, f', handleCont))) mats
		val handleBody =
		    simplifyCase (#region info, exnVarExp, matches', exnVarExp)
	    in
		[O.TryStm (stm_info (#region info), tryBody,
			   O.IdDef (translateId packageId),
			   O.IdDef (translateId exnId), handleBody)]
	    end
	  | translateExp (FailExp info, f, cont) =
	    if !Switches.Language.silentFailExp then
		f (O.TupExp ({region = #region info}, #[]))::translateCont cont
	    else
		f (O.FailExp {region = #region info})::translateCont cont
	  | translateExp (LazyExp (_, exp as VarExp (_, _)), f, cont) =
	    translateExp (exp, f, cont)
	  | translateExp (LazyExp (info, AbsExp (_, exp)), f, cont) =
	    translateExp (LazyExp (info, exp), f, cont)
	  | translateExp (LazyExp (info, UnabsExp (_, exp)), f, cont) =
	    translateExp (LazyExp (info, exp), f, cont)
	  | translateExp (LazyExp (info as {region, typ}, exp), f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (stm_info region, r)]
		val funInfo = {region = region,
			       typ = Type.arrow (Type.tuple #[], typ)}
		val pat = JokPat {region = region, typ = Type.tuple #[]}
		val funExp =
		    FunExp (funInfo, #[Mat (id_info info, pat, exp)])
		val (stms, id) = unfoldTerm (funExp, Goto rest)
	    in
		(r := SOME (f (O.PrimAppExp (id_info info, "Future.byneed",
					     #[id]))::translateCont cont);
		 stms)
	    end
	  | translateExp (SpawnExp (_, exp as VarExp (_, _)), f, cont) =
	    translateExp (exp, f, cont)
	  | translateExp (SpawnExp (info, AbsExp (_, exp)), f, cont) =
	    translateExp (SpawnExp (info, exp), f, cont)
	  | translateExp (SpawnExp (info, UnabsExp (_, exp)), f, cont) =
	    translateExp (SpawnExp (info, exp), f, cont)
	  | translateExp (SpawnExp (info as {region, typ}, exp), f, cont) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (stm_info region, r)]
		val funInfo = {region = region,
			       typ = Type.arrow (Type.tuple #[], typ)}
		val pat = JokPat {region = region, typ = Type.tuple #[]}
		val funExp =
		    FunExp (funInfo, #[Mat (id_info info, pat, exp)])
		val (stms, id) = unfoldTerm (funExp, Goto rest)
	    in
		(r := SOME (f (O.PrimAppExp (id_info info, "Future.concur",
					     #[id]))::translateCont cont);
		 stms)
	    end
	  | translateExp (LetExp (_, decs, exp), f, cont) =
	    let
		val stms = translateExp (exp, f, cont)
	    in
		translateCont (Decs (Vector.toList decs, Goto stms))
	    end
	  | translateExp (AbsExp (_, exp), f, cont) =
	    translateExp (exp, f, cont)
	  | translateExp (UnabsExp (_, exp), f, cont) =
	    translateExp (exp, f, cont)
	and simplifyIf (AndExp (_, exp1, exp2), thenStms, elseStms) =
	    let
		val elseStms' = share elseStms
		val thenStms' = simplifyIf (exp2, thenStms, elseStms')
	    in
		simplifyIf (exp1, thenStms', elseStms')
	    end
	  | simplifyIf (OrExp (_, exp1, exp2), thenStms, elseStms) =
	    let
		val thenStms' = share thenStms
		val elseStms' = simplifyIf (exp2, thenStms', elseStms)
	    in
		simplifyIf (exp1, thenStms', elseStms')
	    end
	  | simplifyIf (exp, thenStms, elseStms) =
	    let
		val info = infoExp exp
		val r = ref NONE
		val rest = [O.IndirectStm (stm_info (#region info), r)]
		val (stms, id) = unfoldTerm (exp, Goto rest)
		val errStms = raisePrim (#region info, "General.Match")
		val stms1 = translateIf (info, id, thenStms, elseStms, errStms)
	    in
		r := SOME stms1; stms
	    end
	and checkReachability consequents =
	    List.app (fn (region, ref bodyOpt) =>
		      if isSome bodyOpt then ()
		      else Error.warn (region, "unreachable expression"))
	    consequents
	and simplifyCase (region, exp, matches, raiseExp) =
	    let
		val r = ref NONE
		val rest = [O.IndirectStm (stm_info region, r)]
		val (stms, id) = unfoldTerm (exp, Goto rest)
		val r' = ref NONE
		val rest' = [O.IndirectStm (stm_info region, r')]
		val (errStms, raiseId) = unfoldTerm (raiseExp, Goto rest')
		val (graph, consequents) = buildGraph (matches, errStms)
		val (body, _) = translateGraph (graph, [(nil, id)], region)
	    in
		r := SOME body;
		r' := SOME [O.RaiseStm (stm_info region, raiseId)];
		checkReachability consequents;
		stms
	    end
	and translateGraph (Node (pos, test, ref thenGraph, ref elseGraph,
				  status as ref (Cooked (_, _))),
			    mapping, region) =
	    let
		val (body, mapping') =
		    translateNode (pos, test, thenGraph, elseGraph,
				   mapping, region)
		val stms = share body
	    in
		status := Translated stms; (stms, mapping')
	    end
	  | translateGraph (Node (_, _, _, _, ref (Translated stms)),
			    mapping, _) =
	    (stms, mapping)
	  | translateGraph (Leaf (stms, stmsOptRef as ref NONE), mapping, _) =
	    let
		val stms' = share stms
	    in
		stmsOptRef := SOME stms'; (stms', mapping)
	    end
	  | translateGraph (Leaf (_, ref (SOME stms)), mapping, _) =
	    (stms, mapping)
	  | translateGraph (_, _, _) =
	    raise Crash.Crash "MkFlatteningPhase.translateGraph"
	and translateNode (pos, RefTest, thenGraph, _, mapping, region) =
	    let
		val (idDef, mapping') =
		    adjoin (LABEL (Label.fromString "ref")::pos, mapping)
		val id = lookup (pos, mapping)
		val (thenBody, mapping'') =
		    translateGraph (thenGraph, mapping', region)
	    in
		(O.RefDec (stm_info region, idDef, id)::thenBody, mapping'')
	    end
	  | translateNode (pos, TupTest n, thenGraph, _, mapping, region) =
	    let
		val (idDefs, mapping') = translateTupArgs (n, pos, mapping)
		val id = lookup (pos, mapping)
		val (thenBody, mapping'') =
		    translateGraph (thenGraph, mapping', region)
	    in
		(O.TupDec (stm_info region, idDefs, id)::thenBody,
		 mapping'')
	    end
	  | translateNode (pos, ProdTest labels, thenGraph, _,
			   mapping, region) =
	    let
		val (labelIdDefList, mapping') =
		    translateProdArgs (labels, pos, mapping)
		val id = lookup (pos, mapping)
		val (thenBody, mapping'') =
		    translateGraph (thenGraph, mapping', region)
	    in
		(O.ProdDec (stm_info region, labelIdDefList, id)::
		 thenBody, mapping'')
	    end
	  | translateNode (_, GuardTest (mapping0, exp),
			   thenGraph, elseGraph, mapping, region) =
	    let
		val info = infoExp exp
		val r = ref NONE
		val rest = [O.IndirectStm (stm_info (#region info), r)]
		val subst = mappingsToSubst (mapping0, mapping)
		val (stms, id) = unfoldTerm (substExp (exp, subst), Goto rest)
		val (thenStms, mapping') =
		    translateGraph (thenGraph, mapping, region)
		val (elseStms, mapping'') =
		    translateGraph (elseGraph, mapping', region)
		val errStms = raisePrim (#region info, "General.Match")
		val stms1 = translateIf (info, id, thenStms, elseStms, errStms)
	    in
		r := SOME stms1; (stms, mapping'')
	    end
	  | translateNode (_, DecTest (mapping0, decs),
			   thenGraph, _, mapping, region) =
	    let
		val (thenBody, mapping') =
		    translateGraph (thenGraph, mapping, region)
		val subst = mappingsToSubst (mapping0, mapping)
		val cont =
		    Decs (Vector.foldr (fn (dec, rest) =>
					substDec (dec, subst)::rest) nil decs,
			  Goto thenBody)
	    in
		(translateCont cont, mapping')
	    end
	  | translateNode (pos, LitTest lit, thenGraph, elseGraph,
			   mapping, region) =
	    let
		val id = lookup (pos, mapping)
		val (thenBody, mapping') =
		    translateGraph (thenGraph, mapping, region)
		val tests = O.LitTests #[(lit, thenBody)]
		val (elseBody, mapping'') =
		    translateGraph (elseGraph, mapping', region)
	    in
		([O.TestStm (stm_info region, id, tests, elseBody)],
		 mapping'')
	    end
	  | translateNode (pos, TagTest (label, n, args, arity),
			   thenGraph, elseGraph, mapping, region) =
	    let
		val id = lookup (pos, mapping)
		val (idDefArgs, mapping') =
		    translateArgs (args, LABEL label::pos, mapping)
		val (thenBody, mapping'') =
		    translateGraph (thenGraph, mapping', region)
		val tests = tagTest (label, n, idDefArgs, arity, thenBody)
		val (elseBody, mapping''') =
		    translateGraph (elseGraph, mapping'', region)
	    in
		([O.TestStm (stm_info region, id, tests, elseBody)],
		 mapping''')
	    end
	  | translateNode (pos, ConTest (longid, args, arity),
			   thenGraph, elseGraph, mapping, region) =
	    let
		val id = lookup (pos, mapping)
		val (stms, id', _) = translateLongid longid
		val (idDefArgs, mapping') =
		    translateArgs (args, longidToSelector longid::pos, mapping)
		val (thenBody, mapping'') =
		    translateGraph (thenGraph, mapping', region)
		val tests = conTest (O.Con id', idDefArgs, arity, thenBody)
		val (elseBody, mapping''') =
		    translateGraph (elseGraph, mapping'', region)
	    in
		(stms @ [O.TestStm (stm_info region, id, tests, elseBody)],
		 mapping''')
	    end
	  | translateNode (pos, VecTest n, thenGraph, elseGraph,
			   mapping, region) =
	    let
		val id = lookup (pos, mapping)
		val (idDefs, mapping') = translateTupArgs (n, pos, mapping)
		val (thenBody, mapping'') =
		    translateGraph (thenGraph, mapping', region)
		val tests = O.VecTests #[(idDefs, thenBody)]
		val (elseBody, mapping''') =
		    translateGraph (elseGraph, mapping'', region)
	    in
		([O.TestStm (stm_info region, id, tests, elseBody)],
		 mapping''')
	    end
	and translateArgs (O.OneArg _, pos, mapping) =
	    let
		val (idDef, mapping') = adjoin (pos, mapping)
	    in
		(O.OneArg idDef, mapping')
	    end
	  | translateArgs (O.TupArgs xs, pos, mapping) =
	    let
		val (idDefs, mapping') =
		    translateTupArgs (Vector.length xs, pos, mapping)
	    in
		(O.TupArgs idDefs, mapping')
	    end
	  | translateArgs (O.ProdArgs labelXVec, pos, mapping) =
	    let
		val (labelIdDefVec, mapping') =
		    translateProdArgs (Vector.map #1 labelXVec, pos, mapping)
	    in
		(O.ProdArgs labelIdDefVec, mapping')
	    end
	and translateTupArgs (n, pos, mapping) =
	    let
		val (idDefs, mapping) =
		    if n = 0 then (nil, mapping)
		    else translateTupArgs' (1, n, pos, mapping)
	    in
		(Vector.fromList idDefs, mapping)
	    end
	and translateTupArgs' (i, n, pos, mapping) =
	    let
		val (idDefs, mapping) =
		    if i = n then (nil, mapping)
		    else translateTupArgs' (i + 1, n, pos, mapping)
		val (idDef, mapping) =
		    adjoin (LABEL (Label.fromInt i)::pos, mapping)
	    in
		(idDef::idDefs, mapping)
	    end
	and translateProdArgs (labels, pos, mapping) =
	    let
		val (labelIdDefList, mapping) =
		    Vector.foldr
		    (fn (label, (labelIdDefList, mapping)) =>
		     let
			 val (idDef, mapping) =
			     adjoin (LABEL label::pos, mapping)
		     in
			 ((label, idDef)::labelIdDefList, mapping)
		     end) (nil, mapping) labels
	    in
		(Vector.fromList labelIdDefList, mapping)
	    end

	fun translate () (desc, (imports, decs, idFlds, sign)) =
	    let
		val imports' =
		    Vector.map (fn (id, sign, url) =>
				(O.IdDef (translateId id),
				 Signature.strip (loadSign (desc, url), sign),
				 url)) imports
		val labelIdList =
		    Vector.foldr (fn (Fld (_, Lab (_, label), id), rest) =>
				  (label, translateId id)::rest) nil idFlds
		val (exports', arity) = LabelSort.sort labelIdList
		val exportExp =
		    case arity of
			LabelSort.Tup _ =>
			    O.TupExp ({region = Source.nowhere},
				      Vector.map #2 exports')
		      | LabelSort.Prod =>
			    O.ProdExp ({region = Source.nowhere}, exports')
		val cont =
		    Goto [O.ExportStm (stm_info Source.nowhere, exportExp)]
		val body' = translateCont (Decs (Vector.toList decs, cont))
	    in
		(imports', body', exports', Signature.fromSig sign)
	    end
    end
