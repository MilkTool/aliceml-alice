(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999-2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

(*
 * This file implements liveness analysis.  Its effect is to annotate
 * all statements in a program with liveness information, i.e., the
 * associated kill-sets (see below).  It does so in two phases:  First
 * the use-sets of all statements are computed (and annotated) during
 * a backwards traversal of the code.  Then the kill-sets are - in a
 * forward traversal of the code - computed from the annotated use-set
 * and the def-set of each statement.  The def-set is not annotated,
 * it is computed as we go along.
 *
 * Definitions:
 *
 * The /use-set/ of a statement S is the set of all identifiers that may
 * be referenced on any path starting from and including S and that have
 * already been initialized on (all) paths to S.
 *
 * The /def-set/ of a statement S is the set of all identifiers that will
 * already have been initialized upon reaching S.
 *
 * The /kill-set/ of a statement S is the set of identifiers that will not
 * be referenced in any path starting from S, and that are not in the
 * kill-set of any statement on a path leading to S.
 *)

import structure PrettyPrint             from "../../lib/utility/PrettyPrint"
import structure Crash                   from "../infrastructure/Crash"
import signature SWITCHES                from "../infrastructure/SWITCHES-sig"
import signature CONTEXT                 from "../infrastructure/CONTEXT-sig"
import structure ComposePhases           from "../infrastructure/ComposePhases"
import structure MkTracingPhase
    from "../infrastructure/MkTracingPhase"
import structure MkResultDumpingPhase
    from "../infrastructure/MkResultDumpingPhase"
import structure MkContextDumpingPhase
    from "../infrastructure/MkContextDumpingPhase"
import structure EmptyContext            from "../infrastructure/EmptyContext"
import structure Stamp                   from "../common/Stamp"
import structure StampSet                from "../common/StampSet"
import signature FLAT_GRAMMAR            from "FLAT_GRAMMAR-sig"
import structure FlatGrammar             from "FlatGrammar"
import structure OutputFlatGrammar       from "OutputFlatGrammar"
import signature LIVENESS_ANALYSIS_PHASE from "LIVENESS_ANALYSIS_PHASE-sig"

structure LivenessAnalysisPhase1 :>
    LIVENESS_ANALYSIS_PHASE where type C.t = unit =
    struct
	structure C = EmptyContext
	structure I = FlatGrammar
	structure O = FlatGrammar

	open I

	(* Annotate `use' set at each statement *)

	datatype 'a lazyCopy =
	    Orig of 'a
	  | Copy of 'a

	fun lazyValOf (Orig x) = x
	  | lazyValOf (Copy x) = x

	fun processArgs (OneArg id, lset, f) = f (lset, id)
	  | processArgs (TupArgs ids, lset, f) =
	    Vector.foldl (fn (id, lset) => f (lset, id)) lset ids
	  | processArgs (ProdArgs labIdVec, lset, f) =
	    Vector.foldl (fn ((_, id), lset) => f (lset, id)) lset labIdVec

	fun delDef (lset as (Orig set), IdDef (Id (_, stamp, _))) =
	    if StampSet.member (set, stamp) then
		let
		    val set' = StampSet.clone set
		in
		    StampSet.delete (set', stamp);
		    Copy set'
		end
	    else lset
	  | delDef (lset as (Copy set), IdDef (Id (_, stamp, _))) =
	    (StampSet.delete (set, stamp); lset)
	  | delDef (lset, Wildcard) = lset

	fun delDefVec (lset, idDefs) =
	    Vector.foldl (fn (idDef, lset) => delDef (lset, idDef)) lset idDefs

	fun ins (lset as (Orig set), Id (_, stamp, _)) =
	    if StampSet.member (set, stamp) then lset
	    else
		let
		    val set' = StampSet.clone set
		in
		    StampSet.insert (set', stamp);
		    Copy set'
		end
	  | ins (lset as (Copy set), Id (_, stamp, _)) =
	    (StampSet.insert (set, stamp); lset)

	fun insVec (lset, ids) =
	    Vector.foldl (fn (id, lset) => ins (lset, id)) lset ids

	fun union (lset as (Copy set), lset') =
	    (StampSet.union (set, lazyValOf lset'); lset)
	  | union (lset', lset as (Copy set)) =
	    (StampSet.union (set, lazyValOf lset'); lset)
	  | union (Orig set, lset') =
	    union (Copy (StampSet.clone set), lset')

	fun setInfo ({liveness = ref (Use _), ...}: stm_info, _) =
	    raise Crash.Crash "LivenessAnalysisPhase1.setInfo"
	  | setInfo ({liveness, ...}: stm_info, lset) =
	    let
		val set = lazyValOf lset
	    in
		liveness := Use set; Orig set
	    end

	fun scanBody (ValDec (info, idDef, exp)::stms) =
	    setInfo (info, scanExp (exp, delDef (scanBody stms, idDef)))
	  | scanBody (RefDec (info, idDef, id)::stms) =
	    setInfo (info, ins (delDef (scanBody stms, idDef), id))
	  | scanBody (TupDec (info, idDefs, id)::stms) =
	    let
		val lset =
		    Vector.foldr (fn (idDef, lset) => delDef (lset, idDef))
		    (scanBody stms) idDefs
	    in
		setInfo (info, ins (lset, id))
	    end
	  | scanBody (ProdDec (info, labelIdDefVec, id)::stms) =
	    let
		val lset =
		    Vector.foldr
		    (fn ((_, idDef), lset) => delDef (lset, idDef))
		    (scanBody stms) labelIdDefVec
	    in
		setInfo (info, ins (lset, id))
	    end
	  | scanBody [RaiseStm (info, Id (_, stamp, _))] =
	    let
		val set = StampSet.new ()
		val _ = StampSet.insert (set, stamp)
	    in
		setInfo (info, Copy set)
	    end
	  | scanBody [ReraiseStm (info, Id (_, stamp, _))] =
	    let
		val set = StampSet.new ()
		val _ = StampSet.insert (set, stamp)
	    in
		setInfo (info, Copy set)
	    end
	  | scanBody [TryStm (info, tryBody, idDef1, idDef2, handleBody)] =
	    let
		val lset1 = scanBody tryBody
		val lset2 =
		    delDef (delDef (scanBody handleBody, idDef1), idDef2)
	    in
		setInfo (info, union (lset1, lset2))
	    end
	  | scanBody [EndTryStm (info, body)] =
	    setInfo (info, scanBody body)
	  | scanBody [EndHandleStm (info, body)] =
	    setInfo (info, scanBody body)
	  | scanBody [TestStm (info, id, tests, body)] =
	    setInfo (info, ins (union (scanTests tests, scanBody body), id))
	  | scanBody [SharedStm ({liveness = ref (Use set'), ...}, _, _)] =
	    Orig set'
	  | scanBody [SharedStm (info, body, _)] =
	    setInfo (info, scanBody body)
	  | scanBody [ReturnStm (info, exp)] =
	    setInfo (info, scanExp (exp, Copy (StampSet.new ())))
	  | scanBody [IndirectStm (info, ref bodyOpt)] =
	    setInfo (info, scanBody (valOf bodyOpt))
	  | scanBody [ExportStm (info, exp)] =
	    setInfo (info, scanExp (exp, Copy (StampSet.new ())))
	  | scanBody _ = raise Crash.Crash "LivenessAnalysisPhase1.scanStm"
	and scanTests (LitTests litBodyVec) =
	    (*--** this and the following folds can be improved *)
	    Vector.foldl (fn ((_, body), lset) => union (lset, scanBody body))
	    (Copy (StampSet.new ())) litBodyVec
	  | scanTests (TagTests tagBodyVec) =
	    Vector.foldl (fn ((_, _, args, body), lset) =>
			  let
			      val lset' = scanBody body
			      val lset' = processArgs (args, lset', delDef)
			  in
			      union (lset, lset')
			  end) (Copy (StampSet.new ())) tagBodyVec
	  | scanTests (ConTests conBodyVec) =
	    Vector.foldl (fn ((id, args, body), lset) =>
			  let
			      val lset' = scanBody body
			      val lset' = ins (lset', id)
			      val lset' = processArgs (args, lset', delDef)
			  in
			      union (lset, lset')
			  end) (Copy (StampSet.new ())) conBodyVec
	  | scanTests (VecTests vecBodyVec) =
	    Vector.foldl (fn ((idDefs, body), lset) =>
			  let
			      val lset' = scanBody body
			      val lset' = delDefVec (lset', idDefs)
			  in
			      union (lset, lset')
			  end) (Copy (StampSet.new ())) vecBodyVec
	and scanExp (LitExp (_, _), lset) = lset
	  | scanExp (PrimExp (_, _), lset) = lset
	  | scanExp (NewExp (_, _), lset) = lset
	  | scanExp (VarExp (_, id), lset) = ins (lset, id)
	  | scanExp (TagExp (_, _, _, args), lset) =
	    processArgs (args, lset, ins)
	  | scanExp (ConExp (_, id, args), lset) =
	    processArgs (args, ins (lset, id), ins)
	  | scanExp (RefExp (_, id), lset) = ins (lset, id)
	  | scanExp (TupExp (_, ids), lset) = insVec (lset, ids)
	  | scanExp (ProdExp (_, labIdVec), lset) =
	    Vector.foldl (fn ((_, id), lset) => ins (lset, id)) lset labIdVec
	  | scanExp (VecExp (_, ids), lset) = insVec (lset, ids)
	  | scanExp (FunExp (_, _, _, args, body), lset) =
	    processArgs (args, union (lset, scanBody body), delDef)
	  | scanExp (PrimAppExp (_, _, ids), lset) = insVec (lset, ids)
	  | scanExp (VarAppExp (_, id, args), lset) =
	    processArgs (args, ins (lset, id), ins)
	  | scanExp (SelAppExp (_, _, _, _, id), lset) = ins (lset, id)
	  | scanExp (LazySelAppExp (_, _, _, _, id), lset) = ins (lset, id)
	  | scanExp (FunAppExp (_, id, _, args), lset) =
	    processArgs (args, ins (lset, id), ins)
	  | scanExp (FailExp _, lset) = lset

	fun translate () (_, component as (_, body, _, _)) =
	    (scanBody body; component)
    end

structure LivenessAnalysisPhase2 :> LIVENESS_ANALYSIS_PHASE
    where type C.t = StampSet.t =
    struct
	structure C: CONTEXT = StampSet
	structure I = FlatGrammar
	structure O = FlatGrammar

	open I

	(* Annotate `kill' set at each statement *)

	fun processArgs (OneArg id, set, f) = f (set, id)
	  | processArgs (TupArgs ids, set, f) =
	    Vector.app (fn id => f (set, id)) ids
	  | processArgs (ProdArgs labIdVec, set, f) =
	    Vector.app (fn (_, id) => f (set, id)) labIdVec

	fun insDef (set, IdDef (Id (_, stamp, _))) =
	    StampSet.insert (set, stamp)
	  | insDef (set, Wildcard) = ()

	fun insDefVec (set, idDefs) =
	    Vector.app (fn idDef => insDef (set, idDef)) idDefs

	fun initStm (ValDec (_, idDef, exp), set) =
	    (insDef (set, idDef); initExp exp)
	  | initStm (RefDec (_, idDef, _), set) = insDef (set, idDef)
	  | initStm (TupDec (_, idDefs, _), set) =
	    Vector.app (fn idDef => insDef (set, idDef)) idDefs
	  | initStm (ProdDec (_, labelIdDefVec, _), set) =
	    Vector.app (fn (_, idDef) => insDef (set, idDef)) labelIdDefVec
	  | initStm (RaiseStm (_, _), _) = ()
	  | initStm (ReraiseStm (_, _), _) = ()
	  | initStm (TryStm (_, tryBody, idDef1, idDef2, handleBody), set) =
	    let
		val set' = StampSet.clone set
	    in
		initBody (tryBody, StampSet.clone set);
		insDef (set', idDef1); insDef (set', idDef2);
		initBody (handleBody, set')
	    end
	  | initStm (EndTryStm (_, body), set) = initBody (body, set)
	  | initStm (EndHandleStm (_, body), set) = initBody (body, set)
	  | initStm (TestStm (_, _, tests, body), set) =
	    (initTests (tests, set); initBody (body, set))
	  | initStm (SharedStm ({liveness = ref (Kill _), ...}, _, _), _) = ()
	  | initStm (SharedStm (_, body, _), set) = initBody (body, set)
	  | initStm (ReturnStm (_, exp), _) = initExp exp
	  | initStm (IndirectStm (_, ref bodyOpt), set) =
	    initBody (valOf bodyOpt, set)
	  | initStm (ExportStm (_, _), _) = ()
	and initTests (LitTests litBodyVec, set) =
	    Vector.app (fn (_, body) => initBody (body, StampSet.clone set))
	    litBodyVec
	  | initTests (TagTests tagBodyVec, set) =
	    Vector.app (fn (_, _, args, body) =>
			let
			    val set' = StampSet.clone set
			in
			    processArgs (args, set', insDef);
			    initBody (body, set')
			end) tagBodyVec
	  | initTests (ConTests conBodyVec, set) =
	    Vector.app (fn (_, args, body) =>
			let
			    val set' = StampSet.clone set
			in
			    processArgs (args, set', insDef);
			    initBody (body, set')
			end) conBodyVec
	  | initTests (VecTests vecBodyVec, set) =
	    Vector.app (fn (idDefs, body) =>
			let
			    val set' = StampSet.clone set
			in
			    insDefVec (set', idDefs);
			    initBody (body, set')
			end) vecBodyVec
	and initExp (FunExp (_, _, _, args, body)) =
	    let
		val set = StampSet.new ()
	    in
		processArgs (args, set, insDef); initBody (body, set)
	    end
	  | initExp _ = ()
	and initBody (stm::stms, defSet) =
	    (case #liveness (infoStm stm) of
		 ref Unknown =>
		     raise Crash.Crash "LivenessAnalysisPhase2.initBody"
	       | r as ref (Use useSet) =>
		     let
			 val killSet = StampSet.new ()
		     in
			 (* killSet = difference (defSet, useSet) *)
			 StampSet.app
			 (fn stamp =>
			  if StampSet.member (useSet, stamp) then ()
			  else StampSet.insert (killSet, stamp)) defSet;
			 StampSet.app
			 (fn stamp => StampSet.delete (defSet, stamp)) killSet;
			 initStm (stm, defSet);
			 r := Kill killSet;
			 initBody (stms, defSet)
		     end
	       | ref (Kill _) => ())
	  | initBody (nil, _) = ()

	fun translate defSet (_, component as (_, body, exportDesc, _)) =
	    (initBody (body, StampSet.clone defSet);
	     Vector.app (fn (_, Id (_, stamp, _)) =>
			 StampSet.insert (defSet, stamp)) exportDesc;
	     component)
    end

functor MkLivenessAnalysisPhase(Switches: SWITCHES) =
    let
	structure Phase1 =
	    MkTracingPhase(structure Phase = LivenessAnalysisPhase1
			   structure Switches = Switches
			   val name = "Liveness Analysis - Pass 1")
	structure Phase1 =
	    MkResultDumpingPhase(
		structure Phase = Phase1
		structure Switches = Switches
		val header = "Live Syntax with `use' sets"
		val pp = PrettyPrint.text o OutputFlatGrammar.componentToString
		val switch = Switches.Debug.dumpLivenessAnalysisIntermediate)

	structure Phase2 =
	    MkTracingPhase(structure Phase = LivenessAnalysisPhase2
			   structure Switches = Switches
			   val name = "Liveness Analysis - Pass 2")
	structure Phase2 =
	    MkContextDumpingPhase(
		structure Phase = Phase2
		structure Switches = Switches
		val header = "Set of defined stamps after liveness analysis"
		fun pp set =
		    let
			open PrettyPrint
			infix ^/^
		    in
			hbox (text "{" ^/^
			      fbox (below (StampSet.fold
					   (fn (stamp, rest) =>
					    text (Stamp.toString stamp) ^/^
					    rest) (text "}") set)))
		    end
		val switch = Switches.Debug.dumpLivenessAnalysisContext)
	structure Phase2 =
	    MkResultDumpingPhase(
		structure Phase = Phase2
		structure Switches = Switches
		val header = "Live Syntax with `kill' sets"
		val pp = PrettyPrint.text o OutputFlatGrammar.componentToString
		val switch = Switches.Debug.dumpLivenessAnalysisResult)
    in
	ComposePhases(structure Phase1 = Phase1
		      structure Phase2 = Phase2)
    end
