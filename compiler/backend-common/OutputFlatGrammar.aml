(*
 * Authors:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 1999-2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import
    structure Url
from "../../lib/utility/Url"

import
    structure Name
from "../../lib/rtt/Name"

import
    structure Label
from "../../lib/rtt/Label"

import
    structure Stamp
from "../common/Stamp"

import
    structure StampSet
from "../common/StampSet"

import
    signature FLAT_GRAMMAR
from "FLAT_GRAMMAR-sig"

import
    structure FlatGrammar
from "FlatGrammar"

import
    signature OUTPUT_FLAT_GRAMMAR
from "OUTPUT_FLAT_GRAMMAR-sig"

structure OutputFlatGrammar :> OUTPUT_FLAT_GRAMMAR =
    struct
	structure I = FlatGrammar

	open I

	datatype format =
	    SEQ of format vector
	  | S of string
	  | I of int
	  | IN
	  | EX
	  | NL
	  | ID of id
	  | IDDEF of idDef
	  | CO of string
	  | NULL
	  | SEP of format * format vector

	fun idToString (Id (_, stamp, Name.InId)) =
	    "$" ^ Stamp.toString stamp
	  | idToString (Id (_, stamp, Name.ExId s)) =
	    "$" ^ Stamp.toString stamp ^ "[" ^ s ^ "]"

	fun format f =
	    let
		val indent = ref 0
		val r = ref nil
		fun append s = r := s::(!r)
		fun format' (SEQ fs) = Vector.app format' fs
		  | format' (S s) = append s
		  | format' (I n) = append (Int.toString n)
		  | format' IN = indent := !indent + 1
		  | format' EX = indent := !indent - 1
		  | format' NL =
		    let
			val n = ref (!indent)
		    in
			append "\n";
			while !n > 4 do (append "\t"; n := !n - 4);
			while !n > 0 do (append "  "; n := !n - 1)
		    end
		  | format' (ID id) = append (idToString id)
		  | format' (IDDEF (IdDef id)) = append (idToString id)
		  | format' (IDDEF Wildcard) = append "_"
		  | format' (CO s) = (append "   (* "; append s; append " *)")
		  | format' NULL = ()
		  | format' (SEP (f, #[])) = ()
		  | format' (SEP (f, fs)) =
		    (format' (Vector.sub (fs, 0));
		     Vector.appi (fn (_, fi) => (format' f; format' fi))
		     (fs, 1, NONE))
	    in
		format' f; String.concat (List.rev (!r))
	    end

	fun visit (stamp, shared) =
	    not (StampSet.member (shared, stamp)) before
	    StampSet.insert (shared, stamp)

	fun insert (x, ys as (y::yr)) =
	    (case Stamp.compare (x, y) of
		 LESS => x::ys
	       | EQUAL => ys
	       | GREATER => y::insert (x, yr))
	  | insert (x, nil) = [x]

	val sort = StampSet.fold insert nil

	fun formatLiveness (ref Unknown) = NULL
	  | formatLiveness (ref (Use set)) =
	    SEQ #[S (List.foldl (fn (stamp, s) =>
				 s ^ " " ^ Stamp.toString stamp)
		     "(* use" (sort set)), S " *)", NL]
	  | formatLiveness (ref (Kill set)) =
	    SEQ #[S (List.foldl (fn (stamp, s) =>
				 s ^ " " ^ Stamp.toString stamp)
		     "(* kill" (sort set)), S " *)", NL]

	fun formatInfo ({liveness, ...}: stm_info) = formatLiveness liveness

	fun formatLit (WordLit w) = SEQ #[S "0w", S (LargeWord.toString w)]
	  | formatLit (IntLit i) = S (LargeInt.toString i)
	  | formatLit (CharLit c) =
	    SEQ #[S "#\"", S (WideChar.toString c), S "\""]
	  | formatLit (StringLit s) =
	    SEQ #[S "\"", S (String.toString s), S "\""]
	  | formatLit (RealLit r) = S (LargeReal.toString r)

	fun formatArgs formatX (OneArg x) = formatX x
	  | formatArgs formatX (TupArgs xs) =
	    SEQ #[S "(", SEP (S ", ", Vector.map formatX xs), S ")"]
	  | formatArgs formatX (ProdArgs labelXVector) =
	    SEQ #[S "{", SEP (S ", ",
			      Vector.map (fn (label, x) =>
					  SEQ #[S (Label.toString label),
						S "=", formatX x])
			      labelXVector), S "}"]

	fun formatStm (ValDec (_, idDef, exp), _) =
	    SEQ #[S "val ", IDDEF idDef, S " = ", IN, formatExp exp, EX]
	  | formatStm (RefAppDec (_, idDef, id'), _) =
	    SEQ #[S "val ref ", IDDEF idDef, S " = ", ID id']
	  | formatStm (TupDec (_, idDefs, id), _) =
	    SEQ #[S "val (", SEP (S ", ", Vector.map IDDEF idDefs),
		  S ") = ", ID id]
	  | formatStm (ProdDec (_, labelIdDefVector, id), _) =
	    SEQ #[S "val {",
		  SEP (S ", ",
		       Vector.map (fn (label, idDef) =>
				   SEQ #[S (Label.toString label), S "=",
					 IDDEF idDef]) labelIdDefVector),
		  S "} = ", ID id]
	  | formatStm (TryStm (_, tryBody, idDef1, idDef2, handleBody),
		       shared) =
	    let
		val handleFormat = formatBody (handleBody, shared)
	    in
		SEQ #[S "try", IN, NL, formatBody (tryBody, shared), EX, NL,
		      S "handle ", IDDEF idDef1, S ", ", IDDEF idDef2, IN, NL,
		      handleFormat]
	    end
	  | formatStm (EndTryStm (_, body), shared) =
	    SEQ #[S "(* end try *)", NL, formatBody (body, shared)]
	  | formatStm (EndHandleStm (_, body), shared) =
	    SEQ #[S "(* end handle *)", EX, NL, formatBody (body, shared)]
	  | formatStm (TestStm (_, id, tests, body), shared) =
	    SEQ #[S "case ", ID id, S " of", IN, NL,
		  formatTests (tests, shared),
		  S "else", IN, NL, formatBody (body, shared), EX, EX]
	  | formatStm (RaiseStm (_, id), _) = SEQ #[S "raise ", ID id]
	  | formatStm (ReraiseStm (_, id), _) = SEQ #[S "reraise ", ID id]
	  | formatStm (SharedStm (_, body, stamp), shared) =
	    if visit (stamp, shared) then
		SEQ #[S "label ", S (Stamp.toString stamp), S ":", NL,
		      formatBody (body, shared)]
	    else
		SEQ #[S "goto ", S (Stamp.toString stamp)]
	  | formatStm (ReturnStm (_, exp), _) =
	    SEQ #[S "return ", IN, formatExp exp, EX]
	  | formatStm (IndirectStm (_, ref NONE), _) =
	    S "indirect (* uninitialized *)"
	  | formatStm (IndirectStm (_, ref (SOME body)), shared) =
	    SEQ #[S "indirect", NL, formatBody (body, shared)]
	  | formatStm (ExportStm (_, exp), _) =
	    SEQ #[S "export ", IN, formatExp exp, EX]
	and formatTests (LitTests litBodyVector, shared) =
	    SEQ (Vector.map (fn (lit, body) =>
			     SEQ #[formatLit lit, S " =>", IN, NL,
				   formatBody (body, shared), EX, NL])
		 litBodyVector)
	  | formatTests (TagTests tagBodyVector, shared) =
	    SEQ (Vector.map (fn (label, n, conArgs, body) =>
			     SEQ #[case conArgs of
				       NONE =>
					   SEQ #[S "tag ",
						 S (Label.toString label),
						 S "/", I n]
				     | SOME args =>
					   SEQ #[S "(tag ",
						 S (Label.toString label),
						 S "/", I n, S ") ",
						 formatArgs IDDEF args],
				   S " =>", IN, NL,
				   formatBody (body, shared), EX, NL])
		 tagBodyVector)
	  | formatTests (ConTests conBodyVector, shared) =
	    SEQ (Vector.map (fn (con, conArgs, body) =>
			     SEQ #[case (con, conArgs) of
				       (Con id, NONE) =>
					   SEQ #[S "con ", ID id]
				     | (Con id, SOME args) =>
					   SEQ #[S "(con ", ID id, S ") ",
						 formatArgs IDDEF args]
				     | (StaticCon stamp, NONE) =>
					   SEQ #[S "con ",
						 S (Stamp.toString stamp)]
				     | (StaticCon stamp, SOME args) =>
					   SEQ #[S "(con ",
						 S (Stamp.toString stamp),
						 S ") ",
						 formatArgs IDDEF args],
				   S " =>", IN, NL,
				   formatBody (body, shared), EX, NL])
		 conBodyVector)
	  | formatTests (VecTests idDefsBodyVector, shared) =
	    SEQ (Vector.map (fn (idDefs, body) =>
			     SEQ #[S "#[",
				   SEP (S ", ", Vector.map IDDEF idDefs),
				   S "]", S " =>", IN, NL,
				   formatBody (body, shared), EX, NL])
		 idDefsBodyVector)
	and formatExp (LitExp (_, lit)) = formatLit lit
	  | formatExp (PrimExp (_, name)) = SEQ #[S "prim \"", S name, S "\""]
	  | formatExp (NewExp _) = S "new"
	  | formatExp (VarExp (_, id)) = ID id
	  | formatExp (TagExp (_, label, n)) =
	    SEQ #[S "tag ", S (Label.toString label), S "/", I n]
	  | formatExp (ConExp (_, con)) =
	    SEQ #[S "con ",
		  case con of
		      Con id => ID id
		    | StaticCon stamp => S (Stamp.toString stamp)]
	  | formatExp (TupExp (_, ids)) =
	    SEQ #[S "(", SEP (S ", ", Vector.map ID ids), S ")"]
	  | formatExp (ProdExp (_, labelIdVector)) =
	    SEQ #[S "{", SEP (S ", ",
			      Vector.map (fn (label, id) =>
					  SEQ #[S (Label.toString label),
						S "=", ID id]) labelIdVector),
		  S "}"]
	  | formatExp (VecExp (_, ids)) =
	    SEQ #[S "#[", SEP (S ", ", Vector.map ID ids), S "]"]
	  | formatExp (FunExp (_, _, _, args, body)) =
	    SEQ #[NL, S "fn ", formatArgs IDDEF args, S " =>",
		  IN, NL, formatBody (body, StampSet.new ()), EX]
	  | formatExp (PrimAppExp (_, name, ids)) =
	    SEQ #[S "prim \"", S name, S "\" (",
		  SEP (S ", ", Vector.map ID ids), S ")"]
	  | formatExp (VarAppExp (_, id, args)) =
	    SEQ #[ID id, S " ", formatArgs ID args]
	  | formatExp (TagAppExp (_, label, n, args)) =
	    SEQ #[S "(tag ", S (Label.toString label), S "/", I n, S ") ",
		  formatArgs ID args]
	  | formatExp (ConAppExp (_, con, args)) =
	    SEQ #[S "(con ",
		  case con of
		      Con id => ID id
		    | StaticCon stamp => S (Stamp.toString stamp), S ") ",
		  formatArgs ID args]
	  | formatExp (RefAppExp (_, id)) =
	    SEQ #[S "ref ", ID id]
	  | formatExp (SelAppExp (_, _, label, n, id)) =
	    SEQ #[S "#", S (Label.toString label), S "/", I n, S " ", ID id]
	  | formatExp (LazySelAppExp (_, _, label, n, id)) =
	    SEQ #[S "lazy#", S (Label.toString label),
		  S "/", I n, S " ", ID id]
	  | formatExp (FunAppExp (_, id, _, args)) =
	    SEQ #[S "funapp ", ID id, S " ", formatArgs ID args]
	  | formatExp (FailExp _) = S "fail"
	and formatBody (stms, shared) =
	    SEP (NL, Vector.fromList (List.map
				      (fn stm =>
				       SEQ #[formatInfo (infoStm stm),
					    formatStm (stm, shared)]) stms))

	fun bodyToString body =
	    format (SEQ #[formatBody (body, StampSet.new ()), NL])

	fun componentToString (importVector, body, _, _) =
	    format (SEQ #[SEQ (Vector.map
			       (fn (idDef, _, url) =>
				SEQ #[S "import ", IDDEF idDef,
				      S " from ", S (Url.toString url),
				      S "\n"]) importVector),
			  formatBody (body, StampSet.new ()), NL])
    end
