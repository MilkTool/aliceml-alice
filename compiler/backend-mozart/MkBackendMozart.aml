(*
 * Author:
 *   Leif Kornstaedt <kornstae@ps.uni-sb.de>
 *
 * Copyright:
 *   Leif Kornstaedt, 2000-2001
 *
 * Last change:
 *   $Date$ by $Author$
 *   $Revision$
 *)

import
    signature SWITCHES
from "../infrastructure/SWITCHES-sig"

import
    signature PHASE
from "../infrastructure/PHASE-sig"

import
    structure EmptyContext
from "../infrastructure/EmptyContext"

import
    signature SIGNATURE
from "../infrastructure/SIGNATURE-sig"

import
    structure MkTracingPhase
from "../infrastructure/MkTracingPhase"

import
    signature TARGET
from "../infrastructure/TARGET-sig"

import
    structure FlatGrammar
from "../backend-common/FlatGrammar"

import
    structure CodeGenPhase
from "CodeGenPhase"

functor MkMozartTarget(structure Switches: SWITCHES
		       structure Sig: SIGNATURE
			   where type t = FlatGrammar.sign): TARGET =
    struct
	structure C = EmptyContext
	structure Sig = Sig

	type t = CodeGenPhase.t

	val sign = CodeGenPhase.sign

	fun save () filename component =
	    CodeGenPhase.save (component, filename, !Switches.Debug.dumpTarget)

	fun apply () component = CodeGenPhase.apply component
    end

functor MkBackendMozart(structure Switches: SWITCHES
			structure MozartTarget: TARGET
			    where type t = CodeGenPhase.t): PHASE =
    MkTracingPhase(structure Phase =
		       struct
			   structure C = CodeGenPhase.C
			   structure I = FlatGrammar
			   structure O = MozartTarget

			   fun translate env (desc, component) =
			       CodeGenPhase.translate (env, desc, component)
		       end
		   structure Switches = Switches
		   val name = "Code Generation")
